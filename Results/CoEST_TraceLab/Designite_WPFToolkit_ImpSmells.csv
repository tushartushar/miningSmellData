Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnExecutedBeginEdit,The method has 135 lines of code.
Long Method,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnExecutedDelete,The method has 102 lines of code.
Long Method,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnSelectedCellsChanged,The method has 103 lines of code.
Long Method,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,MakeFullRowSelection,The method has 164 lines of code.
Long Method,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,MakeCellSelection,The method has 151 lines of code.
Long Method,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnArrowKeyDown,The method has 198 lines of code.
Long Method,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,DetermineRealizedColumnsBlockList,The method has 192 lines of code.
Long Method,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,IsChildInView,The method has 102 lines of code.
Long Method,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,ComputeStarColumnWidths,The method has 113 lines of code.
Long Method,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The method has 314 lines of code.
Long Method,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The method has 248 lines of code.
Long Method,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderClassic,The method has 125 lines of code.
Complex Method,Microsoft.Windows.Automation.Peers,CalendarAutomationPeer,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Automation\Peers\CalendarAutomationPeer.cs,GetSelection,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Windows.Controls,Calendar,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\Calendar.cs,ProcessSelection,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Windows.Controls,SelectedDatesCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\SelectedDatesCollection.cs,InsertItem,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,DoAutoScroll,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnExecutedBeginEdit,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnExecutedCommitEdit,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnExecutedCancelEdit,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnExecutedDelete,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnCurrentCellChanged,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnSelectedCellsChanged,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,UpdateIsSelected,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnArrowKeyDown,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnTabKeyDown,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,GetCellNearMouse,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnExecutedCopy,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,GetAnyCellOrColumnHeader,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,DetermineRealizedColumnsBlockList,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,EnsureFocusTrail,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,VirtualizeChildren,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,ArrangeOverride,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Windows.Controls,DataGridColumn,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumn.cs,OnWidthPropertyChanged,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,InitializeDisplayIndexMap,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,ComputeStarColumnWidths,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,Cyclomatic complexity of the method is 25
Complex Method,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderClassic,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Windows.Controls,DataGridHelper,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHelper.cs,EnsureTwoWayIfNotOneWay,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Windows.Controls,DataGridLengthConverter,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridLengthConverter.cs,ConvertFromString,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Windows.Controls,DataGridRow,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridRow.cs,NotifyPropertyChanged,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Windows.Controls,VirtualizedCellInfoCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\VirtualizedCellInfoCollection.cs,AddRegion,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Windows.Controls,VirtualizedCellInfoCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\VirtualizedCellInfoCollection.cs,OnMoveRow,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Windows.Controls,VirtualizedCellInfoCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\VirtualizedCellInfoCollection.cs,OnMoveColumn,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Windows.Controls,WeakHashtable,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\WeakHashtable.cs,ScavengeKeys,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Windows.Controls,DatePicker,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DatePicker\Microsoft\Windows\Controls\DatePicker.cs,OnApplyTemplate,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Windows.Controls.Primitives,CalendarItem,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\CalendarItem.cs,OnApplyTemplate,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Windows.Controls.Primitives,CalendarItem,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\CalendarItem.cs,PopulateGrids,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Windows.Controls.Primitives,DataGridCellsPresenter,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\Primitives\DataGridCellsPresenter.cs,SyncProperties,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Windows.Controls.Primitives,DataGridCellsPresenter,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\Primitives\DataGridCellsPresenter.cs,InvalidateCellsPanelOnColumnChange,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Windows.Controls.Primitives,DataGridColumnHeadersPresenter,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\Primitives\DataGridColumnHeadersPresenter.cs,FindDisplayIndexAndHeaderPosition,Cyclomatic complexity of the method is 12
Complex Method,System.Windows,VisualStateManager,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\VSM\VisualStateManager\System\Windows\VisualStateManager.cs,GetTransition,Cyclomatic complexity of the method is 10
Long Parameter List,Microsoft.Windows.Controls,ClipboardHelper,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\ClipboardHelper.cs,FormatCell,The method has 5 parameters. Parameters: cellValue' firstCell' lastCell' sb' format
Long Parameter List,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,SelectAndEditOnFocusMove,The method has 5 parameters. Parameters: e' oldCell' wasEditing' allowsExtendSelect' ignoreControlKey
Long Parameter List,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,CalculateCellDistance,The method has 6 parameters. Parameters: cell' rowOwner' itemsHost' itemsHostBounds' isMouseInCorner' distance
Long Parameter List,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,GenerateChild,The method has 6 parameters. Parameters: generator' constraint' column' generatorState' childIndex' childSize
Long Parameter List,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,GenerateChild,The method has 5 parameters. Parameters: generator' constraint' column' childIndex' childSize
Long Parameter List,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,InBlockOrNextBlock,The method has 5 parameters. Parameters: blockList' index' blockIndex' block' pastLastBlock
Long Parameter List,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,EnsureFocusTrail,The method has 5 parameters. Parameters: realizedColumnIndices' realizedColumnDisplayIndices' firstVisibleNonFrozenDisplayIndex' lastVisibleNonFrozenDisplayIndex' constraint
Long Parameter List,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,GenerateChildForFocusTrail,The method has 6 parameters. Parameters: generator' realizedColumnIndices' realizedColumnDisplayIndices' constraint' displayIndex' displayIndexListIterator
Long Parameter List,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,AddToIndicesListIfNeeded,The method has 5 parameters. Parameters: realizedColumnIndices' realizedColumnDisplayIndices' columnIndex' displayIndex' displayIndexListIterator
Long Parameter List,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,ReallocateStarValuesForPositiveResize,The method has 6 parameters. Parameters: startIndex' horizontalChange' perStarExcessRatio' totalStarFactors' perStarWidth' retainAuto
Long Parameter List,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,ReallocateStarValuesForNegativeResize,The method has 6 parameters. Parameters: startIndex' horizontalChange' perStarLagRatio' totalStarFactors' perStarWidth' retainAuto
Long Parameter List,Microsoft.Windows.Controls,DataGridHelper,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHelper.cs,GetCoercedTransferPropertyValue,The method has 5 parameters. Parameters: baseObject' baseValue' baseProperty' parentObject' parentProperty
Long Parameter List,Microsoft.Windows.Controls,DataGridHelper,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHelper.cs,GetCoercedTransferPropertyValue,The method has 7 parameters. Parameters: baseObject' baseValue' baseProperty' parentObject' parentProperty' grandParentObject' grandParentProperty
Long Parameter List,Microsoft.Windows.Controls,DataGridRowClipboardEventArgs,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridRowClipboardEventArgs.cs,DataGridRowClipboardEventArgs,The method has 5 parameters. Parameters: item' startColumnDisplayIndex' endColumnDisplayIndex' isColumnHeadersRow' rowIndexHint
Long Parameter List,Microsoft.Windows.Controls,VirtualizedCellInfoCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\VirtualizedCellInfoCollection.cs,AddRegion,The method has 5 parameters. Parameters: rowIndex' columnIndex' rowCount' columnCount' notify
Long Parameter List,Microsoft.Windows.Controls,VirtualizedCellInfoCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\VirtualizedCellInfoCollection.cs,RemoveRegion,The method has 5 parameters. Parameters: rowIndex' columnIndex' rowCount' columnCount' removeList
Long Parameter List,Microsoft.Windows.Controls,VirtualizedCellInfoCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\VirtualizedCellInfoCollection.cs,OnColumnsChanged,The method has 5 parameters. Parameters: action' oldDisplayIndex' oldColumn' newDisplayIndex' selectedRows
Long Parameter List,Microsoft.Windows.Controls.Primitives,DataGridColumnHeadersPresenter,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\Primitives\DataGridColumnHeadersPresenter.cs,FindDisplayIndexAndHeaderPosition,The method has 5 parameters. Parameters: startPos' findNearestColumn' displayIndex' headerPos' header
Long Parameter List,System.Windows,VisualStateManager,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\VSM\VisualStateManager\System\Windows\VisualStateManager.cs,GoToStateCore,The method has 6 parameters. Parameters: control' templateRoot' stateName' group' state' useTransitions
Long Parameter List,System.Windows,VisualStateManager,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\VSM\VisualStateManager\System\Windows\VisualStateManager.cs,GoToStateInternal,The method has 5 parameters. Parameters: control' element' group' state' useTransitions
Long Identifier,Microsoft.Windows.Automation.Peers,DataGridCellItemAutomationPeer,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Automation\Peers\DataGridCellItemAutomationPeer.cs,GetColumnHeaderItems,The length of the parameter dataGridColumnHeadersPresenter is 30.
Long Identifier,Microsoft.Windows.Automation.Peers,DataGridAutomationPeer,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Automation\Peers\DataGridAutomationPeer.cs,GetColumnHeaders,The length of the parameter dataGridColumnHeadersPresenter is 30.
Long Identifier,Microsoft.Windows.Automation.Peers,DataGridRowAutomationPeer,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Automation\Peers\DataGridRowAutomationPeer.cs,GetChildrenCore,The length of the parameter dataGridRowHeaderAutomationPeer is 31.
Long Identifier,Microsoft.Windows.Automation.Peers,DataGridRowAutomationPeer,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Automation\Peers\DataGridRowAutomationPeer.cs,GetChildrenCore,The length of the parameter dataGridDetailsPresenterAutomationPeer is 38.
Long Identifier,Microsoft.Windows.Controls,Calendar,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\Calendar.cs,,The length of the parameter CalendarDayButtonStyleProperty is 30.
Long Identifier,Microsoft.Windows.Controls,BooleanToSelectiveScrollingOrientationConverter,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\BooleanToSelectiveScrollingOrientationConverter.cs,Convert,The length of the parameter parameterSelectiveScrollingOrientation is 38.
Long Identifier,Microsoft.Windows.Controls,ClipboardHelper,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\ClipboardHelper.cs,,The length of the parameter DATAGRIDVIEW_htmlStartFragment is 30.
Long Identifier,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,RemoveGroupingSortDescriptions,The length of the parameter originalIgnoreSortDescriptionChanges is 36.
Long Identifier,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,AddGroupingSortDescriptions,The length of the parameter originalIgnoreSortDescriptionChanges is 36.
Long Identifier,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,ClearSortDescriptionsOnItemsSourceChange,The length of the parameter groupingSortDescriptionIndices is 30.
Long Identifier,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnExecutedCopy,The length of the parameter preparingRowClipboardContentEventArgs is 37.
Long Identifier,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnExecutedCopy,The length of the parameter preparingRowClipboardContentEventArgs is 37.
Long Identifier,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,,The length of the parameter HorizontalGridLinesBrushProperty is 32.
Long Identifier,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,,The length of the parameter VerticalGridLinesBrushProperty is 30.
Long Identifier,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,,The length of the parameter RowValidationErrorTemplateProperty is 34.
Long Identifier,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,,The length of the parameter AlternatingRowBackgroundProperty is 32.
Long Identifier,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,,The length of the parameter RowHeaderActualWidthPropertyKey is 31.
Long Identifier,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,,The length of the parameter RowHeaderTemplateSelectorProperty is 33.
Long Identifier,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,,The length of the parameter HorizontalScrollBarVisibilityProperty is 37.
Long Identifier,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,,The length of the parameter VerticalScrollBarVisibilityProperty is 35.
Long Identifier,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,,The length of the parameter HorizontalScrollOffsetProperty is 30.
Long Identifier,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,,The length of the parameter RowDetailsVisibilityModeProperty is 32.
Long Identifier,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,,The length of the parameter RowDetailsTemplateSelectorProperty is 34.
Long Identifier,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,,The length of the parameter NonFrozenColumnsViewportHorizontalOffsetPropertyKey is 51.
Long Identifier,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,,The length of the parameter NonFrozenColumnsViewportHorizontalOffsetProperty is 48.
Long Identifier,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,,The length of the parameter EnableRowVirtualizationProperty is 31.
Long Identifier,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,,The length of the parameter EnableColumnVirtualizationProperty is 34.
Long Identifier,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,,The length of the parameter DropLocationIndicatorStyleProperty is 34.
Long Identifier,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,,The length of the parameter CellsPanelHorizontalOffsetPropertyKey is 37.
Long Identifier,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,,The length of the parameter CellsPanelHorizontalOffsetProperty is 34.
Long Identifier,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,,The length of the parameter _internalScrollContentPresenter is 31.
Long Identifier,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,,The length of the parameter _groupingSortDescriptionIndices is 31.
Long Identifier,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,,The length of the parameter _viewportWidthChangeNotificationPending is 39.
Long Identifier,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,DetermineRealizedColumnsBlockList,The length of the parameter firstVisibleNonFrozenDisplayIndex is 33.
Long Identifier,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,DetermineRealizedColumnsBlockList,The length of the parameter lastVisibleNonFrozenDisplayIndex is 32.
Long Identifier,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,EnsureFocusTrail,The length of the parameter firstVisibleNonFrozenDisplayIndex is 33.
Long Identifier,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,EnsureFocusTrail,The length of the parameter lastVisibleNonFrozenDisplayIndex is 32.
Long Identifier,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,,The length of the parameter _clippedChildForFrozenBehaviour is 31.
Long Identifier,Microsoft.Windows.Controls,DataGridColumn,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumn.cs,,The length of the parameter HeaderTemplateSelectorProperty is 30.
Long Identifier,Microsoft.Windows.Controls,DataGridColumn,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumn.cs,,The length of the parameter _ignoreRedistributionOnWidthChange is 34.
Long Identifier,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,InvalidateColumnRealization,The length of the parameter invalidateForNonVirtualizedRows is 31.
Long Identifier,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,,The length of the parameter _columnWidthsComputationPending is 31.
Long Identifier,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,,The length of the parameter _realizedColumnsBlockListForNonVirtualizedRows is 46.
Long Identifier,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,,The length of the parameter _realizedColumnsBlockListForVirtualizedRows is 43.
Long Identifier,Microsoft.Windows.Controls,DataGridHeadersVisibilityToVisibilityConverter,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeadersVisibilityToVisibilityConverter.cs,Convert,The length of the parameter valueAsDataGridHeadersVisibility is 32.
Long Identifier,Microsoft.Windows.Controls,DataGridHeadersVisibilityToVisibilityConverter,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeadersVisibilityToVisibilityConverter.cs,Convert,The length of the parameter parameterAsDataGridHeadersVisibility is 36.
Long Identifier,Microsoft.Windows.Controls,DataGridHelper,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHelper.cs,GetPropertyTransferEnabledMapForObject,The length of the parameter propertyTransferEnabledForObject is 32.
Long Identifier,Microsoft.Windows.Controls,DataGridHelper,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHelper.cs,IsPropertyTransferEnabled,The length of the parameter propertyTransferEnabledForObject is 32.
Long Identifier,Microsoft.Windows.Controls,DataGridRow,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridRow.cs,,The length of the parameter HeaderTemplateSelectorProperty is 30.
Long Identifier,Microsoft.Windows.Controls,DataGridRow,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridRow.cs,,The length of the parameter ValidationErrorTemplateProperty is 31.
Long Identifier,Microsoft.Windows.Controls,DataGridRow,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridRow.cs,,The length of the parameter DetailsTemplateSelectorProperty is 31.
Long Identifier,Microsoft.Windows.Controls,DataGridTemplateColumn,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridTemplateColumn.cs,,The length of the parameter CellEditingTemplateSelectorProperty is 35.
Long Identifier,Microsoft.Windows.Controls,TypeHandlerFactory<TypeHandler>,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\VSM\VisualStateManager\Microsoft\Windows\Controls\TypeHandlerFactory.cs,DetermineBestHandler,The length of the parameter bestIntefaceImplementationType is 30.
Long Identifier,Microsoft.Windows.Controls,VisualStateBehavior,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\VSM\VisualStateManager\Microsoft\Windows\Controls\VisualStateBehavior.cs,,The length of the parameter IsVisualStateBehaviorAttachedProperty is 37.
Long Identifier,Microsoft.Windows.Controls.Primitives,DataGridColumnHeader,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\Primitives\DataGridColumnHeader.cs,,The length of the parameter RightHeaderGripperTemplateName is 30.
Long Identifier,Microsoft.Windows.Controls.Primitives,DataGridColumnHeadersPresenter,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\Primitives\DataGridColumnHeadersPresenter.cs,FindDisplayIndexAndHeaderPosition,The length of the parameter firstVisibleNonFrozenColumnHandled is 34.
Long Identifier,Microsoft.Windows.Controls.Primitives,DataGridColumnHeadersPresenter,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\Primitives\DataGridColumnHeadersPresenter.cs,,The length of the parameter _columnHeaderDragStartPosition is 30.
Long Identifier,Microsoft.Windows.Controls.Primitives,DataGridColumnHeadersPresenter,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\Primitives\DataGridColumnHeadersPresenter.cs,,The length of the parameter _columnHeaderDragStartRelativePosition is 38.
Long Identifier,Microsoft.Windows.Controls.Primitives,DataGridColumnHeadersPresenter,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\Primitives\DataGridColumnHeadersPresenter.cs,,The length of the parameter _columnHeaderDragCurrentPosition is 32.
Long Identifier,Microsoft.Windows.Controls.Primitives,DataGridColumnHeadersPresenter,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\Primitives\DataGridColumnHeadersPresenter.cs,,The length of the parameter _columnHeaderDropLocationIndicator is 34.
Long Identifier,Microsoft.Windows.Controls.Primitives,DataGridRowHeader,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\Primitives\DataGridRowHeader.cs,,The length of the parameter BottomHeaderGripperTemplateName is 31.
Long Identifier,Microsoft.Windows.Controls.Primitives,SelectiveScrollingGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\Primitives\SelectiveScrollingGrid.cs,,The length of the parameter SelectiveScrollingOrientationProperty is 37.
Long Identifier,System.Windows,VisualStateManager,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\VSM\VisualStateManager\System\Windows\VisualStateManager.cs,,The length of the parameter CustomVisualStateManagerProperty is 32.
Long Statement,Microsoft.Windows.Automation.Peers,CalendarAutomationPeer,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Automation\Peers\CalendarAutomationPeer.cs,RaiseSelectionEvents,The length of the statement  "            if (AutomationPeer.ListenerExists(AutomationEvents.SelectionItemPatternOnElementSelected) && numSelected == 1 && numAdded == 1) " is 127.
Long Statement,Microsoft.Windows.Automation.Peers,CalendarAutomationPeer,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Automation\Peers\CalendarAutomationPeer.cs,GetItem,The length of the statement  "            if (this.OwningGrid != null && row >= 0 && row < this.OwningGrid.RowDefinitions.Count && column >= 0 && column < this.OwningGrid.ColumnDefinitions.Count) " is 153.
Long Statement,Microsoft.Windows.Automation.Peers,CalendarAutomationPeer,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Automation\Peers\CalendarAutomationPeer.cs,GetSelection,The length of the statement  "                if (this.OwningCalendar.DisplayMode == CalendarMode.Month && this.OwningCalendar.SelectedDates != null && this.OwningCalendar.SelectedDates.Count != 0) " is 151.
Long Statement,Microsoft.Windows.Automation.Peers,CalendarButtonAutomationPeer,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Automation\Peers\CalendarButtonAutomationPeer.cs,GetHelpTextCore,The length of the statement  "            return date.HasValue ? DateTimeHelper.ToLongDateString(date' DateTimeHelper.GetCulture(this.OwningCalendarButton)) : base.GetHelpTextCore(); " is 140.
Long Statement,Microsoft.Windows.Automation.Peers,CalendarDayButtonAutomationPeer,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Automation\Peers\CalendarDayButtonAutomationPeer.cs,GetHelpTextCore,The length of the statement  "                    return string.Format(DateTimeHelper.GetCurrentDateFormat()' SR.Get(SRID.CalendarAutomationPeer_BlackoutDayHelpText)' dateString); " is 129.
Long Statement,Microsoft.Windows.Automation.Peers,CalendarDayButtonAutomationPeer,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Automation\Peers\CalendarDayButtonAutomationPeer.cs,GetNameCore,The length of the statement  "            return date.HasValue ? DateTimeHelper.ToLongDateString(Date' DateTimeHelper.GetCulture(this.OwningCalendarDayButton)) : base.GetNameCore(); " is 139.
Long Statement,Microsoft.Windows.Automation.Peers,DataGridCellItemAutomationPeer,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Automation\Peers\DataGridCellItemAutomationPeer.cs,GetLocalizedControlTypeCore,The length of the statement  "            return (this.OwningCellPeer != null) ? this.OwningCellPeer.GetLocalizedControlType() : base.GetLocalizedControlTypeCore(); " is 122.
Long Statement,Microsoft.Windows.Automation.Peers,DataGridCellItemAutomationPeer,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Automation\Peers\DataGridCellItemAutomationPeer.cs,GetColumnHeaderItems,The length of the statement  "                DataGridColumnHeader dataGridColumnHeader = dataGridColumnHeadersPresenter.ItemContainerGenerator.ContainerFromIndex(this.OwningDataGrid.Columns.IndexOf(_column)) as DataGridColumnHeader; " is 187.
Long Statement,Microsoft.Windows.Automation.Peers,DataGridCellItemAutomationPeer,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Automation\Peers\DataGridCellItemAutomationPeer.cs,GetRowHeaderItems,The length of the statement  "                DataGridAutomationPeer dataGridAutomationPeer = UIElementAutomationPeer.CreatePeerForElement(this.OwningDataGrid) as DataGridAutomationPeer; " is 140.
Long Statement,Microsoft.Windows.Automation.Peers,DataGridAutomationPeer,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Automation\Peers\DataGridAutomationPeer.cs,GetChildrenCore,The length of the statement  "                AutomationPeer columnsHeaderPresenterPeer = FrameworkElementAutomationPeer.CreatePeerForElement(columnsHeaderPresenter); " is 120.
Long Statement,Microsoft.Windows.Automation.Peers,DataGridAutomationPeer,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Automation\Peers\DataGridAutomationPeer.cs,GetColumnHeaders,The length of the statement  "                    DataGridColumnHeader dataGridColumnHeader = dataGridColumnHeadersPresenter.ItemContainerGenerator.ContainerFromIndex(i) as DataGridColumnHeader; " is 144.
Long Statement,Microsoft.Windows.Automation.Peers,DataGridAutomationPeer,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Automation\Peers\DataGridAutomationPeer.cs,GetItemPeers,The length of the statement  "            Dictionary<object' DataGridItemAutomationPeer> oldChildren = new Dictionary<object' DataGridItemAutomationPeer>(_itemPeers); " is 124.
Long Statement,Microsoft.Windows.Automation.Peers,DataGridAutomationPeer,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Automation\Peers\DataGridAutomationPeer.cs,CalculateVisibleBoundingRect,The length of the statement  "                    // Safer version of transform to descendent (doing the inverse ourself and saves us changing the co-ordinate space of the owner's bounding rectangle)'  " is 150.
Long Statement,Microsoft.Windows.Automation.Peers,DataGridCellAutomationPeer,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Automation\Peers\DataGridCellAutomationPeer.cs,IsOffscreenCore,The length of the statement  "            return DoubleUtil.AreClose(boundingRect' Rect.Empty) || DoubleUtil.AreClose(boundingRect.Height' 0.0) || DoubleUtil.AreClose(boundingRect.Width' 0.0); " is 150.
Long Statement,Microsoft.Windows.Automation.Peers,DataGridColumnHeaderAutomationPeer,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Automation\Peers\DataGridColumnHeaderAutomationPeer.cs,IsOffscreenCore,The length of the statement  "            return DoubleUtil.AreClose(boundingRect' Rect.Empty) || DoubleUtil.AreClose(boundingRect.Height' 0.0) || DoubleUtil.AreClose(boundingRect.Width' 0.0); " is 150.
Long Statement,Microsoft.Windows.Automation.Peers,DataGridItemAutomationPeer,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Automation\Peers\DataGridItemAutomationPeer.cs,GetLocalizedControlTypeCore,The length of the statement  "            return (this.OwningRowPeer != null) ? this.OwningRowPeer.GetLocalizedControlType() : base.GetLocalizedControlTypeCore(); " is 120.
Long Statement,Microsoft.Windows.Automation.Peers,DataGridItemAutomationPeer,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Automation\Peers\DataGridItemAutomationPeer.cs,GetCellItemPeers,The length of the statement  "            Dictionary<DataGridColumn' DataGridCellItemAutomationPeer> oldChildren = new Dictionary<DataGridColumn' DataGridCellItemAutomationPeer>(_itemPeers); " is 148.
Long Statement,Microsoft.Windows.Automation.Peers,DataGridRowAutomationPeer,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Automation\Peers\DataGridRowAutomationPeer.cs,IsOffscreenCore,The length of the statement  "            return DoubleUtil.AreClose(boundingRect' Rect.Empty) || DoubleUtil.AreClose(boundingRect.Height' 0.0) || DoubleUtil.AreClose(boundingRect.Width' 0.0); " is 150.
Long Statement,Microsoft.Windows.Automation.Peers,DataGridRowHeaderAutomationPeer,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Automation\Peers\DataGridRowHeaderAutomationPeer.cs,IsOffscreenCore,The length of the statement  "            return DoubleUtil.AreClose(boundingRect' Rect.Empty) || DoubleUtil.AreClose(boundingRect.Height' 0.0) || DoubleUtil.AreClose(boundingRect.Width' 0.0); " is 150.
Long Statement,Microsoft.Windows.Controls,Calendar,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\Calendar.cs,OnLanguageChanged,The length of the statement  "            if (DependencyPropertyHelper.GetValueSource(d' Calendar.FirstDayOfWeekProperty).BaseValueSource == BaseValueSource.Default) " is 123.
Long Statement,Microsoft.Windows.Controls,Calendar,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\Calendar.cs,IsValidKeyboardSelection,The length of the statement  "                    return DateTime.Compare((DateTime)value' cal.DisplayDateStartInternal) >= 0 && DateTime.Compare((DateTime)value' cal.DisplayDateEndInternal) <= 0; " is 146.
Long Statement,Microsoft.Windows.Controls,Calendar,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\Calendar.cs,ProcessCalendarKey,The length of the statement  "                // If a blackout day is inactive' when clicked on it' the previous inactive day which is not a blackout day can get the focus. " is 126.
Long Statement,Microsoft.Windows.Controls,Calendar,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\Calendar.cs,ProcessCalendarKey,The length of the statement  "                CalendarDayButton currentDayButton = (MonthControl != null) ? MonthControl.GetCalendarDayButton(this.CurrentDate) : null; " is 121.
Long Statement,Microsoft.Windows.Controls,Calendar,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\Calendar.cs,ProcessCalendarKey,The length of the statement  "                if (DateTimeHelper.CompareYearMonth(this.CurrentDate' this.DisplayDateInternal) != 0 && currentDayButton != null && !currentDayButton.IsInactive) " is 145.
Long Statement,Microsoft.Windows.Controls,Calendar,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\Calendar.cs,ProcessLeftKey,The length of the statement  "                    DateTime? selectedDate = this._blackoutDates.GetNonBlackoutDate(DateTimeHelper.AddDays(this.CurrentDate' moveAmmount)' moveAmmount); " is 132.
Long Statement,Microsoft.Windows.Controls,Calendar,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\Calendar.cs,ProcessRightKey,The length of the statement  "                    DateTime? selectedDate = this._blackoutDates.GetNonBlackoutDate(DateTimeHelper.AddDays(this.CurrentDate' moveAmmount)' moveAmmount); " is 132.
Long Statement,Microsoft.Windows.Controls,Calendar,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\Calendar.cs,ProcessSelection,The length of the statement  "                if (this.SelectionMode == CalendarSelectionMode.SingleRange || this.SelectionMode == CalendarSelectionMode.MultipleRange) " is 121.
Long Statement,Microsoft.Windows.Controls,Calendar,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\Calendar.cs,ProcessShiftKeyUp,The length of the statement  "            if (this._isShiftPressed && (this.SelectionMode == CalendarSelectionMode.SingleRange || this.SelectionMode == CalendarSelectionMode.MultipleRange)) " is 147.
Long Statement,Microsoft.Windows.Controls,DateTimeHelper,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\DateTimeHelper.cs,GetCulture,The length of the statement  "            if (DependencyPropertyHelper.GetValueSource(element' FrameworkElement.LanguageProperty).BaseValueSource != BaseValueSource.Default) " is 131.
Long Statement,Microsoft.Windows.Controls,SelectedDatesCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\SelectedDatesCollection.cs,AddRange,The length of the statement  "            // If CalendarSelectionMode.SingleRange and a user programmatically tries to add multiple ranges' we will throw away the old range and replace it with the new one. " is 163.
Long Statement,Microsoft.Windows.Controls,SelectedDatesCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\SelectedDatesCollection.cs,RaiseSelectionChanged,The length of the statement  "            this._owner.OnSelectedDatesCollectionChanged(new CalendarSelectionChangedEventArgs(Calendar.SelectedDatesChangedEvent' removedItems' addedItems)); " is 146.
Long Statement,Microsoft.Windows.Controls,SelectedDatesCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\SelectedDatesCollection.cs,CheckSelectionMode,The length of the statement  "            // if user tries to add an item into the SelectedDates in SingleRange mode' we throw away the old range and replace it with the new one " is 135.
Long Statement,Microsoft.Windows.Controls,ClipboardHelper,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\ClipboardHelper.cs,GetClipboardContentForHtml,The length of the statement  "            string prefix = string.Format(CultureInfo.InvariantCulture' DATAGRIDVIEW_htmlPrefix' bytecountEndOfHtml.ToString("00000000"' CultureInfo.InvariantCulture)' bytecountEndOfFragment.ToString("00000000"' CultureInfo.InvariantCulture)) + DATAGRIDVIEW_htmlStartFragment; " is 264.
Long Statement,Microsoft.Windows.Controls,ColumnHeaderCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\ColumnHeaderCollection.cs,OnColumnsChanged,The length of the statement  "                    newArgs = new NotifyCollectionChangedEventArgs(e.Action' HeadersFromColumns(e.OldItems)' e.NewStartingIndex' e.OldStartingIndex); " is 129.
Long Statement,Microsoft.Windows.Controls,ColumnHeaderCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\ColumnHeaderCollection.cs,OnColumnsChanged,The length of the statement  "                    newArgs = new NotifyCollectionChangedEventArgs(e.Action' HeadersFromColumns(e.NewItems)' HeadersFromColumns(e.OldItems)' e.OldStartingIndex); " is 141.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnNotifyHorizontalOffsetPropertyChanged,The length of the statement  "            ((DataGrid)d).NotifyPropertyChanged(d' e' NotificationTarget.ColumnCollection | NotificationTarget.CellsPresenter | NotificationTarget.ColumnHeadersPresenter); " is 159.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,NotifyPropertyChanged,The length of the statement  "            if ((DataGridHelper.ShouldNotifyColumnHeadersPresenter(target) || DataGridHelper.ShouldNotifyColumnHeaders(target)) && ColumnHeadersPresenter != null) " is 150.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnLoadingRow,The length of the statement  "                Dispatcher.CurrentDispatcher.BeginInvoke(new DispatcherOperationCallback(DelayedOnLoadingRowDetails)' DispatcherPriority.Loaded' row); " is 134.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,ScrollIntoView,The length of the statement  "                Dispatcher.BeginInvoke(DispatcherPriority.Loaded' new DispatcherOperationCallback(OnScrollIntoView)' new object[] { item' column }); " is 132.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,DoAutoScroll,The length of the statement  "                            HandleSelectionForCellInput(cell' /* startDragging = */ false' /* allowsExtendSelect = */ true' /* allowsMinimalSelect = */ true); " is 130.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,EnsureInternalScrollControls,The length of the statement  "                    _internalScrollContentPresenter.SizeChanged += new SizeChangedEventHandler(OnInternalScrollContentPresenterSizeChanged); " is 120.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,CleanUpInternalScrollControls,The length of the statement  "                _internalScrollContentPresenter.SizeChanged -= new SizeChangedEventHandler(OnInternalScrollContentPresenterSizeChanged); " is 120.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnViewportSizeChanged,The length of the statement  "                        Dispatcher.BeginInvoke(new DispatcherOperationCallback(OnDelayedViewportWidthChanged)' DispatcherPriority.Loaded' this); " is 120.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnCanExecuteBeginEdit,The length of the statement  "            bool canExecute = !IsReadOnly && (CurrentCellContainer != null) && !IsEditingCurrentCell && !IsCurrentCellReadOnly && !HasCellValidationError; " is 142.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,GetEventCellOrCurrentCell,The length of the statement  "            return ((source == this) || (source == null)) ? CurrentCellContainer : DataGridHelper.FindVisualParent<DataGridCell>(source); " is 125.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,CanEndEdit,The length of the statement  "                   (editableItems.IsEditingItem && (commit || editableItems.CanCancelEdit || HasRowValidationError) && (editableItems.CurrentEditItem == rowItem)))); " is 146.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnExecutedCommitEdit,The length of the statement  "                    DataGridCellEditEndingEventArgs cellEditEndingEventArgs = new DataGridCellEditEndingEventArgs(cell.Column' cell.RowOwner' cell.EditingElement' DataGridEditAction.Commit); " is 170.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnExecutedCommitEdit,The length of the statement  "                    DataGridRowEditEndingEventArgs rowEditEndingEventArgs = new DataGridRowEditEndingEventArgs(cell.RowOwner' DataGridEditAction.Commit); " is 133.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnExecutedCommitEdit,The length of the statement  "                            // CommitEdit will invoke the bindingGroup's ValidationRule's' so we need to make sure that all of the BindingExpressions " is 121.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnExecutedCommitEdit,The length of the statement  "                            // have already registered with the BindingGroup.  Synchronously flushing the Dispatcher to DataBind priority lets us ensure this. " is 130.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnExecutedCancelEdit,The length of the statement  "                    DataGridCellEditEndingEventArgs cellEditEndingEventArgs = new DataGridCellEditEndingEventArgs(cell.Column' cell.RowOwner' cell.EditingElement' DataGridEditAction.Cancel); " is 170.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnExecutedCancelEdit,The length of the statement  "                        DataGridRowEditEndingEventArgs rowEditEndingEventArgs = new DataGridRowEditEndingEventArgs(cell.RowOwner' DataGridEditAction.Cancel); " is 133.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnExecutedDelete,The length of the statement  "                            HandleSelectionForCellInput(cell' /* startDragging = */ false' /* allowsExtendSelect = */ false' /* allowsMinimalSelect = */ false); " is 132.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnCurrentCellChanged,The length of the statement  "                    dataGrid.EndEdit(CommitEditCommand' dataGrid._currentCellContainer' DataGridEditingUnit.Row' /* exitEditingMode = */ true); " is 123.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnCurrentCellChanged,The length of the statement  "                    dataGrid.EndEdit(CommitEditCommand' dataGrid._currentCellContainer' DataGridEditingUnit.Cell' /* exitEditingMode = */ true); " is 124.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,CommitRowItem,The length of the statement  "            // Debug.Assert(IsEditingRowItem || IsAddingNewItem' "CommitRowItem was called when a row was not being edited or added."); " is 123.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,CancelRowItem,The length of the statement  "            // Debug.Assert(IsEditingRowItem || IsAddingNewItem' "CancelRowItem was called when a row was not being edited or added."); " is 123.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,UpdateNewItemPlaceholder,The length of the statement  "            DataGridRow newItemPlaceholderRow = (DataGridRow)ItemContainerGenerator.ContainerFromItem(CollectionView.NewItemPlaceholder); " is 125.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,NotifySelectedCellsChanged,The length of the statement  "                SelectedCellsChangedEventArgs e = new SelectedCellsChangedEventArgs(this' _pendingSelectedCells' _pendingUnselectedCells); " is 122.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,MakeCellSelection,The length of the statement  "                        _selectedCells.AddRegion(Math.Min(startIndex' endIndex)' Math.Min(startColumnIndex' endColumnIndex)' newRowCount' newColumnCount); " is 130.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnArrowKeyDown,The length of the statement  "                        SelectAndEditOnFocusMove(e' currentCellContainer' wasEditing' /* allowsExtendSelect = */ true' /* ignoreControlKey = */ true); " is 126.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnTabKeyDown,The length of the statement  "                        SelectAndEditOnFocusMove(e' currentCellContainer' wasEditing' /* allowsExtendSelect = */ false' /* ignoreControlKey = */ true); " is 127.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnEnterKeyDown,The length of the statement  "                    int index = Math.Max(0' Math.Min(numItems - 1' Items.IndexOf(currentCellContainer.RowDataItem) + (shiftModifier ? -1 : 1))); " is 124.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnEnterKeyDown,The length of the statement  "                            SelectAndEditOnFocusMove(e' currentCellContainer' /* wasEditing = */ false' /* allowsExtendSelect = */ false' /* ignoreControlKey = */ true); " is 141.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,SelectAndEditOnFocusMove,The length of the statement  "                        HandleSelectionForCellInput(newCell' /* startDragging = */ false' allowsExtendSelect' /* allowsMinimalSelect = */ false); " is 121.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnHomeOrEndKeyDown,The length of the statement  "                DataGridColumn column = ColumnFromDisplayIndex(homeKey ? InternalColumns.FirstVisibleDisplayIndex : InternalColumns.LastVisibleDisplayIndex); " is 141.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnHomeOrEndKeyDown,The length of the statement  "                        HandleSelectionForCellInput(cell' /* startDragging = */ false' /* allowsExtendSelect = */ true' /* allowsMinimalSelect = */ false); " is 131.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnPageUpOrDownKeyDown,The length of the statement  "                                HandleSelectionForCellInput(cell' /* startDragging = */ false' /* allowsExtendSelect = */ true' /* allowsMinimalSelect = */ false); " is 131.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnMouseMove,The length of the statement  "                                    HandleSelectionForCellInput(cell' /* startDragging = */ false' /* allowsExtendSelect = */ true' /* allowsMinimalSelect = */ true); " is 130.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnContextMenuOpening,The length of the statement  "                HandleSelectionForCellInput(cell' /* startDragging = */ false' /* allowsExtendSelect = */ true' /* allowsMinimalSelect = */ true); " is 130.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,GetRowNearMouse,The length of the statement  "            Debug.Assert(RelativeMousePosition != RelativeMousePositions.Over' "The mouse is not supposed to be over the DataGrid."); " is 121.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnItemsSortDescriptionsChanged,The length of the statement  "                    Debug.Assert(e.OldItems.Count == 1 && e.NewItems.Count == 1' "SortDescriptionCollection should handle one element at a time"); " is 126.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,AddGroupingSortDescriptions,The length of the statement  "                        SortDescription sortDescription = new SortDescription(propertyGroupDescription.PropertyName' ListSortDirection.Ascending); " is 122.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnItemsGroupDescriptionsChanged,The length of the statement  "                    Debug.Assert(e.OldItems.Count == 1 && e.NewItems.Count == 1' "GroupDescriptionCollection should handle one element at a time"); " is 127.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,GenerateColumns,The length of the statement  "            Debug.Assert(dataGrid != null || columnCollection != null' "Both dataGrid and columnCollection cannot not be null at the same time"); " is 133.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,GenerateColumns,The length of the statement  "                        DataGridAutoGeneratingColumnEventArgs eventArgs = new DataGridAutoGeneratingColumnEventArgs(dataGridColumn' itemProperty); " is 122.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnFrozenColumnCountPropertyChanged,The length of the statement  "            ((DataGrid)d).NotifyPropertyChanged(d' e' NotificationTarget.ColumnCollection | NotificationTarget.ColumnHeadersPresenter | NotificationTarget.CellsPresenter); " is 159.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnEnableColumnVirtualizationChanged,The length of the statement  "            ((DataGrid)d).NotifyPropertyChanged(d' e' NotificationTarget.CellsPresenter | NotificationTarget.ColumnHeadersPresenter | NotificationTarget.ColumnCollection); " is 159.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnExecutedCopy,The length of the statement  "            Collection<string> formats = new Collection<string>(new string[] { DataFormats.Html' DataFormats.Text' DataFormats.UnicodeText' DataFormats.CommaSeparatedValue }); " is 163.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnExecutedCopy,The length of the statement  "            if (_selectedCells.GetSelectionRange(out minColumnDisplayIndex' out maxColumnDisplayIndex' out minRowIndex' out maxRowIndex)) " is 125.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnExecutedCopy,The length of the statement  "                    DataGridRowClipboardEventArgs preparingRowClipboardContentEventArgs = new DataGridRowClipboardEventArgs(null' minColumnDisplayIndex' maxColumnDisplayIndex' true /*IsColumnHeadersRow*/); " is 185.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnExecutedCopy,The length of the statement  "                        DataGridRowClipboardEventArgs preparingRowClipboardContentEventArgs = new DataGridRowClipboardEventArgs(row' minColumnDisplayIndex' maxColumnDisplayIndex' false /*IsColumnHeadersRow*/' i); " is 188.
Long Statement,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,QueueInvalidateCellsPanelHorizontalOffset,The length of the statement  "                Dispatcher.BeginInvoke(new DispatcherOperationCallback(InvalidateCellsPanelHorizontalOffset)' DispatcherPriority.Loaded' this); " is 127.
Long Statement,Microsoft.Windows.Controls,DataGridCell,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCell.cs,PrepareCell,The length of the statement  "            Debug.Assert(_owner == null || _owner == ownerRow' "_owner should be null before PrepareCell is called or the same value as the ownerRow."); " is 140.
Long Statement,Microsoft.Windows.Controls,DataGridCell,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCell.cs,NotifyPropertyChanged,The length of the statement  "                else if (e.Property == DataGrid.CellStyleProperty || e.Property == DataGridColumn.CellStyleProperty || e.Property == StyleProperty) " is 131.
Long Statement,Microsoft.Windows.Controls,DataGridCell,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCell.cs,NotifyPropertyChanged,The length of the statement  "                else if (e.Property == DataGrid.IsReadOnlyProperty || e.Property == DataGridColumn.IsReadOnlyProperty || e.Property == IsReadOnlyProperty) " is 138.
Long Statement,Microsoft.Windows.Controls,DataGridCell,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCell.cs,RaisePreparingCellForEdit,The length of the statement  "                DataGridPreparingCellForEditEventArgs preparingCellForEditEventArgs = new DataGridPreparingCellForEditEventArgs(Column' RowOwner' editingEventArgs' currentEditingElement); " is 171.
Long Statement,Microsoft.Windows.Controls,DataGridCell,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCell.cs,OnAnyMouseLeftButtonDown,The length of the statement  "                    dataGridOwner.HandleSelectionForCellInput(this' /* startDragging = */ false' /* allowsExtendSelect = */ true' /* allowsMinimalSelect = */ false); " is 145.
Long Statement,Microsoft.Windows.Controls,DataGridCell,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCell.cs,OnAnyMouseLeftButtonDown,The length of the statement  "                    dataGridOwner.HandleSelectionForCellInput(this' /* startDragging = */ Mouse.Captured == null' /* allowsExtendSelect = */ true' /* allowsMinimalSelect = */ true); " is 161.
Long Statement,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,GenerateAndMeasureChildrenForRealizedColumns,The length of the statement  "                measureWidth += GetColumnEstimatedMeasureWidthSum(blockList[blockList.Count - 1].EndIndex + 1' parentDataGrid.Columns.Count - 1' averageColumnWidth); " is 149.
Long Statement,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,DetermineRealizedColumnsBlockList,The length of the statement  "            double viewportStartX = horizontalOffset - cellsPanelOffset;  // indicates the start of viewport with respect to coordinate system of cell panel " is 144.
Long Statement,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,DetermineRealizedColumnsBlockList,The length of the statement  "                    EnsureFocusTrail(realizedColumnIndices' realizedColumnDisplayIndices' firstVisibleNonFrozenDisplayIndex' lastVisibleNonFrozenDisplayIndex' constraint); " is 151.
Long Statement,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,BuildRealizedColumnsBlockList,The length of the statement  "                            int startIndexOffset = lastRealizedColumnsBlock.StartIndexOffset + lastRealizedColumnsBlock.EndIndex - lastRealizedColumnsBlock.StartIndex + 1; " is 143.
Long Statement,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,BuildRealizedColumnsBlockList,The length of the statement  "                            int startIndexOffset = lastRealizedColumnsBlock.StartIndexOffset + lastRealizedColumnsBlock.EndIndex - lastRealizedColumnsBlock.StartIndex + 1; " is 143.
Long Statement,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,IndexToGeneratorPositionForStart,The length of the statement  "            GeneratorPosition position = (generator != null) ? generator.GeneratorPositionFromIndex(index) : new GeneratorPosition(-1' index + 1); " is 134.
Long Statement,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,GenerateChild,The length of the statement  "                generatorState = generator.StartAt(IndexToGeneratorPositionForStart(generator' childIndex' out childIndex)' GeneratorDirection.Forward' true); " is 142.
Long Statement,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,InsertContainer,The length of the statement  "            // We have to do it this way because there could be recycled containers between the container we're looking for and the one before it.  " is 134.
Long Statement,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,InsertContainer,The length of the statement  "            // By finding the index before the place we want to insert and adding one' we ensure that we'll insert the new container in the  " is 127.
Long Statement,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,EnsureAtleastOneHeader,The length of the statement  "                        using (generator.StartAt(IndexToGeneratorPositionForStart(generator' childIndex' out childIndex)' GeneratorDirection.Forward' true)) " is 132.
Long Statement,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,EnsureFocusTrail,The length of the statement  "                if (GenerateChildForFocusTrail(generator' realizedColumnIndices' realizedColumnDisplayIndices' constraint' i' ref displayIndexListIterator)) " is 140.
Long Statement,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,EnsureFocusTrail,The length of the statement  "                    if (GenerateChildForFocusTrail(generator' realizedColumnIndices' realizedColumnDisplayIndices' constraint' i' ref displayIndexListIterator)) " is 140.
Long Statement,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,EnsureFocusTrail,The length of the statement  "                if (GenerateChildForFocusTrail(generator' realizedColumnIndices' realizedColumnDisplayIndices' constraint' i' ref displayIndexListIterator)) " is 140.
Long Statement,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,EnsureFocusTrail,The length of the statement  "                if (GenerateChildForFocusTrail(generator' realizedColumnIndices' realizedColumnDisplayIndices' constraint' i' ref displayIndexListIterator)) " is 140.
Long Statement,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,EnsureFocusTrail,The length of the statement  "                if (GenerateChildForFocusTrail(generator' realizedColumnIndices' realizedColumnDisplayIndices' constraint' i' ref displayIndexListIterator)) " is 140.
Long Statement,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,GenerateChildForFocusTrail,The length of the statement  "                    using (((IItemContainerGenerator)generator).StartAt(IndexToGeneratorPositionForStart(generator' childIndex' out childIndex)' GeneratorDirection.Forward' true)) " is 159.
Long Statement,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,VirtualizeChildren,The length of the statement  "                bool virtualizeChild = pastLastBlock || !InBlockOrNextBlock(blockList' columnIndex' ref blockIndex' ref block' out pastLastBlock); " is 130.
Long Statement,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,Debug_VerifyRealizedIndexCountVsDisplayIndexCount,The length of the statement  "                (lastBlock.StartIndexOffset + lastBlock.EndIndex - lastBlock.StartIndex) == (lastDisplayIndexBlock.StartIndexOffset + lastDisplayIndexBlock.EndIndex - lastDisplayIndexBlock.StartIndex)' " is 185.
Long Statement,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,ArrangeOverride,The length of the statement  "                    bool realizedChild = InBlockOrNextBlock(displayIndexBlockList' i' ref displayIndexBlockIndex' ref displayIndexBlock' out pastLastBlock); " is 136.
Long Statement,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,RemoveChildRange,The length of the statement  "                    Debug.Assert((itemCount == itemUICount) || (itemUICount == 0)' "Both ItemUICount and ItemCount should be equal or ItemUICount should be 0."); " is 141.
Long Statement,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,IsChildInView,The length of the statement  "            double viewportStartX = horizontalOffset - cellsPanelOffset;  // indicates the start of viewport with respect to coordinate system of cell panel " is 144.
Long Statement,Microsoft.Windows.Controls,DataGridColumn,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumn.cs,OnWidthPropertyChanged,The length of the statement  "                            column.SetWidthInternal(new DataGridLength(changedWidth.Value' changedWidth.UnitType' changedWidth.DesiredValue' displayValue)); " is 128.
Long Statement,Microsoft.Windows.Controls,DataGridColumn,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumn.cs,OnCoerceWidth,The length of the statement  "            newDisplayValue = (DoubleUtil.IsNaN(newDisplayValue) ? newDisplayValue : DataGridHelper.CoerceToMinMax(newDisplayValue' column.MinWidth' column.MaxWidth)); " is 155.
Long Statement,Microsoft.Windows.Controls,DataGridColumn,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumn.cs,NotifyPropertyChanged,The length of the statement  "                DataGridOwner.NotifyPropertyChanged(this' propertyName' new DependencyPropertyChangedEventArgs()' NotificationTarget.RefreshCellContent); " is 137.
Long Statement,Microsoft.Windows.Controls,DataGridColumn,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumn.cs,OnCoerceCanUserSort,The length of the statement  "                ValueSource parentValueSource = DependencyPropertyHelper.GetValueSource(column.DataGridOwner' DataGrid.CanUserSortColumnsProperty); " is 131.
Long Statement,Microsoft.Windows.Controls,DataGridColumn,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumn.cs,OnCoerceCanUserSort,The length of the statement  "                bool parentPropertyHasModifiers = parentValueSource.IsAnimated || parentValueSource.IsCoerced || parentValueSource.IsExpression; ; " is 130.
Long Statement,Microsoft.Windows.Controls,DataGridColumn,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumn.cs,OnCoerceCanUserSort,The length of the statement  "                if (parentValueSource.BaseValueSource == propertySource.BaseValueSource && !basePropertyHasModifiers && parentPropertyHasModifiers) " is 131.
Long Statement,Microsoft.Windows.Controls,DataGridColumn,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumn.cs,CreateDefaultColumn,The length of the statement  "            Debug.Assert(itemProperty != null && itemProperty.PropertyType != null' "itemProperty and/or its PropertyType member cannot be null"); " is 134.
Long Statement,Microsoft.Windows.Controls,DataGridColumn,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumn.cs,OnVisibilityPropertyChanged,The length of the statement  "                NotificationTarget.CellsPresenter | NotificationTarget.ColumnHeadersPresenter | NotificationTarget.ColumnCollection | NotificationTarget.ColumnHeaders); " is 152.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,ColumnFromDisplayIndex,The length of the statement  "            Debug.Assert(displayIndex >= 0 && displayIndex < DisplayIndexMap.Count' "displayIndex should have already been validated"); " is 123.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,OnColumnDisplayIndexChanged,The length of the statement  "                // change from -1 to the new value; the OnColumnDisplayIndexChanged further down the stack (from old value to -1) will handle " is 125.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,OnColumnDisplayIndexChanged,The length of the statement  "            Debug.Assert(newDisplayIndex >= 0 && newDisplayIndex < Count' "The new DisplayIndex should have already been validated"); " is 121.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,UpdateDisplayIndexForChangedColumn,The length of the statement  "            // The code below adjusts the DisplayIndex of other columns and shouldn't happen if this column's display index is changed " is 122.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,UpdateDisplayIndexForChangedColumn,The length of the statement  "                Debug.Assert(oldDisplayIndex != newDisplayIndex' "A column's display index must have changed for us to call OnColumnDisplayIndexChanged"); " is 138.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,UpdateDisplayIndexForChangedColumn,The length of the statement  "                    // DisplayIndex increased. All columns with DisplayIndex <= newDisplayIndex and > oldDisplayIndex get their DisplayIndex decremented. " is 133.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,UpdateDisplayIndexForChangedColumn,The length of the statement  "                DataGridOwner.UpdateColumnsOnVirtualizedCellInfoCollections(NotifyCollectionChangedAction.Move' oldDisplayIndex' null' newDisplayIndex); " is 136.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,UpdateDisplayIndexForMovedColumn,The length of the statement  "            DataGridOwner.UpdateColumnsOnVirtualizedCellInfoCollections(NotifyCollectionChangedAction.Move' oldColumnIndex' null' newColumnIndex); " is 134.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,UpdateDisplayIndexForNewColumns,The length of the statement  "                DataGridOwner.UpdateColumnsOnVirtualizedCellInfoCollections(NotifyCollectionChangedAction.Add' -1' null' newDisplayIndex); " is 122.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,InitializeDisplayIndexMap,The length of the statement  "                throw new ArgumentOutOfRangeException("displayIndex"' oldDisplayIndex' SR.Get(SRID.DataGrid_ColumnDisplayIndexOutOfRange' changingColumn.Header)); " is 146.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,UpdateDisplayIndexForRemovedColumns,The length of the statement  "                Debug.Assert(DisplayIndexMap.Count > Count' "Columns were just removed: the display index map shouldn't have yet been updated"); " is 128.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,UpdateDisplayIndexForRemovedColumns,The length of the statement  "                DataGridOwner.UpdateColumnsOnVirtualizedCellInfoCollections(NotifyCollectionChangedAction.Remove' removedDisplayIndex' (DataGridColumn)oldColumns[0]' -1); " is 154.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,UpdateDisplayIndexForReplacedColumn,The length of the statement  "                    DataGridOwner.UpdateColumnsOnVirtualizedCellInfoCollections(NotifyCollectionChangedAction.Replace' newDisplayIndex' oldColumn' newDisplayIndex); " is 144.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,ValidateDisplayIndex,The length of the statement  "                throw new ArgumentOutOfRangeException("displayIndex"' displayIndex' SR.Get(SRID.DataGrid_ColumnDisplayIndexOutOfRange' column.Header)); " is 135.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,Debug_VerifyDisplayIndexMap,The length of the statement  "                Debug.Assert(DisplayIndexMap[i] >= 0 && DisplayIndexMap[i] < Count' "DisplayIndex map entry doesn't point to a valid column"); " is 126.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,ComputeStarColumnWidths,The length of the statement  "                // into partialResolvedColumns giving them atleast the minwidth and there by reducing the availableSpace and totalFactors " is 121.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,ComputeStarColumnWidths,The length of the statement  "                // there by reducing the availablespace and totalfactors. If such column is found' the remaining columns are to be recomputed " is 125.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,InvalidateColumnWidthsComputation,The length of the statement  "            DataGridOwner.Dispatcher.BeginInvoke(new DispatcherOperationCallback(ComputeColumnWidths)' DispatcherPriority.Render' this); " is 124.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,InitializeColumnDisplayValues,The length of the statement  "                    double displayValue = DataGridHelper.CoerceToMinMax(DoubleUtil.IsNaN(width.DesiredValue) ? minWidth : width.DesiredValue' minWidth' column.MaxWidth); " is 149.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,RedistributeColumnWidthsOnWidthChangeOfColumn,The length of the statement  "                    changedColumn.SetWidthInternal(new DataGridLength(width.Value' width.UnitType' width.DesiredValue' minWidth + leftOverSpace)); " is 126.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,ExpandAllColumnWidthsToDesiredValue,The length of the statement  "                    column.SetWidthInternal(new DataGridLength(width.Value' width.UnitType' width.DesiredValue' Math.Min(width.DesiredValue' maxWidth))); " is 133.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,RedistributeColumnWidthsOnNonStarWidthChange,The length of the statement  "                double nonRetrievableSpace = TakeAwayWidthFromColumns(changedColumn' width.DesiredValue - oldWidth.DisplayValue' changedColumn != null); " is 136.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,RedistributeColumnWidthsOnNonStarWidthChange,The length of the statement  "                double newDesiredValue = DataGridHelper.CoerceToMinMax(width.DesiredValue' changedColumn.MinWidth' changedColumn.MaxWidth); " is 123.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,RecomputeColumnWidthsOnColumnPositiveResize,The length of the statement  "                horizontalChange = RecomputeNonStarColumnWidthsOnColumnPositiveResize(horizontalChange' resizingColumnIndex' retainAuto' true); " is 127.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,RecomputeColumnWidthsOnColumnPositiveResize,The length of the statement  "                horizontalChange = RecomputeStarColumnWidthsOnColumnPositiveResize(horizontalChange' resizingColumnIndex' perStarWidth' retainAuto); " is 132.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,RecomputeColumnWidthsOnColumnPositiveResize,The length of the statement  "                horizontalChange = RecomputeNonStarColumnWidthsOnColumnPositiveResize(horizontalChange' resizingColumnIndex' retainAuto' false); " is 128.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,ReallocateStarValuesForPositiveResize,The length of the statement  "                else if (column.Width.IsStar && CanColumnParticipateInResize(column) && DoubleUtil.GreaterThan(width.DisplayValue' column.MinWidth)) " is 132.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,ReallocateStarValuesForPositiveResize,The length of the statement  "                    column.UpdateWidthForStarColumn(Math.Max(columnDesiredWidth' column.MinWidth)' columnDesiredWidth' columnDesiredWidth / perStarWidth); " is 134.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,RecomputeNonStarColumnWidthsOnColumnPositiveResize,The length of the statement  "                    double columnExcessWidth = onlyShrinkToDesiredWidth ? width.DisplayValue - Math.Max(width.DesiredValue' column.MinWidth) : width.DisplayValue - column.MinWidth; " is 160.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,RecomputeNonStarColumnWidthsOnColumnPositiveResize,The length of the statement  "                        column.SetWidthInternal(new DataGridLength(width.Value' width.UnitType' width.DesiredValue' width.DisplayValue - columnExcessWidth)); " is 133.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,RecomputeColumnWidthsOnColumnNegativeResize,The length of the statement  "                horizontalChange = RecomputeNonStarColumnWidthsOnColumnNegativeResize(horizontalChange' resizingColumnIndex' retainAuto' false); " is 128.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,RecomputeColumnWidthsOnColumnNegativeResize,The length of the statement  "                horizontalChange = RecomputeStarColumnWidthsOnColumnNegativeResize(horizontalChange' resizingColumnIndex' perStarWidth' retainAuto); " is 132.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,RecomputeColumnWidthsOnColumnNegativeResize,The length of the statement  "                horizontalChange = RecomputeNonStarColumnWidthsOnColumnNegativeResize(horizontalChange' resizingColumnIndex' retainAuto' true); " is 127.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,RecomputeNonStarColumnWidthsOnColumnNegativeResize,The length of the statement  "                    double maxColumnResizeWidth = expandBeyondDesiredWidth ? column.MaxWidth : Math.Min(width.DesiredValue' column.MaxWidth); " is 121.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,RecomputeNonStarColumnWidthsOnColumnNegativeResize,The length of the statement  "                        column.SetWidthInternal(new DataGridLength(width.Value' width.UnitType' width.DesiredValue' width.DisplayValue + columnLagWidth)); " is 130.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,ReallocateStarValuesForNegativeResize,The length of the statement  "                else if (column.Width.IsStar && CanColumnParticipateInResize(column) && DoubleUtil.LessThan(width.DisplayValue' column.MaxWidth)) " is 129.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,ReallocateStarValuesForNegativeResize,The length of the statement  "                    column.UpdateWidthForStarColumn(Math.Min(columnDesiredWidth' column.MaxWidth)' columnDesiredWidth' columnDesiredWidth / perStarWidth); " is 134.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,SetResizedColumnWidth,The length of the statement  "            double columnDisplayWidth = DataGridHelper.CoerceToMinMax(width.DisplayValue + widthDelta' column.MinWidth' column.MaxWidth); " is 125.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,SetResizedColumnWidth,The length of the statement  "                column.SetWidthInternal(new DataGridLength(columnDisplayWidth' DataGridLengthUnitType.Pixel' columnDisplayWidth' columnDisplayWidth)); " is 134.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,GiveAwayWidthToEveryNonStarColumn,The length of the statement  "                    column.SetWidthInternal(new DataGridLength(width.Value' width.UnitType' width.DesiredValue' width.DisplayValue + perColumnGiveAwayWidth)); " is 138.
Long Statement,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,TakeAwayWidthFromEveryNonStarColumn,The length of the statement  "                    column.SetWidthInternal(new DataGridLength(width.Value' width.UnitType' width.DesiredValue' width.DisplayValue - perColumnTakeAwayWidth)); " is 138.
Long Statement,Microsoft.Windows.Controls,TextBlockComboBox,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridComboBoxColumn.cs,OnDataContextPropertyChanged,The length of the statement  "                bool isLocalValue = (DependencyPropertyHelper.GetValueSource(combo' SelectedItemProperty).BaseValueSource == BaseValueSource.Local); " is 132.
Long Statement,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The length of the statement  "                PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)AeroFreezables.ArrowUpGeometry : (int)AeroFreezables.ArrowDownGeometry); " is 151.
Long Statement,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The length of the statement  "            LunaFreezables backgroundType = isPressed ? LunaFreezables.PressedBackground : isHovered ? LunaFreezables.HoveredBackground : LunaFreezables.NormalBackground; " is 158.
Long Statement,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The length of the statement  "                ArcSegment arc = new ArcSegment(new Point(size.Width - 2.5' 2.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true); " is 131.
Long Statement,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The length of the statement  "                    SolidColorBrush tabStrokeBrush = new SolidColorBrush((colorVariant == Luna.HomeStead) ? Color.FromArgb(0xFF' 0xCF' 0x72' 0x25) : Color.FromArgb(0xFF' 0xF8' 0xA9' 0x00)); " is 169.
Long Statement,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The length of the statement  "                    border = new SolidColorBrush((colorVariant == Luna.Metallic) ? Color.FromArgb(0xFF' 0x80' 0x80' 0x99) : Color.FromArgb(0xFF' 0xA5' 0xA5' 0x97)); " is 144.
Long Statement,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The length of the statement  "                        LinearGradientBrush gripper = (LinearGradientBrush)GetCachedFreezable((int)(horizontal ? LunaFreezables.HorizontalGripper : LunaFreezables.VerticalGripper)); " is 157.
Long Statement,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The length of the statement  "                    dc.DrawRectangle(sideBrush' null' new Rect(horizontal ? 0.0 : Max0(size.Width - 2.0)' 4.0' 2.0' Max0(size.Height - 8.0))); " is 122.
Long Statement,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The length of the statement  "                PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)LunaFreezables.ArrowUpGeometry : (int)LunaFreezables.ArrowDownGeometry); " is 151.
Long Statement,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderClassic,The length of the statement  "                PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)ClassicFreezables.ArrowUpGeometry : (int)ClassicFreezables.ArrowDownGeometry); " is 157.
Long Statement,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderClassic,The length of the statement  "                    CacheFreezable(arrowGeometry' ascending ? (int)ClassicFreezables.ArrowUpGeometry : (int)ClassicFreezables.ArrowDownGeometry); " is 125.
Long Statement,Microsoft.Windows.Controls,DataGridHelper,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHelper.cs,OnColumnWidthChanged,The length of the statement  "            Debug.Assert((cell is DataGridCell) || (cell is DataGridColumnHeader)' "provideColumn should be one of the cell or header containers."); " is 136.
Long Statement,Microsoft.Windows.Controls,DataGridHelper,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHelper.cs,GetParentPanelForCell,The length of the statement  "            Debug.Assert((cell is DataGridCell) || (cell is DataGridColumnHeader)' "provideColumn should be one of the cell or header containers."); " is 136.
Long Statement,Microsoft.Windows.Controls,DataGridHelper,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHelper.cs,GetCoercedTransferPropertyValue,The length of the statement  "            // If not a 'Transfer Property Coercion'' simply return baseValue.  This will cause a property change if the value changes' which " is 129.
Long Statement,Microsoft.Windows.Controls,DataGridLengthConverter,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridLengthConverter.cs,ConvertTo,The length of the statement  "                    ConstructorInfo ci = typeof(DataGridLength).GetConstructor(new Type[] { typeof(double)' typeof(DataGridLengthUnitType) }); " is 122.
Long Statement,Microsoft.Windows.Controls,DataGridRow,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridRow.cs,PrepareRow,The length of the statement  "            Debug.Assert(_owner == null || _owner == owningDataGrid' "_owner should be null before PrepareRow is called or the same as the owningDataGrid."); " is 145.
Long Statement,Microsoft.Windows.Controls,DataGridRow,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridRow.cs,PrepareRow,The length of the statement  "            // Since we just changed _owner we need to invalidate all child properties that rely on a value supplied by the DataGrid. " is 121.
Long Statement,Microsoft.Windows.Controls,DataGridRow,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridRow.cs,PrepareRow,The length of the statement  "            // A common scenario is when a recycled Row was detached from the visual tree and has just been reattached (we always clear out the  " is 131.
Long Statement,Microsoft.Windows.Controls,DataGridRow,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridRow.cs,PrepareRow,The length of the statement  "            Dispatcher.BeginInvoke(new DispatcherOperationCallback(DelayedValidateWithoutUpdate)' DispatcherPriority.DataBind' BindingGroup); " is 129.
Long Statement,Microsoft.Windows.Controls,DataGridRow,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridRow.cs,OnNotifyDetailsTemplatePropertyChanged,The length of the statement  "            // It only makes sense to fire UnloadingRowDetails if the row details are already loaded. The same is true for LoadingRowDetails' " is 129.
Long Statement,Microsoft.Windows.Controls,DataGridRow,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridRow.cs,OnNotifyDetailsTemplatePropertyChanged,The length of the statement  "                    Dispatcher.CurrentDispatcher.BeginInvoke(new DispatcherOperationCallback(DataGrid.DelayedOnLoadingRowDetails)' DispatcherPriority.Loaded' row); " is 143.
Long Statement,Microsoft.Windows.Controls,DataGridRow,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridRow.cs,OnNotifyDetailsVisibilityChanged,The length of the statement  "            Dispatcher.CurrentDispatcher.BeginInvoke(new DispatcherOperationCallback(DelayedRowDetailsVisibilityChanged)' DispatcherPriority.Loaded' row); " is 142.
Long Statement,Microsoft.Windows.Controls,DataGridRow,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridRow.cs,NotifyPropertyChanged,The length of the statement  "                else if (e.Property == DataGrid.RowDetailsVisibilityModeProperty || e.Property == DetailsVisibilityProperty || e.Property == IsSelectedProperty) " is 144.
Long Statement,Microsoft.Windows.Controls,DataGridRow,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridRow.cs,NotifyPropertyChanged,The length of the statement  "                    Dispatcher.BeginInvoke(new DispatcherOperationCallback(DelayedValidateWithoutUpdate)' DispatcherPriority.DataBind' e.NewValue); " is 127.
Long Statement,Microsoft.Windows.Controls,DataGridRowClipboardEventArgs,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridRowClipboardEventArgs.cs,FormatClipboardCellValues,The length of the statement  "                ClipboardHelper.FormatCell(ClipboardRowContent[i].Content' i == 0 /* firstCell */' i == count - 1 /* lastCell */' sb' format); " is 126.
Long Statement,Microsoft.Windows.Controls,MultipleCopiesCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\MultipleCopiesCollection.cs,MirrorCollectionChange,The length of the statement  "                        "We're mirroring the Columns collection which is an ObservableCollection and only supports removing one item at a time"); " is 121.
Long Statement,Microsoft.Windows.Controls,MultipleCopiesCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\MultipleCopiesCollection.cs,MirrorCollectionChange,The length of the statement  "                        "We're mirroring the Columns collection which is an ObservableCollection and only supports replacing one item at a time"); " is 122.
Long Statement,Microsoft.Windows.Controls,MultipleCopiesCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\MultipleCopiesCollection.cs,Move,The length of the statement  "            OnCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Move' CopiedItem' newIndex' oldIndex)); " is 126.
Long Statement,Microsoft.Windows.Controls,MultipleCopiesCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\MultipleCopiesCollection.cs,OnReplace,The length of the statement  "            OnCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Replace' newItem' oldItem' index)); " is 122.
Long Statement,Microsoft.Windows.Controls,DatePicker,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DatePicker\Microsoft\Windows\Controls\DatePicker.cs,OnSelectedDateChanged,The length of the statement  "            dp.OnSelectedDateChanged(new CalendarSelectionChangedEventArgs(DatePicker.SelectedDateChangedEvent' removedItems' addedItems)); " is 127.
Long Statement,Microsoft.Windows.Controls,DatePicker,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DatePicker\Microsoft\Windows\Controls\DatePicker.cs,CalendarDayOrMonthButton_PreviewKeyDown,The length of the statement  "            if (args.Key == Key.Escape || ((args.Key == Key.Enter || args.Key == Key.Space) && c.DisplayMode == CalendarMode.Month)) " is 120.
Long Statement,Microsoft.Windows.Controls,DatePicker,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DatePicker\Microsoft\Windows\Controls\DatePicker.cs,Calendar_SelectedDatesChanged,The length of the statement  "            if (e.AddedItems.Count > 0 && this.SelectedDate.HasValue && DateTime.Compare((DateTime)e.AddedItems[0]' this.SelectedDate.Value) != 0) " is 134.
Long Statement,Microsoft.Windows.Controls,DatePicker,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DatePicker\Microsoft\Windows\Controls\DatePicker.cs,ParseText,The length of the statement  "                    DatePickerDateValidationErrorEventArgs dateValidationError = new DatePickerDateValidationErrorEventArgs(new ArgumentOutOfRangeException("text"' SR.Get(SRID.Calendar_OnSelectedDateChanged_InvalidValue))' text); " is 209.
Long Statement,Microsoft.Windows.Controls,DatePicker,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DatePicker\Microsoft\Windows\Controls\DatePicker.cs,SetWaterMarkText,The length of the statement  "                            this._textBox.Watermark = string.Format(CultureInfo.CurrentCulture' SR.Get(SRID.DatePicker_WatermarkText)' dtfi.LongDatePattern.ToString()); " is 140.
Long Statement,Microsoft.Windows.Controls,DatePicker,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DatePicker\Microsoft\Windows\Controls\DatePicker.cs,SetWaterMarkText,The length of the statement  "                            this._textBox.Watermark = string.Format(CultureInfo.CurrentCulture' SR.Get(SRID.DatePicker_WatermarkText)' dtfi.ShortDatePattern.ToString()); " is 141.
Long Statement,Microsoft.Windows.Controls,TypeHandlerFactory<TypeHandler>,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\VSM\VisualStateManager\Microsoft\Windows\Controls\TypeHandlerFactory.cs,GetImplementingType,The length of the statement  "            // Walk up the base type chain starting at type and return the most-base type that still implements the base type passed in. " is 124.
Long Statement,Microsoft.Windows.Controls,TypeHandlerFactory<TypeHandler>,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\VSM\VisualStateManager\Microsoft\Windows\Controls\TypeHandlerFactory.cs,GetImplementingType,The length of the statement  "            Debug.Assert(implementingType != null && DoesTypeImplement(baseType' implementingType)' "Error finding class that implements given interface."); " is 144.
Long Statement,Microsoft.Windows.Controls,VisualStateBehaviorFactory,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\VSM\VisualStateManager\Microsoft\Windows\Controls\VisualStateBehaviorFactory.cs,AttachBehavior,The length of the statement  "            if (DependencyPropertyHelper.GetValueSource(control' VisualStateBehavior.VisualStateBehaviorProperty).BaseValueSource == BaseValueSource.Default) " is 145.
Long Statement,Microsoft.Windows.Controls.Primitives,CalendarButton,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\CalendarButton.cs,ChangeVisualState,The length of the statement  "                VisualStates.GoToState(this' useTransitions' VisualStates.StateCalendarButtonFocused' VisualStates.StateCalendarButtonUnfocused); " is 129.
Long Statement,Microsoft.Windows.Controls.Primitives,CalendarDayButton,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\CalendarDayButton.cs,ChangeVisualState,The length of the statement  "                VisualStates.GoToState(this' useTransitions' VisualStates.StateCalendarButtonFocused' VisualStates.StateCalendarButtonUnfocused); " is 129.
Long Statement,Microsoft.Windows.Controls.Primitives,CalendarItem,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\CalendarItem.cs,EndDrag,The length of the statement  "                        (Owner.SelectionMode == CalendarSelectionMode.SingleDate || Owner.SelectionMode == CalendarSelectionMode.MultipleRange)) " is 120.
Long Statement,Microsoft.Windows.Controls.Primitives,CalendarItem,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\CalendarItem.cs,FinishSelection,The length of the statement  "            if (this.Owner.SelectionMode == CalendarSelectionMode.None || this.Owner.SelectionMode == CalendarSelectionMode.SingleDate) " is 123.
Long Statement,Microsoft.Windows.Controls.Primitives,CalendarItem,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\CalendarItem.cs,PopulateGrids,The length of the statement  "                        dayCell.AddHandler(CalendarDayButton.MouseLeftButtonDownEvent' new MouseButtonEventHandler(Cell_MouseLeftButtonDown)' true); " is 124.
Long Statement,Microsoft.Windows.Controls.Primitives,CalendarItem,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\CalendarItem.cs,PopulateGrids,The length of the statement  "                        dayCell.AddHandler(CalendarDayButton.MouseLeftButtonUpEvent' new MouseButtonEventHandler(Cell_MouseLeftButtonUp)' true); " is 120.
Long Statement,Microsoft.Windows.Controls.Primitives,CalendarItem,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\CalendarItem.cs,PopulateGrids,The length of the statement  "                        monthCell.AddHandler(CalendarButton.MouseLeftButtonDownEvent' new MouseButtonEventHandler(Month_MouseLeftButtonDown)' true); " is 124.
Long Statement,Microsoft.Windows.Controls.Primitives,CalendarItem,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\CalendarItem.cs,PopulateGrids,The length of the statement  "                        monthCell.AddHandler(CalendarButton.MouseLeftButtonUpEvent' new MouseButtonEventHandler(Month_MouseLeftButtonUp)' true); " is 120.
Long Statement,Microsoft.Windows.Controls.Primitives,CalendarItem,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\CalendarItem.cs,SetMonthModeDayTitles,The length of the statement  "                            daytitle.DataContext = shortestDayNames[(childIndex + (int)DateTimeHelper.GetDateFormat(DateTimeHelper.GetCulture(this)).FirstDayOfWeek) % shortestDayNames.Length]; " is 164.
Long Statement,Microsoft.Windows.Controls.Primitives,CalendarItem,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\CalendarItem.cs,SetMonthModeDayButtonState,The length of the statement  "                    if (DateTimeHelper.CompareDays(dateToAdd.Value' this.Owner.DisplayDateStartInternal) < 0 || DateTimeHelper.CompareDays(dateToAdd.Value' this.Owner.DisplayDateEndInternal) > 0) " is 175.
Long Statement,Microsoft.Windows.Controls.Primitives,CalendarItem,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\CalendarItem.cs,SetMonthModeDayButtonState,The length of the statement  "                        // Since we should be comparing the Date values not DateTime values' we can't use this.Owner.SelectedDates.Contains(dateToAdd) directly " is 135.
Long Statement,Microsoft.Windows.Controls.Primitives,CalendarItem,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\CalendarItem.cs,SetYearModeMonthButtons,The length of the statement  "                    if (DateTimeHelper.CompareYearMonth(day' this.Owner.DisplayDateStartInternal) < 0 || DateTimeHelper.CompareYearMonth(day' this.Owner.DisplayDateEndInternal) > 0) " is 161.
Long Statement,Microsoft.Windows.Controls.Primitives,CalendarItem,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\CalendarItem.cs,GetNumberOfDisplayedDaysFromPreviousMonth,The length of the statement  "                i = ((day - DateTimeHelper.GetDateFormat(DateTimeHelper.GetCulture(this)).FirstDayOfWeek + NUMBER_OF_DAYS_IN_WEEK) % NUMBER_OF_DAYS_IN_WEEK); " is 141.
Long Statement,Microsoft.Windows.Controls.Primitives,DataGridCellsPresenter,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\Primitives\DataGridCellsPresenter.cs,SyncProperties,The length of the statement  "            NotifyPropertyChanged(this' new DependencyPropertyChangedEventArgs(DataGrid.CellStyleProperty' null' null)' NotificationTarget.Cells); " is 134.
Long Statement,Microsoft.Windows.Controls.Primitives,DataGridCellsPresenter,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\Primitives\DataGridCellsPresenter.cs,InvalidateCellsPanelOnColumnChange,The length of the statement  "            // either RebuildRealizedColumnsBlockListForNonVirtualizedRows or RebuildRealizedColumnsBlockListForVirtualizedRows is true  " is 123.
Long Statement,Microsoft.Windows.Controls.Primitives,DataGridColumnHeader,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\Primitives\DataGridColumnHeader.cs,NotifyPropertyChanged,The length of the statement  "            else if (e.Property == DataGrid.ColumnHeaderStyleProperty || e.Property == DataGridColumn.HeaderStyleProperty || e.Property == StyleProperty) " is 141.
Long Statement,Microsoft.Windows.Controls.Primitives,DataGridColumnHeadersPresenter,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\Primitives\DataGridColumnHeadersPresenter.cs,ArrangeOverride,The length of the statement  "            UIElement child = (VisualTreeHelper.GetChildrenCount(this) > 0) ? VisualTreeHelper.GetChild(this' 0) as UIElement : null; " is 121.
Long Statement,Microsoft.Windows.Controls.Primitives,DataGridColumnHeadersPresenter,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\Primitives\DataGridColumnHeadersPresenter.cs,ArrangeOverride,The length of the statement  "                _columnHeaderDropLocationIndicator.Arrange(new Rect(point' new Size(dropIndicatorWidth' _columnHeaderDropLocationIndicator.Height))); " is 133.
Long Statement,Microsoft.Windows.Controls.Primitives,DataGridColumnHeadersPresenter,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\Primitives\DataGridColumnHeadersPresenter.cs,ColumnFromContainer,The length of the statement  "            Debug.Assert(HeaderCollection != null' "This is a helper method for preparing and clearing a container; if it's called we must have a valid ItemSource"); " is 153.
Long Statement,Microsoft.Windows.Controls.Primitives,DataGridColumnHeadersPresenter,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\Primitives\DataGridColumnHeadersPresenter.cs,StartColumnHeaderDrag,The length of the statement  "            DragStartedEventArgs dragStartedEventArgs = new DragStartedEventArgs(_columnHeaderDragStartPosition.X' _columnHeaderDragStartPosition.Y); " is 137.
Long Statement,Microsoft.Windows.Controls.Primitives,DataGridColumnHeadersPresenter,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\Primitives\DataGridColumnHeadersPresenter.cs,StartColumnHeaderDrag,The length of the statement  "            DataGridColumnReorderingEventArgs reorderingEventArgs = new DataGridColumnReorderingEventArgs(_draggingSrcColumnHeader.Column); " is 127.
Long Statement,Microsoft.Windows.Controls.Primitives,DataGridColumnHeadersPresenter,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\Primitives\DataGridColumnHeadersPresenter.cs,FindDisplayIndexAndHeaderPosition,The length of the statement  "                        if (_draggingSrcColumnHeader != null && _draggingSrcColumnHeader.Column != null && _draggingSrcColumnHeader.Column.DisplayIndex < displayIndex) " is 143.
Long Statement,Microsoft.Windows.Controls.Primitives,DataGridDetailsPresenter,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\Primitives\DataGridDetailsPresenter.cs,NotifyPropertyChanged,The length of the statement  "            if (e.Property == DataGrid.RowDetailsTemplateProperty || e.Property == DataGridRow.DetailsTemplateProperty || e.Property == ContentTemplateProperty) " is 148.
Long Statement,Microsoft.Windows.Controls.Primitives,DataGridDetailsPresenter,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\Primitives\DataGridDetailsPresenter.cs,NotifyPropertyChanged,The length of the statement  "            else if (e.Property == DataGrid.RowDetailsTemplateSelectorProperty || e.Property == DataGridRow.DetailsTemplateSelectorProperty || e.Property == ContentTemplateSelectorProperty) " is 177.
Long Statement,Microsoft.Windows.Controls.Primitives,DataGridRowHeader,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\Primitives\DataGridRowHeader.cs,NotifyPropertyChanged,The length of the statement  "            else if (e.Property == DataGrid.RowHeaderStyleProperty || e.Property == DataGridRow.HeaderStyleProperty || e.Property == StyleProperty) " is 135.
Long Statement,Microsoft.Windows.Controls.Primitives,DataGridRowHeader,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\Primitives\DataGridRowHeader.cs,NotifyPropertyChanged,The length of the statement  "            else if (e.Property == DataGrid.RowHeaderTemplateProperty || e.Property == DataGridRow.HeaderTemplateProperty || e.Property == ContentTemplateProperty) " is 151.
Long Statement,Microsoft.Windows.Controls.Primitives,DataGridRowHeader,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\Primitives\DataGridRowHeader.cs,NotifyPropertyChanged,The length of the statement  "            else if (e.Property == DataGrid.RowHeaderTemplateSelectorProperty || e.Property == DataGridRow.HeaderTemplateSelectorProperty || e.Property == ContentTemplateSelectorProperty) " is 175.
Long Statement,Microsoft.Windows.Controls.Primitives,DataGridRowHeader,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\Primitives\DataGridRowHeader.cs,NotifyPropertyChanged,The length of the statement  "                // If the DataGrid has not run layout the headers parent may not position the cells correctly when the header size changes. " is 123.
Long Statement,Microsoft.Windows.Controls.Primitives,DataGridRowHeader,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\Primitives\DataGridRowHeader.cs,NotifyPropertyChanged,The length of the statement  "                // This will cause the cells to be out of sync with the columns. To avoid this we will force a layout of the headers parent panel. " is 130.
Long Statement,Microsoft.Windows.Controls.Primitives,DatePickerTextBox,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DatePicker\Microsoft\Windows\Controls\DatePickerTextBox.cs,ExtractTemplatePart,The length of the statement  "                string.Format(CultureInfo.InvariantCulture' SR.Get(SRID.DatePickerTextBox_TemplatePartIsOfIncorrectType)' partName' typeof(T).Name)); " is 133.
Long Statement,System.Windows,VisualStateManager,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\VSM\VisualStateManager\System\Windows\VisualStateManager.cs,GetVisualStateGroupsInternal,The length of the statement  "            Collection<VisualStateGroup> groups = obj.GetValue(VisualStateManager.VisualStateGroupsProperty) as Collection<VisualStateGroup>; " is 129.
Long Statement,System.Windows,VisualStateManager,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\VSM\VisualStateManager\System\Windows\VisualStateManager.cs,GoToStateInternal,The length of the statement  "            VisualTransition transition = useTransitions ? VisualStateManager.GetTransition(element' group' lastState' state) : null; " is 121.
Long Statement,System.Windows,VisualStateManager,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\VSM\VisualStateManager\System\Windows\VisualStateManager.cs,GenerateDynamicTransitionAnimations,The length of the statement  "            Dictionary<TimelineDataToken' Timeline> transitionAnimations = FlattenTimelines(transition != null ? transition.Storyboard : null); " is 131.
Long Statement,XamlGeneratedNamespace,GeneratedInternalTypeHelper,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\obj\Debug\GeneratedInternalTypeHelper.g.cs,CreateInstance,The length of the statement  "            return System.Activator.CreateInstance(type' ((System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.NonPublic)  " is 128.
Complex Conditional,Microsoft.Windows.Automation.Peers,CalendarAutomationPeer,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Automation\Peers\CalendarAutomationPeer.cs,GetItem,The conditional expression  "this.OwningGrid != null && row >= 0 && row < this.OwningGrid.RowDefinitions.Count && column >= 0 && column < this.OwningGrid.ColumnDefinitions.Count"  is complex.
Complex Conditional,Microsoft.Windows.Automation.Peers,DataGridAutomationPeer,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Automation\Peers\DataGridAutomationPeer.cs,GetItem,The conditional expression  "row >= 0 && row < this.OwningDataGrid.Items.Count &&                  column >= 0 && column < this.OwningDataGrid.Columns.Count"  is complex.
Complex Conditional,Microsoft.Windows.Automation.Peers,DataGridAutomationPeer,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Automation\Peers\DataGridAutomationPeer.cs,CalculateVisibleBoundingRect,The conditional expression  "visual != null && boundingRect != Rect.Empty && boundingRect.Height != 0 && boundingRect.Width != 0"  is complex.
Complex Conditional,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnExecutedCommitEdit,The conditional expression  "validationPassed &&                       !eventCanceled &&                      (((editingUnit == DataGridEditingUnit.Row) && IsAddingOrEditingRowItem(cell.RowDataItem)) ||                       (!EditableItems.CanCancelEdit && IsEditingItem(cell.RowDataItem)))"  is complex.
Complex Conditional,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnCoerceCanUserAddOrDeleteRows,The conditional expression  "(canUserAddRowsProperty && !dataGrid.EditableItems.CanAddNew) ||                          (!canUserAddRowsProperty && !dataGrid.EditableItems.CanRemove)"  is complex.
Complex Conditional,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnLoadingRowDetailsWrapper,The conditional expression  "row != null &&                  row.DetailsLoaded == false &&                  row.DetailsVisibility == Visibility.Visible &&                  row.DetailsPresenter != null"  is complex.
Complex Conditional,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,NotifySelectedCellsChanged,The conditional expression  "((_pendingSelectedCells != null) && (_pendingSelectedCells.Count > 0)) ||                   ((_pendingUnselectedCells != null) && (_pendingUnselectedCells.Count > 0))"  is complex.
Complex Conditional,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,MakeCellSelection,The conditional expression  "(startIndex >= 0) && (endIndex >= 0) &&                          (startColumnIndex >= 0) && (endColumnIndex >= 0)"  is complex.
Complex Conditional,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnArrowKeyDown,The conditional expression  "navigateFromCellContainer ||                          ((startElement != null) && startElement.MoveFocus(request)) ||                          ((startContentElement != null) && startContentElement.MoveFocus(request))"  is complex.
Complex Conditional,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnTabKeyDown,The conditional expression  "((startElement != null) && startElement.MoveFocus(request)) ||                          ((startContentElement != null) && startContentElement.MoveFocus(request))"  is complex.
Complex Conditional,Microsoft.Windows.Controls,DataGridBoundColumn,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridBoundColumn.cs,RefreshCellContent,The conditional expression  "(string.Compare(propertyName' "Binding"' StringComparison.Ordinal) == 0) ||                      (string.Compare(propertyName' "ElementStyle"' StringComparison.Ordinal) == 0 && !isCellEditing) ||                      (string.Compare(propertyName' "EditingElementStyle"' StringComparison.Ordinal) == 0 && isCellEditing)"  is complex.
Complex Conditional,Microsoft.Windows.Controls,DataGridCell,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCell.cs,OnAnyMouseLeftButtonDown,The conditional expression  "focusWithin && !isCtrlKeyPressed && !e.Handled && !IsEditing && !IsReadOnly && IsSelected"  is complex.
Complex Conditional,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,MeasureChild,The conditional expression  "width.IsAuto ||                      (width.IsSizeToHeader && isColumnHeader) ||                      (width.IsSizeToCells && !isColumnHeader)"  is complex.
Complex Conditional,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,VirtualizeChildren,The conditional expression  "(cell != null && (cell.IsEditing || cell.IsKeyboardFocusWithin)) ||                      (cellsPresenter != null &&                      cellsPresenter.IsItemItsOwnContainerInternal(cellsPresenter.Items[columnIndex])) ||                      (headersPresenter != null &&                      headersPresenter.IsItemItsOwnContainerInternal(headersPresenter.Items[columnIndex]))"  is complex.
Complex Conditional,Microsoft.Windows.Controls,DataGridColumn,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumn.cs,GetConstraintWidth,The conditional expression  "width.IsAbsolute ||                   width.IsStar ||                  (width.IsSizeToCells && isHeader) ||                  (width.IsSizeToHeader && !isHeader)"  is complex.
Complex Conditional,Microsoft.Windows.Controls,DataGridColumn,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumn.cs,UpdateDesiredWidthForAutoColumn,The conditional expression  "width.IsAuto ||                   (width.IsSizeToCells && !isHeader) ||                  (width.IsSizeToHeader && isHeader)"  is complex.
Complex Conditional,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,UpdateDisplayIndexForReplacedColumn,The conditional expression  "oldColumns != null && oldColumns.Count > 0 && newColumns != null && newColumns.Count > 0"  is complex.
Complex Conditional,Microsoft.Windows.Controls,DataGridComboBoxColumn,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridComboBoxColumn.cs,RefreshCellContent,The conditional expression  "(string.Compare(propertyName' "ElementStyle"' StringComparison.Ordinal) == 0 && !isCellEditing) ||                      (string.Compare(propertyName' "EditingElementStyle"' StringComparison.Ordinal) == 0 && isCellEditing)"  is complex.
Complex Conditional,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The conditional expression  "isHovered && !isPressed && (size.Width >= 6.0) && (size.Height >= 4.0)"  is complex.
Complex Conditional,Microsoft.Windows.Controls,DataGridHelper,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHelper.cs,OnColumnWidthChanged,The conditional expression  "width.IsAuto ||                       (!isColumnHeader && width.IsSizeToCells) ||                      (isColumnHeader && width.IsSizeToHeader)"  is complex.
Complex Conditional,Microsoft.Windows.Controls,DataGridLength,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridLength.cs,DataGridLength,The conditional expression  "type != DataGridLengthUnitType.Auto &&                  type != DataGridLengthUnitType.Pixel &&                  type != DataGridLengthUnitType.Star &&                  type != DataGridLengthUnitType.SizeToCells &&                  type != DataGridLengthUnitType.SizeToHeader"  is complex.
Complex Conditional,Microsoft.Windows.Controls,DataGridRow,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridRow.cs,NotifyPropertyChanged,The conditional expression  "e.Property == DataGrid.RowBackgroundProperty || e.Property == DataGrid.AlternatingRowBackgroundProperty ||                      e.Property == BackgroundProperty || e.Property == AlternationIndexProperty"  is complex.
Complex Conditional,Microsoft.Windows.Controls,DataGridTemplateColumn,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridTemplateColumn.cs,RefreshCellContent,The conditional expression  "(!isCellEditing &&                          ((string.Compare(propertyName' "CellTemplate"' StringComparison.Ordinal) == 0) ||                          (string.Compare(propertyName' "CellTemplateSelector"' StringComparison.Ordinal) == 0))) ||                      (isCellEditing &&                          ((string.Compare(propertyName' "CellEditingTemplate"' StringComparison.Ordinal) == 0) ||                          (string.Compare(propertyName' "CellEditingTemplateSelector"' StringComparison.Ordinal) == 0)))"  is complex.
Complex Conditional,Microsoft.Windows.Controls,VirtualizedCellInfoCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\VirtualizedCellInfoCollection.cs,GetCellInfoFromIndex,The conditional expression  "(rowIndex >= 0) && (columnIndex >= 0) &&                  (rowIndex < owner.Items.Count) && (columnIndex < owner.Columns.Count)"  is complex.
Complex Conditional,Microsoft.Windows.Controls,WeakKeyComparer,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\WeakHashtable.cs,Equals,The conditional expression  "wX!= null && wY != null && !wY.IsAlive && !wX.IsAlive"  is complex.
Complex Conditional,Microsoft.Windows.Controls,DatePicker,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DatePicker\Microsoft\Windows\Controls\DatePicker.cs,CalendarDayOrMonthButton_PreviewKeyDown,The conditional expression  "args.Key == Key.Escape || ((args.Key == Key.Enter || args.Key == Key.Space) && c.DisplayMode == CalendarMode.Month)"  is complex.
Complex Conditional,Microsoft.Windows.Controls.Primitives,CalendarItem,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\CalendarItem.cs,EndDrag,The conditional expression  "ctrl &&                          DateTime.Compare(this.Owner.HoverStart.Value' selectedDate) == 0 &&                          (Owner.SelectionMode == CalendarSelectionMode.SingleDate || Owner.SelectionMode == CalendarSelectionMode.MultipleRange)"  is complex.
Complex Conditional,Microsoft.Windows.Controls.Primitives,CalendarItem,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\CalendarItem.cs,SetMonthModeCalendarDayButtons,The conditional expression  "(!isMinMonth || (dayOffset >= 0)) && (!isMaxMonth || (dayOffset < daysInMonth))"  is complex.
Complex Conditional,Microsoft.Windows.Controls.Primitives,DataGridCellsPresenter,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\Primitives\DataGridCellsPresenter.cs,NotifyPropertyChanged,The conditional expression  "e.Property == DataGrid.FrozenColumnCountProperty ||                      e.Property == DataGridColumn.VisibilityProperty ||                      e.Property == DataGrid.CellsPanelHorizontalOffsetProperty ||                      e.Property == DataGrid.HorizontalScrollOffsetProperty ||                      string.Compare(propertyName' "ViewportWidth"' StringComparison.Ordinal) == 0 ||                      string.Compare(propertyName' "DelayedColumnWidthComputation"' StringComparison.Ordinal) == 0"  is complex.
Complex Conditional,Microsoft.Windows.Controls.Primitives,DataGridColumnHeadersPresenter,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\Primitives\DataGridColumnHeadersPresenter.cs,NotifyPropertyChanged,The conditional expression  "e.Property == DataGrid.FrozenColumnCountProperty ||                      e.Property == DataGridColumn.VisibilityProperty ||                      e.Property == DataGrid.CellsPanelHorizontalOffsetProperty ||                      string.Compare(propertyName' "ViewportWidth"' StringComparison.Ordinal) == 0 ||                      string.Compare(propertyName' "DelayedColumnWidthComputation"' StringComparison.Ordinal) == 0"  is complex.
Complex Conditional,Microsoft.Windows.Controls.Primitives,DataGridRowHeader,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\Primitives\DataGridRowHeader.cs,SetTopGripperVisibility,The conditional expression  "dataGrid != null && parent != null &&                       dataGrid.CanUserResizeRows && dataGrid.Items.Count > 1 &&                      !object.ReferenceEquals(parent.Item' dataGrid.Items[0])"  is complex.
Complex Conditional,System.Windows,VisualStateManager,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\VSM\VisualStateManager\System\Windows\VisualStateManager.cs,GoToStateInternal,The conditional expression  "transition == null || (transition.GeneratedDuration == DurationZero &&                                              (transition.Storyboard == null || transition.Storyboard.Duration == DurationZero))"  is complex.
Complex Conditional,System.Windows,TimelineDataToken,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\VSM\VisualStateManager\System\Windows\VisualStateManager.cs,Equals,The conditional expression  "(other._target == _target) &&                      (other._targetName == _targetName) &&                       (other._targetProperty.Path == _targetProperty.Path) &&                      (other._targetProperty.PathParameters.Count == _targetProperty.PathParameters.Count)"  is complex.
Empty Catch Block,Microsoft.Windows.Controls,TypeHandlerFactory<TypeHandler>,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\VSM\VisualStateManager\Microsoft\Windows\Controls\TypeHandlerFactory.cs,GetGenericTypeDefinition,The method has an empty catch block.
Empty Catch Block,Microsoft.Windows.Controls,TypeHandlerFactory<TypeHandler>,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\VSM\VisualStateManager\Microsoft\Windows\Controls\TypeHandlerFactory.cs,GetGenericTypeDefinition,The method has an empty catch block.
Empty Catch Block,Microsoft.Windows.Controls,TypeHandlerFactory<TypeHandler>,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\VSM\VisualStateManager\Microsoft\Windows\Controls\TypeHandlerFactory.cs,GetGenericTypeDefinition,The method has an empty catch block.
Empty Catch Block,Microsoft.Windows.Controls,TypeHandlerFactory<TypeHandler>,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\VSM\VisualStateManager\Microsoft\Windows\Controls\TypeHandlerFactory.cs,GetGenericTypeDefinition,The method has an empty catch block.
Empty Catch Block,Microsoft.Windows.Controls,TypeHandlerFactory<TypeHandler>,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\VSM\VisualStateManager\Microsoft\Windows\Controls\TypeHandlerFactory.cs,GetGenericTypeDefinition,The method has an empty catch block.
Magic Number,Microsoft.Windows.Automation.Peers,CalendarAutomationPeer,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Automation\Peers\CalendarAutomationPeer.cs,GetSupportedViews,The following statement contains a magic number: int[] supportedViews = new int[3];
Magic Number,Microsoft.Windows.Automation.Peers,CalendarAutomationPeer,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Automation\Peers\CalendarAutomationPeer.cs,GetSupportedViews,The following statement contains a magic number: supportedViews[2] = (int)CalendarMode.Decade;
Magic Number,Microsoft.Windows.Automation.Peers,CalendarAutomationPeer,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Automation\Peers\CalendarAutomationPeer.cs,GetViewName,The following statement contains a magic number: switch (viewId)              {                  case 0:                      {                          return SR.Get(SRID.CalendarAutomationPeer_MonthMode);                      }                    case 1:                      {                          return SR.Get(SRID.CalendarAutomationPeer_YearMode);                      }                    case 2:                      {                          return SR.Get(SRID.CalendarAutomationPeer_DecadeMode);                      }              }
Magic Number,Microsoft.Windows.Automation.Peers,DataGridRowAutomationPeer,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Automation\Peers\DataGridRowAutomationPeer.cs,GetChildrenCore,The following statement contains a magic number: List<AutomationPeer> children = new List<AutomationPeer>(3);
Magic Number,Microsoft.Windows.Controls,Calendar,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\Calendar.cs,OnIsTodayHighlightedChanged,The following statement contains a magic number: if (i > -2 && i < 2)              {                  c.UpdateCellItems();              }
Magic Number,Microsoft.Windows.Controls,Calendar,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\Calendar.cs,OnIsTodayHighlightedChanged,The following statement contains a magic number: if (i > -2 && i < 2)              {                  c.UpdateCellItems();              }
Magic Number,Microsoft.Windows.Controls,Calendar,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\Calendar.cs,ProcessEndKey,The following statement contains a magic number: switch (this.DisplayMode)              {                  case CalendarMode.Month:                  {                      if (this.DisplayDate != null)                      {                          DateTime? selectedDate = new DateTime(this.DisplayDateInternal.Year' this.DisplayDateInternal.Month' 1);                            if (DateTimeHelper.CompareYearMonth(DateTime.MaxValue' selectedDate.Value) > 0)                          {                              // since DisplayDate is not equal to DateTime.MaxValue we are sure selectedDate is not null                              selectedDate = DateTimeHelper.AddMonths(selectedDate.Value' 1).Value;                              selectedDate = DateTimeHelper.AddDays(selectedDate.Value' -1).Value;                          }                          else                          {                              selectedDate = DateTime.MaxValue;                          }                            ProcessSelection(shift' selectedDate);                      }                        break;                  }                    case CalendarMode.Year:                  {                      DateTime selectedMonth = new DateTime(this.DisplayDate.Year' 12' 1);                      OnSelectedMonthChanged(selectedMonth);                      break;                  }                    case CalendarMode.Decade:                  {                      DateTime? selectedYear = new DateTime(DateTimeHelper.EndOfDecade(this.DisplayDate)' 1' 1);                      OnSelectedYearChanged(selectedYear);                      break;                  }              }
Magic Number,Microsoft.Windows.Controls,Calendar,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\Calendar.cs,ProcessPageDownKey,The following statement contains a magic number: switch (this.DisplayMode)              {                  case CalendarMode.Month:                  {                      DateTime? selectedDate = this._blackoutDates.GetNonBlackoutDate(DateTimeHelper.AddMonths(this.CurrentDate' 1)' 1);                      ProcessSelection(shift' selectedDate);                      break;                  }                    case CalendarMode.Year:                  {                      DateTime? selectedMonth = DateTimeHelper.AddYears(this.DisplayDate' 1);                      OnSelectedMonthChanged(selectedMonth);                      break;                  }                    case CalendarMode.Decade:                  {                      DateTime? selectedYear = DateTimeHelper.AddYears(this.DisplayDate' 10);                      OnSelectedYearChanged(selectedYear);                      break;                  }              }
Magic Number,Microsoft.Windows.Controls,Calendar,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\Calendar.cs,ProcessPageUpKey,The following statement contains a magic number: switch (this.DisplayMode)              {                  case CalendarMode.Month:                  {                      DateTime? selectedDate = this._blackoutDates.GetNonBlackoutDate(DateTimeHelper.AddMonths(this.CurrentDate' -1)' -1);                      ProcessSelection(shift' selectedDate);                      break;                  }                    case CalendarMode.Year:                  {                      DateTime? selectedMonth = DateTimeHelper.AddYears(this.DisplayDate' -1);                      OnSelectedMonthChanged(selectedMonth);                      break;                  }                    case CalendarMode.Decade:                  {                      DateTime? selectedYear = DateTimeHelper.AddYears(this.DisplayDate' -10);                      OnSelectedYearChanged(selectedYear);                      break;                  }              }
Magic Number,Microsoft.Windows.Controls,DateTimeHelper,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\DateTimeHelper.cs,CompareYearMonth,The following statement contains a magic number: return ((dt1.Year - dt2.Year) * 12) + (dt1.Month - dt2.Month);
Magic Number,Microsoft.Windows.Controls,DateTimeHelper,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\DateTimeHelper.cs,DecadeOfDate,The following statement contains a magic number: return date.Year - (date.Year % 10);
Magic Number,Microsoft.Windows.Controls,DateTimeHelper,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\DateTimeHelper.cs,EndOfDecade,The following statement contains a magic number: return DecadeOfDate(date) + 9;
Magic Number,Microsoft.Windows.Controls,DateTimeHelper,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\DateTimeHelper.cs,ToDecadeRangeString,The following statement contains a magic number: if (format != null)              {                  int decadeEnd = decade + 9;                  result = decade.ToString(format) + "-" + decadeEnd.ToString(format);              }
Magic Number,Microsoft.Windows.Controls,SelectedDatesCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\SelectedDatesCollection.cs,InsertItem,The following statement contains a magic number: if (!this.Contains(item))              {                  Collection<DateTime> addedItems = new Collection<DateTime>();                    bool isCleared = CheckSelectionMode();                    if (Calendar.IsValidDateSelection(this._owner' item))                  {                      // If the Collection is cleared since it is SingleRange and it had another range                      // set the index to 0                      if (isCleared)                      {                          index = 0;                          isCleared = false;                      }                        base.InsertItem(index' item);                      UpdateMinMax(item);                        // The event fires after SelectedDate changes                      if (index == 0 && !(this._owner.SelectedDate.HasValue && DateTime.Compare(this._owner.SelectedDate.Value' item) == 0))                      {                          this._owner.SelectedDate = item;                      }                        if (!_isAddingRange)                      {                          addedItems.Add(item);                            RaiseSelectionChanged(this._removedItems' addedItems);                          this._removedItems.Clear();                          int monthDifference = DateTimeHelper.CompareYearMonth(item' this._owner.DisplayDateInternal);                            if (monthDifference < 2 && monthDifference > -2)                          {                              this._owner.UpdateCellItems();                          }                      }                      else                      {                          this._addedItems.Add(item);                      }                  }                  else                  {                      throw new ArgumentOutOfRangeException(SR.Get(SRID.Calendar_OnSelectedDateChanged_InvalidValue));                  }              }
Magic Number,Microsoft.Windows.Controls,SelectedDatesCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\SelectedDatesCollection.cs,InsertItem,The following statement contains a magic number: if (!this.Contains(item))              {                  Collection<DateTime> addedItems = new Collection<DateTime>();                    bool isCleared = CheckSelectionMode();                    if (Calendar.IsValidDateSelection(this._owner' item))                  {                      // If the Collection is cleared since it is SingleRange and it had another range                      // set the index to 0                      if (isCleared)                      {                          index = 0;                          isCleared = false;                      }                        base.InsertItem(index' item);                      UpdateMinMax(item);                        // The event fires after SelectedDate changes                      if (index == 0 && !(this._owner.SelectedDate.HasValue && DateTime.Compare(this._owner.SelectedDate.Value' item) == 0))                      {                          this._owner.SelectedDate = item;                      }                        if (!_isAddingRange)                      {                          addedItems.Add(item);                            RaiseSelectionChanged(this._removedItems' addedItems);                          this._removedItems.Clear();                          int monthDifference = DateTimeHelper.CompareYearMonth(item' this._owner.DisplayDateInternal);                            if (monthDifference < 2 && monthDifference > -2)                          {                              this._owner.UpdateCellItems();                          }                      }                      else                      {                          this._addedItems.Add(item);                      }                  }                  else                  {                      throw new ArgumentOutOfRangeException(SR.Get(SRID.Calendar_OnSelectedDateChanged_InvalidValue));                  }              }
Magic Number,Microsoft.Windows.Controls,SelectedDatesCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\SelectedDatesCollection.cs,RemoveItem,The following statement contains a magic number: if (index >= this.Count)              {                  base.RemoveItem(index);                  ClearMinMax();              }              else              {                  Collection<DateTime> addedItems = new Collection<DateTime>();                  Collection<DateTime> removedItems = new Collection<DateTime>();                  int monthDifference = DateTimeHelper.CompareYearMonth(this[index]' this._owner.DisplayDateInternal);                    removedItems.Add(this[index]);                  base.RemoveItem(index);                  ClearMinMax();                    // The event fires after SelectedDate changes                  if (index == 0)                  {                      if (Count > 0)                      {                          this._owner.SelectedDate = this[0];                      }                      else                      {                          this._owner.SelectedDate = null;                      }                  }                    RaiseSelectionChanged(removedItems' addedItems);                    if (monthDifference < 2 && monthDifference > -2)                  {                      this._owner.UpdateCellItems();                  }              }
Magic Number,Microsoft.Windows.Controls,SelectedDatesCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\SelectedDatesCollection.cs,RemoveItem,The following statement contains a magic number: if (index >= this.Count)              {                  base.RemoveItem(index);                  ClearMinMax();              }              else              {                  Collection<DateTime> addedItems = new Collection<DateTime>();                  Collection<DateTime> removedItems = new Collection<DateTime>();                  int monthDifference = DateTimeHelper.CompareYearMonth(this[index]' this._owner.DisplayDateInternal);                    removedItems.Add(this[index]);                  base.RemoveItem(index);                  ClearMinMax();                    // The event fires after SelectedDate changes                  if (index == 0)                  {                      if (Count > 0)                      {                          this._owner.SelectedDate = this[0];                      }                      else                      {                          this._owner.SelectedDate = null;                      }                  }                    RaiseSelectionChanged(removedItems' addedItems);                    if (monthDifference < 2 && monthDifference > -2)                  {                      this._owner.UpdateCellItems();                  }              }
Magic Number,Microsoft.Windows.Controls,SelectedDatesCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\SelectedDatesCollection.cs,SetItem,The following statement contains a magic number: if (!this.Contains(item))              {                  Collection<DateTime> addedItems = new Collection<DateTime>();                  Collection<DateTime> removedItems = new Collection<DateTime>();                    if (index >= this.Count)                  {                      base.SetItem(index' item);                      UpdateMinMax(item);                  }                  else                  {                      if (item != null && DateTime.Compare(this[index]' item) != 0 && Calendar.IsValidDateSelection(this._owner' item))                      {                          removedItems.Add(this[index]);                          base.SetItem(index' item);                          UpdateMinMax(item);                            addedItems.Add(item);                            // The event fires after SelectedDate changes                          if (index == 0 && !(this._owner.SelectedDate.HasValue && DateTime.Compare(this._owner.SelectedDate.Value' item) == 0))                          {                              this._owner.SelectedDate = item;                          }                            RaiseSelectionChanged(removedItems' addedItems);                            int monthDifference = DateTimeHelper.CompareYearMonth(item' this._owner.DisplayDateInternal);                            if (monthDifference < 2 && monthDifference > -2)                          {                              this._owner.UpdateCellItems();                          }                      }                  }              }
Magic Number,Microsoft.Windows.Controls,SelectedDatesCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\SelectedDatesCollection.cs,SetItem,The following statement contains a magic number: if (!this.Contains(item))              {                  Collection<DateTime> addedItems = new Collection<DateTime>();                  Collection<DateTime> removedItems = new Collection<DateTime>();                    if (index >= this.Count)                  {                      base.SetItem(index' item);                      UpdateMinMax(item);                  }                  else                  {                      if (item != null && DateTime.Compare(this[index]' item) != 0 && Calendar.IsValidDateSelection(this._owner' item))                      {                          removedItems.Add(this[index]);                          base.SetItem(index' item);                          UpdateMinMax(item);                            addedItems.Add(item);                            // The event fires after SelectedDate changes                          if (index == 0 && !(this._owner.SelectedDate.HasValue && DateTime.Compare(this._owner.SelectedDate.Value' item) == 0))                          {                              this._owner.SelectedDate = item;                          }                            RaiseSelectionChanged(removedItems' addedItems);                            int monthDifference = DateTimeHelper.CompareYearMonth(item' this._owner.DisplayDateInternal);                            if (monthDifference < 2 && monthDifference > -2)                          {                              this._owner.UpdateCellItems();                          }                      }                  }              }
Magic Number,Microsoft.Windows.Controls,ClipboardHelper,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\ClipboardHelper.cs,GetClipboardContentForHtml,The following statement contains a magic number: int bytecountEndOfFragment = 135 + content.Length;
Magic Number,Microsoft.Windows.Controls,ClipboardHelper,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\ClipboardHelper.cs,GetClipboardContentForHtml,The following statement contains a magic number: int bytecountEndOfHtml = bytecountEndOfFragment + 36;
Magic Number,Microsoft.Windows.Controls,ClipboardHelper,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\ClipboardHelper.cs,FormatPlainTextAsHtml,The following statement contains a magic number: for (int i = 0; i < cb; i++)              {                  char ch = s[i];                  switch (ch)                  {                      case '<':                          output.Write("&lt;");                          break;                      case '>':                          output.Write("&gt;");                          break;                      case '"':                          output.Write("&quot;");                          break;                      case '&':                          output.Write("&amp;");                          break;                      case ' ':                          if (prevCh == ' ')                          {                              output.Write("&nbsp;");                          }                          else                          {                              output.Write(ch);                          }                            break;                      case '\r':                          // Ignore \r' only handle \n                          break;                      case '\n':                          output.Write("<br>");                          break;                        // REVIEW: what to do with tabs?  See original code in xsp\System\Web\httpserverutility.cs                      default:                          // The seemingly arbitrary 160 comes from RFC                          if (ch >= 160 && ch < 256)                          {                              output.Write("&#");                              output.Write(((int)ch).ToString(NumberFormatInfo.InvariantInfo));                              output.Write(';');                          }                          else                          {                              output.Write(ch);                          }                            break;                  }                    prevCh = ch;              }
Magic Number,Microsoft.Windows.Controls,ClipboardHelper,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\ClipboardHelper.cs,FormatPlainTextAsHtml,The following statement contains a magic number: for (int i = 0; i < cb; i++)              {                  char ch = s[i];                  switch (ch)                  {                      case '<':                          output.Write("&lt;");                          break;                      case '>':                          output.Write("&gt;");                          break;                      case '"':                          output.Write("&quot;");                          break;                      case '&':                          output.Write("&amp;");                          break;                      case ' ':                          if (prevCh == ' ')                          {                              output.Write("&nbsp;");                          }                          else                          {                              output.Write(ch);                          }                            break;                      case '\r':                          // Ignore \r' only handle \n                          break;                      case '\n':                          output.Write("<br>");                          break;                        // REVIEW: what to do with tabs?  See original code in xsp\System\Web\httpserverutility.cs                      default:                          // The seemingly arbitrary 160 comes from RFC                          if (ch >= 160 && ch < 256)                          {                              output.Write("&#");                              output.Write(((int)ch).ToString(NumberFormatInfo.InvariantInfo));                              output.Write(';');                          }                          else                          {                              output.Write(ch);                          }                            break;                  }                    prevCh = ch;              }
Magic Number,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnCoerceAlternationCount,The following statement contains a magic number: if (((int)baseValue) < 2)              {                  DataGrid dataGrid = (DataGrid)d;                  if (dataGrid.AlternatingRowBackground != null)                  {                      // There is an alternate background' coerce to 2.                      return 2;                  }              }
Magic Number,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnCoerceAlternationCount,The following statement contains a magic number: if (((int)baseValue) < 2)              {                  DataGrid dataGrid = (DataGrid)d;                  if (dataGrid.AlternatingRowBackground != null)                  {                      // There is an alternate background' coerce to 2.                      return 2;                  }              }
Magic Number,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnExecutedBeginEdit,The following statement contains a magic number: if ((cell != null) && !cell.IsReadOnly && !cell.IsEditing)              {                  bool addedPlaceholder = false;                  bool deselectedPlaceholder = false;                  bool reselectPlaceholderCells = false;                  List<int> columnIndexRanges = null;                  int newItemIndex = -1;                  object newItem = null;                  bool placeholderAtBeginning = (EditableItems.NewItemPlaceholderPosition == NewItemPlaceholderPosition.AtBeginning);                    if (IsNewItemPlaceholder(cell.RowDataItem))                  {                      // If editing the new item placeholder' then create a new item and edit that instead.                      if (SelectedItems.Contains(CollectionView.NewItemPlaceholder))                      {                          // Unselect the NewItemPlaceholder and select the new row                          UnselectItem(CollectionView.NewItemPlaceholder);                          deselectedPlaceholder = true;                      }                      else                      {                          // Cells will automatically unselect when the new item placeholder is removed' but we                          // should reselect them on the new item.                          newItemIndex = Items.IndexOf(cell.RowDataItem);                          reselectPlaceholderCells = ((newItemIndex >= 0) && _selectedCells.Intersects(newItemIndex' out columnIndexRanges));                      }                        newItem = AddNewItem();                      CurrentItem = newItem; // Puts focus on the added row                      cell = CurrentCellContainer;                      if (CurrentCellContainer == null)                      {                          // CurrentCellContainer becomes null if focus moves out of the datagrid                          // Calling UpdateLayout instantiates the CurrentCellContainer                          UpdateLayout();                          cell = CurrentCellContainer;                          if ((cell != null) && !cell.IsKeyboardFocusWithin)                          {                              cell.Focus();                          }                      }                        if (deselectedPlaceholder)                      {                          // Re-select the new item if the placeholder was selected before                          SelectItem(newItem);                      }                      else if (reselectPlaceholderCells)                      {                          // Re-select placeholder cells if they were selected before                          using (UpdateSelectedCells())                          {                              int rowIndex = newItemIndex;                                // When the placeholder is at the beginning' we don't hide it' so those cells need to be unselected.                              // The cells to select are also now one row below.                              if (placeholderAtBeginning)                              {                                  _selectedCells.RemoveRegion(newItemIndex' 0' 1' Columns.Count);                                  rowIndex++;                              }                                for (int i = 0' count = columnIndexRanges.Count; i < count; i += 2)                              {                                  _selectedCells.AddRegion(rowIndex' columnIndexRanges[i]' 1' columnIndexRanges[i + 1]);                              }                          }                      }                        addedPlaceholder = true;                  }                    RoutedEventArgs editingEventArgs = e.Parameter as RoutedEventArgs;                  DataGridBeginningEditEventArgs beginningEditEventArgs = null;                    if (cell != null)                  {                      // Give the callback an opportunity to cancel edit mode                      beginningEditEventArgs = new DataGridBeginningEditEventArgs(cell.Column' cell.RowOwner' editingEventArgs);                      OnBeginningEdit(beginningEditEventArgs);                  }                    if ((cell == null) || beginningEditEventArgs.Cancel)                  {                      // If CurrentCellContainer is null then cancel editing                      if (deselectedPlaceholder)                      {                          // If the new item placeholder was deselected and the new item was selected'                          // de-select the new item. Selecting the new item placeholder comes at the end.                          // This is to accomodate the scenario where the new item placeholder only appears                          // when not editing a new item.                          UnselectItem(newItem);                      }                      else if (reselectPlaceholderCells && placeholderAtBeginning)                      {                          // When the placeholder is at the beginning' we need to unselect the added item cells.                          _selectedCells.RemoveRegion(newItemIndex + 1' 0' 1' Columns.Count);                      }                        if (addedPlaceholder)                      {                          // The edit was canceled' cancel the new item                          CancelRowItem();                            // Display the new item placeholder again                          UpdateNewItemPlaceholder(/* isAddingNewItem = */ false);                            // Put focus back on the placeholder                          SetCurrentItemToPlaceholder();                      }                        if (deselectedPlaceholder)                      {                          // If the new item placeholder was deselected' then select it again.                          SelectItem(CollectionView.NewItemPlaceholder);                      }                      else if (reselectPlaceholderCells)                      {                          for (int i = 0' count = columnIndexRanges.Count; i < count; i += 2)                          {                              _selectedCells.AddRegion(newItemIndex' columnIndexRanges[i]' 1' columnIndexRanges[i + 1]);                          }                      }                  }                  else                  {                      if (!addedPlaceholder && !IsEditingRowItem)                      {                          EditRowItem(cell.RowDataItem);                                                    var bindingGroup = cell.RowOwner.BindingGroup;                          if (bindingGroup != null)                          {                              bindingGroup.BeginEdit();                          }                            _editingRowItem = cell.RowDataItem;                          _editingRowIndex = Items.IndexOf(_editingRowItem);                      }                        cell.BeginEdit(editingEventArgs);                      cell.RowOwner.IsEditing = true;                  }              }
Magic Number,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnExecutedBeginEdit,The following statement contains a magic number: if ((cell != null) && !cell.IsReadOnly && !cell.IsEditing)              {                  bool addedPlaceholder = false;                  bool deselectedPlaceholder = false;                  bool reselectPlaceholderCells = false;                  List<int> columnIndexRanges = null;                  int newItemIndex = -1;                  object newItem = null;                  bool placeholderAtBeginning = (EditableItems.NewItemPlaceholderPosition == NewItemPlaceholderPosition.AtBeginning);                    if (IsNewItemPlaceholder(cell.RowDataItem))                  {                      // If editing the new item placeholder' then create a new item and edit that instead.                      if (SelectedItems.Contains(CollectionView.NewItemPlaceholder))                      {                          // Unselect the NewItemPlaceholder and select the new row                          UnselectItem(CollectionView.NewItemPlaceholder);                          deselectedPlaceholder = true;                      }                      else                      {                          // Cells will automatically unselect when the new item placeholder is removed' but we                          // should reselect them on the new item.                          newItemIndex = Items.IndexOf(cell.RowDataItem);                          reselectPlaceholderCells = ((newItemIndex >= 0) && _selectedCells.Intersects(newItemIndex' out columnIndexRanges));                      }                        newItem = AddNewItem();                      CurrentItem = newItem; // Puts focus on the added row                      cell = CurrentCellContainer;                      if (CurrentCellContainer == null)                      {                          // CurrentCellContainer becomes null if focus moves out of the datagrid                          // Calling UpdateLayout instantiates the CurrentCellContainer                          UpdateLayout();                          cell = CurrentCellContainer;                          if ((cell != null) && !cell.IsKeyboardFocusWithin)                          {                              cell.Focus();                          }                      }                        if (deselectedPlaceholder)                      {                          // Re-select the new item if the placeholder was selected before                          SelectItem(newItem);                      }                      else if (reselectPlaceholderCells)                      {                          // Re-select placeholder cells if they were selected before                          using (UpdateSelectedCells())                          {                              int rowIndex = newItemIndex;                                // When the placeholder is at the beginning' we don't hide it' so those cells need to be unselected.                              // The cells to select are also now one row below.                              if (placeholderAtBeginning)                              {                                  _selectedCells.RemoveRegion(newItemIndex' 0' 1' Columns.Count);                                  rowIndex++;                              }                                for (int i = 0' count = columnIndexRanges.Count; i < count; i += 2)                              {                                  _selectedCells.AddRegion(rowIndex' columnIndexRanges[i]' 1' columnIndexRanges[i + 1]);                              }                          }                      }                        addedPlaceholder = true;                  }                    RoutedEventArgs editingEventArgs = e.Parameter as RoutedEventArgs;                  DataGridBeginningEditEventArgs beginningEditEventArgs = null;                    if (cell != null)                  {                      // Give the callback an opportunity to cancel edit mode                      beginningEditEventArgs = new DataGridBeginningEditEventArgs(cell.Column' cell.RowOwner' editingEventArgs);                      OnBeginningEdit(beginningEditEventArgs);                  }                    if ((cell == null) || beginningEditEventArgs.Cancel)                  {                      // If CurrentCellContainer is null then cancel editing                      if (deselectedPlaceholder)                      {                          // If the new item placeholder was deselected and the new item was selected'                          // de-select the new item. Selecting the new item placeholder comes at the end.                          // This is to accomodate the scenario where the new item placeholder only appears                          // when not editing a new item.                          UnselectItem(newItem);                      }                      else if (reselectPlaceholderCells && placeholderAtBeginning)                      {                          // When the placeholder is at the beginning' we need to unselect the added item cells.                          _selectedCells.RemoveRegion(newItemIndex + 1' 0' 1' Columns.Count);                      }                        if (addedPlaceholder)                      {                          // The edit was canceled' cancel the new item                          CancelRowItem();                            // Display the new item placeholder again                          UpdateNewItemPlaceholder(/* isAddingNewItem = */ false);                            // Put focus back on the placeholder                          SetCurrentItemToPlaceholder();                      }                        if (deselectedPlaceholder)                      {                          // If the new item placeholder was deselected' then select it again.                          SelectItem(CollectionView.NewItemPlaceholder);                      }                      else if (reselectPlaceholderCells)                      {                          for (int i = 0' count = columnIndexRanges.Count; i < count; i += 2)                          {                              _selectedCells.AddRegion(newItemIndex' columnIndexRanges[i]' 1' columnIndexRanges[i + 1]);                          }                      }                  }                  else                  {                      if (!addedPlaceholder && !IsEditingRowItem)                      {                          EditRowItem(cell.RowDataItem);                                                    var bindingGroup = cell.RowOwner.BindingGroup;                          if (bindingGroup != null)                          {                              bindingGroup.BeginEdit();                          }                            _editingRowItem = cell.RowDataItem;                          _editingRowIndex = Items.IndexOf(_editingRowItem);                      }                        cell.BeginEdit(editingEventArgs);                      cell.RowOwner.IsEditing = true;                  }              }
Magic Number,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,CancelRowItem,The following statement contains a magic number: if (IsEditingRowItem)              {                  EditableItems.CancelEdit();              }              else              {                  object currentAddItem = EditableItems.CurrentAddItem;                  bool wasCurrent = currentAddItem == CurrentItem;                  bool wasSelected = SelectedItems.Contains(currentAddItem);                  bool reselectPlaceholderCells = false;                  List<int> columnIndexRanges = null;                  int newItemIndex = -1;                    if (wasSelected)                  {                      // Unselect the item that was being added                      UnselectItem(currentAddItem);                  }                  else                  {                      // Cells will automatically unselect when the new item is removed' but we                      // should reselect them on the placeholder.                      newItemIndex = Items.IndexOf(currentAddItem);                      reselectPlaceholderCells = ((newItemIndex >= 0) && _selectedCells.Intersects(newItemIndex' out columnIndexRanges));                  }                    // Cancel the add and remove it from the collection                  EditableItems.CancelNew();                    // Show the placeholder again                  UpdateNewItemPlaceholder(/* isAddingNewItem = */ false);                    if (wasCurrent)                  {                      // Focus the placeholder if the new item had focus                      CurrentItem = CollectionView.NewItemPlaceholder;                  }                    if (wasSelected)                  {                      // Re-select the placeholder if it was selected before                      SelectItem(CollectionView.NewItemPlaceholder);                  }                  else if (reselectPlaceholderCells)                  {                      // Re-select placeholder cells if they were selected before                      using (UpdateSelectedCells())                      {                          int rowIndex = newItemIndex;                          bool placeholderAtBeginning = (EditableItems.NewItemPlaceholderPosition == NewItemPlaceholderPosition.AtBeginning);                            // When the placeholder is at the beginning' we need to unselect the cells                           // in the added row and move those back to the previous row.                          if (placeholderAtBeginning)                          {                              _selectedCells.RemoveRegion(newItemIndex' 0' 1' Columns.Count);                              rowIndex--;                          }                            for (int i = 0' count = columnIndexRanges.Count; i < count; i += 2)                          {                              _selectedCells.AddRegion(rowIndex' columnIndexRanges[i]' 1' columnIndexRanges[i + 1]);                          }                      }                  }              }
Magic Number,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,UpdateIsSelected,The following statement contains a magic number: if (cells != null)              {                  int numCells = cells.Count;                  if (numCells > 0)                  {                      // Determine if it would be better to iterate through all the visible cells                      // instead of through the update list.                      bool useTracker = false;                                            // For "small" updates it's simpler to just go through the cells' get the container'                      // and update IsSelected. For "large" updates' it's faster to go through the visible                      // cells' see if they're in the collection' and then update IsSelected.                      // Determining small vs. large is going to be done using a magic number.                      // 750 is close to the number of visible cells Excel shows by default on a 1280x1024 monitor.                      if (numCells > 750)                      {                          int numTracker = 0;                          int numColumns = _columns.Count;                            ContainerTracking<DataGridRow> rowTracker = _rowTrackingRoot;                          while (rowTracker != null)                          {                              numTracker += numColumns;                              if (numTracker >= numCells)                              {                                  // There are more cells visible than being updated                                  break;                              }                                                     rowTracker = rowTracker.Next;                          }                            useTracker = (numCells > numTracker);                      }                        if (useTracker)                      {                          ContainerTracking<DataGridRow> rowTracker = _rowTrackingRoot;                          while (rowTracker != null)                          {                              DataGridRow row = rowTracker.Container;                              DataGridCellsPresenter cellsPresenter = row.CellsPresenter;                              if (cellsPresenter != null)                              {                                  ContainerTracking<DataGridCell> cellTracker = cellsPresenter.CellTrackingRoot;                                  while (cellTracker != null)                                  {                                      DataGridCell cell = cellTracker.Container;                                      DataGridCellInfo cellInfo = new DataGridCellInfo(cell);                                      if (cells.Contains(cellInfo))                                      {                                          cell.SyncIsSelected(isSelected);                                      }                                        cellTracker = cellTracker.Next;                                  }                              }                                rowTracker = rowTracker.Next;                          }                      }                      else                      {                          foreach (DataGridCellInfo cellInfo in cells)                          {                              DataGridCell cell = TryFindCell(cellInfo);                              if (cell != null)                              {                                  cell.SyncIsSelected(isSelected);                              }                          }                      }                  }              }
Magic Number,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,CalculateCellDistance,The following statement contains a magic number: if (itemsHostBounds.Contains(transform.TransformBounds(cellBounds)))              {                  Point pt = Mouse.GetPosition(cell);                  if (isMouseInCorner)                  {                      // When the mouse is in the corner' go by distance from center of the cell                      Vector v = new Vector(pt.X - (cellBounds.Width * 0.5)' pt.Y - (cellBounds.Height * 0.5));                      distance = v.Length;                      return true;                  }                  else                  {                      Point rowPt = Mouse.GetPosition(rowOwner);                      Rect rowBounds = new Rect(new Point()' rowOwner.RenderSize);                        // The mouse should overlap a row or column                      if ((pt.X >= cellBounds.Left) && (pt.X <= cellBounds.Right))                      {                          // The mouse is within a column                          if ((rowPt.Y >= rowBounds.Top) && (rowPt.Y <= rowBounds.Bottom))                          {                              // Mouse is within the cell                              distance = 0.0;                          }                          else                          {                              // Mouse is outside but is within a columns horizontal bounds                              distance = Math.Abs(pt.Y - cellBounds.Top);                          }                            return true;                      }                      else if ((rowPt.Y >= rowBounds.Top) && (rowPt.Y <= rowBounds.Bottom))                      {                          // Mouse is outside but is within a row's vertical bounds                          distance = Math.Abs(pt.X - cellBounds.Left);                          return true;                      }                  }              }
Magic Number,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,CalculateCellDistance,The following statement contains a magic number: if (itemsHostBounds.Contains(transform.TransformBounds(cellBounds)))              {                  Point pt = Mouse.GetPosition(cell);                  if (isMouseInCorner)                  {                      // When the mouse is in the corner' go by distance from center of the cell                      Vector v = new Vector(pt.X - (cellBounds.Width * 0.5)' pt.Y - (cellBounds.Height * 0.5));                      distance = v.Length;                      return true;                  }                  else                  {                      Point rowPt = Mouse.GetPosition(rowOwner);                      Rect rowBounds = new Rect(new Point()' rowOwner.RenderSize);                        // The mouse should overlap a row or column                      if ((pt.X >= cellBounds.Left) && (pt.X <= cellBounds.Right))                      {                          // The mouse is within a column                          if ((rowPt.Y >= rowBounds.Top) && (rowPt.Y <= rowBounds.Bottom))                          {                              // Mouse is within the cell                              distance = 0.0;                          }                          else                          {                              // Mouse is outside but is within a columns horizontal bounds                              distance = Math.Abs(pt.Y - cellBounds.Top);                          }                            return true;                      }                      else if ((rowPt.Y >= rowBounds.Top) && (rowPt.Y <= rowBounds.Bottom))                      {                          // Mouse is outside but is within a row's vertical bounds                          distance = Math.Abs(pt.X - cellBounds.Left);                          return true;                      }                  }              }
Magic Number,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,DataGridColumnCollection,The following statement contains a magic number: DisplayIndexMap = new List<int>(5);
Magic Number,Microsoft.Windows.Controls,DataGridColumnDropSeparator,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnDropSeparator.cs,OnCoerceWidth,The following statement contains a magic number: if (DoubleUtil.IsNaN(width))              {                  return 2.0;              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (horizontal)              {                  // When horizontal' rotate the rendering by -90 degrees                  Matrix m1 = new Matrix();                  m1.RotateAt(-90.0' 0.0' 0.0);                  Matrix m2 = new Matrix();                  m2.Translate(0.0' size.Height);                    MatrixTransform horizontalRotate = new MatrixTransform(m1 * m2);                  horizontalRotate.Freeze();                  dc.PushTransform(horizontalRotate);                    double temp = size.Width;                  size.Width = size.Height;                  size.Height = temp;              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (hasBevel)              {                  // This is a highlight that can be drawn by just filling the background with the color.                  // It will be seen through the gab between the border and the background.                  LinearGradientBrush bevel = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.NormalBevel);                  if (bevel == null)                  {                      bevel = new LinearGradientBrush();                      bevel.StartPoint = new Point();                      bevel.EndPoint = new Point(0.0' 1.0);                      bevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFF' 0xFF' 0xFF)' 0.0));                      bevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFF' 0xFF' 0xFF)' 0.4));                      bevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFC' 0xFC' 0xFD)' 0.4));                      bevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFB' 0xFC' 0xFC)' 1.0));                      bevel.Freeze();                        CacheFreezable(bevel' (int)AeroFreezables.NormalBevel);                  }                    dc.DrawRectangle(bevel' null' new Rect(0.0' 0.0' size.Width' size.Height));              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (hasBevel)              {                  // This is a highlight that can be drawn by just filling the background with the color.                  // It will be seen through the gab between the border and the background.                  LinearGradientBrush bevel = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.NormalBevel);                  if (bevel == null)                  {                      bevel = new LinearGradientBrush();                      bevel.StartPoint = new Point();                      bevel.EndPoint = new Point(0.0' 1.0);                      bevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFF' 0xFF' 0xFF)' 0.0));                      bevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFF' 0xFF' 0xFF)' 0.4));                      bevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFC' 0xFC' 0xFD)' 0.4));                      bevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFB' 0xFC' 0xFC)' 1.0));                      bevel.Freeze();                        CacheFreezable(bevel' (int)AeroFreezables.NormalBevel);                  }                    dc.DrawRectangle(bevel' null' new Rect(0.0' 0.0' size.Width' size.Height));              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (background == null)              {                  background = new LinearGradientBrush();                  background.StartPoint = new Point();                  background.EndPoint = new Point(0.0' 1.0);                    switch (backgroundType)                  {                      case AeroFreezables.NormalBackground:                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFF' 0xFF' 0xFF)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFF' 0xFF' 0xFF)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF7' 0xF8' 0xFA)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF1' 0xF2' 0xF4)' 1.0));                          break;                        case AeroFreezables.PressedBackground:                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBC' 0xE4' 0xF9)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBC' 0xE4' 0xF9)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x8D' 0xD6' 0xF7)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x8A' 0xD1' 0xF5)' 1.0));                          break;                        case AeroFreezables.HoveredBackground:                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0xF7' 0xFF)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0xF7' 0xFF)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBD' 0xED' 0xFF)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xB7' 0xE7' 0xFB)' 1.0));                          break;                        case AeroFreezables.SortedBackground:                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF2' 0xF9' 0xFC)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF2' 0xF9' 0xFC)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE1' 0xF1' 0xF9)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xD8' 0xEC' 0xF6)' 1.0));                          break;                  }                    background.Freeze();                    CacheFreezable(background' (int)backgroundType);              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (background == null)              {                  background = new LinearGradientBrush();                  background.StartPoint = new Point();                  background.EndPoint = new Point(0.0' 1.0);                    switch (backgroundType)                  {                      case AeroFreezables.NormalBackground:                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFF' 0xFF' 0xFF)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFF' 0xFF' 0xFF)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF7' 0xF8' 0xFA)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF1' 0xF2' 0xF4)' 1.0));                          break;                        case AeroFreezables.PressedBackground:                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBC' 0xE4' 0xF9)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBC' 0xE4' 0xF9)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x8D' 0xD6' 0xF7)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x8A' 0xD1' 0xF5)' 1.0));                          break;                        case AeroFreezables.HoveredBackground:                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0xF7' 0xFF)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0xF7' 0xFF)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBD' 0xED' 0xFF)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xB7' 0xE7' 0xFB)' 1.0));                          break;                        case AeroFreezables.SortedBackground:                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF2' 0xF9' 0xFC)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF2' 0xF9' 0xFC)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE1' 0xF1' 0xF9)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xD8' 0xEC' 0xF6)' 1.0));                          break;                  }                    background.Freeze();                    CacheFreezable(background' (int)backgroundType);              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (background == null)              {                  background = new LinearGradientBrush();                  background.StartPoint = new Point();                  background.EndPoint = new Point(0.0' 1.0);                    switch (backgroundType)                  {                      case AeroFreezables.NormalBackground:                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFF' 0xFF' 0xFF)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFF' 0xFF' 0xFF)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF7' 0xF8' 0xFA)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF1' 0xF2' 0xF4)' 1.0));                          break;                        case AeroFreezables.PressedBackground:                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBC' 0xE4' 0xF9)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBC' 0xE4' 0xF9)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x8D' 0xD6' 0xF7)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x8A' 0xD1' 0xF5)' 1.0));                          break;                        case AeroFreezables.HoveredBackground:                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0xF7' 0xFF)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0xF7' 0xFF)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBD' 0xED' 0xFF)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xB7' 0xE7' 0xFB)' 1.0));                          break;                        case AeroFreezables.SortedBackground:                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF2' 0xF9' 0xFC)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF2' 0xF9' 0xFC)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE1' 0xF1' 0xF9)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xD8' 0xEC' 0xF6)' 1.0));                          break;                  }                    background.Freeze();                    CacheFreezable(background' (int)backgroundType);              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (background == null)              {                  background = new LinearGradientBrush();                  background.StartPoint = new Point();                  background.EndPoint = new Point(0.0' 1.0);                    switch (backgroundType)                  {                      case AeroFreezables.NormalBackground:                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFF' 0xFF' 0xFF)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFF' 0xFF' 0xFF)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF7' 0xF8' 0xFA)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF1' 0xF2' 0xF4)' 1.0));                          break;                        case AeroFreezables.PressedBackground:                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBC' 0xE4' 0xF9)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBC' 0xE4' 0xF9)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x8D' 0xD6' 0xF7)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x8A' 0xD1' 0xF5)' 1.0));                          break;                        case AeroFreezables.HoveredBackground:                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0xF7' 0xFF)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0xF7' 0xFF)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBD' 0xED' 0xFF)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xB7' 0xE7' 0xFB)' 1.0));                          break;                        case AeroFreezables.SortedBackground:                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF2' 0xF9' 0xFC)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF2' 0xF9' 0xFC)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE1' 0xF1' 0xF9)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xD8' 0xEC' 0xF6)' 1.0));                          break;                  }                    background.Freeze();                    CacheFreezable(background' (int)backgroundType);              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (background == null)              {                  background = new LinearGradientBrush();                  background.StartPoint = new Point();                  background.EndPoint = new Point(0.0' 1.0);                    switch (backgroundType)                  {                      case AeroFreezables.NormalBackground:                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFF' 0xFF' 0xFF)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFF' 0xFF' 0xFF)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF7' 0xF8' 0xFA)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF1' 0xF2' 0xF4)' 1.0));                          break;                        case AeroFreezables.PressedBackground:                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBC' 0xE4' 0xF9)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBC' 0xE4' 0xF9)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x8D' 0xD6' 0xF7)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x8A' 0xD1' 0xF5)' 1.0));                          break;                        case AeroFreezables.HoveredBackground:                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0xF7' 0xFF)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0xF7' 0xFF)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBD' 0xED' 0xFF)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xB7' 0xE7' 0xFB)' 1.0));                          break;                        case AeroFreezables.SortedBackground:                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF2' 0xF9' 0xFC)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF2' 0xF9' 0xFC)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE1' 0xF1' 0xF9)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xD8' 0xEC' 0xF6)' 1.0));                          break;                  }                    background.Freeze();                    CacheFreezable(background' (int)backgroundType);              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (background == null)              {                  background = new LinearGradientBrush();                  background.StartPoint = new Point();                  background.EndPoint = new Point(0.0' 1.0);                    switch (backgroundType)                  {                      case AeroFreezables.NormalBackground:                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFF' 0xFF' 0xFF)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFF' 0xFF' 0xFF)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF7' 0xF8' 0xFA)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF1' 0xF2' 0xF4)' 1.0));                          break;                        case AeroFreezables.PressedBackground:                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBC' 0xE4' 0xF9)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBC' 0xE4' 0xF9)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x8D' 0xD6' 0xF7)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x8A' 0xD1' 0xF5)' 1.0));                          break;                        case AeroFreezables.HoveredBackground:                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0xF7' 0xFF)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0xF7' 0xFF)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBD' 0xED' 0xFF)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xB7' 0xE7' 0xFB)' 1.0));                          break;                        case AeroFreezables.SortedBackground:                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF2' 0xF9' 0xFC)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF2' 0xF9' 0xFC)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE1' 0xF1' 0xF9)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xD8' 0xEC' 0xF6)' 1.0));                          break;                  }                    background.Freeze();                    CacheFreezable(background' (int)backgroundType);              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (background == null)              {                  background = new LinearGradientBrush();                  background.StartPoint = new Point();                  background.EndPoint = new Point(0.0' 1.0);                    switch (backgroundType)                  {                      case AeroFreezables.NormalBackground:                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFF' 0xFF' 0xFF)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFF' 0xFF' 0xFF)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF7' 0xF8' 0xFA)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF1' 0xF2' 0xF4)' 1.0));                          break;                        case AeroFreezables.PressedBackground:                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBC' 0xE4' 0xF9)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBC' 0xE4' 0xF9)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x8D' 0xD6' 0xF7)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x8A' 0xD1' 0xF5)' 1.0));                          break;                        case AeroFreezables.HoveredBackground:                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0xF7' 0xFF)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0xF7' 0xFF)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBD' 0xED' 0xFF)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xB7' 0xE7' 0xFB)' 1.0));                          break;                        case AeroFreezables.SortedBackground:                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF2' 0xF9' 0xFC)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF2' 0xF9' 0xFC)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE1' 0xF1' 0xF9)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xD8' 0xEC' 0xF6)' 1.0));                          break;                  }                    background.Freeze();                    CacheFreezable(background' (int)backgroundType);              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (background == null)              {                  background = new LinearGradientBrush();                  background.StartPoint = new Point();                  background.EndPoint = new Point(0.0' 1.0);                    switch (backgroundType)                  {                      case AeroFreezables.NormalBackground:                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFF' 0xFF' 0xFF)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFF' 0xFF' 0xFF)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF7' 0xF8' 0xFA)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF1' 0xF2' 0xF4)' 1.0));                          break;                        case AeroFreezables.PressedBackground:                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBC' 0xE4' 0xF9)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBC' 0xE4' 0xF9)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x8D' 0xD6' 0xF7)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x8A' 0xD1' 0xF5)' 1.0));                          break;                        case AeroFreezables.HoveredBackground:                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0xF7' 0xFF)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0xF7' 0xFF)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBD' 0xED' 0xFF)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xB7' 0xE7' 0xFB)' 1.0));                          break;                        case AeroFreezables.SortedBackground:                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF2' 0xF9' 0xFC)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF2' 0xF9' 0xFC)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE1' 0xF1' 0xF9)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xD8' 0xEC' 0xF6)' 1.0));                          break;                  }                    background.Freeze();                    CacheFreezable(background' (int)backgroundType);              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (size.Width >= 2.0)              {                  // Draw the borders on the sides                  AeroFreezables sideType = AeroFreezables.NormalSides;                  if (isPressed)                  {                      sideType = AeroFreezables.PressedSides;                  }                  else if (isHovered)                  {                      sideType = AeroFreezables.HoveredSides;                  }                  else if (isSorted || isSelected)                  {                      sideType = AeroFreezables.SortedSides;                  }                    if (SeparatorVisibility == Visibility.Visible)                  {                      Brush sideBrush;                      if (SeparatorBrush != null)                      {                          sideBrush = SeparatorBrush;                      }                      else                      {                          sideBrush = (Brush)GetCachedFreezable((int)sideType);                          if (sideBrush == null)                          {                              LinearGradientBrush lgBrush = null;                              if (sideType != AeroFreezables.SortedSides)                              {                                  lgBrush = new LinearGradientBrush();                                  lgBrush.StartPoint = new Point();                                  lgBrush.EndPoint = new Point(0.0' 1.0);                                  sideBrush = lgBrush;                              }                                switch (sideType)                              {                                  case AeroFreezables.NormalSides:                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF2' 0xF2' 0xF2)' 0.0));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEF' 0xEF' 0xEF)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE7' 0xE8' 0xEA)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDE' 0xDF' 0xE1)' 1.0));                                      break;                                    case AeroFreezables.PressedSides:                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x7A' 0x9E' 0xB1)' 0.0));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x7A' 0x9E' 0xB1)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x50' 0x91' 0xAF)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x4D' 0x8D' 0xAD)' 1.0));                                      break;                                    case AeroFreezables.HoveredSides:                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x88' 0xCB' 0xEB)' 0.0));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x88' 0xCB' 0xEB)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x69' 0xBB' 0xE3)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x69' 0xBB' 0xE3)' 1.0));                                      break;                                    case AeroFreezables.SortedSides:                                      sideBrush = new SolidColorBrush(Color.FromArgb(0xFF' 0x96' 0xD9' 0xF9));                                      break;                              }                                sideBrush.Freeze();                                CacheFreezable(sideBrush' (int)sideType);                          }                      }                        dc.DrawRectangle(sideBrush' null' new Rect(0.0' 0.0' 1.0' Max0(size.Height - 0.95)));                      dc.DrawRectangle(sideBrush' null' new Rect(size.Width - 1.0' 0.0' 1.0' Max0(size.Height - 0.95)));                  }              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (size.Width >= 2.0)              {                  // Draw the borders on the sides                  AeroFreezables sideType = AeroFreezables.NormalSides;                  if (isPressed)                  {                      sideType = AeroFreezables.PressedSides;                  }                  else if (isHovered)                  {                      sideType = AeroFreezables.HoveredSides;                  }                  else if (isSorted || isSelected)                  {                      sideType = AeroFreezables.SortedSides;                  }                    if (SeparatorVisibility == Visibility.Visible)                  {                      Brush sideBrush;                      if (SeparatorBrush != null)                      {                          sideBrush = SeparatorBrush;                      }                      else                      {                          sideBrush = (Brush)GetCachedFreezable((int)sideType);                          if (sideBrush == null)                          {                              LinearGradientBrush lgBrush = null;                              if (sideType != AeroFreezables.SortedSides)                              {                                  lgBrush = new LinearGradientBrush();                                  lgBrush.StartPoint = new Point();                                  lgBrush.EndPoint = new Point(0.0' 1.0);                                  sideBrush = lgBrush;                              }                                switch (sideType)                              {                                  case AeroFreezables.NormalSides:                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF2' 0xF2' 0xF2)' 0.0));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEF' 0xEF' 0xEF)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE7' 0xE8' 0xEA)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDE' 0xDF' 0xE1)' 1.0));                                      break;                                    case AeroFreezables.PressedSides:                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x7A' 0x9E' 0xB1)' 0.0));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x7A' 0x9E' 0xB1)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x50' 0x91' 0xAF)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x4D' 0x8D' 0xAD)' 1.0));                                      break;                                    case AeroFreezables.HoveredSides:                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x88' 0xCB' 0xEB)' 0.0));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x88' 0xCB' 0xEB)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x69' 0xBB' 0xE3)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x69' 0xBB' 0xE3)' 1.0));                                      break;                                    case AeroFreezables.SortedSides:                                      sideBrush = new SolidColorBrush(Color.FromArgb(0xFF' 0x96' 0xD9' 0xF9));                                      break;                              }                                sideBrush.Freeze();                                CacheFreezable(sideBrush' (int)sideType);                          }                      }                        dc.DrawRectangle(sideBrush' null' new Rect(0.0' 0.0' 1.0' Max0(size.Height - 0.95)));                      dc.DrawRectangle(sideBrush' null' new Rect(size.Width - 1.0' 0.0' 1.0' Max0(size.Height - 0.95)));                  }              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (size.Width >= 2.0)              {                  // Draw the borders on the sides                  AeroFreezables sideType = AeroFreezables.NormalSides;                  if (isPressed)                  {                      sideType = AeroFreezables.PressedSides;                  }                  else if (isHovered)                  {                      sideType = AeroFreezables.HoveredSides;                  }                  else if (isSorted || isSelected)                  {                      sideType = AeroFreezables.SortedSides;                  }                    if (SeparatorVisibility == Visibility.Visible)                  {                      Brush sideBrush;                      if (SeparatorBrush != null)                      {                          sideBrush = SeparatorBrush;                      }                      else                      {                          sideBrush = (Brush)GetCachedFreezable((int)sideType);                          if (sideBrush == null)                          {                              LinearGradientBrush lgBrush = null;                              if (sideType != AeroFreezables.SortedSides)                              {                                  lgBrush = new LinearGradientBrush();                                  lgBrush.StartPoint = new Point();                                  lgBrush.EndPoint = new Point(0.0' 1.0);                                  sideBrush = lgBrush;                              }                                switch (sideType)                              {                                  case AeroFreezables.NormalSides:                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF2' 0xF2' 0xF2)' 0.0));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEF' 0xEF' 0xEF)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE7' 0xE8' 0xEA)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDE' 0xDF' 0xE1)' 1.0));                                      break;                                    case AeroFreezables.PressedSides:                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x7A' 0x9E' 0xB1)' 0.0));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x7A' 0x9E' 0xB1)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x50' 0x91' 0xAF)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x4D' 0x8D' 0xAD)' 1.0));                                      break;                                    case AeroFreezables.HoveredSides:                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x88' 0xCB' 0xEB)' 0.0));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x88' 0xCB' 0xEB)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x69' 0xBB' 0xE3)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x69' 0xBB' 0xE3)' 1.0));                                      break;                                    case AeroFreezables.SortedSides:                                      sideBrush = new SolidColorBrush(Color.FromArgb(0xFF' 0x96' 0xD9' 0xF9));                                      break;                              }                                sideBrush.Freeze();                                CacheFreezable(sideBrush' (int)sideType);                          }                      }                        dc.DrawRectangle(sideBrush' null' new Rect(0.0' 0.0' 1.0' Max0(size.Height - 0.95)));                      dc.DrawRectangle(sideBrush' null' new Rect(size.Width - 1.0' 0.0' 1.0' Max0(size.Height - 0.95)));                  }              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (size.Width >= 2.0)              {                  // Draw the borders on the sides                  AeroFreezables sideType = AeroFreezables.NormalSides;                  if (isPressed)                  {                      sideType = AeroFreezables.PressedSides;                  }                  else if (isHovered)                  {                      sideType = AeroFreezables.HoveredSides;                  }                  else if (isSorted || isSelected)                  {                      sideType = AeroFreezables.SortedSides;                  }                    if (SeparatorVisibility == Visibility.Visible)                  {                      Brush sideBrush;                      if (SeparatorBrush != null)                      {                          sideBrush = SeparatorBrush;                      }                      else                      {                          sideBrush = (Brush)GetCachedFreezable((int)sideType);                          if (sideBrush == null)                          {                              LinearGradientBrush lgBrush = null;                              if (sideType != AeroFreezables.SortedSides)                              {                                  lgBrush = new LinearGradientBrush();                                  lgBrush.StartPoint = new Point();                                  lgBrush.EndPoint = new Point(0.0' 1.0);                                  sideBrush = lgBrush;                              }                                switch (sideType)                              {                                  case AeroFreezables.NormalSides:                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF2' 0xF2' 0xF2)' 0.0));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEF' 0xEF' 0xEF)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE7' 0xE8' 0xEA)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDE' 0xDF' 0xE1)' 1.0));                                      break;                                    case AeroFreezables.PressedSides:                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x7A' 0x9E' 0xB1)' 0.0));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x7A' 0x9E' 0xB1)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x50' 0x91' 0xAF)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x4D' 0x8D' 0xAD)' 1.0));                                      break;                                    case AeroFreezables.HoveredSides:                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x88' 0xCB' 0xEB)' 0.0));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x88' 0xCB' 0xEB)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x69' 0xBB' 0xE3)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x69' 0xBB' 0xE3)' 1.0));                                      break;                                    case AeroFreezables.SortedSides:                                      sideBrush = new SolidColorBrush(Color.FromArgb(0xFF' 0x96' 0xD9' 0xF9));                                      break;                              }                                sideBrush.Freeze();                                CacheFreezable(sideBrush' (int)sideType);                          }                      }                        dc.DrawRectangle(sideBrush' null' new Rect(0.0' 0.0' 1.0' Max0(size.Height - 0.95)));                      dc.DrawRectangle(sideBrush' null' new Rect(size.Width - 1.0' 0.0' 1.0' Max0(size.Height - 0.95)));                  }              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (size.Width >= 2.0)              {                  // Draw the borders on the sides                  AeroFreezables sideType = AeroFreezables.NormalSides;                  if (isPressed)                  {                      sideType = AeroFreezables.PressedSides;                  }                  else if (isHovered)                  {                      sideType = AeroFreezables.HoveredSides;                  }                  else if (isSorted || isSelected)                  {                      sideType = AeroFreezables.SortedSides;                  }                    if (SeparatorVisibility == Visibility.Visible)                  {                      Brush sideBrush;                      if (SeparatorBrush != null)                      {                          sideBrush = SeparatorBrush;                      }                      else                      {                          sideBrush = (Brush)GetCachedFreezable((int)sideType);                          if (sideBrush == null)                          {                              LinearGradientBrush lgBrush = null;                              if (sideType != AeroFreezables.SortedSides)                              {                                  lgBrush = new LinearGradientBrush();                                  lgBrush.StartPoint = new Point();                                  lgBrush.EndPoint = new Point(0.0' 1.0);                                  sideBrush = lgBrush;                              }                                switch (sideType)                              {                                  case AeroFreezables.NormalSides:                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF2' 0xF2' 0xF2)' 0.0));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEF' 0xEF' 0xEF)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE7' 0xE8' 0xEA)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDE' 0xDF' 0xE1)' 1.0));                                      break;                                    case AeroFreezables.PressedSides:                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x7A' 0x9E' 0xB1)' 0.0));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x7A' 0x9E' 0xB1)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x50' 0x91' 0xAF)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x4D' 0x8D' 0xAD)' 1.0));                                      break;                                    case AeroFreezables.HoveredSides:                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x88' 0xCB' 0xEB)' 0.0));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x88' 0xCB' 0xEB)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x69' 0xBB' 0xE3)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x69' 0xBB' 0xE3)' 1.0));                                      break;                                    case AeroFreezables.SortedSides:                                      sideBrush = new SolidColorBrush(Color.FromArgb(0xFF' 0x96' 0xD9' 0xF9));                                      break;                              }                                sideBrush.Freeze();                                CacheFreezable(sideBrush' (int)sideType);                          }                      }                        dc.DrawRectangle(sideBrush' null' new Rect(0.0' 0.0' 1.0' Max0(size.Height - 0.95)));                      dc.DrawRectangle(sideBrush' null' new Rect(size.Width - 1.0' 0.0' 1.0' Max0(size.Height - 0.95)));                  }              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (size.Width >= 2.0)              {                  // Draw the borders on the sides                  AeroFreezables sideType = AeroFreezables.NormalSides;                  if (isPressed)                  {                      sideType = AeroFreezables.PressedSides;                  }                  else if (isHovered)                  {                      sideType = AeroFreezables.HoveredSides;                  }                  else if (isSorted || isSelected)                  {                      sideType = AeroFreezables.SortedSides;                  }                    if (SeparatorVisibility == Visibility.Visible)                  {                      Brush sideBrush;                      if (SeparatorBrush != null)                      {                          sideBrush = SeparatorBrush;                      }                      else                      {                          sideBrush = (Brush)GetCachedFreezable((int)sideType);                          if (sideBrush == null)                          {                              LinearGradientBrush lgBrush = null;                              if (sideType != AeroFreezables.SortedSides)                              {                                  lgBrush = new LinearGradientBrush();                                  lgBrush.StartPoint = new Point();                                  lgBrush.EndPoint = new Point(0.0' 1.0);                                  sideBrush = lgBrush;                              }                                switch (sideType)                              {                                  case AeroFreezables.NormalSides:                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF2' 0xF2' 0xF2)' 0.0));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEF' 0xEF' 0xEF)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE7' 0xE8' 0xEA)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDE' 0xDF' 0xE1)' 1.0));                                      break;                                    case AeroFreezables.PressedSides:                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x7A' 0x9E' 0xB1)' 0.0));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x7A' 0x9E' 0xB1)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x50' 0x91' 0xAF)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x4D' 0x8D' 0xAD)' 1.0));                                      break;                                    case AeroFreezables.HoveredSides:                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x88' 0xCB' 0xEB)' 0.0));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x88' 0xCB' 0xEB)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x69' 0xBB' 0xE3)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x69' 0xBB' 0xE3)' 1.0));                                      break;                                    case AeroFreezables.SortedSides:                                      sideBrush = new SolidColorBrush(Color.FromArgb(0xFF' 0x96' 0xD9' 0xF9));                                      break;                              }                                sideBrush.Freeze();                                CacheFreezable(sideBrush' (int)sideType);                          }                      }                        dc.DrawRectangle(sideBrush' null' new Rect(0.0' 0.0' 1.0' Max0(size.Height - 0.95)));                      dc.DrawRectangle(sideBrush' null' new Rect(size.Width - 1.0' 0.0' 1.0' Max0(size.Height - 0.95)));                  }              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (size.Width >= 2.0)              {                  // Draw the borders on the sides                  AeroFreezables sideType = AeroFreezables.NormalSides;                  if (isPressed)                  {                      sideType = AeroFreezables.PressedSides;                  }                  else if (isHovered)                  {                      sideType = AeroFreezables.HoveredSides;                  }                  else if (isSorted || isSelected)                  {                      sideType = AeroFreezables.SortedSides;                  }                    if (SeparatorVisibility == Visibility.Visible)                  {                      Brush sideBrush;                      if (SeparatorBrush != null)                      {                          sideBrush = SeparatorBrush;                      }                      else                      {                          sideBrush = (Brush)GetCachedFreezable((int)sideType);                          if (sideBrush == null)                          {                              LinearGradientBrush lgBrush = null;                              if (sideType != AeroFreezables.SortedSides)                              {                                  lgBrush = new LinearGradientBrush();                                  lgBrush.StartPoint = new Point();                                  lgBrush.EndPoint = new Point(0.0' 1.0);                                  sideBrush = lgBrush;                              }                                switch (sideType)                              {                                  case AeroFreezables.NormalSides:                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF2' 0xF2' 0xF2)' 0.0));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEF' 0xEF' 0xEF)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE7' 0xE8' 0xEA)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDE' 0xDF' 0xE1)' 1.0));                                      break;                                    case AeroFreezables.PressedSides:                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x7A' 0x9E' 0xB1)' 0.0));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x7A' 0x9E' 0xB1)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x50' 0x91' 0xAF)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x4D' 0x8D' 0xAD)' 1.0));                                      break;                                    case AeroFreezables.HoveredSides:                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x88' 0xCB' 0xEB)' 0.0));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x88' 0xCB' 0xEB)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x69' 0xBB' 0xE3)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x69' 0xBB' 0xE3)' 1.0));                                      break;                                    case AeroFreezables.SortedSides:                                      sideBrush = new SolidColorBrush(Color.FromArgb(0xFF' 0x96' 0xD9' 0xF9));                                      break;                              }                                sideBrush.Freeze();                                CacheFreezable(sideBrush' (int)sideType);                          }                      }                        dc.DrawRectangle(sideBrush' null' new Rect(0.0' 0.0' 1.0' Max0(size.Height - 0.95)));                      dc.DrawRectangle(sideBrush' null' new Rect(size.Width - 1.0' 0.0' 1.0' Max0(size.Height - 0.95)));                  }              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (size.Width >= 2.0)              {                  // Draw the borders on the sides                  AeroFreezables sideType = AeroFreezables.NormalSides;                  if (isPressed)                  {                      sideType = AeroFreezables.PressedSides;                  }                  else if (isHovered)                  {                      sideType = AeroFreezables.HoveredSides;                  }                  else if (isSorted || isSelected)                  {                      sideType = AeroFreezables.SortedSides;                  }                    if (SeparatorVisibility == Visibility.Visible)                  {                      Brush sideBrush;                      if (SeparatorBrush != null)                      {                          sideBrush = SeparatorBrush;                      }                      else                      {                          sideBrush = (Brush)GetCachedFreezable((int)sideType);                          if (sideBrush == null)                          {                              LinearGradientBrush lgBrush = null;                              if (sideType != AeroFreezables.SortedSides)                              {                                  lgBrush = new LinearGradientBrush();                                  lgBrush.StartPoint = new Point();                                  lgBrush.EndPoint = new Point(0.0' 1.0);                                  sideBrush = lgBrush;                              }                                switch (sideType)                              {                                  case AeroFreezables.NormalSides:                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF2' 0xF2' 0xF2)' 0.0));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEF' 0xEF' 0xEF)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE7' 0xE8' 0xEA)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDE' 0xDF' 0xE1)' 1.0));                                      break;                                    case AeroFreezables.PressedSides:                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x7A' 0x9E' 0xB1)' 0.0));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x7A' 0x9E' 0xB1)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x50' 0x91' 0xAF)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x4D' 0x8D' 0xAD)' 1.0));                                      break;                                    case AeroFreezables.HoveredSides:                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x88' 0xCB' 0xEB)' 0.0));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x88' 0xCB' 0xEB)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x69' 0xBB' 0xE3)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x69' 0xBB' 0xE3)' 1.0));                                      break;                                    case AeroFreezables.SortedSides:                                      sideBrush = new SolidColorBrush(Color.FromArgb(0xFF' 0x96' 0xD9' 0xF9));                                      break;                              }                                sideBrush.Freeze();                                CacheFreezable(sideBrush' (int)sideType);                          }                      }                        dc.DrawRectangle(sideBrush' null' new Rect(0.0' 0.0' 1.0' Max0(size.Height - 0.95)));                      dc.DrawRectangle(sideBrush' null' new Rect(size.Width - 1.0' 0.0' 1.0' Max0(size.Height - 0.95)));                  }              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (size.Width >= 2.0)              {                  // Draw the borders on the sides                  AeroFreezables sideType = AeroFreezables.NormalSides;                  if (isPressed)                  {                      sideType = AeroFreezables.PressedSides;                  }                  else if (isHovered)                  {                      sideType = AeroFreezables.HoveredSides;                  }                  else if (isSorted || isSelected)                  {                      sideType = AeroFreezables.SortedSides;                  }                    if (SeparatorVisibility == Visibility.Visible)                  {                      Brush sideBrush;                      if (SeparatorBrush != null)                      {                          sideBrush = SeparatorBrush;                      }                      else                      {                          sideBrush = (Brush)GetCachedFreezable((int)sideType);                          if (sideBrush == null)                          {                              LinearGradientBrush lgBrush = null;                              if (sideType != AeroFreezables.SortedSides)                              {                                  lgBrush = new LinearGradientBrush();                                  lgBrush.StartPoint = new Point();                                  lgBrush.EndPoint = new Point(0.0' 1.0);                                  sideBrush = lgBrush;                              }                                switch (sideType)                              {                                  case AeroFreezables.NormalSides:                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF2' 0xF2' 0xF2)' 0.0));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEF' 0xEF' 0xEF)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE7' 0xE8' 0xEA)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDE' 0xDF' 0xE1)' 1.0));                                      break;                                    case AeroFreezables.PressedSides:                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x7A' 0x9E' 0xB1)' 0.0));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x7A' 0x9E' 0xB1)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x50' 0x91' 0xAF)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x4D' 0x8D' 0xAD)' 1.0));                                      break;                                    case AeroFreezables.HoveredSides:                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x88' 0xCB' 0xEB)' 0.0));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x88' 0xCB' 0xEB)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x69' 0xBB' 0xE3)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x69' 0xBB' 0xE3)' 1.0));                                      break;                                    case AeroFreezables.SortedSides:                                      sideBrush = new SolidColorBrush(Color.FromArgb(0xFF' 0x96' 0xD9' 0xF9));                                      break;                              }                                sideBrush.Freeze();                                CacheFreezable(sideBrush' (int)sideType);                          }                      }                        dc.DrawRectangle(sideBrush' null' new Rect(0.0' 0.0' 1.0' Max0(size.Height - 0.95)));                      dc.DrawRectangle(sideBrush' null' new Rect(size.Width - 1.0' 0.0' 1.0' Max0(size.Height - 0.95)));                  }              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (isPressed && (size.Width >= 4.0) && (size.Height >= 4.0))              {                  // When pressed' there are added borders on the left and top                  LinearGradientBrush topBrush = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.PressedTop);                  if (topBrush == null)                  {                      topBrush = new LinearGradientBrush();                      topBrush.StartPoint = new Point();                      topBrush.EndPoint = new Point(0.0' 1.0);                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x86' 0xA3' 0xB2)' 0.0));                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x86' 0xA3' 0xB2)' 0.1));                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xAA' 0xCE' 0xE1)' 0.9));                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xAA' 0xCE' 0xE1)' 1.0));                      topBrush.Freeze();                        CacheFreezable(topBrush' (int)AeroFreezables.PressedTop);                  }                    dc.DrawRectangle(topBrush' null' new Rect(0.0' 0.0' size.Width' 2.0));                    LinearGradientBrush pressedBevel = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.PressedBevel);                  if (pressedBevel == null)                  {                      pressedBevel = new LinearGradientBrush();                      pressedBevel.StartPoint = new Point();                      pressedBevel.EndPoint = new Point(0.0' 1.0);                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xA2' 0xCB' 0xE0)' 0.0));                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xA2' 0xCB' 0xE0)' 0.4));                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x72' 0xBC' 0xDF)' 0.4));                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x6E' 0xB8' 0xDC)' 1.0));                      pressedBevel.Freeze();                        CacheFreezable(pressedBevel' (int)AeroFreezables.PressedBevel);                  }                    dc.DrawRectangle(pressedBevel' null' new Rect(1.0' 0.0' 1.0' size.Height - 0.95));                  dc.DrawRectangle(pressedBevel' null' new Rect(size.Width - 2.0' 0.0' 1.0' size.Height - 0.95));              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (isPressed && (size.Width >= 4.0) && (size.Height >= 4.0))              {                  // When pressed' there are added borders on the left and top                  LinearGradientBrush topBrush = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.PressedTop);                  if (topBrush == null)                  {                      topBrush = new LinearGradientBrush();                      topBrush.StartPoint = new Point();                      topBrush.EndPoint = new Point(0.0' 1.0);                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x86' 0xA3' 0xB2)' 0.0));                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x86' 0xA3' 0xB2)' 0.1));                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xAA' 0xCE' 0xE1)' 0.9));                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xAA' 0xCE' 0xE1)' 1.0));                      topBrush.Freeze();                        CacheFreezable(topBrush' (int)AeroFreezables.PressedTop);                  }                    dc.DrawRectangle(topBrush' null' new Rect(0.0' 0.0' size.Width' 2.0));                    LinearGradientBrush pressedBevel = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.PressedBevel);                  if (pressedBevel == null)                  {                      pressedBevel = new LinearGradientBrush();                      pressedBevel.StartPoint = new Point();                      pressedBevel.EndPoint = new Point(0.0' 1.0);                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xA2' 0xCB' 0xE0)' 0.0));                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xA2' 0xCB' 0xE0)' 0.4));                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x72' 0xBC' 0xDF)' 0.4));                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x6E' 0xB8' 0xDC)' 1.0));                      pressedBevel.Freeze();                        CacheFreezable(pressedBevel' (int)AeroFreezables.PressedBevel);                  }                    dc.DrawRectangle(pressedBevel' null' new Rect(1.0' 0.0' 1.0' size.Height - 0.95));                  dc.DrawRectangle(pressedBevel' null' new Rect(size.Width - 2.0' 0.0' 1.0' size.Height - 0.95));              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (isPressed && (size.Width >= 4.0) && (size.Height >= 4.0))              {                  // When pressed' there are added borders on the left and top                  LinearGradientBrush topBrush = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.PressedTop);                  if (topBrush == null)                  {                      topBrush = new LinearGradientBrush();                      topBrush.StartPoint = new Point();                      topBrush.EndPoint = new Point(0.0' 1.0);                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x86' 0xA3' 0xB2)' 0.0));                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x86' 0xA3' 0xB2)' 0.1));                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xAA' 0xCE' 0xE1)' 0.9));                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xAA' 0xCE' 0xE1)' 1.0));                      topBrush.Freeze();                        CacheFreezable(topBrush' (int)AeroFreezables.PressedTop);                  }                    dc.DrawRectangle(topBrush' null' new Rect(0.0' 0.0' size.Width' 2.0));                    LinearGradientBrush pressedBevel = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.PressedBevel);                  if (pressedBevel == null)                  {                      pressedBevel = new LinearGradientBrush();                      pressedBevel.StartPoint = new Point();                      pressedBevel.EndPoint = new Point(0.0' 1.0);                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xA2' 0xCB' 0xE0)' 0.0));                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xA2' 0xCB' 0xE0)' 0.4));                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x72' 0xBC' 0xDF)' 0.4));                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x6E' 0xB8' 0xDC)' 1.0));                      pressedBevel.Freeze();                        CacheFreezable(pressedBevel' (int)AeroFreezables.PressedBevel);                  }                    dc.DrawRectangle(pressedBevel' null' new Rect(1.0' 0.0' 1.0' size.Height - 0.95));                  dc.DrawRectangle(pressedBevel' null' new Rect(size.Width - 2.0' 0.0' 1.0' size.Height - 0.95));              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (isPressed && (size.Width >= 4.0) && (size.Height >= 4.0))              {                  // When pressed' there are added borders on the left and top                  LinearGradientBrush topBrush = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.PressedTop);                  if (topBrush == null)                  {                      topBrush = new LinearGradientBrush();                      topBrush.StartPoint = new Point();                      topBrush.EndPoint = new Point(0.0' 1.0);                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x86' 0xA3' 0xB2)' 0.0));                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x86' 0xA3' 0xB2)' 0.1));                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xAA' 0xCE' 0xE1)' 0.9));                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xAA' 0xCE' 0xE1)' 1.0));                      topBrush.Freeze();                        CacheFreezable(topBrush' (int)AeroFreezables.PressedTop);                  }                    dc.DrawRectangle(topBrush' null' new Rect(0.0' 0.0' size.Width' 2.0));                    LinearGradientBrush pressedBevel = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.PressedBevel);                  if (pressedBevel == null)                  {                      pressedBevel = new LinearGradientBrush();                      pressedBevel.StartPoint = new Point();                      pressedBevel.EndPoint = new Point(0.0' 1.0);                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xA2' 0xCB' 0xE0)' 0.0));                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xA2' 0xCB' 0xE0)' 0.4));                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x72' 0xBC' 0xDF)' 0.4));                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x6E' 0xB8' 0xDC)' 1.0));                      pressedBevel.Freeze();                        CacheFreezable(pressedBevel' (int)AeroFreezables.PressedBevel);                  }                    dc.DrawRectangle(pressedBevel' null' new Rect(1.0' 0.0' 1.0' size.Height - 0.95));                  dc.DrawRectangle(pressedBevel' null' new Rect(size.Width - 2.0' 0.0' 1.0' size.Height - 0.95));              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (isPressed && (size.Width >= 4.0) && (size.Height >= 4.0))              {                  // When pressed' there are added borders on the left and top                  LinearGradientBrush topBrush = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.PressedTop);                  if (topBrush == null)                  {                      topBrush = new LinearGradientBrush();                      topBrush.StartPoint = new Point();                      topBrush.EndPoint = new Point(0.0' 1.0);                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x86' 0xA3' 0xB2)' 0.0));                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x86' 0xA3' 0xB2)' 0.1));                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xAA' 0xCE' 0xE1)' 0.9));                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xAA' 0xCE' 0xE1)' 1.0));                      topBrush.Freeze();                        CacheFreezable(topBrush' (int)AeroFreezables.PressedTop);                  }                    dc.DrawRectangle(topBrush' null' new Rect(0.0' 0.0' size.Width' 2.0));                    LinearGradientBrush pressedBevel = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.PressedBevel);                  if (pressedBevel == null)                  {                      pressedBevel = new LinearGradientBrush();                      pressedBevel.StartPoint = new Point();                      pressedBevel.EndPoint = new Point(0.0' 1.0);                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xA2' 0xCB' 0xE0)' 0.0));                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xA2' 0xCB' 0xE0)' 0.4));                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x72' 0xBC' 0xDF)' 0.4));                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x6E' 0xB8' 0xDC)' 1.0));                      pressedBevel.Freeze();                        CacheFreezable(pressedBevel' (int)AeroFreezables.PressedBevel);                  }                    dc.DrawRectangle(pressedBevel' null' new Rect(1.0' 0.0' 1.0' size.Height - 0.95));                  dc.DrawRectangle(pressedBevel' null' new Rect(size.Width - 2.0' 0.0' 1.0' size.Height - 0.95));              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (isPressed && (size.Width >= 4.0) && (size.Height >= 4.0))              {                  // When pressed' there are added borders on the left and top                  LinearGradientBrush topBrush = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.PressedTop);                  if (topBrush == null)                  {                      topBrush = new LinearGradientBrush();                      topBrush.StartPoint = new Point();                      topBrush.EndPoint = new Point(0.0' 1.0);                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x86' 0xA3' 0xB2)' 0.0));                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x86' 0xA3' 0xB2)' 0.1));                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xAA' 0xCE' 0xE1)' 0.9));                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xAA' 0xCE' 0xE1)' 1.0));                      topBrush.Freeze();                        CacheFreezable(topBrush' (int)AeroFreezables.PressedTop);                  }                    dc.DrawRectangle(topBrush' null' new Rect(0.0' 0.0' size.Width' 2.0));                    LinearGradientBrush pressedBevel = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.PressedBevel);                  if (pressedBevel == null)                  {                      pressedBevel = new LinearGradientBrush();                      pressedBevel.StartPoint = new Point();                      pressedBevel.EndPoint = new Point(0.0' 1.0);                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xA2' 0xCB' 0xE0)' 0.0));                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xA2' 0xCB' 0xE0)' 0.4));                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x72' 0xBC' 0xDF)' 0.4));                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x6E' 0xB8' 0xDC)' 1.0));                      pressedBevel.Freeze();                        CacheFreezable(pressedBevel' (int)AeroFreezables.PressedBevel);                  }                    dc.DrawRectangle(pressedBevel' null' new Rect(1.0' 0.0' 1.0' size.Height - 0.95));                  dc.DrawRectangle(pressedBevel' null' new Rect(size.Width - 2.0' 0.0' 1.0' size.Height - 0.95));              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (isPressed && (size.Width >= 4.0) && (size.Height >= 4.0))              {                  // When pressed' there are added borders on the left and top                  LinearGradientBrush topBrush = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.PressedTop);                  if (topBrush == null)                  {                      topBrush = new LinearGradientBrush();                      topBrush.StartPoint = new Point();                      topBrush.EndPoint = new Point(0.0' 1.0);                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x86' 0xA3' 0xB2)' 0.0));                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x86' 0xA3' 0xB2)' 0.1));                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xAA' 0xCE' 0xE1)' 0.9));                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xAA' 0xCE' 0xE1)' 1.0));                      topBrush.Freeze();                        CacheFreezable(topBrush' (int)AeroFreezables.PressedTop);                  }                    dc.DrawRectangle(topBrush' null' new Rect(0.0' 0.0' size.Width' 2.0));                    LinearGradientBrush pressedBevel = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.PressedBevel);                  if (pressedBevel == null)                  {                      pressedBevel = new LinearGradientBrush();                      pressedBevel.StartPoint = new Point();                      pressedBevel.EndPoint = new Point(0.0' 1.0);                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xA2' 0xCB' 0xE0)' 0.0));                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xA2' 0xCB' 0xE0)' 0.4));                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x72' 0xBC' 0xDF)' 0.4));                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x6E' 0xB8' 0xDC)' 1.0));                      pressedBevel.Freeze();                        CacheFreezable(pressedBevel' (int)AeroFreezables.PressedBevel);                  }                    dc.DrawRectangle(pressedBevel' null' new Rect(1.0' 0.0' 1.0' size.Height - 0.95));                  dc.DrawRectangle(pressedBevel' null' new Rect(size.Width - 2.0' 0.0' 1.0' size.Height - 0.95));              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (isPressed && (size.Width >= 4.0) && (size.Height >= 4.0))              {                  // When pressed' there are added borders on the left and top                  LinearGradientBrush topBrush = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.PressedTop);                  if (topBrush == null)                  {                      topBrush = new LinearGradientBrush();                      topBrush.StartPoint = new Point();                      topBrush.EndPoint = new Point(0.0' 1.0);                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x86' 0xA3' 0xB2)' 0.0));                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x86' 0xA3' 0xB2)' 0.1));                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xAA' 0xCE' 0xE1)' 0.9));                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xAA' 0xCE' 0xE1)' 1.0));                      topBrush.Freeze();                        CacheFreezable(topBrush' (int)AeroFreezables.PressedTop);                  }                    dc.DrawRectangle(topBrush' null' new Rect(0.0' 0.0' size.Width' 2.0));                    LinearGradientBrush pressedBevel = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.PressedBevel);                  if (pressedBevel == null)                  {                      pressedBevel = new LinearGradientBrush();                      pressedBevel.StartPoint = new Point();                      pressedBevel.EndPoint = new Point(0.0' 1.0);                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xA2' 0xCB' 0xE0)' 0.0));                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xA2' 0xCB' 0xE0)' 0.4));                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x72' 0xBC' 0xDF)' 0.4));                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x6E' 0xB8' 0xDC)' 1.0));                      pressedBevel.Freeze();                        CacheFreezable(pressedBevel' (int)AeroFreezables.PressedBevel);                  }                    dc.DrawRectangle(pressedBevel' null' new Rect(1.0' 0.0' 1.0' size.Height - 0.95));                  dc.DrawRectangle(pressedBevel' null' new Rect(size.Width - 2.0' 0.0' 1.0' size.Height - 0.95));              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (isPressed && (size.Width >= 4.0) && (size.Height >= 4.0))              {                  // When pressed' there are added borders on the left and top                  LinearGradientBrush topBrush = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.PressedTop);                  if (topBrush == null)                  {                      topBrush = new LinearGradientBrush();                      topBrush.StartPoint = new Point();                      topBrush.EndPoint = new Point(0.0' 1.0);                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x86' 0xA3' 0xB2)' 0.0));                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x86' 0xA3' 0xB2)' 0.1));                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xAA' 0xCE' 0xE1)' 0.9));                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xAA' 0xCE' 0xE1)' 1.0));                      topBrush.Freeze();                        CacheFreezable(topBrush' (int)AeroFreezables.PressedTop);                  }                    dc.DrawRectangle(topBrush' null' new Rect(0.0' 0.0' size.Width' 2.0));                    LinearGradientBrush pressedBevel = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.PressedBevel);                  if (pressedBevel == null)                  {                      pressedBevel = new LinearGradientBrush();                      pressedBevel.StartPoint = new Point();                      pressedBevel.EndPoint = new Point(0.0' 1.0);                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xA2' 0xCB' 0xE0)' 0.0));                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xA2' 0xCB' 0xE0)' 0.4));                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x72' 0xBC' 0xDF)' 0.4));                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x6E' 0xB8' 0xDC)' 1.0));                      pressedBevel.Freeze();                        CacheFreezable(pressedBevel' (int)AeroFreezables.PressedBevel);                  }                    dc.DrawRectangle(pressedBevel' null' new Rect(1.0' 0.0' 1.0' size.Height - 0.95));                  dc.DrawRectangle(pressedBevel' null' new Rect(size.Width - 2.0' 0.0' 1.0' size.Height - 0.95));              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (isPressed && (size.Width >= 4.0) && (size.Height >= 4.0))              {                  // When pressed' there are added borders on the left and top                  LinearGradientBrush topBrush = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.PressedTop);                  if (topBrush == null)                  {                      topBrush = new LinearGradientBrush();                      topBrush.StartPoint = new Point();                      topBrush.EndPoint = new Point(0.0' 1.0);                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x86' 0xA3' 0xB2)' 0.0));                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x86' 0xA3' 0xB2)' 0.1));                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xAA' 0xCE' 0xE1)' 0.9));                      topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xAA' 0xCE' 0xE1)' 1.0));                      topBrush.Freeze();                        CacheFreezable(topBrush' (int)AeroFreezables.PressedTop);                  }                    dc.DrawRectangle(topBrush' null' new Rect(0.0' 0.0' size.Width' 2.0));                    LinearGradientBrush pressedBevel = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.PressedBevel);                  if (pressedBevel == null)                  {                      pressedBevel = new LinearGradientBrush();                      pressedBevel.StartPoint = new Point();                      pressedBevel.EndPoint = new Point(0.0' 1.0);                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xA2' 0xCB' 0xE0)' 0.0));                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xA2' 0xCB' 0xE0)' 0.4));                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x72' 0xBC' 0xDF)' 0.4));                      pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x6E' 0xB8' 0xDC)' 1.0));                      pressedBevel.Freeze();                        CacheFreezable(pressedBevel' (int)AeroFreezables.PressedBevel);                  }                    dc.DrawRectangle(pressedBevel' null' new Rect(1.0' 0.0' 1.0' size.Height - 0.95));                  dc.DrawRectangle(pressedBevel' null' new Rect(size.Width - 2.0' 0.0' 1.0' size.Height - 0.95));              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (size.Height >= 2.0)              {                  // Draw the bottom border                  AeroFreezables bottomType = AeroFreezables.NormalBottom;                  if (isPressed)                  {                      bottomType = AeroFreezables.PressedOrHoveredBottom;                  }                  else if (isHovered)                  {                      bottomType = AeroFreezables.PressedOrHoveredBottom;                  }                  else if (isSorted || isSelected)                  {                      bottomType = AeroFreezables.SortedBottom;                  }                    SolidColorBrush bottomBrush = (SolidColorBrush)GetCachedFreezable((int)bottomType);                  if (bottomBrush == null)                  {                      switch (bottomType)                      {                          case AeroFreezables.NormalBottom:                              bottomBrush = new SolidColorBrush(Color.FromArgb(0xFF' 0xD5' 0xD5' 0xD5));                              break;                            case AeroFreezables.PressedOrHoveredBottom:                              bottomBrush = new SolidColorBrush(Color.FromArgb(0xFF' 0x93' 0xC9' 0xE3));                              break;                            case AeroFreezables.SortedBottom:                              bottomBrush = new SolidColorBrush(Color.FromArgb(0xFF' 0x96' 0xD9' 0xF9));                              break;                      }                        bottomBrush.Freeze();                        CacheFreezable(bottomBrush' (int)bottomType);                  }                    dc.DrawRectangle(bottomBrush' null' new Rect(0.0' size.Height - 1.0' size.Width' 1.0));              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // Draw the sort arrow                  TranslateTransform positionTransform = new TranslateTransform((size.Width - 8.0) * 0.5' 1.0);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)AeroFreezables.ArrowUpGeometry : (int)AeroFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 4.0);                            LineSegment line = new LineSegment(new Point(4.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(8.0' 4.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(8.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(4.0' 4.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)AeroFreezables.ArrowUpGeometry : (int)AeroFreezables.ArrowDownGeometry);                  }                    // Draw two arrows' one inset in the other. This is to achieve a double gradient over both the border and the fill.                  LinearGradientBrush arrowBorder = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.ArrowBorder);                  if (arrowBorder == null)                  {                      arrowBorder = new LinearGradientBrush();                      arrowBorder.StartPoint = new Point();                      arrowBorder.EndPoint = new Point(1.0' 1.0);                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x3C' 0x5E' 0x72)' 0.0));                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x3C' 0x5E' 0x72)' 0.1));                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xC3' 0xE4' 0xF5)' 1.0));                      arrowBorder.Freeze();                      CacheFreezable(arrowBorder' (int)AeroFreezables.ArrowBorder);                  }                    dc.DrawGeometry(arrowBorder' null' arrowGeometry);                    LinearGradientBrush arrowFill = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.ArrowFill);                  if (arrowFill == null)                  {                      arrowFill = new LinearGradientBrush();                      arrowFill.StartPoint = new Point();                      arrowFill.EndPoint = new Point(1.0' 1.0);                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x61' 0x96' 0xB6)' 0.0));                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x61' 0x96' 0xB6)' 0.1));                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xCA' 0xE6' 0xF5)' 1.0));                      arrowFill.Freeze();                      CacheFreezable(arrowFill' (int)AeroFreezables.ArrowFill);                  }                    // Inset the fill arrow inside the border arrow                  ScaleTransform arrowScale = (ScaleTransform)GetCachedFreezable((int)AeroFreezables.ArrowFillScale);                  if (arrowScale == null)                  {                      arrowScale = new ScaleTransform(0.75' 0.75' 3.5' 4.0);                      arrowScale.Freeze();                      CacheFreezable(arrowScale' (int)AeroFreezables.ArrowFillScale);                  }                    dc.PushTransform(arrowScale);                    dc.DrawGeometry(arrowFill' null' arrowGeometry);                    dc.Pop(); // Scale Transform                  dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // Draw the sort arrow                  TranslateTransform positionTransform = new TranslateTransform((size.Width - 8.0) * 0.5' 1.0);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)AeroFreezables.ArrowUpGeometry : (int)AeroFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 4.0);                            LineSegment line = new LineSegment(new Point(4.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(8.0' 4.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(8.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(4.0' 4.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)AeroFreezables.ArrowUpGeometry : (int)AeroFreezables.ArrowDownGeometry);                  }                    // Draw two arrows' one inset in the other. This is to achieve a double gradient over both the border and the fill.                  LinearGradientBrush arrowBorder = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.ArrowBorder);                  if (arrowBorder == null)                  {                      arrowBorder = new LinearGradientBrush();                      arrowBorder.StartPoint = new Point();                      arrowBorder.EndPoint = new Point(1.0' 1.0);                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x3C' 0x5E' 0x72)' 0.0));                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x3C' 0x5E' 0x72)' 0.1));                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xC3' 0xE4' 0xF5)' 1.0));                      arrowBorder.Freeze();                      CacheFreezable(arrowBorder' (int)AeroFreezables.ArrowBorder);                  }                    dc.DrawGeometry(arrowBorder' null' arrowGeometry);                    LinearGradientBrush arrowFill = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.ArrowFill);                  if (arrowFill == null)                  {                      arrowFill = new LinearGradientBrush();                      arrowFill.StartPoint = new Point();                      arrowFill.EndPoint = new Point(1.0' 1.0);                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x61' 0x96' 0xB6)' 0.0));                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x61' 0x96' 0xB6)' 0.1));                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xCA' 0xE6' 0xF5)' 1.0));                      arrowFill.Freeze();                      CacheFreezable(arrowFill' (int)AeroFreezables.ArrowFill);                  }                    // Inset the fill arrow inside the border arrow                  ScaleTransform arrowScale = (ScaleTransform)GetCachedFreezable((int)AeroFreezables.ArrowFillScale);                  if (arrowScale == null)                  {                      arrowScale = new ScaleTransform(0.75' 0.75' 3.5' 4.0);                      arrowScale.Freeze();                      CacheFreezable(arrowScale' (int)AeroFreezables.ArrowFillScale);                  }                    dc.PushTransform(arrowScale);                    dc.DrawGeometry(arrowFill' null' arrowGeometry);                    dc.Pop(); // Scale Transform                  dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // Draw the sort arrow                  TranslateTransform positionTransform = new TranslateTransform((size.Width - 8.0) * 0.5' 1.0);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)AeroFreezables.ArrowUpGeometry : (int)AeroFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 4.0);                            LineSegment line = new LineSegment(new Point(4.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(8.0' 4.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(8.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(4.0' 4.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)AeroFreezables.ArrowUpGeometry : (int)AeroFreezables.ArrowDownGeometry);                  }                    // Draw two arrows' one inset in the other. This is to achieve a double gradient over both the border and the fill.                  LinearGradientBrush arrowBorder = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.ArrowBorder);                  if (arrowBorder == null)                  {                      arrowBorder = new LinearGradientBrush();                      arrowBorder.StartPoint = new Point();                      arrowBorder.EndPoint = new Point(1.0' 1.0);                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x3C' 0x5E' 0x72)' 0.0));                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x3C' 0x5E' 0x72)' 0.1));                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xC3' 0xE4' 0xF5)' 1.0));                      arrowBorder.Freeze();                      CacheFreezable(arrowBorder' (int)AeroFreezables.ArrowBorder);                  }                    dc.DrawGeometry(arrowBorder' null' arrowGeometry);                    LinearGradientBrush arrowFill = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.ArrowFill);                  if (arrowFill == null)                  {                      arrowFill = new LinearGradientBrush();                      arrowFill.StartPoint = new Point();                      arrowFill.EndPoint = new Point(1.0' 1.0);                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x61' 0x96' 0xB6)' 0.0));                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x61' 0x96' 0xB6)' 0.1));                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xCA' 0xE6' 0xF5)' 1.0));                      arrowFill.Freeze();                      CacheFreezable(arrowFill' (int)AeroFreezables.ArrowFill);                  }                    // Inset the fill arrow inside the border arrow                  ScaleTransform arrowScale = (ScaleTransform)GetCachedFreezable((int)AeroFreezables.ArrowFillScale);                  if (arrowScale == null)                  {                      arrowScale = new ScaleTransform(0.75' 0.75' 3.5' 4.0);                      arrowScale.Freeze();                      CacheFreezable(arrowScale' (int)AeroFreezables.ArrowFillScale);                  }                    dc.PushTransform(arrowScale);                    dc.DrawGeometry(arrowFill' null' arrowGeometry);                    dc.Pop(); // Scale Transform                  dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // Draw the sort arrow                  TranslateTransform positionTransform = new TranslateTransform((size.Width - 8.0) * 0.5' 1.0);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)AeroFreezables.ArrowUpGeometry : (int)AeroFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 4.0);                            LineSegment line = new LineSegment(new Point(4.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(8.0' 4.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(8.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(4.0' 4.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)AeroFreezables.ArrowUpGeometry : (int)AeroFreezables.ArrowDownGeometry);                  }                    // Draw two arrows' one inset in the other. This is to achieve a double gradient over both the border and the fill.                  LinearGradientBrush arrowBorder = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.ArrowBorder);                  if (arrowBorder == null)                  {                      arrowBorder = new LinearGradientBrush();                      arrowBorder.StartPoint = new Point();                      arrowBorder.EndPoint = new Point(1.0' 1.0);                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x3C' 0x5E' 0x72)' 0.0));                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x3C' 0x5E' 0x72)' 0.1));                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xC3' 0xE4' 0xF5)' 1.0));                      arrowBorder.Freeze();                      CacheFreezable(arrowBorder' (int)AeroFreezables.ArrowBorder);                  }                    dc.DrawGeometry(arrowBorder' null' arrowGeometry);                    LinearGradientBrush arrowFill = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.ArrowFill);                  if (arrowFill == null)                  {                      arrowFill = new LinearGradientBrush();                      arrowFill.StartPoint = new Point();                      arrowFill.EndPoint = new Point(1.0' 1.0);                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x61' 0x96' 0xB6)' 0.0));                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x61' 0x96' 0xB6)' 0.1));                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xCA' 0xE6' 0xF5)' 1.0));                      arrowFill.Freeze();                      CacheFreezable(arrowFill' (int)AeroFreezables.ArrowFill);                  }                    // Inset the fill arrow inside the border arrow                  ScaleTransform arrowScale = (ScaleTransform)GetCachedFreezable((int)AeroFreezables.ArrowFillScale);                  if (arrowScale == null)                  {                      arrowScale = new ScaleTransform(0.75' 0.75' 3.5' 4.0);                      arrowScale.Freeze();                      CacheFreezable(arrowScale' (int)AeroFreezables.ArrowFillScale);                  }                    dc.PushTransform(arrowScale);                    dc.DrawGeometry(arrowFill' null' arrowGeometry);                    dc.Pop(); // Scale Transform                  dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // Draw the sort arrow                  TranslateTransform positionTransform = new TranslateTransform((size.Width - 8.0) * 0.5' 1.0);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)AeroFreezables.ArrowUpGeometry : (int)AeroFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 4.0);                            LineSegment line = new LineSegment(new Point(4.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(8.0' 4.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(8.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(4.0' 4.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)AeroFreezables.ArrowUpGeometry : (int)AeroFreezables.ArrowDownGeometry);                  }                    // Draw two arrows' one inset in the other. This is to achieve a double gradient over both the border and the fill.                  LinearGradientBrush arrowBorder = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.ArrowBorder);                  if (arrowBorder == null)                  {                      arrowBorder = new LinearGradientBrush();                      arrowBorder.StartPoint = new Point();                      arrowBorder.EndPoint = new Point(1.0' 1.0);                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x3C' 0x5E' 0x72)' 0.0));                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x3C' 0x5E' 0x72)' 0.1));                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xC3' 0xE4' 0xF5)' 1.0));                      arrowBorder.Freeze();                      CacheFreezable(arrowBorder' (int)AeroFreezables.ArrowBorder);                  }                    dc.DrawGeometry(arrowBorder' null' arrowGeometry);                    LinearGradientBrush arrowFill = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.ArrowFill);                  if (arrowFill == null)                  {                      arrowFill = new LinearGradientBrush();                      arrowFill.StartPoint = new Point();                      arrowFill.EndPoint = new Point(1.0' 1.0);                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x61' 0x96' 0xB6)' 0.0));                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x61' 0x96' 0xB6)' 0.1));                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xCA' 0xE6' 0xF5)' 1.0));                      arrowFill.Freeze();                      CacheFreezable(arrowFill' (int)AeroFreezables.ArrowFill);                  }                    // Inset the fill arrow inside the border arrow                  ScaleTransform arrowScale = (ScaleTransform)GetCachedFreezable((int)AeroFreezables.ArrowFillScale);                  if (arrowScale == null)                  {                      arrowScale = new ScaleTransform(0.75' 0.75' 3.5' 4.0);                      arrowScale.Freeze();                      CacheFreezable(arrowScale' (int)AeroFreezables.ArrowFillScale);                  }                    dc.PushTransform(arrowScale);                    dc.DrawGeometry(arrowFill' null' arrowGeometry);                    dc.Pop(); // Scale Transform                  dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // Draw the sort arrow                  TranslateTransform positionTransform = new TranslateTransform((size.Width - 8.0) * 0.5' 1.0);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)AeroFreezables.ArrowUpGeometry : (int)AeroFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 4.0);                            LineSegment line = new LineSegment(new Point(4.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(8.0' 4.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(8.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(4.0' 4.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)AeroFreezables.ArrowUpGeometry : (int)AeroFreezables.ArrowDownGeometry);                  }                    // Draw two arrows' one inset in the other. This is to achieve a double gradient over both the border and the fill.                  LinearGradientBrush arrowBorder = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.ArrowBorder);                  if (arrowBorder == null)                  {                      arrowBorder = new LinearGradientBrush();                      arrowBorder.StartPoint = new Point();                      arrowBorder.EndPoint = new Point(1.0' 1.0);                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x3C' 0x5E' 0x72)' 0.0));                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x3C' 0x5E' 0x72)' 0.1));                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xC3' 0xE4' 0xF5)' 1.0));                      arrowBorder.Freeze();                      CacheFreezable(arrowBorder' (int)AeroFreezables.ArrowBorder);                  }                    dc.DrawGeometry(arrowBorder' null' arrowGeometry);                    LinearGradientBrush arrowFill = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.ArrowFill);                  if (arrowFill == null)                  {                      arrowFill = new LinearGradientBrush();                      arrowFill.StartPoint = new Point();                      arrowFill.EndPoint = new Point(1.0' 1.0);                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x61' 0x96' 0xB6)' 0.0));                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x61' 0x96' 0xB6)' 0.1));                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xCA' 0xE6' 0xF5)' 1.0));                      arrowFill.Freeze();                      CacheFreezable(arrowFill' (int)AeroFreezables.ArrowFill);                  }                    // Inset the fill arrow inside the border arrow                  ScaleTransform arrowScale = (ScaleTransform)GetCachedFreezable((int)AeroFreezables.ArrowFillScale);                  if (arrowScale == null)                  {                      arrowScale = new ScaleTransform(0.75' 0.75' 3.5' 4.0);                      arrowScale.Freeze();                      CacheFreezable(arrowScale' (int)AeroFreezables.ArrowFillScale);                  }                    dc.PushTransform(arrowScale);                    dc.DrawGeometry(arrowFill' null' arrowGeometry);                    dc.Pop(); // Scale Transform                  dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // Draw the sort arrow                  TranslateTransform positionTransform = new TranslateTransform((size.Width - 8.0) * 0.5' 1.0);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)AeroFreezables.ArrowUpGeometry : (int)AeroFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 4.0);                            LineSegment line = new LineSegment(new Point(4.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(8.0' 4.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(8.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(4.0' 4.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)AeroFreezables.ArrowUpGeometry : (int)AeroFreezables.ArrowDownGeometry);                  }                    // Draw two arrows' one inset in the other. This is to achieve a double gradient over both the border and the fill.                  LinearGradientBrush arrowBorder = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.ArrowBorder);                  if (arrowBorder == null)                  {                      arrowBorder = new LinearGradientBrush();                      arrowBorder.StartPoint = new Point();                      arrowBorder.EndPoint = new Point(1.0' 1.0);                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x3C' 0x5E' 0x72)' 0.0));                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x3C' 0x5E' 0x72)' 0.1));                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xC3' 0xE4' 0xF5)' 1.0));                      arrowBorder.Freeze();                      CacheFreezable(arrowBorder' (int)AeroFreezables.ArrowBorder);                  }                    dc.DrawGeometry(arrowBorder' null' arrowGeometry);                    LinearGradientBrush arrowFill = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.ArrowFill);                  if (arrowFill == null)                  {                      arrowFill = new LinearGradientBrush();                      arrowFill.StartPoint = new Point();                      arrowFill.EndPoint = new Point(1.0' 1.0);                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x61' 0x96' 0xB6)' 0.0));                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x61' 0x96' 0xB6)' 0.1));                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xCA' 0xE6' 0xF5)' 1.0));                      arrowFill.Freeze();                      CacheFreezable(arrowFill' (int)AeroFreezables.ArrowFill);                  }                    // Inset the fill arrow inside the border arrow                  ScaleTransform arrowScale = (ScaleTransform)GetCachedFreezable((int)AeroFreezables.ArrowFillScale);                  if (arrowScale == null)                  {                      arrowScale = new ScaleTransform(0.75' 0.75' 3.5' 4.0);                      arrowScale.Freeze();                      CacheFreezable(arrowScale' (int)AeroFreezables.ArrowFillScale);                  }                    dc.PushTransform(arrowScale);                    dc.DrawGeometry(arrowFill' null' arrowGeometry);                    dc.Pop(); // Scale Transform                  dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // Draw the sort arrow                  TranslateTransform positionTransform = new TranslateTransform((size.Width - 8.0) * 0.5' 1.0);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)AeroFreezables.ArrowUpGeometry : (int)AeroFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 4.0);                            LineSegment line = new LineSegment(new Point(4.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(8.0' 4.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(8.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(4.0' 4.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)AeroFreezables.ArrowUpGeometry : (int)AeroFreezables.ArrowDownGeometry);                  }                    // Draw two arrows' one inset in the other. This is to achieve a double gradient over both the border and the fill.                  LinearGradientBrush arrowBorder = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.ArrowBorder);                  if (arrowBorder == null)                  {                      arrowBorder = new LinearGradientBrush();                      arrowBorder.StartPoint = new Point();                      arrowBorder.EndPoint = new Point(1.0' 1.0);                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x3C' 0x5E' 0x72)' 0.0));                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x3C' 0x5E' 0x72)' 0.1));                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xC3' 0xE4' 0xF5)' 1.0));                      arrowBorder.Freeze();                      CacheFreezable(arrowBorder' (int)AeroFreezables.ArrowBorder);                  }                    dc.DrawGeometry(arrowBorder' null' arrowGeometry);                    LinearGradientBrush arrowFill = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.ArrowFill);                  if (arrowFill == null)                  {                      arrowFill = new LinearGradientBrush();                      arrowFill.StartPoint = new Point();                      arrowFill.EndPoint = new Point(1.0' 1.0);                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x61' 0x96' 0xB6)' 0.0));                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x61' 0x96' 0xB6)' 0.1));                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xCA' 0xE6' 0xF5)' 1.0));                      arrowFill.Freeze();                      CacheFreezable(arrowFill' (int)AeroFreezables.ArrowFill);                  }                    // Inset the fill arrow inside the border arrow                  ScaleTransform arrowScale = (ScaleTransform)GetCachedFreezable((int)AeroFreezables.ArrowFillScale);                  if (arrowScale == null)                  {                      arrowScale = new ScaleTransform(0.75' 0.75' 3.5' 4.0);                      arrowScale.Freeze();                      CacheFreezable(arrowScale' (int)AeroFreezables.ArrowFillScale);                  }                    dc.PushTransform(arrowScale);                    dc.DrawGeometry(arrowFill' null' arrowGeometry);                    dc.Pop(); // Scale Transform                  dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // Draw the sort arrow                  TranslateTransform positionTransform = new TranslateTransform((size.Width - 8.0) * 0.5' 1.0);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)AeroFreezables.ArrowUpGeometry : (int)AeroFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 4.0);                            LineSegment line = new LineSegment(new Point(4.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(8.0' 4.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(8.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(4.0' 4.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)AeroFreezables.ArrowUpGeometry : (int)AeroFreezables.ArrowDownGeometry);                  }                    // Draw two arrows' one inset in the other. This is to achieve a double gradient over both the border and the fill.                  LinearGradientBrush arrowBorder = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.ArrowBorder);                  if (arrowBorder == null)                  {                      arrowBorder = new LinearGradientBrush();                      arrowBorder.StartPoint = new Point();                      arrowBorder.EndPoint = new Point(1.0' 1.0);                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x3C' 0x5E' 0x72)' 0.0));                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x3C' 0x5E' 0x72)' 0.1));                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xC3' 0xE4' 0xF5)' 1.0));                      arrowBorder.Freeze();                      CacheFreezable(arrowBorder' (int)AeroFreezables.ArrowBorder);                  }                    dc.DrawGeometry(arrowBorder' null' arrowGeometry);                    LinearGradientBrush arrowFill = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.ArrowFill);                  if (arrowFill == null)                  {                      arrowFill = new LinearGradientBrush();                      arrowFill.StartPoint = new Point();                      arrowFill.EndPoint = new Point(1.0' 1.0);                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x61' 0x96' 0xB6)' 0.0));                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x61' 0x96' 0xB6)' 0.1));                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xCA' 0xE6' 0xF5)' 1.0));                      arrowFill.Freeze();                      CacheFreezable(arrowFill' (int)AeroFreezables.ArrowFill);                  }                    // Inset the fill arrow inside the border arrow                  ScaleTransform arrowScale = (ScaleTransform)GetCachedFreezable((int)AeroFreezables.ArrowFillScale);                  if (arrowScale == null)                  {                      arrowScale = new ScaleTransform(0.75' 0.75' 3.5' 4.0);                      arrowScale.Freeze();                      CacheFreezable(arrowScale' (int)AeroFreezables.ArrowFillScale);                  }                    dc.PushTransform(arrowScale);                    dc.DrawGeometry(arrowFill' null' arrowGeometry);                    dc.Pop(); // Scale Transform                  dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // Draw the sort arrow                  TranslateTransform positionTransform = new TranslateTransform((size.Width - 8.0) * 0.5' 1.0);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)AeroFreezables.ArrowUpGeometry : (int)AeroFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 4.0);                            LineSegment line = new LineSegment(new Point(4.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(8.0' 4.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(8.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(4.0' 4.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)AeroFreezables.ArrowUpGeometry : (int)AeroFreezables.ArrowDownGeometry);                  }                    // Draw two arrows' one inset in the other. This is to achieve a double gradient over both the border and the fill.                  LinearGradientBrush arrowBorder = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.ArrowBorder);                  if (arrowBorder == null)                  {                      arrowBorder = new LinearGradientBrush();                      arrowBorder.StartPoint = new Point();                      arrowBorder.EndPoint = new Point(1.0' 1.0);                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x3C' 0x5E' 0x72)' 0.0));                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x3C' 0x5E' 0x72)' 0.1));                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xC3' 0xE4' 0xF5)' 1.0));                      arrowBorder.Freeze();                      CacheFreezable(arrowBorder' (int)AeroFreezables.ArrowBorder);                  }                    dc.DrawGeometry(arrowBorder' null' arrowGeometry);                    LinearGradientBrush arrowFill = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.ArrowFill);                  if (arrowFill == null)                  {                      arrowFill = new LinearGradientBrush();                      arrowFill.StartPoint = new Point();                      arrowFill.EndPoint = new Point(1.0' 1.0);                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x61' 0x96' 0xB6)' 0.0));                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x61' 0x96' 0xB6)' 0.1));                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xCA' 0xE6' 0xF5)' 1.0));                      arrowFill.Freeze();                      CacheFreezable(arrowFill' (int)AeroFreezables.ArrowFill);                  }                    // Inset the fill arrow inside the border arrow                  ScaleTransform arrowScale = (ScaleTransform)GetCachedFreezable((int)AeroFreezables.ArrowFillScale);                  if (arrowScale == null)                  {                      arrowScale = new ScaleTransform(0.75' 0.75' 3.5' 4.0);                      arrowScale.Freeze();                      CacheFreezable(arrowScale' (int)AeroFreezables.ArrowFillScale);                  }                    dc.PushTransform(arrowScale);                    dc.DrawGeometry(arrowFill' null' arrowGeometry);                    dc.Pop(); // Scale Transform                  dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // Draw the sort arrow                  TranslateTransform positionTransform = new TranslateTransform((size.Width - 8.0) * 0.5' 1.0);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)AeroFreezables.ArrowUpGeometry : (int)AeroFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 4.0);                            LineSegment line = new LineSegment(new Point(4.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(8.0' 4.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(8.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(4.0' 4.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)AeroFreezables.ArrowUpGeometry : (int)AeroFreezables.ArrowDownGeometry);                  }                    // Draw two arrows' one inset in the other. This is to achieve a double gradient over both the border and the fill.                  LinearGradientBrush arrowBorder = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.ArrowBorder);                  if (arrowBorder == null)                  {                      arrowBorder = new LinearGradientBrush();                      arrowBorder.StartPoint = new Point();                      arrowBorder.EndPoint = new Point(1.0' 1.0);                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x3C' 0x5E' 0x72)' 0.0));                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x3C' 0x5E' 0x72)' 0.1));                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xC3' 0xE4' 0xF5)' 1.0));                      arrowBorder.Freeze();                      CacheFreezable(arrowBorder' (int)AeroFreezables.ArrowBorder);                  }                    dc.DrawGeometry(arrowBorder' null' arrowGeometry);                    LinearGradientBrush arrowFill = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.ArrowFill);                  if (arrowFill == null)                  {                      arrowFill = new LinearGradientBrush();                      arrowFill.StartPoint = new Point();                      arrowFill.EndPoint = new Point(1.0' 1.0);                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x61' 0x96' 0xB6)' 0.0));                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x61' 0x96' 0xB6)' 0.1));                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xCA' 0xE6' 0xF5)' 1.0));                      arrowFill.Freeze();                      CacheFreezable(arrowFill' (int)AeroFreezables.ArrowFill);                  }                    // Inset the fill arrow inside the border arrow                  ScaleTransform arrowScale = (ScaleTransform)GetCachedFreezable((int)AeroFreezables.ArrowFillScale);                  if (arrowScale == null)                  {                      arrowScale = new ScaleTransform(0.75' 0.75' 3.5' 4.0);                      arrowScale.Freeze();                      CacheFreezable(arrowScale' (int)AeroFreezables.ArrowFillScale);                  }                    dc.PushTransform(arrowScale);                    dc.DrawGeometry(arrowFill' null' arrowGeometry);                    dc.Pop(); // Scale Transform                  dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // Draw the sort arrow                  TranslateTransform positionTransform = new TranslateTransform((size.Width - 8.0) * 0.5' 1.0);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)AeroFreezables.ArrowUpGeometry : (int)AeroFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 4.0);                            LineSegment line = new LineSegment(new Point(4.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(8.0' 4.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(8.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(4.0' 4.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)AeroFreezables.ArrowUpGeometry : (int)AeroFreezables.ArrowDownGeometry);                  }                    // Draw two arrows' one inset in the other. This is to achieve a double gradient over both the border and the fill.                  LinearGradientBrush arrowBorder = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.ArrowBorder);                  if (arrowBorder == null)                  {                      arrowBorder = new LinearGradientBrush();                      arrowBorder.StartPoint = new Point();                      arrowBorder.EndPoint = new Point(1.0' 1.0);                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x3C' 0x5E' 0x72)' 0.0));                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x3C' 0x5E' 0x72)' 0.1));                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xC3' 0xE4' 0xF5)' 1.0));                      arrowBorder.Freeze();                      CacheFreezable(arrowBorder' (int)AeroFreezables.ArrowBorder);                  }                    dc.DrawGeometry(arrowBorder' null' arrowGeometry);                    LinearGradientBrush arrowFill = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.ArrowFill);                  if (arrowFill == null)                  {                      arrowFill = new LinearGradientBrush();                      arrowFill.StartPoint = new Point();                      arrowFill.EndPoint = new Point(1.0' 1.0);                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x61' 0x96' 0xB6)' 0.0));                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x61' 0x96' 0xB6)' 0.1));                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xCA' 0xE6' 0xF5)' 1.0));                      arrowFill.Freeze();                      CacheFreezable(arrowFill' (int)AeroFreezables.ArrowFill);                  }                    // Inset the fill arrow inside the border arrow                  ScaleTransform arrowScale = (ScaleTransform)GetCachedFreezable((int)AeroFreezables.ArrowFillScale);                  if (arrowScale == null)                  {                      arrowScale = new ScaleTransform(0.75' 0.75' 3.5' 4.0);                      arrowScale.Freeze();                      CacheFreezable(arrowScale' (int)AeroFreezables.ArrowFillScale);                  }                    dc.PushTransform(arrowScale);                    dc.DrawGeometry(arrowFill' null' arrowGeometry);                    dc.Pop(); // Scale Transform                  dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // Draw the sort arrow                  TranslateTransform positionTransform = new TranslateTransform((size.Width - 8.0) * 0.5' 1.0);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)AeroFreezables.ArrowUpGeometry : (int)AeroFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 4.0);                            LineSegment line = new LineSegment(new Point(4.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(8.0' 4.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(8.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(4.0' 4.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)AeroFreezables.ArrowUpGeometry : (int)AeroFreezables.ArrowDownGeometry);                  }                    // Draw two arrows' one inset in the other. This is to achieve a double gradient over both the border and the fill.                  LinearGradientBrush arrowBorder = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.ArrowBorder);                  if (arrowBorder == null)                  {                      arrowBorder = new LinearGradientBrush();                      arrowBorder.StartPoint = new Point();                      arrowBorder.EndPoint = new Point(1.0' 1.0);                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x3C' 0x5E' 0x72)' 0.0));                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x3C' 0x5E' 0x72)' 0.1));                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xC3' 0xE4' 0xF5)' 1.0));                      arrowBorder.Freeze();                      CacheFreezable(arrowBorder' (int)AeroFreezables.ArrowBorder);                  }                    dc.DrawGeometry(arrowBorder' null' arrowGeometry);                    LinearGradientBrush arrowFill = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.ArrowFill);                  if (arrowFill == null)                  {                      arrowFill = new LinearGradientBrush();                      arrowFill.StartPoint = new Point();                      arrowFill.EndPoint = new Point(1.0' 1.0);                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x61' 0x96' 0xB6)' 0.0));                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x61' 0x96' 0xB6)' 0.1));                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xCA' 0xE6' 0xF5)' 1.0));                      arrowFill.Freeze();                      CacheFreezable(arrowFill' (int)AeroFreezables.ArrowFill);                  }                    // Inset the fill arrow inside the border arrow                  ScaleTransform arrowScale = (ScaleTransform)GetCachedFreezable((int)AeroFreezables.ArrowFillScale);                  if (arrowScale == null)                  {                      arrowScale = new ScaleTransform(0.75' 0.75' 3.5' 4.0);                      arrowScale.Freeze();                      CacheFreezable(arrowScale' (int)AeroFreezables.ArrowFillScale);                  }                    dc.PushTransform(arrowScale);                    dc.DrawGeometry(arrowFill' null' arrowGeometry);                    dc.Pop(); // Scale Transform                  dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // Draw the sort arrow                  TranslateTransform positionTransform = new TranslateTransform((size.Width - 8.0) * 0.5' 1.0);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)AeroFreezables.ArrowUpGeometry : (int)AeroFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 4.0);                            LineSegment line = new LineSegment(new Point(4.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(8.0' 4.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(8.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(4.0' 4.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)AeroFreezables.ArrowUpGeometry : (int)AeroFreezables.ArrowDownGeometry);                  }                    // Draw two arrows' one inset in the other. This is to achieve a double gradient over both the border and the fill.                  LinearGradientBrush arrowBorder = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.ArrowBorder);                  if (arrowBorder == null)                  {                      arrowBorder = new LinearGradientBrush();                      arrowBorder.StartPoint = new Point();                      arrowBorder.EndPoint = new Point(1.0' 1.0);                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x3C' 0x5E' 0x72)' 0.0));                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x3C' 0x5E' 0x72)' 0.1));                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xC3' 0xE4' 0xF5)' 1.0));                      arrowBorder.Freeze();                      CacheFreezable(arrowBorder' (int)AeroFreezables.ArrowBorder);                  }                    dc.DrawGeometry(arrowBorder' null' arrowGeometry);                    LinearGradientBrush arrowFill = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.ArrowFill);                  if (arrowFill == null)                  {                      arrowFill = new LinearGradientBrush();                      arrowFill.StartPoint = new Point();                      arrowFill.EndPoint = new Point(1.0' 1.0);                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x61' 0x96' 0xB6)' 0.0));                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x61' 0x96' 0xB6)' 0.1));                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xCA' 0xE6' 0xF5)' 1.0));                      arrowFill.Freeze();                      CacheFreezable(arrowFill' (int)AeroFreezables.ArrowFill);                  }                    // Inset the fill arrow inside the border arrow                  ScaleTransform arrowScale = (ScaleTransform)GetCachedFreezable((int)AeroFreezables.ArrowFillScale);                  if (arrowScale == null)                  {                      arrowScale = new ScaleTransform(0.75' 0.75' 3.5' 4.0);                      arrowScale.Freeze();                      CacheFreezable(arrowScale' (int)AeroFreezables.ArrowFillScale);                  }                    dc.PushTransform(arrowScale);                    dc.DrawGeometry(arrowFill' null' arrowGeometry);                    dc.Pop(); // Scale Transform                  dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // Draw the sort arrow                  TranslateTransform positionTransform = new TranslateTransform((size.Width - 8.0) * 0.5' 1.0);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)AeroFreezables.ArrowUpGeometry : (int)AeroFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 4.0);                            LineSegment line = new LineSegment(new Point(4.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(8.0' 4.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(8.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(4.0' 4.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)AeroFreezables.ArrowUpGeometry : (int)AeroFreezables.ArrowDownGeometry);                  }                    // Draw two arrows' one inset in the other. This is to achieve a double gradient over both the border and the fill.                  LinearGradientBrush arrowBorder = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.ArrowBorder);                  if (arrowBorder == null)                  {                      arrowBorder = new LinearGradientBrush();                      arrowBorder.StartPoint = new Point();                      arrowBorder.EndPoint = new Point(1.0' 1.0);                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x3C' 0x5E' 0x72)' 0.0));                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x3C' 0x5E' 0x72)' 0.1));                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xC3' 0xE4' 0xF5)' 1.0));                      arrowBorder.Freeze();                      CacheFreezable(arrowBorder' (int)AeroFreezables.ArrowBorder);                  }                    dc.DrawGeometry(arrowBorder' null' arrowGeometry);                    LinearGradientBrush arrowFill = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.ArrowFill);                  if (arrowFill == null)                  {                      arrowFill = new LinearGradientBrush();                      arrowFill.StartPoint = new Point();                      arrowFill.EndPoint = new Point(1.0' 1.0);                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x61' 0x96' 0xB6)' 0.0));                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x61' 0x96' 0xB6)' 0.1));                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xCA' 0xE6' 0xF5)' 1.0));                      arrowFill.Freeze();                      CacheFreezable(arrowFill' (int)AeroFreezables.ArrowFill);                  }                    // Inset the fill arrow inside the border arrow                  ScaleTransform arrowScale = (ScaleTransform)GetCachedFreezable((int)AeroFreezables.ArrowFillScale);                  if (arrowScale == null)                  {                      arrowScale = new ScaleTransform(0.75' 0.75' 3.5' 4.0);                      arrowScale.Freeze();                      CacheFreezable(arrowScale' (int)AeroFreezables.ArrowFillScale);                  }                    dc.PushTransform(arrowScale);                    dc.DrawGeometry(arrowFill' null' arrowGeometry);                    dc.Pop(); // Scale Transform                  dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // Draw the sort arrow                  TranslateTransform positionTransform = new TranslateTransform((size.Width - 8.0) * 0.5' 1.0);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)AeroFreezables.ArrowUpGeometry : (int)AeroFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 4.0);                            LineSegment line = new LineSegment(new Point(4.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(8.0' 4.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(8.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(4.0' 4.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)AeroFreezables.ArrowUpGeometry : (int)AeroFreezables.ArrowDownGeometry);                  }                    // Draw two arrows' one inset in the other. This is to achieve a double gradient over both the border and the fill.                  LinearGradientBrush arrowBorder = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.ArrowBorder);                  if (arrowBorder == null)                  {                      arrowBorder = new LinearGradientBrush();                      arrowBorder.StartPoint = new Point();                      arrowBorder.EndPoint = new Point(1.0' 1.0);                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x3C' 0x5E' 0x72)' 0.0));                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x3C' 0x5E' 0x72)' 0.1));                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xC3' 0xE4' 0xF5)' 1.0));                      arrowBorder.Freeze();                      CacheFreezable(arrowBorder' (int)AeroFreezables.ArrowBorder);                  }                    dc.DrawGeometry(arrowBorder' null' arrowGeometry);                    LinearGradientBrush arrowFill = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.ArrowFill);                  if (arrowFill == null)                  {                      arrowFill = new LinearGradientBrush();                      arrowFill.StartPoint = new Point();                      arrowFill.EndPoint = new Point(1.0' 1.0);                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x61' 0x96' 0xB6)' 0.0));                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x61' 0x96' 0xB6)' 0.1));                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xCA' 0xE6' 0xF5)' 1.0));                      arrowFill.Freeze();                      CacheFreezable(arrowFill' (int)AeroFreezables.ArrowFill);                  }                    // Inset the fill arrow inside the border arrow                  ScaleTransform arrowScale = (ScaleTransform)GetCachedFreezable((int)AeroFreezables.ArrowFillScale);                  if (arrowScale == null)                  {                      arrowScale = new ScaleTransform(0.75' 0.75' 3.5' 4.0);                      arrowScale.Freeze();                      CacheFreezable(arrowScale' (int)AeroFreezables.ArrowFillScale);                  }                    dc.PushTransform(arrowScale);                    dc.DrawGeometry(arrowFill' null' arrowGeometry);                    dc.Pop(); // Scale Transform                  dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // Draw the sort arrow                  TranslateTransform positionTransform = new TranslateTransform((size.Width - 8.0) * 0.5' 1.0);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)AeroFreezables.ArrowUpGeometry : (int)AeroFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 4.0);                            LineSegment line = new LineSegment(new Point(4.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(8.0' 4.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(8.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(4.0' 4.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)AeroFreezables.ArrowUpGeometry : (int)AeroFreezables.ArrowDownGeometry);                  }                    // Draw two arrows' one inset in the other. This is to achieve a double gradient over both the border and the fill.                  LinearGradientBrush arrowBorder = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.ArrowBorder);                  if (arrowBorder == null)                  {                      arrowBorder = new LinearGradientBrush();                      arrowBorder.StartPoint = new Point();                      arrowBorder.EndPoint = new Point(1.0' 1.0);                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x3C' 0x5E' 0x72)' 0.0));                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x3C' 0x5E' 0x72)' 0.1));                      arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xC3' 0xE4' 0xF5)' 1.0));                      arrowBorder.Freeze();                      CacheFreezable(arrowBorder' (int)AeroFreezables.ArrowBorder);                  }                    dc.DrawGeometry(arrowBorder' null' arrowGeometry);                    LinearGradientBrush arrowFill = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.ArrowFill);                  if (arrowFill == null)                  {                      arrowFill = new LinearGradientBrush();                      arrowFill.StartPoint = new Point();                      arrowFill.EndPoint = new Point(1.0' 1.0);                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x61' 0x96' 0xB6)' 0.0));                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x61' 0x96' 0xB6)' 0.1));                      arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xCA' 0xE6' 0xF5)' 1.0));                      arrowFill.Freeze();                      CacheFreezable(arrowFill' (int)AeroFreezables.ArrowFill);                  }                    // Inset the fill arrow inside the border arrow                  ScaleTransform arrowScale = (ScaleTransform)GetCachedFreezable((int)AeroFreezables.ArrowFillScale);                  if (arrowScale == null)                  {                      arrowScale = new ScaleTransform(0.75' 0.75' 3.5' 4.0);                      arrowScale.Freeze();                      CacheFreezable(arrowScale' (int)AeroFreezables.ArrowFillScale);                  }                    dc.PushTransform(arrowScale);                    dc.DrawGeometry(arrowFill' null' arrowGeometry);                    dc.Pop(); // Scale Transform                  dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (horizontal)              {                  // When horizontal' rotate the rendering by -90 degrees                  Matrix m1 = new Matrix();                  m1.RotateAt(-90.0' 0.0' 0.0);                  Matrix m2 = new Matrix();                  m2.Translate(0.0' size.Height);                    MatrixTransform horizontalRotate = new MatrixTransform(m1 * m2);                  horizontalRotate.Freeze();                  dc.PushTransform(horizontalRotate);                    double temp = size.Width;                  size.Width = size.Height;                  size.Height = temp;              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (background == null)              {                  background = new LinearGradientBrush();                  background.StartPoint = new Point();                  background.EndPoint = new Point(0.0' 1.0);                    if (isPressed)                  {                      if (colorVariant == Luna.Metallic)                      {                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xB9' 0xB9' 0xC8)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEC' 0xEC' 0xF3)' 0.1));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEC' 0xEC' 0xF3)' 1.0));                      }                      else                      {                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xC1' 0xC2' 0xB8)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDE' 0xDF' 0xD8)' 0.1));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDE' 0xDF' 0xD8)' 1.0));                      }                  }                  else if (isHovered || isSelected)                  {                      if (colorVariant == Luna.Metallic)                      {                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFE' 0xFE' 0xFE)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFE' 0xFE' 0xFE)' 0.85));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBD' 0xBE' 0xCE)' 1.0));                      }                      else                      {                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFA' 0xF9' 0xF4)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFA' 0xF9' 0xF4)' 0.85));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEC' 0xE9' 0xD8)' 1.0));                      }                  }                  else                  {                      if (colorVariant == Luna.Metallic)                      {                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF9' 0xFA' 0xFD)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF9' 0xFA' 0xFD)' 0.85));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBD' 0xBE' 0xCE)' 1.0));                      }                      else                      {                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEB' 0xEA' 0xDB)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEB' 0xEA' 0xDB)' 0.85));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xCB' 0xC7' 0xB8)' 1.0));                      }                  }                    background.Freeze();                  CacheFreezable(background' (int)backgroundType);              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (background == null)              {                  background = new LinearGradientBrush();                  background.StartPoint = new Point();                  background.EndPoint = new Point(0.0' 1.0);                    if (isPressed)                  {                      if (colorVariant == Luna.Metallic)                      {                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xB9' 0xB9' 0xC8)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEC' 0xEC' 0xF3)' 0.1));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEC' 0xEC' 0xF3)' 1.0));                      }                      else                      {                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xC1' 0xC2' 0xB8)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDE' 0xDF' 0xD8)' 0.1));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDE' 0xDF' 0xD8)' 1.0));                      }                  }                  else if (isHovered || isSelected)                  {                      if (colorVariant == Luna.Metallic)                      {                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFE' 0xFE' 0xFE)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFE' 0xFE' 0xFE)' 0.85));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBD' 0xBE' 0xCE)' 1.0));                      }                      else                      {                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFA' 0xF9' 0xF4)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFA' 0xF9' 0xF4)' 0.85));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEC' 0xE9' 0xD8)' 1.0));                      }                  }                  else                  {                      if (colorVariant == Luna.Metallic)                      {                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF9' 0xFA' 0xFD)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF9' 0xFA' 0xFD)' 0.85));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBD' 0xBE' 0xCE)' 1.0));                      }                      else                      {                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEB' 0xEA' 0xDB)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEB' 0xEA' 0xDB)' 0.85));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xCB' 0xC7' 0xB8)' 1.0));                      }                  }                    background.Freeze();                  CacheFreezable(background' (int)backgroundType);              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (background == null)              {                  background = new LinearGradientBrush();                  background.StartPoint = new Point();                  background.EndPoint = new Point(0.0' 1.0);                    if (isPressed)                  {                      if (colorVariant == Luna.Metallic)                      {                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xB9' 0xB9' 0xC8)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEC' 0xEC' 0xF3)' 0.1));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEC' 0xEC' 0xF3)' 1.0));                      }                      else                      {                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xC1' 0xC2' 0xB8)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDE' 0xDF' 0xD8)' 0.1));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDE' 0xDF' 0xD8)' 1.0));                      }                  }                  else if (isHovered || isSelected)                  {                      if (colorVariant == Luna.Metallic)                      {                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFE' 0xFE' 0xFE)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFE' 0xFE' 0xFE)' 0.85));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBD' 0xBE' 0xCE)' 1.0));                      }                      else                      {                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFA' 0xF9' 0xF4)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFA' 0xF9' 0xF4)' 0.85));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEC' 0xE9' 0xD8)' 1.0));                      }                  }                  else                  {                      if (colorVariant == Luna.Metallic)                      {                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF9' 0xFA' 0xFD)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF9' 0xFA' 0xFD)' 0.85));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBD' 0xBE' 0xCE)' 1.0));                      }                      else                      {                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEB' 0xEA' 0xDB)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEB' 0xEA' 0xDB)' 0.85));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xCB' 0xC7' 0xB8)' 1.0));                      }                  }                    background.Freeze();                  CacheFreezable(background' (int)backgroundType);              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (background == null)              {                  background = new LinearGradientBrush();                  background.StartPoint = new Point();                  background.EndPoint = new Point(0.0' 1.0);                    if (isPressed)                  {                      if (colorVariant == Luna.Metallic)                      {                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xB9' 0xB9' 0xC8)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEC' 0xEC' 0xF3)' 0.1));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEC' 0xEC' 0xF3)' 1.0));                      }                      else                      {                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xC1' 0xC2' 0xB8)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDE' 0xDF' 0xD8)' 0.1));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDE' 0xDF' 0xD8)' 1.0));                      }                  }                  else if (isHovered || isSelected)                  {                      if (colorVariant == Luna.Metallic)                      {                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFE' 0xFE' 0xFE)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFE' 0xFE' 0xFE)' 0.85));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBD' 0xBE' 0xCE)' 1.0));                      }                      else                      {                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFA' 0xF9' 0xF4)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFA' 0xF9' 0xF4)' 0.85));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEC' 0xE9' 0xD8)' 1.0));                      }                  }                  else                  {                      if (colorVariant == Luna.Metallic)                      {                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF9' 0xFA' 0xFD)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF9' 0xFA' 0xFD)' 0.85));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBD' 0xBE' 0xCE)' 1.0));                      }                      else                      {                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEB' 0xEA' 0xDB)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEB' 0xEA' 0xDB)' 0.85));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xCB' 0xC7' 0xB8)' 1.0));                      }                  }                    background.Freeze();                  CacheFreezable(background' (int)backgroundType);              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (background == null)              {                  background = new LinearGradientBrush();                  background.StartPoint = new Point();                  background.EndPoint = new Point(0.0' 1.0);                    if (isPressed)                  {                      if (colorVariant == Luna.Metallic)                      {                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xB9' 0xB9' 0xC8)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEC' 0xEC' 0xF3)' 0.1));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEC' 0xEC' 0xF3)' 1.0));                      }                      else                      {                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xC1' 0xC2' 0xB8)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDE' 0xDF' 0xD8)' 0.1));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDE' 0xDF' 0xD8)' 1.0));                      }                  }                  else if (isHovered || isSelected)                  {                      if (colorVariant == Luna.Metallic)                      {                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFE' 0xFE' 0xFE)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFE' 0xFE' 0xFE)' 0.85));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBD' 0xBE' 0xCE)' 1.0));                      }                      else                      {                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFA' 0xF9' 0xF4)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFA' 0xF9' 0xF4)' 0.85));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEC' 0xE9' 0xD8)' 1.0));                      }                  }                  else                  {                      if (colorVariant == Luna.Metallic)                      {                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF9' 0xFA' 0xFD)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF9' 0xFA' 0xFD)' 0.85));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBD' 0xBE' 0xCE)' 1.0));                      }                      else                      {                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEB' 0xEA' 0xDB)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEB' 0xEA' 0xDB)' 0.85));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xCB' 0xC7' 0xB8)' 1.0));                      }                  }                    background.Freeze();                  CacheFreezable(background' (int)backgroundType);              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (background == null)              {                  background = new LinearGradientBrush();                  background.StartPoint = new Point();                  background.EndPoint = new Point(0.0' 1.0);                    if (isPressed)                  {                      if (colorVariant == Luna.Metallic)                      {                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xB9' 0xB9' 0xC8)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEC' 0xEC' 0xF3)' 0.1));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEC' 0xEC' 0xF3)' 1.0));                      }                      else                      {                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xC1' 0xC2' 0xB8)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDE' 0xDF' 0xD8)' 0.1));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDE' 0xDF' 0xD8)' 1.0));                      }                  }                  else if (isHovered || isSelected)                  {                      if (colorVariant == Luna.Metallic)                      {                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFE' 0xFE' 0xFE)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFE' 0xFE' 0xFE)' 0.85));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBD' 0xBE' 0xCE)' 1.0));                      }                      else                      {                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFA' 0xF9' 0xF4)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFA' 0xF9' 0xF4)' 0.85));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEC' 0xE9' 0xD8)' 1.0));                      }                  }                  else                  {                      if (colorVariant == Luna.Metallic)                      {                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF9' 0xFA' 0xFD)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF9' 0xFA' 0xFD)' 0.85));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBD' 0xBE' 0xCE)' 1.0));                      }                      else                      {                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEB' 0xEA' 0xDB)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEB' 0xEA' 0xDB)' 0.85));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xCB' 0xC7' 0xB8)' 1.0));                      }                  }                    background.Freeze();                  CacheFreezable(background' (int)backgroundType);              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (isHovered && !isPressed && (size.Width >= 6.0) && (size.Height >= 4.0))              {                  // When hovered' there is a colored tab at the bottom                  TranslateTransform positionTransform = new TranslateTransform(0.0' size.Height - 3.0);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    PathGeometry tabGeometry = new PathGeometry();                  PathFigure tabFigure = new PathFigure();                    tabFigure.StartPoint = new Point(0.5' 0.5);                    LineSegment line = new LineSegment(new Point(size.Width - 0.5' 0.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    ArcSegment arc = new ArcSegment(new Point(size.Width - 2.5' 2.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    line = new LineSegment(new Point(2.5' 2.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    arc = new ArcSegment(new Point(0.5' 0.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    tabFigure.IsClosed = true;                  tabFigure.Freeze();                    tabGeometry.Figures.Add(tabFigure);                  tabGeometry.Freeze();                    Pen tabStroke = (Pen)GetCachedFreezable((int)LunaFreezables.TabStroke);                  if (tabStroke == null)                  {                      SolidColorBrush tabStrokeBrush = new SolidColorBrush((colorVariant == Luna.HomeStead) ? Color.FromArgb(0xFF' 0xCF' 0x72' 0x25) : Color.FromArgb(0xFF' 0xF8' 0xA9' 0x00));                      tabStrokeBrush.Freeze();                        tabStroke = new Pen(tabStrokeBrush' 1.0);                      tabStroke.Freeze();                        CacheFreezable(tabStroke' (int)LunaFreezables.TabStroke);                  }                    LinearGradientBrush tabFill = (LinearGradientBrush)GetCachedFreezable((int)LunaFreezables.TabFill);                  if (tabFill == null)                  {                      tabFill = new LinearGradientBrush();                      tabFill.StartPoint = new Point();                      tabFill.EndPoint = new Point(1.0' 0.0);                      if (colorVariant == Luna.HomeStead)                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 1.0));                      }                      else                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFC' 0xE0' 0xA6)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.1));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.9));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDF' 0x97' 0x00)' 1.0));                      }                        tabFill.Freeze();                      CacheFreezable(tabFill' (int)LunaFreezables.TabFill);                  }                    dc.DrawGeometry(tabFill' tabStroke' tabGeometry);                                    dc.Pop(); // Translate Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (isHovered && !isPressed && (size.Width >= 6.0) && (size.Height >= 4.0))              {                  // When hovered' there is a colored tab at the bottom                  TranslateTransform positionTransform = new TranslateTransform(0.0' size.Height - 3.0);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    PathGeometry tabGeometry = new PathGeometry();                  PathFigure tabFigure = new PathFigure();                    tabFigure.StartPoint = new Point(0.5' 0.5);                    LineSegment line = new LineSegment(new Point(size.Width - 0.5' 0.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    ArcSegment arc = new ArcSegment(new Point(size.Width - 2.5' 2.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    line = new LineSegment(new Point(2.5' 2.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    arc = new ArcSegment(new Point(0.5' 0.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    tabFigure.IsClosed = true;                  tabFigure.Freeze();                    tabGeometry.Figures.Add(tabFigure);                  tabGeometry.Freeze();                    Pen tabStroke = (Pen)GetCachedFreezable((int)LunaFreezables.TabStroke);                  if (tabStroke == null)                  {                      SolidColorBrush tabStrokeBrush = new SolidColorBrush((colorVariant == Luna.HomeStead) ? Color.FromArgb(0xFF' 0xCF' 0x72' 0x25) : Color.FromArgb(0xFF' 0xF8' 0xA9' 0x00));                      tabStrokeBrush.Freeze();                        tabStroke = new Pen(tabStrokeBrush' 1.0);                      tabStroke.Freeze();                        CacheFreezable(tabStroke' (int)LunaFreezables.TabStroke);                  }                    LinearGradientBrush tabFill = (LinearGradientBrush)GetCachedFreezable((int)LunaFreezables.TabFill);                  if (tabFill == null)                  {                      tabFill = new LinearGradientBrush();                      tabFill.StartPoint = new Point();                      tabFill.EndPoint = new Point(1.0' 0.0);                      if (colorVariant == Luna.HomeStead)                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 1.0));                      }                      else                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFC' 0xE0' 0xA6)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.1));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.9));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDF' 0x97' 0x00)' 1.0));                      }                        tabFill.Freeze();                      CacheFreezable(tabFill' (int)LunaFreezables.TabFill);                  }                    dc.DrawGeometry(tabFill' tabStroke' tabGeometry);                                    dc.Pop(); // Translate Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (isHovered && !isPressed && (size.Width >= 6.0) && (size.Height >= 4.0))              {                  // When hovered' there is a colored tab at the bottom                  TranslateTransform positionTransform = new TranslateTransform(0.0' size.Height - 3.0);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    PathGeometry tabGeometry = new PathGeometry();                  PathFigure tabFigure = new PathFigure();                    tabFigure.StartPoint = new Point(0.5' 0.5);                    LineSegment line = new LineSegment(new Point(size.Width - 0.5' 0.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    ArcSegment arc = new ArcSegment(new Point(size.Width - 2.5' 2.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    line = new LineSegment(new Point(2.5' 2.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    arc = new ArcSegment(new Point(0.5' 0.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    tabFigure.IsClosed = true;                  tabFigure.Freeze();                    tabGeometry.Figures.Add(tabFigure);                  tabGeometry.Freeze();                    Pen tabStroke = (Pen)GetCachedFreezable((int)LunaFreezables.TabStroke);                  if (tabStroke == null)                  {                      SolidColorBrush tabStrokeBrush = new SolidColorBrush((colorVariant == Luna.HomeStead) ? Color.FromArgb(0xFF' 0xCF' 0x72' 0x25) : Color.FromArgb(0xFF' 0xF8' 0xA9' 0x00));                      tabStrokeBrush.Freeze();                        tabStroke = new Pen(tabStrokeBrush' 1.0);                      tabStroke.Freeze();                        CacheFreezable(tabStroke' (int)LunaFreezables.TabStroke);                  }                    LinearGradientBrush tabFill = (LinearGradientBrush)GetCachedFreezable((int)LunaFreezables.TabFill);                  if (tabFill == null)                  {                      tabFill = new LinearGradientBrush();                      tabFill.StartPoint = new Point();                      tabFill.EndPoint = new Point(1.0' 0.0);                      if (colorVariant == Luna.HomeStead)                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 1.0));                      }                      else                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFC' 0xE0' 0xA6)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.1));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.9));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDF' 0x97' 0x00)' 1.0));                      }                        tabFill.Freeze();                      CacheFreezable(tabFill' (int)LunaFreezables.TabFill);                  }                    dc.DrawGeometry(tabFill' tabStroke' tabGeometry);                                    dc.Pop(); // Translate Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (isHovered && !isPressed && (size.Width >= 6.0) && (size.Height >= 4.0))              {                  // When hovered' there is a colored tab at the bottom                  TranslateTransform positionTransform = new TranslateTransform(0.0' size.Height - 3.0);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    PathGeometry tabGeometry = new PathGeometry();                  PathFigure tabFigure = new PathFigure();                    tabFigure.StartPoint = new Point(0.5' 0.5);                    LineSegment line = new LineSegment(new Point(size.Width - 0.5' 0.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    ArcSegment arc = new ArcSegment(new Point(size.Width - 2.5' 2.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    line = new LineSegment(new Point(2.5' 2.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    arc = new ArcSegment(new Point(0.5' 0.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    tabFigure.IsClosed = true;                  tabFigure.Freeze();                    tabGeometry.Figures.Add(tabFigure);                  tabGeometry.Freeze();                    Pen tabStroke = (Pen)GetCachedFreezable((int)LunaFreezables.TabStroke);                  if (tabStroke == null)                  {                      SolidColorBrush tabStrokeBrush = new SolidColorBrush((colorVariant == Luna.HomeStead) ? Color.FromArgb(0xFF' 0xCF' 0x72' 0x25) : Color.FromArgb(0xFF' 0xF8' 0xA9' 0x00));                      tabStrokeBrush.Freeze();                        tabStroke = new Pen(tabStrokeBrush' 1.0);                      tabStroke.Freeze();                        CacheFreezable(tabStroke' (int)LunaFreezables.TabStroke);                  }                    LinearGradientBrush tabFill = (LinearGradientBrush)GetCachedFreezable((int)LunaFreezables.TabFill);                  if (tabFill == null)                  {                      tabFill = new LinearGradientBrush();                      tabFill.StartPoint = new Point();                      tabFill.EndPoint = new Point(1.0' 0.0);                      if (colorVariant == Luna.HomeStead)                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 1.0));                      }                      else                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFC' 0xE0' 0xA6)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.1));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.9));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDF' 0x97' 0x00)' 1.0));                      }                        tabFill.Freeze();                      CacheFreezable(tabFill' (int)LunaFreezables.TabFill);                  }                    dc.DrawGeometry(tabFill' tabStroke' tabGeometry);                                    dc.Pop(); // Translate Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (isHovered && !isPressed && (size.Width >= 6.0) && (size.Height >= 4.0))              {                  // When hovered' there is a colored tab at the bottom                  TranslateTransform positionTransform = new TranslateTransform(0.0' size.Height - 3.0);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    PathGeometry tabGeometry = new PathGeometry();                  PathFigure tabFigure = new PathFigure();                    tabFigure.StartPoint = new Point(0.5' 0.5);                    LineSegment line = new LineSegment(new Point(size.Width - 0.5' 0.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    ArcSegment arc = new ArcSegment(new Point(size.Width - 2.5' 2.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    line = new LineSegment(new Point(2.5' 2.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    arc = new ArcSegment(new Point(0.5' 0.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    tabFigure.IsClosed = true;                  tabFigure.Freeze();                    tabGeometry.Figures.Add(tabFigure);                  tabGeometry.Freeze();                    Pen tabStroke = (Pen)GetCachedFreezable((int)LunaFreezables.TabStroke);                  if (tabStroke == null)                  {                      SolidColorBrush tabStrokeBrush = new SolidColorBrush((colorVariant == Luna.HomeStead) ? Color.FromArgb(0xFF' 0xCF' 0x72' 0x25) : Color.FromArgb(0xFF' 0xF8' 0xA9' 0x00));                      tabStrokeBrush.Freeze();                        tabStroke = new Pen(tabStrokeBrush' 1.0);                      tabStroke.Freeze();                        CacheFreezable(tabStroke' (int)LunaFreezables.TabStroke);                  }                    LinearGradientBrush tabFill = (LinearGradientBrush)GetCachedFreezable((int)LunaFreezables.TabFill);                  if (tabFill == null)                  {                      tabFill = new LinearGradientBrush();                      tabFill.StartPoint = new Point();                      tabFill.EndPoint = new Point(1.0' 0.0);                      if (colorVariant == Luna.HomeStead)                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 1.0));                      }                      else                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFC' 0xE0' 0xA6)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.1));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.9));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDF' 0x97' 0x00)' 1.0));                      }                        tabFill.Freeze();                      CacheFreezable(tabFill' (int)LunaFreezables.TabFill);                  }                    dc.DrawGeometry(tabFill' tabStroke' tabGeometry);                                    dc.Pop(); // Translate Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (isHovered && !isPressed && (size.Width >= 6.0) && (size.Height >= 4.0))              {                  // When hovered' there is a colored tab at the bottom                  TranslateTransform positionTransform = new TranslateTransform(0.0' size.Height - 3.0);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    PathGeometry tabGeometry = new PathGeometry();                  PathFigure tabFigure = new PathFigure();                    tabFigure.StartPoint = new Point(0.5' 0.5);                    LineSegment line = new LineSegment(new Point(size.Width - 0.5' 0.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    ArcSegment arc = new ArcSegment(new Point(size.Width - 2.5' 2.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    line = new LineSegment(new Point(2.5' 2.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    arc = new ArcSegment(new Point(0.5' 0.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    tabFigure.IsClosed = true;                  tabFigure.Freeze();                    tabGeometry.Figures.Add(tabFigure);                  tabGeometry.Freeze();                    Pen tabStroke = (Pen)GetCachedFreezable((int)LunaFreezables.TabStroke);                  if (tabStroke == null)                  {                      SolidColorBrush tabStrokeBrush = new SolidColorBrush((colorVariant == Luna.HomeStead) ? Color.FromArgb(0xFF' 0xCF' 0x72' 0x25) : Color.FromArgb(0xFF' 0xF8' 0xA9' 0x00));                      tabStrokeBrush.Freeze();                        tabStroke = new Pen(tabStrokeBrush' 1.0);                      tabStroke.Freeze();                        CacheFreezable(tabStroke' (int)LunaFreezables.TabStroke);                  }                    LinearGradientBrush tabFill = (LinearGradientBrush)GetCachedFreezable((int)LunaFreezables.TabFill);                  if (tabFill == null)                  {                      tabFill = new LinearGradientBrush();                      tabFill.StartPoint = new Point();                      tabFill.EndPoint = new Point(1.0' 0.0);                      if (colorVariant == Luna.HomeStead)                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 1.0));                      }                      else                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFC' 0xE0' 0xA6)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.1));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.9));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDF' 0x97' 0x00)' 1.0));                      }                        tabFill.Freeze();                      CacheFreezable(tabFill' (int)LunaFreezables.TabFill);                  }                    dc.DrawGeometry(tabFill' tabStroke' tabGeometry);                                    dc.Pop(); // Translate Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (isHovered && !isPressed && (size.Width >= 6.0) && (size.Height >= 4.0))              {                  // When hovered' there is a colored tab at the bottom                  TranslateTransform positionTransform = new TranslateTransform(0.0' size.Height - 3.0);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    PathGeometry tabGeometry = new PathGeometry();                  PathFigure tabFigure = new PathFigure();                    tabFigure.StartPoint = new Point(0.5' 0.5);                    LineSegment line = new LineSegment(new Point(size.Width - 0.5' 0.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    ArcSegment arc = new ArcSegment(new Point(size.Width - 2.5' 2.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    line = new LineSegment(new Point(2.5' 2.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    arc = new ArcSegment(new Point(0.5' 0.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    tabFigure.IsClosed = true;                  tabFigure.Freeze();                    tabGeometry.Figures.Add(tabFigure);                  tabGeometry.Freeze();                    Pen tabStroke = (Pen)GetCachedFreezable((int)LunaFreezables.TabStroke);                  if (tabStroke == null)                  {                      SolidColorBrush tabStrokeBrush = new SolidColorBrush((colorVariant == Luna.HomeStead) ? Color.FromArgb(0xFF' 0xCF' 0x72' 0x25) : Color.FromArgb(0xFF' 0xF8' 0xA9' 0x00));                      tabStrokeBrush.Freeze();                        tabStroke = new Pen(tabStrokeBrush' 1.0);                      tabStroke.Freeze();                        CacheFreezable(tabStroke' (int)LunaFreezables.TabStroke);                  }                    LinearGradientBrush tabFill = (LinearGradientBrush)GetCachedFreezable((int)LunaFreezables.TabFill);                  if (tabFill == null)                  {                      tabFill = new LinearGradientBrush();                      tabFill.StartPoint = new Point();                      tabFill.EndPoint = new Point(1.0' 0.0);                      if (colorVariant == Luna.HomeStead)                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 1.0));                      }                      else                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFC' 0xE0' 0xA6)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.1));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.9));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDF' 0x97' 0x00)' 1.0));                      }                        tabFill.Freeze();                      CacheFreezable(tabFill' (int)LunaFreezables.TabFill);                  }                    dc.DrawGeometry(tabFill' tabStroke' tabGeometry);                                    dc.Pop(); // Translate Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (isHovered && !isPressed && (size.Width >= 6.0) && (size.Height >= 4.0))              {                  // When hovered' there is a colored tab at the bottom                  TranslateTransform positionTransform = new TranslateTransform(0.0' size.Height - 3.0);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    PathGeometry tabGeometry = new PathGeometry();                  PathFigure tabFigure = new PathFigure();                    tabFigure.StartPoint = new Point(0.5' 0.5);                    LineSegment line = new LineSegment(new Point(size.Width - 0.5' 0.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    ArcSegment arc = new ArcSegment(new Point(size.Width - 2.5' 2.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    line = new LineSegment(new Point(2.5' 2.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    arc = new ArcSegment(new Point(0.5' 0.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    tabFigure.IsClosed = true;                  tabFigure.Freeze();                    tabGeometry.Figures.Add(tabFigure);                  tabGeometry.Freeze();                    Pen tabStroke = (Pen)GetCachedFreezable((int)LunaFreezables.TabStroke);                  if (tabStroke == null)                  {                      SolidColorBrush tabStrokeBrush = new SolidColorBrush((colorVariant == Luna.HomeStead) ? Color.FromArgb(0xFF' 0xCF' 0x72' 0x25) : Color.FromArgb(0xFF' 0xF8' 0xA9' 0x00));                      tabStrokeBrush.Freeze();                        tabStroke = new Pen(tabStrokeBrush' 1.0);                      tabStroke.Freeze();                        CacheFreezable(tabStroke' (int)LunaFreezables.TabStroke);                  }                    LinearGradientBrush tabFill = (LinearGradientBrush)GetCachedFreezable((int)LunaFreezables.TabFill);                  if (tabFill == null)                  {                      tabFill = new LinearGradientBrush();                      tabFill.StartPoint = new Point();                      tabFill.EndPoint = new Point(1.0' 0.0);                      if (colorVariant == Luna.HomeStead)                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 1.0));                      }                      else                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFC' 0xE0' 0xA6)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.1));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.9));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDF' 0x97' 0x00)' 1.0));                      }                        tabFill.Freeze();                      CacheFreezable(tabFill' (int)LunaFreezables.TabFill);                  }                    dc.DrawGeometry(tabFill' tabStroke' tabGeometry);                                    dc.Pop(); // Translate Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (isHovered && !isPressed && (size.Width >= 6.0) && (size.Height >= 4.0))              {                  // When hovered' there is a colored tab at the bottom                  TranslateTransform positionTransform = new TranslateTransform(0.0' size.Height - 3.0);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    PathGeometry tabGeometry = new PathGeometry();                  PathFigure tabFigure = new PathFigure();                    tabFigure.StartPoint = new Point(0.5' 0.5);                    LineSegment line = new LineSegment(new Point(size.Width - 0.5' 0.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    ArcSegment arc = new ArcSegment(new Point(size.Width - 2.5' 2.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    line = new LineSegment(new Point(2.5' 2.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    arc = new ArcSegment(new Point(0.5' 0.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    tabFigure.IsClosed = true;                  tabFigure.Freeze();                    tabGeometry.Figures.Add(tabFigure);                  tabGeometry.Freeze();                    Pen tabStroke = (Pen)GetCachedFreezable((int)LunaFreezables.TabStroke);                  if (tabStroke == null)                  {                      SolidColorBrush tabStrokeBrush = new SolidColorBrush((colorVariant == Luna.HomeStead) ? Color.FromArgb(0xFF' 0xCF' 0x72' 0x25) : Color.FromArgb(0xFF' 0xF8' 0xA9' 0x00));                      tabStrokeBrush.Freeze();                        tabStroke = new Pen(tabStrokeBrush' 1.0);                      tabStroke.Freeze();                        CacheFreezable(tabStroke' (int)LunaFreezables.TabStroke);                  }                    LinearGradientBrush tabFill = (LinearGradientBrush)GetCachedFreezable((int)LunaFreezables.TabFill);                  if (tabFill == null)                  {                      tabFill = new LinearGradientBrush();                      tabFill.StartPoint = new Point();                      tabFill.EndPoint = new Point(1.0' 0.0);                      if (colorVariant == Luna.HomeStead)                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 1.0));                      }                      else                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFC' 0xE0' 0xA6)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.1));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.9));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDF' 0x97' 0x00)' 1.0));                      }                        tabFill.Freeze();                      CacheFreezable(tabFill' (int)LunaFreezables.TabFill);                  }                    dc.DrawGeometry(tabFill' tabStroke' tabGeometry);                                    dc.Pop(); // Translate Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (isHovered && !isPressed && (size.Width >= 6.0) && (size.Height >= 4.0))              {                  // When hovered' there is a colored tab at the bottom                  TranslateTransform positionTransform = new TranslateTransform(0.0' size.Height - 3.0);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    PathGeometry tabGeometry = new PathGeometry();                  PathFigure tabFigure = new PathFigure();                    tabFigure.StartPoint = new Point(0.5' 0.5);                    LineSegment line = new LineSegment(new Point(size.Width - 0.5' 0.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    ArcSegment arc = new ArcSegment(new Point(size.Width - 2.5' 2.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    line = new LineSegment(new Point(2.5' 2.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    arc = new ArcSegment(new Point(0.5' 0.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    tabFigure.IsClosed = true;                  tabFigure.Freeze();                    tabGeometry.Figures.Add(tabFigure);                  tabGeometry.Freeze();                    Pen tabStroke = (Pen)GetCachedFreezable((int)LunaFreezables.TabStroke);                  if (tabStroke == null)                  {                      SolidColorBrush tabStrokeBrush = new SolidColorBrush((colorVariant == Luna.HomeStead) ? Color.FromArgb(0xFF' 0xCF' 0x72' 0x25) : Color.FromArgb(0xFF' 0xF8' 0xA9' 0x00));                      tabStrokeBrush.Freeze();                        tabStroke = new Pen(tabStrokeBrush' 1.0);                      tabStroke.Freeze();                        CacheFreezable(tabStroke' (int)LunaFreezables.TabStroke);                  }                    LinearGradientBrush tabFill = (LinearGradientBrush)GetCachedFreezable((int)LunaFreezables.TabFill);                  if (tabFill == null)                  {                      tabFill = new LinearGradientBrush();                      tabFill.StartPoint = new Point();                      tabFill.EndPoint = new Point(1.0' 0.0);                      if (colorVariant == Luna.HomeStead)                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 1.0));                      }                      else                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFC' 0xE0' 0xA6)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.1));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.9));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDF' 0x97' 0x00)' 1.0));                      }                        tabFill.Freeze();                      CacheFreezable(tabFill' (int)LunaFreezables.TabFill);                  }                    dc.DrawGeometry(tabFill' tabStroke' tabGeometry);                                    dc.Pop(); // Translate Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (isHovered && !isPressed && (size.Width >= 6.0) && (size.Height >= 4.0))              {                  // When hovered' there is a colored tab at the bottom                  TranslateTransform positionTransform = new TranslateTransform(0.0' size.Height - 3.0);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    PathGeometry tabGeometry = new PathGeometry();                  PathFigure tabFigure = new PathFigure();                    tabFigure.StartPoint = new Point(0.5' 0.5);                    LineSegment line = new LineSegment(new Point(size.Width - 0.5' 0.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    ArcSegment arc = new ArcSegment(new Point(size.Width - 2.5' 2.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    line = new LineSegment(new Point(2.5' 2.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    arc = new ArcSegment(new Point(0.5' 0.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    tabFigure.IsClosed = true;                  tabFigure.Freeze();                    tabGeometry.Figures.Add(tabFigure);                  tabGeometry.Freeze();                    Pen tabStroke = (Pen)GetCachedFreezable((int)LunaFreezables.TabStroke);                  if (tabStroke == null)                  {                      SolidColorBrush tabStrokeBrush = new SolidColorBrush((colorVariant == Luna.HomeStead) ? Color.FromArgb(0xFF' 0xCF' 0x72' 0x25) : Color.FromArgb(0xFF' 0xF8' 0xA9' 0x00));                      tabStrokeBrush.Freeze();                        tabStroke = new Pen(tabStrokeBrush' 1.0);                      tabStroke.Freeze();                        CacheFreezable(tabStroke' (int)LunaFreezables.TabStroke);                  }                    LinearGradientBrush tabFill = (LinearGradientBrush)GetCachedFreezable((int)LunaFreezables.TabFill);                  if (tabFill == null)                  {                      tabFill = new LinearGradientBrush();                      tabFill.StartPoint = new Point();                      tabFill.EndPoint = new Point(1.0' 0.0);                      if (colorVariant == Luna.HomeStead)                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 1.0));                      }                      else                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFC' 0xE0' 0xA6)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.1));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.9));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDF' 0x97' 0x00)' 1.0));                      }                        tabFill.Freeze();                      CacheFreezable(tabFill' (int)LunaFreezables.TabFill);                  }                    dc.DrawGeometry(tabFill' tabStroke' tabGeometry);                                    dc.Pop(); // Translate Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (isHovered && !isPressed && (size.Width >= 6.0) && (size.Height >= 4.0))              {                  // When hovered' there is a colored tab at the bottom                  TranslateTransform positionTransform = new TranslateTransform(0.0' size.Height - 3.0);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    PathGeometry tabGeometry = new PathGeometry();                  PathFigure tabFigure = new PathFigure();                    tabFigure.StartPoint = new Point(0.5' 0.5);                    LineSegment line = new LineSegment(new Point(size.Width - 0.5' 0.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    ArcSegment arc = new ArcSegment(new Point(size.Width - 2.5' 2.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    line = new LineSegment(new Point(2.5' 2.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    arc = new ArcSegment(new Point(0.5' 0.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    tabFigure.IsClosed = true;                  tabFigure.Freeze();                    tabGeometry.Figures.Add(tabFigure);                  tabGeometry.Freeze();                    Pen tabStroke = (Pen)GetCachedFreezable((int)LunaFreezables.TabStroke);                  if (tabStroke == null)                  {                      SolidColorBrush tabStrokeBrush = new SolidColorBrush((colorVariant == Luna.HomeStead) ? Color.FromArgb(0xFF' 0xCF' 0x72' 0x25) : Color.FromArgb(0xFF' 0xF8' 0xA9' 0x00));                      tabStrokeBrush.Freeze();                        tabStroke = new Pen(tabStrokeBrush' 1.0);                      tabStroke.Freeze();                        CacheFreezable(tabStroke' (int)LunaFreezables.TabStroke);                  }                    LinearGradientBrush tabFill = (LinearGradientBrush)GetCachedFreezable((int)LunaFreezables.TabFill);                  if (tabFill == null)                  {                      tabFill = new LinearGradientBrush();                      tabFill.StartPoint = new Point();                      tabFill.EndPoint = new Point(1.0' 0.0);                      if (colorVariant == Luna.HomeStead)                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 1.0));                      }                      else                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFC' 0xE0' 0xA6)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.1));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.9));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDF' 0x97' 0x00)' 1.0));                      }                        tabFill.Freeze();                      CacheFreezable(tabFill' (int)LunaFreezables.TabFill);                  }                    dc.DrawGeometry(tabFill' tabStroke' tabGeometry);                                    dc.Pop(); // Translate Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (isHovered && !isPressed && (size.Width >= 6.0) && (size.Height >= 4.0))              {                  // When hovered' there is a colored tab at the bottom                  TranslateTransform positionTransform = new TranslateTransform(0.0' size.Height - 3.0);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    PathGeometry tabGeometry = new PathGeometry();                  PathFigure tabFigure = new PathFigure();                    tabFigure.StartPoint = new Point(0.5' 0.5);                    LineSegment line = new LineSegment(new Point(size.Width - 0.5' 0.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    ArcSegment arc = new ArcSegment(new Point(size.Width - 2.5' 2.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    line = new LineSegment(new Point(2.5' 2.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    arc = new ArcSegment(new Point(0.5' 0.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    tabFigure.IsClosed = true;                  tabFigure.Freeze();                    tabGeometry.Figures.Add(tabFigure);                  tabGeometry.Freeze();                    Pen tabStroke = (Pen)GetCachedFreezable((int)LunaFreezables.TabStroke);                  if (tabStroke == null)                  {                      SolidColorBrush tabStrokeBrush = new SolidColorBrush((colorVariant == Luna.HomeStead) ? Color.FromArgb(0xFF' 0xCF' 0x72' 0x25) : Color.FromArgb(0xFF' 0xF8' 0xA9' 0x00));                      tabStrokeBrush.Freeze();                        tabStroke = new Pen(tabStrokeBrush' 1.0);                      tabStroke.Freeze();                        CacheFreezable(tabStroke' (int)LunaFreezables.TabStroke);                  }                    LinearGradientBrush tabFill = (LinearGradientBrush)GetCachedFreezable((int)LunaFreezables.TabFill);                  if (tabFill == null)                  {                      tabFill = new LinearGradientBrush();                      tabFill.StartPoint = new Point();                      tabFill.EndPoint = new Point(1.0' 0.0);                      if (colorVariant == Luna.HomeStead)                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 1.0));                      }                      else                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFC' 0xE0' 0xA6)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.1));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.9));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDF' 0x97' 0x00)' 1.0));                      }                        tabFill.Freeze();                      CacheFreezable(tabFill' (int)LunaFreezables.TabFill);                  }                    dc.DrawGeometry(tabFill' tabStroke' tabGeometry);                                    dc.Pop(); // Translate Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (isHovered && !isPressed && (size.Width >= 6.0) && (size.Height >= 4.0))              {                  // When hovered' there is a colored tab at the bottom                  TranslateTransform positionTransform = new TranslateTransform(0.0' size.Height - 3.0);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    PathGeometry tabGeometry = new PathGeometry();                  PathFigure tabFigure = new PathFigure();                    tabFigure.StartPoint = new Point(0.5' 0.5);                    LineSegment line = new LineSegment(new Point(size.Width - 0.5' 0.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    ArcSegment arc = new ArcSegment(new Point(size.Width - 2.5' 2.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    line = new LineSegment(new Point(2.5' 2.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    arc = new ArcSegment(new Point(0.5' 0.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    tabFigure.IsClosed = true;                  tabFigure.Freeze();                    tabGeometry.Figures.Add(tabFigure);                  tabGeometry.Freeze();                    Pen tabStroke = (Pen)GetCachedFreezable((int)LunaFreezables.TabStroke);                  if (tabStroke == null)                  {                      SolidColorBrush tabStrokeBrush = new SolidColorBrush((colorVariant == Luna.HomeStead) ? Color.FromArgb(0xFF' 0xCF' 0x72' 0x25) : Color.FromArgb(0xFF' 0xF8' 0xA9' 0x00));                      tabStrokeBrush.Freeze();                        tabStroke = new Pen(tabStrokeBrush' 1.0);                      tabStroke.Freeze();                        CacheFreezable(tabStroke' (int)LunaFreezables.TabStroke);                  }                    LinearGradientBrush tabFill = (LinearGradientBrush)GetCachedFreezable((int)LunaFreezables.TabFill);                  if (tabFill == null)                  {                      tabFill = new LinearGradientBrush();                      tabFill.StartPoint = new Point();                      tabFill.EndPoint = new Point(1.0' 0.0);                      if (colorVariant == Luna.HomeStead)                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 1.0));                      }                      else                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFC' 0xE0' 0xA6)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.1));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.9));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDF' 0x97' 0x00)' 1.0));                      }                        tabFill.Freeze();                      CacheFreezable(tabFill' (int)LunaFreezables.TabFill);                  }                    dc.DrawGeometry(tabFill' tabStroke' tabGeometry);                                    dc.Pop(); // Translate Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (isHovered && !isPressed && (size.Width >= 6.0) && (size.Height >= 4.0))              {                  // When hovered' there is a colored tab at the bottom                  TranslateTransform positionTransform = new TranslateTransform(0.0' size.Height - 3.0);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    PathGeometry tabGeometry = new PathGeometry();                  PathFigure tabFigure = new PathFigure();                    tabFigure.StartPoint = new Point(0.5' 0.5);                    LineSegment line = new LineSegment(new Point(size.Width - 0.5' 0.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    ArcSegment arc = new ArcSegment(new Point(size.Width - 2.5' 2.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    line = new LineSegment(new Point(2.5' 2.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    arc = new ArcSegment(new Point(0.5' 0.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    tabFigure.IsClosed = true;                  tabFigure.Freeze();                    tabGeometry.Figures.Add(tabFigure);                  tabGeometry.Freeze();                    Pen tabStroke = (Pen)GetCachedFreezable((int)LunaFreezables.TabStroke);                  if (tabStroke == null)                  {                      SolidColorBrush tabStrokeBrush = new SolidColorBrush((colorVariant == Luna.HomeStead) ? Color.FromArgb(0xFF' 0xCF' 0x72' 0x25) : Color.FromArgb(0xFF' 0xF8' 0xA9' 0x00));                      tabStrokeBrush.Freeze();                        tabStroke = new Pen(tabStrokeBrush' 1.0);                      tabStroke.Freeze();                        CacheFreezable(tabStroke' (int)LunaFreezables.TabStroke);                  }                    LinearGradientBrush tabFill = (LinearGradientBrush)GetCachedFreezable((int)LunaFreezables.TabFill);                  if (tabFill == null)                  {                      tabFill = new LinearGradientBrush();                      tabFill.StartPoint = new Point();                      tabFill.EndPoint = new Point(1.0' 0.0);                      if (colorVariant == Luna.HomeStead)                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 1.0));                      }                      else                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFC' 0xE0' 0xA6)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.1));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.9));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDF' 0x97' 0x00)' 1.0));                      }                        tabFill.Freeze();                      CacheFreezable(tabFill' (int)LunaFreezables.TabFill);                  }                    dc.DrawGeometry(tabFill' tabStroke' tabGeometry);                                    dc.Pop(); // Translate Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (isHovered && !isPressed && (size.Width >= 6.0) && (size.Height >= 4.0))              {                  // When hovered' there is a colored tab at the bottom                  TranslateTransform positionTransform = new TranslateTransform(0.0' size.Height - 3.0);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    PathGeometry tabGeometry = new PathGeometry();                  PathFigure tabFigure = new PathFigure();                    tabFigure.StartPoint = new Point(0.5' 0.5);                    LineSegment line = new LineSegment(new Point(size.Width - 0.5' 0.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    ArcSegment arc = new ArcSegment(new Point(size.Width - 2.5' 2.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    line = new LineSegment(new Point(2.5' 2.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    arc = new ArcSegment(new Point(0.5' 0.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    tabFigure.IsClosed = true;                  tabFigure.Freeze();                    tabGeometry.Figures.Add(tabFigure);                  tabGeometry.Freeze();                    Pen tabStroke = (Pen)GetCachedFreezable((int)LunaFreezables.TabStroke);                  if (tabStroke == null)                  {                      SolidColorBrush tabStrokeBrush = new SolidColorBrush((colorVariant == Luna.HomeStead) ? Color.FromArgb(0xFF' 0xCF' 0x72' 0x25) : Color.FromArgb(0xFF' 0xF8' 0xA9' 0x00));                      tabStrokeBrush.Freeze();                        tabStroke = new Pen(tabStrokeBrush' 1.0);                      tabStroke.Freeze();                        CacheFreezable(tabStroke' (int)LunaFreezables.TabStroke);                  }                    LinearGradientBrush tabFill = (LinearGradientBrush)GetCachedFreezable((int)LunaFreezables.TabFill);                  if (tabFill == null)                  {                      tabFill = new LinearGradientBrush();                      tabFill.StartPoint = new Point();                      tabFill.EndPoint = new Point(1.0' 0.0);                      if (colorVariant == Luna.HomeStead)                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 1.0));                      }                      else                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFC' 0xE0' 0xA6)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.1));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.9));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDF' 0x97' 0x00)' 1.0));                      }                        tabFill.Freeze();                      CacheFreezable(tabFill' (int)LunaFreezables.TabFill);                  }                    dc.DrawGeometry(tabFill' tabStroke' tabGeometry);                                    dc.Pop(); // Translate Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (isHovered && !isPressed && (size.Width >= 6.0) && (size.Height >= 4.0))              {                  // When hovered' there is a colored tab at the bottom                  TranslateTransform positionTransform = new TranslateTransform(0.0' size.Height - 3.0);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    PathGeometry tabGeometry = new PathGeometry();                  PathFigure tabFigure = new PathFigure();                    tabFigure.StartPoint = new Point(0.5' 0.5);                    LineSegment line = new LineSegment(new Point(size.Width - 0.5' 0.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    ArcSegment arc = new ArcSegment(new Point(size.Width - 2.5' 2.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    line = new LineSegment(new Point(2.5' 2.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    arc = new ArcSegment(new Point(0.5' 0.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    tabFigure.IsClosed = true;                  tabFigure.Freeze();                    tabGeometry.Figures.Add(tabFigure);                  tabGeometry.Freeze();                    Pen tabStroke = (Pen)GetCachedFreezable((int)LunaFreezables.TabStroke);                  if (tabStroke == null)                  {                      SolidColorBrush tabStrokeBrush = new SolidColorBrush((colorVariant == Luna.HomeStead) ? Color.FromArgb(0xFF' 0xCF' 0x72' 0x25) : Color.FromArgb(0xFF' 0xF8' 0xA9' 0x00));                      tabStrokeBrush.Freeze();                        tabStroke = new Pen(tabStrokeBrush' 1.0);                      tabStroke.Freeze();                        CacheFreezable(tabStroke' (int)LunaFreezables.TabStroke);                  }                    LinearGradientBrush tabFill = (LinearGradientBrush)GetCachedFreezable((int)LunaFreezables.TabFill);                  if (tabFill == null)                  {                      tabFill = new LinearGradientBrush();                      tabFill.StartPoint = new Point();                      tabFill.EndPoint = new Point(1.0' 0.0);                      if (colorVariant == Luna.HomeStead)                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 1.0));                      }                      else                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFC' 0xE0' 0xA6)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.1));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.9));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDF' 0x97' 0x00)' 1.0));                      }                        tabFill.Freeze();                      CacheFreezable(tabFill' (int)LunaFreezables.TabFill);                  }                    dc.DrawGeometry(tabFill' tabStroke' tabGeometry);                                    dc.Pop(); // Translate Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (isHovered && !isPressed && (size.Width >= 6.0) && (size.Height >= 4.0))              {                  // When hovered' there is a colored tab at the bottom                  TranslateTransform positionTransform = new TranslateTransform(0.0' size.Height - 3.0);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    PathGeometry tabGeometry = new PathGeometry();                  PathFigure tabFigure = new PathFigure();                    tabFigure.StartPoint = new Point(0.5' 0.5);                    LineSegment line = new LineSegment(new Point(size.Width - 0.5' 0.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    ArcSegment arc = new ArcSegment(new Point(size.Width - 2.5' 2.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    line = new LineSegment(new Point(2.5' 2.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    arc = new ArcSegment(new Point(0.5' 0.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    tabFigure.IsClosed = true;                  tabFigure.Freeze();                    tabGeometry.Figures.Add(tabFigure);                  tabGeometry.Freeze();                    Pen tabStroke = (Pen)GetCachedFreezable((int)LunaFreezables.TabStroke);                  if (tabStroke == null)                  {                      SolidColorBrush tabStrokeBrush = new SolidColorBrush((colorVariant == Luna.HomeStead) ? Color.FromArgb(0xFF' 0xCF' 0x72' 0x25) : Color.FromArgb(0xFF' 0xF8' 0xA9' 0x00));                      tabStrokeBrush.Freeze();                        tabStroke = new Pen(tabStrokeBrush' 1.0);                      tabStroke.Freeze();                        CacheFreezable(tabStroke' (int)LunaFreezables.TabStroke);                  }                    LinearGradientBrush tabFill = (LinearGradientBrush)GetCachedFreezable((int)LunaFreezables.TabFill);                  if (tabFill == null)                  {                      tabFill = new LinearGradientBrush();                      tabFill.StartPoint = new Point();                      tabFill.EndPoint = new Point(1.0' 0.0);                      if (colorVariant == Luna.HomeStead)                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 1.0));                      }                      else                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFC' 0xE0' 0xA6)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.1));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.9));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDF' 0x97' 0x00)' 1.0));                      }                        tabFill.Freeze();                      CacheFreezable(tabFill' (int)LunaFreezables.TabFill);                  }                    dc.DrawGeometry(tabFill' tabStroke' tabGeometry);                                    dc.Pop(); // Translate Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (isHovered && !isPressed && (size.Width >= 6.0) && (size.Height >= 4.0))              {                  // When hovered' there is a colored tab at the bottom                  TranslateTransform positionTransform = new TranslateTransform(0.0' size.Height - 3.0);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    PathGeometry tabGeometry = new PathGeometry();                  PathFigure tabFigure = new PathFigure();                    tabFigure.StartPoint = new Point(0.5' 0.5);                    LineSegment line = new LineSegment(new Point(size.Width - 0.5' 0.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    ArcSegment arc = new ArcSegment(new Point(size.Width - 2.5' 2.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    line = new LineSegment(new Point(2.5' 2.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    arc = new ArcSegment(new Point(0.5' 0.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    tabFigure.IsClosed = true;                  tabFigure.Freeze();                    tabGeometry.Figures.Add(tabFigure);                  tabGeometry.Freeze();                    Pen tabStroke = (Pen)GetCachedFreezable((int)LunaFreezables.TabStroke);                  if (tabStroke == null)                  {                      SolidColorBrush tabStrokeBrush = new SolidColorBrush((colorVariant == Luna.HomeStead) ? Color.FromArgb(0xFF' 0xCF' 0x72' 0x25) : Color.FromArgb(0xFF' 0xF8' 0xA9' 0x00));                      tabStrokeBrush.Freeze();                        tabStroke = new Pen(tabStrokeBrush' 1.0);                      tabStroke.Freeze();                        CacheFreezable(tabStroke' (int)LunaFreezables.TabStroke);                  }                    LinearGradientBrush tabFill = (LinearGradientBrush)GetCachedFreezable((int)LunaFreezables.TabFill);                  if (tabFill == null)                  {                      tabFill = new LinearGradientBrush();                      tabFill.StartPoint = new Point();                      tabFill.EndPoint = new Point(1.0' 0.0);                      if (colorVariant == Luna.HomeStead)                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 1.0));                      }                      else                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFC' 0xE0' 0xA6)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.1));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.9));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDF' 0x97' 0x00)' 1.0));                      }                        tabFill.Freeze();                      CacheFreezable(tabFill' (int)LunaFreezables.TabFill);                  }                    dc.DrawGeometry(tabFill' tabStroke' tabGeometry);                                    dc.Pop(); // Translate Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (isHovered && !isPressed && (size.Width >= 6.0) && (size.Height >= 4.0))              {                  // When hovered' there is a colored tab at the bottom                  TranslateTransform positionTransform = new TranslateTransform(0.0' size.Height - 3.0);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    PathGeometry tabGeometry = new PathGeometry();                  PathFigure tabFigure = new PathFigure();                    tabFigure.StartPoint = new Point(0.5' 0.5);                    LineSegment line = new LineSegment(new Point(size.Width - 0.5' 0.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    ArcSegment arc = new ArcSegment(new Point(size.Width - 2.5' 2.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    line = new LineSegment(new Point(2.5' 2.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    arc = new ArcSegment(new Point(0.5' 0.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    tabFigure.IsClosed = true;                  tabFigure.Freeze();                    tabGeometry.Figures.Add(tabFigure);                  tabGeometry.Freeze();                    Pen tabStroke = (Pen)GetCachedFreezable((int)LunaFreezables.TabStroke);                  if (tabStroke == null)                  {                      SolidColorBrush tabStrokeBrush = new SolidColorBrush((colorVariant == Luna.HomeStead) ? Color.FromArgb(0xFF' 0xCF' 0x72' 0x25) : Color.FromArgb(0xFF' 0xF8' 0xA9' 0x00));                      tabStrokeBrush.Freeze();                        tabStroke = new Pen(tabStrokeBrush' 1.0);                      tabStroke.Freeze();                        CacheFreezable(tabStroke' (int)LunaFreezables.TabStroke);                  }                    LinearGradientBrush tabFill = (LinearGradientBrush)GetCachedFreezable((int)LunaFreezables.TabFill);                  if (tabFill == null)                  {                      tabFill = new LinearGradientBrush();                      tabFill.StartPoint = new Point();                      tabFill.EndPoint = new Point(1.0' 0.0);                      if (colorVariant == Luna.HomeStead)                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 1.0));                      }                      else                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFC' 0xE0' 0xA6)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.1));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.9));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDF' 0x97' 0x00)' 1.0));                      }                        tabFill.Freeze();                      CacheFreezable(tabFill' (int)LunaFreezables.TabFill);                  }                    dc.DrawGeometry(tabFill' tabStroke' tabGeometry);                                    dc.Pop(); // Translate Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (isHovered && !isPressed && (size.Width >= 6.0) && (size.Height >= 4.0))              {                  // When hovered' there is a colored tab at the bottom                  TranslateTransform positionTransform = new TranslateTransform(0.0' size.Height - 3.0);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    PathGeometry tabGeometry = new PathGeometry();                  PathFigure tabFigure = new PathFigure();                    tabFigure.StartPoint = new Point(0.5' 0.5);                    LineSegment line = new LineSegment(new Point(size.Width - 0.5' 0.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    ArcSegment arc = new ArcSegment(new Point(size.Width - 2.5' 2.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    line = new LineSegment(new Point(2.5' 2.5)' true);                  line.Freeze();                  tabFigure.Segments.Add(line);                    arc = new ArcSegment(new Point(0.5' 0.5)' new Size(2.0' 2.0)' 90.0' false' SweepDirection.Clockwise' true);                  arc.Freeze();                  tabFigure.Segments.Add(arc);                    tabFigure.IsClosed = true;                  tabFigure.Freeze();                    tabGeometry.Figures.Add(tabFigure);                  tabGeometry.Freeze();                    Pen tabStroke = (Pen)GetCachedFreezable((int)LunaFreezables.TabStroke);                  if (tabStroke == null)                  {                      SolidColorBrush tabStrokeBrush = new SolidColorBrush((colorVariant == Luna.HomeStead) ? Color.FromArgb(0xFF' 0xCF' 0x72' 0x25) : Color.FromArgb(0xFF' 0xF8' 0xA9' 0x00));                      tabStrokeBrush.Freeze();                        tabStroke = new Pen(tabStrokeBrush' 1.0);                      tabStroke.Freeze();                        CacheFreezable(tabStroke' (int)LunaFreezables.TabStroke);                  }                    LinearGradientBrush tabFill = (LinearGradientBrush)GetCachedFreezable((int)LunaFreezables.TabFill);                  if (tabFill == null)                  {                      tabFill = new LinearGradientBrush();                      tabFill.StartPoint = new Point();                      tabFill.EndPoint = new Point(1.0' 0.0);                      if (colorVariant == Luna.HomeStead)                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0x91' 0x4F)' 1.0));                      }                      else                      {                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFC' 0xE0' 0xA6)' 0.0));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.1));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF6' 0xC4' 0x56)' 0.9));                          tabFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDF' 0x97' 0x00)' 1.0));                      }                        tabFill.Freeze();                      CacheFreezable(tabFill' (int)LunaFreezables.TabFill);                  }                    dc.DrawGeometry(tabFill' tabStroke' tabGeometry);                                    dc.Pop(); // Translate Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (isPressed && (size.Width >= 2.0) && (size.Height >= 2.0))              {                  // When pressed' there is a border on the left and bottom                  SolidColorBrush border = (SolidColorBrush)GetCachedFreezable((int)LunaFreezables.PressedBorder);                  if (border == null)                  {                      border = new SolidColorBrush((colorVariant == Luna.Metallic) ? Color.FromArgb(0xFF' 0x80' 0x80' 0x99) : Color.FromArgb(0xFF' 0xA5' 0xA5' 0x97));                      border.Freeze();                      CacheFreezable(border' (int)LunaFreezables.PressedBorder);                  }                    dc.DrawRectangle(border' null' new Rect(0.0' 0.0' 1.0' size.Height));                  dc.DrawRectangle(border' null' new Rect(0.0' Max0(size.Height - 1.0)' size.Width' 1.0));              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (isPressed && (size.Width >= 2.0) && (size.Height >= 2.0))              {                  // When pressed' there is a border on the left and bottom                  SolidColorBrush border = (SolidColorBrush)GetCachedFreezable((int)LunaFreezables.PressedBorder);                  if (border == null)                  {                      border = new SolidColorBrush((colorVariant == Luna.Metallic) ? Color.FromArgb(0xFF' 0x80' 0x80' 0x99) : Color.FromArgb(0xFF' 0xA5' 0xA5' 0x97));                      border.Freeze();                      CacheFreezable(border' (int)LunaFreezables.PressedBorder);                  }                    dc.DrawRectangle(border' null' new Rect(0.0' 0.0' 1.0' size.Height));                  dc.DrawRectangle(border' null' new Rect(0.0' Max0(size.Height - 1.0)' size.Width' 1.0));              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (!isPressed && !isHovered && (size.Width >= 4.0))              {                  if (SeparatorVisibility == Visibility.Visible)                  {                      Brush sideBrush;                      if (SeparatorBrush != null)                      {                          sideBrush = SeparatorBrush;                      }                      else                      {                          // When not pressed or hovered' draw the resize gripper                          LinearGradientBrush gripper = (LinearGradientBrush)GetCachedFreezable((int)(horizontal ? LunaFreezables.HorizontalGripper : LunaFreezables.VerticalGripper));                          if (gripper == null)                          {                              gripper = new LinearGradientBrush();                              gripper.StartPoint = new Point();                              gripper.EndPoint = new Point(1.0' 0.0);                                Color highlight = Color.FromArgb(0xFF' 0xFF' 0xFF' 0xFF);                              Color shadow = Color.FromArgb(0xFF' 0xC7' 0xC5' 0xB2);                                if (horizontal)                              {                                  gripper.GradientStops.Add(new GradientStop(highlight' 0.0));                                  gripper.GradientStops.Add(new GradientStop(highlight' 0.25));                                  gripper.GradientStops.Add(new GradientStop(shadow' 0.75));                                  gripper.GradientStops.Add(new GradientStop(shadow' 1.0));                              }                              else                              {                                  gripper.GradientStops.Add(new GradientStop(shadow' 0.0));                                  gripper.GradientStops.Add(new GradientStop(shadow' 0.25));                                  gripper.GradientStops.Add(new GradientStop(highlight' 0.75));                                  gripper.GradientStops.Add(new GradientStop(highlight' 1.0));                              }                                gripper.Freeze();                              CacheFreezable(gripper' (int)(horizontal ? LunaFreezables.HorizontalGripper : LunaFreezables.VerticalGripper));                          }                            sideBrush = gripper;                      }                        dc.DrawRectangle(sideBrush' null' new Rect(horizontal ? 0.0 : Max0(size.Width - 2.0)' 4.0' 2.0' Max0(size.Height - 8.0)));                  }              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (!isPressed && !isHovered && (size.Width >= 4.0))              {                  if (SeparatorVisibility == Visibility.Visible)                  {                      Brush sideBrush;                      if (SeparatorBrush != null)                      {                          sideBrush = SeparatorBrush;                      }                      else                      {                          // When not pressed or hovered' draw the resize gripper                          LinearGradientBrush gripper = (LinearGradientBrush)GetCachedFreezable((int)(horizontal ? LunaFreezables.HorizontalGripper : LunaFreezables.VerticalGripper));                          if (gripper == null)                          {                              gripper = new LinearGradientBrush();                              gripper.StartPoint = new Point();                              gripper.EndPoint = new Point(1.0' 0.0);                                Color highlight = Color.FromArgb(0xFF' 0xFF' 0xFF' 0xFF);                              Color shadow = Color.FromArgb(0xFF' 0xC7' 0xC5' 0xB2);                                if (horizontal)                              {                                  gripper.GradientStops.Add(new GradientStop(highlight' 0.0));                                  gripper.GradientStops.Add(new GradientStop(highlight' 0.25));                                  gripper.GradientStops.Add(new GradientStop(shadow' 0.75));                                  gripper.GradientStops.Add(new GradientStop(shadow' 1.0));                              }                              else                              {                                  gripper.GradientStops.Add(new GradientStop(shadow' 0.0));                                  gripper.GradientStops.Add(new GradientStop(shadow' 0.25));                                  gripper.GradientStops.Add(new GradientStop(highlight' 0.75));                                  gripper.GradientStops.Add(new GradientStop(highlight' 1.0));                              }                                gripper.Freeze();                              CacheFreezable(gripper' (int)(horizontal ? LunaFreezables.HorizontalGripper : LunaFreezables.VerticalGripper));                          }                            sideBrush = gripper;                      }                        dc.DrawRectangle(sideBrush' null' new Rect(horizontal ? 0.0 : Max0(size.Width - 2.0)' 4.0' 2.0' Max0(size.Height - 8.0)));                  }              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (!isPressed && !isHovered && (size.Width >= 4.0))              {                  if (SeparatorVisibility == Visibility.Visible)                  {                      Brush sideBrush;                      if (SeparatorBrush != null)                      {                          sideBrush = SeparatorBrush;                      }                      else                      {                          // When not pressed or hovered' draw the resize gripper                          LinearGradientBrush gripper = (LinearGradientBrush)GetCachedFreezable((int)(horizontal ? LunaFreezables.HorizontalGripper : LunaFreezables.VerticalGripper));                          if (gripper == null)                          {                              gripper = new LinearGradientBrush();                              gripper.StartPoint = new Point();                              gripper.EndPoint = new Point(1.0' 0.0);                                Color highlight = Color.FromArgb(0xFF' 0xFF' 0xFF' 0xFF);                              Color shadow = Color.FromArgb(0xFF' 0xC7' 0xC5' 0xB2);                                if (horizontal)                              {                                  gripper.GradientStops.Add(new GradientStop(highlight' 0.0));                                  gripper.GradientStops.Add(new GradientStop(highlight' 0.25));                                  gripper.GradientStops.Add(new GradientStop(shadow' 0.75));                                  gripper.GradientStops.Add(new GradientStop(shadow' 1.0));                              }                              else                              {                                  gripper.GradientStops.Add(new GradientStop(shadow' 0.0));                                  gripper.GradientStops.Add(new GradientStop(shadow' 0.25));                                  gripper.GradientStops.Add(new GradientStop(highlight' 0.75));                                  gripper.GradientStops.Add(new GradientStop(highlight' 1.0));                              }                                gripper.Freeze();                              CacheFreezable(gripper' (int)(horizontal ? LunaFreezables.HorizontalGripper : LunaFreezables.VerticalGripper));                          }                            sideBrush = gripper;                      }                        dc.DrawRectangle(sideBrush' null' new Rect(horizontal ? 0.0 : Max0(size.Width - 2.0)' 4.0' 2.0' Max0(size.Height - 8.0)));                  }              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (!isPressed && !isHovered && (size.Width >= 4.0))              {                  if (SeparatorVisibility == Visibility.Visible)                  {                      Brush sideBrush;                      if (SeparatorBrush != null)                      {                          sideBrush = SeparatorBrush;                      }                      else                      {                          // When not pressed or hovered' draw the resize gripper                          LinearGradientBrush gripper = (LinearGradientBrush)GetCachedFreezable((int)(horizontal ? LunaFreezables.HorizontalGripper : LunaFreezables.VerticalGripper));                          if (gripper == null)                          {                              gripper = new LinearGradientBrush();                              gripper.StartPoint = new Point();                              gripper.EndPoint = new Point(1.0' 0.0);                                Color highlight = Color.FromArgb(0xFF' 0xFF' 0xFF' 0xFF);                              Color shadow = Color.FromArgb(0xFF' 0xC7' 0xC5' 0xB2);                                if (horizontal)                              {                                  gripper.GradientStops.Add(new GradientStop(highlight' 0.0));                                  gripper.GradientStops.Add(new GradientStop(highlight' 0.25));                                  gripper.GradientStops.Add(new GradientStop(shadow' 0.75));                                  gripper.GradientStops.Add(new GradientStop(shadow' 1.0));                              }                              else                              {                                  gripper.GradientStops.Add(new GradientStop(shadow' 0.0));                                  gripper.GradientStops.Add(new GradientStop(shadow' 0.25));                                  gripper.GradientStops.Add(new GradientStop(highlight' 0.75));                                  gripper.GradientStops.Add(new GradientStop(highlight' 1.0));                              }                                gripper.Freeze();                              CacheFreezable(gripper' (int)(horizontal ? LunaFreezables.HorizontalGripper : LunaFreezables.VerticalGripper));                          }                            sideBrush = gripper;                      }                        dc.DrawRectangle(sideBrush' null' new Rect(horizontal ? 0.0 : Max0(size.Width - 2.0)' 4.0' 2.0' Max0(size.Height - 8.0)));                  }              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (!isPressed && !isHovered && (size.Width >= 4.0))              {                  if (SeparatorVisibility == Visibility.Visible)                  {                      Brush sideBrush;                      if (SeparatorBrush != null)                      {                          sideBrush = SeparatorBrush;                      }                      else                      {                          // When not pressed or hovered' draw the resize gripper                          LinearGradientBrush gripper = (LinearGradientBrush)GetCachedFreezable((int)(horizontal ? LunaFreezables.HorizontalGripper : LunaFreezables.VerticalGripper));                          if (gripper == null)                          {                              gripper = new LinearGradientBrush();                              gripper.StartPoint = new Point();                              gripper.EndPoint = new Point(1.0' 0.0);                                Color highlight = Color.FromArgb(0xFF' 0xFF' 0xFF' 0xFF);                              Color shadow = Color.FromArgb(0xFF' 0xC7' 0xC5' 0xB2);                                if (horizontal)                              {                                  gripper.GradientStops.Add(new GradientStop(highlight' 0.0));                                  gripper.GradientStops.Add(new GradientStop(highlight' 0.25));                                  gripper.GradientStops.Add(new GradientStop(shadow' 0.75));                                  gripper.GradientStops.Add(new GradientStop(shadow' 1.0));                              }                              else                              {                                  gripper.GradientStops.Add(new GradientStop(shadow' 0.0));                                  gripper.GradientStops.Add(new GradientStop(shadow' 0.25));                                  gripper.GradientStops.Add(new GradientStop(highlight' 0.75));                                  gripper.GradientStops.Add(new GradientStop(highlight' 1.0));                              }                                gripper.Freeze();                              CacheFreezable(gripper' (int)(horizontal ? LunaFreezables.HorizontalGripper : LunaFreezables.VerticalGripper));                          }                            sideBrush = gripper;                      }                        dc.DrawRectangle(sideBrush' null' new Rect(horizontal ? 0.0 : Max0(size.Width - 2.0)' 4.0' 2.0' Max0(size.Height - 8.0)));                  }              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (!isPressed && !isHovered && (size.Width >= 4.0))              {                  if (SeparatorVisibility == Visibility.Visible)                  {                      Brush sideBrush;                      if (SeparatorBrush != null)                      {                          sideBrush = SeparatorBrush;                      }                      else                      {                          // When not pressed or hovered' draw the resize gripper                          LinearGradientBrush gripper = (LinearGradientBrush)GetCachedFreezable((int)(horizontal ? LunaFreezables.HorizontalGripper : LunaFreezables.VerticalGripper));                          if (gripper == null)                          {                              gripper = new LinearGradientBrush();                              gripper.StartPoint = new Point();                              gripper.EndPoint = new Point(1.0' 0.0);                                Color highlight = Color.FromArgb(0xFF' 0xFF' 0xFF' 0xFF);                              Color shadow = Color.FromArgb(0xFF' 0xC7' 0xC5' 0xB2);                                if (horizontal)                              {                                  gripper.GradientStops.Add(new GradientStop(highlight' 0.0));                                  gripper.GradientStops.Add(new GradientStop(highlight' 0.25));                                  gripper.GradientStops.Add(new GradientStop(shadow' 0.75));                                  gripper.GradientStops.Add(new GradientStop(shadow' 1.0));                              }                              else                              {                                  gripper.GradientStops.Add(new GradientStop(shadow' 0.0));                                  gripper.GradientStops.Add(new GradientStop(shadow' 0.25));                                  gripper.GradientStops.Add(new GradientStop(highlight' 0.75));                                  gripper.GradientStops.Add(new GradientStop(highlight' 1.0));                              }                                gripper.Freeze();                              CacheFreezable(gripper' (int)(horizontal ? LunaFreezables.HorizontalGripper : LunaFreezables.VerticalGripper));                          }                            sideBrush = gripper;                      }                        dc.DrawRectangle(sideBrush' null' new Rect(horizontal ? 0.0 : Max0(size.Width - 2.0)' 4.0' 2.0' Max0(size.Height - 8.0)));                  }              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (!isPressed && !isHovered && (size.Width >= 4.0))              {                  if (SeparatorVisibility == Visibility.Visible)                  {                      Brush sideBrush;                      if (SeparatorBrush != null)                      {                          sideBrush = SeparatorBrush;                      }                      else                      {                          // When not pressed or hovered' draw the resize gripper                          LinearGradientBrush gripper = (LinearGradientBrush)GetCachedFreezable((int)(horizontal ? LunaFreezables.HorizontalGripper : LunaFreezables.VerticalGripper));                          if (gripper == null)                          {                              gripper = new LinearGradientBrush();                              gripper.StartPoint = new Point();                              gripper.EndPoint = new Point(1.0' 0.0);                                Color highlight = Color.FromArgb(0xFF' 0xFF' 0xFF' 0xFF);                              Color shadow = Color.FromArgb(0xFF' 0xC7' 0xC5' 0xB2);                                if (horizontal)                              {                                  gripper.GradientStops.Add(new GradientStop(highlight' 0.0));                                  gripper.GradientStops.Add(new GradientStop(highlight' 0.25));                                  gripper.GradientStops.Add(new GradientStop(shadow' 0.75));                                  gripper.GradientStops.Add(new GradientStop(shadow' 1.0));                              }                              else                              {                                  gripper.GradientStops.Add(new GradientStop(shadow' 0.0));                                  gripper.GradientStops.Add(new GradientStop(shadow' 0.25));                                  gripper.GradientStops.Add(new GradientStop(highlight' 0.75));                                  gripper.GradientStops.Add(new GradientStop(highlight' 1.0));                              }                                gripper.Freeze();                              CacheFreezable(gripper' (int)(horizontal ? LunaFreezables.HorizontalGripper : LunaFreezables.VerticalGripper));                          }                            sideBrush = gripper;                      }                        dc.DrawRectangle(sideBrush' null' new Rect(horizontal ? 0.0 : Max0(size.Width - 2.0)' 4.0' 2.0' Max0(size.Height - 8.0)));                  }              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (!isPressed && !isHovered && (size.Width >= 4.0))              {                  if (SeparatorVisibility == Visibility.Visible)                  {                      Brush sideBrush;                      if (SeparatorBrush != null)                      {                          sideBrush = SeparatorBrush;                      }                      else                      {                          // When not pressed or hovered' draw the resize gripper                          LinearGradientBrush gripper = (LinearGradientBrush)GetCachedFreezable((int)(horizontal ? LunaFreezables.HorizontalGripper : LunaFreezables.VerticalGripper));                          if (gripper == null)                          {                              gripper = new LinearGradientBrush();                              gripper.StartPoint = new Point();                              gripper.EndPoint = new Point(1.0' 0.0);                                Color highlight = Color.FromArgb(0xFF' 0xFF' 0xFF' 0xFF);                              Color shadow = Color.FromArgb(0xFF' 0xC7' 0xC5' 0xB2);                                if (horizontal)                              {                                  gripper.GradientStops.Add(new GradientStop(highlight' 0.0));                                  gripper.GradientStops.Add(new GradientStop(highlight' 0.25));                                  gripper.GradientStops.Add(new GradientStop(shadow' 0.75));                                  gripper.GradientStops.Add(new GradientStop(shadow' 1.0));                              }                              else                              {                                  gripper.GradientStops.Add(new GradientStop(shadow' 0.0));                                  gripper.GradientStops.Add(new GradientStop(shadow' 0.25));                                  gripper.GradientStops.Add(new GradientStop(highlight' 0.75));                                  gripper.GradientStops.Add(new GradientStop(highlight' 1.0));                              }                                gripper.Freeze();                              CacheFreezable(gripper' (int)(horizontal ? LunaFreezables.HorizontalGripper : LunaFreezables.VerticalGripper));                          }                            sideBrush = gripper;                      }                        dc.DrawRectangle(sideBrush' null' new Rect(horizontal ? 0.0 : Max0(size.Width - 2.0)' 4.0' 2.0' Max0(size.Height - 8.0)));                  }              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (!isPressed && !isHovered && (size.Width >= 4.0))              {                  if (SeparatorVisibility == Visibility.Visible)                  {                      Brush sideBrush;                      if (SeparatorBrush != null)                      {                          sideBrush = SeparatorBrush;                      }                      else                      {                          // When not pressed or hovered' draw the resize gripper                          LinearGradientBrush gripper = (LinearGradientBrush)GetCachedFreezable((int)(horizontal ? LunaFreezables.HorizontalGripper : LunaFreezables.VerticalGripper));                          if (gripper == null)                          {                              gripper = new LinearGradientBrush();                              gripper.StartPoint = new Point();                              gripper.EndPoint = new Point(1.0' 0.0);                                Color highlight = Color.FromArgb(0xFF' 0xFF' 0xFF' 0xFF);                              Color shadow = Color.FromArgb(0xFF' 0xC7' 0xC5' 0xB2);                                if (horizontal)                              {                                  gripper.GradientStops.Add(new GradientStop(highlight' 0.0));                                  gripper.GradientStops.Add(new GradientStop(highlight' 0.25));                                  gripper.GradientStops.Add(new GradientStop(shadow' 0.75));                                  gripper.GradientStops.Add(new GradientStop(shadow' 1.0));                              }                              else                              {                                  gripper.GradientStops.Add(new GradientStop(shadow' 0.0));                                  gripper.GradientStops.Add(new GradientStop(shadow' 0.25));                                  gripper.GradientStops.Add(new GradientStop(highlight' 0.75));                                  gripper.GradientStops.Add(new GradientStop(highlight' 1.0));                              }                                gripper.Freeze();                              CacheFreezable(gripper' (int)(horizontal ? LunaFreezables.HorizontalGripper : LunaFreezables.VerticalGripper));                          }                            sideBrush = gripper;                      }                        dc.DrawRectangle(sideBrush' null' new Rect(horizontal ? 0.0 : Max0(size.Width - 2.0)' 4.0' 2.0' Max0(size.Height - 8.0)));                  }              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // When sorted' draw an arrow on the right                  TranslateTransform positionTransform = new TranslateTransform(size.Width - 15.0' (size.Height - 5.0) * 0.5);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)LunaFreezables.ArrowUpGeometry : (int)LunaFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 5.0);                            LineSegment line = new LineSegment(new Point(5.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(10.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(10.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(5.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)LunaFreezables.ArrowUpGeometry : (int)LunaFreezables.ArrowDownGeometry);                  }                    SolidColorBrush arrowFill = (SolidColorBrush)GetCachedFreezable((int)LunaFreezables.ArrowFill);                  if (arrowFill == null)                  {                      arrowFill = new SolidColorBrush(Color.FromArgb(0xFF' 0xAC' 0xA8' 0x99));                      arrowFill.Freeze();                      CacheFreezable(arrowFill' (int)LunaFreezables.ArrowFill);                  }                    dc.DrawGeometry(arrowFill' null' arrowGeometry);                    dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // When sorted' draw an arrow on the right                  TranslateTransform positionTransform = new TranslateTransform(size.Width - 15.0' (size.Height - 5.0) * 0.5);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)LunaFreezables.ArrowUpGeometry : (int)LunaFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 5.0);                            LineSegment line = new LineSegment(new Point(5.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(10.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(10.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(5.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)LunaFreezables.ArrowUpGeometry : (int)LunaFreezables.ArrowDownGeometry);                  }                    SolidColorBrush arrowFill = (SolidColorBrush)GetCachedFreezable((int)LunaFreezables.ArrowFill);                  if (arrowFill == null)                  {                      arrowFill = new SolidColorBrush(Color.FromArgb(0xFF' 0xAC' 0xA8' 0x99));                      arrowFill.Freeze();                      CacheFreezable(arrowFill' (int)LunaFreezables.ArrowFill);                  }                    dc.DrawGeometry(arrowFill' null' arrowGeometry);                    dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // When sorted' draw an arrow on the right                  TranslateTransform positionTransform = new TranslateTransform(size.Width - 15.0' (size.Height - 5.0) * 0.5);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)LunaFreezables.ArrowUpGeometry : (int)LunaFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 5.0);                            LineSegment line = new LineSegment(new Point(5.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(10.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(10.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(5.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)LunaFreezables.ArrowUpGeometry : (int)LunaFreezables.ArrowDownGeometry);                  }                    SolidColorBrush arrowFill = (SolidColorBrush)GetCachedFreezable((int)LunaFreezables.ArrowFill);                  if (arrowFill == null)                  {                      arrowFill = new SolidColorBrush(Color.FromArgb(0xFF' 0xAC' 0xA8' 0x99));                      arrowFill.Freeze();                      CacheFreezable(arrowFill' (int)LunaFreezables.ArrowFill);                  }                    dc.DrawGeometry(arrowFill' null' arrowGeometry);                    dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // When sorted' draw an arrow on the right                  TranslateTransform positionTransform = new TranslateTransform(size.Width - 15.0' (size.Height - 5.0) * 0.5);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)LunaFreezables.ArrowUpGeometry : (int)LunaFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 5.0);                            LineSegment line = new LineSegment(new Point(5.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(10.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(10.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(5.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)LunaFreezables.ArrowUpGeometry : (int)LunaFreezables.ArrowDownGeometry);                  }                    SolidColorBrush arrowFill = (SolidColorBrush)GetCachedFreezable((int)LunaFreezables.ArrowFill);                  if (arrowFill == null)                  {                      arrowFill = new SolidColorBrush(Color.FromArgb(0xFF' 0xAC' 0xA8' 0x99));                      arrowFill.Freeze();                      CacheFreezable(arrowFill' (int)LunaFreezables.ArrowFill);                  }                    dc.DrawGeometry(arrowFill' null' arrowGeometry);                    dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // When sorted' draw an arrow on the right                  TranslateTransform positionTransform = new TranslateTransform(size.Width - 15.0' (size.Height - 5.0) * 0.5);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)LunaFreezables.ArrowUpGeometry : (int)LunaFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 5.0);                            LineSegment line = new LineSegment(new Point(5.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(10.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(10.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(5.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)LunaFreezables.ArrowUpGeometry : (int)LunaFreezables.ArrowDownGeometry);                  }                    SolidColorBrush arrowFill = (SolidColorBrush)GetCachedFreezable((int)LunaFreezables.ArrowFill);                  if (arrowFill == null)                  {                      arrowFill = new SolidColorBrush(Color.FromArgb(0xFF' 0xAC' 0xA8' 0x99));                      arrowFill.Freeze();                      CacheFreezable(arrowFill' (int)LunaFreezables.ArrowFill);                  }                    dc.DrawGeometry(arrowFill' null' arrowGeometry);                    dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // When sorted' draw an arrow on the right                  TranslateTransform positionTransform = new TranslateTransform(size.Width - 15.0' (size.Height - 5.0) * 0.5);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)LunaFreezables.ArrowUpGeometry : (int)LunaFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 5.0);                            LineSegment line = new LineSegment(new Point(5.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(10.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(10.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(5.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)LunaFreezables.ArrowUpGeometry : (int)LunaFreezables.ArrowDownGeometry);                  }                    SolidColorBrush arrowFill = (SolidColorBrush)GetCachedFreezable((int)LunaFreezables.ArrowFill);                  if (arrowFill == null)                  {                      arrowFill = new SolidColorBrush(Color.FromArgb(0xFF' 0xAC' 0xA8' 0x99));                      arrowFill.Freeze();                      CacheFreezable(arrowFill' (int)LunaFreezables.ArrowFill);                  }                    dc.DrawGeometry(arrowFill' null' arrowGeometry);                    dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // When sorted' draw an arrow on the right                  TranslateTransform positionTransform = new TranslateTransform(size.Width - 15.0' (size.Height - 5.0) * 0.5);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)LunaFreezables.ArrowUpGeometry : (int)LunaFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 5.0);                            LineSegment line = new LineSegment(new Point(5.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(10.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(10.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(5.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)LunaFreezables.ArrowUpGeometry : (int)LunaFreezables.ArrowDownGeometry);                  }                    SolidColorBrush arrowFill = (SolidColorBrush)GetCachedFreezable((int)LunaFreezables.ArrowFill);                  if (arrowFill == null)                  {                      arrowFill = new SolidColorBrush(Color.FromArgb(0xFF' 0xAC' 0xA8' 0x99));                      arrowFill.Freeze();                      CacheFreezable(arrowFill' (int)LunaFreezables.ArrowFill);                  }                    dc.DrawGeometry(arrowFill' null' arrowGeometry);                    dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // When sorted' draw an arrow on the right                  TranslateTransform positionTransform = new TranslateTransform(size.Width - 15.0' (size.Height - 5.0) * 0.5);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)LunaFreezables.ArrowUpGeometry : (int)LunaFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 5.0);                            LineSegment line = new LineSegment(new Point(5.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(10.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(10.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(5.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)LunaFreezables.ArrowUpGeometry : (int)LunaFreezables.ArrowDownGeometry);                  }                    SolidColorBrush arrowFill = (SolidColorBrush)GetCachedFreezable((int)LunaFreezables.ArrowFill);                  if (arrowFill == null)                  {                      arrowFill = new SolidColorBrush(Color.FromArgb(0xFF' 0xAC' 0xA8' 0x99));                      arrowFill.Freeze();                      CacheFreezable(arrowFill' (int)LunaFreezables.ArrowFill);                  }                    dc.DrawGeometry(arrowFill' null' arrowGeometry);                    dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // When sorted' draw an arrow on the right                  TranslateTransform positionTransform = new TranslateTransform(size.Width - 15.0' (size.Height - 5.0) * 0.5);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)LunaFreezables.ArrowUpGeometry : (int)LunaFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 5.0);                            LineSegment line = new LineSegment(new Point(5.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(10.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(10.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(5.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)LunaFreezables.ArrowUpGeometry : (int)LunaFreezables.ArrowDownGeometry);                  }                    SolidColorBrush arrowFill = (SolidColorBrush)GetCachedFreezable((int)LunaFreezables.ArrowFill);                  if (arrowFill == null)                  {                      arrowFill = new SolidColorBrush(Color.FromArgb(0xFF' 0xAC' 0xA8' 0x99));                      arrowFill.Freeze();                      CacheFreezable(arrowFill' (int)LunaFreezables.ArrowFill);                  }                    dc.DrawGeometry(arrowFill' null' arrowGeometry);                    dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // When sorted' draw an arrow on the right                  TranslateTransform positionTransform = new TranslateTransform(size.Width - 15.0' (size.Height - 5.0) * 0.5);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)LunaFreezables.ArrowUpGeometry : (int)LunaFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 5.0);                            LineSegment line = new LineSegment(new Point(5.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(10.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(10.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(5.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)LunaFreezables.ArrowUpGeometry : (int)LunaFreezables.ArrowDownGeometry);                  }                    SolidColorBrush arrowFill = (SolidColorBrush)GetCachedFreezable((int)LunaFreezables.ArrowFill);                  if (arrowFill == null)                  {                      arrowFill = new SolidColorBrush(Color.FromArgb(0xFF' 0xAC' 0xA8' 0x99));                      arrowFill.Freeze();                      CacheFreezable(arrowFill' (int)LunaFreezables.ArrowFill);                  }                    dc.DrawGeometry(arrowFill' null' arrowGeometry);                    dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // When sorted' draw an arrow on the right                  TranslateTransform positionTransform = new TranslateTransform(size.Width - 15.0' (size.Height - 5.0) * 0.5);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)LunaFreezables.ArrowUpGeometry : (int)LunaFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 5.0);                            LineSegment line = new LineSegment(new Point(5.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(10.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(10.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(5.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)LunaFreezables.ArrowUpGeometry : (int)LunaFreezables.ArrowDownGeometry);                  }                    SolidColorBrush arrowFill = (SolidColorBrush)GetCachedFreezable((int)LunaFreezables.ArrowFill);                  if (arrowFill == null)                  {                      arrowFill = new SolidColorBrush(Color.FromArgb(0xFF' 0xAC' 0xA8' 0x99));                      arrowFill.Freeze();                      CacheFreezable(arrowFill' (int)LunaFreezables.ArrowFill);                  }                    dc.DrawGeometry(arrowFill' null' arrowGeometry);                    dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderLuna,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // When sorted' draw an arrow on the right                  TranslateTransform positionTransform = new TranslateTransform(size.Width - 15.0' (size.Height - 5.0) * 0.5);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)LunaFreezables.ArrowUpGeometry : (int)LunaFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 5.0);                            LineSegment line = new LineSegment(new Point(5.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(10.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(10.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(5.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)LunaFreezables.ArrowUpGeometry : (int)LunaFreezables.ArrowDownGeometry);                  }                    SolidColorBrush arrowFill = (SolidColorBrush)GetCachedFreezable((int)LunaFreezables.ArrowFill);                  if (arrowFill == null)                  {                      arrowFill = new SolidColorBrush(Color.FromArgb(0xFF' 0xAC' 0xA8' 0x99));                      arrowFill.Freeze();                      CacheFreezable(arrowFill' (int)LunaFreezables.ArrowFill);                  }                    dc.DrawGeometry(arrowFill' null' arrowGeometry);                    dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderClassic,The following statement contains a magic number: if ((size.Width > 3.0) && (size.Height > 3.0))              {                  // Draw the border                  if (isPressed)                  {                      dc.DrawRectangle(dark' null' new Rect(0.0' 0.0' size.Width' 1.0));                      dc.DrawRectangle(dark' null' new Rect(0.0' 0.0' 1.0' size.Height));                      dc.DrawRectangle(dark' null' new Rect(0.0' Max0(size.Height - 1.0)' size.Width' 1.0));                      dc.DrawRectangle(dark' null' new Rect(Max0(size.Width - 1.0)' 0.0' 1.0' size.Height));                  }                  else                  {                      dc.DrawRectangle(light' null' new Rect(0.0' 0.0' 1.0' Max0(size.Height - 1.0)));                      dc.DrawRectangle(light' null' new Rect(0.0' 0.0' Max0(size.Width - 1.0)' 1.0));                                            if (shouldDrawRight)                      {                          if (!usingSeparatorBrush)                          {                              dc.DrawRectangle(dark' null' new Rect(Max0(size.Width - 2.0)' 1.0' 1.0' Max0(size.Height - 2.0)));                          }                            dc.DrawRectangle(darkDarkRight' null' new Rect(Max0(size.Width - 1.0)' 0.0' 1.0' size.Height));                      }                        if (shouldDrawBottom)                      {                          if (!usingSeparatorBrush)                          {                              dc.DrawRectangle(dark' null' new Rect(1.0' Max0(size.Height - 2.0)' Max0(size.Width - 2.0)' 1.0));                          }                            dc.DrawRectangle(darkDarkBottom' null' new Rect(0.0' Max0(size.Height - 1.0)' size.Width' 1.0));                      }                  }              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderClassic,The following statement contains a magic number: if ((size.Width > 3.0) && (size.Height > 3.0))              {                  // Draw the border                  if (isPressed)                  {                      dc.DrawRectangle(dark' null' new Rect(0.0' 0.0' size.Width' 1.0));                      dc.DrawRectangle(dark' null' new Rect(0.0' 0.0' 1.0' size.Height));                      dc.DrawRectangle(dark' null' new Rect(0.0' Max0(size.Height - 1.0)' size.Width' 1.0));                      dc.DrawRectangle(dark' null' new Rect(Max0(size.Width - 1.0)' 0.0' 1.0' size.Height));                  }                  else                  {                      dc.DrawRectangle(light' null' new Rect(0.0' 0.0' 1.0' Max0(size.Height - 1.0)));                      dc.DrawRectangle(light' null' new Rect(0.0' 0.0' Max0(size.Width - 1.0)' 1.0));                                            if (shouldDrawRight)                      {                          if (!usingSeparatorBrush)                          {                              dc.DrawRectangle(dark' null' new Rect(Max0(size.Width - 2.0)' 1.0' 1.0' Max0(size.Height - 2.0)));                          }                            dc.DrawRectangle(darkDarkRight' null' new Rect(Max0(size.Width - 1.0)' 0.0' 1.0' size.Height));                      }                        if (shouldDrawBottom)                      {                          if (!usingSeparatorBrush)                          {                              dc.DrawRectangle(dark' null' new Rect(1.0' Max0(size.Height - 2.0)' Max0(size.Width - 2.0)' 1.0));                          }                            dc.DrawRectangle(darkDarkBottom' null' new Rect(0.0' Max0(size.Height - 1.0)' size.Width' 1.0));                      }                  }              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderClassic,The following statement contains a magic number: if ((size.Width > 3.0) && (size.Height > 3.0))              {                  // Draw the border                  if (isPressed)                  {                      dc.DrawRectangle(dark' null' new Rect(0.0' 0.0' size.Width' 1.0));                      dc.DrawRectangle(dark' null' new Rect(0.0' 0.0' 1.0' size.Height));                      dc.DrawRectangle(dark' null' new Rect(0.0' Max0(size.Height - 1.0)' size.Width' 1.0));                      dc.DrawRectangle(dark' null' new Rect(Max0(size.Width - 1.0)' 0.0' 1.0' size.Height));                  }                  else                  {                      dc.DrawRectangle(light' null' new Rect(0.0' 0.0' 1.0' Max0(size.Height - 1.0)));                      dc.DrawRectangle(light' null' new Rect(0.0' 0.0' Max0(size.Width - 1.0)' 1.0));                                            if (shouldDrawRight)                      {                          if (!usingSeparatorBrush)                          {                              dc.DrawRectangle(dark' null' new Rect(Max0(size.Width - 2.0)' 1.0' 1.0' Max0(size.Height - 2.0)));                          }                            dc.DrawRectangle(darkDarkRight' null' new Rect(Max0(size.Width - 1.0)' 0.0' 1.0' size.Height));                      }                        if (shouldDrawBottom)                      {                          if (!usingSeparatorBrush)                          {                              dc.DrawRectangle(dark' null' new Rect(1.0' Max0(size.Height - 2.0)' Max0(size.Width - 2.0)' 1.0));                          }                            dc.DrawRectangle(darkDarkBottom' null' new Rect(0.0' Max0(size.Height - 1.0)' size.Width' 1.0));                      }                  }              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderClassic,The following statement contains a magic number: if ((size.Width > 3.0) && (size.Height > 3.0))              {                  // Draw the border                  if (isPressed)                  {                      dc.DrawRectangle(dark' null' new Rect(0.0' 0.0' size.Width' 1.0));                      dc.DrawRectangle(dark' null' new Rect(0.0' 0.0' 1.0' size.Height));                      dc.DrawRectangle(dark' null' new Rect(0.0' Max0(size.Height - 1.0)' size.Width' 1.0));                      dc.DrawRectangle(dark' null' new Rect(Max0(size.Width - 1.0)' 0.0' 1.0' size.Height));                  }                  else                  {                      dc.DrawRectangle(light' null' new Rect(0.0' 0.0' 1.0' Max0(size.Height - 1.0)));                      dc.DrawRectangle(light' null' new Rect(0.0' 0.0' Max0(size.Width - 1.0)' 1.0));                                            if (shouldDrawRight)                      {                          if (!usingSeparatorBrush)                          {                              dc.DrawRectangle(dark' null' new Rect(Max0(size.Width - 2.0)' 1.0' 1.0' Max0(size.Height - 2.0)));                          }                            dc.DrawRectangle(darkDarkRight' null' new Rect(Max0(size.Width - 1.0)' 0.0' 1.0' size.Height));                      }                        if (shouldDrawBottom)                      {                          if (!usingSeparatorBrush)                          {                              dc.DrawRectangle(dark' null' new Rect(1.0' Max0(size.Height - 2.0)' Max0(size.Width - 2.0)' 1.0));                          }                            dc.DrawRectangle(darkDarkBottom' null' new Rect(0.0' Max0(size.Height - 1.0)' size.Width' 1.0));                      }                  }              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderClassic,The following statement contains a magic number: if ((size.Width > 3.0) && (size.Height > 3.0))              {                  // Draw the border                  if (isPressed)                  {                      dc.DrawRectangle(dark' null' new Rect(0.0' 0.0' size.Width' 1.0));                      dc.DrawRectangle(dark' null' new Rect(0.0' 0.0' 1.0' size.Height));                      dc.DrawRectangle(dark' null' new Rect(0.0' Max0(size.Height - 1.0)' size.Width' 1.0));                      dc.DrawRectangle(dark' null' new Rect(Max0(size.Width - 1.0)' 0.0' 1.0' size.Height));                  }                  else                  {                      dc.DrawRectangle(light' null' new Rect(0.0' 0.0' 1.0' Max0(size.Height - 1.0)));                      dc.DrawRectangle(light' null' new Rect(0.0' 0.0' Max0(size.Width - 1.0)' 1.0));                                            if (shouldDrawRight)                      {                          if (!usingSeparatorBrush)                          {                              dc.DrawRectangle(dark' null' new Rect(Max0(size.Width - 2.0)' 1.0' 1.0' Max0(size.Height - 2.0)));                          }                            dc.DrawRectangle(darkDarkRight' null' new Rect(Max0(size.Width - 1.0)' 0.0' 1.0' size.Height));                      }                        if (shouldDrawBottom)                      {                          if (!usingSeparatorBrush)                          {                              dc.DrawRectangle(dark' null' new Rect(1.0' Max0(size.Height - 2.0)' Max0(size.Width - 2.0)' 1.0));                          }                            dc.DrawRectangle(darkDarkBottom' null' new Rect(0.0' Max0(size.Height - 1.0)' size.Width' 1.0));                      }                  }              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderClassic,The following statement contains a magic number: if ((size.Width > 3.0) && (size.Height > 3.0))              {                  // Draw the border                  if (isPressed)                  {                      dc.DrawRectangle(dark' null' new Rect(0.0' 0.0' size.Width' 1.0));                      dc.DrawRectangle(dark' null' new Rect(0.0' 0.0' 1.0' size.Height));                      dc.DrawRectangle(dark' null' new Rect(0.0' Max0(size.Height - 1.0)' size.Width' 1.0));                      dc.DrawRectangle(dark' null' new Rect(Max0(size.Width - 1.0)' 0.0' 1.0' size.Height));                  }                  else                  {                      dc.DrawRectangle(light' null' new Rect(0.0' 0.0' 1.0' Max0(size.Height - 1.0)));                      dc.DrawRectangle(light' null' new Rect(0.0' 0.0' Max0(size.Width - 1.0)' 1.0));                                            if (shouldDrawRight)                      {                          if (!usingSeparatorBrush)                          {                              dc.DrawRectangle(dark' null' new Rect(Max0(size.Width - 2.0)' 1.0' 1.0' Max0(size.Height - 2.0)));                          }                            dc.DrawRectangle(darkDarkRight' null' new Rect(Max0(size.Width - 1.0)' 0.0' 1.0' size.Height));                      }                        if (shouldDrawBottom)                      {                          if (!usingSeparatorBrush)                          {                              dc.DrawRectangle(dark' null' new Rect(1.0' Max0(size.Height - 2.0)' Max0(size.Width - 2.0)' 1.0));                          }                            dc.DrawRectangle(darkDarkBottom' null' new Rect(0.0' Max0(size.Height - 1.0)' size.Width' 1.0));                      }                  }              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderClassic,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // If sorted' draw an arrow on the right                  TranslateTransform positionTransform = new TranslateTransform(size.Width - 15.0' (size.Height - 5.0) * 0.5);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)ClassicFreezables.ArrowUpGeometry : (int)ClassicFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 5.0);                            LineSegment line = new LineSegment(new Point(5.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(10.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(10.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(5.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)ClassicFreezables.ArrowUpGeometry : (int)ClassicFreezables.ArrowDownGeometry);                  }                    dc.DrawGeometry(SystemColors.GrayTextBrush' null' arrowGeometry);                    dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderClassic,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // If sorted' draw an arrow on the right                  TranslateTransform positionTransform = new TranslateTransform(size.Width - 15.0' (size.Height - 5.0) * 0.5);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)ClassicFreezables.ArrowUpGeometry : (int)ClassicFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 5.0);                            LineSegment line = new LineSegment(new Point(5.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(10.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(10.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(5.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)ClassicFreezables.ArrowUpGeometry : (int)ClassicFreezables.ArrowDownGeometry);                  }                    dc.DrawGeometry(SystemColors.GrayTextBrush' null' arrowGeometry);                    dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderClassic,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // If sorted' draw an arrow on the right                  TranslateTransform positionTransform = new TranslateTransform(size.Width - 15.0' (size.Height - 5.0) * 0.5);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)ClassicFreezables.ArrowUpGeometry : (int)ClassicFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 5.0);                            LineSegment line = new LineSegment(new Point(5.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(10.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(10.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(5.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)ClassicFreezables.ArrowUpGeometry : (int)ClassicFreezables.ArrowDownGeometry);                  }                    dc.DrawGeometry(SystemColors.GrayTextBrush' null' arrowGeometry);                    dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderClassic,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // If sorted' draw an arrow on the right                  TranslateTransform positionTransform = new TranslateTransform(size.Width - 15.0' (size.Height - 5.0) * 0.5);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)ClassicFreezables.ArrowUpGeometry : (int)ClassicFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 5.0);                            LineSegment line = new LineSegment(new Point(5.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(10.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(10.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(5.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)ClassicFreezables.ArrowUpGeometry : (int)ClassicFreezables.ArrowDownGeometry);                  }                    dc.DrawGeometry(SystemColors.GrayTextBrush' null' arrowGeometry);                    dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderClassic,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // If sorted' draw an arrow on the right                  TranslateTransform positionTransform = new TranslateTransform(size.Width - 15.0' (size.Height - 5.0) * 0.5);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)ClassicFreezables.ArrowUpGeometry : (int)ClassicFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 5.0);                            LineSegment line = new LineSegment(new Point(5.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(10.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(10.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(5.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)ClassicFreezables.ArrowUpGeometry : (int)ClassicFreezables.ArrowDownGeometry);                  }                    dc.DrawGeometry(SystemColors.GrayTextBrush' null' arrowGeometry);                    dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderClassic,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // If sorted' draw an arrow on the right                  TranslateTransform positionTransform = new TranslateTransform(size.Width - 15.0' (size.Height - 5.0) * 0.5);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)ClassicFreezables.ArrowUpGeometry : (int)ClassicFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 5.0);                            LineSegment line = new LineSegment(new Point(5.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(10.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(10.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(5.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)ClassicFreezables.ArrowUpGeometry : (int)ClassicFreezables.ArrowDownGeometry);                  }                    dc.DrawGeometry(SystemColors.GrayTextBrush' null' arrowGeometry);                    dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderClassic,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // If sorted' draw an arrow on the right                  TranslateTransform positionTransform = new TranslateTransform(size.Width - 15.0' (size.Height - 5.0) * 0.5);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)ClassicFreezables.ArrowUpGeometry : (int)ClassicFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 5.0);                            LineSegment line = new LineSegment(new Point(5.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(10.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(10.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(5.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)ClassicFreezables.ArrowUpGeometry : (int)ClassicFreezables.ArrowDownGeometry);                  }                    dc.DrawGeometry(SystemColors.GrayTextBrush' null' arrowGeometry);                    dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderClassic,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // If sorted' draw an arrow on the right                  TranslateTransform positionTransform = new TranslateTransform(size.Width - 15.0' (size.Height - 5.0) * 0.5);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)ClassicFreezables.ArrowUpGeometry : (int)ClassicFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 5.0);                            LineSegment line = new LineSegment(new Point(5.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(10.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(10.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(5.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)ClassicFreezables.ArrowUpGeometry : (int)ClassicFreezables.ArrowDownGeometry);                  }                    dc.DrawGeometry(SystemColors.GrayTextBrush' null' arrowGeometry);                    dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderClassic,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // If sorted' draw an arrow on the right                  TranslateTransform positionTransform = new TranslateTransform(size.Width - 15.0' (size.Height - 5.0) * 0.5);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)ClassicFreezables.ArrowUpGeometry : (int)ClassicFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 5.0);                            LineSegment line = new LineSegment(new Point(5.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(10.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(10.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(5.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)ClassicFreezables.ArrowUpGeometry : (int)ClassicFreezables.ArrowDownGeometry);                  }                    dc.DrawGeometry(SystemColors.GrayTextBrush' null' arrowGeometry);                    dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderClassic,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // If sorted' draw an arrow on the right                  TranslateTransform positionTransform = new TranslateTransform(size.Width - 15.0' (size.Height - 5.0) * 0.5);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)ClassicFreezables.ArrowUpGeometry : (int)ClassicFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 5.0);                            LineSegment line = new LineSegment(new Point(5.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(10.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(10.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(5.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)ClassicFreezables.ArrowUpGeometry : (int)ClassicFreezables.ArrowDownGeometry);                  }                    dc.DrawGeometry(SystemColors.GrayTextBrush' null' arrowGeometry);                    dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderClassic,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // If sorted' draw an arrow on the right                  TranslateTransform positionTransform = new TranslateTransform(size.Width - 15.0' (size.Height - 5.0) * 0.5);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)ClassicFreezables.ArrowUpGeometry : (int)ClassicFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 5.0);                            LineSegment line = new LineSegment(new Point(5.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(10.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(10.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(5.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)ClassicFreezables.ArrowUpGeometry : (int)ClassicFreezables.ArrowDownGeometry);                  }                    dc.DrawGeometry(SystemColors.GrayTextBrush' null' arrowGeometry);                    dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderClassic,The following statement contains a magic number: if (isSorted && (size.Width > 14.0) && (size.Height > 10.0))              {                  // If sorted' draw an arrow on the right                  TranslateTransform positionTransform = new TranslateTransform(size.Width - 15.0' (size.Height - 5.0) * 0.5);                  positionTransform.Freeze();                  dc.PushTransform(positionTransform);                    bool ascending = (sortDirection == ListSortDirection.Ascending);                  PathGeometry arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)ClassicFreezables.ArrowUpGeometry : (int)ClassicFreezables.ArrowDownGeometry);                  if (arrowGeometry == null)                  {                      arrowGeometry = new PathGeometry();                      PathFigure arrowFigure = new PathFigure();                        if (ascending)                      {                          arrowFigure.StartPoint = new Point(0.0' 5.0);                            LineSegment line = new LineSegment(new Point(5.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(10.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                      else                      {                          arrowFigure.StartPoint = new Point(0.0' 0.0);                            LineSegment line = new LineSegment(new Point(10.0' 0.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                            line = new LineSegment(new Point(5.0' 5.0)' false);                          line.Freeze();                          arrowFigure.Segments.Add(line);                      }                        arrowFigure.IsClosed = true;                      arrowFigure.Freeze();                        arrowGeometry.Figures.Add(arrowFigure);                      arrowGeometry.Freeze();                        CacheFreezable(arrowGeometry' ascending ? (int)ClassicFreezables.ArrowUpGeometry : (int)ClassicFreezables.ArrowDownGeometry);                  }                    dc.DrawGeometry(SystemColors.GrayTextBrush' null' arrowGeometry);                    dc.Pop(); // Position Transform              }
Magic Number,Microsoft.Windows.Controls,DatePicker,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DatePicker\Microsoft\Windows\Controls\DatePicker.cs,SetIsHandlerSuspended,The following statement contains a magic number: if (value)              {                  if (_isHandlerSuspended == null)                  {                      _isHandlerSuspended = new Dictionary<DependencyProperty' bool>(2);                  }                    _isHandlerSuspended[property] = true;              }              else              {                  if (_isHandlerSuspended != null)                  {                      _isHandlerSuspended.Remove(property);                  }              }
Magic Number,Microsoft.Windows.Controls,DatePicker,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DatePicker\Microsoft\Windows\Controls\DatePicker.cs,Calendar_SelectedDatesChanged,The following statement contains a magic number: Debug.Assert(e.AddedItems.Count < 2);
Magic Number,Microsoft.Windows.Controls.Primitives,CalendarItem,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\CalendarItem.cs,UpdateDecadeMode,The following statement contains a magic number: int decadeEnd = decade + 9;
Magic Number,Microsoft.Windows.Controls.Primitives,CalendarItem,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\CalendarItem.cs,GetDecadeForDecadeMode,The following statement contains a magic number: if (_isMonthPressed && _yearView != null)              {                  UIElementCollection yearViewChildren = _yearView.Children;                  int count = yearViewChildren.Count;                    if (count > 0)                  {                      CalendarButton child = yearViewChildren[0] as CalendarButton;                      if (child != null &&                          child.DataContext is DateTime &&                          ((DateTime)child.DataContext).Year == selectedYear.Year)                      {                          return (decade + 10);                      }                  }                    if (count > 1)                  {                      CalendarButton child = yearViewChildren[count - 1] as CalendarButton;                      if (child != null &&                          child.DataContext is DateTime &&                          ((DateTime)child.DataContext).Year == selectedYear.Year)                      {                          return (decade - 10);                      }                  }              }
Magic Number,Microsoft.Windows.Controls.Primitives,CalendarItem,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\CalendarItem.cs,GetDecadeForDecadeMode,The following statement contains a magic number: if (_isMonthPressed && _yearView != null)              {                  UIElementCollection yearViewChildren = _yearView.Children;                  int count = yearViewChildren.Count;                    if (count > 0)                  {                      CalendarButton child = yearViewChildren[0] as CalendarButton;                      if (child != null &&                          child.DataContext is DateTime &&                          ((DateTime)child.DataContext).Year == selectedYear.Year)                      {                          return (decade + 10);                      }                  }                    if (count > 1)                  {                      CalendarButton child = yearViewChildren[count - 1] as CalendarButton;                      if (child != null &&                          child.DataContext is DateTime &&                          ((DateTime)child.DataContext).Year == selectedYear.Year)                      {                          return (decade - 10);                      }                  }              }
Magic Number,Microsoft.Windows.Controls.Primitives,DataGridColumnHeadersPresenter,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\Primitives\DataGridColumnHeadersPresenter.cs,ArrangeOverride,The following statement contains a magic number: if (_columnHeaderDropLocationIndicator != null && _isColumnHeaderDragging)              {                  Point point = FindColumnHeaderPositionByCurrentPosition(_columnHeaderDragCurrentPosition' true);                  double dropIndicatorWidth = _columnHeaderDropLocationIndicator.Width;                  point.X -= dropIndicatorWidth * 0.5;                  _columnHeaderDropLocationIndicator.Arrange(new Rect(point' new Size(dropIndicatorWidth' _columnHeaderDropLocationIndicator.Height)));              }
Magic Number,Microsoft.Windows.Controls.Primitives,DataGridColumnHeadersPresenter,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\Primitives\DataGridColumnHeadersPresenter.cs,OnHeaderMouseMove,The following statement contains a magic number: if (e.LeftButton == MouseButtonState.Pressed)              {                  if (_prepareColumnHeaderDragging)                  {                      _columnHeaderDragCurrentPosition = e.GetPosition(this);                        if (!_isColumnHeaderDragging)                      {                          if (CheckStartColumnHeaderDrag(_columnHeaderDragCurrentPosition' _columnHeaderDragStartPosition))                          {                              StartColumnHeaderDrag();                          }                      }                      else                      {                          bool shouldDisplayDragIndicator = IsMousePositionValidForColumnDrag(2.0);                          Visibility dragIndicatorVisibility = shouldDisplayDragIndicator ? Visibility.Visible : Visibility.Collapsed;                            if (_columnHeaderDragIndicator != null)                          {                              _columnHeaderDragIndicator.Visibility = dragIndicatorVisibility;                          }                            if (_columnHeaderDropLocationIndicator != null)                          {                              _columnHeaderDropLocationIndicator.Visibility = dragIndicatorVisibility;                          }                            InvalidateArrange();                            DragDeltaEventArgs dragDeltaEventArgs = new DragDeltaEventArgs(                              _columnHeaderDragCurrentPosition.X - _columnHeaderDragStartPosition.X'                              _columnHeaderDragCurrentPosition.Y - _columnHeaderDragStartPosition.Y);                            _columnHeaderDragStartPosition = _columnHeaderDragCurrentPosition;                          ParentDataGrid.OnColumnHeaderDragDelta(dragDeltaEventArgs);                      }                  }              }
Magic Number,Microsoft.Windows.Controls.Primitives,DataGridColumnHeadersPresenter,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\Primitives\DataGridColumnHeadersPresenter.cs,FinishColumnHeaderDrag,The following statement contains a magic number: if (!isCancel)              {                  int newDisplayIndex = -1;                  bool dragEndPositionValid = IsMousePositionValidForColumnDrag(                      2.0'                      out newDisplayIndex);                    DataGridColumn column = _draggingSrcColumnHeader.Column;                  if (column != null && dragEndPositionValid && newDisplayIndex != column.DisplayIndex)                  {                      column.DisplayIndex = newDisplayIndex;                        DataGridColumnEventArgs columnEventArgs = new DataGridColumnEventArgs(_draggingSrcColumnHeader.Column);                      ParentDataGrid.OnColumnReordered(columnEventArgs);                  }              }
Magic Number,Microsoft.Windows.Controls.Primitives,DataGridColumnHeadersPresenter,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\Primitives\DataGridColumnHeadersPresenter.cs,FindDisplayIndexAndHeaderPosition,The following statement contains a magic number: for (i = 0; i < dataGrid.Columns.Count; i++)              {                  displayIndex++;                  DataGridColumnHeader currentHeader = dataGrid.ColumnHeaderFromDisplayIndex(i);                  if (currentHeader == null)                  {                      DataGridColumn column = dataGrid.ColumnFromDisplayIndex(i);                      if (!column.IsVisible)                      {                          continue;                      }                      else                      {                          headerStartX = headerEndX;                          if (i >= dataGrid.FrozenColumnCount &&                              !firstVisibleNonFrozenColumnHandled)                          {                              headerStartX -= dataGrid.HorizontalScrollOffset;                              firstVisibleNonFrozenColumnHandled = true;                          }                            headerEndX = headerStartX + GetColumnEstimatedWidth(column' averageColumnWidth);                      }                  }                  else                  {                      GeneralTransform transform = currentHeader.TransformToAncestor(this);                      headerStartX = transform.Transform(originPoint).X;                      headerEndX = headerStartX + currentHeader.RenderSize.Width;                  }                    if (DoubleUtil.LessThanOrClose(startPos.X' headerStartX))                  {                      break;                  }                    if (DoubleUtil.GreaterThanOrClose(startPos.X' headerStartX) &&                      DoubleUtil.LessThanOrClose(startPos.X' headerEndX))                  {                      if (findNearestColumn)                      {                          double headerMidX = (headerStartX + headerEndX) * 0.5;                          if (DoubleUtil.GreaterThanOrClose(startPos.X' headerMidX))                          {                              headerStartX = headerEndX;                              displayIndex++;                          }                            if (_draggingSrcColumnHeader != null && _draggingSrcColumnHeader.Column != null && _draggingSrcColumnHeader.Column.DisplayIndex < displayIndex)                          {                              displayIndex--;                          }                      }                      else                      {                          header = currentHeader;                      }                        break;                  }              }
Magic Number,MS.Internal,DoubleUtil,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DoubleUtil.cs,AreClose,The following statement contains a magic number: double eps = (Math.Abs(value1) + Math.Abs(value2) + 10.0) * DBL_EPSILON;
Magic Number,MS.Internal,DoubleUtil,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DoubleUtil.cs,IsOne,The following statement contains a magic number: return Math.Abs(value - 1.0) < 10.0 * DBL_EPSILON;
Magic Number,System.Windows,VisualStateManager,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\VSM\VisualStateManager\System\Windows\VisualStateManager.cs,GetTransition,The following statement contains a magic number: if (transitions != null)              {                  foreach (VisualTransition transition in transitions)                  {                      if (defaultTransition == null && transition.IsDefault)                      {                          defaultTransition = transition;                          continue;                      }                        int score = -1;                        VisualState transitionFromState = group.GetState(transition.From);                      VisualState transitionToState = group.GetState(transition.To);                        if (from == transitionFromState)                      {                          score += 1;                      }                      else if (transitionFromState != null)                      {                          continue;                      }                        if (to == transitionToState)                      {                          score += 2;                      }                      else if (transitionToState != null)                      {                          continue;                      }                        if (score > bestScore)                      {                          bestScore = score;                          best = transition;                      }                  }              }
Missing Default,Microsoft.Windows.Automation.Peers,CalendarAutomationPeer,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Automation\Peers\CalendarAutomationPeer.cs,GetViewName,The following switch statement is missing a default case: switch (viewId)              {                  case 0:                      {                          return SR.Get(SRID.CalendarAutomationPeer_MonthMode);                      }                    case 1:                      {                          return SR.Get(SRID.CalendarAutomationPeer_YearMode);                      }                    case 2:                      {                          return SR.Get(SRID.CalendarAutomationPeer_DecadeMode);                      }              }
Missing Default,Microsoft.Windows.Automation.Peers,DataGridCellItemAutomationPeer,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Automation\Peers\DataGridCellItemAutomationPeer.cs,GetPattern,The following switch statement is missing a default case: switch (patternInterface)              {                  case PatternInterface.Invoke:                      if (!this.OwningDataGrid.IsReadOnly && !_column.IsReadOnly)                      {                          return this;                      }                        break;                  case PatternInterface.SelectionItem:                  case PatternInterface.ScrollItem:                  case PatternInterface.GridItem:                  case PatternInterface.TableItem:                      return this;              }
Missing Default,Microsoft.Windows.Automation.Peers,DataGridAutomationPeer,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Automation\Peers\DataGridAutomationPeer.cs,GetPattern,The following switch statement is missing a default case: switch (patternInterface)              {                  case PatternInterface.Grid:                  case PatternInterface.Selection:                  case PatternInterface.Table:                      return this;                  case PatternInterface.Scroll:                      {                          ScrollViewer scrollViewer = this.OwningDataGrid.InternalScrollHost;                          if (scrollViewer != null)                          {                              AutomationPeer scrollPeer = UIElementAutomationPeer.CreatePeerForElement(scrollViewer);                              IScrollProvider scrollProvider = scrollPeer as IScrollProvider;                              if (scrollPeer != null && scrollProvider != null)                              {                                  scrollPeer.EventsSource = this;                                  return scrollProvider;                              }                          }                            break;                      }              }
Missing Default,Microsoft.Windows.Automation.Peers,DataGridColumnHeaderAutomationPeer,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Automation\Peers\DataGridColumnHeaderAutomationPeer.cs,GetPattern,The following switch statement is missing a default case: switch (patternInterface)              {                  case PatternInterface.Invoke:                      {                          if (this.OwningHeader.Column != null && this.OwningHeader.Column.CanUserSort)                          {                              return this;                          }                            break;                      }                    case PatternInterface.ScrollItem:                      {                          return this;                      }                    case PatternInterface.Transform:                      {                          if (this.OwningHeader.Column != null && this.OwningHeader.Column.DataGridOwner.CanUserResizeColumns)                          {                              return this;                          }                                                    break;                      }              }
Missing Default,Microsoft.Windows.Automation.Peers,DataGridItemAutomationPeer,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Automation\Peers\DataGridItemAutomationPeer.cs,GetPattern,The following switch statement is missing a default case: switch (patternInterface)              {                  case PatternInterface.Invoke:                      {                          if (!this.OwningDataGrid.IsReadOnly)                          {                              return this;                          }                            break;                      }                    case PatternInterface.ScrollItem:                  case PatternInterface.Selection:                      return this;                  case PatternInterface.SelectionItem:                      if (IsRowSelectionUnit)                      {                          return this;                      }                      break;              }
Missing Default,Microsoft.Windows.Controls,Calendar,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\Calendar.cs,ProcessCalendarKey,The following switch statement is missing a default case: switch (e.Key)              {                  case Key.Up:                  {                      ProcessUpKey(ctrl' shift);                      return true;                  }                    case Key.Down:                  {                      ProcessDownKey(ctrl' shift);                      return true;                  }                    case Key.Left:                  {                      ProcessLeftKey(shift);                      return true;                  }                    case Key.Right:                  {                      ProcessRightKey(shift);                      return true;                  }                    case Key.PageDown:                  {                      ProcessPageDownKey(shift);                      return true;                  }                    case Key.PageUp:                  {                      ProcessPageUpKey(shift);                      return true;                  }                    case Key.Home:                  {                      ProcessHomeKey(shift);                      return true;                  }                    case Key.End:                  {                      ProcessEndKey(shift);                      return true;                  }                    case Key.Enter:                  case Key.Space:                  {                      return ProcessEnterKey();                  }              }
Missing Default,Microsoft.Windows.Controls,Calendar,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\Calendar.cs,ProcessDownKey,The following switch statement is missing a default case: switch (this.DisplayMode)              {                  case CalendarMode.Month:                  {                      if (!ctrl || shift)                      {                          DateTime? selectedDate = this._blackoutDates.GetNonBlackoutDate(DateTimeHelper.AddDays(this.CurrentDate' COLS)' 1);                          ProcessSelection(shift' selectedDate);                      }                        break;                  }                    case CalendarMode.Year:                  {                      if (ctrl)                      {                          this.DisplayMode = CalendarMode.Month;                          FocusDate(this.DisplayDate);                      }                      else                      {                          DateTime? selectedMonth = DateTimeHelper.AddMonths(this.DisplayDate' YEAR_COLS);                          OnSelectedMonthChanged(selectedMonth);                      }                        break;                  }                    case CalendarMode.Decade:                  {                      if (ctrl)                      {                                                  this.DisplayMode = CalendarMode.Year;                          FocusDate(this.DisplayDate);                      }                      else                      {                          DateTime? selectedYear = DateTimeHelper.AddYears(this.DisplayDate' YEAR_COLS);                          OnSelectedYearChanged(selectedYear);                      }                        break;                  }              }
Missing Default,Microsoft.Windows.Controls,Calendar,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\Calendar.cs,ProcessEndKey,The following switch statement is missing a default case: switch (this.DisplayMode)              {                  case CalendarMode.Month:                  {                      if (this.DisplayDate != null)                      {                          DateTime? selectedDate = new DateTime(this.DisplayDateInternal.Year' this.DisplayDateInternal.Month' 1);                            if (DateTimeHelper.CompareYearMonth(DateTime.MaxValue' selectedDate.Value) > 0)                          {                              // since DisplayDate is not equal to DateTime.MaxValue we are sure selectedDate is not null                              selectedDate = DateTimeHelper.AddMonths(selectedDate.Value' 1).Value;                              selectedDate = DateTimeHelper.AddDays(selectedDate.Value' -1).Value;                          }                          else                          {                              selectedDate = DateTime.MaxValue;                          }                            ProcessSelection(shift' selectedDate);                      }                        break;                  }                    case CalendarMode.Year:                  {                      DateTime selectedMonth = new DateTime(this.DisplayDate.Year' 12' 1);                      OnSelectedMonthChanged(selectedMonth);                      break;                  }                    case CalendarMode.Decade:                  {                      DateTime? selectedYear = new DateTime(DateTimeHelper.EndOfDecade(this.DisplayDate)' 1' 1);                      OnSelectedYearChanged(selectedYear);                      break;                  }              }
Missing Default,Microsoft.Windows.Controls,Calendar,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\Calendar.cs,ProcessEnterKey,The following switch statement is missing a default case: switch (this.DisplayMode)              {                  case CalendarMode.Year:                  {                      this.DisplayMode = CalendarMode.Month;                      FocusDate(this.DisplayDate);                      return true;                  }                    case CalendarMode.Decade:                  {                      this.DisplayMode = CalendarMode.Year;                      FocusDate(this.DisplayDate);                      return true;                  }              }
Missing Default,Microsoft.Windows.Controls,Calendar,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\Calendar.cs,ProcessHomeKey,The following switch statement is missing a default case: switch (this.DisplayMode)              {                  case CalendarMode.Month:                  {                      // TODO: Not all types of calendars start with Day1. If Non-Gregorian is supported check this:                      DateTime? selectedDate = new DateTime(this.DisplayDateInternal.Year' this.DisplayDateInternal.Month' 1);                      ProcessSelection(shift' selectedDate);                      break;                  }                    case CalendarMode.Year:                  {                      DateTime selectedMonth = new DateTime(this.DisplayDate.Year' 1' 1);                      OnSelectedMonthChanged(selectedMonth);                      break;                  }                    case CalendarMode.Decade:                  {                      DateTime? selectedYear = new DateTime(DateTimeHelper.DecadeOfDate(this.DisplayDate)' 1' 1);                      OnSelectedYearChanged(selectedYear);                      break;                  }              }
Missing Default,Microsoft.Windows.Controls,Calendar,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\Calendar.cs,ProcessLeftKey,The following switch statement is missing a default case: switch (this.DisplayMode)              {                  case CalendarMode.Month:                  {                      DateTime? selectedDate = this._blackoutDates.GetNonBlackoutDate(DateTimeHelper.AddDays(this.CurrentDate' moveAmmount)' moveAmmount);                      ProcessSelection(shift' selectedDate);                      break;                  }                    case CalendarMode.Year:                  {                      DateTime? selectedMonth = DateTimeHelper.AddMonths(this.DisplayDate' moveAmmount);                      OnSelectedMonthChanged(selectedMonth);                      break;                  }                    case CalendarMode.Decade:                  {                      DateTime? selectedYear = DateTimeHelper.AddYears(this.DisplayDate' moveAmmount);                      OnSelectedYearChanged(selectedYear);                      break;                  }              }
Missing Default,Microsoft.Windows.Controls,Calendar,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\Calendar.cs,ProcessPageDownKey,The following switch statement is missing a default case: switch (this.DisplayMode)              {                  case CalendarMode.Month:                  {                      DateTime? selectedDate = this._blackoutDates.GetNonBlackoutDate(DateTimeHelper.AddMonths(this.CurrentDate' 1)' 1);                      ProcessSelection(shift' selectedDate);                      break;                  }                    case CalendarMode.Year:                  {                      DateTime? selectedMonth = DateTimeHelper.AddYears(this.DisplayDate' 1);                      OnSelectedMonthChanged(selectedMonth);                      break;                  }                    case CalendarMode.Decade:                  {                      DateTime? selectedYear = DateTimeHelper.AddYears(this.DisplayDate' 10);                      OnSelectedYearChanged(selectedYear);                      break;                  }              }
Missing Default,Microsoft.Windows.Controls,Calendar,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\Calendar.cs,ProcessPageUpKey,The following switch statement is missing a default case: switch (this.DisplayMode)              {                  case CalendarMode.Month:                  {                      DateTime? selectedDate = this._blackoutDates.GetNonBlackoutDate(DateTimeHelper.AddMonths(this.CurrentDate' -1)' -1);                      ProcessSelection(shift' selectedDate);                      break;                  }                    case CalendarMode.Year:                  {                      DateTime? selectedMonth = DateTimeHelper.AddYears(this.DisplayDate' -1);                      OnSelectedMonthChanged(selectedMonth);                      break;                  }                    case CalendarMode.Decade:                  {                      DateTime? selectedYear = DateTimeHelper.AddYears(this.DisplayDate' -10);                      OnSelectedYearChanged(selectedYear);                      break;                  }              }
Missing Default,Microsoft.Windows.Controls,Calendar,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\Calendar.cs,ProcessRightKey,The following switch statement is missing a default case: switch (this.DisplayMode)              {                  case CalendarMode.Month:                  {                      DateTime? selectedDate = this._blackoutDates.GetNonBlackoutDate(DateTimeHelper.AddDays(this.CurrentDate' moveAmmount)' moveAmmount);                      ProcessSelection(shift' selectedDate);                      break;                  }                    case CalendarMode.Year:                  {                      DateTime? selectedMonth = DateTimeHelper.AddMonths(this.DisplayDate' moveAmmount);                      OnSelectedMonthChanged(selectedMonth);                      break;                  }                    case CalendarMode.Decade:                  {                      DateTime? selectedYear = DateTimeHelper.AddYears(this.DisplayDate' moveAmmount);                      OnSelectedYearChanged(selectedYear);                      break;                  }              }
Missing Default,Microsoft.Windows.Controls,Calendar,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\Calendar.cs,ProcessUpKey,The following switch statement is missing a default case: switch (this.DisplayMode)              {                  case CalendarMode.Month:                  {                      if (ctrl)                      {                          this.DisplayMode = CalendarMode.Year;                          FocusDate(this.DisplayDate);                      }                      else                      {                          DateTime? selectedDate = this._blackoutDates.GetNonBlackoutDate(DateTimeHelper.AddDays(this.CurrentDate' -COLS)' -1);                          ProcessSelection(shift' selectedDate);                      }                        break;                  }                    case CalendarMode.Year:                  {                      if (ctrl)                      {                          this.DisplayMode = CalendarMode.Decade;                          FocusDate(this.DisplayDate);                      }                      else                      {                          DateTime? selectedMonth = DateTimeHelper.AddMonths(this.DisplayDate' -YEAR_COLS);                          OnSelectedMonthChanged(selectedMonth);                      }                        break;                  }                    case CalendarMode.Decade:                  {                      if (!ctrl)                      {                          DateTime? selectedYear = DateTimeHelper.AddYears(this.DisplayDate' -YEAR_COLS);                          OnSelectedYearChanged(selectedYear);                      }                        break;                  }              }
Missing Default,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnColumnsChanged,The following switch statement is missing a default case: switch (e.Action)              {                  case NotifyCollectionChangedAction.Add:                      UpdateDataGridReference(e.NewItems' /* clear = */ false);                      UpdateColumnSizeConstraints(e.NewItems);                      break;                    case NotifyCollectionChangedAction.Remove:                      UpdateDataGridReference(e.OldItems' /* clear = */ true);                      break;                    case NotifyCollectionChangedAction.Replace:                      UpdateDataGridReference(e.OldItems' /* clear = */ true);                      UpdateDataGridReference(e.NewItems' /* clear = */ false);                      UpdateColumnSizeConstraints(e.NewItems);                      break;                    case NotifyCollectionChangedAction.Reset:                      // We can't clear column references on Reset: _columns has 0 items and e.OldItems is empty.                      _selectedCells.Clear();                      break;              }
Missing Default,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnRowValidationRulesChanged,The following switch statement is missing a default case: switch (e.Action)                      {                          case NotifyCollectionChangedAction.Add:                              foreach (ValidationRule rule in e.NewItems)                              {                                  _rowValidationBindingGroup.ValidationRules.Add(rule);                              }                                break;                            case NotifyCollectionChangedAction.Remove:                              foreach (ValidationRule rule in e.OldItems)                              {                                  _rowValidationBindingGroup.ValidationRules.Remove(rule);                              }                                break;                            case NotifyCollectionChangedAction.Replace:                              foreach (ValidationRule rule in e.OldItems)                              {                                  _rowValidationBindingGroup.ValidationRules.Remove(rule);                              }                                foreach (ValidationRule rule in e.NewItems)                              {                                  _rowValidationBindingGroup.ValidationRules.Add(rule);                              }                                break;                            case NotifyCollectionChangedAction.Reset:                              _rowValidationBindingGroup.ValidationRules.Clear();                              break;                      }
Missing Default,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnKeyDown,The following switch statement is missing a default case: switch (e.Key)              {                  case Key.Tab:                      OnTabKeyDown(e);                      break;                    case Key.Enter:                      OnEnterKeyDown(e);                      break;                    case Key.Left:                  case Key.Right:                  case Key.Up:                  case Key.Down:                      OnArrowKeyDown(e);                      break;                    case Key.Home:                  case Key.End:                      OnHomeOrEndKeyDown(e);                      break;                    case Key.PageUp:                  case Key.PageDown:                      OnPageUpOrDownKeyDown(e);                      break;              }
Missing Default,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnItemsSortDescriptionsChanged,The following switch statement is missing a default case: switch (e.Action)              {                  case NotifyCollectionChangedAction.Add:                      Debug.Assert(e.NewItems.Count == 1' "SortDescriptionCollection should handle one element at a time");                      for (int i = 0' count = GroupingSortDescriptionIndices.Count; i < count; i++)                      {                          if (GroupingSortDescriptionIndices[i] >= e.NewStartingIndex)                          {                              GroupingSortDescriptionIndices[i]++;                          }                      }                        break;                  case NotifyCollectionChangedAction.Remove:                      Debug.Assert(e.OldItems.Count == 1' "SortDescriptionCollection should handle one element at a time");                      for (int i = 0' count = GroupingSortDescriptionIndices.Count; i < count; i++)                      {                          if (GroupingSortDescriptionIndices[i] > e.OldStartingIndex)                          {                              GroupingSortDescriptionIndices[i]--;                          }                          else if (GroupingSortDescriptionIndices[i] == e.OldStartingIndex)                          {                              GroupingSortDescriptionIndices.RemoveAt(i);                              i--;                              count--;                          }                      }                        break;                  case NotifyCollectionChangedAction.Move:                      // SortDescriptionCollection doesnt support move' atleast as an atomic operation. Hence Do nothing.                      break;                  case NotifyCollectionChangedAction.Replace:                      Debug.Assert(e.OldItems.Count == 1 && e.NewItems.Count == 1' "SortDescriptionCollection should handle one element at a time");                      GroupingSortDescriptionIndices.Remove(e.OldStartingIndex);                      break;                  case NotifyCollectionChangedAction.Reset:                      GroupingSortDescriptionIndices.Clear();                      break;              }
Missing Default,Microsoft.Windows.Controls,DataGrid,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGrid.cs,OnItemsGroupDescriptionsChanged,The following switch statement is missing a default case: switch (e.Action)              {                  case NotifyCollectionChangedAction.Add:                      Debug.Assert(e.NewItems.Count == 1' "GroupDescriptionCollection should handle one element at a time");                      if (CanConvertToSortDescription(e.NewItems[0] as PropertyGroupDescription))                      {                          RegenerateGroupingSortDescriptions();                      }                        break;                  case NotifyCollectionChangedAction.Remove:                      Debug.Assert(e.OldItems.Count == 1' "GroupDescriptionCollection should handle one element at a time");                      if (CanConvertToSortDescription(e.OldItems[0] as PropertyGroupDescription))                      {                          RegenerateGroupingSortDescriptions();                      }                        break;                  case NotifyCollectionChangedAction.Move:                      // Do Nothing                      break;                  case NotifyCollectionChangedAction.Replace:                      Debug.Assert(e.OldItems.Count == 1 && e.NewItems.Count == 1' "GroupDescriptionCollection should handle one element at a time");                      if (CanConvertToSortDescription(e.OldItems[0] as PropertyGroupDescription) ||                           CanConvertToSortDescription(e.NewItems[0] as PropertyGroupDescription))                      {                          RegenerateGroupingSortDescriptions();                      }                        break;                  case NotifyCollectionChangedAction.Reset:                      RemoveGroupingSortDescriptions();                      break;              }
Missing Default,Microsoft.Windows.Controls,DataGridCellsPanel,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridCellsPanel.cs,OnItemsChanged,The following switch statement is missing a default case: switch (args.Action)              {                  case NotifyCollectionChangedAction.Remove:                      OnItemsRemove(args);                      break;                    case NotifyCollectionChangedAction.Replace:                      OnItemsReplace(args);                      break;                    case NotifyCollectionChangedAction.Move:                      OnItemsMove(args);                      break;                    case NotifyCollectionChangedAction.Reset:                      break;              }
Missing Default,Microsoft.Windows.Controls,DataGridColumnCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridColumnCollection.cs,OnCollectionChanged,The following switch statement is missing a default case: switch (e.Action)              {                  case NotifyCollectionChangedAction.Add:                      if (DisplayIndexMapInitialized)                      {                          UpdateDisplayIndexForNewColumns(e.NewItems' e.NewStartingIndex);                      }                        InvalidateHasVisibleStarColumns();                      break;                    case NotifyCollectionChangedAction.Move:                      if (DisplayIndexMapInitialized)                      {                          UpdateDisplayIndexForMovedColumn(e.OldStartingIndex' e.NewStartingIndex);                      }                        break;                    case NotifyCollectionChangedAction.Remove:                      if (DisplayIndexMapInitialized)                      {                          UpdateDisplayIndexForRemovedColumns(e.OldItems' e.OldStartingIndex);                      }                        ClearDisplayIndex(e.OldItems' e.NewItems);                      InvalidateHasVisibleStarColumns();                      break;                    case NotifyCollectionChangedAction.Replace:                      if (DisplayIndexMapInitialized)                      {                          UpdateDisplayIndexForReplacedColumn(e.OldItems' e.NewItems);                      }                        ClearDisplayIndex(e.OldItems' e.NewItems);                      InvalidateHasVisibleStarColumns();                      break;                    case NotifyCollectionChangedAction.Reset:                      // We dont ClearDisplayIndex here because we no longer have access to the old items.                      // Instead this is handled in ClearItems.                      if (DisplayIndexMapInitialized)                      {                          DisplayIndexMap.Clear();                          DataGridOwner.UpdateColumnsOnVirtualizedCellInfoCollections(NotifyCollectionChangedAction.Reset' -1' null' -1);                      }                        HasVisibleStarColumns = false;                      break;              }
Missing Default,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,OnRender,The following switch statement is missing a default case: switch (Theme)                  {                      case ClassicThemeName:                          RenderClassic(dc);                          break;                        case LunaNormalColorName:                          RenderLuna(dc' Luna.NormalColor);                          break;                        case LunaHomeSteadName:                          RenderLuna(dc' Luna.HomeStead);                          break;                        case LunaMetallicName:                          RenderLuna(dc' Luna.Metallic);                          break;                        case RoyaleNormalColorName:                          RenderLuna(dc' Luna.Metallic);                          break;                        case AeroNormalColorName:                          RenderAeroNormalColor(dc);                          break;                  }
Missing Default,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following switch statement is missing a default case: switch (backgroundType)                  {                      case AeroFreezables.NormalBackground:                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFF' 0xFF' 0xFF)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xFF' 0xFF' 0xFF)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF7' 0xF8' 0xFA)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF1' 0xF2' 0xF4)' 1.0));                          break;                        case AeroFreezables.PressedBackground:                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBC' 0xE4' 0xF9)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBC' 0xE4' 0xF9)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x8D' 0xD6' 0xF7)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x8A' 0xD1' 0xF5)' 1.0));                          break;                        case AeroFreezables.HoveredBackground:                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0xF7' 0xFF)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE3' 0xF7' 0xFF)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xBD' 0xED' 0xFF)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xB7' 0xE7' 0xFB)' 1.0));                          break;                        case AeroFreezables.SortedBackground:                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF2' 0xF9' 0xFC)' 0.0));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF2' 0xF9' 0xFC)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE1' 0xF1' 0xF9)' 0.4));                          background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xD8' 0xEC' 0xF6)' 1.0));                          break;                  }
Missing Default,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following switch statement is missing a default case: switch (sideType)                              {                                  case AeroFreezables.NormalSides:                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xF2' 0xF2' 0xF2)' 0.0));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xEF' 0xEF' 0xEF)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xE7' 0xE8' 0xEA)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0xDE' 0xDF' 0xE1)' 1.0));                                      break;                                    case AeroFreezables.PressedSides:                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x7A' 0x9E' 0xB1)' 0.0));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x7A' 0x9E' 0xB1)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x50' 0x91' 0xAF)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x4D' 0x8D' 0xAD)' 1.0));                                      break;                                    case AeroFreezables.HoveredSides:                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x88' 0xCB' 0xEB)' 0.0));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x88' 0xCB' 0xEB)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x69' 0xBB' 0xE3)' 0.4));                                      lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF' 0x69' 0xBB' 0xE3)' 1.0));                                      break;                                    case AeroFreezables.SortedSides:                                      sideBrush = new SolidColorBrush(Color.FromArgb(0xFF' 0x96' 0xD9' 0xF9));                                      break;                              }
Missing Default,Microsoft.Windows.Controls,DataGridHeaderBorder,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeaderBorder.cs,RenderAeroNormalColor,The following switch statement is missing a default case: switch (bottomType)                      {                          case AeroFreezables.NormalBottom:                              bottomBrush = new SolidColorBrush(Color.FromArgb(0xFF' 0xD5' 0xD5' 0xD5));                              break;                            case AeroFreezables.PressedOrHoveredBottom:                              bottomBrush = new SolidColorBrush(Color.FromArgb(0xFF' 0x93' 0xC9' 0xE3));                              break;                            case AeroFreezables.SortedBottom:                              bottomBrush = new SolidColorBrush(Color.FromArgb(0xFF' 0x96' 0xD9' 0xF9));                              break;                      }
Missing Default,Microsoft.Windows.Controls,DataGridHeadersVisibilityToVisibilityConverter,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHeadersVisibilityToVisibilityConverter.cs,Convert,The following switch statement is missing a default case: switch (valueAsDataGridHeadersVisibility)                  {                      case DataGridHeadersVisibility.All:                          visible = true;                          break;                      case DataGridHeadersVisibility.Column:                          visible = parameterAsDataGridHeadersVisibility == DataGridHeadersVisibility.Column ||                                       parameterAsDataGridHeadersVisibility == DataGridHeadersVisibility.None;                          break;                      case DataGridHeadersVisibility.Row:                          visible = parameterAsDataGridHeadersVisibility == DataGridHeadersVisibility.Row ||                                       parameterAsDataGridHeadersVisibility == DataGridHeadersVisibility.None;                          break;                  }
Missing Default,Microsoft.Windows.Controls,DataGridHelper,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridHelper.cs,IsGridLineVisible,The following switch statement is missing a default case: switch (visibility)                  {                      case DataGridGridLinesVisibility.All:                          return true;                      case DataGridGridLinesVisibility.Horizontal:                          return isHorizontal;                      case DataGridGridLinesVisibility.None:                          return false;                      case DataGridGridLinesVisibility.Vertical:                          return !isHorizontal;                  }
Missing Default,Microsoft.Windows.Controls,DataGridRow,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridRow.cs,OnCoerceBackground,The following switch statement is missing a default case: switch (row.AlternationIndex)              {                  case 0:                      coercedValue = DataGridHelper.GetCoercedTransferPropertyValue(                          row'                           baseValue'                           BackgroundProperty'                          row.DataGridOwner'                           DataGrid.RowBackgroundProperty);                        break;                  case 1:                      coercedValue = DataGridHelper.GetCoercedTransferPropertyValue(                          row'                           baseValue'                           BackgroundProperty'                          row.DataGridOwner'                           DataGrid.AlternatingRowBackgroundProperty);                        break;              }
Missing Default,Microsoft.Windows.Controls,DataGridTextColumn,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\DataGridTextColumn.cs,RefreshCellContent,The following switch statement is missing a default case: switch (propertyName)                      {                          case "FontFamily":                              DataGridHelper.SyncColumnProperty(this' textElement' TextElement.FontFamilyProperty' FontFamilyProperty);                              break;                          case "FontSize":                              DataGridHelper.SyncColumnProperty(this' textElement' TextElement.FontSizeProperty' FontSizeProperty);                              break;                          case "FontStyle":                              DataGridHelper.SyncColumnProperty(this' textElement' TextElement.FontStyleProperty' FontStyleProperty);                              break;                          case "FontWeight":                              DataGridHelper.SyncColumnProperty(this' textElement' TextElement.FontWeightProperty' FontWeightProperty);                              break;                          case "Foreground":                              DataGridHelper.SyncColumnProperty(this' textElement' TextElement.ForegroundProperty' ForegroundProperty);                              break;                      }
Missing Default,Microsoft.Windows.Controls,MultipleCopiesCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\MultipleCopiesCollection.cs,MirrorCollectionChange,The following switch statement is missing a default case: switch (e.Action)              {                  case NotifyCollectionChangedAction.Add:                      Debug.Assert(                          e.NewItems.Count == 1'                           "We're mirroring the Columns collection which is an ObservableCollection and only supports adding one item at a time");                      Insert(e.NewStartingIndex);                      break;                    case NotifyCollectionChangedAction.Move:                      Debug.Assert(                          e.NewItems.Count == 1'                          "We're mirroring the Columns collection which is an ObservableCollection and only supports moving one item at a time");                      Move(e.OldStartingIndex' e.NewStartingIndex);                      break;                    case NotifyCollectionChangedAction.Remove:                      Debug.Assert(                          e.OldItems.Count == 1'                          "We're mirroring the Columns collection which is an ObservableCollection and only supports removing one item at a time");                      RemoveAt(e.OldStartingIndex);                      break;                    case NotifyCollectionChangedAction.Replace:                      Debug.Assert(                          e.NewItems.Count == 1'                          "We're mirroring the Columns collection which is an ObservableCollection and only supports replacing one item at a time");                      OnReplace(CopiedItem' CopiedItem' e.NewStartingIndex);                      break;                    case NotifyCollectionChangedAction.Reset:                      Reset();                      break;              }
Missing Default,Microsoft.Windows.Controls,VirtualizedCellInfoCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\VirtualizedCellInfoCollection.cs,OnItemsCollectionChanged,The following switch statement is missing a default case: switch (e.Action)                  {                      case NotifyCollectionChangedAction.Add:                          OnAddRow(e.NewStartingIndex);                          break;                        case NotifyCollectionChangedAction.Remove:                          OnRemoveRow(e.OldStartingIndex' e.OldItems[0]);                          break;                        case NotifyCollectionChangedAction.Replace:                          OnReplaceRow(e.OldStartingIndex' e.OldItems[0]);                          break;                        case NotifyCollectionChangedAction.Move:                          OnMoveRow(e.OldStartingIndex' e.NewStartingIndex);                          break;                        case NotifyCollectionChangedAction.Reset:                          RestoreOnlyFullRows(selectedRows);                          break;                  }
Missing Default,Microsoft.Windows.Controls,VirtualizedCellInfoCollection,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DataGrid\Microsoft\Windows\Controls\VirtualizedCellInfoCollection.cs,OnColumnsChanged,The following switch statement is missing a default case: switch (action)                  {                      case NotifyCollectionChangedAction.Add:                          OnAddColumn(newDisplayIndex' selectedRows);                          break;                        case NotifyCollectionChangedAction.Remove:                          OnRemoveColumn(oldDisplayIndex' oldColumn);                          break;                        case NotifyCollectionChangedAction.Replace:                          OnReplaceColumn(oldDisplayIndex' oldColumn' selectedRows);                          break;                        case NotifyCollectionChangedAction.Move:                          OnMoveColumn(oldDisplayIndex' newDisplayIndex);                          break;                        case NotifyCollectionChangedAction.Reset:                          _regions.Clear();                          break;                  }
Missing Default,Microsoft.Windows.Controls,DatePicker,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DatePicker\Microsoft\Windows\Controls\DatePicker.cs,DateTimeToString,The following switch statement is missing a default case: switch (this.SelectedDateFormat)              {                  case DatePickerFormat.Short:                      {                          return string.Format(CultureInfo.CurrentCulture' d.ToString(dtfi.ShortDatePattern' dtfi));                      }                    case DatePickerFormat.Long:                      {                          return string.Format(CultureInfo.CurrentCulture' d.ToString(dtfi.LongDatePattern' dtfi));                      }              }
Missing Default,Microsoft.Windows.Controls,DatePicker,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DatePicker\Microsoft\Windows\Controls\DatePicker.cs,ProcessDatePickerKey,The following switch statement is missing a default case: switch (e.Key)              {                  case Key.System:                  {                      switch (e.SystemKey)                      {                          case Key.Down:                          {                              if ((Keyboard.Modifiers & ModifierKeys.Alt) == ModifierKeys.Alt)                              {                                  TogglePopUp();                                  return true;                              }                                break;                          }                      }                        break;                  }                    case Key.Enter:                  {                      SetSelectedDate();                      return true;                  }              }
Missing Default,Microsoft.Windows.Controls,DatePicker,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DatePicker\Microsoft\Windows\Controls\DatePicker.cs,ProcessDatePickerKey,The following switch statement is missing a default case: switch (e.SystemKey)                      {                          case Key.Down:                          {                              if ((Keyboard.Modifiers & ModifierKeys.Alt) == ModifierKeys.Alt)                              {                                  TogglePopUp();                                  return true;                              }                                break;                          }                      }
Missing Default,Microsoft.Windows.Controls,DatePicker,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\DatePicker\Microsoft\Windows\Controls\DatePicker.cs,SetWaterMarkText,The following switch statement is missing a default case: switch (this.SelectedDateFormat)                  {                      case DatePickerFormat.Long:                          {                              this._textBox.Watermark = string.Format(CultureInfo.CurrentCulture' SR.Get(SRID.DatePicker_WatermarkText)' dtfi.LongDatePattern.ToString());                              break;                          }                        case DatePickerFormat.Short:                          {                              this._textBox.Watermark = string.Format(CultureInfo.CurrentCulture' SR.Get(SRID.DatePicker_WatermarkText)' dtfi.ShortDatePattern.ToString());                              break;                          }                  }
Missing Default,Microsoft.Windows.Controls.Primitives,CalendarItem,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\CalendarItem.cs,Cell_Clicked,The following switch statement is missing a default case: switch (this.Owner.SelectionMode)                  {                      case CalendarSelectionMode.None:                      {                          break;                      }                        case CalendarSelectionMode.SingleDate:                      {                          if (!ctrl)                          {                              this.Owner.SelectedDate = clickedDate;                          }                          else                          {                              this.Owner.SelectedDates.Toggle(clickedDate);                          }                            break;                      }                        case CalendarSelectionMode.SingleRange:                          {                              DateTime? lastDate = this.Owner.CurrentDate;                              this.Owner.SelectedDates.ClearInternal(true /*fireChangeNotification*/);                              if (shift && lastDate.HasValue)                              {                                  this.Owner.SelectedDates.AddRangeInternal(lastDate.Value' clickedDate);                              }                              else                              {                                  this.Owner.SelectedDate = clickedDate;                                  this.Owner.HoverStart = null;                                  this.Owner.HoverEnd = null;                              }                                break;                          }                        case CalendarSelectionMode.MultipleRange:                          {                              if (!ctrl)                              {                                  this.Owner.SelectedDates.ClearInternal(true /*fireChangeNotification*/);                              }                                if (shift)                              {                                  this.Owner.SelectedDates.AddRangeInternal(this.Owner.CurrentDate' clickedDate);                              }                              else                              {                                  if (!ctrl)                                  {                                      this.Owner.SelectedDate = clickedDate;                                  }                                  else                                  {                                      this.Owner.SelectedDates.Toggle(clickedDate);                                      this.Owner.HoverStart = null;                                      this.Owner.HoverEnd = null;                                  }                              }                                break;                          }                  }
Missing Default,Microsoft.Windows.Controls.Primitives,CalendarItem,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\CalendarItem.cs,Cell_MouseLeftButtonDown,The following switch statement is missing a default case: switch (this.Owner.SelectionMode)                  {                      case CalendarSelectionMode.None:                      {                          break;                      }                        case CalendarSelectionMode.SingleDate:                      {                          this.Owner.DatePickerDisplayDateFlag = true;                          if (!ctrl)                          {                              this.Owner.SelectedDate = selectedDate;                          }                          else                          {                              this.Owner.SelectedDates.Toggle(selectedDate);                          }                            break;                      }                        case CalendarSelectionMode.SingleRange:                      {                          this.Owner.SelectedDates.ClearInternal();                            if (shift)                          {                              if (!this.Owner.HoverStart.HasValue)                              {                                  this.Owner.HoverStart = this.Owner.HoverEnd = this.Owner.CurrentDate;                              }                          }                          else                          {                              this.Owner.HoverStart = this.Owner.HoverEnd = selectedDate;                          }                            break;                      }                        case CalendarSelectionMode.MultipleRange:                      {                          if (!ctrl)                          {                              this.Owner.SelectedDates.ClearInternal();                          }                            if (shift)                          {                              if (!this.Owner.HoverStart.HasValue)                              {                                  this.Owner.HoverStart = this.Owner.HoverEnd = this.Owner.CurrentDate;                              }                          }                          else                          {                              this.Owner.HoverStart = this.Owner.HoverEnd = selectedDate;                          }                            break;                      }                  }
Missing Default,Microsoft.Windows.Controls.Primitives,CalendarItem,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\CalendarItem.cs,Cell_MouseEnter,The following switch statement is missing a default case: switch (this.Owner.SelectionMode)                  {                      case CalendarSelectionMode.SingleDate:                      {                          this.Owner.DatePickerDisplayDateFlag = true;                          this.Owner.HoverStart = this.Owner.HoverEnd = null;                          if (this.Owner.SelectedDates.Count == 0)                          {                              this.Owner.SelectedDates.Add(selectedDate);                          }                          else                          {                              this.Owner.SelectedDates[0] = selectedDate;                          }                            return;                      }                  }
Missing Default,Microsoft.Windows.Controls.Primitives,CalendarItem,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Calendar\Microsoft\Windows\Controls\CalendarItem.cs,FinishSelection,The following switch statement is missing a default case: switch (this.Owner.SelectionMode)                  {                      case CalendarSelectionMode.SingleRange:                      {                          // Update SelectedDates                          this.Owner.SelectedDates.ClearInternal();                          EndDrag(ctrl' selectedDate);                          break;                      }                        case CalendarSelectionMode.MultipleRange:                      {                          // add the selection (either single day or SingleRange day)                          EndDrag(ctrl' selectedDate);                          break;                      }                  }
