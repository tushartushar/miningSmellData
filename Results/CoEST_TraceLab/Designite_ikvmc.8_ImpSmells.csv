Implementation smell,Namespace,Class,File,Method,Description
Long Method,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,PublishProperties,The method has 119 lines of code.
Long Method,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,EmitMapXmlMetadata,The method has 191 lines of code.
Long Method,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,FinishGhost,The method has 262 lines of code.
Long Method,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,GetTypeWrapperCompilerHook,The method has 135 lines of code.
Long Method,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,Compile,The method has 102 lines of code.
Long Method,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,CreateCompiler,The method has 250 lines of code.
Long Method,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,CompilePass3,The method has 137 lines of code.
Long Method,IKVM.Internal,RemappedMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,DoLink,The method has 233 lines of code.
Long Method,IKVM.Internal,RemappedMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,Finish,The method has 235 lines of code.
Long Method,IKVM.Internal,StaticCompiler,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,IssueMessage,The method has 218 lines of code.
Long Method,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ClassFile,The method has 379 lines of code.
Long Method,IKVM.Internal,Field,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Field,The method has 123 lines of code.
Long Method,IKVM.Internal,Method,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Method,The method has 213 lines of code.
Long Method,IKVM.Internal,Code,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Read,The method has 203 lines of code.
Long Method,IKVM.Internal,Instruction,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Read,The method has 119 lines of code.
Long Method,IKVM.Internal,ClassLoaderWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassLoaderWrapper.cs,LoadGenericClass,The method has 159 lines of code.
Long Method,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizePatterns,The method has 182 lines of code.
Long Method,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,RemoveDeadCode,The method has 200 lines of code.
Long Method,IKVM.Internal,DotNetTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,LazyPublishMembers,The method has 238 lines of code.
Long Method,IKVM.Internal,DynamicTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,VerifyDelegate,The method has 104 lines of code.
Long Method,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,CreateStep1,The method has 108 lines of code.
Long Method,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,CreateStep2,The method has 347 lines of code.
Long Method,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,LinkField,The method has 147 lines of code.
Long Method,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FinishCore,The method has 108 lines of code.
Long Method,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FindBaseMethods7,The method has 164 lines of code.
Long Method,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,LinkMethod,The method has 126 lines of code.
Long Method,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GenerateMethod,The method has 255 lines of code.
Long Method,IKVM.Internal,AnnotationBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Link,The method has 130 lines of code.
Long Method,IKVM.Internal,AnnotationBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Finish,The method has 195 lines of code.
Long Method,IKVM.Internal,Metadata,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Create,The method has 115 lines of code.
Long Method,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FinishImpl,The method has 584 lines of code.
Long Method,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,ImplementInterfaceMethodStubImpl,The method has 130 lines of code.
Long Method,IKVM.Internal,JniBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Generate,The method has 172 lines of code.
Long Method,IKVM.Internal,JsrMethodAnalyzer,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\JsrInliner.cs,JsrMethodAnalyzer,The method has 940 lines of code.
Long Method,IKVM.Internal.MapXml,Call,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\remapper.cs,Generate,The method has 112 lines of code.
Complex Method,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,GetBaseTypeForDefineType,Cyclomatic complexity of the method is 10
Complex Method,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,AddMapXmlFields,Cyclomatic complexity of the method is 8
Complex Method,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,PublishProperties,Cyclomatic complexity of the method is 21
Complex Method,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,IsPInvokeMethod,Cyclomatic complexity of the method is 8
Complex Method,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,MapModifiers,Cyclomatic complexity of the method is 11
Complex Method,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,EmitMapXmlMetadata,Cyclomatic complexity of the method is 44
Complex Method,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,FinishGhost,Cyclomatic complexity of the method is 12
Complex Method,IKVM.Internal,AssemblyResolver,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AssemblyResolver.cs,universe_AssemblyResolve,Cyclomatic complexity of the method is 13
Complex Method,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,CreateModuleBuilder,Cyclomatic complexity of the method is 8
Complex Method,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,LoadClassImpl,Cyclomatic complexity of the method is 10
Complex Method,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,GetTypeWrapperCompilerHook,Cyclomatic complexity of the method is 19
Complex Method,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,WriteExportMap,Cyclomatic complexity of the method is 13
Complex Method,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,AddResources,Cyclomatic complexity of the method is 11
Complex Method,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,LoadMappedExceptions,Cyclomatic complexity of the method is 10
Complex Method,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,GetXmlMapParameters,Cyclomatic complexity of the method is 9
Complex Method,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,Compile,Cyclomatic complexity of the method is 20
Complex Method,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,CreateCompiler,Cyclomatic complexity of the method is 41
Complex Method,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,CompilePass1,Cyclomatic complexity of the method is 10
Complex Method,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,CompilePass3,Cyclomatic complexity of the method is 25
Complex Method,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,ValidateAndSetMap,Cyclomatic complexity of the method is 12
Complex Method,IKVM.Internal,RemapperTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,RemapperTypeWrapper,Cyclomatic complexity of the method is 19
Complex Method,IKVM.Internal,RemapperTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,Process2ndPassStep2,Cyclomatic complexity of the method is 10
Complex Method,IKVM.Internal,RemapperTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,Process4thPass,Cyclomatic complexity of the method is 18
Complex Method,IKVM.Internal,RemappedConstructorWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,Finish,Cyclomatic complexity of the method is 14
Complex Method,IKVM.Internal,RemappedMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,DoLink,Cyclomatic complexity of the method is 39
Complex Method,IKVM.Internal,RemappedMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,Finish,Cyclomatic complexity of the method is 38
Complex Method,IKVM.Internal,StaticCompiler,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,IssueMessage,Cyclomatic complexity of the method is 58
Complex Method,IKVM.Internal,ProxyGenerator,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\Proxy.cs,CheckAndCollect,Cyclomatic complexity of the method is 8
Complex Method,IKVM.Internal,ProxyGenerator,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\Proxy.cs,CreateMethod,Cyclomatic complexity of the method is 12
Complex Method,IKVM.Internal,Boxer,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\Proxy.cs,EmitUnbox,Cyclomatic complexity of the method is 9
Complex Method,IKVM.Internal,Boxer,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\Proxy.cs,EmitBox,Cyclomatic complexity of the method is 9
Complex Method,IKVM.Internal,AssemblyClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\AssemblyClassLoader.cs,DoInitializeExports,Cyclomatic complexity of the method is 9
Complex Method,IKVM.Internal,AssemblyLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\AssemblyClassLoader.cs,AssemblyLoader,Cyclomatic complexity of the method is 9
Complex Method,IKVM.Internal,AssemblyLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\AssemblyClassLoader.cs,DoLoad,Cyclomatic complexity of the method is 16
Complex Method,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,GetClassName,Cyclomatic complexity of the method is 10
Complex Method,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ClassFile,Cyclomatic complexity of the method is 75
Complex Method,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ReadAnnotationElementValue,Cyclomatic complexity of the method is 15
Complex Method,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,IsValidMethodSig,Cyclomatic complexity of the method is 12
Complex Method,IKVM.Internal,Field,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Field,Cyclomatic complexity of the method is 26
Complex Method,IKVM.Internal,Method,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Method,Cyclomatic complexity of the method is 45
Complex Method,IKVM.Internal,Code,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Read,Cyclomatic complexity of the method is 26
Complex Method,IKVM.Internal,Instruction,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Read,Cyclomatic complexity of the method is 22
Complex Method,IKVM.Internal,ClassLoaderWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassLoaderWrapper.cs,LoadArrayClass,Cyclomatic complexity of the method is 15
Complex Method,IKVM.Internal,ClassLoaderWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassLoaderWrapper.cs,LoadGenericClass,Cyclomatic complexity of the method is 31
Complex Method,IKVM.Internal,ClassLoaderWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassLoaderWrapper.cs,SigDecoderWrapper,Cyclomatic complexity of the method is 15
Complex Method,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,RealEmitPseudoOpCode,Cyclomatic complexity of the method is 15
Complex Method,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,RealEmitOpCode,Cyclomatic complexity of the method is 19
Complex Method,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,IsSideEffectFreePush,Cyclomatic complexity of the method is 11
Complex Method,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizeBranchSizes,Cyclomatic complexity of the method is 20
Complex Method,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizePatterns,Cyclomatic complexity of the method is 24
Complex Method,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,PatchCompare,Cyclomatic complexity of the method is 8
Complex Method,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizeLdcI4,Cyclomatic complexity of the method is 12
Complex Method,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizeLdcI8,Cyclomatic complexity of the method is 15
Complex Method,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,UpdateLabelRefCounts,Cyclomatic complexity of the method is 8
Complex Method,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,RemoveDeadCode,Cyclomatic complexity of the method is 35
Complex Method,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,DeduplicateBranchSourceTargetCode,Cyclomatic complexity of the method is 11
Complex Method,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,MergeExceptionBlocks,Cyclomatic complexity of the method is 15
Complex Method,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,DumpMethod,Cyclomatic complexity of the method is 10
Complex Method,IKVM.Internal,DotNetTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,GetModifiers,Cyclomatic complexity of the method is 10
Complex Method,IKVM.Internal,DotNetTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,GetName,Cyclomatic complexity of the method is 9
Complex Method,IKVM.Internal,DotNetTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,LazyPublishMembers,Cyclomatic complexity of the method is 41
Complex Method,IKVM.Internal,DotNetTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,MakeMethodDescriptor,Cyclomatic complexity of the method is 9
Complex Method,IKVM.Internal,DotNetTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,CreateMethodWrapper,Cyclomatic complexity of the method is 9
Complex Method,IKVM.Internal,AttributeAnnotationTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,GetConstructors,Cyclomatic complexity of the method is 14
Complex Method,IKVM.Internal,AttributeAnnotationMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,MapType,Cyclomatic complexity of the method is 16
Complex Method,IKVM.Internal,AttributeAnnotation,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,Apply,Cyclomatic complexity of the method is 10
Complex Method,IKVM.Internal,DynamicClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicClassLoader.cs,FinishAll,Cyclomatic complexity of the method is 10
Complex Method,IKVM.Internal,DynamicTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,DynamicTypeWrapper,Cyclomatic complexity of the method is 11
Complex Method,IKVM.Internal,DynamicTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,VerifyDelegate,Cyclomatic complexity of the method is 23
Complex Method,IKVM.Internal,DynamicTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GetParameterNamesFromSig,Cyclomatic complexity of the method is 20
Complex Method,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,CreateStep1,Cyclomatic complexity of the method is 17
Complex Method,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,CreateStep2,Cyclomatic complexity of the method is 50
Complex Method,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,IsSideEffectFreeStaticInitializerOrNoop,Cyclomatic complexity of the method is 12
Complex Method,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,AddMirandaMethods,Cyclomatic complexity of the method is 8
Complex Method,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,CheckLoaderConstraints,Cyclomatic complexity of the method is 8
Complex Method,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,LinkField,Cyclomatic complexity of the method is 21
Complex Method,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FinishCore,Cyclomatic complexity of the method is 16
Complex Method,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FindBaseMethods7,Cyclomatic complexity of the method is 32
Complex Method,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FindBaseMethodsLegacy,Cyclomatic complexity of the method is 18
Complex Method,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GetBaseFinalizeMethod,Cyclomatic complexity of the method is 11
Complex Method,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GetPropertyAccess,Cyclomatic complexity of the method is 12
Complex Method,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,LinkMethod,Cyclomatic complexity of the method is 19
Complex Method,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GenerateMethod,Cyclomatic complexity of the method is 38
Complex Method,IKVM.Internal,DelegateInvokeStubMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,DoLink,Cyclomatic complexity of the method is 11
Complex Method,IKVM.Internal,AnnotationBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Link,Cyclomatic complexity of the method is 26
Complex Method,IKVM.Internal,AnnotationBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Finish,Cyclomatic complexity of the method is 30
Complex Method,IKVM.Internal,Metadata,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Create,Cyclomatic complexity of the method is 29
Complex Method,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FinishImpl,Cyclomatic complexity of the method is 89
Complex Method,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GenerateAccessStub,Cyclomatic complexity of the method is 9
Complex Method,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GenerateAccessStub,Cyclomatic complexity of the method is 10
Complex Method,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,ImplementInterfaceMethodStubImpl,Cyclomatic complexity of the method is 18
Complex Method,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,EmitCallerIDStub,Cyclomatic complexity of the method is 10
Complex Method,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,ImplementInterfaces,Cyclomatic complexity of the method is 9
Complex Method,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,AddUnsupportedAbstractMethods,Cyclomatic complexity of the method is 8
Complex Method,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,EmitConstantValueInitialization,Cyclomatic complexity of the method is 13
Complex Method,IKVM.Internal,JniBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Generate,Cyclomatic complexity of the method is 19
Complex Method,IKVM.Internal,SubroutineCall,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\JsrInliner.cs,InlineSubroutine,Cyclomatic complexity of the method is 8
Complex Method,IKVM.Internal,JsrMethodAnalyzer,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\JsrInliner.cs,JsrMethodAnalyzer,Cyclomatic complexity of the method is 160
Complex Method,IKVM.Internal,InstructionState,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\JsrInliner.cs,MergeSubroutineHelper,Cyclomatic complexity of the method is 10
Complex Method,IKVM.Internal,MethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\MemberWrapper.cs,GetMethodAttributes,Cyclomatic complexity of the method is 8
Complex Method,IKVM.Internal,ConstantFieldWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\MemberWrapper.cs,EmitGetImpl,Cyclomatic complexity of the method is 9
Complex Method,IKVM.Internal,Serialization,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\Serialization.cs,AddAutomagicSerialization,Cyclomatic complexity of the method is 11
Complex Method,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,ParseValue,Cyclomatic complexity of the method is 13
Complex Method,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,CreateCustomAttribute,Cyclomatic complexity of the method is 11
Complex Method,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,GetModifiers,Cyclomatic complexity of the method is 12
Complex Method,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,GetModifiers,Cyclomatic complexity of the method is 10
Complex Method,IKVM.Internal,EnumHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,OrBoxedIntegrals,Cyclomatic complexity of the method is 9
Complex Method,IKVM.Internal,Annotation,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,ConvertValue,Cyclomatic complexity of the method is 9
Complex Method,IKVM.Internal,Annotation,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,ValueQualifyClassNames,Cyclomatic complexity of the method is 12
Complex Method,IKVM.Internal,TypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,IsAssignableTo,Cyclomatic complexity of the method is 8
Complex Method,IKVM.Internal,CompiledTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,GetModifiers,Cyclomatic complexity of the method is 10
Complex Method,IKVM.Internal,CompiledTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,GetInterfaces,Cyclomatic complexity of the method is 8
Complex Method,IKVM.Internal,CompiledTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,SigTypePatchUp,Cyclomatic complexity of the method is 8
Complex Method,IKVM.Internal,CompiledTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,GetNameSigFromMethodBase,Cyclomatic complexity of the method is 10
Complex Method,IKVM.Internal,CompiledTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,AddMethodOrConstructor,Cyclomatic complexity of the method is 9
Complex Method,IKVM.Internal,CompiledTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,LazyPublishFields,Cyclomatic complexity of the method is 9
Complex Method,IKVM.Internal.MapXml,Call,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\remapper.cs,Generate,Cyclomatic complexity of the method is 19
Complex Method,IKVM.Internal.MapXml,Ldtoken,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\remapper.cs,Resolve,Cyclomatic complexity of the method is 9
Long Parameter List,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,AddXmlMapParameterAttributes,The method has 5 parameters. Parameters: method' className' methodName' methodSig' pbs
Long Parameter List,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,CompilerClassLoader,The method has 6 parameters. Parameters: referencedAssemblies' options' path' targetIsModule' assemblyName' classes
Long Parameter List,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,SetMain,The method has 5 parameters. Parameters: m' target' props' noglobbing' apartmentAttributeType
Long Parameter List,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,ValidateNameSig,The method has 6 parameters. Parameters: member' clazz' name' sig' valid' field
Long Parameter List,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,ValidatePropertyGetterSetter,The method has 5 parameters. Parameters: getterOrSetter' clazz' property' method' valid
Long Parameter List,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ClassFile,The method has 5 parameters. Parameters: buf' offset' length' inputClassName' options
Long Parameter List,IKVM.Internal,Code,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Read,The method has 5 parameters. Parameters: classFile' utf8_cp' method' br' options
Long Parameter List,IKVM.Internal,ExceptionTableEntry,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ExceptionTableEntry,The method has 5 parameters. Parameters: startIndex' endIndex' handlerIndex' catch_type' ordinal
Long Parameter List,IKVM.Internal,ExceptionTableEntry,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ExceptionTableEntry,The method has 6 parameters. Parameters: startIndex' endIndex' handlerIndex' catch_type' ordinal' isFinally
Long Parameter List,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,PatchCompare,The method has 5 parameters. Parameters: index' ble' blt' bge' bgt
Long Parameter List,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,DefineSymbolDocument,The method has 5 parameters. Parameters: module' url' language' languageVendor' documentType
Long Parameter List,IKVM.Internal,DotNetTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,InterfaceMethodStubHelper,The method has 6 parameters. Parameters: methodsList' method' name' sig' args' ret
Long Parameter List,IKVM.Internal,DotNetTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,MakeMethodDescriptor,The method has 5 parameters. Parameters: mb' name' sig' args' ret
Long Parameter List,IKVM.Internal,DotNetTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,CreateMethodWrapper,The method has 6 parameters. Parameters: name' sig' argTypeWrappers' retTypeWrapper' mb' privateInterfaceImplHack
Long Parameter List,IKVM.Internal,DynamicOnlyMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,DynamicOnlyMethodWrapper,The method has 6 parameters. Parameters: declaringType' name' sig' returnType' parameterTypes' flags
Long Parameter List,IKVM.Internal,ByRefMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,ByRefMethodWrapper,The method has 10 parameters. Parameters: args' byrefs' declaringType' name' sig' method' returnType' parameterTypes' modifiers' hideFromReflection
Long Parameter List,IKVM.Internal,AnnotationBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,EmitSetValueCall,The method has 5 parameters. Parameters: annotationAttributeBaseType' ilgen' name' tw' argIndex
Long Parameter List,IKVM.Internal,FinishedTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FinishedTypeImpl,The method has 7 parameters. Parameters: type' innerclasses' declaringTypeWrapper' reflectiveModifiers' metadata' clinitMethod' finalizeMethod
Long Parameter List,IKVM.Internal,JniBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Generate,The method has 9 parameters. Parameters: context' ilGenerator' wrapper' mw' typeBuilder' classFile' m' args' thruProxy
Long Parameter List,IKVM.Internal,EmitIntrinsicContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,EmitIntrinsicContext,The method has 9 parameters. Parameters: method' context' ilgen' ma' opcodeIndex' caller' classFile' code' flags
Long Parameter List,IKVM.Internal,JsrMethodAnalyzer,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\JsrInliner.cs,JsrMethodAnalyzer,The method has 5 parameters. Parameters: mw' classFile' method' classLoader' flags
Long Parameter List,IKVM.Internal,InstructionState,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\JsrInliner.cs,InstructionState,The method has 6 parameters. Parameters: stack' stackSize' stackEnd' locals' subroutines' callsites
Long Parameter List,IKVM.Internal,MemberWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\MemberWrapper.cs,MemberWrapper,The method has 5 parameters. Parameters: declaringType' name' sig' modifiers' flags
Long Parameter List,IKVM.Internal,MethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\MemberWrapper.cs,Create,The method has 8 parameters. Parameters: declaringType' name' sig' method' returnType' parameterTypes' modifiers' flags
Long Parameter List,IKVM.Internal,MethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\MemberWrapper.cs,MethodWrapper,The method has 8 parameters. Parameters: declaringType' name' sig' method' returnType' parameterTypes' modifiers' flags
Long Parameter List,IKVM.Internal,GhostMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\MemberWrapper.cs,GhostMethodWrapper,The method has 8 parameters. Parameters: declaringType' name' sig' method' returnType' parameterTypes' modifiers' flags
Long Parameter List,IKVM.Internal,SmartMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\MemberWrapper.cs,SmartMethodWrapper,The method has 8 parameters. Parameters: declaringType' name' sig' method' returnType' parameterTypes' modifiers' flags
Long Parameter List,IKVM.Internal,SimpleCallMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\MemberWrapper.cs,SimpleCallMethodWrapper,The method has 10 parameters. Parameters: declaringType' name' sig' method' returnType' parameterTypes' modifiers' flags' call' callvirt
Long Parameter List,IKVM.Internal,SmartCallMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\MemberWrapper.cs,SmartCallMethodWrapper,The method has 10 parameters. Parameters: declaringType' name' sig' method' returnType' parameterTypes' modifiers' flags' call' callvirt
Long Parameter List,IKVM.Internal,SmartConstructorMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\MemberWrapper.cs,SmartConstructorMethodWrapper,The method has 7 parameters. Parameters: declaringType' name' sig' method' parameterTypes' modifiers' flags
Long Parameter List,IKVM.Internal,AccessStubMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\MemberWrapper.cs,AccessStubMethodWrapper,The method has 10 parameters. Parameters: declaringType' name' sig' core' stubVirtual' stubNonVirtual' returnType' parameterTypes' modifiers' flags
Long Parameter List,IKVM.Internal,AccessStubConstructorMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\MemberWrapper.cs,AccessStubConstructorMethodWrapper,The method has 7 parameters. Parameters: declaringType' sig' core' stub' parameterTypes' modifiers' flags
Long Parameter List,IKVM.Internal,FieldWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\MemberWrapper.cs,FieldWrapper,The method has 7 parameters. Parameters: declaringType' fieldType' name' sig' modifiers' field' flags
Long Parameter List,IKVM.Internal,FieldWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\MemberWrapper.cs,FieldWrapper,The method has 6 parameters. Parameters: declaringType' fieldType' name' sig' modifiers' field
Long Parameter List,IKVM.Internal,FieldWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\MemberWrapper.cs,Create,The method has 6 parameters. Parameters: declaringType' fieldType' fi' name' sig' modifiers
Long Parameter List,IKVM.Internal,SimpleFieldWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\MemberWrapper.cs,SimpleFieldWrapper,The method has 6 parameters. Parameters: declaringType' fieldType' fi' name' sig' modifiers
Long Parameter List,IKVM.Internal,VolatileLongDoubleFieldWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\MemberWrapper.cs,VolatileLongDoubleFieldWrapper,The method has 6 parameters. Parameters: declaringType' fieldType' fi' name' sig' modifiers
Long Parameter List,IKVM.Internal,ConstantFieldWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\MemberWrapper.cs,ConstantFieldWrapper,The method has 8 parameters. Parameters: declaringType' fieldType' name' sig' modifiers' field' constant' flags
Long Parameter List,IKVM.Internal,CompiledAccessStubFieldWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\MemberWrapper.cs,CompiledAccessStubFieldWrapper,The method has 6 parameters. Parameters: wrapper' property' field' propertyType' modifiers' flags
Long Parameter List,IKVM.Internal,CompiledTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,GetNameSigFromMethodBase,The method has 6 parameters. Parameters: method' name' sig' retType' paramTypes' flags
Long Parameter List,IKVM.Internal,CompiledRemappedMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,CompiledRemappedMethodWrapper,The method has 10 parameters. Parameters: declaringType' name' sig' method' returnType' parameterTypes' modifiers' hideFromReflection' mbHelper' mbNonvirtualHelper
Long Identifier,IKVM.Internal,FakeTypes,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\FakeTypes.cs,,The length of the parameter genericAttributeAnnotationType is 30.
Long Identifier,IKVM.Internal,FakeTypes,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\FakeTypes.cs,,The length of the parameter genericAttributeAnnotationMultipleType is 38.
Long Identifier,IKVM.Internal,FakeTypes,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\FakeTypes.cs,,The length of the parameter genericAttributeAnnotationReturnValueType is 41.
Long Identifier,IKVM.Internal,ProxyGenerator,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\Proxy.cs,,The length of the parameter undeclaredThrowableExceptionConstructor is 39.
Long Identifier,IKVM.Internal,ProxyGenerator,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\Proxy.cs,,The length of the parameter javaLangNoClassDefFoundErrorConstructor is 39.
Long Identifier,IKVM.Internal,DotNetTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,,The length of the parameter AttributeAnnotationReturnValueSuffix is 36.
Long Identifier,IKVM.Internal,DotNetTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,,The length of the parameter AttributeAnnotationMultipleSuffix is 33.
Long Identifier,IKVM.Internal,DotNetTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,,The length of the parameter GenericDelegateInterfaceTypeName is 32.
Long Identifier,IKVM.Internal,DotNetTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,,The length of the parameter GenericAttributeAnnotationTypeName is 34.
Long Identifier,IKVM.Internal,DotNetTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,,The length of the parameter GenericAttributeAnnotationReturnValueTypeName is 45.
Long Identifier,IKVM.Internal,DotNetTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,,The length of the parameter GenericAttributeAnnotationMultipleTypeName is 42.
Long Identifier,IKVM.Internal,Serialization,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\Serialization.cs,AddAutomagicSerializationToWorkaroundBaseClass,The length of the parameter typeBuilderWorkaroundBaseClass is 30.
Long Identifier,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,,The length of the parameter typeofLineNumberTableAttribute is 30.
Long Identifier,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,,The length of the parameter typeofRemappedInterfaceMethodAttribute is 38.
Long Identifier,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,,The length of the parameter typeofExceptionIsUnsafeForMappingAttribute is 42.
Long Identifier,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,,The length of the parameter typeofHideFromReflectionAttribute is 33.
Long Identifier,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,,The length of the parameter typeofNoPackagePrefixAttribute is 30.
Long Identifier,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,,The length of the parameter typeofAnnotationAttributeAttribute is 34.
Long Identifier,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,,The length of the parameter typeofNonNestedInnerClassAttribute is 34.
Long Identifier,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,,The length of the parameter typeofNonNestedOuterClassAttribute is 34.
Long Identifier,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,,The length of the parameter typeofEnclosingMethodAttribute is 30.
Long Statement,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,GetBaseTypeForDefineType,The length of the statement  "					TypeBuilder typeBuilder = context.ModuleBuilder.DefineType(name' TypeAttributes.Public | TypeAttributes.Abstract' base.GetBaseTypeForDefineType()); " is 147.
Long Statement,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,AddMapXmlFields,The length of the statement  "								fields[fields.Length - 1] = FieldWrapper.Create(this' null' null' field.Name' field.Sig' new ExModifiers((Modifiers)field.Modifiers' false)); " is 141.
Long Statement,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,EmitMapXmlMethodPrologueAndOrBody,The length of the statement  "			IKVM.Internal.MapXml.InstructionList prologue = classLoader.GetMethodPrologue(new MethodKey(f.Name' m.Name' m.Signature)); " is 122.
Long Statement,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,PublishProperties,The length of the statement  "				PropertyBuilder propbuilder = typeBuilder.DefineProperty(prop.Name' PropertyAttributes.None' typeWrapper.TypeAsSignatureType' indexer); " is 135.
Long Statement,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,PublishProperties,The length of the statement  "							mb = typeBuilder.DefineMethod("get_" + prop.Name' GetPropertyMethodAttributes(mw' final)' typeWrapper.TypeAsSignatureType' indexer); " is 132.
Long Statement,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,PublishProperties,The length of the statement  "							mb = typeBuilder.DefineMethod("set_" + prop.Name' GetPropertyMethodAttributes(mw' final)' mw.ReturnTypeForDefineMethod' args); " is 126.
Long Statement,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,IsPInvokeMethod,The length of the statement  "									if(StaticCompiler.GetType(classLoader' attr.Type) == JVM.Import(typeof(System.Runtime.InteropServices.DllImportAttribute))) " is 123.
Long Statement,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,MapModifiers,The length of the statement  "				if((modifiers & Modifiers.Final) != 0 && (attribs & MethodAttributes.NewSlot) != 0 && (attribs & MethodAttributes.Virtual) == 0) " is 128.
Long Statement,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,EmitMapXmlMetadata,The length of the statement  "									Console.Error.WriteLine("Error: Constructor {0}.<init>{1} in xml remap file doesn't have a body."' clazz.Name' constructor.Sig); " is 128.
Long Statement,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,EmitMapXmlMetadata,The length of the statement  "									Console.Error.WriteLine("Error: Method {0}.{1}{2} in xml remap file doesn't have a body."' clazz.Name' method.Name' method.Sig); " is 128.
Long Statement,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,EmitMapXmlMetadata,The length of the statement  "									MethodWrapper mw = GetClassLoader().LoadClassByDottedName(method.@override.Class).GetMethodWrapper(method.@override.Name' method.Sig' true); " is 140.
Long Statement,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,EmitMapXmlMetadata,The length of the statement  "									MethodBuilder mb = mw.GetDefineMethodHelper().DefineMethod(this' typeBuilder' tw.Name + "/" + m.Name' MethodAttributes.Private | MethodAttributes.NewSlot | MethodAttributes.Virtual | MethodAttributes.Final | MethodAttributes.CheckAccessOnOverride); " is 248.
Long Statement,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,FinishGhost,The length of the statement  "						MethodBuilder stub = methods[i].GetDefineMethodHelper().DefineMethod(this' typeBuilder' methods[i].Name' MethodAttributes.Public); " is 130.
Long Statement,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,FinishGhost,The length of the statement  "						mb = typeBuilder.DefineMethod("op_Implicit"' MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.SpecialName' TypeAsSignatureType' new Type[] { implementers[i].TypeAsSignatureType }); " is 229.
Long Statement,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,FinishGhost,The length of the statement  "					ilgen.Emit(OpCodes.Call' StaticCompiler.GetRuntimeType("IKVM.Runtime.GhostTag").GetMethod("IsGhostArrayInstance"' BindingFlags.NonPublic | BindingFlags.Static)); " is 161.
Long Statement,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,FinishGhost,The length of the statement  "					mb = typeBuilder.DefineMethod("ToObject"' MethodAttributes.HideBySig | MethodAttributes.Public' Types.Object' Type.EmptyTypes); " is 127.
Long Statement,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,FinishGhost,The length of the statement  "					ilgen.Emit(OpCodes.Call' StaticCompiler.GetRuntimeType("IKVM.Runtime.GhostTag").GetMethod("ThrowClassCastException"' BindingFlags.NonPublic | BindingFlags.Static)); " is 164.
Long Statement,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,FinishGhost,The length of the statement  "					mb = typeBuilder.DefineMethod("Equals"' MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Virtual' Types.Boolean' new Type[] { Types.Object }); " is 165.
Long Statement,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,FinishGhost,The length of the statement  "					mb = typeBuilder.DefineMethod("GetHashCode"' MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Virtual' Types.Int32' Type.EmptyTypes); " is 156.
Long Statement,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,FinishGhost,The length of the statement  "					mb = typeBuilder.DefineMethod("op_Equality"' MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.SpecialName' Types.Boolean' new Type[] { typeBuilder' typeBuilder }); " is 212.
Long Statement,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,FinishGhost,The length of the statement  "					mb = typeBuilder.DefineMethod("op_Inequality"' MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.SpecialName' Types.Boolean' new Type[] { typeBuilder' typeBuilder }); " is 214.
Long Statement,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,DefineGhostType,The length of the statement  "			TypeBuilder typeBuilder = classLoader.GetTypeWrapperFactory().ModuleBuilder.DefineType(mangledTypeName' typeAttribs' Types.ValueType); " is 134.
Long Statement,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,DefineGhostType,The length of the statement  "			typeBuilderGhostInterface = typeBuilder.DefineNestedType("__Interface"' TypeAttributes.Interface | TypeAttributes.Abstract | TypeAttributes.NestedPublic); " is 154.
Long Statement,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,DefineGhostType,The length of the statement  "			ghostIsInstanceMethod = typeBuilder.DefineMethod("IsInstance"' MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static' Types.Boolean' new Type[] { Types.Object }); " is 187.
Long Statement,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,DefineGhostType,The length of the statement  "			ghostIsInstanceArrayMethod = typeBuilder.DefineMethod("IsInstanceArray"' MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static' Types.Boolean' new Type[] { Types.Object' Types.Int32 }); " is 210.
Long Statement,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,DefineGhostType,The length of the statement  "			ghostCastMethod = typeBuilder.DefineMethod("Cast"' MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static' typeBuilder' new Type[] { Types.Object }); " is 173.
Long Statement,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,DefineGhostType,The length of the statement  "			ghostCastArrayMethod = typeBuilder.DefineMethod("CastArray"' MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static' Types.Void' new Type[] { Types.Object' Types.Int32 }); " is 195.
Long Statement,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,GetReplacedMethodsFor,The length of the statement  "			IKVM.Internal.MapXml.ReplaceMethodCall[] replacedMethods = ((CompilerClassLoader)GetClassLoader()).GetReplacedMethodsFor(mw); " is 125.
Long Statement,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,GetReplacedMethodsFor,The length of the statement  "						list.Add(new ReplacedMethodWrapper(GetClassLoader().LoadClassByDottedName(replacedMethods[i].Class)' replacedMethods[i].Name' replacedMethods[i].Sig' replacedMethods[i].code)); " is 176.
Long Statement,IKVM.Internal,WorkaroundBaseClass,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,GetSerializationConstructor,The length of the statement  "					baseSerializationCtor = Serialization.AddAutomagicSerializationToWorkaroundBaseClass(typeBuilder' wrapper.BaseTypeWrapper.GetSerializationConstructor()); " is 153.
Long Statement,IKVM.Internal,WorkaroundBaseClass,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,Finish,The length of the statement  "						MethodBuilder mb = mw.GetDefineMethodHelper().DefineMethod(wrapper' typeBuilder' mw.Name' MethodAttributes.FamORAssem | MethodAttributes.Virtual | MethodAttributes.HideBySig | MethodAttributes.CheckAccessOnOverride); " is 216.
Long Statement,IKVM.Internal,ReplacedMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,DoEmit,The length of the statement  "				IKVM.Internal.MapXml.CodeGenContext context = new IKVM.Internal.MapXml.CodeGenContext(this.DeclaringType.GetClassLoader()); " is 123.
Long Statement,IKVM.Internal,AssemblyResolver,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AssemblyResolver.cs,LoadFile,The length of the statement  "						// to avoid problems (i.e. weird exceptions)' we don't allow assemblies to load that reference a newer version of mscorlib " is 122.
Long Statement,IKVM.Internal,AssemblyResolver,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AssemblyResolver.cs,LoadFile,The length of the statement  "								Console.Error.WriteLine("Error: unable to load assembly '{0}' as it depends on a higher version of mscorlib than the one currently loaded"' path); " is 146.
Long Statement,IKVM.Internal,AssemblyResolver,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AssemblyResolver.cs,LoadFile,The length of the statement  "						EmitWarning(WarningId.LocationIgnored' "assembly \"{0}\" is ignored as previously loaded assembly \"{1}\" has the same identity \"{2}\""' path' asm.Location' asm.FullName); " is 172.
Long Statement,IKVM.Internal,AssemblyResolver,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AssemblyResolver.cs,universe_AssemblyResolve,The length of the statement  "					EmitWarning(WarningId.HigherVersion' "assuming assembly reference \"{0}\" matches \"{1}\"' you may need to supply runtime policy"' previousMatch.FullName' name.FullName); " is 170.
Long Statement,IKVM.Internal,AssemblyResolver,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AssemblyResolver.cs,universe_AssemblyResolve,The length of the statement  "					Console.Error.WriteLine("Error: Assembly '{0}' uses '{1}' which has a higher version than referenced assembly '{2}'"' args.RequestingAssembly.FullName' name.FullName' previousMatch.FullName); " is 191.
Long Statement,IKVM.Internal,AssemblyResolver,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AssemblyResolver.cs,universe_AssemblyResolve,The length of the statement  "					Console.Error.WriteLine("Error: Assembly '{0}' was requested which is a higher version than referenced assembly '{1}'"' name.FullName' previousMatch.FullName); " is 159.
Long Statement,IKVM.Internal,AssemblyResolver,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AssemblyResolver.cs,Match,The length of the statement  "			//   1 = lower version match (i.e. not a suitable match' but used in error reporting: something was found but the version was too low) " is 134.
Long Statement,IKVM.Internal,AssemblyResolver,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AssemblyResolver.cs,Match,The length of the statement  "			//   2 = higher version potential match (i.e. we can use this version' but if it is available the exact match will be preferred) " is 128.
Long Statement,IKVM.Internal,AssemblyResolver,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AssemblyResolver.cs,AddLibraryPaths,The length of the statement  "						EmitWarning(WarningId.InvalidLibDirectoryEnvironment' "directory \"{0}\" specified in LIB environment is not valid"' dir); " is 122.
Long Statement,IKVM.Internal,AssemblyResolver,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AssemblyResolver.cs,FindAssemblyPath,The length of the statement  "						EmitWarning(WarningId.LegacySearchRule' "found assembly \"{0}\" using legacy search rule' please append '.dll' to the reference"' file); " is 136.
Long Statement,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,CreateModuleBuilder,The length of the statement  "				CustomAttributeBuilder debugAttr = new CustomAttributeBuilder(JVM.Import(typeof(DebuggableAttribute)).GetConstructor(new Type[] { Types.Boolean' Types.Boolean })' new object[] { true' this.EmitDebugInfo }); " is 206.
Long Statement,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,AddInternalsVisibleToAttribute,The length of the statement  "			CustomAttributeBuilder cab = new CustomAttributeBuilder(JVM.Import(typeof(InternalsVisibleToAttribute)).GetConstructor(new Type[] { Types.String })' new object[] { name }); " is 172.
Long Statement,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,SetMain,The length of the statement  "			MethodBuilder mainStub = this.GetTypeWrapperFactory().ModuleBuilder.DefineGlobalMethod("main"' MethodAttributes.Public | MethodAttributes.Static' Types.Int32' new Type[] { Types.String.MakeArrayType() }); " is 204.
Long Statement,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,SetMain,The length of the statement  "				mainStub.SetCustomAttribute(new CustomAttributeBuilder(apartmentAttributeType.GetConstructor(Type.EmptyTypes)' new object[0])); " is 127.
Long Statement,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,SetMain,The length of the statement  "				ilgen.Emit(OpCodes.Newobj' JVM.Import(typeof(System.Collections.Generic.Dictionary<string' string>)).GetConstructor(Type.EmptyTypes)); " is 134.
Long Statement,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,SetMain,The length of the statement  "						ilgen.Emit(OpCodes.Call' JVM.Import(typeof(Environment)).GetMethod("ExpandEnvironmentVariables"' new Type[] { Types.String })); " is 127.
Long Statement,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,SetMain,The length of the statement  "					ilgen.Emit(OpCodes.Callvirt' JVM.Import(typeof(System.Collections.Generic.Dictionary<string' string>)).GetMethod("Add")); " is 121.
Long Statement,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,SetMain,The length of the statement  "			LoadClassByDottedName("ikvm.runtime.Util").GetMethodWrapper("mapException"' "(Ljava.lang.Throwable;)Ljava.lang.Throwable;"' false).EmitCall(ilgen); " is 147.
Long Statement,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,SetMain,The length of the statement  "			ClassLoaderWrapper.LoadClassCritical("java.lang.ThreadGroup").GetMethodWrapper("uncaughtException"' "(Ljava.lang.Thread;Ljava.lang.Throwable;)V"' false).EmitCallvirt(ilgen); " is 173.
Long Statement,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,Save,The length of the statement  "				mb.SetCustomAttribute(new CustomAttributeBuilder(JVM.LoadType(typeof(PackageListAttribute)).GetConstructor(new Type[] { JVM.Import(typeof(string[])) })' new object[] { list })); " is 177.
Long Statement,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,Save,The length of the statement  "					throw new FatalCompilerErrorException(Message.ErrorWritingFile' GetTypeWrapperFactory().ModuleBuilder.FullyQualifiedName' x.Message); " is 133.
Long Statement,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,AddJavaModuleAttribute,The length of the statement  "				CustomAttributeBuilder cab = new CustomAttributeBuilder(typeofJavaModuleAttribute.GetConstructor(new Type[] { JVM.Import(typeof(string[])) })' new object[] { list }' propInfos' propValues); " is 189.
Long Statement,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,AddJavaModuleAttribute,The length of the statement  "				CustomAttributeBuilder cab = new CustomAttributeBuilder(typeofJavaModuleAttribute.GetConstructor(Type.EmptyTypes)' new object[0]' propInfos' propValues); " is 153.
Long Statement,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,AddResources,The length of the statement  "			// BUG we need to call GetTypeWrapperFactory() to make sure that the assemblyBuilder is created (when building an empty target) " is 127.
Long Statement,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,AddResources,The length of the statement  "					name = Path.GetFileNameWithoutExtension(name) + "-" + moduleBuilder.ModuleVersionId.ToString("N") + Path.GetExtension(name); " is 124.
Long Statement,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,MapMethodAccessModifiers,The length of the statement  "			const IKVM.Internal.MapXml.MapModifiers access = IKVM.Internal.MapXml.MapModifiers.Public | IKVM.Internal.MapXml.MapModifiers.Protected | IKVM.Internal.MapXml.MapModifiers.Private; " is 180.
Long Statement,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,MapFieldAccessModifiers,The length of the statement  "			const IKVM.Internal.MapXml.MapModifiers access = IKVM.Internal.MapXml.MapModifiers.Public | IKVM.Internal.MapXml.MapModifiers.Protected | IKVM.Internal.MapXml.MapModifiers.Private; " is 180.
Long Statement,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,Compile,The length of the statement  "					runtimeAssembly = Path.Combine(typeof(CompilerClassLoader).Assembly.Location' ".." + Path.DirectorySeparatorChar + "IKVM.Runtime.dll"); " is 135.
Long Statement,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,Compile,The length of the statement  "				StaticCompiler.runtimeJniAssembly = StaticCompiler.LoadFile(Path.Combine(StaticCompiler.runtimeAssembly.Location' ".." + Path.DirectorySeparatorChar + "IKVM.Runtime.JNI.dll")); " is 176.
Long Statement,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,Compile,The length of the statement  "						&& (compiler1.options.crossReferenceAllPeers || (compiler1.options.peerReferences != null && Array.IndexOf(compiler1.options.peerReferences' compiler2.options.assembly) != -1))) " is 177.
Long Statement,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,Compile,The length of the statement  "						TypeBuilder tb = compiler.options.sharedclassloader[0].GetTypeWrapperFactory().ModuleBuilder.DefineType("__<MainAssembly>"' TypeAttributes.NotPublic | TypeAttributes.Abstract | TypeAttributes.SpecialName); " is 205.
Long Statement,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,CreateCompiler,The length of the statement  "								throw new FatalCompilerErrorException(Message.RuntimeMismatch' reference.Location' runtimeAssemblyName.FullName' asmref.FullName); " is 130.
Long Statement,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,CreateCompiler,The length of the statement  "								throw new FatalCompilerErrorException(Message.RuntimeMismatch' reference.Location' runtimeAssemblyName.FullName' asmref.FullName); " is 130.
Long Statement,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,CreateCompiler,The length of the statement  "					StaticCompiler.IssueMessage(options' Message.NonPrimaryAssemblyReference' references[i].GetName().Name' acl.MainAssembly.GetName().Name); " is 137.
Long Statement,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,CreateCompiler,The length of the statement  "			loader = new CompilerClassLoader(referencedAssemblies' options' options.path' options.targetIsModule' options.assembly' h); " is 123.
Long Statement,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,CreateCompiler,The length of the statement  "				System.Xml.Serialization.XmlSerializer ser = new System.Xml.Serialization.XmlSerializer(typeof(IKVM.Internal.MapXml.Root)); " is 123.
Long Statement,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,IsStub,The length of the statement  "					return new ClassFile(classdef.data' 0' classdef.data.Length' className' ClassFileParseOptions.RelaxedClassNameValidation).IKVMAssemblyAttribute != null; " is 152.
Long Statement,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,CompilePass1,The length of the statement  "						if(!(loader is GenericClassLoader || loader is CompilerClassLoader || (importedStubTypes.ContainsKey(s) && importedStubTypes[s] == wrapper) || IsStub(s))) " is 154.
Long Statement,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,CompilePass1,The length of the statement  "							StaticCompiler.IssueMessage(options' Message.SkippingReferencedClass' s' ((AssemblyClassLoader)loader).GetAssembly(wrapper).FullName); " is 134.
Long Statement,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,CompilePass3,The length of the statement  "				CustomAttributeBuilder filever = new CustomAttributeBuilder(JVM.Import(typeof(System.Reflection.AssemblyFileVersionAttribute)).GetConstructor(new Type[] { Types.String })' new object[] { options.fileversion }); " is 210.
Long Statement,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,CompilePass3,The length of the statement  "				ConstructorInfo ci = JVM.LoadType(typeof(CustomAssemblyClassLoaderAttribute)).GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic' null' new Type[] { Types.Type }' null); " is 202.
Long Statement,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,CompilePass3,The length of the statement  "				// TODO it would be better to do this for all assemblies in a shared class loader group (because options.classloader is relevant only for the main assembly)' " is 157.
Long Statement,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,CompilePass3,The length of the statement  "				// but since it is probably common to specify the custom assembly class loader at the group level' it hopefully won't make much difference in practice. " is 151.
Long Statement,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,CompilePass3,The length of the statement  "					MethodBuilder moduleInitializer = GetTypeWrapperFactory().ModuleBuilder.DefineGlobalMethod(".cctor"' MethodAttributes.Private | MethodAttributes.Static | MethodAttributes.SpecialName | MethodAttributes.RTSpecialName' null' Type.EmptyTypes); " is 240.
Long Statement,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,CompilePass3,The length of the statement  "					ilgen.Emit(OpCodes.Call' JVM.Import(typeof(System.Reflection.MethodBase)).GetMethod("GetMethodFromHandle"' new Type[] { JVM.Import(typeof(RuntimeMethodHandle)) })); " is 164.
Long Statement,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,ser_UnknownElement,The length of the statement  "			StaticCompiler.IssueMessage(Message.UnknownElementInMapFile' e.Element.Name' e.LineNumber.ToString()' e.LinePosition.ToString()); " is 129.
Long Statement,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,ser_UnknownAttribute,The length of the statement  "			StaticCompiler.IssueMessage(Message.UnknownAttributeInMapFile' e.Attr.Name' e.LineNumber.ToString()' e.LinePosition.ToString()); " is 128.
Long Statement,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,TryEnableUnmanagedExports,The length of the statement  "			if ((options.imageFileMachine == ImageFileMachine.I386 && (options.pekind & PortableExecutableKinds.Required32Bit) != 0) " is 120.
Long Statement,IKVM.Internal,RemapperTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,Process2ndPassStep2,The length of the statement  "								fields.Add(new ConstantFieldWrapper(this' GetClassLoader().FieldTypeWrapperFromSig(f.Sig)' f.Name' f.Sig' (Modifiers)f.Modifiers' fb' constant' MemberFlags.None)); " is 163.
Long Statement,IKVM.Internal,RemapperTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,Process2ndPassStep2,The length of the statement  "								fields.Add(FieldWrapper.Create(this' GetClassLoader().FieldTypeWrapperFromSig(f.Sig)' fb' f.Name' f.Sig' new ExModifiers((Modifiers)f.Modifiers' false))); " is 154.
Long Statement,IKVM.Internal,RemapperTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,Process4thPass,The length of the statement  "					foreach(MethodInfo mi in typeBuilder.BaseType.GetMethods(BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static | BindingFlags.FlattenHierarchy)) " is 156.
Long Statement,IKVM.Internal,RemapperTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,Process4thPass,The length of the statement  "							MethodBuilder mb = typeBuilder.DefineMethod(mi.Name' mi.Attributes & (MethodAttributes.MemberAccessMask | MethodAttributes.SpecialName | MethodAttributes.Static)' mi.ReturnType' paramTypes); " is 190.
Long Statement,IKVM.Internal,RemapperTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,Process4thPass,The length of the statement  "					foreach(PropertyInfo pi in typeBuilder.BaseType.GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static)) " is 129.
Long Statement,IKVM.Internal,RemappedConstructorWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,DoLink,The length of the statement  "						mbHelper = typeWrapper.typeBuilder.DefineMethod("newhelper"' attr | MethodAttributes.Static' CallingConventions.Standard' typeWrapper.shadowType' paramTypes); " is 158.
Long Statement,IKVM.Internal,RemappedMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,EmitCall,The length of the statement  "						// When calling a final instance method on a remapped type from a class derived from a .NET class (i.e. a cli.System.Object or cli.System.Exception derived base class) " is 167.
Long Statement,IKVM.Internal,RemappedMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,EmitCall,The length of the statement  "						// then we can't call the java.lang.Object or java.lang.Throwable methods and we have to go through the instancehelper_ method. Note that since the method " is 154.
Long Statement,IKVM.Internal,RemappedMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,DoLink,The length of the statement  "						MethodInfo interfaceMethod = typeWrapper.shadowType.GetMethod(m.@override.Name' typeWrapper.GetClassLoader().ArgTypeListFromSig(m.Sig)); " is 136.
Long Statement,IKVM.Internal,RemappedMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,DoLink,The length of the statement  "								typeWrapper.helperTypeBuilder = typeWrapper.typeBuilder.DefineNestedType("__Helper"' TypeAttributes.NestedPublic | TypeAttributes.Class | TypeAttributes.Sealed); " is 161.
Long Statement,IKVM.Internal,RemappedMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,DoLink,The length of the statement  "								ilgen = CodeEmitter.Create(typeWrapper.helperTypeBuilder.DefineConstructor(MethodAttributes.Private' CallingConventions.Standard' Type.EmptyTypes)); " is 148.
Long Statement,IKVM.Internal,RemappedMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,DoLink,The length of the statement  "							helper = typeWrapper.helperTypeBuilder.DefineMethod(m.Name' MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static' typeWrapper.GetClassLoader().RetTypeWrapperFromSig(m.Sig).TypeAsSignatureType' argTypes); " is 229.
Long Statement,IKVM.Internal,RemappedMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,DoLink,The length of the statement  "								RemappedMethodWrapper baseMethod = typeWrapper.BaseTypeWrapper.GetMethodWrapper(m.Name' m.Sig' true) as RemappedMethodWrapper; " is 126.
Long Statement,IKVM.Internal,RemappedMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,DoLink,The length of the statement  "							else if((m.Modifiers & IKVM.Internal.MapXml.MapModifiers.Private) == 0 && (m.Modifiers & IKVM.Internal.MapXml.MapModifiers.Final) == 0) " is 135.
Long Statement,IKVM.Internal,RemappedMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,DoLink,The length of the statement  "									MethodInfo autoOverride = typeWrapper.shadowType.GetMethod(m.Name' BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic' null' paramTypes' null); " is 161.
Long Statement,IKVM.Internal,RemappedMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,DoLink,The length of the statement  "									RemappedMethodWrapper baseMethod = typeWrapper.BaseTypeWrapper.GetMethodWrapper(m.Name' m.Sig' true) as RemappedMethodWrapper; " is 126.
Long Statement,IKVM.Internal,RemappedMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,DoLink,The length of the statement  "											overrideMethod = typeWrapper.BaseTypeWrapper.TypeAsTBD.GetMethod(baseMethod.m.@override.Name' BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic' null' paramTypes' null); " is 188.
Long Statement,IKVM.Internal,RemappedMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,DoLink,The length of the statement  "							mbHelper = typeWrapper.typeBuilder.DefineMethod("instancehelper_" + m.Name' attr' CallingConventions.Standard' retType' exParamTypes); " is 134.
Long Statement,IKVM.Internal,RemappedMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,DoLink,The length of the statement  "							mbHelper.SetCustomAttribute(new CustomAttributeBuilder(JVM.Import(typeof(ObsoleteAttribute)).GetConstructor(new Type[] { Types.String })' new object[] { "This function will be removed from future versions. Please use extension methods from ikvm.extensions namespace instead." })); " is 280.
Long Statement,IKVM.Internal,RemappedMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,Finish,The length of the statement  "							baseMethod = DeclaringType.TypeAsTBD.GetMethod(m.@override.Name' BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic' null' paramTypes' null); " is 159.
Long Statement,IKVM.Internal,RemappedMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,Finish,The length of the statement  "							(m.Modifiers & IKVM.Internal.MapXml.MapModifiers.Private) == 0 && (m.Modifiers & IKVM.Internal.MapXml.MapModifiers.Final) == 0) " is 127.
Long Statement,IKVM.Internal,RemappedMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,Finish,The length of the statement  "								MethodInfo baseMethod = shadowType.GetMethod(m.@override.Name' BindingFlags.Instance | BindingFlags.Public' null' paramTypes' null); " is 132.
Long Statement,IKVM.Internal,RemappedMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,Finish,The length of the statement  "								RemappedMethodWrapper baseMethod = DeclaringType.BaseTypeWrapper.GetMethodWrapper(Name' Signature' true) as RemappedMethodWrapper; " is 130.
Long Statement,IKVM.Internal,RemappedMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,Finish,The length of the statement  "								MethodInfo overrideMethod = shadowType.GetMethod(baseMethod.m.@override.Name' BindingFlags.Instance | BindingFlags.Public' null' paramTypes' null); " is 147.
Long Statement,IKVM.Internal,RemappedMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,Finish,The length of the statement  "						MethodBuilder mb = typeWrapper.typeBuilder.DefineMethod("nonvirtualhelper/" + this.Name' MethodAttributes.Private | MethodAttributes.Static' this.ReturnTypeForDefineMethod' argTypes); " is 183.
Long Statement,IKVM.Internal,RemappedMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,Finish,The length of the statement  "							MethodInfo baseMethod = shadowType.GetMethod(m.@override.Name' BindingFlags.Instance | BindingFlags.Public' null' paramTypes' null); " is 132.
Long Statement,IKVM.Internal,ExceptionMapEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,Emit,The length of the statement  "				MethodWrapper mwSuppressFillInStackTrace = CoreClasses.java.lang.Throwable.Wrapper.GetMethodWrapper("__<suppressFillInStackTrace>"' "()V"' false); " is 146.
Long Statement,IKVM.Internal,StaticCompiler,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,IssueMessage,The length of the statement  "					msg = "Referenced assembly \"{0}\" is not the primary assembly of a shared class loader group' referencing primary assembly \"{1}\" instead"; " is 141.
Long Statement,IKVM.Internal,StaticCompiler,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,IssueMessage,The length of the statement  "			Console.Error.Write("{0} IKVMC{1:D4}: "' error ? "error" : msgId < Message.StartWarnings ? "note" : "warning"' (int)msgId); " is 123.
Long Statement,IKVM.Internal,FakeTypes,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\FakeTypes.cs,Create,The length of the statement  "			TypeBuilder tb = modb.DefineType(DotNetTypeWrapper.GenericDelegateInterfaceTypeName' TypeAttributes.Interface | TypeAttributes.Abstract | TypeAttributes.Public); " is 161.
Long Statement,IKVM.Internal,FakeTypes,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\FakeTypes.cs,Create,The length of the statement  "			genericAttributeAnnotationMultipleType = CreateAnnotationType(modb' DotNetTypeWrapper.GenericAttributeAnnotationMultipleTypeName); " is 130.
Long Statement,IKVM.Internal,FakeTypes,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\FakeTypes.cs,Create,The length of the statement  "			genericAttributeAnnotationReturnValueType = CreateAnnotationType(modb' DotNetTypeWrapper.GenericAttributeAnnotationReturnValueTypeName); " is 136.
Long Statement,IKVM.Internal,FakeTypes,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\FakeTypes.cs,Finish,The length of the statement  "			CodeEmitter ilgen = CodeEmitter.Create(tb.DefineConstructor(MethodAttributes.Private' CallingConventions.Standard' new Type[] { Types.String' Types.Int32 })); " is 158.
Long Statement,IKVM.Internal,FakeTypes,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\FakeTypes.cs,CreateEnumEnum,The length of the statement  "			TypeBuilder tb = modb.DefineType(DotNetTypeWrapper.GenericEnumEnumTypeName' TypeAttributes.Class | TypeAttributes.Sealed | TypeAttributes.Public); " is 146.
Long Statement,IKVM.Internal,FakeTypes,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\FakeTypes.cs,Load,The length of the statement  "			genericAttributeAnnotationMultipleType = assembly.GetType(DotNetTypeWrapper.GenericAttributeAnnotationMultipleTypeName); " is 120.
Long Statement,IKVM.Internal,FakeTypes,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\FakeTypes.cs,Load,The length of the statement  "			genericAttributeAnnotationReturnValueType = assembly.GetType(DotNetTypeWrapper.GenericAttributeAnnotationReturnValueTypeName); " is 126.
Long Statement,IKVM.Internal,ProxyGenerator,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\Proxy.cs,CreateNoFail,The length of the statement  "				methods[i].fb = tb.DefineField("m" + i' javaLangReflectMethod.TypeAsSignatureType' FieldAttributes.Private | FieldAttributes.Static); " is 133.
Long Statement,IKVM.Internal,ProxyGenerator,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\Proxy.cs,CreateConstructor,The length of the statement  "			ConstructorBuilder cb = tb.DefineConstructor(MethodAttributes.Public' CallingConventions.Standard' new Type[] { invocationHandlerClass.TypeAsSignatureType }); " is 158.
Long Statement,IKVM.Internal,ProxyGenerator,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\Proxy.cs,CreateMethod,The length of the statement  "			MethodBuilder mb = pm.mw.GetDefineMethodHelper().DefineMethod(loader.GetTypeWrapperFactory()' tb' pm.mw.Name' MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.Final); " is 187.
Long Statement,IKVM.Internal,AssemblyClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\AssemblyClassLoader.cs,DoInitializeExports,The length of the statement  "					if (!(ReflectUtil.IsDynamicAssembly(assemblyLoader.Assembly)) && assemblyLoader.Assembly.GetManifestResourceInfo("ikvm.exports") != null) " is 137.
Long Statement,IKVM.Internal,AssemblyClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\AssemblyClassLoader.cs,GetWrapperFromAssemblyType,The length of the statement  "					throw new FatalCompilerErrorException(Message.AssemblyContainsDuplicateClassNames' type.FullName' wrapper.TypeAsTBD.FullName' wrapper.Name' type.Assembly.FullName); " is 164.
Long Statement,IKVM.Internal,AssemblyClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\AssemblyClassLoader.cs,GetWrapperFromAssemblyType,The length of the statement  "					string msg = String.Format("\nType \"{0}\" and \"{1}\" both map to the same name \"{2}\".\n"' type.FullName' wrapper.TypeAsTBD.FullName' wrapper.Name); " is 151.
Long Statement,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ReadBootstrapMethods,The length of the statement  "					throw new ClassFormatError("bootstrap_method_index {0} has bad constant type in class file {1}"' bsm_index' classFile.Name); " is 124.
Long Statement,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ReadBootstrapMethods,The length of the statement  "						throw new ClassFormatError("argument_index {0} has bad constant type in class file {1}"' argument_index' classFile.Name); " is 121.
Long Statement,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ReadAnnotationElementValue,The length of the statement  "			return new object[] { AnnotationDefaultAttribute.TAG_ERROR' "java.lang.IllegalArgumentException"' "Wrong type at constant pool index" }; " is 136.
Long Statement,IKVM.Internal,ConstantPoolItemFMI,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Resolve,The length of the statement  "				ConstantPoolItemNameAndType name_and_type = (ConstantPoolItemNameAndType)classFile.GetConstantPoolItem(name_and_type_index); " is 124.
Long Statement,IKVM.Internal,ConstantPoolItemInvokeDynamic,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Resolve,The length of the statement  "				ConstantPoolItemNameAndType name_and_type = (ConstantPoolItemNameAndType)classFile.GetConstantPoolItem(name_and_type_index); " is 124.
Long Statement,IKVM.Internal,ConstantPoolItemInvokeDynamic,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Resolve,The length of the statement  "				descriptor = String.Intern(classFile.GetConstantPoolUtf8String(utf8_cp' name_and_type.descriptor_index).Replace('/'' '.')); " is 123.
Long Statement,IKVM.Internal,Field,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,DecodePropertyAnnotation,The length of the statement  "					Tracer.Error(Tracer.ClassLoading' "Ignoring duplicate ikvm.lang.Property annotation on {0}.{1}"' classFile.Name' this.Name); " is 124.
Long Statement,IKVM.Internal,Field,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,DecodePropertyAnnotation,The length of the statement  "					Tracer.Error(Tracer.ClassLoading' "Ignoring malformed ikvm.lang.Property annotation on {0}.{1}"' classFile.Name' this.Name); " is 124.
Long Statement,IKVM.Internal,Method,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ValidateSig,The length of the statement  "					throw new ClassFormatError("{0} (Method \"{1}\" has invalid signature \"{2}\")"' classFile.Name' this.Name' descriptor); " is 120.
Long Statement,IKVM.Internal,ClassLoaderWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassLoaderWrapper.cs,CheckDefineClassAllowed,The length of the statement  "			// this hook exists so that AssemblyClassLoader can prevent DefineClass when the name is already present in the assembly " is 120.
Long Statement,IKVM.Internal,ClassLoaderWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassLoaderWrapper.cs,LoadGenericClass,The length of the statement  "				TypeWrapper outer = LoadGenericClass(name.Substring(0' name.Length - DotNetTypeWrapper.DelegateInterfaceSuffix.Length)); " is 120.
Long Statement,IKVM.Internal,ClassLoaderWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassLoaderWrapper.cs,SetWrapperForClassLoader,The length of the statement  "			typeof(java.lang.ClassLoader).GetField("wrapper"' BindingFlags.NonPublic | BindingFlags.Instance).SetValue(javaClassLoader' wrapper); " is 133.
Long Statement,IKVM.Internal,ClassLoaderWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassLoaderWrapper.cs,IssueMessage,The length of the statement  "			// it's not ideal when we end up here (because it means we're emitting a warning that is not associated with a specific output target)' " is 135.
Long Statement,IKVM.Internal,ClassLoaderWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassLoaderWrapper.cs,IssueMessage,The length of the statement  "			// but it happens when we're decoding something in a referenced assembly that either doesn't make sense or contains an unloadable type " is 134.
Long Statement,IKVM.Internal,DotNetTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,LazyPublishMembers,The length of the statement  "						fieldsList.Add(new ConstantFieldWrapper(this' fieldType' name' fieldType.SigName' Modifiers.Public | Modifiers.Static | Modifiers.Final' fields[i]' val' MemberFlags.None)); " is 172.
Long Statement,IKVM.Internal,DotNetTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,LazyPublishMembers,The length of the statement  "				FieldInfo[] fields = type.GetFields(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance); " is 156.
Long Statement,IKVM.Internal,DotNetTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,LazyPublishMembers,The length of the statement  "						fieldsList.Add(CreateFieldWrapperDotNet(AttributeHelper.GetModifiers(fields[i]' true).Modifiers' fields[i].Name' fields[i].FieldType' fields[i])); " is 146.
Long Statement,IKVM.Internal,DotNetTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,LazyPublishMembers,The length of the statement  "				ConstructorInfo[] constructors = type.GetConstructors(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance); " is 174.
Long Statement,IKVM.Internal,DotNetTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,LazyPublishMembers,The length of the statement  "				MethodInfo[] methods = type.GetMethods(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance); " is 159.
Long Statement,IKVM.Internal,DotNetTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,LazyPublishMembers,The length of the statement  "									// HACK we need to link here' because during a core library build we might reference java.lang.AutoCloseable (via IDisposable) before it has been linked " is 152.
Long Statement,IKVM.Internal,DotNetTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,LazyPublishMembers,The length of the statement  "											throw new InvalidOperationException("Missing protected method support for " + baseTypeWrapper.Name + "::" + m.Name + m.Signature); " is 130.
Long Statement,IKVM.Internal,DotNetTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,LazyPublishMembers,The length of the statement  "					methodsList.Add("writeReplace()Ljava.lang.Object;"' new SimpleCallMethodWrapper(this' "writeReplace"' "()Ljava.lang.Object;"' " is 125.
Long Statement,IKVM.Internal,DotNetTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,LazyPublishMembers,The length of the statement  "						typeof(ikvm.@internal.Serialization).GetMethod("writeReplace")' CoreClasses.java.lang.Object.Wrapper' TypeWrapper.EmptyArray' " is 125.
Long Statement,IKVM.Internal,DotNetTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,CreateMethodWrapper,The length of the statement  "				MethodWrapper mw = new SimpleCallMethodWrapper(this' "finalize"' "()V"' (MethodInfo)mb' PrimitiveTypeWrapper.VOID' TypeWrapper.EmptyArray' mods' MemberFlags.None' SimpleOpCode.Call' SimpleOpCode.Callvirt); " is 205.
Long Statement,IKVM.Internal,DotNetTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,CreateMethodWrapper,The length of the statement  "					return new SmartConstructorMethodWrapper(this' name' sig' (ConstructorInfo)mb' argTypeWrappers' mods' MemberFlags.None); " is 120.
Long Statement,IKVM.Internal,DotNetTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,CreateMethodWrapper,The length of the statement  "					return new SmartCallMethodWrapper(this' name' sig' (MethodInfo)mb' retTypeWrapper' argTypeWrappers' mods' MemberFlags.None' SimpleOpCode.Call' SimpleOpCode.Callvirt); " is 166.
Long Statement,IKVM.Internal,EnumFieldWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,EmitGetImpl,The length of the statement  "					ilgen.Emit(OpCodes.Call' typeofByteCodeHelper.GetMethod("GetDotNetEnumField").MakeGenericMethod(this.DeclaringType.TypeAsBaseType)); " is 132.
Long Statement,IKVM.Internal,AttributeAnnotationTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,LazyPublishMembers,The length of the statement  "					methods.Add(new AttributeAnnotationMethodWrapper(this' "value"' singleOneArgCtor.GetParameters()[0].ParameterType' defCtor != null)); " is 133.
Long Statement,IKVM.Internal,AttributeAnnotationTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,GetAttributeUsage,The length of the statement  "						if (cad.ConstructorArguments.Count == 1 && cad.ConstructorArguments[0].ArgumentType == JVM.Import(typeof(AttributeTargets))) " is 124.
Long Statement,IKVM.Internal,ReturnValueAnnotationTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,LazyPublishMembers,The length of the statement  "					SetMethods(new MethodWrapper[] { new DynamicOnlyMethodWrapper(this' "value"' "()" + tw.SigName' tw' TypeWrapper.EmptyArray' MemberFlags.None) }); " is 145.
Long Statement,IKVM.Internal,MultipleAnnotationTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,LazyPublishMembers,The length of the statement  "					SetMethods(new MethodWrapper[] { new DynamicOnlyMethodWrapper(this' "value"' "()" + tw.SigName' tw' TypeWrapper.EmptyArray' MemberFlags.None) }); " is 145.
Long Statement,IKVM.Internal,AttributeAnnotation,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,Apply,The length of the statement  "						loader.IssueMessage(Message.IgnoredCustomAttribute' type.FullName' "Type '" + tb.FullName + "' does not extend cli.System.Object"); " is 131.
Long Statement,IKVM.Internal,AttributeAnnotation,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,Apply,The length of the statement  "						Tracer.Error(Tracer.Runtime' "StructLayoutAttribute cannot be applied to {0}' because it does not directly extend cli.System.Object"' tb.FullName); " is 147.
Long Statement,IKVM.Internal,DelegateMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,EmitIntrinsic,The length of the statement  "				MethodWrapper mw = targetType.GetMethodWrapper(GetDelegateInvokeStubName(DeclaringType.TypeAsTBD)' iface.GetMethods()[0].Signature' true); " is 138.
Long Statement,IKVM.Internal,DelegateMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,CreateErrorStub,The length of the statement  "				ilgen.EmitThrow(isAbstract ? "java.lang.AbstractMethodError" : "java.lang.IllegalAccessError"' targetType.Name + ".Invoke" + iface.GetMethods()[0].Signature); " is 158.
Long Statement,IKVM.Internal,EnumValueFieldWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,EmitGetImpl,The length of the statement  "				// NOTE if the reference on the stack is null' we *want* the NullReferenceException' so we don't use TypeWrapper.EmitUnbox " is 122.
Long Statement,IKVM.Internal,CloneMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,EmitCall,The length of the statement  "				ilgen.Emit(OpCodes.Call' Types.Object.GetMethod("MemberwiseClone"' BindingFlags.Instance | BindingFlags.NonPublic' null' Type.EmptyTypes' null)); " is 145.
Long Statement,IKVM.Internal,DynamicClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicClassLoader.cs,DefineProxyHelper,The length of the statement  "				proxyHelperContainer = moduleBuilder.DefineType("__<Proxy>"' TypeAttributes.Public | TypeAttributes.Interface | TypeAttributes.Abstract); " is 137.
Long Statement,IKVM.Internal,DynamicClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicClassLoader.cs,DefineProxyHelper,The length of the statement  "			proxyHelpers.Add(proxyHelperContainer.DefineNestedType(TypeNameUtil.MangleNestedTypeName(type.FullName)' TypeAttributes.NestedPublic | TypeAttributes.Interface | TypeAttributes.Abstract' null' new Type[] { type })); " is 215.
Long Statement,IKVM.Internal,DynamicClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicClassLoader.cs,DefineProxy,The length of the statement  "				proxiesContainer = moduleBuilder.DefineType("__<Proxies>"' TypeAttributes.Public | TypeAttributes.Class | TypeAttributes.Sealed | TypeAttributes.Abstract); " is 155.
Long Statement,IKVM.Internal,DynamicClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicClassLoader.cs,DefineProxy,The length of the statement  "			TypeBuilder tb = proxiesContainer.DefineNestedType(GetProxyNestedName(interfaces)' TypeAttributes.NestedPublic | TypeAttributes.Class | TypeAttributes.Sealed' proxyClass.TypeAsBaseType' ifaces); " is 194.
Long Statement,IKVM.Internal,DynamicClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicClassLoader.cs,DefineUnloadable,The length of the statement  "				type = unloadableContainer.DefineNestedType(TypeNameUtil.MangleNestedTypeName(name)' TypeAttributes.NestedPrivate | TypeAttributes.Interface | TypeAttributes.Abstract); " is 168.
Long Statement,IKVM.Internal,DynamicTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,VerifyDelegate,The length of the statement  "			if (beginInvoke != null && beginInvoke.Signature != invoke.Signature.Substring(0' invoke.Signature.IndexOf(')')) + "Lcli.System.AsyncCallback;Ljava.lang.Object;)Lcli.System.IAsyncResult;") " is 188.
Long Statement,IKVM.Internal,DynamicTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,VerifyDelegate,The length of the statement  "			if (endInvoke != null && endInvoke.Signature != "(Lcli.System.IAsyncResult;)" + invoke.Signature.Substring(invoke.Signature.IndexOf(')') + 1)) " is 142.
Long Statement,IKVM.Internal,DynamicTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GenerateOverrideStub,The length of the statement  "			MethodBuilder overrideStub = baseMethod.GetDefineMethodHelper().DefineMethod(this' typeBuilder' "__<overridestub>" + baseMethod.Name' MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.NewSlot | MethodAttributes.Final); " is 239.
Long Statement,IKVM.Internal,DynamicTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GetModOpt,The length of the statement  "					// (note that in this case we only add the custom modifiers to make the signature unique' we never read back this information) " is 126.
Long Statement,IKVM.Internal,DynamicTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,NeedsType2AccessStub,The length of the statement  "			return (fw.HasNonPublicTypeInSignature || (fw.IsFinal && !classLoader.StrictFinalFieldSemantics && !(fw is ConstantFieldWrapper) && !(fw is DynamicPropertyFieldWrapper))) " is 170.
Long Statement,IKVM.Internal,DynamicTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,NeedsType2AccessStub,The length of the statement  "				&& (fw.FieldTypeWrapper.IsUnloadable || fw.FieldTypeWrapper.IsAccessibleFrom(this) || fw.FieldTypeWrapper.InternalsVisibleTo(this)); " is 132.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,CreateStep1,The length of the statement  "						methods[i] = new SmartCallMethodWrapper(wrapper' m.Name' m.Signature' null' null' null' m.Modifiers' flags' SimpleOpCode.Call' SimpleOpCode.Callvirt); " is 150.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,CreateStep1,The length of the statement  "						fields[i] = new ConstantFieldWrapper(wrapper' fieldType' fld.Name' fld.Signature' fld.Modifiers' null' fld.ConstantValue' MemberFlags.None); " is 140.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,CreateStep1,The length of the statement  "						fields[i] = FieldWrapper.Create(wrapper' null' null' fld.Name' fld.Signature' new ExModifiers(fld.Modifiers' fld.IsInternal)); " is 126.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,CreateStep2,The length of the statement  "								Tracer.Warning(Tracer.Compiler' "Unable to load outer class {0} for inner class {1} ({2}: {3})"' outerClassName' f.Name' x.GetType().Name' x.Message); " is 150.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,CreateStep2,The length of the statement  "					// When we're statically compiling' we associate the typeBuilder with the wrapper. This enables types in referenced assemblies to refer back to " is 143.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,CreateStep2,The length of the statement  "					// types that we're currently compiling (i.e. a cyclic dependency between the currently assembly we're compiling and a referenced assembly). " is 140.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,CreateStep2,The length of the statement  "						enumBuilder = typeBuilder.DefineNestedType(name' TypeAttributes.Class | TypeAttributes.Sealed | TypeAttributes.NestedPublic | TypeAttributes.Serializable' Types.Enum); " is 167.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,CreateStep2,The length of the statement  "						enumBuilder.DefineField("value__"' Types.Int32' FieldAttributes.Public | FieldAttributes.SpecialName | FieldAttributes.RTSpecialName); " is 134.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,CreateStep2,The length of the statement  "								FieldBuilder fieldBuilder = enumBuilder.DefineField(f.Fields[i].Name' enumBuilder' FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.Literal); " is 158.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,CreateStep2,The length of the statement  "						AttributeHelper.SetEnclosingMethodAttribute(typeBuilder' classFile.EnclosingMethod[0]' classFile.EnclosingMethod[1]' classFile.EnclosingMethod[2]); " is 147.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,CreateStep2,The length of the statement  "					if (setModifiers || classFile.IsInternal || (classFile.Modifiers & (Modifiers.Synthetic | Modifiers.Annotation | Modifiers.Enum)) != 0) " is 135.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,CreateStep2,The length of the statement  "						// so we prevent inlining for now (it also turns out that on x86 not inlining this method actually has a positive perf impact in some cases...) " is 143.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,AddMirandaMethods,The length of the statement  "									mw = new SmartCallMethodWrapper(wrapper' ifmethod.Name' ifmethod.Signature' null' null' null' Modifiers.Public | Modifiers.Abstract' MemberFlags.HideFromReflection | MemberFlags.MirandaMethod' SimpleOpCode.Call' SimpleOpCode.Callvirt); " is 235.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,AddDelegateInvokeStubs,The length of the statement  "						MethodWrapper mw = new DelegateInvokeStubMethodWrapper(wrapper' iface.DeclaringTypeWrapper.TypeAsBaseType' iface.GetMethods()[0].Signature); " is 140.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,CheckLoaderConstraints,The length of the statement  "							((UnloadableTypeWrapper)mw.ReturnType).SetCustomModifier(((UnloadableTypeWrapper)baseMethod.ReturnType).CustomModifier); " is 120.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,CheckLoaderConstraints,The length of the statement  "						StaticCompiler.LinkageError("Method \"{2}.{3}{4}\" has a return type \"{0}\" and tries to override method \"{5}.{3}{4}\" that has a return type \"{1}\""' mw.ReturnType' baseMethod.ReturnType' mw.DeclaringType.Name' mw.Name' mw.Signature' baseMethod.DeclaringType.Name); " is 269.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,CheckLoaderConstraints,The length of the statement  "							StaticCompiler.LinkageError("Method \"{2}.{3}{4}\" has an argument type \"{0}\" and tries to override method \"{5}.{3}{4}\" that has an argument type \"{1}\""' here[i]' there[i]' mw.DeclaringType.Name' mw.Name' mw.Signature' baseMethod.DeclaringType.Name); " is 256.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,LinkField,The length of the statement  "						CustomAttributeBuilder transientAttrib = new CustomAttributeBuilder(JVM.Import(typeof(NonSerializedAttribute)).GetConstructor(Type.EmptyTypes)' new object[0]); " is 159.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FinishCore,The length of the statement  "						// before we bake our type' we need to link any inner annotations to allow them to create their attribute type (as a nested type) " is 129.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FinishCore,The length of the statement  "						CustomAttributeBuilder cab = new CustomAttributeBuilder(JVM.LoadType(typeof(AnnotationAttributeAttribute)).GetConstructor(new Type[] { Types.String })' new object[] { annotationBuilder.AttributeTypeName }); " is 206.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FinishCore,The length of the statement  "						// In dynamic mode' we may need to emit a call to this method from a DynamicMethod which doesn't support calling unfinished methods' " is 132.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FinishCore,The length of the statement  "						finishedClinitMethod = type.GetMethod("__<clinit>"' BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic); " is 120.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FinishCore,The length of the statement  "					finishedType = new FinishedTypeImpl(type' innerClassesTypeWrappers' declaringTypeWrapper' wrapper.ReflectiveModifiers' Metadata.Create(classFile)' finishedClinitMethod' finalizeMethod); " is 185.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,DefineClassInitializer,The length of the statement  "					// NOTE it turns out that on .NET 2.0 this isn't necessary anymore (neither Ref.Emit nor the CLR verifier complain about it)' " is 125.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,DefineClassInitializer,The length of the statement  "					// but the C# compiler still considers interfaces with non-public methods to be invalid' so to keep interop with C# we have " is 123.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,DefineClassInitializer,The length of the statement  "					return typeBuilder.DefineConstructor(MethodAttributes.Static | MethodAttributes.Public' CallingConventions.Standard' Type.EmptyTypes); " is 134.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FindBaseMethods7,The length of the statement  "					else if (baseMethod.IsFinal && (baseMethod.IsPublic || baseMethod.IsProtected || baseMethod.DeclaringType.IsPackageAccessibleFrom(wrapper))) " is 140.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FindBaseMethods7,The length of the statement  "						throw new VerifyError("final method " + baseMethod.Name + baseMethod.Signature + " in " + baseMethod.DeclaringType.Name + " is overridden in " + wrapper.Name); " is 159.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FindBaseMethods7,The length of the statement  "					else if (topPublicOrProtectedMethod == null && !baseMethod.IsPublic && !baseMethod.IsProtected && !baseMethod.DeclaringType.IsPackageAccessibleFrom(wrapper)) " is 157.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FindBaseMethods7,The length of the statement  "						// this is a package private method that we're not overriding (unless its vtable stream interleaves ours' which is a case we handle below) " is 138.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FindBaseMethods7,The length of the statement  "					else if (topPublicOrProtectedMethod != null && baseMethod.IsFinal && !baseMethod.IsPublic && !baseMethod.IsProtected && !baseMethod.DeclaringType.IsPackageAccessibleFrom(wrapper)) " is 179.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FindBaseMethods7,The length of the statement  "						// this is package private final method that we would override had it not been final' but which is ignored by HotSpot (instead of throwing a VerifyError) " is 153.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FindBaseMethods7,The length of the statement  "								MethodWrapper baseMethod3 = GetPackageBaseMethod(baseMethod.DeclaringType.BaseTypeWrapper' name' sig' baseMethod2.DeclaringType); " is 129.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FindBaseMethods7,The length of the statement  "							// if TryGetClassFileVersion fails' we know that it is safe to call GetMethod() so we look at the actual method attributes here' " is 128.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FindBaseMethods7,The length of the statement  "							// because access widing ensures that if the method had overridden the top level method it would also be public or protected " is 124.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FindBaseMethods7,The length of the statement  "							// this means that baseMethod is part of a class with a major version < 51' so we have to explicitly override the top level method as well " is 138.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FindBaseMethods7,The length of the statement  "							// (we don't need to look for another package method to override' because by necessity baseMethod is already in our package) " is 124.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FindBaseMethods7,The length of the statement  "										throw new VerifyError("final method " + baseMethod2.Name + baseMethod2.Signature + " in " + baseMethod2.DeclaringType.Name + " is overridden in " + wrapper.Name); " is 162.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FindBaseMethodsLegacy,The length of the statement  "						throw new VerifyError("final method " + baseMethod.Name + baseMethod.Signature + " in " + baseMethod.DeclaringType.Name + " is overridden in " + wrapper.Name); " is 159.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FindBaseMethodsLegacy,The length of the statement  "										throw new VerifyError("final method " + baseMethod2.Name + baseMethod2.Signature + " in " + baseMethod2.DeclaringType.Name + " is overridden in " + wrapper.Name); " is 162.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GetBaseFinalizeMethod,The length of the statement  "				MethodInfo baseFinalize = type.GetMethod("__<Finalize>"' BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance' null' Type.EmptyTypes' null); " is 156.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GetBaseFinalizeMethod,The length of the statement  "					foreach (MethodInfo m in type.GetMethods(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly)) " is 139.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,LinkMethod,The length of the statement  "							MethodBuilder mb = methods[index].GetDefineMethodHelper().DefineMethod(wrapper' typeBuilder' methods[index].Name' MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.Abstract | MethodAttributes.CheckAccessOnOverride); " is 291.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GenerateConstructor,The length of the statement  "				ConstructorBuilder cb = mw.GetDefineMethodHelper().DefineConstructor(wrapper' typeBuilder' GetMethodAccess(mw) | MethodAttributes.HideBySig); " is 141.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GenerateMethod,The length of the statement  "					if (baseMethods[index] != null && ReferenceEquals(m.Name' StringConstants.FINALIZE) && ReferenceEquals(m.Signature' StringConstants.SIG_VOID)) " is 142.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GenerateMethod,The length of the statement  "						&& (methods[index].IsExplicitOverride || baseMethods[index][0].RealName != name || CheckRequireOverrideStub(methods[index]' baseMethods[index][0])) " is 147.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GenerateMethod,The length of the statement  "						finalizeMethod = typeBuilder.DefineMethod(finalizeName' attr' CallingConventions.Standard' Types.Void' Type.EmptyTypes); " is 120.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GenerateMethod,The length of the statement  "						CustomAttributeBuilder cab = new CustomAttributeBuilder(StaticCompiler.GetRuntimeType("IKVM.Attributes.AnnotationDefaultAttribute").GetConstructor(new Type[] { Types.Object })' new object[] { classFile.Methods[index].AnnotationDefault }); " is 238.
Long Statement,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,IsAccessBridge,The length of the statement  "				if ((m.Modifiers & (Modifiers.Abstract | Modifiers.Native | Modifiers.Public | Modifiers.Bridge)) == (Modifiers.Public | Modifiers.Bridge)) " is 139.
Long Statement,IKVM.Internal,DelegateConstructorMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,DoLink,The length of the statement  "					constructor = typeBuilder.DefineConstructor(attribs' CallingConventions.Standard' new Type[] { Types.Object' Types.IntPtr }' null' null); " is 137.
Long Statement,IKVM.Internal,DelegateInvokeStubMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,DoLink,The length of the statement  "						ilgen.EmitThrow(mw == null || mw.IsStatic ? "java.lang.AbstractMethodError" : "java.lang.IllegalAccessError"' DeclaringType.Name + ".Invoke" + Signature); " is 154.
Long Statement,IKVM.Internal,AnnotationBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Link,The length of the statement  "					TypeWrapper annotationAttributeBaseType = ClassLoaderWrapper.LoadClassCritical("ikvm.internal.AnnotationAttributeBase"); " is 120.
Long Statement,IKVM.Internal,AnnotationBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Link,The length of the statement  "						attributeTypeBuilder = outer.DefineNestedType(o.GetInnerClassName(o.outerClassWrapper.Name' name + "Attribute")' typeAttributes' annotationAttributeBaseType.TypeAsBaseType); " is 173.
Long Statement,IKVM.Internal,AnnotationBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Link,The length of the statement  "						attributeTypeBuilder = o.wrapper.classLoader.GetTypeWrapperFactory().ModuleBuilder.DefineType(name + "Attribute"' typeAttributes' annotationAttributeBaseType.TypeAsBaseType); " is 174.
Long Statement,IKVM.Internal,AnnotationBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Link,The length of the statement  "					// NOTE we "abuse" the InnerClassAttribute to add a custom attribute to name the class "$Proxy[Annotation]" in the Java world " is 125.
Long Statement,IKVM.Internal,AnnotationBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Link,The length of the statement  "					AttributeHelper.SetInnerClass(attributeTypeBuilder' o.classFile.Name.Substring(0' dotindex) + "$Proxy" + o.classFile.Name.Substring(dotindex)' Modifiers.Final); " is 160.
Long Statement,IKVM.Internal,AnnotationBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Link,The length of the statement  "															targets |= AttributeTargets.Class | AttributeTargets.Interface | AttributeTargets.Struct | AttributeTargets.Delegate | AttributeTargets.Enum; " is 141.
Long Statement,IKVM.Internal,AnnotationBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Link,The length of the statement  "											CustomAttributeBuilder cab2 = new CustomAttributeBuilder(JVM.Import(typeof(AttributeUsageAttribute)).GetConstructor(new Type[] { JVM.Import(typeof(AttributeTargets)) })' new object[] { targets }); " is 196.
Long Statement,IKVM.Internal,AnnotationBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Link,The length of the statement  "					defineConstructor = attributeTypeBuilder.DefineConstructor(MethodAttributes.Public' CallingConventions.Standard' new Type[] { JVM.Import(typeof(object[])) }); " is 158.
Long Statement,IKVM.Internal,AnnotationBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,EmitSetValueCall,The length of the statement  "					MethodWrapper setValueMethod = annotationAttributeBaseType.GetMethodWrapper("setValue"' "(Ljava.lang.String;Ljava.lang.Object;)V"' false); " is 138.
Long Statement,IKVM.Internal,AnnotationBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Finish,The length of the statement  "					TypeWrapper annotationAttributeBaseType = ClassLoaderWrapper.LoadClassCritical("ikvm.internal.AnnotationAttributeBase"); " is 120.
Long Statement,IKVM.Internal,AnnotationBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Finish,The length of the statement  "					ConstructorBuilder defaultConstructor = attributeTypeBuilder.DefineConstructor(unsupported || requiredArgCount > 0 ? MethodAttributes.Private : MethodAttributes.Public' CallingConventions.Standard' Type.EmptyTypes); " is 215.
Long Statement,IKVM.Internal,AnnotationBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Finish,The length of the statement  "							ConstructorBuilder reqArgConstructor = attributeTypeBuilder.DefineConstructor(MethodAttributes.Public' CallingConventions.Standard' args); " is 138.
Long Statement,IKVM.Internal,AnnotationBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Finish,The length of the statement  "								ConstructorBuilder cb = attributeTypeBuilder.DefineConstructor(MethodAttributes.Public' CallingConventions.Standard' new Type[] { argType }); " is 141.
Long Statement,IKVM.Internal,AnnotationBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Finish,The length of the statement  "					MethodWrapper getValueMethod = annotationAttributeBaseType.GetMethodWrapper("getValue"' "(Ljava.lang.String;)Ljava.lang.Object;"' false); " is 137.
Long Statement,IKVM.Internal,AnnotationBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Finish,The length of the statement  "					MethodWrapper getByteValueMethod = annotationAttributeBaseType.GetMethodWrapper("getByteValue"' "(Ljava.lang.String;)B"' false); " is 128.
Long Statement,IKVM.Internal,AnnotationBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Finish,The length of the statement  "					MethodWrapper getBooleanValueMethod = annotationAttributeBaseType.GetMethodWrapper("getBooleanValue"' "(Ljava.lang.String;)Z"' false); " is 134.
Long Statement,IKVM.Internal,AnnotationBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Finish,The length of the statement  "					MethodWrapper getCharValueMethod = annotationAttributeBaseType.GetMethodWrapper("getCharValue"' "(Ljava.lang.String;)C"' false); " is 128.
Long Statement,IKVM.Internal,AnnotationBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Finish,The length of the statement  "					MethodWrapper getShortValueMethod = annotationAttributeBaseType.GetMethodWrapper("getShortValue"' "(Ljava.lang.String;)S"' false); " is 130.
Long Statement,IKVM.Internal,AnnotationBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Finish,The length of the statement  "					MethodWrapper getIntValueMethod = annotationAttributeBaseType.GetMethodWrapper("getIntValue"' "(Ljava.lang.String;)I"' false); " is 126.
Long Statement,IKVM.Internal,AnnotationBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Finish,The length of the statement  "					MethodWrapper getFloatValueMethod = annotationAttributeBaseType.GetMethodWrapper("getFloatValue"' "(Ljava.lang.String;)F"' false); " is 130.
Long Statement,IKVM.Internal,AnnotationBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Finish,The length of the statement  "					MethodWrapper getLongValueMethod = annotationAttributeBaseType.GetMethodWrapper("getLongValue"' "(Ljava.lang.String;)J"' false); " is 128.
Long Statement,IKVM.Internal,AnnotationBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Finish,The length of the statement  "					MethodWrapper getDoubleValueMethod = annotationAttributeBaseType.GetMethodWrapper("getDoubleValue"' "(Ljava.lang.String;)D"' false); " is 132.
Long Statement,IKVM.Internal,AnnotationBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Finish,The length of the statement  "							MethodBuilder mb = o.methods[i].GetDefineMethodHelper().DefineMethod(o.wrapper' attributeTypeBuilder' o.methods[i].Name' MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final | MethodAttributes.NewSlot); " is 226.
Long Statement,IKVM.Internal,AnnotationBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Finish,The length of the statement  "									PropertyBuilder pb = attributeTypeBuilder.DefineProperty(o.methods[i].Name' PropertyAttributes.None' argType' Type.EmptyTypes); " is 127.
Long Statement,IKVM.Internal,AnnotationBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Finish,The length of the statement  "									MethodBuilder setter = attributeTypeBuilder.DefineMethod("set_" + o.methods[i].Name' MethodAttributes.Public' Types.Void' new Type[] { argType }); " is 146.
Long Statement,IKVM.Internal,AnnotationBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Finish,The length of the statement  "									MethodBuilder getter = attributeTypeBuilder.DefineMethod("get_" + o.methods[i].Name' MethodAttributes.Public' argType' Type.EmptyTypes); " is 136.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,CreateGetCallerID,The length of the statement  "				FieldBuilder callerIDField = typeBuilder.DefineField("__<callerID>"' tw.TypeAsSignatureType' FieldAttributes.Private | FieldAttributes.Static | FieldAttributes.SpecialName); " is 173.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,CreateGetCallerID,The length of the statement  "				MethodBuilder mb = typeBuilder.DefineMethod("__<GetCallerID>"' MethodAttributes.Private | MethodAttributes.Static | MethodAttributes.SpecialName' tw.TypeAsSignatureType' Type.EmptyTypes); " is 187.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FinishImpl,The length of the statement  "									while (fmw != mw && (fmw.IsStatic || fmw.IsPrivate || !(mw.DeclaringType.IsPackageAccessibleFrom(fmw.DeclaringType) || (mw.IsInternal && mw.DeclaringType.InternalsVisibleTo(fmw.DeclaringType))))) " is 195.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FinishImpl,The length of the statement  "								nativeCodeType = StaticCompiler.GetType(wrapper.GetClassLoader()' "IKVM.NativeCode." + classFile.Name.Replace('$'' '+')); " is 121.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FinishImpl,The length of the statement  "										ilGenerator.EmitThrow("java.lang.UnsatisfiedLinkError"' "Native method not implemented (compiled with -nojni): " + classFile.Name + "." + m.Name + m.Signature); " is 160.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FinishImpl,The length of the statement  "						ConstructorBuilder cb = typeBuilder.DefineConstructor(MethodAttributes.PrivateScope' CallingConventions.Standard' Type.EmptyTypes); " is 131.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FinishImpl,The length of the statement  "					tbFields = typeBuilder.DefineNestedType(name' TypeAttributes.Class | TypeAttributes.NestedPublic | TypeAttributes.Sealed | TypeAttributes.Abstract); " is 148.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FinishImpl,The length of the statement  "				// if we inherit public members from non-public base classes or have public members with non-public types in their signature' we need access stubs " is 146.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FinishImpl,The length of the statement  "				// When we're statically compiling we don't need to set the wrapper here' because we've already done so for the typeBuilder earlier. " is 132.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GenerateAccessStub,The length of the statement  "					FieldBuilder fb = typeBuilder.DefineField(fw.Name' fw.FieldTypeWrapper.TypeAsSignatureType' null' new Type[] { JVM.LoadType(typeof(IKVM.Attributes.AccessStub)) }' attribs); " is 172.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GenerateAccessStub,The length of the statement  "					PropertyBuilder pb = typeBuilder.DefineProperty(fw.Name' PropertyAttributes.None' propType' null' modopt' Type.EmptyTypes' null' null); " is 135.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GenerateAccessStub,The length of the statement  "					MethodBuilder getter = typeBuilder.DefineMethod("get_" + fw.Name' attribs' CallingConventions.Standard' propType' null' modopt2' Type.EmptyTypes' null' null); " is 158.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GenerateAccessStub,The length of the statement  "						MethodBuilder setter = typeBuilder.DefineMethod("set_" + fw.Name' attribs' CallingConventions.Standard' null' null' null' new Type[] { propType }' null' new Type[][] { modopt2 }); " is 179.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GenerateAccessStub,The length of the statement  "						// we don't do a DynamicCast if fw.FieldTypeWrapper is unloadable' because for normal unloadable fields we don't enfore the type either " is 135.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GenerateAccessStub,The length of the statement  "				MethodBuilder mb = typeBuilder.DefineMethod(name' stubattribs' CallingConventions.Standard' returnType' null' modoptReturnType' parameterTypes' null' modopt); " is 158.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,ImplementInterfaceMethodStubImpl,The length of the statement  "				// prevent clashes with overloaded method stubs that are erased to the same signature (e.g. unloadable types and ghost arrays) " is 126.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,ImplementInterfaceMethodStubImpl,The length of the statement  "				// HACK the signature and name are the wrong way around to work around a C++/CLI bug (apparantely it looks looks at the last n " is 126.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,ImplementInterfaceMethodStubImpl,The length of the statement  "						// UPDATE unfortunately' according to Serge Lidin the spec is correct' and it is not allowed to have virtual privatescope " is 121.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,ImplementInterfaceMethodStubImpl,The length of the statement  "					if (!wrapper.IsAbstract || (!baseClassInterface && wrapper.GetMethodWrapper(ifmethod.Name' ifmethod.Signature' false) != null)) " is 127.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,DefineInterfaceStubMethod,The length of the statement  "				return mw.GetDefineMethodHelper().DefineMethod(wrapper' typeBuilder' name' MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.Final); " is 209.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,EmitCallerIDStub,The length of the statement  "				// we don't need to support custom modifiers' because there aren't any callerid methods that have parameter types that require a custom modifier " is 144.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,EmitCallerIDStub,The length of the statement  "						ParameterBuilder pb = mb.DefineParameter(mw.IsStatic ? i + 1 : i' ParameterAttributes.None' parameterNames[mw.IsStatic ? i : i - 1]); " is 133.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,EmitCallerIDStub,The length of the statement  "				MethodWrapper callerID = CoreClasses.ikvm.@internal.CallerID.Wrapper.GetMethodWrapper("create"' "(Lcli.System.Diagnostics.StackFrame;)Likvm.internal.CallerID;"' false); " is 168.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,ImplementInterfaces,The length of the statement  "									&& !wrapper.ImplementsInterface(ClassLoaderWrapper.GetWrapperFromType(JVM.Import(typeof(System.Collections.IEnumerable))))) " is 123.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,ImplementInterfaces,The length of the statement  "									TypeWrapper enumeratorType = ClassLoaderWrapper.GetBootstrapClassLoader().LoadClassByDottedNameFast("ikvm.lang.IterableEnumerator"); " is 132.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,ImplementInterfaces,The length of the statement  "										// FXBUG we're using the same method name as the C# compiler here because both the .NET and Mono implementations of Xml serialization depend on this method name " is 160.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,ImplementInterfaces,The length of the statement  "										MethodBuilder mb = typeBuilder.DefineMethod("System.Collections.IEnumerable.GetEnumerator"' MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.NewSlot | MethodAttributes.Final | MethodAttributes.SpecialName' JVM.Import(typeof(System.Collections.IEnumerator))' Type.EmptyTypes); " is 297.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,ImplementInterfaces,The length of the statement  "								MethodBuilder mb = typeBuilder.DefineMethod("op_Implicit"' MethodAttributes.HideBySig | MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.SpecialName' iface.TypeAsSignatureType' new Type[] { wrapper.TypeAsSignatureType }); " is 241.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,AddUnsupportedAbstractMethods,The length of the statement  "				foreach (MethodBase mb in wrapper.BaseTypeWrapper.TypeAsBaseType.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance)) " is 146.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GenerateUnsupportedAbstractMethodStub,The length of the statement  "				MethodBuilder m = typeBuilder.DefineMethod("__<unsupported>" + mb.DeclaringType.FullName + "/" + mb.Name' attr' ((MethodInfo)mb).ReturnType' parameterTypes); " is 157.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GenerateUnsupportedAbstractMethodStub,The length of the statement  "				ilgen.EmitThrow("java.lang.AbstractMethodError"' "Method " + mb.DeclaringType.FullName + "." + mb.Name + " is unsupported by IKVM."); " is 133.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,CompileConstructorBody,The length of the statement  "				Compiler.Compile(context' wrapper' methods[methodIndex]' classFile' m' ilGenerator' ref nonLeaf' invokespecialstubcache); " is 121.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,EmitCallerIDInitialization,The length of the statement  "						MethodWrapper create = tw.GetMethodWrapper("create"' "(Lcli.System.RuntimeTypeHandle;)Likvm.internal.CallerID;"' false); " is 120.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,EmitCreateCallerID,The length of the statement  "				TypeBuilder typeCallerID = typeBuilder.DefineNestedType("__<CallerID>"' TypeAttributes.Sealed | TypeAttributes.NestedPrivate' tw.TypeAsBaseType); " is 145.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,DefineThreadLocalType,The length of the statement  "				TypeBuilder tb = typeBuilder.DefineNestedType("__<tls>_" + id' TypeAttributes.NestedPrivate | TypeAttributes.Sealed' threadLocal.TypeAsBaseType); " is 145.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,DefineThreadLocalType,The length of the statement  "				fb.SetCustomAttribute(new CustomAttributeBuilder(JVM.Import(typeof(ThreadStaticAttribute)).GetConstructor(Type.EmptyTypes)' new object[0])); " is 140.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,DefineThreadLocalType,The length of the statement  "				MethodBuilder mbGet = tb.DefineMethod("get"' MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.Final' Types.Object' Type.EmptyTypes); " is 153.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,DefineThreadLocalType,The length of the statement  "				MethodBuilder mbSet = tb.DefineMethod("set"' MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.Final' null' new Type[] { Types.Object }); " is 157.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GetAtomicReferenceFieldUpdater,The length of the statement  "					TypeWrapper arfuTypeWrapper = ClassLoaderWrapper.LoadClassCritical("ikvm.internal.IntrinsicAtomicReferenceFieldUpdater"); " is 121.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GetAtomicReferenceFieldUpdater,The length of the statement  "					TypeBuilder tb = typeBuilder.DefineNestedType("__<ARFU>_" + arfuMap.Count' TypeAttributes.NestedPrivate | TypeAttributes.Sealed' arfuTypeWrapper.TypeAsBaseType); " is 161.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,DefineIndyCallSiteType,The length of the statement  "				TypeBuilder tb = typeBuilder.DefineNestedType("__<>IndyCS" + id' TypeAttributes.NestedPrivate | TypeAttributes.Abstract | TypeAttributes.Sealed | TypeAttributes.BeforeFieldInit); " is 178.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,DefineMethodHandleConstantType,The length of the statement  "				TypeBuilder tb = typeBuilder.DefineNestedType("__<>MHC" + index' TypeAttributes.NestedPrivate | TypeAttributes.Sealed | TypeAttributes.Abstract | TypeAttributes.BeforeFieldInit); ; " is 180.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,DefineMethodHandleDispatchStub,The length of the statement  "				return typeBuilder.DefineMethod("__<>MHC"' MethodAttributes.Static | MethodAttributes.PrivateScope' returnType' parameterTypes); " is 128.
Long Statement,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,DefineDelegateInvokeErrorStub,The length of the statement  "				return typeBuilder.DefineMethod("__<>"' MethodAttributes.PrivateScope | MethodAttributes.Static' returnType' parameterTypes); " is 125.
Long Statement,IKVM.Internal,JniBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Generate,The length of the statement  "					FieldBuilder methodPtr = typeBuilder.DefineField("__<jniptr>" + m.Name + sig' Types.IntPtr' FieldAttributes.Static | FieldAttributes.PrivateScope); " is 147.
Long Statement,IKVM.Internal,DefineMethodHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,DefineMethod,The length of the statement  "			return tb.DefineMethod(name' attribs' CallingConventions.Standard' mw.ReturnType.TypeAsSignatureType' null' modoptReturnType' parameterTypes' null' modopt); " is 156.
Long Statement,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,Register,The length of the statement  "			intrinsics.Add(new IntrinsicKey("java.lang.Class"' "getDeclaredField"' "(Ljava.lang.String;)Ljava.lang.reflect.Field;")' Class_getDeclaredField); " is 145.
Long Statement,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,Register,The length of the statement  "			intrinsics.Add(new IntrinsicKey("java.lang.System"' "arraycopy"' "(Ljava.lang.Object;ILjava.lang.Object;II)V")' System_arraycopy); " is 130.
Long Statement,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,Register,The length of the statement  "			intrinsics.Add(new IntrinsicKey("java.util.concurrent.atomic.AtomicReferenceFieldUpdater"' "newUpdater"' "(Ljava.lang.Class;Ljava.lang.Class;Ljava.lang.String;)Ljava.util.concurrent.atomic.AtomicReferenceFieldUpdater;")' AtomicReferenceFieldUpdater_newUpdater); " is 261.
Long Statement,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,Register,The length of the statement  "			intrinsics.Add(new IntrinsicKey("sun.reflect.Reflection"' "getCallerClass"' "(I)Ljava.lang.Class;")' Reflection_getCallerClass); " is 128.
Long Statement,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,Register,The length of the statement  "			intrinsics.Add(new IntrinsicKey("java.lang.ClassLoader"' "getCallerClassLoader"' "()Ljava.lang.ClassLoader;")' ClassLoader_getCallerClassLoader); " is 145.
Long Statement,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,Register,The length of the statement  "			intrinsics.Add(new IntrinsicKey("ikvm.internal.CallerID"' "getCallerID"' "()Likvm.internal.CallerID;")' CallerID_getCallerID); " is 126.
Long Statement,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,Register,The length of the statement  "			intrinsics.Add(new IntrinsicKey("ikvm.runtime.Util"' "getInstanceTypeFromClass"' "(Ljava.lang.Class;)Lcli.System.Type;")' Util_getInstanceTypeFromClass); " is 153.
Long Statement,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,Register,The length of the statement  "			intrinsics.Add(new IntrinsicKey("java.lang.Class"' "getPrimitiveClass"' "(Ljava.lang.String;)Ljava.lang.Class;")' Class_getPrimitiveClass); " is 139.
Long Statement,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,Register,The length of the statement  "			intrinsics.Add(new IntrinsicKey("sun.misc.Unsafe"' "ensureClassInitialized"' "(Ljava.lang.Class;)V")' Unsafe_ensureClassInitialized); " is 133.
Long Statement,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,IsIntrinsic,The length of the statement  "			return intrinsics.ContainsKey(new IntrinsicKey(mw)) && mw.DeclaringType.GetClassLoader() == CoreClasses.java.lang.Object.Wrapper.GetClassLoader(); " is 146.
Long Statement,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,Object_getClass,The length of the statement  "				&& (IsSafeForGetClassOptimization(eic.GetStackTypeWrapper(0' 0)) || IsSafeForGetClassOptimization(eic.GetStackTypeWrapper(2' 0)))) " is 130.
Long Statement,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,Class_getDeclaredField,The length of the statement  "				if (cpi.Class == "sun.misc.Unsafe" && cpi.Name == "objectFieldOffset" && cpi.Signature == "(Ljava.lang.reflect.Field;)J") " is 121.
Long Statement,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,AtomicReferenceFieldUpdater_newUpdater,The length of the statement  "			return AtomicReferenceFieldUpdaterEmitter.Emit(eic.Context' eic.Caller.DeclaringType' eic.Emitter' eic.ClassFile' eic.OpcodeIndex' eic.Code' eic.Flags); " is 152.
Long Statement,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,EmitLoadCharArrayLiteral,The length of the statement  "					TypeBuilder tb = mod.DefineType(typename' TypeAttributes.Sealed | TypeAttributes.Class | TypeAttributes.ExplicitLayout | TypeAttributes.NotPublic' Types.ValueType' PackingSize.Size1' length); " is 191.
Long Statement,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,EmitLoadCharArrayLiteral,The length of the statement  "			// NOTE this also means that this will only work during static compilation' because ModuleBuilder.CreateGlobalFunctions() must " is 126.
Long Statement,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,EmitLoadCharArrayLiteral,The length of the statement  "			ilgen.Emit(OpCodes.Call' JVM.Import(typeof(System.Runtime.CompilerServices.RuntimeHelpers)).GetMethod("InitializeArray"' new Type[] { Types.Array' JVM.Import(typeof(RuntimeFieldHandle)) })); " is 190.
Long Statement,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,Reflection_getCallerClass,The length of the statement  "				MethodWrapper mw = CoreClasses.ikvm.@internal.CallerID.Wrapper.GetMethodWrapper("getCallerClass"' "()Ljava.lang.Class;"' false); " is 128.
Long Statement,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,ClassLoader_getCallerClassLoader,The length of the statement  "				MethodWrapper mw = CoreClasses.ikvm.@internal.CallerID.Wrapper.GetMethodWrapper("getCallerClassLoader"' "()Ljava.lang.ClassLoader;"' false); " is 140.
Long Statement,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,ThreadLocal_new,The length of the statement  "			// it is only valid to replace a ThreadLocal instantiation by our ThreadStatic based version' if we can prove that the instantiation only happens once " is 150.
Long Statement,IKVM.Internal,IntrinsicKey,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,Equals,The length of the statement  "				return ReferenceEquals(className' other.className) && ReferenceEquals(methodName' other.methodName) && ReferenceEquals(methodSignature' other.methodSignature); " is 159.
Long Statement,IKVM.Internal,JsrInliner,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\JsrInliner.cs,InlineJsrs,The length of the statement  "				// note that we're also (needlessly) processing the subroutines here' but that shouldn't be a problem (just a minor waste of cpu) " is 129.
Long Statement,IKVM.Internal,JsrInliner,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\JsrInliner.cs,InlineJsrs,The length of the statement  "			List<ClassFile.Method.ExceptionTableEntry> exceptions = new List<ClassFile.Method.ExceptionTableEntry>(m.ExceptionTable); " is 121.
Long Statement,IKVM.Internal,SubroutineCall,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\JsrInliner.cs,InlineSubroutine,The length of the statement  "									int subid = inliner.ma.GetLocalTypeWrapper(instructionIndex' inliner.m.Instructions[instructionIndex].TargetIndex).SubroutineIndex; " is 131.
Long Statement,IKVM.Internal,SubroutineCall,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\JsrInliner.cs,DoExceptions,The length of the statement  "						ClassFile.Method.ExceptionTableEntry newEntry = new ClassFile.Method.ExceptionTableEntry(start' end' branchMap[entry.handlerIndex]' entry.catch_type' entry.ordinal); " is 165.
Long Statement,IKVM.Internal,InstructionState,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\JsrInliner.cs,CopyLocalsAndSubroutines,The length of the statement  "					InstructionState copy = new InstructionState(new SimpleType[stack.Length]' 0' stack.Length' locals' subroutines' callsites); " is 124.
Long Statement,IKVM.Internal,MethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\MemberWrapper.cs,Create,The length of the statement  "				return new SmartConstructorMethodWrapper(declaringType' name' sig' (ConstructorInfo)method' parameterTypes' modifiers' flags); " is 126.
Long Statement,IKVM.Internal,MethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\MemberWrapper.cs,Create,The length of the statement  "				return new SmartCallMethodWrapper(declaringType' name' sig' (MethodInfo)method' returnType' parameterTypes' modifiers' flags' SimpleOpCode.Call' method.IsStatic ? SimpleOpCode.Call : SimpleOpCode.Callvirt); " is 206.
Long Statement,IKVM.Internal,MethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\MemberWrapper.cs,UpdateNonPublicTypeInSignatureFlag,The length of the statement  "			if ((IsPublic || IsProtected) && (returnTypeWrapper != null && parameterTypeWrappers != null) && !(this is AccessStubMethodWrapper) && !(this is AccessStubConstructorMethodWrapper)) " is 181.
Long Statement,IKVM.Internal,MethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\MemberWrapper.cs,AssertLinked,The length of the statement  "			Debug.Assert(parameterTypeWrappers != null && returnTypeWrapper != null' this.DeclaringType.Name + "::" + this.Name + this.Signature); " is 134.
Long Statement,IKVM.Internal,FieldWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\MemberWrapper.cs,AssertLinked,The length of the statement  "				Tracer.Error(Tracer.Runtime' "AssertLinked failed: " + this.DeclaringType.Name + "::" + this.Name + " (" + this.Signature + ")"); " is 129.
Long Statement,IKVM.Internal,DynamicPropertyFieldWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\MemberWrapper.cs,GetMethod,The length of the statement  "				Tracer.Error(Tracer.Compiler' "Property '{0}' accessor '{1}' not found in class '{2}'"' this.Name' name' this.DeclaringType.Name); " is 130.
Long Statement,IKVM.Internal,ReflectUtil,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ReflectUtil.cs,IsDynamicAssembly,The length of the statement  "					get_IsDynamic = (Predicate<Assembly>)Delegate.CreateDelegate(typeof(Predicate<Assembly>)' typeof(Assembly).GetMethod("get_IsDynamic")); " is 135.
Long Statement,IKVM.Internal,RuntimeHelperTypes,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\RuntimeHelperTypes.cs,EmitClassLiteral,The length of the statement  "			TypeBuilder tb = ccl.GetTypeWrapperFactory().ModuleBuilder.DefineType("ikvm.internal.ClassLiteral`1"' TypeAttributes.Public | TypeAttributes.Sealed | TypeAttributes.Abstract | TypeAttributes.Class | TypeAttributes.BeforeFieldInit); " is 231.
Long Statement,IKVM.Internal,RuntimeHelperTypes,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\RuntimeHelperTypes.cs,EmitClassLiteral,The length of the statement  "			classLiteralField = tb.DefineField("Value"' classType' FieldAttributes.Public | FieldAttributes.Static | FieldAttributes.InitOnly); " is 131.
Long Statement,IKVM.Internal,Serialization,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\Serialization.cs,IsSafeForAutomagicSerialization,The length of the statement  "			if (wrapper.GetMethodWrapper("GetObjectData"' "(Lcli.System.Runtime.Serialization.SerializationInfo;Lcli.System.Runtime.Serialization.StreamingContext;)V"' false) != null) " is 171.
Long Statement,IKVM.Internal,Serialization,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\Serialization.cs,IsSafeForAutomagicSerialization,The length of the statement  "			if (wrapper.GetMethodWrapper("<init>"' "(Lcli.System.Runtime.Serialization.SerializationInfo;Lcli.System.Runtime.Serialization.StreamingContext;)V"' false) != null) " is 164.
Long Statement,IKVM.Internal,Serialization,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\Serialization.cs,AddGetObjectData,The length of the statement  "			MethodBuilder getObjectData = tb.DefineMethod("GetObjectData"' MethodAttributes.Family | MethodAttributes.Virtual | MethodAttributes.NewSlot' null' " is 147.
Long Statement,IKVM.Internal,Serialization,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\Serialization.cs,AddGetObjectData,The length of the statement  "			MethodWrapper mw = serializationHelper.GetMethodWrapper("writeObject"' "(Ljava.lang.Object;Lcli.System.Runtime.Serialization.SerializationInfo;)V"' false); " is 155.
Long Statement,IKVM.Internal,Serialization,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\Serialization.cs,AddConstructor,The length of the statement  "			ConstructorBuilder ctor = tb.DefineConstructor(MethodAttributes.Family' CallingConventions.Standard' new Type[] { JVM.Import(typeof(SerializationInfo))' JVM.Import(typeof(StreamingContext)) }); " is 193.
Long Statement,IKVM.Internal,Serialization,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\Serialization.cs,AddConstructor,The length of the statement  "				MethodWrapper mw = serializationHelper.GetMethodWrapper("readObject"' "(Ljava.lang.Object;Lcli.System.Runtime.Serialization.SerializationInfo;)V"' false); " is 154.
Long Statement,IKVM.Internal,Serialization,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\Serialization.cs,AddReadResolve,The length of the statement  "				MethodBuilder getRealObject = tb.DefineMethod("IObjectReference.GetRealObject"' MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.NewSlot | MethodAttributes.Final' " is 184.
Long Statement,IKVM.Internal,Serialization,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\Serialization.cs,RemoveReadResolve,The length of the statement  "			MethodBuilder getRealObject = tb.DefineMethod("IObjectReference.GetRealObject"' MethodAttributes.Private | MethodAttributes.Virtual | MethodAttributes.NewSlot | MethodAttributes.Final' " is 184.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,GetAttributeArgsAndTypes,The length of the statement  "					Array arr = Array.CreateInstance(Type.__GetSystemType(Type.GetTypeCode(tw.ElementTypeWrapper.TypeAsArrayType))' attr.Params[i].Elements.Length); " is 144.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,CreateCustomAttribute,The length of the statement  "						propertyValues[i] = ParseValue(loader' loader.FieldTypeWrapperFromSigNoThrow(attr.Properties[i].Sig)' attr.Properties[i].Value); " is 128.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,GetEditorBrowsableNever,The length of the statement  "				editorBrowsableNever = new CustomAttributeBuilder(JVM.Import(typeof(System.ComponentModel.EditorBrowsableAttribute)).GetConstructor(new Type[] { JVM.Import(typeof(System.ComponentModel.EditorBrowsableState)) })' new object[] { (int)System.ComponentModel.EditorBrowsableState.Never }); " is 284.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,SetDeprecatedAttribute,The length of the statement  "				deprecatedAttribute = new CustomAttributeBuilder(JVM.Import(typeof(ObsoleteAttribute)).GetConstructor(Type.EmptyTypes)' new object[0]); " is 135.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,SetDeprecatedAttribute,The length of the statement  "				deprecatedAttribute = new CustomAttributeBuilder(JVM.Import(typeof(ObsoleteAttribute)).GetConstructor(Type.EmptyTypes)' new object[0]); " is 135.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,SetDeprecatedAttribute,The length of the statement  "				deprecatedAttribute = new CustomAttributeBuilder(JVM.Import(typeof(ObsoleteAttribute)).GetConstructor(Type.EmptyTypes)' new object[0]); " is 135.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,SetDeprecatedAttribute,The length of the statement  "				deprecatedAttribute = new CustomAttributeBuilder(JVM.Import(typeof(ObsoleteAttribute)).GetConstructor(Type.EmptyTypes)' new object[0]); " is 135.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,SetGhostInterface,The length of the statement  "				ghostInterfaceAttribute = new CustomAttributeBuilder(typeofGhostInterfaceAttribute.GetConstructor(Type.EmptyTypes)' new object[0]); " is 131.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,HideFromReflection,The length of the statement  "			CustomAttributeBuilder cab = new CustomAttributeBuilder(typeofHideFromReflectionAttribute.GetConstructor(Type.EmptyTypes)' new object[0]); " is 138.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,HideFromReflection,The length of the statement  "			CustomAttributeBuilder cab = new CustomAttributeBuilder(typeofHideFromReflectionAttribute.GetConstructor(new Type[] { Types.Int32 })' new object[] { reason }); " is 159.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,HideFromReflection,The length of the statement  "			CustomAttributeBuilder cab = new CustomAttributeBuilder(typeofHideFromReflectionAttribute.GetConstructor(Type.EmptyTypes)' new object[0]); " is 138.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,HideFromReflection,The length of the statement  "			CustomAttributeBuilder cab = new CustomAttributeBuilder(typeofHideFromReflectionAttribute.GetConstructor(Type.EmptyTypes)' new object[0]); " is 138.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,HideFromJava,The length of the statement  "				hideFromJavaAttribute = new CustomAttributeBuilder(typeofHideFromJavaAttribute.GetConstructor(Type.EmptyTypes)' new object[0]); " is 127.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,HideFromJava,The length of the statement  "				hideFromJavaAttribute = new CustomAttributeBuilder(typeofHideFromJavaAttribute.GetConstructor(Type.EmptyTypes)' new object[0]); " is 127.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,HideFromJava,The length of the statement  "				hideFromJavaAttribute = new CustomAttributeBuilder(typeofHideFromJavaAttribute.GetConstructor(Type.EmptyTypes)' new object[0]); " is 127.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,HideFromJava,The length of the statement  "				hideFromJavaAttribute = new CustomAttributeBuilder(typeofHideFromJavaAttribute.GetConstructor(Type.EmptyTypes)' new object[0]); " is 127.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,HideFromJava,The length of the statement  "				hideFromJavaAttribute = new CustomAttributeBuilder(typeofHideFromJavaAttribute.GetConstructor(Type.EmptyTypes)' new object[0]); " is 127.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,IsHideFromJava,The length of the statement  "				|| (type.IsNested && (type.DeclaringType.IsDefined(typeofHideFromJavaAttribute' false) || type.Name.StartsWith("__<"' StringComparison.Ordinal))); " is 146.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,GetModifiers,The length of the statement  "			if(parameters.Length > 0 && parameters[parameters.Length - 1].IsDefined(JVM.Import(typeof(ParamArrayAttribute))' false)) " is 120.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,SetModifiers,The length of the statement  "				customAttributeBuilder = new CustomAttributeBuilder(typeofModifiersAttribute.GetConstructor(new Type[] { typeofModifiers' Types.Boolean })' new object[] { modifiers' isInternal }); " is 180.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,SetModifiers,The length of the statement  "				customAttributeBuilder = new CustomAttributeBuilder(typeofModifiersAttribute.GetConstructor(new Type[] { typeofModifiers })' new object[] { modifiers }); " is 153.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,SetModifiers,The length of the statement  "				customAttributeBuilder = new CustomAttributeBuilder(typeofModifiersAttribute.GetConstructor(new Type[] { typeofModifiers' Types.Boolean })' new object[] { modifiers' isInternal }); " is 180.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,SetModifiers,The length of the statement  "				customAttributeBuilder = new CustomAttributeBuilder(typeofModifiersAttribute.GetConstructor(new Type[] { typeofModifiers })' new object[] { modifiers }); " is 153.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,SetModifiers,The length of the statement  "				customAttributeBuilder = new CustomAttributeBuilder(typeofModifiersAttribute.GetConstructor(new Type[] { typeofModifiers' Types.Boolean })' new object[] { modifiers' isInternal }); " is 180.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,SetModifiers,The length of the statement  "				customAttributeBuilder = new CustomAttributeBuilder(typeofModifiersAttribute.GetConstructor(new Type[] { typeofModifiers })' new object[] { modifiers }); " is 153.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,SetModifiers,The length of the statement  "				customAttributeBuilder = new CustomAttributeBuilder(typeofModifiersAttribute.GetConstructor(new Type[] { typeofModifiers' Types.Boolean })' new object[] { modifiers' isInternal }); " is 180.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,SetModifiers,The length of the statement  "				customAttributeBuilder = new CustomAttributeBuilder(typeofModifiersAttribute.GetConstructor(new Type[] { typeofModifiers })' new object[] { modifiers }); " is 153.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,SetModifiers,The length of the statement  "				customAttributeBuilder = new CustomAttributeBuilder(typeofModifiersAttribute.GetConstructor(new Type[] { typeofModifiers' Types.Boolean })' new object[] { modifiers' isInternal }); " is 180.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,SetModifiers,The length of the statement  "				customAttributeBuilder = new CustomAttributeBuilder(typeofModifiersAttribute.GetConstructor(new Type[] { typeofModifiers })' new object[] { modifiers }); " is 153.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,SetNameSig,The length of the statement  "			CustomAttributeBuilder customAttributeBuilder = new CustomAttributeBuilder(typeofNameSigAttribute.GetConstructor(new Type[] { Types.String' Types.String })' new object[] { name' sig }); " is 185.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,SetEnclosingMethodAttribute,The length of the statement  "				enclosingMethodAttribute = typeofEnclosingMethodAttribute.GetConstructor(new Type[] { Types.String' Types.String' Types.String }); " is 130.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,SetEnclosingMethodAttribute,The length of the statement  "			tb.SetCustomAttribute(new CustomAttributeBuilder(enclosingMethodAttribute' new object[] { className' methodName' methodSig })); " is 127.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,SetSignatureAttribute,The length of the statement  "				((ConstructorBuilder)mb).SetCustomAttribute(new CustomAttributeBuilder(signatureAttribute' new object[] { signature })); " is 120.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,SetParamArrayAttribute,The length of the statement  "				paramArrayAttribute = new CustomAttributeBuilder(JVM.Import(typeof(ParamArrayAttribute)).GetConstructor(Type.EmptyTypes)' new object[0]); " is 137.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,GetNonNestedInnerClasses,The length of the statement  "			foreach(CustomAttributeData cad in CustomAttributeData.__GetCustomAttributes(t' typeofNonNestedInnerClassAttribute' false)) " is 123.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,GetNonNestedOuterClasses,The length of the statement  "			foreach(CustomAttributeData cad in CustomAttributeData.__GetCustomAttributes(t' typeofNonNestedOuterClassAttribute' false)) " is 123.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,GetRemappedInterfaceMethods,The length of the statement  "			foreach(CustomAttributeData cad in CustomAttributeData.__GetCustomAttributes(type' typeofRemappedInterfaceMethodAttribute' false)) " is 130.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,GetRemappedInterfaceMethods,The length of the statement  "				attrs.Add(new RemappedInterfaceMethodAttribute((string)args[0].Value' (string)args[1].Value' DecodeArray<string>(args[2]))); " is 124.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,GetRemappedClasses,The length of the statement  "			foreach(CustomAttributeData cad in CustomAttributeData.__GetCustomAttributes(coreAssembly' typeofRemappedClassAttribute' false)) " is 128.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,GetAnnotationAttributeType,The length of the statement  "			foreach(CustomAttributeData cad in CustomAttributeData.__GetCustomAttributes(type' typeofAnnotationAttributeAttribute' false)) " is 126.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,IsNoPackagePrefix,The length of the statement  "			return type.IsDefined(typeofNoPackagePrefixAttribute' false) || type.Assembly.IsDefined(typeofNoPackagePrefixAttribute' false); " is 127.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,GetEnclosingMethodAttribute,The length of the statement  "			foreach (CustomAttributeData cad in CustomAttributeData.__GetCustomAttributes(type' typeofEnclosingMethodAttribute' false)) " is 123.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,GetEnclosingMethodAttribute,The length of the statement  "				return new EnclosingMethodAttribute((string)cad.ConstructorArguments[0].Value' (string)cad.ConstructorArguments[1].Value' (string)cad.ConstructorArguments[2].Value); " is 165.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,SetRemappedClass,The length of the statement  "			ConstructorInfo remappedClassAttribute = typeofRemappedClassAttribute.GetConstructor(new Type[] { Types.String' Types.Type }); " is 126.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,SetRemappedClass,The length of the statement  "			assemblyBuilder.SetCustomAttribute(new CustomAttributeBuilder(remappedClassAttribute' new object[] { name' shadowType })); " is 122.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,SetRemappedInterfaceMethod,The length of the statement  "			CustomAttributeBuilder cab = new CustomAttributeBuilder(typeofRemappedInterfaceMethodAttribute.GetConstructor(new Type[] { Types.String' Types.String' Types.String.MakeArrayType() })' new object[] { name' mappedTo' throws }); " is 225.
Long Statement,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,SetExceptionIsUnsafeForMapping,The length of the statement  "			CustomAttributeBuilder cab = new CustomAttributeBuilder(typeofExceptionIsUnsafeForMappingAttribute.GetConstructor(Type.EmptyTypes)' new object[0]); " is 147.
Long Statement,IKVM.Internal,Annotation,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,ValueQualifyClassNames,The length of the statement  "						return new object[] { AnnotationDefaultAttribute.TAG_CLASS' "L" + tw.TypeAsBaseType.AssemblyQualifiedName.Replace('.'' '/') + ";" }; " is 132.
Long Statement,IKVM.Internal,Annotation,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,ValueQualifyClassNames,The length of the statement  "					return new object[] { AnnotationDefaultAttribute.TAG_ENUM' "L" + tw.TypeAsBaseType.AssemblyQualifiedName.Replace('.'' '/') + ";"' val[2] }; " is 139.
Long Statement,IKVM.Internal,TypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,GetMethodWrapper,The length of the statement  "			// We need to get the methods before calling String.IsInterned' because getting them might cause the strings to be interned " is 123.
Long Statement,IKVM.Internal,TypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,IsPackageAccessibleFrom,The length of the statement  "					// (during compilation we have multiple CompilerClassLoader instances to represent the single shared runtime class loader) " is 122.
Long Statement,IKVM.Internal,TypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,IsAssignableTo,The length of the statement  "				return (!elem1.IsNonPrimitiveValueType && elem1.IsSubTypeOf(elem2)) || (rank1 == rank2 && elem2.IsGhost && elem1 == CoreClasses.java.lang.Object.Wrapper); " is 154.
Long Statement,IKVM.Internal,TypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,EmitConvStackTypeToSignatureType,The length of the statement  "				else if(IsInterfaceOrInterfaceArray && (sourceType == null || sourceType.IsUnloadable || !sourceType.IsAssignableTo(this))) " is 123.
Long Statement,IKVM.Internal,TypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,GetImplementedInterfacesAsTypeWrappers,The length of the statement  "					// for remapped interfaces' we also return the original interface (Java types will ignore it' if it isn't listed in the ImplementsAttribute) " is 140.
Long Statement,IKVM.Internal,TypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,GetSerializationConstructor,The length of the statement  "						JVM.Import(typeof(System.Runtime.Serialization.SerializationInfo))' JVM.Import(typeof(System.Runtime.Serialization.StreamingContext)) }' null); " is 143.
Long Statement,IKVM.Internal,CompiledTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,GetNameSigFromMethodBase,The length of the statement  "			retType = method is ConstructorInfo ? PrimitiveTypeWrapper.VOID : GetParameterTypeWrapper(((MethodInfo)method).ReturnParameter); " is 128.
Long Statement,IKVM.Internal,CompiledTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,LazyPublishMethods,The length of the statement  "			const BindingFlags flags = BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance; " is 146.
Long Statement,IKVM.Internal,CompiledTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,AddMethodOrConstructor,The length of the statement  "						int id = Int32.Parse(name.Substring(NamePrefix.AccessStub.Length' name.IndexOf('|'' NamePrefix.AccessStub.Length) - NamePrefix.AccessStub.Length)); " is 147.
Long Statement,IKVM.Internal,CompiledTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,AddMethodOrConstructor,The length of the statement  "						MethodInfo nonvirt = type.GetMethod(NamePrefix.NonVirtual + id' BindingFlags.NonPublic | BindingFlags.DeclaredOnly | BindingFlags.Instance); " is 140.
Long Statement,IKVM.Internal,CompiledTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,AddMethodOrConstructor,The length of the statement  "						methods.Add(new AccessStubMethodWrapper(this' name' sig' mi' mi' nonvirt ?? mi' retType' paramTypes' mods.Modifiers & ~Modifiers.Final' flags)); " is 144.
Long Statement,IKVM.Internal,CompiledTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,AddMethodOrConstructor,The length of the statement  "								mw = new AccessStubMethodWrapper(this' name' sig' mi' stubVirt' stubNonVirt ?? stubVirt' retType' paramTypes' mw.Modifiers' flags); " is 131.
Long Statement,IKVM.Internal,CompiledTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,GetType2AccessStubs,The length of the statement  "			const BindingFlags flags = BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance; " is 146.
Long Statement,IKVM.Internal,CompiledTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,GetType2AccessStub,The length of the statement  "			const BindingFlags flags = BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance; " is 124.
Long Statement,IKVM.Internal,CompiledTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,LazyPublishFields,The length of the statement  "			const BindingFlags flags = BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance; " is 146.
Long Statement,IKVM.Internal,CompiledTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,LazyPublishFields,The length of the statement  "			// FXBUG on .NET 3.5 and Mono Type.GetProperties() will not return "duplicate" properties (i.e. that have the same name and type' but differ in custom modifiers). " is 162.
Long Statement,IKVM.Internal,CompiledTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,LazyPublishFields,The length of the statement  "			// .NET 4.0 works as expected. We don't have a workaround' because that would require name mangling again and this situation is very unlikely anyway. " is 149.
Long Statement,IKVM.Internal,CompiledRemappedTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,LazyPublishMethods,The length of the statement  "				const BindingFlags bindingFlags = BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance; " is 153.
Long Statement,IKVM.Internal,CompiledRemappedTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,LazyPublishMethods,The length of the statement  "						MethodWrapper mw = new CompiledRemappedMethodWrapper(this' m.Name' sig' method' retType' paramTypes' modifiers' false' mbHelper' null); " is 135.
Long Statement,IKVM.Internal,CompiledRemappedTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,LazyPublishFields,The length of the statement  "				FieldInfo[] fields = type.GetFields(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance); " is 156.
Long Statement,IKVM.Internal,CompiledRemappedTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,CreateRemappedMethodWrapper,The length of the statement  "					MethodInfo helper = type.GetMethod("instancehelper_" + mb.Name' BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static' null' argTypes' null); " is 154.
Long Statement,IKVM.Internal,CompiledRemappedTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,CreateRemappedMethodWrapper,The length of the statement  "					mbNonvirtualHelper = type.GetMethod("nonvirtualhelper/" + mb.Name' BindingFlags.NonPublic | BindingFlags.Static' null' argTypes' null); " is 135.
Long Statement,IKVM.Internal,CompiledRemappedTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,CreateRemappedMethodWrapper,The length of the statement  "				return new CompiledRemappedMethodWrapper(this' name' sig' mb' retType' paramTypes' modifiers' hideFromReflection' mbHelper' mbNonvirtualHelper); " is 144.
Long Statement,IKVM.Internal,CompiledRemappedMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,CallImpl,The length of the statement  "						// When calling a final instance method on a remapped type from a class derived from a .NET class (i.e. a cli.System.Object or cli.System.Exception derived base class) " is 167.
Long Statement,IKVM.Internal,CompiledRemappedMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,CallImpl,The length of the statement  "						// then we can't call the java.lang.Object or java.lang.Throwable methods and we have to go through the instancehelper_ method. Note that since the method " is 154.
Long Statement,IKVM.Internal,CompiledRemappedMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,CallvirtImpl,The length of the statement  "				Debug.Assert(!mbHelper.IsStatic || mbHelper.Name.StartsWith("instancehelper_") || mbHelper.DeclaringType.Name == "__Helper"); " is 125.
Long Statement,IKVM.Internal,CompiledAnnotation,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,MakeCustomAttributeBuilder,The length of the statement  "				return new CustomAttributeBuilder(type.GetConstructor(new Type[] { JVM.Import(typeof(object[])) })' new object[] { annotation }); " is 129.
Long Statement,IKVM.Internal,ArrayTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,LazyPublishMembers,The length of the statement  "			MethodWrapper mw = new SimpleCallMethodWrapper(this' "clone"' "()Ljava.lang.Object;"' CloneMethod' CoreClasses.java.lang.Object.Wrapper' TypeWrapper.EmptyArray' Modifiers.Public' MemberFlags.HideFromReflection' SimpleOpCode.Callvirt' SimpleOpCode.Callvirt); " is 257.
Long Statement,IKVM.Internal.MapXml,Call,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\remapper.cs,Generate,The length of the statement  "				ConstructorInfo ci = StaticCompiler.GetTypeForMapXml(context.ClassLoader' type).GetConstructor(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance' null' CallingConventions.Standard' argTypes' null); " is 216.
Long Statement,IKVM.Internal.MapXml,Call,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\remapper.cs,Generate,The length of the statement  "					MethodInfo mi = StaticCompiler.GetTypeForMapXml(context.ClassLoader' type).GetMethod(Name' BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static' null' argTypes' null); " is 205.
Long Statement,IKVM.Internal.MapXml,Ldsfld,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\remapper.cs,Generate,The length of the statement  "				ilgen.Emit(OpCodes.Ldsfld' StaticCompiler.GetTypeForMapXml(context.ClassLoader' Type).GetField(Name' BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic)); " is 170.
Long Statement,IKVM.Internal.MapXml,Ldtoken,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\remapper.cs,Validate,The length of the statement  "					StaticCompiler.IssueMessage(Message.MapXmlError' "not implemented: cannot use 'type' attribute with 'method' or 'field' attribute for ldtoken"); " is 144.
Long Statement,IKVM.Internal.MapXml,Ldtoken,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\remapper.cs,Validate,The length of the statement  "						StaticCompiler.IssueMessage(Message.MapXmlError' "cannot specify 'sig' attribute without either 'method' or 'field' attribute for ldtoken"); " is 140.
Complex Conditional,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,GetBaseTypeForDefineType,The conditional expression  "this.IsPublic && this.IsAbstract && baseTypeWrapper.IsPublic && baseTypeWrapper.IsAbstract"  is complex.
Complex Conditional,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,AddParameterMetadata,The conditional expression  "(mw.DeclaringType.IsPublic && (mw.IsPublic || mw.IsProtected)) || classLoader.EmitDebugInfo"  is complex.
Complex Conditional,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,PublishProperties,The conditional expression  "mb == null || mb.DeclaringType != typeBuilder || (!mb.IsFinal && final)"  is complex.
Complex Conditional,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,PublishProperties,The conditional expression  "mb == null || mb.DeclaringType != typeBuilder || (!mb.IsFinal && final)"  is complex.
Complex Conditional,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,GetTypeWrapperCompilerHook,The conditional expression  "!f.IsInterface  						&& !f.IsAbstract  						&& !f.IsPublic  						&& !f.IsInternal  						&& !f.IsFinal  						&& !baseClasses.ContainsKey(f.Name)  						&& !options.targetIsModule  						&& options.sharedclassloader == null"  is complex.
Complex Conditional,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,Compile,The conditional expression  "compiler1 != compiler2  						&& (compiler1.options.crossReferenceAllPeers || (compiler1.options.peerReferences != null && Array.IndexOf(compiler1.options.peerReferences' compiler2.options.assembly) != -1))"  is complex.
Complex Conditional,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,CreateCompiler,The conditional expression  "m.IsPublic && m.IsStatic && m.Name == "main" && m.Signature == "([Ljava.lang.String;)V""  is complex.
Complex Conditional,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,CompilePass1,The conditional expression  "!(loader is GenericClassLoader || loader is CompilerClassLoader || (importedStubTypes.ContainsKey(s) && importedStubTypes[s] == wrapper) || IsStub(s))"  is complex.
Complex Conditional,IKVM.Internal,RemappedMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,DoLink,The conditional expression  "baseMethod != null &&  									!baseMethod.IsFinal &&  									!baseMethod.IsPrivate &&  									(baseMethod.m.@override != null ||  									baseMethod.m.redirect != null ||  									baseMethod.m.body != null ||  									baseMethod.m.alternateBody != null)"  is complex.
Complex Conditional,IKVM.Internal,RemappedMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,Finish,The conditional expression  "m.@override != null && m.redirect == null && m.body == null && m.alternateBody == null"  is complex.
Complex Conditional,IKVM.Internal,RemappedMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,Finish,The conditional expression  "mbCore != null &&   							(m.@override == null || m.redirect != null) &&  							(m.Modifiers & IKVM.Internal.MapXml.MapModifiers.Private) == 0 && (m.Modifiers & IKVM.Internal.MapXml.MapModifiers.Final) == 0"  is complex.
Complex Conditional,IKVM.Internal,AssemblyLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\AssemblyClassLoader.cs,GetJavaType,The conditional expression  "t != null  						&& !AttributeHelper.IsHideFromJava(t)  						&& !t.IsArray  						&& !t.IsPointer  						&& !t.IsByRef"  is complex.
Complex Conditional,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,GetClassName,The conditional expression  "(majorVersion & FLAG_MASK_MAJORVERSION) != majorVersion  				|| majorVersion < SupportedVersions.Minimum  				|| majorVersion > SupportedVersions.Maximum  				|| (majorVersion == SupportedVersions.Minimum && minorVersion < 3)  				|| (majorVersion == SupportedVersions.Maximum && minorVersion != 0)"  is complex.
Complex Conditional,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ClassFile,The conditional expression  "(majorVersion & FLAG_MASK_MAJORVERSION) != majorVersion  					|| majorVersion < SupportedVersions.Minimum  					|| majorVersion > SupportedVersions.Maximum  					|| (majorVersion == SupportedVersions.Minimum && minorVersion < 3)  					|| (majorVersion == SupportedVersions.Maximum && minorVersion != 0)"  is complex.
Complex Conditional,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ClassFile,The conditional expression  "(IsInterface && IsFinal)  					|| (IsAbstract && IsFinal)  					|| (majorVersion >= 49 && IsAnnotation && !IsInterface)  					|| (majorVersion >= 49 && IsInterface && (!IsAbstract || IsSuper || IsEnum))"  is complex.
Complex Conditional,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,RemoveUnusedFields,The conditional expression  "f.IsPrivate && f.IsStatic && f.Name != "serialVersionUID" && !IsReferenced(f)"  is complex.
Complex Conditional,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,IsReferenced,The conditional expression  "fieldref != null &&   					fieldref.Class == this.Name &&   					fieldref.Name == fld.Name &&   					fieldref.Signature == fld.Signature"  is complex.
Complex Conditional,IKVM.Internal,ConstantPoolItemMethodref,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Link,The conditional expression  "Name != StringConstants.INIT &&   						(thisType.Modifiers & (Modifiers.Interface | Modifiers.Super)) == Modifiers.Super &&  						thisType != wrapper && thisType.IsSubTypeOf(wrapper)"  is complex.
Complex Conditional,IKVM.Internal,Field,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Field,The conditional expression  "(IsPrivate && IsPublic) || (IsPrivate && IsProtected) || (IsPublic && IsProtected)  					|| (IsFinal && IsVolatile)  					|| (classFile.IsInterface && (!IsPublic || !IsStatic || !IsFinal || IsTransient))"  is complex.
Complex Conditional,IKVM.Internal,Method,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Method,The conditional expression  "ReferenceEquals(Name' StringConstants.CLINIT) && ReferenceEquals(Signature' StringConstants.SIG_VOID) && (classFile.MajorVersion < 51 || IsStatic)"  is complex.
Complex Conditional,IKVM.Internal,Method,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Method,The conditional expression  "(ReferenceEquals(Name' StringConstants.INIT) && (IsStatic || IsSynchronized || IsFinal || IsAbstract || IsNative))  						|| (IsPrivate && IsPublic) || (IsPrivate && IsProtected) || (IsPublic && IsProtected)  						|| (IsAbstract && (IsFinal || IsNative || IsPrivate || IsStatic || IsSynchronized))  						|| (classFile.IsInterface && (!IsPublic || !IsAbstract))"  is complex.
Complex Conditional,IKVM.Internal,Code,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Read,The conditional expression  "start_pc >= end_pc  							|| end_pc > code_length  							|| handler_pc >= code_length  							|| (catch_type != 0 && !classFile.SafeIsConstantPoolClass(catch_type))"  is complex.
Complex Conditional,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,RemoveJumpNext,The conditional expression  "i >= 2  						&& code[i - 1].pseudo == CodeType.LineNumber  						&& code[i - 2].opcode == OpCodes.Br  						&& code[i - 2].MatchLabel(code[i])"  is complex.
Complex Conditional,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizePatterns,The conditional expression  "code[i].opcode == OpCodes.Isinst  					&& code[i + 1].opcode == OpCodes.Ldnull  					&& code[i + 2].opcode == OpCodes.Cgt_Un  					&& (code[i + 3].opcode == OpCodes.Brfalse || code[i + 3].opcode == OpCodes.Brtrue)"  is complex.
Complex Conditional,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizePatterns,The conditional expression  "code[i].opcode == OpCodes.Ldelem_I1  					&& code[i + 1].opcode == OpCodes.Ldc_I4 && code[i + 1].ValueInt32 == 255  					&& code[i + 2].opcode == OpCodes.And"  is complex.
Complex Conditional,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizePatterns,The conditional expression  "code[i].opcode == OpCodes.Ldelem_I1  					&& code[i + 1].opcode == OpCodes.Conv_I8  					&& code[i + 2].opcode == OpCodes.Ldc_I8 && code[i + 2].ValueInt64 == 255  					&& code[i + 3].opcode == OpCodes.And"  is complex.
Complex Conditional,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizePatterns,The conditional expression  "i < code.Count - 10  					&& code[i].opcode == OpCodes.Ldc_I4  					&& code[i + 1].opcode == OpCodes.Dup  					&& code[i + 2].opcode == OpCodes.Ldc_I4_M1  					&& code[i + 3].opcode == OpCodes.Bne_Un_S  					&& code[i + 4].opcode == OpCodes.Pop  					&& code[i + 5].opcode == OpCodes.Neg  					&& code[i + 6].opcode == OpCodes.Br_S  					&& code[i + 7].pseudo == CodeType.Label && code[i + 7].MatchLabel(code[i + 3]) && code[i + 7].Label.Temp == 1  					&& code[i + 8].opcode == OpCodes.Div  					&& code[i + 9].pseudo == CodeType.Label && code[i + 9].Label == code[i + 6].Label && code[i + 9].Label.Temp == 1"  is complex.
Complex Conditional,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizePatterns,The conditional expression  "i < code.Count - 11  					&& code[i].opcode == OpCodes.Ldc_I8  					&& code[i + 1].opcode == OpCodes.Dup  					&& code[i + 2].opcode == OpCodes.Ldc_I4_M1  					&& code[i + 3].opcode == OpCodes.Conv_I8  					&& code[i + 4].opcode == OpCodes.Bne_Un_S  					&& code[i + 5].opcode == OpCodes.Pop  					&& code[i + 6].opcode == OpCodes.Neg  					&& code[i + 7].opcode == OpCodes.Br_S  					&& code[i + 8].pseudo == CodeType.Label && code[i + 8].MatchLabel(code[i + 4]) && code[i + 8].Label.Temp == 1  					&& code[i + 9].opcode == OpCodes.Div  					&& code[i + 10].pseudo == CodeType.Label && code[i + 10].MatchLabel(code[i + 7]) && code[i + 10].Label.Temp == 1"  is complex.
Complex Conditional,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizePatterns,The conditional expression  "i < code.Count - 13  					&& code[i + 0].opcode == OpCodes.Box  					&& code[i + 1].opcode == OpCodes.Dup  					&& code[i + 2].opcode == OpCodes.Brtrue_S  					&& code[i + 3].opcode == OpCodes.Pop  					&& code[i + 4].opcode == OpCodes.Ldloca && code[i + 4].Local.LocalType == code[i + 0].Type  					&& code[i + 5].opcode == OpCodes.Initobj && code[i + 5].Type == code[i + 0].Type  					&& code[i + 6].opcode == OpCodes.Ldloc && code[i + 6].Local == code[i + 4].Local  					&& code[i + 7].pseudo == CodeType.ReleaseTempLocal && code[i + 7].Local == code[i + 6].Local  					&& code[i + 8].opcode == OpCodes.Br_S  					&& code[i + 9].pseudo == CodeType.Label && code[i + 9].MatchLabel(code[i + 2]) && code[i + 9].Label.Temp == 1  					&& code[i + 10].opcode == OpCodes.Unbox && code[i + 10].Type == code[i + 0].Type  					&& code[i + 11].opcode == OpCodes.Ldobj && code[i + 11].Type == code[i + 0].Type  					&& code[i + 12].pseudo == CodeType.Label && code[i + 12].MatchLabel(code[i + 8]) && code[i + 12].Label.Temp == 1"  is complex.
Complex Conditional,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizePatterns,The conditional expression  "i < code.Count - 6  					&& code[i].opcode.FlowControl == FlowControl.Cond_Branch  					&& code[i + 1].opcode == OpCodes.Ldc_I4 && code[i + 1].ValueInt32 == 1  					&& code[i + 2].opcode == OpCodes.Br  					&& code[i + 3].pseudo == CodeType.Label && code[i + 3].MatchLabel(code[i]) && code[i + 3].Label.Temp == 1  					&& code[i + 4].opcode == OpCodes.Ldc_I4 && code[i + 4].ValueInt32 == 0  					&& code[i + 5].pseudo == CodeType.Label && code[i + 5].MatchLabel(code[i + 2]) && code[i + 5].Label.Temp == 1"  is complex.
Complex Conditional,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizeStackTransfer,The conditional expression  "code[i].opcode == OpCodes.Ldloc  					&& code[i + 1].opcode == OpCodes.Stloc  					&& code[i + 2].pseudo == CodeType.BeginExceptionBlock  					&& code[i + 3].opcode == OpCodes.Ldloc && code[i + 3].MatchLocal(code[i + 1])  					&& code[i + 4].pseudo == CodeType.ReleaseTempLocal && code[i + 4].MatchLocal(code[i + 3])"  is complex.
Complex Conditional,IKVM.Internal,DotNetTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,MangleTypeName,The conditional expression  "c == '+' && !escape && (sb.Length == 0 || sb[sb.Length - 1] != '$')"  is complex.
Complex Conditional,IKVM.Internal,DotNetTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,MangleTypeName,The conditional expression  ""_0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".IndexOf(c) != -1  					|| (c == '.' && !escape && !nested)"  is complex.
Complex Conditional,IKVM.Internal,DotNetTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,DemangleTypeName,The conditional expression  "digit0 == -1 || digit1 == -1 || digit2 == -1 || digit3 == -1"  is complex.
Complex Conditional,IKVM.Internal,DotNetTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,LazyPublishMembers,The conditional expression  "baseMethod != null && baseMethod.IsFinal && !baseMethod.IsStatic && !baseMethod.IsPrivate"  is complex.
Complex Conditional,IKVM.Internal,DotNetTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,LazyPublishMembers,The conditional expression  "!m.IsStatic && !m.IsFinal && (m.IsPublic || m.IsProtected) && m.Name != "<init>""  is complex.
Complex Conditional,IKVM.Internal,DotNetTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,InterfaceMethodStubHelper,The conditional expression  "existing == null || existing is ByRefMethodWrapper || existing.IsStatic || !existing.IsPublic"  is complex.
Complex Conditional,IKVM.Internal,DotNetTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,CreateMethodWrapper,The conditional expression  "name == "Finalize" && sig == "()V" && !mb.IsStatic &&  				IsRemappedImplDerived(TypeAsBaseType)"  is complex.
Complex Conditional,IKVM.Internal,AttributeAnnotationTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,GetConstructors,The conditional expression  "t0.IsEnum && (t1 == Types.Byte || t1 == Types.Int16 || t1 == Types.Int32)"  is complex.
Complex Conditional,IKVM.Internal,DynamicTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,VerifyDelegate,The conditional expression  "!invoke.IsPublic || !invoke.IsNative || invoke.IsFinal || invoke.IsStatic"  is complex.
Complex Conditional,IKVM.Internal,DynamicTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,VerifyDelegate,The conditional expression  "(beginInvoke != null && endInvoke == null) || (beginInvoke == null && endInvoke != null)"  is complex.
Complex Conditional,IKVM.Internal,DynamicTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,VerifyDelegate,The conditional expression  "constructor.Instructions.Length < 3  				|| constructor.Instructions[0].NormalizedOpCode != NormalizedByteCode.__aload  				|| constructor.Instructions[0].NormalizedArg1 != 0  				|| constructor.Instructions[1].NormalizedOpCode != NormalizedByteCode.__invokespecial  				|| constructor.Instructions[2].NormalizedOpCode != NormalizedByteCode.__return"  is complex.
Complex Conditional,IKVM.Internal,DynamicTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GetModOpt,The conditional expression  "tw1.IsErasedOrBoxedPrimitiveOrRemapped || tw.IsGhostArray || (mustBePublic && !tw1.IsPublic)"  is complex.
Complex Conditional,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,CreateStep1,The conditional expression  "m.HasCallerIDAnnotation  						&& (m.IsStatic || classFile.IsFinal)  						&& CoreClasses.java.lang.Object.Wrapper.InternalsVisibleTo(wrapper)"  is complex.
Complex Conditional,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,CreateStep2,The conditional expression  "outerInnerClasses[i].outerClass != 0  												&& outerClassFile.GetConstantPoolClass(outerInnerClasses[i].outerClass) == outerClassFile.Name  												&& outerInnerClasses[i].innerClass != 0  												&& outerClassFile.GetConstantPoolClass(outerInnerClasses[i].innerClass) == f.Name"  is complex.
Complex Conditional,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,IsSideEffectFreeStaticInitializerOrNoop,The conditional expression  "!field.IsFinal || !field.IsStatic || !field.IsProperty || field.PropertySetter != null"  is complex.
Complex Conditional,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,IsSideEffectFreeStaticInitializerOrNoop,The conditional expression  "bc == NormalizedByteCode.__areturn ||  						bc == NormalizedByteCode.__ireturn ||  						bc == NormalizedByteCode.__lreturn ||  						bc == NormalizedByteCode.__freturn ||  						bc == NormalizedByteCode.__dreturn"  is complex.
Complex Conditional,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FindBaseMethods7,The conditional expression  "baseMethod.IsFinal && (baseMethod.IsPublic || baseMethod.IsProtected || baseMethod.DeclaringType.IsPackageAccessibleFrom(wrapper))"  is complex.
Complex Conditional,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FindBaseMethods7,The conditional expression  "topPublicOrProtectedMethod == null && !baseMethod.IsPublic && !baseMethod.IsProtected && !baseMethod.DeclaringType.IsPackageAccessibleFrom(wrapper)"  is complex.
Complex Conditional,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FindBaseMethods7,The conditional expression  "topPublicOrProtectedMethod != null && baseMethod.IsFinal && !baseMethod.IsPublic && !baseMethod.IsProtected && !baseMethod.DeclaringType.IsPackageAccessibleFrom(wrapper)"  is complex.
Complex Conditional,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FindBaseMethods7,The conditional expression  "!baseMethod.IsPublic && !baseMethod.IsProtected &&  							((TryGetClassFileVersion(baseMethod.DeclaringType' out majorVersion) && majorVersion < 51)  							// if TryGetClassFileVersion fails' we know that it is safe to call GetMethod() so we look at the actual method attributes here'  							// because access widing ensures that if the method had overridden the top level method it would also be public or protected  							|| (LinkAndGetMethod(baseMethod).Attributes & MethodAttributes.MemberAccessMask) == MethodAttributes.Assembly)"  is complex.
Complex Conditional,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FindBaseMethodsLegacy,The conditional expression  "baseMethod.IsFinal  						&& !baseMethod.IsPrivate  						&& (baseMethod.IsPublic || baseMethod.IsProtected || baseMethod.DeclaringType.IsPackageAccessibleFrom(wrapper))"  is complex.
Complex Conditional,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GetPropertyAccess,The conditional expression  "field.IsProperty  						&& field.IsStatic == mw.IsStatic  						&& field.Signature == sig  						&& (field.PropertyGetter == mw.Name || field.PropertySetter == mw.Name)"  is complex.
Complex Conditional,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,LinkMethod,The conditional expression  "(m.Modifiers & (Modifiers.Synthetic | Modifiers.Bridge)) != 0  						&& (m.IsPublic || m.IsProtected)  						&& wrapper.IsPublic  						&& !IsAccessBridge(classFile' m)"  is complex.
Complex Conditional,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GenerateMethod,The conditional expression  "classFile.IsPublic && !classFile.IsFinal && !(m.IsPublic || m.IsProtected)"  is complex.
Complex Conditional,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GenerateMethod,The conditional expression  "(m.Modifiers & Modifiers.Bridge) != 0 && (m.IsPublic || m.IsProtected) && wrapper.IsPublic"  is complex.
Complex Conditional,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GenerateMethod,The conditional expression  "(baseMethod.IsPublic && !m.IsPublic) ||  								((baseMethod.IsFamily || baseMethod.IsFamilyOrAssembly) && !m.IsPublic && !m.IsProtected) ||  								(!m.IsPublic && !m.IsProtected && !baseMethodWrapper.DeclaringType.IsPackageAccessibleFrom(wrapper))"  is complex.
Complex Conditional,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GenerateMethod,The conditional expression  "needFinalize &&  							!m.IsAbstract && !m.IsNative &&  							(!m.IsFinal || classFile.IsFinal) &&  							m.Instructions.Length > 0 &&  							m.Instructions[0].NormalizedOpCode == NormalizedByteCode.__return"  is complex.
Complex Conditional,IKVM.Internal,AnnotationBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Link,The conditional expression  "eval != null  													&& eval.Length == 3  													&& eval[0].Equals(AnnotationDefaultAttribute.TAG_ENUM)  													&& eval[1].Equals("Ljava/lang/annotation/ElementType;")"  is complex.
Complex Conditional,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FinishImpl,The conditional expression  "fmw != mw && (fmw.IsStatic || fmw.IsPrivate || !(mw.DeclaringType.IsPackageAccessibleFrom(fmw.DeclaringType) || (mw.IsInternal && mw.DeclaringType.InternalsVisibleTo(fmw.DeclaringType))))"  is complex.
Complex Conditional,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FinishImpl,The conditional expression  "classFile.IsPublic && !classFile.IsFinal && !(m.IsPublic || m.IsProtected)"  is complex.
Complex Conditional,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FinishImpl,The conditional expression  "clinitIndex != -1 || (basehasclinit && !classFile.IsInterface) || classFile.HasInitializedFields"  is complex.
Complex Conditional,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FinishImpl,The conditional expression  "classFile.IsInterface && classFile.IsPublic && !wrapper.IsGhost && classFile.Fields.Length > 0"  is complex.
Complex Conditional,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FinishImpl,The conditional expression  "wrapper.GetClassLoader().EmitDebugInfo  #if STATIC_COMPILER   || (classFile.IsPublic && (m.IsPublic || m.IsProtected))"  is complex.
Complex Conditional,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,AddType1FieldAccessStubs,The conditional expression  "(fw.IsPublic || (fw.IsProtected && !wrapper.IsFinal))  								&& wrapper.GetFieldWrapper(fw.Name' fw.Signature) == fw"  is complex.
Complex Conditional,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,AddType1MethodAccessStubs,The conditional expression  "(mw.IsPublic || (mw.IsProtected && !wrapper.IsFinal))  							&& (!mw.IsAbstract || wrapper.IsAbstract)  							&& mw.Name != StringConstants.INIT  							&& wrapper.GetMethodWrapper(mw.Name' mw.Signature' true) == mw  							&& ParametersAreAccessible(mw)"  is complex.
Complex Conditional,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,AddType1MethodAccessStubs,The conditional expression  "!mw.IsStatic && !mw.IsFinal && !mw.IsAbstract && !wrapper.IsFinal"  is complex.
Complex Conditional,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,AddType2MethodAccessStubs,The conditional expression  "mw.HasNonPublicTypeInSignature  						&& (mw.IsPublic || (mw.IsProtected && !wrapper.IsFinal))  						&& ParametersAreAccessible(mw)"  is complex.
Complex Conditional,IKVM.Internal,FinishContext,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,AddType2MethodAccessStubs,The conditional expression  "!mw.IsStatic && !mw.IsFinal && !mw.IsAbstract && mw.Name != StringConstants.INIT && !wrapper.IsFinal"  is complex.
Complex Conditional,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,Object_getClass,The conditional expression  "eic.MatchRange(0' 4)  				&& eic.Match(1' NormalizedByteCode.__aload)  				&& eic.Match(2' NormalizedByteCode.__invokevirtual)  				&& (eic.Match(3' NormalizedByteCode.__if_acmpeq) || eic.Match(3' NormalizedByteCode.__if_acmpne))  				&& (IsSafeForGetClassOptimization(eic.GetStackTypeWrapper(0' 0)) || IsSafeForGetClassOptimization(eic.GetStackTypeWrapper(2' 0)))"  is complex.
Complex Conditional,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,Class_getDeclaredField,The conditional expression  "eic.MatchRange(-2' 4)  				&& eic.Match(-2' NormalizedByteCode.__ldc) && eic.GetClassLiteral(-2) == eic.Caller.DeclaringType  				&& eic.Match(-1' NormalizedByteCode.__ldc_nothrow)  				&& eic.Match(1' NormalizedByteCode.__invokevirtual)"  is complex.
Complex Conditional,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,EmitLoadCharArrayLiteral,The conditional expression  "type == null  				|| !type.IsValueType  				|| type.StructLayoutAttribute.Pack != 1 || type.StructLayoutAttribute.Size != length"  is complex.
Complex Conditional,IKVM.Internal,JsrMethodAnalyzer,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\JsrInliner.cs,JsrMethodAnalyzer,The conditional expression  "start >= end || start == -1 || end == -1 || handler <= 0"  is complex.
Complex Conditional,IKVM.Internal,JsrMethodAnalyzer,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\JsrInliner.cs,JsrMethodAnalyzer,The conditional expression  "method.ExceptionTable[j].startIndex <= i  										&& (i < method.ExceptionTable[j].endIndex  											|| (i == method.ExceptionTable[j].endIndex  												&& ByteCodeMetaData.GetFlowControl(instructions[i - 1].NormalizedOpCode) == ByteCodeFlowControl.Next))"  is complex.
Complex Conditional,IKVM.Internal,MemberWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\MemberWrapper.cs,IsPublicOrProtectedMemberAccessible,The conditional expression  "IsPublic || (IsProtected && caller.IsSubTypeOf(DeclaringType) && (IsStatic || instance.IsSubTypeOf(caller)))"  is complex.
Complex Conditional,IKVM.Internal,MethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\MemberWrapper.cs,UpdateNonPublicTypeInSignatureFlag,The conditional expression  "(IsPublic || IsProtected) && (returnTypeWrapper != null && parameterTypeWrappers != null) && !(this is AccessStubMethodWrapper) && !(this is AccessStubConstructorMethodWrapper)"  is complex.
Complex Conditional,IKVM.Internal,FieldWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\MemberWrapper.cs,FieldWrapper,The conditional expression  "IsFinal  				&& DeclaringType.IsPublic  				&& (IsPublic || (IsProtected && !DeclaringType.IsFinal))  				&& !DeclaringType.GetClassLoader().StrictFinalFieldSemantics  				&& DeclaringType is DynamicTypeWrapper  				&& !(this is ConstantFieldWrapper)  				&& !(this is DynamicPropertyFieldWrapper)"  is complex.
Complex Conditional,IKVM.Internal,FieldWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\MemberWrapper.cs,UpdateNonPublicTypeInSignatureFlag,The conditional expression  "(IsPublic || IsProtected) && fieldType != null && !IsAccessStub"  is complex.
Complex Conditional,IKVM.Internal,ConstantFieldWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\MemberWrapper.cs,EmitGetImpl,The conditional expression  "constant is int ||   				constant is short ||  				constant is ushort ||  				constant is byte ||  				constant is sbyte ||  				constant is char ||  				constant is bool"  is complex.
Complex Conditional,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,GetModifiers,The conditional expression  "(mb.IsFinal || (!mb.IsVirtual && ((modifiers & Modifiers.Private) == 0))) && !mb.IsStatic && !mb.IsConstructor"  is complex.
Complex Conditional,IKVM.Internal,Annotation,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,HasRetentionPolicyRuntime,The conditional expression  "val != null  									&& val.Length == 3  									&& val[0].Equals(AnnotationDefaultAttribute.TAG_ENUM)  									&& val[1].Equals("Ljava/lang/annotation/RetentionPolicy;")  									&& val[2].Equals("RUNTIME")"  is complex.
Complex Conditional,IKVM.Internal,TypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,EmitConvStackTypeToSignatureType,The conditional expression  "IsInterfaceOrInterfaceArray && (sourceType == null || sourceType.IsUnloadable || !sourceType.IsAssignableTo(this))"  is complex.
Complex Conditional,IKVM.Internal,CompiledRemappedTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,AddMethod,The conditional expression  "!AttributeHelper.IsHideFromJava(method)  					&& (remappedType.IsSealed || !method.Name.StartsWith("instancehelper_"))  					&& (!remappedType.IsSealed || method.IsStatic)"  is complex.
Complex Conditional,IKVM.Internal.MapXml,Ldtoken,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\remapper.cs,Resolve,The conditional expression  "Class != null || Method != null || Field != null || Sig != null"  is complex.
Complex Conditional,IKVM.Internal.MapXml,Redirect,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\remapper.cs,Emit,The conditional expression  "Type != "static" || Class == null || Name == null || Sig == null"  is complex.
Virtual Method Call from Constructor,IKVM.Internal,AssemblyClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\AssemblyClassLoader.cs,AssemblyClassLoader,The constructor "AssemblyClassLoader" calls a virtual method "GetManifestResourceInfo".
Virtual Method Call from Constructor,IKVM.Internal,AssemblyClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\AssemblyClassLoader.cs,AssemblyClassLoader,The constructor "AssemblyClassLoader" calls a virtual method "GetManifestResourceStream".
Virtual Method Call from Constructor,IKVM.Internal,AssemblyLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\AssemblyClassLoader.cs,AssemblyLoader,The constructor "AssemblyLoader" calls a virtual method "GetModules".
Virtual Method Call from Constructor,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ClassFile,The constructor "ClassFile" calls a virtual method "Resolve".
Virtual Method Call from Constructor,IKVM.Internal,FieldOrMethod,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,FieldOrMethod,The constructor "FieldOrMethod" calls a virtual method "ValidateSig".
Virtual Method Call from Constructor,IKVM.Internal,DelegateInnerClassTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,DelegateInnerClassTypeWrapper,The constructor "DelegateInnerClassTypeWrapper" calls a virtual method "GetParameters".
Virtual Method Call from Constructor,IKVM.Internal,DelegateInnerClassTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,DelegateInnerClassTypeWrapper,The constructor "DelegateInnerClassTypeWrapper" calls a virtual method "GetElementType".
Virtual Method Call from Constructor,IKVM.Internal,DelegateConstructorMethodWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,DelegateConstructorMethodWrapper,The constructor "DelegateConstructorMethodWrapper" calls a virtual method "GetClassLoader".
Virtual Method Call from Constructor,IKVM.Internal,FieldWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\MemberWrapper.cs,FieldWrapper,The constructor "FieldWrapper" calls a virtual method "GetClassLoader".
Virtual Method Call from Constructor,IKVM.Internal,CompiledAccessStubFieldWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\MemberWrapper.cs,CompiledAccessStubFieldWrapper,The constructor "CompiledAccessStubFieldWrapper" calls a virtual method "GetGetMethod".
Virtual Method Call from Constructor,IKVM.Internal,CompiledAccessStubFieldWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\MemberWrapper.cs,CompiledAccessStubFieldWrapper,The constructor "CompiledAccessStubFieldWrapper" calls a virtual method "GetSetMethod".
Empty Catch Block,IKVM.Internal,AssemblyResolver,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AssemblyResolver.cs,CanonicalizePath,The method has an empty catch block.
Empty Catch Block,IKVM.Internal,AssemblyResolver,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AssemblyResolver.cs,CanonicalizePath,The method has an empty catch block.
Empty Catch Block,IKVM.Internal,AssemblyResolver,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AssemblyResolver.cs,CanonicalizePath,The method has an empty catch block.
Empty Catch Block,IKVM.Internal,AssemblyResolver,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AssemblyResolver.cs,CanonicalizePath,The method has an empty catch block.
Empty Catch Block,IKVM.Internal,AssemblyResolver,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AssemblyResolver.cs,CanonicalizePath,The method has an empty catch block.
Empty Catch Block,IKVM.Internal,AssemblyResolver,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AssemblyResolver.cs,CanonicalizePath,The method has an empty catch block.
Empty Catch Block,IKVM.Internal,AssemblyResolver,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AssemblyResolver.cs,ResolveReference,The method has an empty catch block.
Empty Catch Block,IKVM.Internal,AssemblyResolver,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AssemblyResolver.cs,ResolveReference,The method has an empty catch block.
Empty Catch Block,IKVM.Internal,AssemblyResolver,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AssemblyResolver.cs,LoadMscorlib,The method has an empty catch block.
Empty Catch Block,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,CreateCompiler,The method has an empty catch block.
Empty Catch Block,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,IsStub,The method has an empty catch block.
Empty Catch Block,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,CompilePass3,The method has an empty catch block.
Empty Catch Block,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,CompilePass3,The method has an empty catch block.
Empty Catch Block,IKVM.Internal,ProxyGenerator,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\Proxy.cs,Create,The method has an empty catch block.
Empty Catch Block,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,IsValidConstant,The method has an empty catch block.
Empty Catch Block,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ReadAnnotationElementValue,The method has an empty catch block.
Empty Catch Block,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ReadAnnotationElementValue,The method has an empty catch block.
Empty Catch Block,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ReadAnnotationElementValue,The method has an empty catch block.
Empty Catch Block,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,IsValidAnnotationElementType,The method has an empty catch block.
Empty Catch Block,IKVM.Internal,JsrMethodAnalyzer,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\JsrInliner.cs,GetMethodref,The method has an empty catch block.
Empty Catch Block,IKVM.Internal,JsrMethodAnalyzer,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\JsrInliner.cs,GetMethodref,The method has an empty catch block.
Empty Catch Block,IKVM.Internal,JsrMethodAnalyzer,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\JsrInliner.cs,GetFieldref,The method has an empty catch block.
Empty Catch Block,IKVM.Internal,JsrMethodAnalyzer,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\JsrInliner.cs,GetFieldref,The method has an empty catch block.
Empty Catch Block,IKVM.Internal,JsrMethodAnalyzer,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\JsrInliner.cs,GetConstantPoolConstantType,The method has an empty catch block.
Empty Catch Block,IKVM.Internal,JsrMethodAnalyzer,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\JsrInliner.cs,GetConstantPoolConstantType,The method has an empty catch block.
Empty Catch Block,IKVM.Internal,JsrMethodAnalyzer,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\JsrInliner.cs,GetConstantPoolConstantType,The method has an empty catch block.
Empty Catch Block,IKVM.Internal,Tracer,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\tracer.cs,Tracer,The method has an empty catch block.
Empty Catch Block,IKVM.Internal,Tracer,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\tracer.cs,Init,The method has an empty catch block.
Empty Catch Block,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,GetInternalsVisibleToAttributes,The method has an empty catch block.
Empty Catch Block,IKVM.Internal,CompiledTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,SigTypePatchUp,The method has an empty catch block.
Magic Number,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,DefineGhostType,The following statement contains a magic number: ghostIsInstanceArrayMethod.DefineParameter(2' ParameterAttributes.None' "rank");
Magic Number,IKVM.Internal,AotTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AotTypeWrapper.cs,DefineGhostType,The following statement contains a magic number: ghostCastArrayMethod.DefineParameter(2' ParameterAttributes.None' "rank");
Magic Number,IKVM.Internal,AssemblyResolver,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AssemblyResolver.cs,universe_AssemblyResolve,The following statement contains a magic number: previousMatchLevel == 2
Magic Number,IKVM.Internal,AssemblyResolver,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AssemblyResolver.cs,Match,The following statement contains a magic number: switch (result)  			{  				case AssemblyComparisonResult.EquivalentFullMatch:  				case AssemblyComparisonResult.EquivalentPartialMatch:  				case AssemblyComparisonResult.EquivalentFXUnified:  				case AssemblyComparisonResult.EquivalentPartialFXUnified:  				case AssemblyComparisonResult.EquivalentPartialWeakNamed:  				case AssemblyComparisonResult.EquivalentWeakNamed:  					return true;  				case AssemblyComparisonResult.NonEquivalentPartialVersion:  				case AssemblyComparisonResult.NonEquivalentVersion:  					if (bestMatchLevel < 1)  					{  						bestMatchLevel = 1;  						bestMatch = assemblyDef;  					}  					return false;  				case AssemblyComparisonResult.EquivalentUnified:  				case AssemblyComparisonResult.EquivalentPartialUnified:  					if (bestMatchLevel < 2)  					{  						bestMatchLevel = 2;  						bestMatch = assemblyDef;  					}  					return false;  				case AssemblyComparisonResult.NonEquivalent:  				case AssemblyComparisonResult.Unknown:  					return false;  				default:  					throw new NotImplementedException();  			}
Magic Number,IKVM.Internal,AssemblyResolver,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\AssemblyResolver.cs,Match,The following statement contains a magic number: switch (result)  			{  				case AssemblyComparisonResult.EquivalentFullMatch:  				case AssemblyComparisonResult.EquivalentPartialMatch:  				case AssemblyComparisonResult.EquivalentFXUnified:  				case AssemblyComparisonResult.EquivalentPartialFXUnified:  				case AssemblyComparisonResult.EquivalentPartialWeakNamed:  				case AssemblyComparisonResult.EquivalentWeakNamed:  					return true;  				case AssemblyComparisonResult.NonEquivalentPartialVersion:  				case AssemblyComparisonResult.NonEquivalentVersion:  					if (bestMatchLevel < 1)  					{  						bestMatchLevel = 1;  						bestMatch = assemblyDef;  					}  					return false;  				case AssemblyComparisonResult.EquivalentUnified:  				case AssemblyComparisonResult.EquivalentPartialUnified:  					if (bestMatchLevel < 2)  					{  						bestMatchLevel = 2;  						bestMatch = assemblyDef;  					}  					return false;  				case AssemblyComparisonResult.NonEquivalent:  				case AssemblyComparisonResult.Unknown:  					return false;  				default:  					throw new NotImplementedException();  			}
Magic Number,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,AddJavaModuleAttribute,The following statement contains a magic number: string[] list = new string[nameMappings.Count * 2];
Magic Number,IKVM.Internal,CompilerClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,AddResources,The following statement contains a magic number: zip.SetLevel(9);
Magic Number,IKVM.Internal,StaticCompiler,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,IssueMessage,The following statement contains a magic number: ++errorCount == 100
Magic Number,IKVM.Internal,StaticCompiler,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,LinkageError,The following statement contains a magic number: object[] args = new object[values.Length + 2];
Magic Number,IKVM.Internal,StaticCompiler,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\ikvmc\CompilerClassLoader.cs,LinkageError,The following statement contains a magic number: values.CopyTo(args' 2);
Magic Number,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,GetClassName,The following statement contains a magic number: (majorVersion & FLAG_MASK_MAJORVERSION) != majorVersion  				|| majorVersion < SupportedVersions.Minimum  				|| majorVersion > SupportedVersions.Maximum  				|| (majorVersion == SupportedVersions.Minimum && minorVersion < 3)  				|| (majorVersion == SupportedVersions.Maximum && minorVersion != 0)
Magic Number,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,GetClassName,The following statement contains a magic number: switch(tag)  				{  					case Constant.Class:  						cpclass[i] = br.ReadUInt16();  						break;  					case Constant.Double:  					case Constant.Long:  						br.Skip(8);  						i++;  						break;  					case Constant.Fieldref:  					case Constant.InterfaceMethodref:  					case Constant.Methodref:  					case Constant.InvokeDynamic:  					case Constant.NameAndType:  					case Constant.Float:  					case Constant.Integer:  						br.Skip(4);  						break;  					case Constant.MethodHandle:  						br.Skip(3);  						break;  					case Constant.String:  					case Constant.MethodType:  						br.Skip(2);  						break;  					case Constant.Utf8:  						utf8_cp[i] = br.ReadString("<unknown>");  						break;  					default:  						throw new ClassFormatError("Illegal constant pool type 0x{0:X}"' tag);  				}
Magic Number,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,GetClassName,The following statement contains a magic number: switch(tag)  				{  					case Constant.Class:  						cpclass[i] = br.ReadUInt16();  						break;  					case Constant.Double:  					case Constant.Long:  						br.Skip(8);  						i++;  						break;  					case Constant.Fieldref:  					case Constant.InterfaceMethodref:  					case Constant.Methodref:  					case Constant.InvokeDynamic:  					case Constant.NameAndType:  					case Constant.Float:  					case Constant.Integer:  						br.Skip(4);  						break;  					case Constant.MethodHandle:  						br.Skip(3);  						break;  					case Constant.String:  					case Constant.MethodType:  						br.Skip(2);  						break;  					case Constant.Utf8:  						utf8_cp[i] = br.ReadString("<unknown>");  						break;  					default:  						throw new ClassFormatError("Illegal constant pool type 0x{0:X}"' tag);  				}
Magic Number,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,GetClassName,The following statement contains a magic number: switch(tag)  				{  					case Constant.Class:  						cpclass[i] = br.ReadUInt16();  						break;  					case Constant.Double:  					case Constant.Long:  						br.Skip(8);  						i++;  						break;  					case Constant.Fieldref:  					case Constant.InterfaceMethodref:  					case Constant.Methodref:  					case Constant.InvokeDynamic:  					case Constant.NameAndType:  					case Constant.Float:  					case Constant.Integer:  						br.Skip(4);  						break;  					case Constant.MethodHandle:  						br.Skip(3);  						break;  					case Constant.String:  					case Constant.MethodType:  						br.Skip(2);  						break;  					case Constant.Utf8:  						utf8_cp[i] = br.ReadString("<unknown>");  						break;  					default:  						throw new ClassFormatError("Illegal constant pool type 0x{0:X}"' tag);  				}
Magic Number,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,GetClassName,The following statement contains a magic number: switch(tag)  				{  					case Constant.Class:  						cpclass[i] = br.ReadUInt16();  						break;  					case Constant.Double:  					case Constant.Long:  						br.Skip(8);  						i++;  						break;  					case Constant.Fieldref:  					case Constant.InterfaceMethodref:  					case Constant.Methodref:  					case Constant.InvokeDynamic:  					case Constant.NameAndType:  					case Constant.Float:  					case Constant.Integer:  						br.Skip(4);  						break;  					case Constant.MethodHandle:  						br.Skip(3);  						break;  					case Constant.String:  					case Constant.MethodType:  						br.Skip(2);  						break;  					case Constant.Utf8:  						utf8_cp[i] = br.ReadString("<unknown>");  						break;  					default:  						throw new ClassFormatError("Illegal constant pool type 0x{0:X}"' tag);  				}
Magic Number,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ClassFile,The following statement contains a magic number: (majorVersion & FLAG_MASK_MAJORVERSION) != majorVersion  					|| majorVersion < SupportedVersions.Minimum  					|| majorVersion > SupportedVersions.Maximum  					|| (majorVersion == SupportedVersions.Minimum && minorVersion < 3)  					|| (majorVersion == SupportedVersions.Maximum && minorVersion != 0)
Magic Number,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ClassFile,The following statement contains a magic number: switch(tag)  					{  						case Constant.Class:  							constantpool[i] = new ConstantPoolItemClass(br);  							break;  						case Constant.Double:  							constantpool[i] = new ConstantPoolItemDouble(br);  							i++;  							break;  						case Constant.Fieldref:  							constantpool[i] = new ConstantPoolItemFieldref(br);  							break;  						case Constant.Float:  							constantpool[i] = new ConstantPoolItemFloat(br);  							break;  						case Constant.Integer:  							constantpool[i] = new ConstantPoolItemInteger(br);  							break;  						case Constant.InterfaceMethodref:  							constantpool[i] = new ConstantPoolItemInterfaceMethodref(br);  							break;  						case Constant.Long:  							constantpool[i] = new ConstantPoolItemLong(br);  							i++;  							break;  						case Constant.Methodref:  							constantpool[i] = new ConstantPoolItemMethodref(br);  							break;  						case Constant.NameAndType:  							constantpool[i] = new ConstantPoolItemNameAndType(br);  							break;  						case Constant.MethodHandle:  							if (majorVersion < 51)  								goto default;  							constantpool[i] = new ConstantPoolItemMethodHandle(br);  							break;  						case Constant.MethodType:  							if (majorVersion < 51)  								goto default;  							constantpool[i] = new ConstantPoolItemMethodType(br);  							break;  						case Constant.InvokeDynamic:  							if (majorVersion < 51)  								goto default;  							constantpool[i] = new ConstantPoolItemInvokeDynamic(br);  							break;  						case Constant.String:  							constantpool[i] = new ConstantPoolItemString(br);  							break;  						case Constant.Utf8:  							utf8_cp[i] = br.ReadString(inputClassName);  							break;  						default:  							throw new ClassFormatError("{0} (Illegal constant pool type 0x{1:X})"' inputClassName' tag);  					}
Magic Number,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ClassFile,The following statement contains a magic number: switch(tag)  					{  						case Constant.Class:  							constantpool[i] = new ConstantPoolItemClass(br);  							break;  						case Constant.Double:  							constantpool[i] = new ConstantPoolItemDouble(br);  							i++;  							break;  						case Constant.Fieldref:  							constantpool[i] = new ConstantPoolItemFieldref(br);  							break;  						case Constant.Float:  							constantpool[i] = new ConstantPoolItemFloat(br);  							break;  						case Constant.Integer:  							constantpool[i] = new ConstantPoolItemInteger(br);  							break;  						case Constant.InterfaceMethodref:  							constantpool[i] = new ConstantPoolItemInterfaceMethodref(br);  							break;  						case Constant.Long:  							constantpool[i] = new ConstantPoolItemLong(br);  							i++;  							break;  						case Constant.Methodref:  							constantpool[i] = new ConstantPoolItemMethodref(br);  							break;  						case Constant.NameAndType:  							constantpool[i] = new ConstantPoolItemNameAndType(br);  							break;  						case Constant.MethodHandle:  							if (majorVersion < 51)  								goto default;  							constantpool[i] = new ConstantPoolItemMethodHandle(br);  							break;  						case Constant.MethodType:  							if (majorVersion < 51)  								goto default;  							constantpool[i] = new ConstantPoolItemMethodType(br);  							break;  						case Constant.InvokeDynamic:  							if (majorVersion < 51)  								goto default;  							constantpool[i] = new ConstantPoolItemInvokeDynamic(br);  							break;  						case Constant.String:  							constantpool[i] = new ConstantPoolItemString(br);  							break;  						case Constant.Utf8:  							utf8_cp[i] = br.ReadString(inputClassName);  							break;  						default:  							throw new ClassFormatError("{0} (Illegal constant pool type 0x{1:X})"' inputClassName' tag);  					}
Magic Number,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ClassFile,The following statement contains a magic number: switch(tag)  					{  						case Constant.Class:  							constantpool[i] = new ConstantPoolItemClass(br);  							break;  						case Constant.Double:  							constantpool[i] = new ConstantPoolItemDouble(br);  							i++;  							break;  						case Constant.Fieldref:  							constantpool[i] = new ConstantPoolItemFieldref(br);  							break;  						case Constant.Float:  							constantpool[i] = new ConstantPoolItemFloat(br);  							break;  						case Constant.Integer:  							constantpool[i] = new ConstantPoolItemInteger(br);  							break;  						case Constant.InterfaceMethodref:  							constantpool[i] = new ConstantPoolItemInterfaceMethodref(br);  							break;  						case Constant.Long:  							constantpool[i] = new ConstantPoolItemLong(br);  							i++;  							break;  						case Constant.Methodref:  							constantpool[i] = new ConstantPoolItemMethodref(br);  							break;  						case Constant.NameAndType:  							constantpool[i] = new ConstantPoolItemNameAndType(br);  							break;  						case Constant.MethodHandle:  							if (majorVersion < 51)  								goto default;  							constantpool[i] = new ConstantPoolItemMethodHandle(br);  							break;  						case Constant.MethodType:  							if (majorVersion < 51)  								goto default;  							constantpool[i] = new ConstantPoolItemMethodType(br);  							break;  						case Constant.InvokeDynamic:  							if (majorVersion < 51)  								goto default;  							constantpool[i] = new ConstantPoolItemInvokeDynamic(br);  							break;  						case Constant.String:  							constantpool[i] = new ConstantPoolItemString(br);  							break;  						case Constant.Utf8:  							utf8_cp[i] = br.ReadString(inputClassName);  							break;  						default:  							throw new ClassFormatError("{0} (Illegal constant pool type 0x{1:X})"' inputClassName' tag);  					}
Magic Number,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ClassFile,The following statement contains a magic number: (IsInterface && IsFinal)  					|| (IsAbstract && IsFinal)  					|| (majorVersion >= 49 && IsAnnotation && !IsInterface)  					|| (majorVersion >= 49 && IsInterface && (!IsAbstract || IsSuper || IsEnum))
Magic Number,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ClassFile,The following statement contains a magic number: (IsInterface && IsFinal)  					|| (IsAbstract && IsFinal)  					|| (majorVersion >= 49 && IsAnnotation && !IsInterface)  					|| (majorVersion >= 49 && IsInterface && (!IsAbstract || IsSuper || IsEnum))
Magic Number,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ClassFile,The following statement contains a magic number: switch(GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16()))  					{  						case "Deprecated":  							if(br.ReadUInt32() != 0)  							{  								throw new ClassFormatError("Invalid Deprecated attribute length");  							}  							flags |= FLAG_MASK_DEPRECATED;  							break;  						case "SourceFile":  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("SourceFile attribute has incorrect length");  							}  							sourceFile = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "InnerClasses":  						{  							BigEndianBinaryReader rdr = br;  							uint attribute_length = br.ReadUInt32();  							ushort count = rdr.ReadUInt16();  							if(this.MajorVersion >= 49 && attribute_length != 2 + count * (2 + 2 + 2 + 2))  							{  								throw new ClassFormatError("{0} (InnerClasses attribute has incorrect length)"' this.Name);  							}  							innerClasses = new InnerClass[count];  							for(int j = 0; j < innerClasses.Length; j++)  							{  								innerClasses[j].innerClass = rdr.ReadUInt16();  								innerClasses[j].outerClass = rdr.ReadUInt16();  								innerClasses[j].name = rdr.ReadUInt16();  								innerClasses[j].accessFlags = (Modifiers)rdr.ReadUInt16();  								if(innerClasses[j].innerClass != 0 && !(GetConstantPoolItem(innerClasses[j].innerClass) is ConstantPoolItemClass))  								{  									throw new ClassFormatError("{0} (inner_class_info_index has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].outerClass != 0 && !(GetConstantPoolItem(innerClasses[j].outerClass) is ConstantPoolItemClass))  								{  									throw new ClassFormatError("{0} (outer_class_info_index has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].name != 0 && utf8_cp[innerClasses[j].name] == null)  								{  									throw new ClassFormatError("{0} (inner class name has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].innerClass == innerClasses[j].outerClass)  								{  									throw new ClassFormatError("{0} (Class is both inner and outer class)"' this.Name);  								}  								if(innerClasses[j].innerClass != 0 && innerClasses[j].outerClass != 0)  								{  									MarkLinkRequiredConstantPoolItem(innerClasses[j].innerClass);  									MarkLinkRequiredConstantPoolItem(innerClasses[j].outerClass);  								}  							}  							break;  						}  						case "Signature":  							if(majorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("Signature attribute has incorrect length");  							}  							signature = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "EnclosingMethod":  							if(majorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 4)  							{  								throw new ClassFormatError("EnclosingMethod attribute has incorrect length");  							}  							else  							{  								int class_index = br.ReadUInt16();  								int method_index = br.ReadUInt16();  								if(method_index == 0)  								{  									enclosingMethod = new string[] {  										GetConstantPoolClass(class_index)'  										null'  										null  																   };  								}  								else  								{  									ConstantPoolItemNameAndType m = (ConstantPoolItemNameAndType)GetConstantPoolItem(method_index);  									enclosingMethod = new string[] {  										GetConstantPoolClass(class_index)'  										GetConstantPoolUtf8String(utf8_cp' m.name_index)'  										GetConstantPoolUtf8String(utf8_cp' m.descriptor_index).Replace('/'' '.')  																   };  								}  							}  							break;  						case "RuntimeVisibleAnnotations":  							if(majorVersion < 49)  							{  								goto default;  							}  							annotations = ReadAnnotations(br' this' utf8_cp);  							break;  #if STATIC_COMPILER  						case "RuntimeInvisibleAnnotations":  							if(majorVersion < 49)  							{  								goto default;  							}  							foreach(object[] annot in ReadAnnotations(br' this' utf8_cp))  							{  								if(annot[1].Equals("Likvm/lang/Internal;"))  								{  									this.access_flags &= ~Modifiers.AccessMask;  									flags |= FLAG_MASK_INTERNAL;  								}  							}  							break;  #endif  						case "BootstrapMethods":  							if(majorVersion < 51)  							{  								goto default;  							}  							bootstrapMethods = ReadBootstrapMethods(br' this);  							break;  						case "IKVM.NET.Assembly":  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("IKVM.NET.Assembly attribute has incorrect length");  							}  							ikvmAssembly = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						default:  							br.Skip(br.ReadUInt32());  							break;  					}
Magic Number,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ClassFile,The following statement contains a magic number: switch(GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16()))  					{  						case "Deprecated":  							if(br.ReadUInt32() != 0)  							{  								throw new ClassFormatError("Invalid Deprecated attribute length");  							}  							flags |= FLAG_MASK_DEPRECATED;  							break;  						case "SourceFile":  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("SourceFile attribute has incorrect length");  							}  							sourceFile = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "InnerClasses":  						{  							BigEndianBinaryReader rdr = br;  							uint attribute_length = br.ReadUInt32();  							ushort count = rdr.ReadUInt16();  							if(this.MajorVersion >= 49 && attribute_length != 2 + count * (2 + 2 + 2 + 2))  							{  								throw new ClassFormatError("{0} (InnerClasses attribute has incorrect length)"' this.Name);  							}  							innerClasses = new InnerClass[count];  							for(int j = 0; j < innerClasses.Length; j++)  							{  								innerClasses[j].innerClass = rdr.ReadUInt16();  								innerClasses[j].outerClass = rdr.ReadUInt16();  								innerClasses[j].name = rdr.ReadUInt16();  								innerClasses[j].accessFlags = (Modifiers)rdr.ReadUInt16();  								if(innerClasses[j].innerClass != 0 && !(GetConstantPoolItem(innerClasses[j].innerClass) is ConstantPoolItemClass))  								{  									throw new ClassFormatError("{0} (inner_class_info_index has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].outerClass != 0 && !(GetConstantPoolItem(innerClasses[j].outerClass) is ConstantPoolItemClass))  								{  									throw new ClassFormatError("{0} (outer_class_info_index has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].name != 0 && utf8_cp[innerClasses[j].name] == null)  								{  									throw new ClassFormatError("{0} (inner class name has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].innerClass == innerClasses[j].outerClass)  								{  									throw new ClassFormatError("{0} (Class is both inner and outer class)"' this.Name);  								}  								if(innerClasses[j].innerClass != 0 && innerClasses[j].outerClass != 0)  								{  									MarkLinkRequiredConstantPoolItem(innerClasses[j].innerClass);  									MarkLinkRequiredConstantPoolItem(innerClasses[j].outerClass);  								}  							}  							break;  						}  						case "Signature":  							if(majorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("Signature attribute has incorrect length");  							}  							signature = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "EnclosingMethod":  							if(majorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 4)  							{  								throw new ClassFormatError("EnclosingMethod attribute has incorrect length");  							}  							else  							{  								int class_index = br.ReadUInt16();  								int method_index = br.ReadUInt16();  								if(method_index == 0)  								{  									enclosingMethod = new string[] {  										GetConstantPoolClass(class_index)'  										null'  										null  																   };  								}  								else  								{  									ConstantPoolItemNameAndType m = (ConstantPoolItemNameAndType)GetConstantPoolItem(method_index);  									enclosingMethod = new string[] {  										GetConstantPoolClass(class_index)'  										GetConstantPoolUtf8String(utf8_cp' m.name_index)'  										GetConstantPoolUtf8String(utf8_cp' m.descriptor_index).Replace('/'' '.')  																   };  								}  							}  							break;  						case "RuntimeVisibleAnnotations":  							if(majorVersion < 49)  							{  								goto default;  							}  							annotations = ReadAnnotations(br' this' utf8_cp);  							break;  #if STATIC_COMPILER  						case "RuntimeInvisibleAnnotations":  							if(majorVersion < 49)  							{  								goto default;  							}  							foreach(object[] annot in ReadAnnotations(br' this' utf8_cp))  							{  								if(annot[1].Equals("Likvm/lang/Internal;"))  								{  									this.access_flags &= ~Modifiers.AccessMask;  									flags |= FLAG_MASK_INTERNAL;  								}  							}  							break;  #endif  						case "BootstrapMethods":  							if(majorVersion < 51)  							{  								goto default;  							}  							bootstrapMethods = ReadBootstrapMethods(br' this);  							break;  						case "IKVM.NET.Assembly":  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("IKVM.NET.Assembly attribute has incorrect length");  							}  							ikvmAssembly = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						default:  							br.Skip(br.ReadUInt32());  							break;  					}
Magic Number,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ClassFile,The following statement contains a magic number: switch(GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16()))  					{  						case "Deprecated":  							if(br.ReadUInt32() != 0)  							{  								throw new ClassFormatError("Invalid Deprecated attribute length");  							}  							flags |= FLAG_MASK_DEPRECATED;  							break;  						case "SourceFile":  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("SourceFile attribute has incorrect length");  							}  							sourceFile = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "InnerClasses":  						{  							BigEndianBinaryReader rdr = br;  							uint attribute_length = br.ReadUInt32();  							ushort count = rdr.ReadUInt16();  							if(this.MajorVersion >= 49 && attribute_length != 2 + count * (2 + 2 + 2 + 2))  							{  								throw new ClassFormatError("{0} (InnerClasses attribute has incorrect length)"' this.Name);  							}  							innerClasses = new InnerClass[count];  							for(int j = 0; j < innerClasses.Length; j++)  							{  								innerClasses[j].innerClass = rdr.ReadUInt16();  								innerClasses[j].outerClass = rdr.ReadUInt16();  								innerClasses[j].name = rdr.ReadUInt16();  								innerClasses[j].accessFlags = (Modifiers)rdr.ReadUInt16();  								if(innerClasses[j].innerClass != 0 && !(GetConstantPoolItem(innerClasses[j].innerClass) is ConstantPoolItemClass))  								{  									throw new ClassFormatError("{0} (inner_class_info_index has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].outerClass != 0 && !(GetConstantPoolItem(innerClasses[j].outerClass) is ConstantPoolItemClass))  								{  									throw new ClassFormatError("{0} (outer_class_info_index has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].name != 0 && utf8_cp[innerClasses[j].name] == null)  								{  									throw new ClassFormatError("{0} (inner class name has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].innerClass == innerClasses[j].outerClass)  								{  									throw new ClassFormatError("{0} (Class is both inner and outer class)"' this.Name);  								}  								if(innerClasses[j].innerClass != 0 && innerClasses[j].outerClass != 0)  								{  									MarkLinkRequiredConstantPoolItem(innerClasses[j].innerClass);  									MarkLinkRequiredConstantPoolItem(innerClasses[j].outerClass);  								}  							}  							break;  						}  						case "Signature":  							if(majorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("Signature attribute has incorrect length");  							}  							signature = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "EnclosingMethod":  							if(majorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 4)  							{  								throw new ClassFormatError("EnclosingMethod attribute has incorrect length");  							}  							else  							{  								int class_index = br.ReadUInt16();  								int method_index = br.ReadUInt16();  								if(method_index == 0)  								{  									enclosingMethod = new string[] {  										GetConstantPoolClass(class_index)'  										null'  										null  																   };  								}  								else  								{  									ConstantPoolItemNameAndType m = (ConstantPoolItemNameAndType)GetConstantPoolItem(method_index);  									enclosingMethod = new string[] {  										GetConstantPoolClass(class_index)'  										GetConstantPoolUtf8String(utf8_cp' m.name_index)'  										GetConstantPoolUtf8String(utf8_cp' m.descriptor_index).Replace('/'' '.')  																   };  								}  							}  							break;  						case "RuntimeVisibleAnnotations":  							if(majorVersion < 49)  							{  								goto default;  							}  							annotations = ReadAnnotations(br' this' utf8_cp);  							break;  #if STATIC_COMPILER  						case "RuntimeInvisibleAnnotations":  							if(majorVersion < 49)  							{  								goto default;  							}  							foreach(object[] annot in ReadAnnotations(br' this' utf8_cp))  							{  								if(annot[1].Equals("Likvm/lang/Internal;"))  								{  									this.access_flags &= ~Modifiers.AccessMask;  									flags |= FLAG_MASK_INTERNAL;  								}  							}  							break;  #endif  						case "BootstrapMethods":  							if(majorVersion < 51)  							{  								goto default;  							}  							bootstrapMethods = ReadBootstrapMethods(br' this);  							break;  						case "IKVM.NET.Assembly":  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("IKVM.NET.Assembly attribute has incorrect length");  							}  							ikvmAssembly = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						default:  							br.Skip(br.ReadUInt32());  							break;  					}
Magic Number,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ClassFile,The following statement contains a magic number: switch(GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16()))  					{  						case "Deprecated":  							if(br.ReadUInt32() != 0)  							{  								throw new ClassFormatError("Invalid Deprecated attribute length");  							}  							flags |= FLAG_MASK_DEPRECATED;  							break;  						case "SourceFile":  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("SourceFile attribute has incorrect length");  							}  							sourceFile = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "InnerClasses":  						{  							BigEndianBinaryReader rdr = br;  							uint attribute_length = br.ReadUInt32();  							ushort count = rdr.ReadUInt16();  							if(this.MajorVersion >= 49 && attribute_length != 2 + count * (2 + 2 + 2 + 2))  							{  								throw new ClassFormatError("{0} (InnerClasses attribute has incorrect length)"' this.Name);  							}  							innerClasses = new InnerClass[count];  							for(int j = 0; j < innerClasses.Length; j++)  							{  								innerClasses[j].innerClass = rdr.ReadUInt16();  								innerClasses[j].outerClass = rdr.ReadUInt16();  								innerClasses[j].name = rdr.ReadUInt16();  								innerClasses[j].accessFlags = (Modifiers)rdr.ReadUInt16();  								if(innerClasses[j].innerClass != 0 && !(GetConstantPoolItem(innerClasses[j].innerClass) is ConstantPoolItemClass))  								{  									throw new ClassFormatError("{0} (inner_class_info_index has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].outerClass != 0 && !(GetConstantPoolItem(innerClasses[j].outerClass) is ConstantPoolItemClass))  								{  									throw new ClassFormatError("{0} (outer_class_info_index has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].name != 0 && utf8_cp[innerClasses[j].name] == null)  								{  									throw new ClassFormatError("{0} (inner class name has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].innerClass == innerClasses[j].outerClass)  								{  									throw new ClassFormatError("{0} (Class is both inner and outer class)"' this.Name);  								}  								if(innerClasses[j].innerClass != 0 && innerClasses[j].outerClass != 0)  								{  									MarkLinkRequiredConstantPoolItem(innerClasses[j].innerClass);  									MarkLinkRequiredConstantPoolItem(innerClasses[j].outerClass);  								}  							}  							break;  						}  						case "Signature":  							if(majorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("Signature attribute has incorrect length");  							}  							signature = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "EnclosingMethod":  							if(majorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 4)  							{  								throw new ClassFormatError("EnclosingMethod attribute has incorrect length");  							}  							else  							{  								int class_index = br.ReadUInt16();  								int method_index = br.ReadUInt16();  								if(method_index == 0)  								{  									enclosingMethod = new string[] {  										GetConstantPoolClass(class_index)'  										null'  										null  																   };  								}  								else  								{  									ConstantPoolItemNameAndType m = (ConstantPoolItemNameAndType)GetConstantPoolItem(method_index);  									enclosingMethod = new string[] {  										GetConstantPoolClass(class_index)'  										GetConstantPoolUtf8String(utf8_cp' m.name_index)'  										GetConstantPoolUtf8String(utf8_cp' m.descriptor_index).Replace('/'' '.')  																   };  								}  							}  							break;  						case "RuntimeVisibleAnnotations":  							if(majorVersion < 49)  							{  								goto default;  							}  							annotations = ReadAnnotations(br' this' utf8_cp);  							break;  #if STATIC_COMPILER  						case "RuntimeInvisibleAnnotations":  							if(majorVersion < 49)  							{  								goto default;  							}  							foreach(object[] annot in ReadAnnotations(br' this' utf8_cp))  							{  								if(annot[1].Equals("Likvm/lang/Internal;"))  								{  									this.access_flags &= ~Modifiers.AccessMask;  									flags |= FLAG_MASK_INTERNAL;  								}  							}  							break;  #endif  						case "BootstrapMethods":  							if(majorVersion < 51)  							{  								goto default;  							}  							bootstrapMethods = ReadBootstrapMethods(br' this);  							break;  						case "IKVM.NET.Assembly":  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("IKVM.NET.Assembly attribute has incorrect length");  							}  							ikvmAssembly = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						default:  							br.Skip(br.ReadUInt32());  							break;  					}
Magic Number,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ClassFile,The following statement contains a magic number: switch(GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16()))  					{  						case "Deprecated":  							if(br.ReadUInt32() != 0)  							{  								throw new ClassFormatError("Invalid Deprecated attribute length");  							}  							flags |= FLAG_MASK_DEPRECATED;  							break;  						case "SourceFile":  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("SourceFile attribute has incorrect length");  							}  							sourceFile = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "InnerClasses":  						{  							BigEndianBinaryReader rdr = br;  							uint attribute_length = br.ReadUInt32();  							ushort count = rdr.ReadUInt16();  							if(this.MajorVersion >= 49 && attribute_length != 2 + count * (2 + 2 + 2 + 2))  							{  								throw new ClassFormatError("{0} (InnerClasses attribute has incorrect length)"' this.Name);  							}  							innerClasses = new InnerClass[count];  							for(int j = 0; j < innerClasses.Length; j++)  							{  								innerClasses[j].innerClass = rdr.ReadUInt16();  								innerClasses[j].outerClass = rdr.ReadUInt16();  								innerClasses[j].name = rdr.ReadUInt16();  								innerClasses[j].accessFlags = (Modifiers)rdr.ReadUInt16();  								if(innerClasses[j].innerClass != 0 && !(GetConstantPoolItem(innerClasses[j].innerClass) is ConstantPoolItemClass))  								{  									throw new ClassFormatError("{0} (inner_class_info_index has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].outerClass != 0 && !(GetConstantPoolItem(innerClasses[j].outerClass) is ConstantPoolItemClass))  								{  									throw new ClassFormatError("{0} (outer_class_info_index has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].name != 0 && utf8_cp[innerClasses[j].name] == null)  								{  									throw new ClassFormatError("{0} (inner class name has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].innerClass == innerClasses[j].outerClass)  								{  									throw new ClassFormatError("{0} (Class is both inner and outer class)"' this.Name);  								}  								if(innerClasses[j].innerClass != 0 && innerClasses[j].outerClass != 0)  								{  									MarkLinkRequiredConstantPoolItem(innerClasses[j].innerClass);  									MarkLinkRequiredConstantPoolItem(innerClasses[j].outerClass);  								}  							}  							break;  						}  						case "Signature":  							if(majorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("Signature attribute has incorrect length");  							}  							signature = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "EnclosingMethod":  							if(majorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 4)  							{  								throw new ClassFormatError("EnclosingMethod attribute has incorrect length");  							}  							else  							{  								int class_index = br.ReadUInt16();  								int method_index = br.ReadUInt16();  								if(method_index == 0)  								{  									enclosingMethod = new string[] {  										GetConstantPoolClass(class_index)'  										null'  										null  																   };  								}  								else  								{  									ConstantPoolItemNameAndType m = (ConstantPoolItemNameAndType)GetConstantPoolItem(method_index);  									enclosingMethod = new string[] {  										GetConstantPoolClass(class_index)'  										GetConstantPoolUtf8String(utf8_cp' m.name_index)'  										GetConstantPoolUtf8String(utf8_cp' m.descriptor_index).Replace('/'' '.')  																   };  								}  							}  							break;  						case "RuntimeVisibleAnnotations":  							if(majorVersion < 49)  							{  								goto default;  							}  							annotations = ReadAnnotations(br' this' utf8_cp);  							break;  #if STATIC_COMPILER  						case "RuntimeInvisibleAnnotations":  							if(majorVersion < 49)  							{  								goto default;  							}  							foreach(object[] annot in ReadAnnotations(br' this' utf8_cp))  							{  								if(annot[1].Equals("Likvm/lang/Internal;"))  								{  									this.access_flags &= ~Modifiers.AccessMask;  									flags |= FLAG_MASK_INTERNAL;  								}  							}  							break;  #endif  						case "BootstrapMethods":  							if(majorVersion < 51)  							{  								goto default;  							}  							bootstrapMethods = ReadBootstrapMethods(br' this);  							break;  						case "IKVM.NET.Assembly":  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("IKVM.NET.Assembly attribute has incorrect length");  							}  							ikvmAssembly = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						default:  							br.Skip(br.ReadUInt32());  							break;  					}
Magic Number,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ClassFile,The following statement contains a magic number: switch(GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16()))  					{  						case "Deprecated":  							if(br.ReadUInt32() != 0)  							{  								throw new ClassFormatError("Invalid Deprecated attribute length");  							}  							flags |= FLAG_MASK_DEPRECATED;  							break;  						case "SourceFile":  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("SourceFile attribute has incorrect length");  							}  							sourceFile = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "InnerClasses":  						{  							BigEndianBinaryReader rdr = br;  							uint attribute_length = br.ReadUInt32();  							ushort count = rdr.ReadUInt16();  							if(this.MajorVersion >= 49 && attribute_length != 2 + count * (2 + 2 + 2 + 2))  							{  								throw new ClassFormatError("{0} (InnerClasses attribute has incorrect length)"' this.Name);  							}  							innerClasses = new InnerClass[count];  							for(int j = 0; j < innerClasses.Length; j++)  							{  								innerClasses[j].innerClass = rdr.ReadUInt16();  								innerClasses[j].outerClass = rdr.ReadUInt16();  								innerClasses[j].name = rdr.ReadUInt16();  								innerClasses[j].accessFlags = (Modifiers)rdr.ReadUInt16();  								if(innerClasses[j].innerClass != 0 && !(GetConstantPoolItem(innerClasses[j].innerClass) is ConstantPoolItemClass))  								{  									throw new ClassFormatError("{0} (inner_class_info_index has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].outerClass != 0 && !(GetConstantPoolItem(innerClasses[j].outerClass) is ConstantPoolItemClass))  								{  									throw new ClassFormatError("{0} (outer_class_info_index has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].name != 0 && utf8_cp[innerClasses[j].name] == null)  								{  									throw new ClassFormatError("{0} (inner class name has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].innerClass == innerClasses[j].outerClass)  								{  									throw new ClassFormatError("{0} (Class is both inner and outer class)"' this.Name);  								}  								if(innerClasses[j].innerClass != 0 && innerClasses[j].outerClass != 0)  								{  									MarkLinkRequiredConstantPoolItem(innerClasses[j].innerClass);  									MarkLinkRequiredConstantPoolItem(innerClasses[j].outerClass);  								}  							}  							break;  						}  						case "Signature":  							if(majorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("Signature attribute has incorrect length");  							}  							signature = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "EnclosingMethod":  							if(majorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 4)  							{  								throw new ClassFormatError("EnclosingMethod attribute has incorrect length");  							}  							else  							{  								int class_index = br.ReadUInt16();  								int method_index = br.ReadUInt16();  								if(method_index == 0)  								{  									enclosingMethod = new string[] {  										GetConstantPoolClass(class_index)'  										null'  										null  																   };  								}  								else  								{  									ConstantPoolItemNameAndType m = (ConstantPoolItemNameAndType)GetConstantPoolItem(method_index);  									enclosingMethod = new string[] {  										GetConstantPoolClass(class_index)'  										GetConstantPoolUtf8String(utf8_cp' m.name_index)'  										GetConstantPoolUtf8String(utf8_cp' m.descriptor_index).Replace('/'' '.')  																   };  								}  							}  							break;  						case "RuntimeVisibleAnnotations":  							if(majorVersion < 49)  							{  								goto default;  							}  							annotations = ReadAnnotations(br' this' utf8_cp);  							break;  #if STATIC_COMPILER  						case "RuntimeInvisibleAnnotations":  							if(majorVersion < 49)  							{  								goto default;  							}  							foreach(object[] annot in ReadAnnotations(br' this' utf8_cp))  							{  								if(annot[1].Equals("Likvm/lang/Internal;"))  								{  									this.access_flags &= ~Modifiers.AccessMask;  									flags |= FLAG_MASK_INTERNAL;  								}  							}  							break;  #endif  						case "BootstrapMethods":  							if(majorVersion < 51)  							{  								goto default;  							}  							bootstrapMethods = ReadBootstrapMethods(br' this);  							break;  						case "IKVM.NET.Assembly":  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("IKVM.NET.Assembly attribute has incorrect length");  							}  							ikvmAssembly = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						default:  							br.Skip(br.ReadUInt32());  							break;  					}
Magic Number,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ClassFile,The following statement contains a magic number: switch(GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16()))  					{  						case "Deprecated":  							if(br.ReadUInt32() != 0)  							{  								throw new ClassFormatError("Invalid Deprecated attribute length");  							}  							flags |= FLAG_MASK_DEPRECATED;  							break;  						case "SourceFile":  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("SourceFile attribute has incorrect length");  							}  							sourceFile = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "InnerClasses":  						{  							BigEndianBinaryReader rdr = br;  							uint attribute_length = br.ReadUInt32();  							ushort count = rdr.ReadUInt16();  							if(this.MajorVersion >= 49 && attribute_length != 2 + count * (2 + 2 + 2 + 2))  							{  								throw new ClassFormatError("{0} (InnerClasses attribute has incorrect length)"' this.Name);  							}  							innerClasses = new InnerClass[count];  							for(int j = 0; j < innerClasses.Length; j++)  							{  								innerClasses[j].innerClass = rdr.ReadUInt16();  								innerClasses[j].outerClass = rdr.ReadUInt16();  								innerClasses[j].name = rdr.ReadUInt16();  								innerClasses[j].accessFlags = (Modifiers)rdr.ReadUInt16();  								if(innerClasses[j].innerClass != 0 && !(GetConstantPoolItem(innerClasses[j].innerClass) is ConstantPoolItemClass))  								{  									throw new ClassFormatError("{0} (inner_class_info_index has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].outerClass != 0 && !(GetConstantPoolItem(innerClasses[j].outerClass) is ConstantPoolItemClass))  								{  									throw new ClassFormatError("{0} (outer_class_info_index has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].name != 0 && utf8_cp[innerClasses[j].name] == null)  								{  									throw new ClassFormatError("{0} (inner class name has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].innerClass == innerClasses[j].outerClass)  								{  									throw new ClassFormatError("{0} (Class is both inner and outer class)"' this.Name);  								}  								if(innerClasses[j].innerClass != 0 && innerClasses[j].outerClass != 0)  								{  									MarkLinkRequiredConstantPoolItem(innerClasses[j].innerClass);  									MarkLinkRequiredConstantPoolItem(innerClasses[j].outerClass);  								}  							}  							break;  						}  						case "Signature":  							if(majorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("Signature attribute has incorrect length");  							}  							signature = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "EnclosingMethod":  							if(majorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 4)  							{  								throw new ClassFormatError("EnclosingMethod attribute has incorrect length");  							}  							else  							{  								int class_index = br.ReadUInt16();  								int method_index = br.ReadUInt16();  								if(method_index == 0)  								{  									enclosingMethod = new string[] {  										GetConstantPoolClass(class_index)'  										null'  										null  																   };  								}  								else  								{  									ConstantPoolItemNameAndType m = (ConstantPoolItemNameAndType)GetConstantPoolItem(method_index);  									enclosingMethod = new string[] {  										GetConstantPoolClass(class_index)'  										GetConstantPoolUtf8String(utf8_cp' m.name_index)'  										GetConstantPoolUtf8String(utf8_cp' m.descriptor_index).Replace('/'' '.')  																   };  								}  							}  							break;  						case "RuntimeVisibleAnnotations":  							if(majorVersion < 49)  							{  								goto default;  							}  							annotations = ReadAnnotations(br' this' utf8_cp);  							break;  #if STATIC_COMPILER  						case "RuntimeInvisibleAnnotations":  							if(majorVersion < 49)  							{  								goto default;  							}  							foreach(object[] annot in ReadAnnotations(br' this' utf8_cp))  							{  								if(annot[1].Equals("Likvm/lang/Internal;"))  								{  									this.access_flags &= ~Modifiers.AccessMask;  									flags |= FLAG_MASK_INTERNAL;  								}  							}  							break;  #endif  						case "BootstrapMethods":  							if(majorVersion < 51)  							{  								goto default;  							}  							bootstrapMethods = ReadBootstrapMethods(br' this);  							break;  						case "IKVM.NET.Assembly":  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("IKVM.NET.Assembly attribute has incorrect length");  							}  							ikvmAssembly = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						default:  							br.Skip(br.ReadUInt32());  							break;  					}
Magic Number,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ClassFile,The following statement contains a magic number: switch(GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16()))  					{  						case "Deprecated":  							if(br.ReadUInt32() != 0)  							{  								throw new ClassFormatError("Invalid Deprecated attribute length");  							}  							flags |= FLAG_MASK_DEPRECATED;  							break;  						case "SourceFile":  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("SourceFile attribute has incorrect length");  							}  							sourceFile = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "InnerClasses":  						{  							BigEndianBinaryReader rdr = br;  							uint attribute_length = br.ReadUInt32();  							ushort count = rdr.ReadUInt16();  							if(this.MajorVersion >= 49 && attribute_length != 2 + count * (2 + 2 + 2 + 2))  							{  								throw new ClassFormatError("{0} (InnerClasses attribute has incorrect length)"' this.Name);  							}  							innerClasses = new InnerClass[count];  							for(int j = 0; j < innerClasses.Length; j++)  							{  								innerClasses[j].innerClass = rdr.ReadUInt16();  								innerClasses[j].outerClass = rdr.ReadUInt16();  								innerClasses[j].name = rdr.ReadUInt16();  								innerClasses[j].accessFlags = (Modifiers)rdr.ReadUInt16();  								if(innerClasses[j].innerClass != 0 && !(GetConstantPoolItem(innerClasses[j].innerClass) is ConstantPoolItemClass))  								{  									throw new ClassFormatError("{0} (inner_class_info_index has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].outerClass != 0 && !(GetConstantPoolItem(innerClasses[j].outerClass) is ConstantPoolItemClass))  								{  									throw new ClassFormatError("{0} (outer_class_info_index has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].name != 0 && utf8_cp[innerClasses[j].name] == null)  								{  									throw new ClassFormatError("{0} (inner class name has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].innerClass == innerClasses[j].outerClass)  								{  									throw new ClassFormatError("{0} (Class is both inner and outer class)"' this.Name);  								}  								if(innerClasses[j].innerClass != 0 && innerClasses[j].outerClass != 0)  								{  									MarkLinkRequiredConstantPoolItem(innerClasses[j].innerClass);  									MarkLinkRequiredConstantPoolItem(innerClasses[j].outerClass);  								}  							}  							break;  						}  						case "Signature":  							if(majorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("Signature attribute has incorrect length");  							}  							signature = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "EnclosingMethod":  							if(majorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 4)  							{  								throw new ClassFormatError("EnclosingMethod attribute has incorrect length");  							}  							else  							{  								int class_index = br.ReadUInt16();  								int method_index = br.ReadUInt16();  								if(method_index == 0)  								{  									enclosingMethod = new string[] {  										GetConstantPoolClass(class_index)'  										null'  										null  																   };  								}  								else  								{  									ConstantPoolItemNameAndType m = (ConstantPoolItemNameAndType)GetConstantPoolItem(method_index);  									enclosingMethod = new string[] {  										GetConstantPoolClass(class_index)'  										GetConstantPoolUtf8String(utf8_cp' m.name_index)'  										GetConstantPoolUtf8String(utf8_cp' m.descriptor_index).Replace('/'' '.')  																   };  								}  							}  							break;  						case "RuntimeVisibleAnnotations":  							if(majorVersion < 49)  							{  								goto default;  							}  							annotations = ReadAnnotations(br' this' utf8_cp);  							break;  #if STATIC_COMPILER  						case "RuntimeInvisibleAnnotations":  							if(majorVersion < 49)  							{  								goto default;  							}  							foreach(object[] annot in ReadAnnotations(br' this' utf8_cp))  							{  								if(annot[1].Equals("Likvm/lang/Internal;"))  								{  									this.access_flags &= ~Modifiers.AccessMask;  									flags |= FLAG_MASK_INTERNAL;  								}  							}  							break;  #endif  						case "BootstrapMethods":  							if(majorVersion < 51)  							{  								goto default;  							}  							bootstrapMethods = ReadBootstrapMethods(br' this);  							break;  						case "IKVM.NET.Assembly":  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("IKVM.NET.Assembly attribute has incorrect length");  							}  							ikvmAssembly = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						default:  							br.Skip(br.ReadUInt32());  							break;  					}
Magic Number,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ClassFile,The following statement contains a magic number: switch(GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16()))  					{  						case "Deprecated":  							if(br.ReadUInt32() != 0)  							{  								throw new ClassFormatError("Invalid Deprecated attribute length");  							}  							flags |= FLAG_MASK_DEPRECATED;  							break;  						case "SourceFile":  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("SourceFile attribute has incorrect length");  							}  							sourceFile = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "InnerClasses":  						{  							BigEndianBinaryReader rdr = br;  							uint attribute_length = br.ReadUInt32();  							ushort count = rdr.ReadUInt16();  							if(this.MajorVersion >= 49 && attribute_length != 2 + count * (2 + 2 + 2 + 2))  							{  								throw new ClassFormatError("{0} (InnerClasses attribute has incorrect length)"' this.Name);  							}  							innerClasses = new InnerClass[count];  							for(int j = 0; j < innerClasses.Length; j++)  							{  								innerClasses[j].innerClass = rdr.ReadUInt16();  								innerClasses[j].outerClass = rdr.ReadUInt16();  								innerClasses[j].name = rdr.ReadUInt16();  								innerClasses[j].accessFlags = (Modifiers)rdr.ReadUInt16();  								if(innerClasses[j].innerClass != 0 && !(GetConstantPoolItem(innerClasses[j].innerClass) is ConstantPoolItemClass))  								{  									throw new ClassFormatError("{0} (inner_class_info_index has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].outerClass != 0 && !(GetConstantPoolItem(innerClasses[j].outerClass) is ConstantPoolItemClass))  								{  									throw new ClassFormatError("{0} (outer_class_info_index has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].name != 0 && utf8_cp[innerClasses[j].name] == null)  								{  									throw new ClassFormatError("{0} (inner class name has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].innerClass == innerClasses[j].outerClass)  								{  									throw new ClassFormatError("{0} (Class is both inner and outer class)"' this.Name);  								}  								if(innerClasses[j].innerClass != 0 && innerClasses[j].outerClass != 0)  								{  									MarkLinkRequiredConstantPoolItem(innerClasses[j].innerClass);  									MarkLinkRequiredConstantPoolItem(innerClasses[j].outerClass);  								}  							}  							break;  						}  						case "Signature":  							if(majorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("Signature attribute has incorrect length");  							}  							signature = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "EnclosingMethod":  							if(majorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 4)  							{  								throw new ClassFormatError("EnclosingMethod attribute has incorrect length");  							}  							else  							{  								int class_index = br.ReadUInt16();  								int method_index = br.ReadUInt16();  								if(method_index == 0)  								{  									enclosingMethod = new string[] {  										GetConstantPoolClass(class_index)'  										null'  										null  																   };  								}  								else  								{  									ConstantPoolItemNameAndType m = (ConstantPoolItemNameAndType)GetConstantPoolItem(method_index);  									enclosingMethod = new string[] {  										GetConstantPoolClass(class_index)'  										GetConstantPoolUtf8String(utf8_cp' m.name_index)'  										GetConstantPoolUtf8String(utf8_cp' m.descriptor_index).Replace('/'' '.')  																   };  								}  							}  							break;  						case "RuntimeVisibleAnnotations":  							if(majorVersion < 49)  							{  								goto default;  							}  							annotations = ReadAnnotations(br' this' utf8_cp);  							break;  #if STATIC_COMPILER  						case "RuntimeInvisibleAnnotations":  							if(majorVersion < 49)  							{  								goto default;  							}  							foreach(object[] annot in ReadAnnotations(br' this' utf8_cp))  							{  								if(annot[1].Equals("Likvm/lang/Internal;"))  								{  									this.access_flags &= ~Modifiers.AccessMask;  									flags |= FLAG_MASK_INTERNAL;  								}  							}  							break;  #endif  						case "BootstrapMethods":  							if(majorVersion < 51)  							{  								goto default;  							}  							bootstrapMethods = ReadBootstrapMethods(br' this);  							break;  						case "IKVM.NET.Assembly":  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("IKVM.NET.Assembly attribute has incorrect length");  							}  							ikvmAssembly = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						default:  							br.Skip(br.ReadUInt32());  							break;  					}
Magic Number,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ClassFile,The following statement contains a magic number: switch(GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16()))  					{  						case "Deprecated":  							if(br.ReadUInt32() != 0)  							{  								throw new ClassFormatError("Invalid Deprecated attribute length");  							}  							flags |= FLAG_MASK_DEPRECATED;  							break;  						case "SourceFile":  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("SourceFile attribute has incorrect length");  							}  							sourceFile = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "InnerClasses":  						{  							BigEndianBinaryReader rdr = br;  							uint attribute_length = br.ReadUInt32();  							ushort count = rdr.ReadUInt16();  							if(this.MajorVersion >= 49 && attribute_length != 2 + count * (2 + 2 + 2 + 2))  							{  								throw new ClassFormatError("{0} (InnerClasses attribute has incorrect length)"' this.Name);  							}  							innerClasses = new InnerClass[count];  							for(int j = 0; j < innerClasses.Length; j++)  							{  								innerClasses[j].innerClass = rdr.ReadUInt16();  								innerClasses[j].outerClass = rdr.ReadUInt16();  								innerClasses[j].name = rdr.ReadUInt16();  								innerClasses[j].accessFlags = (Modifiers)rdr.ReadUInt16();  								if(innerClasses[j].innerClass != 0 && !(GetConstantPoolItem(innerClasses[j].innerClass) is ConstantPoolItemClass))  								{  									throw new ClassFormatError("{0} (inner_class_info_index has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].outerClass != 0 && !(GetConstantPoolItem(innerClasses[j].outerClass) is ConstantPoolItemClass))  								{  									throw new ClassFormatError("{0} (outer_class_info_index has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].name != 0 && utf8_cp[innerClasses[j].name] == null)  								{  									throw new ClassFormatError("{0} (inner class name has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].innerClass == innerClasses[j].outerClass)  								{  									throw new ClassFormatError("{0} (Class is both inner and outer class)"' this.Name);  								}  								if(innerClasses[j].innerClass != 0 && innerClasses[j].outerClass != 0)  								{  									MarkLinkRequiredConstantPoolItem(innerClasses[j].innerClass);  									MarkLinkRequiredConstantPoolItem(innerClasses[j].outerClass);  								}  							}  							break;  						}  						case "Signature":  							if(majorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("Signature attribute has incorrect length");  							}  							signature = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "EnclosingMethod":  							if(majorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 4)  							{  								throw new ClassFormatError("EnclosingMethod attribute has incorrect length");  							}  							else  							{  								int class_index = br.ReadUInt16();  								int method_index = br.ReadUInt16();  								if(method_index == 0)  								{  									enclosingMethod = new string[] {  										GetConstantPoolClass(class_index)'  										null'  										null  																   };  								}  								else  								{  									ConstantPoolItemNameAndType m = (ConstantPoolItemNameAndType)GetConstantPoolItem(method_index);  									enclosingMethod = new string[] {  										GetConstantPoolClass(class_index)'  										GetConstantPoolUtf8String(utf8_cp' m.name_index)'  										GetConstantPoolUtf8String(utf8_cp' m.descriptor_index).Replace('/'' '.')  																   };  								}  							}  							break;  						case "RuntimeVisibleAnnotations":  							if(majorVersion < 49)  							{  								goto default;  							}  							annotations = ReadAnnotations(br' this' utf8_cp);  							break;  #if STATIC_COMPILER  						case "RuntimeInvisibleAnnotations":  							if(majorVersion < 49)  							{  								goto default;  							}  							foreach(object[] annot in ReadAnnotations(br' this' utf8_cp))  							{  								if(annot[1].Equals("Likvm/lang/Internal;"))  								{  									this.access_flags &= ~Modifiers.AccessMask;  									flags |= FLAG_MASK_INTERNAL;  								}  							}  							break;  #endif  						case "BootstrapMethods":  							if(majorVersion < 51)  							{  								goto default;  							}  							bootstrapMethods = ReadBootstrapMethods(br' this);  							break;  						case "IKVM.NET.Assembly":  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("IKVM.NET.Assembly attribute has incorrect length");  							}  							ikvmAssembly = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						default:  							br.Skip(br.ReadUInt32());  							break;  					}
Magic Number,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ClassFile,The following statement contains a magic number: switch(GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16()))  					{  						case "Deprecated":  							if(br.ReadUInt32() != 0)  							{  								throw new ClassFormatError("Invalid Deprecated attribute length");  							}  							flags |= FLAG_MASK_DEPRECATED;  							break;  						case "SourceFile":  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("SourceFile attribute has incorrect length");  							}  							sourceFile = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "InnerClasses":  						{  							BigEndianBinaryReader rdr = br;  							uint attribute_length = br.ReadUInt32();  							ushort count = rdr.ReadUInt16();  							if(this.MajorVersion >= 49 && attribute_length != 2 + count * (2 + 2 + 2 + 2))  							{  								throw new ClassFormatError("{0} (InnerClasses attribute has incorrect length)"' this.Name);  							}  							innerClasses = new InnerClass[count];  							for(int j = 0; j < innerClasses.Length; j++)  							{  								innerClasses[j].innerClass = rdr.ReadUInt16();  								innerClasses[j].outerClass = rdr.ReadUInt16();  								innerClasses[j].name = rdr.ReadUInt16();  								innerClasses[j].accessFlags = (Modifiers)rdr.ReadUInt16();  								if(innerClasses[j].innerClass != 0 && !(GetConstantPoolItem(innerClasses[j].innerClass) is ConstantPoolItemClass))  								{  									throw new ClassFormatError("{0} (inner_class_info_index has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].outerClass != 0 && !(GetConstantPoolItem(innerClasses[j].outerClass) is ConstantPoolItemClass))  								{  									throw new ClassFormatError("{0} (outer_class_info_index has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].name != 0 && utf8_cp[innerClasses[j].name] == null)  								{  									throw new ClassFormatError("{0} (inner class name has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].innerClass == innerClasses[j].outerClass)  								{  									throw new ClassFormatError("{0} (Class is both inner and outer class)"' this.Name);  								}  								if(innerClasses[j].innerClass != 0 && innerClasses[j].outerClass != 0)  								{  									MarkLinkRequiredConstantPoolItem(innerClasses[j].innerClass);  									MarkLinkRequiredConstantPoolItem(innerClasses[j].outerClass);  								}  							}  							break;  						}  						case "Signature":  							if(majorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("Signature attribute has incorrect length");  							}  							signature = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "EnclosingMethod":  							if(majorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 4)  							{  								throw new ClassFormatError("EnclosingMethod attribute has incorrect length");  							}  							else  							{  								int class_index = br.ReadUInt16();  								int method_index = br.ReadUInt16();  								if(method_index == 0)  								{  									enclosingMethod = new string[] {  										GetConstantPoolClass(class_index)'  										null'  										null  																   };  								}  								else  								{  									ConstantPoolItemNameAndType m = (ConstantPoolItemNameAndType)GetConstantPoolItem(method_index);  									enclosingMethod = new string[] {  										GetConstantPoolClass(class_index)'  										GetConstantPoolUtf8String(utf8_cp' m.name_index)'  										GetConstantPoolUtf8String(utf8_cp' m.descriptor_index).Replace('/'' '.')  																   };  								}  							}  							break;  						case "RuntimeVisibleAnnotations":  							if(majorVersion < 49)  							{  								goto default;  							}  							annotations = ReadAnnotations(br' this' utf8_cp);  							break;  #if STATIC_COMPILER  						case "RuntimeInvisibleAnnotations":  							if(majorVersion < 49)  							{  								goto default;  							}  							foreach(object[] annot in ReadAnnotations(br' this' utf8_cp))  							{  								if(annot[1].Equals("Likvm/lang/Internal;"))  								{  									this.access_flags &= ~Modifiers.AccessMask;  									flags |= FLAG_MASK_INTERNAL;  								}  							}  							break;  #endif  						case "BootstrapMethods":  							if(majorVersion < 51)  							{  								goto default;  							}  							bootstrapMethods = ReadBootstrapMethods(br' this);  							break;  						case "IKVM.NET.Assembly":  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("IKVM.NET.Assembly attribute has incorrect length");  							}  							ikvmAssembly = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						default:  							br.Skip(br.ReadUInt32());  							break;  					}
Magic Number,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ClassFile,The following statement contains a magic number: switch(GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16()))  					{  						case "Deprecated":  							if(br.ReadUInt32() != 0)  							{  								throw new ClassFormatError("Invalid Deprecated attribute length");  							}  							flags |= FLAG_MASK_DEPRECATED;  							break;  						case "SourceFile":  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("SourceFile attribute has incorrect length");  							}  							sourceFile = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "InnerClasses":  						{  							BigEndianBinaryReader rdr = br;  							uint attribute_length = br.ReadUInt32();  							ushort count = rdr.ReadUInt16();  							if(this.MajorVersion >= 49 && attribute_length != 2 + count * (2 + 2 + 2 + 2))  							{  								throw new ClassFormatError("{0} (InnerClasses attribute has incorrect length)"' this.Name);  							}  							innerClasses = new InnerClass[count];  							for(int j = 0; j < innerClasses.Length; j++)  							{  								innerClasses[j].innerClass = rdr.ReadUInt16();  								innerClasses[j].outerClass = rdr.ReadUInt16();  								innerClasses[j].name = rdr.ReadUInt16();  								innerClasses[j].accessFlags = (Modifiers)rdr.ReadUInt16();  								if(innerClasses[j].innerClass != 0 && !(GetConstantPoolItem(innerClasses[j].innerClass) is ConstantPoolItemClass))  								{  									throw new ClassFormatError("{0} (inner_class_info_index has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].outerClass != 0 && !(GetConstantPoolItem(innerClasses[j].outerClass) is ConstantPoolItemClass))  								{  									throw new ClassFormatError("{0} (outer_class_info_index has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].name != 0 && utf8_cp[innerClasses[j].name] == null)  								{  									throw new ClassFormatError("{0} (inner class name has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].innerClass == innerClasses[j].outerClass)  								{  									throw new ClassFormatError("{0} (Class is both inner and outer class)"' this.Name);  								}  								if(innerClasses[j].innerClass != 0 && innerClasses[j].outerClass != 0)  								{  									MarkLinkRequiredConstantPoolItem(innerClasses[j].innerClass);  									MarkLinkRequiredConstantPoolItem(innerClasses[j].outerClass);  								}  							}  							break;  						}  						case "Signature":  							if(majorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("Signature attribute has incorrect length");  							}  							signature = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "EnclosingMethod":  							if(majorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 4)  							{  								throw new ClassFormatError("EnclosingMethod attribute has incorrect length");  							}  							else  							{  								int class_index = br.ReadUInt16();  								int method_index = br.ReadUInt16();  								if(method_index == 0)  								{  									enclosingMethod = new string[] {  										GetConstantPoolClass(class_index)'  										null'  										null  																   };  								}  								else  								{  									ConstantPoolItemNameAndType m = (ConstantPoolItemNameAndType)GetConstantPoolItem(method_index);  									enclosingMethod = new string[] {  										GetConstantPoolClass(class_index)'  										GetConstantPoolUtf8String(utf8_cp' m.name_index)'  										GetConstantPoolUtf8String(utf8_cp' m.descriptor_index).Replace('/'' '.')  																   };  								}  							}  							break;  						case "RuntimeVisibleAnnotations":  							if(majorVersion < 49)  							{  								goto default;  							}  							annotations = ReadAnnotations(br' this' utf8_cp);  							break;  #if STATIC_COMPILER  						case "RuntimeInvisibleAnnotations":  							if(majorVersion < 49)  							{  								goto default;  							}  							foreach(object[] annot in ReadAnnotations(br' this' utf8_cp))  							{  								if(annot[1].Equals("Likvm/lang/Internal;"))  								{  									this.access_flags &= ~Modifiers.AccessMask;  									flags |= FLAG_MASK_INTERNAL;  								}  							}  							break;  #endif  						case "BootstrapMethods":  							if(majorVersion < 51)  							{  								goto default;  							}  							bootstrapMethods = ReadBootstrapMethods(br' this);  							break;  						case "IKVM.NET.Assembly":  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("IKVM.NET.Assembly attribute has incorrect length");  							}  							ikvmAssembly = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						default:  							br.Skip(br.ReadUInt32());  							break;  					}
Magic Number,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ClassFile,The following statement contains a magic number: switch(GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16()))  					{  						case "Deprecated":  							if(br.ReadUInt32() != 0)  							{  								throw new ClassFormatError("Invalid Deprecated attribute length");  							}  							flags |= FLAG_MASK_DEPRECATED;  							break;  						case "SourceFile":  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("SourceFile attribute has incorrect length");  							}  							sourceFile = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "InnerClasses":  						{  							BigEndianBinaryReader rdr = br;  							uint attribute_length = br.ReadUInt32();  							ushort count = rdr.ReadUInt16();  							if(this.MajorVersion >= 49 && attribute_length != 2 + count * (2 + 2 + 2 + 2))  							{  								throw new ClassFormatError("{0} (InnerClasses attribute has incorrect length)"' this.Name);  							}  							innerClasses = new InnerClass[count];  							for(int j = 0; j < innerClasses.Length; j++)  							{  								innerClasses[j].innerClass = rdr.ReadUInt16();  								innerClasses[j].outerClass = rdr.ReadUInt16();  								innerClasses[j].name = rdr.ReadUInt16();  								innerClasses[j].accessFlags = (Modifiers)rdr.ReadUInt16();  								if(innerClasses[j].innerClass != 0 && !(GetConstantPoolItem(innerClasses[j].innerClass) is ConstantPoolItemClass))  								{  									throw new ClassFormatError("{0} (inner_class_info_index has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].outerClass != 0 && !(GetConstantPoolItem(innerClasses[j].outerClass) is ConstantPoolItemClass))  								{  									throw new ClassFormatError("{0} (outer_class_info_index has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].name != 0 && utf8_cp[innerClasses[j].name] == null)  								{  									throw new ClassFormatError("{0} (inner class name has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].innerClass == innerClasses[j].outerClass)  								{  									throw new ClassFormatError("{0} (Class is both inner and outer class)"' this.Name);  								}  								if(innerClasses[j].innerClass != 0 && innerClasses[j].outerClass != 0)  								{  									MarkLinkRequiredConstantPoolItem(innerClasses[j].innerClass);  									MarkLinkRequiredConstantPoolItem(innerClasses[j].outerClass);  								}  							}  							break;  						}  						case "Signature":  							if(majorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("Signature attribute has incorrect length");  							}  							signature = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "EnclosingMethod":  							if(majorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 4)  							{  								throw new ClassFormatError("EnclosingMethod attribute has incorrect length");  							}  							else  							{  								int class_index = br.ReadUInt16();  								int method_index = br.ReadUInt16();  								if(method_index == 0)  								{  									enclosingMethod = new string[] {  										GetConstantPoolClass(class_index)'  										null'  										null  																   };  								}  								else  								{  									ConstantPoolItemNameAndType m = (ConstantPoolItemNameAndType)GetConstantPoolItem(method_index);  									enclosingMethod = new string[] {  										GetConstantPoolClass(class_index)'  										GetConstantPoolUtf8String(utf8_cp' m.name_index)'  										GetConstantPoolUtf8String(utf8_cp' m.descriptor_index).Replace('/'' '.')  																   };  								}  							}  							break;  						case "RuntimeVisibleAnnotations":  							if(majorVersion < 49)  							{  								goto default;  							}  							annotations = ReadAnnotations(br' this' utf8_cp);  							break;  #if STATIC_COMPILER  						case "RuntimeInvisibleAnnotations":  							if(majorVersion < 49)  							{  								goto default;  							}  							foreach(object[] annot in ReadAnnotations(br' this' utf8_cp))  							{  								if(annot[1].Equals("Likvm/lang/Internal;"))  								{  									this.access_flags &= ~Modifiers.AccessMask;  									flags |= FLAG_MASK_INTERNAL;  								}  							}  							break;  #endif  						case "BootstrapMethods":  							if(majorVersion < 51)  							{  								goto default;  							}  							bootstrapMethods = ReadBootstrapMethods(br' this);  							break;  						case "IKVM.NET.Assembly":  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("IKVM.NET.Assembly attribute has incorrect length");  							}  							ikvmAssembly = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						default:  							br.Skip(br.ReadUInt32());  							break;  					}
Magic Number,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ClassFile,The following statement contains a magic number: switch(GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16()))  					{  						case "Deprecated":  							if(br.ReadUInt32() != 0)  							{  								throw new ClassFormatError("Invalid Deprecated attribute length");  							}  							flags |= FLAG_MASK_DEPRECATED;  							break;  						case "SourceFile":  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("SourceFile attribute has incorrect length");  							}  							sourceFile = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "InnerClasses":  						{  							BigEndianBinaryReader rdr = br;  							uint attribute_length = br.ReadUInt32();  							ushort count = rdr.ReadUInt16();  							if(this.MajorVersion >= 49 && attribute_length != 2 + count * (2 + 2 + 2 + 2))  							{  								throw new ClassFormatError("{0} (InnerClasses attribute has incorrect length)"' this.Name);  							}  							innerClasses = new InnerClass[count];  							for(int j = 0; j < innerClasses.Length; j++)  							{  								innerClasses[j].innerClass = rdr.ReadUInt16();  								innerClasses[j].outerClass = rdr.ReadUInt16();  								innerClasses[j].name = rdr.ReadUInt16();  								innerClasses[j].accessFlags = (Modifiers)rdr.ReadUInt16();  								if(innerClasses[j].innerClass != 0 && !(GetConstantPoolItem(innerClasses[j].innerClass) is ConstantPoolItemClass))  								{  									throw new ClassFormatError("{0} (inner_class_info_index has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].outerClass != 0 && !(GetConstantPoolItem(innerClasses[j].outerClass) is ConstantPoolItemClass))  								{  									throw new ClassFormatError("{0} (outer_class_info_index has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].name != 0 && utf8_cp[innerClasses[j].name] == null)  								{  									throw new ClassFormatError("{0} (inner class name has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].innerClass == innerClasses[j].outerClass)  								{  									throw new ClassFormatError("{0} (Class is both inner and outer class)"' this.Name);  								}  								if(innerClasses[j].innerClass != 0 && innerClasses[j].outerClass != 0)  								{  									MarkLinkRequiredConstantPoolItem(innerClasses[j].innerClass);  									MarkLinkRequiredConstantPoolItem(innerClasses[j].outerClass);  								}  							}  							break;  						}  						case "Signature":  							if(majorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("Signature attribute has incorrect length");  							}  							signature = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "EnclosingMethod":  							if(majorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 4)  							{  								throw new ClassFormatError("EnclosingMethod attribute has incorrect length");  							}  							else  							{  								int class_index = br.ReadUInt16();  								int method_index = br.ReadUInt16();  								if(method_index == 0)  								{  									enclosingMethod = new string[] {  										GetConstantPoolClass(class_index)'  										null'  										null  																   };  								}  								else  								{  									ConstantPoolItemNameAndType m = (ConstantPoolItemNameAndType)GetConstantPoolItem(method_index);  									enclosingMethod = new string[] {  										GetConstantPoolClass(class_index)'  										GetConstantPoolUtf8String(utf8_cp' m.name_index)'  										GetConstantPoolUtf8String(utf8_cp' m.descriptor_index).Replace('/'' '.')  																   };  								}  							}  							break;  						case "RuntimeVisibleAnnotations":  							if(majorVersion < 49)  							{  								goto default;  							}  							annotations = ReadAnnotations(br' this' utf8_cp);  							break;  #if STATIC_COMPILER  						case "RuntimeInvisibleAnnotations":  							if(majorVersion < 49)  							{  								goto default;  							}  							foreach(object[] annot in ReadAnnotations(br' this' utf8_cp))  							{  								if(annot[1].Equals("Likvm/lang/Internal;"))  								{  									this.access_flags &= ~Modifiers.AccessMask;  									flags |= FLAG_MASK_INTERNAL;  								}  							}  							break;  #endif  						case "BootstrapMethods":  							if(majorVersion < 51)  							{  								goto default;  							}  							bootstrapMethods = ReadBootstrapMethods(br' this);  							break;  						case "IKVM.NET.Assembly":  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("IKVM.NET.Assembly attribute has incorrect length");  							}  							ikvmAssembly = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						default:  							br.Skip(br.ReadUInt32());  							break;  					}
Magic Number,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ClassFile,The following statement contains a magic number: switch(GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16()))  					{  						case "Deprecated":  							if(br.ReadUInt32() != 0)  							{  								throw new ClassFormatError("Invalid Deprecated attribute length");  							}  							flags |= FLAG_MASK_DEPRECATED;  							break;  						case "SourceFile":  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("SourceFile attribute has incorrect length");  							}  							sourceFile = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "InnerClasses":  						{  							BigEndianBinaryReader rdr = br;  							uint attribute_length = br.ReadUInt32();  							ushort count = rdr.ReadUInt16();  							if(this.MajorVersion >= 49 && attribute_length != 2 + count * (2 + 2 + 2 + 2))  							{  								throw new ClassFormatError("{0} (InnerClasses attribute has incorrect length)"' this.Name);  							}  							innerClasses = new InnerClass[count];  							for(int j = 0; j < innerClasses.Length; j++)  							{  								innerClasses[j].innerClass = rdr.ReadUInt16();  								innerClasses[j].outerClass = rdr.ReadUInt16();  								innerClasses[j].name = rdr.ReadUInt16();  								innerClasses[j].accessFlags = (Modifiers)rdr.ReadUInt16();  								if(innerClasses[j].innerClass != 0 && !(GetConstantPoolItem(innerClasses[j].innerClass) is ConstantPoolItemClass))  								{  									throw new ClassFormatError("{0} (inner_class_info_index has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].outerClass != 0 && !(GetConstantPoolItem(innerClasses[j].outerClass) is ConstantPoolItemClass))  								{  									throw new ClassFormatError("{0} (outer_class_info_index has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].name != 0 && utf8_cp[innerClasses[j].name] == null)  								{  									throw new ClassFormatError("{0} (inner class name has bad constant pool index)"' this.Name);  								}  								if(innerClasses[j].innerClass == innerClasses[j].outerClass)  								{  									throw new ClassFormatError("{0} (Class is both inner and outer class)"' this.Name);  								}  								if(innerClasses[j].innerClass != 0 && innerClasses[j].outerClass != 0)  								{  									MarkLinkRequiredConstantPoolItem(innerClasses[j].innerClass);  									MarkLinkRequiredConstantPoolItem(innerClasses[j].outerClass);  								}  							}  							break;  						}  						case "Signature":  							if(majorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("Signature attribute has incorrect length");  							}  							signature = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "EnclosingMethod":  							if(majorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 4)  							{  								throw new ClassFormatError("EnclosingMethod attribute has incorrect length");  							}  							else  							{  								int class_index = br.ReadUInt16();  								int method_index = br.ReadUInt16();  								if(method_index == 0)  								{  									enclosingMethod = new string[] {  										GetConstantPoolClass(class_index)'  										null'  										null  																   };  								}  								else  								{  									ConstantPoolItemNameAndType m = (ConstantPoolItemNameAndType)GetConstantPoolItem(method_index);  									enclosingMethod = new string[] {  										GetConstantPoolClass(class_index)'  										GetConstantPoolUtf8String(utf8_cp' m.name_index)'  										GetConstantPoolUtf8String(utf8_cp' m.descriptor_index).Replace('/'' '.')  																   };  								}  							}  							break;  						case "RuntimeVisibleAnnotations":  							if(majorVersion < 49)  							{  								goto default;  							}  							annotations = ReadAnnotations(br' this' utf8_cp);  							break;  #if STATIC_COMPILER  						case "RuntimeInvisibleAnnotations":  							if(majorVersion < 49)  							{  								goto default;  							}  							foreach(object[] annot in ReadAnnotations(br' this' utf8_cp))  							{  								if(annot[1].Equals("Likvm/lang/Internal;"))  								{  									this.access_flags &= ~Modifiers.AccessMask;  									flags |= FLAG_MASK_INTERNAL;  								}  							}  							break;  #endif  						case "BootstrapMethods":  							if(majorVersion < 51)  							{  								goto default;  							}  							bootstrapMethods = ReadBootstrapMethods(br' this);  							break;  						case "IKVM.NET.Assembly":  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("IKVM.NET.Assembly attribute has incorrect length");  							}  							ikvmAssembly = GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						default:  							br.Skip(br.ReadUInt32());  							break;  					}
Magic Number,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ReadAnnotation,The following statement contains a magic number: object[] annot = new object[2 + num_element_value_pairs * 2];
Magic Number,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ReadAnnotation,The following statement contains a magic number: object[] annot = new object[2 + num_element_value_pairs * 2];
Magic Number,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ReadAnnotation,The following statement contains a magic number: annot[2 + i * 2 + 0] = classFile.GetConstantPoolUtf8String(utf8_cp' rdr.ReadUInt16());
Magic Number,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ReadAnnotation,The following statement contains a magic number: annot[2 + i * 2 + 0] = classFile.GetConstantPoolUtf8String(utf8_cp' rdr.ReadUInt16());
Magic Number,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ReadAnnotation,The following statement contains a magic number: annot[2 + i * 2 + 1] = ReadAnnotationElementValue(rdr' classFile' utf8_cp);
Magic Number,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,ReadAnnotation,The following statement contains a magic number: annot[2 + i * 2 + 1] = ReadAnnotationElementValue(rdr' classFile' utf8_cp);
Magic Number,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,IsValidMethodName,The following statement contains a magic number: return majorVersion >= 49 || IsValidPre49Identifier(name);
Magic Number,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,IsValidFieldName,The following statement contains a magic number: return majorVersion >= 49 || IsValidPre49Identifier(name);
Magic Number,IKVM.Internal,ClassFile,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,IsValidMethodSig,The following statement contains a magic number: sig.Length < 3 || sig[0] != '('
Magic Number,IKVM.Internal,Field,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Field,The following statement contains a magic number: switch(classFile.GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16()))  					{  						case "Deprecated":  							if(br.ReadUInt32() != 0)  							{  								throw new ClassFormatError("Invalid Deprecated attribute length");  							}  							flags |= FLAG_MASK_DEPRECATED;  							break;  						case "ConstantValue":  						{  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("Invalid ConstantValue attribute length");  							}  							ushort index = br.ReadUInt16();  							try  							{  								switch(Signature)  								{  									case "I":  										constantValue = classFile.GetConstantPoolConstantInteger(index);  										break;  									case "S":  										constantValue = (short)classFile.GetConstantPoolConstantInteger(index);  										break;  									case "B":  										constantValue = (byte)classFile.GetConstantPoolConstantInteger(index);  										break;  									case "C":  										constantValue = (char)classFile.GetConstantPoolConstantInteger(index);  										break;  									case "Z":  										constantValue = classFile.GetConstantPoolConstantInteger(index) != 0;  										break;  									case "J":  										constantValue = classFile.GetConstantPoolConstantLong(index);  										break;  									case "F":  										constantValue = classFile.GetConstantPoolConstantFloat(index);  										break;  									case "D":  										constantValue = classFile.GetConstantPoolConstantDouble(index);  										break;  									case "Ljava.lang.String;":  										constantValue = classFile.GetConstantPoolConstantString(index);  										break;  									default:  										throw new ClassFormatError("{0} (Invalid signature for constant)"' classFile.Name);  								}  							}  							catch(InvalidCastException)  							{  								throw new ClassFormatError("{0} (Bad index into constant pool)"' classFile.Name);  							}  							catch(IndexOutOfRangeException)  							{  								throw new ClassFormatError("{0} (Bad index into constant pool)"' classFile.Name);  							}  							catch(InvalidOperationException)  							{  								throw new ClassFormatError("{0} (Bad index into constant pool)"' classFile.Name);  							}  							catch(NullReferenceException)  							{  								throw new ClassFormatError("{0} (Bad index into constant pool)"' classFile.Name);  							}  							break;  						}  						case "Signature":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("Signature attribute has incorrect length");  							}  							signature = classFile.GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "RuntimeVisibleAnnotations":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							annotations = ReadAnnotations(br' classFile' utf8_cp);  							break;  						case "RuntimeInvisibleAnnotations":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							foreach(object[] annot in ReadAnnotations(br' classFile' utf8_cp))  							{  								if(annot[1].Equals("Likvm/lang/Property;"))  								{  									DecodePropertyAnnotation(classFile' annot);  								}  #if STATIC_COMPILER  								else if(annot[1].Equals("Likvm/lang/Internal;"))  								{  									this.access_flags &= ~Modifiers.AccessMask;  									flags |= FLAG_MASK_INTERNAL;  								}  #endif  							}  							break;  						default:  							br.Skip(br.ReadUInt32());  							break;  					}
Magic Number,IKVM.Internal,Field,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Field,The following statement contains a magic number: switch(classFile.GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16()))  					{  						case "Deprecated":  							if(br.ReadUInt32() != 0)  							{  								throw new ClassFormatError("Invalid Deprecated attribute length");  							}  							flags |= FLAG_MASK_DEPRECATED;  							break;  						case "ConstantValue":  						{  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("Invalid ConstantValue attribute length");  							}  							ushort index = br.ReadUInt16();  							try  							{  								switch(Signature)  								{  									case "I":  										constantValue = classFile.GetConstantPoolConstantInteger(index);  										break;  									case "S":  										constantValue = (short)classFile.GetConstantPoolConstantInteger(index);  										break;  									case "B":  										constantValue = (byte)classFile.GetConstantPoolConstantInteger(index);  										break;  									case "C":  										constantValue = (char)classFile.GetConstantPoolConstantInteger(index);  										break;  									case "Z":  										constantValue = classFile.GetConstantPoolConstantInteger(index) != 0;  										break;  									case "J":  										constantValue = classFile.GetConstantPoolConstantLong(index);  										break;  									case "F":  										constantValue = classFile.GetConstantPoolConstantFloat(index);  										break;  									case "D":  										constantValue = classFile.GetConstantPoolConstantDouble(index);  										break;  									case "Ljava.lang.String;":  										constantValue = classFile.GetConstantPoolConstantString(index);  										break;  									default:  										throw new ClassFormatError("{0} (Invalid signature for constant)"' classFile.Name);  								}  							}  							catch(InvalidCastException)  							{  								throw new ClassFormatError("{0} (Bad index into constant pool)"' classFile.Name);  							}  							catch(IndexOutOfRangeException)  							{  								throw new ClassFormatError("{0} (Bad index into constant pool)"' classFile.Name);  							}  							catch(InvalidOperationException)  							{  								throw new ClassFormatError("{0} (Bad index into constant pool)"' classFile.Name);  							}  							catch(NullReferenceException)  							{  								throw new ClassFormatError("{0} (Bad index into constant pool)"' classFile.Name);  							}  							break;  						}  						case "Signature":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("Signature attribute has incorrect length");  							}  							signature = classFile.GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "RuntimeVisibleAnnotations":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							annotations = ReadAnnotations(br' classFile' utf8_cp);  							break;  						case "RuntimeInvisibleAnnotations":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							foreach(object[] annot in ReadAnnotations(br' classFile' utf8_cp))  							{  								if(annot[1].Equals("Likvm/lang/Property;"))  								{  									DecodePropertyAnnotation(classFile' annot);  								}  #if STATIC_COMPILER  								else if(annot[1].Equals("Likvm/lang/Internal;"))  								{  									this.access_flags &= ~Modifiers.AccessMask;  									flags |= FLAG_MASK_INTERNAL;  								}  #endif  							}  							break;  						default:  							br.Skip(br.ReadUInt32());  							break;  					}
Magic Number,IKVM.Internal,Field,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Field,The following statement contains a magic number: switch(classFile.GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16()))  					{  						case "Deprecated":  							if(br.ReadUInt32() != 0)  							{  								throw new ClassFormatError("Invalid Deprecated attribute length");  							}  							flags |= FLAG_MASK_DEPRECATED;  							break;  						case "ConstantValue":  						{  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("Invalid ConstantValue attribute length");  							}  							ushort index = br.ReadUInt16();  							try  							{  								switch(Signature)  								{  									case "I":  										constantValue = classFile.GetConstantPoolConstantInteger(index);  										break;  									case "S":  										constantValue = (short)classFile.GetConstantPoolConstantInteger(index);  										break;  									case "B":  										constantValue = (byte)classFile.GetConstantPoolConstantInteger(index);  										break;  									case "C":  										constantValue = (char)classFile.GetConstantPoolConstantInteger(index);  										break;  									case "Z":  										constantValue = classFile.GetConstantPoolConstantInteger(index) != 0;  										break;  									case "J":  										constantValue = classFile.GetConstantPoolConstantLong(index);  										break;  									case "F":  										constantValue = classFile.GetConstantPoolConstantFloat(index);  										break;  									case "D":  										constantValue = classFile.GetConstantPoolConstantDouble(index);  										break;  									case "Ljava.lang.String;":  										constantValue = classFile.GetConstantPoolConstantString(index);  										break;  									default:  										throw new ClassFormatError("{0} (Invalid signature for constant)"' classFile.Name);  								}  							}  							catch(InvalidCastException)  							{  								throw new ClassFormatError("{0} (Bad index into constant pool)"' classFile.Name);  							}  							catch(IndexOutOfRangeException)  							{  								throw new ClassFormatError("{0} (Bad index into constant pool)"' classFile.Name);  							}  							catch(InvalidOperationException)  							{  								throw new ClassFormatError("{0} (Bad index into constant pool)"' classFile.Name);  							}  							catch(NullReferenceException)  							{  								throw new ClassFormatError("{0} (Bad index into constant pool)"' classFile.Name);  							}  							break;  						}  						case "Signature":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("Signature attribute has incorrect length");  							}  							signature = classFile.GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "RuntimeVisibleAnnotations":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							annotations = ReadAnnotations(br' classFile' utf8_cp);  							break;  						case "RuntimeInvisibleAnnotations":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							foreach(object[] annot in ReadAnnotations(br' classFile' utf8_cp))  							{  								if(annot[1].Equals("Likvm/lang/Property;"))  								{  									DecodePropertyAnnotation(classFile' annot);  								}  #if STATIC_COMPILER  								else if(annot[1].Equals("Likvm/lang/Internal;"))  								{  									this.access_flags &= ~Modifiers.AccessMask;  									flags |= FLAG_MASK_INTERNAL;  								}  #endif  							}  							break;  						default:  							br.Skip(br.ReadUInt32());  							break;  					}
Magic Number,IKVM.Internal,Field,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Field,The following statement contains a magic number: switch(classFile.GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16()))  					{  						case "Deprecated":  							if(br.ReadUInt32() != 0)  							{  								throw new ClassFormatError("Invalid Deprecated attribute length");  							}  							flags |= FLAG_MASK_DEPRECATED;  							break;  						case "ConstantValue":  						{  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("Invalid ConstantValue attribute length");  							}  							ushort index = br.ReadUInt16();  							try  							{  								switch(Signature)  								{  									case "I":  										constantValue = classFile.GetConstantPoolConstantInteger(index);  										break;  									case "S":  										constantValue = (short)classFile.GetConstantPoolConstantInteger(index);  										break;  									case "B":  										constantValue = (byte)classFile.GetConstantPoolConstantInteger(index);  										break;  									case "C":  										constantValue = (char)classFile.GetConstantPoolConstantInteger(index);  										break;  									case "Z":  										constantValue = classFile.GetConstantPoolConstantInteger(index) != 0;  										break;  									case "J":  										constantValue = classFile.GetConstantPoolConstantLong(index);  										break;  									case "F":  										constantValue = classFile.GetConstantPoolConstantFloat(index);  										break;  									case "D":  										constantValue = classFile.GetConstantPoolConstantDouble(index);  										break;  									case "Ljava.lang.String;":  										constantValue = classFile.GetConstantPoolConstantString(index);  										break;  									default:  										throw new ClassFormatError("{0} (Invalid signature for constant)"' classFile.Name);  								}  							}  							catch(InvalidCastException)  							{  								throw new ClassFormatError("{0} (Bad index into constant pool)"' classFile.Name);  							}  							catch(IndexOutOfRangeException)  							{  								throw new ClassFormatError("{0} (Bad index into constant pool)"' classFile.Name);  							}  							catch(InvalidOperationException)  							{  								throw new ClassFormatError("{0} (Bad index into constant pool)"' classFile.Name);  							}  							catch(NullReferenceException)  							{  								throw new ClassFormatError("{0} (Bad index into constant pool)"' classFile.Name);  							}  							break;  						}  						case "Signature":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("Signature attribute has incorrect length");  							}  							signature = classFile.GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "RuntimeVisibleAnnotations":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							annotations = ReadAnnotations(br' classFile' utf8_cp);  							break;  						case "RuntimeInvisibleAnnotations":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							foreach(object[] annot in ReadAnnotations(br' classFile' utf8_cp))  							{  								if(annot[1].Equals("Likvm/lang/Property;"))  								{  									DecodePropertyAnnotation(classFile' annot);  								}  #if STATIC_COMPILER  								else if(annot[1].Equals("Likvm/lang/Internal;"))  								{  									this.access_flags &= ~Modifiers.AccessMask;  									flags |= FLAG_MASK_INTERNAL;  								}  #endif  							}  							break;  						default:  							br.Skip(br.ReadUInt32());  							break;  					}
Magic Number,IKVM.Internal,Field,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Field,The following statement contains a magic number: switch(classFile.GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16()))  					{  						case "Deprecated":  							if(br.ReadUInt32() != 0)  							{  								throw new ClassFormatError("Invalid Deprecated attribute length");  							}  							flags |= FLAG_MASK_DEPRECATED;  							break;  						case "ConstantValue":  						{  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("Invalid ConstantValue attribute length");  							}  							ushort index = br.ReadUInt16();  							try  							{  								switch(Signature)  								{  									case "I":  										constantValue = classFile.GetConstantPoolConstantInteger(index);  										break;  									case "S":  										constantValue = (short)classFile.GetConstantPoolConstantInteger(index);  										break;  									case "B":  										constantValue = (byte)classFile.GetConstantPoolConstantInteger(index);  										break;  									case "C":  										constantValue = (char)classFile.GetConstantPoolConstantInteger(index);  										break;  									case "Z":  										constantValue = classFile.GetConstantPoolConstantInteger(index) != 0;  										break;  									case "J":  										constantValue = classFile.GetConstantPoolConstantLong(index);  										break;  									case "F":  										constantValue = classFile.GetConstantPoolConstantFloat(index);  										break;  									case "D":  										constantValue = classFile.GetConstantPoolConstantDouble(index);  										break;  									case "Ljava.lang.String;":  										constantValue = classFile.GetConstantPoolConstantString(index);  										break;  									default:  										throw new ClassFormatError("{0} (Invalid signature for constant)"' classFile.Name);  								}  							}  							catch(InvalidCastException)  							{  								throw new ClassFormatError("{0} (Bad index into constant pool)"' classFile.Name);  							}  							catch(IndexOutOfRangeException)  							{  								throw new ClassFormatError("{0} (Bad index into constant pool)"' classFile.Name);  							}  							catch(InvalidOperationException)  							{  								throw new ClassFormatError("{0} (Bad index into constant pool)"' classFile.Name);  							}  							catch(NullReferenceException)  							{  								throw new ClassFormatError("{0} (Bad index into constant pool)"' classFile.Name);  							}  							break;  						}  						case "Signature":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("Signature attribute has incorrect length");  							}  							signature = classFile.GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "RuntimeVisibleAnnotations":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							annotations = ReadAnnotations(br' classFile' utf8_cp);  							break;  						case "RuntimeInvisibleAnnotations":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							foreach(object[] annot in ReadAnnotations(br' classFile' utf8_cp))  							{  								if(annot[1].Equals("Likvm/lang/Property;"))  								{  									DecodePropertyAnnotation(classFile' annot);  								}  #if STATIC_COMPILER  								else if(annot[1].Equals("Likvm/lang/Internal;"))  								{  									this.access_flags &= ~Modifiers.AccessMask;  									flags |= FLAG_MASK_INTERNAL;  								}  #endif  							}  							break;  						default:  							br.Skip(br.ReadUInt32());  							break;  					}
Magic Number,IKVM.Internal,Field,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,DecodePropertyAnnotation,The following statement contains a magic number: propertyGetterSetter = new string[2];
Magic Number,IKVM.Internal,Method,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Method,The following statement contains a magic number: ReferenceEquals(Name' StringConstants.CLINIT) && ReferenceEquals(Signature' StringConstants.SIG_VOID) && (classFile.MajorVersion < 51 || IsStatic)
Magic Number,IKVM.Internal,Method,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Method,The following statement contains a magic number: switch(classFile.GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16()))  					{  						case "Deprecated":  							if(br.ReadUInt32() != 0)  							{  								throw new ClassFormatError("Invalid Deprecated attribute length");  							}  							flags |= FLAG_MASK_DEPRECATED;  							break;  						case "Code":  						{  							if(!code.IsEmpty)  							{  								throw new ClassFormatError("{0} (Duplicate Code attribute)"' classFile.Name);  							}  							BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());  							code.Read(classFile' utf8_cp' this' rdr' options);  							if(!rdr.IsAtEnd)  							{  								throw new ClassFormatError("{0} (Code attribute has wrong length)"' classFile.Name);  							}  							break;  						}  						case "Exceptions":  						{  							if(exceptions != null)  							{  								throw new ClassFormatError("{0} (Duplicate Exceptions attribute)"' classFile.Name);  							}  							BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());  							ushort count = rdr.ReadUInt16();  							exceptions = new string[count];  							for(int j = 0; j < count; j++)  							{  								exceptions[j] = classFile.GetConstantPoolClass(rdr.ReadUInt16());  							}  							if(!rdr.IsAtEnd)  							{  								throw new ClassFormatError("{0} (Exceptions attribute has wrong length)"' classFile.Name);  							}  							break;  						}  						case "Signature":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("Signature attribute has incorrect length");  							}  							signature = classFile.GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "RuntimeVisibleAnnotations":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							annotations = ReadAnnotations(br' classFile' utf8_cp);  							break;  						case "RuntimeVisibleParameterAnnotations":  						{  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							if(low == null)  							{  								low = new LowFreqData();  							}  							BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());  							byte num_parameters = rdr.ReadByte();  							low.parameterAnnotations = new object[num_parameters][];  							for(int j = 0; j < num_parameters; j++)  							{  								ushort num_annotations = rdr.ReadUInt16();  								low.parameterAnnotations[j] = new object[num_annotations];  								for(int k = 0; k < num_annotations; k++)  								{  									low.parameterAnnotations[j][k] = ReadAnnotation(rdr' classFile' utf8_cp);  								}  							}  							if(!rdr.IsAtEnd)  							{  								throw new ClassFormatError("{0} (RuntimeVisibleParameterAnnotations attribute has wrong length)"' classFile.Name);  							}  							break;  						}  						case "AnnotationDefault":  						{  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							if(low == null)  							{  								low = new LowFreqData();  							}  							BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());  							low.annotationDefault = ReadAnnotationElementValue(rdr' classFile' utf8_cp);  							if(!rdr.IsAtEnd)  							{  								throw new ClassFormatError("{0} (AnnotationDefault attribute has wrong length)"' classFile.Name);  							}  							break;  						}  #if STATIC_COMPILER  						case "RuntimeInvisibleAnnotations":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							foreach(object[] annot in ReadAnnotations(br' classFile' utf8_cp))  							{  								if(annot[1].Equals("Likvm/lang/Internal;"))  								{  									if (classFile.IsInterface)  									{  										StaticCompiler.IssueMessage(Message.InterfaceMethodCantBeInternal' classFile.Name' this.Name' this.Signature);  									}  									else  									{  										this.access_flags &= ~Modifiers.AccessMask;  										flags |= FLAG_MASK_INTERNAL;  									}  								}  								if(annot[1].Equals("Likvm/internal/HasCallerID;"))  								{  									flags |= FLAG_HAS_CALLERID;  								}  								if(annot[1].Equals("Likvm/lang/DllExport;"))  								{  									string name = null;  									int? ordinal = null;  									for (int j = 2; j < annot.Length; j += 2)  									{  										if (annot[j].Equals("name") && annot[j + 1] is string)  										{  											name = (string)annot[j + 1];  										}  										else if (annot[j].Equals("ordinal") && annot[j + 1] is int)  										{  											ordinal = (int)annot[j + 1];  										}  									}  									if (name != null && ordinal != null)  									{  										if (!IsStatic)  										{  											StaticCompiler.IssueMessage(Message.DllExportMustBeStaticMethod' classFile.Name' this.Name' this.Signature);  										}  										else  										{  											if (low == null)  											{  												low = new LowFreqData();  											}  											low.DllExportName = name;  											low.DllExportOrdinal = ordinal.Value;  										}  									}  								}  							}  							break;  #endif  						default:  							br.Skip(br.ReadUInt32());  							break;  					}
Magic Number,IKVM.Internal,Method,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Method,The following statement contains a magic number: switch(classFile.GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16()))  					{  						case "Deprecated":  							if(br.ReadUInt32() != 0)  							{  								throw new ClassFormatError("Invalid Deprecated attribute length");  							}  							flags |= FLAG_MASK_DEPRECATED;  							break;  						case "Code":  						{  							if(!code.IsEmpty)  							{  								throw new ClassFormatError("{0} (Duplicate Code attribute)"' classFile.Name);  							}  							BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());  							code.Read(classFile' utf8_cp' this' rdr' options);  							if(!rdr.IsAtEnd)  							{  								throw new ClassFormatError("{0} (Code attribute has wrong length)"' classFile.Name);  							}  							break;  						}  						case "Exceptions":  						{  							if(exceptions != null)  							{  								throw new ClassFormatError("{0} (Duplicate Exceptions attribute)"' classFile.Name);  							}  							BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());  							ushort count = rdr.ReadUInt16();  							exceptions = new string[count];  							for(int j = 0; j < count; j++)  							{  								exceptions[j] = classFile.GetConstantPoolClass(rdr.ReadUInt16());  							}  							if(!rdr.IsAtEnd)  							{  								throw new ClassFormatError("{0} (Exceptions attribute has wrong length)"' classFile.Name);  							}  							break;  						}  						case "Signature":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("Signature attribute has incorrect length");  							}  							signature = classFile.GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "RuntimeVisibleAnnotations":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							annotations = ReadAnnotations(br' classFile' utf8_cp);  							break;  						case "RuntimeVisibleParameterAnnotations":  						{  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							if(low == null)  							{  								low = new LowFreqData();  							}  							BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());  							byte num_parameters = rdr.ReadByte();  							low.parameterAnnotations = new object[num_parameters][];  							for(int j = 0; j < num_parameters; j++)  							{  								ushort num_annotations = rdr.ReadUInt16();  								low.parameterAnnotations[j] = new object[num_annotations];  								for(int k = 0; k < num_annotations; k++)  								{  									low.parameterAnnotations[j][k] = ReadAnnotation(rdr' classFile' utf8_cp);  								}  							}  							if(!rdr.IsAtEnd)  							{  								throw new ClassFormatError("{0} (RuntimeVisibleParameterAnnotations attribute has wrong length)"' classFile.Name);  							}  							break;  						}  						case "AnnotationDefault":  						{  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							if(low == null)  							{  								low = new LowFreqData();  							}  							BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());  							low.annotationDefault = ReadAnnotationElementValue(rdr' classFile' utf8_cp);  							if(!rdr.IsAtEnd)  							{  								throw new ClassFormatError("{0} (AnnotationDefault attribute has wrong length)"' classFile.Name);  							}  							break;  						}  #if STATIC_COMPILER  						case "RuntimeInvisibleAnnotations":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							foreach(object[] annot in ReadAnnotations(br' classFile' utf8_cp))  							{  								if(annot[1].Equals("Likvm/lang/Internal;"))  								{  									if (classFile.IsInterface)  									{  										StaticCompiler.IssueMessage(Message.InterfaceMethodCantBeInternal' classFile.Name' this.Name' this.Signature);  									}  									else  									{  										this.access_flags &= ~Modifiers.AccessMask;  										flags |= FLAG_MASK_INTERNAL;  									}  								}  								if(annot[1].Equals("Likvm/internal/HasCallerID;"))  								{  									flags |= FLAG_HAS_CALLERID;  								}  								if(annot[1].Equals("Likvm/lang/DllExport;"))  								{  									string name = null;  									int? ordinal = null;  									for (int j = 2; j < annot.Length; j += 2)  									{  										if (annot[j].Equals("name") && annot[j + 1] is string)  										{  											name = (string)annot[j + 1];  										}  										else if (annot[j].Equals("ordinal") && annot[j + 1] is int)  										{  											ordinal = (int)annot[j + 1];  										}  									}  									if (name != null && ordinal != null)  									{  										if (!IsStatic)  										{  											StaticCompiler.IssueMessage(Message.DllExportMustBeStaticMethod' classFile.Name' this.Name' this.Signature);  										}  										else  										{  											if (low == null)  											{  												low = new LowFreqData();  											}  											low.DllExportName = name;  											low.DllExportOrdinal = ordinal.Value;  										}  									}  								}  							}  							break;  #endif  						default:  							br.Skip(br.ReadUInt32());  							break;  					}
Magic Number,IKVM.Internal,Method,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Method,The following statement contains a magic number: switch(classFile.GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16()))  					{  						case "Deprecated":  							if(br.ReadUInt32() != 0)  							{  								throw new ClassFormatError("Invalid Deprecated attribute length");  							}  							flags |= FLAG_MASK_DEPRECATED;  							break;  						case "Code":  						{  							if(!code.IsEmpty)  							{  								throw new ClassFormatError("{0} (Duplicate Code attribute)"' classFile.Name);  							}  							BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());  							code.Read(classFile' utf8_cp' this' rdr' options);  							if(!rdr.IsAtEnd)  							{  								throw new ClassFormatError("{0} (Code attribute has wrong length)"' classFile.Name);  							}  							break;  						}  						case "Exceptions":  						{  							if(exceptions != null)  							{  								throw new ClassFormatError("{0} (Duplicate Exceptions attribute)"' classFile.Name);  							}  							BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());  							ushort count = rdr.ReadUInt16();  							exceptions = new string[count];  							for(int j = 0; j < count; j++)  							{  								exceptions[j] = classFile.GetConstantPoolClass(rdr.ReadUInt16());  							}  							if(!rdr.IsAtEnd)  							{  								throw new ClassFormatError("{0} (Exceptions attribute has wrong length)"' classFile.Name);  							}  							break;  						}  						case "Signature":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("Signature attribute has incorrect length");  							}  							signature = classFile.GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "RuntimeVisibleAnnotations":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							annotations = ReadAnnotations(br' classFile' utf8_cp);  							break;  						case "RuntimeVisibleParameterAnnotations":  						{  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							if(low == null)  							{  								low = new LowFreqData();  							}  							BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());  							byte num_parameters = rdr.ReadByte();  							low.parameterAnnotations = new object[num_parameters][];  							for(int j = 0; j < num_parameters; j++)  							{  								ushort num_annotations = rdr.ReadUInt16();  								low.parameterAnnotations[j] = new object[num_annotations];  								for(int k = 0; k < num_annotations; k++)  								{  									low.parameterAnnotations[j][k] = ReadAnnotation(rdr' classFile' utf8_cp);  								}  							}  							if(!rdr.IsAtEnd)  							{  								throw new ClassFormatError("{0} (RuntimeVisibleParameterAnnotations attribute has wrong length)"' classFile.Name);  							}  							break;  						}  						case "AnnotationDefault":  						{  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							if(low == null)  							{  								low = new LowFreqData();  							}  							BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());  							low.annotationDefault = ReadAnnotationElementValue(rdr' classFile' utf8_cp);  							if(!rdr.IsAtEnd)  							{  								throw new ClassFormatError("{0} (AnnotationDefault attribute has wrong length)"' classFile.Name);  							}  							break;  						}  #if STATIC_COMPILER  						case "RuntimeInvisibleAnnotations":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							foreach(object[] annot in ReadAnnotations(br' classFile' utf8_cp))  							{  								if(annot[1].Equals("Likvm/lang/Internal;"))  								{  									if (classFile.IsInterface)  									{  										StaticCompiler.IssueMessage(Message.InterfaceMethodCantBeInternal' classFile.Name' this.Name' this.Signature);  									}  									else  									{  										this.access_flags &= ~Modifiers.AccessMask;  										flags |= FLAG_MASK_INTERNAL;  									}  								}  								if(annot[1].Equals("Likvm/internal/HasCallerID;"))  								{  									flags |= FLAG_HAS_CALLERID;  								}  								if(annot[1].Equals("Likvm/lang/DllExport;"))  								{  									string name = null;  									int? ordinal = null;  									for (int j = 2; j < annot.Length; j += 2)  									{  										if (annot[j].Equals("name") && annot[j + 1] is string)  										{  											name = (string)annot[j + 1];  										}  										else if (annot[j].Equals("ordinal") && annot[j + 1] is int)  										{  											ordinal = (int)annot[j + 1];  										}  									}  									if (name != null && ordinal != null)  									{  										if (!IsStatic)  										{  											StaticCompiler.IssueMessage(Message.DllExportMustBeStaticMethod' classFile.Name' this.Name' this.Signature);  										}  										else  										{  											if (low == null)  											{  												low = new LowFreqData();  											}  											low.DllExportName = name;  											low.DllExportOrdinal = ordinal.Value;  										}  									}  								}  							}  							break;  #endif  						default:  							br.Skip(br.ReadUInt32());  							break;  					}
Magic Number,IKVM.Internal,Method,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Method,The following statement contains a magic number: switch(classFile.GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16()))  					{  						case "Deprecated":  							if(br.ReadUInt32() != 0)  							{  								throw new ClassFormatError("Invalid Deprecated attribute length");  							}  							flags |= FLAG_MASK_DEPRECATED;  							break;  						case "Code":  						{  							if(!code.IsEmpty)  							{  								throw new ClassFormatError("{0} (Duplicate Code attribute)"' classFile.Name);  							}  							BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());  							code.Read(classFile' utf8_cp' this' rdr' options);  							if(!rdr.IsAtEnd)  							{  								throw new ClassFormatError("{0} (Code attribute has wrong length)"' classFile.Name);  							}  							break;  						}  						case "Exceptions":  						{  							if(exceptions != null)  							{  								throw new ClassFormatError("{0} (Duplicate Exceptions attribute)"' classFile.Name);  							}  							BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());  							ushort count = rdr.ReadUInt16();  							exceptions = new string[count];  							for(int j = 0; j < count; j++)  							{  								exceptions[j] = classFile.GetConstantPoolClass(rdr.ReadUInt16());  							}  							if(!rdr.IsAtEnd)  							{  								throw new ClassFormatError("{0} (Exceptions attribute has wrong length)"' classFile.Name);  							}  							break;  						}  						case "Signature":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("Signature attribute has incorrect length");  							}  							signature = classFile.GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "RuntimeVisibleAnnotations":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							annotations = ReadAnnotations(br' classFile' utf8_cp);  							break;  						case "RuntimeVisibleParameterAnnotations":  						{  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							if(low == null)  							{  								low = new LowFreqData();  							}  							BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());  							byte num_parameters = rdr.ReadByte();  							low.parameterAnnotations = new object[num_parameters][];  							for(int j = 0; j < num_parameters; j++)  							{  								ushort num_annotations = rdr.ReadUInt16();  								low.parameterAnnotations[j] = new object[num_annotations];  								for(int k = 0; k < num_annotations; k++)  								{  									low.parameterAnnotations[j][k] = ReadAnnotation(rdr' classFile' utf8_cp);  								}  							}  							if(!rdr.IsAtEnd)  							{  								throw new ClassFormatError("{0} (RuntimeVisibleParameterAnnotations attribute has wrong length)"' classFile.Name);  							}  							break;  						}  						case "AnnotationDefault":  						{  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							if(low == null)  							{  								low = new LowFreqData();  							}  							BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());  							low.annotationDefault = ReadAnnotationElementValue(rdr' classFile' utf8_cp);  							if(!rdr.IsAtEnd)  							{  								throw new ClassFormatError("{0} (AnnotationDefault attribute has wrong length)"' classFile.Name);  							}  							break;  						}  #if STATIC_COMPILER  						case "RuntimeInvisibleAnnotations":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							foreach(object[] annot in ReadAnnotations(br' classFile' utf8_cp))  							{  								if(annot[1].Equals("Likvm/lang/Internal;"))  								{  									if (classFile.IsInterface)  									{  										StaticCompiler.IssueMessage(Message.InterfaceMethodCantBeInternal' classFile.Name' this.Name' this.Signature);  									}  									else  									{  										this.access_flags &= ~Modifiers.AccessMask;  										flags |= FLAG_MASK_INTERNAL;  									}  								}  								if(annot[1].Equals("Likvm/internal/HasCallerID;"))  								{  									flags |= FLAG_HAS_CALLERID;  								}  								if(annot[1].Equals("Likvm/lang/DllExport;"))  								{  									string name = null;  									int? ordinal = null;  									for (int j = 2; j < annot.Length; j += 2)  									{  										if (annot[j].Equals("name") && annot[j + 1] is string)  										{  											name = (string)annot[j + 1];  										}  										else if (annot[j].Equals("ordinal") && annot[j + 1] is int)  										{  											ordinal = (int)annot[j + 1];  										}  									}  									if (name != null && ordinal != null)  									{  										if (!IsStatic)  										{  											StaticCompiler.IssueMessage(Message.DllExportMustBeStaticMethod' classFile.Name' this.Name' this.Signature);  										}  										else  										{  											if (low == null)  											{  												low = new LowFreqData();  											}  											low.DllExportName = name;  											low.DllExportOrdinal = ordinal.Value;  										}  									}  								}  							}  							break;  #endif  						default:  							br.Skip(br.ReadUInt32());  							break;  					}
Magic Number,IKVM.Internal,Method,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Method,The following statement contains a magic number: switch(classFile.GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16()))  					{  						case "Deprecated":  							if(br.ReadUInt32() != 0)  							{  								throw new ClassFormatError("Invalid Deprecated attribute length");  							}  							flags |= FLAG_MASK_DEPRECATED;  							break;  						case "Code":  						{  							if(!code.IsEmpty)  							{  								throw new ClassFormatError("{0} (Duplicate Code attribute)"' classFile.Name);  							}  							BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());  							code.Read(classFile' utf8_cp' this' rdr' options);  							if(!rdr.IsAtEnd)  							{  								throw new ClassFormatError("{0} (Code attribute has wrong length)"' classFile.Name);  							}  							break;  						}  						case "Exceptions":  						{  							if(exceptions != null)  							{  								throw new ClassFormatError("{0} (Duplicate Exceptions attribute)"' classFile.Name);  							}  							BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());  							ushort count = rdr.ReadUInt16();  							exceptions = new string[count];  							for(int j = 0; j < count; j++)  							{  								exceptions[j] = classFile.GetConstantPoolClass(rdr.ReadUInt16());  							}  							if(!rdr.IsAtEnd)  							{  								throw new ClassFormatError("{0} (Exceptions attribute has wrong length)"' classFile.Name);  							}  							break;  						}  						case "Signature":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("Signature attribute has incorrect length");  							}  							signature = classFile.GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "RuntimeVisibleAnnotations":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							annotations = ReadAnnotations(br' classFile' utf8_cp);  							break;  						case "RuntimeVisibleParameterAnnotations":  						{  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							if(low == null)  							{  								low = new LowFreqData();  							}  							BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());  							byte num_parameters = rdr.ReadByte();  							low.parameterAnnotations = new object[num_parameters][];  							for(int j = 0; j < num_parameters; j++)  							{  								ushort num_annotations = rdr.ReadUInt16();  								low.parameterAnnotations[j] = new object[num_annotations];  								for(int k = 0; k < num_annotations; k++)  								{  									low.parameterAnnotations[j][k] = ReadAnnotation(rdr' classFile' utf8_cp);  								}  							}  							if(!rdr.IsAtEnd)  							{  								throw new ClassFormatError("{0} (RuntimeVisibleParameterAnnotations attribute has wrong length)"' classFile.Name);  							}  							break;  						}  						case "AnnotationDefault":  						{  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							if(low == null)  							{  								low = new LowFreqData();  							}  							BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());  							low.annotationDefault = ReadAnnotationElementValue(rdr' classFile' utf8_cp);  							if(!rdr.IsAtEnd)  							{  								throw new ClassFormatError("{0} (AnnotationDefault attribute has wrong length)"' classFile.Name);  							}  							break;  						}  #if STATIC_COMPILER  						case "RuntimeInvisibleAnnotations":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							foreach(object[] annot in ReadAnnotations(br' classFile' utf8_cp))  							{  								if(annot[1].Equals("Likvm/lang/Internal;"))  								{  									if (classFile.IsInterface)  									{  										StaticCompiler.IssueMessage(Message.InterfaceMethodCantBeInternal' classFile.Name' this.Name' this.Signature);  									}  									else  									{  										this.access_flags &= ~Modifiers.AccessMask;  										flags |= FLAG_MASK_INTERNAL;  									}  								}  								if(annot[1].Equals("Likvm/internal/HasCallerID;"))  								{  									flags |= FLAG_HAS_CALLERID;  								}  								if(annot[1].Equals("Likvm/lang/DllExport;"))  								{  									string name = null;  									int? ordinal = null;  									for (int j = 2; j < annot.Length; j += 2)  									{  										if (annot[j].Equals("name") && annot[j + 1] is string)  										{  											name = (string)annot[j + 1];  										}  										else if (annot[j].Equals("ordinal") && annot[j + 1] is int)  										{  											ordinal = (int)annot[j + 1];  										}  									}  									if (name != null && ordinal != null)  									{  										if (!IsStatic)  										{  											StaticCompiler.IssueMessage(Message.DllExportMustBeStaticMethod' classFile.Name' this.Name' this.Signature);  										}  										else  										{  											if (low == null)  											{  												low = new LowFreqData();  											}  											low.DllExportName = name;  											low.DllExportOrdinal = ordinal.Value;  										}  									}  								}  							}  							break;  #endif  						default:  							br.Skip(br.ReadUInt32());  							break;  					}
Magic Number,IKVM.Internal,Method,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Method,The following statement contains a magic number: switch(classFile.GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16()))  					{  						case "Deprecated":  							if(br.ReadUInt32() != 0)  							{  								throw new ClassFormatError("Invalid Deprecated attribute length");  							}  							flags |= FLAG_MASK_DEPRECATED;  							break;  						case "Code":  						{  							if(!code.IsEmpty)  							{  								throw new ClassFormatError("{0} (Duplicate Code attribute)"' classFile.Name);  							}  							BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());  							code.Read(classFile' utf8_cp' this' rdr' options);  							if(!rdr.IsAtEnd)  							{  								throw new ClassFormatError("{0} (Code attribute has wrong length)"' classFile.Name);  							}  							break;  						}  						case "Exceptions":  						{  							if(exceptions != null)  							{  								throw new ClassFormatError("{0} (Duplicate Exceptions attribute)"' classFile.Name);  							}  							BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());  							ushort count = rdr.ReadUInt16();  							exceptions = new string[count];  							for(int j = 0; j < count; j++)  							{  								exceptions[j] = classFile.GetConstantPoolClass(rdr.ReadUInt16());  							}  							if(!rdr.IsAtEnd)  							{  								throw new ClassFormatError("{0} (Exceptions attribute has wrong length)"' classFile.Name);  							}  							break;  						}  						case "Signature":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("Signature attribute has incorrect length");  							}  							signature = classFile.GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "RuntimeVisibleAnnotations":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							annotations = ReadAnnotations(br' classFile' utf8_cp);  							break;  						case "RuntimeVisibleParameterAnnotations":  						{  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							if(low == null)  							{  								low = new LowFreqData();  							}  							BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());  							byte num_parameters = rdr.ReadByte();  							low.parameterAnnotations = new object[num_parameters][];  							for(int j = 0; j < num_parameters; j++)  							{  								ushort num_annotations = rdr.ReadUInt16();  								low.parameterAnnotations[j] = new object[num_annotations];  								for(int k = 0; k < num_annotations; k++)  								{  									low.parameterAnnotations[j][k] = ReadAnnotation(rdr' classFile' utf8_cp);  								}  							}  							if(!rdr.IsAtEnd)  							{  								throw new ClassFormatError("{0} (RuntimeVisibleParameterAnnotations attribute has wrong length)"' classFile.Name);  							}  							break;  						}  						case "AnnotationDefault":  						{  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							if(low == null)  							{  								low = new LowFreqData();  							}  							BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());  							low.annotationDefault = ReadAnnotationElementValue(rdr' classFile' utf8_cp);  							if(!rdr.IsAtEnd)  							{  								throw new ClassFormatError("{0} (AnnotationDefault attribute has wrong length)"' classFile.Name);  							}  							break;  						}  #if STATIC_COMPILER  						case "RuntimeInvisibleAnnotations":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							foreach(object[] annot in ReadAnnotations(br' classFile' utf8_cp))  							{  								if(annot[1].Equals("Likvm/lang/Internal;"))  								{  									if (classFile.IsInterface)  									{  										StaticCompiler.IssueMessage(Message.InterfaceMethodCantBeInternal' classFile.Name' this.Name' this.Signature);  									}  									else  									{  										this.access_flags &= ~Modifiers.AccessMask;  										flags |= FLAG_MASK_INTERNAL;  									}  								}  								if(annot[1].Equals("Likvm/internal/HasCallerID;"))  								{  									flags |= FLAG_HAS_CALLERID;  								}  								if(annot[1].Equals("Likvm/lang/DllExport;"))  								{  									string name = null;  									int? ordinal = null;  									for (int j = 2; j < annot.Length; j += 2)  									{  										if (annot[j].Equals("name") && annot[j + 1] is string)  										{  											name = (string)annot[j + 1];  										}  										else if (annot[j].Equals("ordinal") && annot[j + 1] is int)  										{  											ordinal = (int)annot[j + 1];  										}  									}  									if (name != null && ordinal != null)  									{  										if (!IsStatic)  										{  											StaticCompiler.IssueMessage(Message.DllExportMustBeStaticMethod' classFile.Name' this.Name' this.Signature);  										}  										else  										{  											if (low == null)  											{  												low = new LowFreqData();  											}  											low.DllExportName = name;  											low.DllExportOrdinal = ordinal.Value;  										}  									}  								}  							}  							break;  #endif  						default:  							br.Skip(br.ReadUInt32());  							break;  					}
Magic Number,IKVM.Internal,Method,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Method,The following statement contains a magic number: switch(classFile.GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16()))  					{  						case "Deprecated":  							if(br.ReadUInt32() != 0)  							{  								throw new ClassFormatError("Invalid Deprecated attribute length");  							}  							flags |= FLAG_MASK_DEPRECATED;  							break;  						case "Code":  						{  							if(!code.IsEmpty)  							{  								throw new ClassFormatError("{0} (Duplicate Code attribute)"' classFile.Name);  							}  							BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());  							code.Read(classFile' utf8_cp' this' rdr' options);  							if(!rdr.IsAtEnd)  							{  								throw new ClassFormatError("{0} (Code attribute has wrong length)"' classFile.Name);  							}  							break;  						}  						case "Exceptions":  						{  							if(exceptions != null)  							{  								throw new ClassFormatError("{0} (Duplicate Exceptions attribute)"' classFile.Name);  							}  							BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());  							ushort count = rdr.ReadUInt16();  							exceptions = new string[count];  							for(int j = 0; j < count; j++)  							{  								exceptions[j] = classFile.GetConstantPoolClass(rdr.ReadUInt16());  							}  							if(!rdr.IsAtEnd)  							{  								throw new ClassFormatError("{0} (Exceptions attribute has wrong length)"' classFile.Name);  							}  							break;  						}  						case "Signature":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("Signature attribute has incorrect length");  							}  							signature = classFile.GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "RuntimeVisibleAnnotations":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							annotations = ReadAnnotations(br' classFile' utf8_cp);  							break;  						case "RuntimeVisibleParameterAnnotations":  						{  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							if(low == null)  							{  								low = new LowFreqData();  							}  							BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());  							byte num_parameters = rdr.ReadByte();  							low.parameterAnnotations = new object[num_parameters][];  							for(int j = 0; j < num_parameters; j++)  							{  								ushort num_annotations = rdr.ReadUInt16();  								low.parameterAnnotations[j] = new object[num_annotations];  								for(int k = 0; k < num_annotations; k++)  								{  									low.parameterAnnotations[j][k] = ReadAnnotation(rdr' classFile' utf8_cp);  								}  							}  							if(!rdr.IsAtEnd)  							{  								throw new ClassFormatError("{0} (RuntimeVisibleParameterAnnotations attribute has wrong length)"' classFile.Name);  							}  							break;  						}  						case "AnnotationDefault":  						{  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							if(low == null)  							{  								low = new LowFreqData();  							}  							BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());  							low.annotationDefault = ReadAnnotationElementValue(rdr' classFile' utf8_cp);  							if(!rdr.IsAtEnd)  							{  								throw new ClassFormatError("{0} (AnnotationDefault attribute has wrong length)"' classFile.Name);  							}  							break;  						}  #if STATIC_COMPILER  						case "RuntimeInvisibleAnnotations":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							foreach(object[] annot in ReadAnnotations(br' classFile' utf8_cp))  							{  								if(annot[1].Equals("Likvm/lang/Internal;"))  								{  									if (classFile.IsInterface)  									{  										StaticCompiler.IssueMessage(Message.InterfaceMethodCantBeInternal' classFile.Name' this.Name' this.Signature);  									}  									else  									{  										this.access_flags &= ~Modifiers.AccessMask;  										flags |= FLAG_MASK_INTERNAL;  									}  								}  								if(annot[1].Equals("Likvm/internal/HasCallerID;"))  								{  									flags |= FLAG_HAS_CALLERID;  								}  								if(annot[1].Equals("Likvm/lang/DllExport;"))  								{  									string name = null;  									int? ordinal = null;  									for (int j = 2; j < annot.Length; j += 2)  									{  										if (annot[j].Equals("name") && annot[j + 1] is string)  										{  											name = (string)annot[j + 1];  										}  										else if (annot[j].Equals("ordinal") && annot[j + 1] is int)  										{  											ordinal = (int)annot[j + 1];  										}  									}  									if (name != null && ordinal != null)  									{  										if (!IsStatic)  										{  											StaticCompiler.IssueMessage(Message.DllExportMustBeStaticMethod' classFile.Name' this.Name' this.Signature);  										}  										else  										{  											if (low == null)  											{  												low = new LowFreqData();  											}  											low.DllExportName = name;  											low.DllExportOrdinal = ordinal.Value;  										}  									}  								}  							}  							break;  #endif  						default:  							br.Skip(br.ReadUInt32());  							break;  					}
Magic Number,IKVM.Internal,Method,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Method,The following statement contains a magic number: switch(classFile.GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16()))  					{  						case "Deprecated":  							if(br.ReadUInt32() != 0)  							{  								throw new ClassFormatError("Invalid Deprecated attribute length");  							}  							flags |= FLAG_MASK_DEPRECATED;  							break;  						case "Code":  						{  							if(!code.IsEmpty)  							{  								throw new ClassFormatError("{0} (Duplicate Code attribute)"' classFile.Name);  							}  							BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());  							code.Read(classFile' utf8_cp' this' rdr' options);  							if(!rdr.IsAtEnd)  							{  								throw new ClassFormatError("{0} (Code attribute has wrong length)"' classFile.Name);  							}  							break;  						}  						case "Exceptions":  						{  							if(exceptions != null)  							{  								throw new ClassFormatError("{0} (Duplicate Exceptions attribute)"' classFile.Name);  							}  							BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());  							ushort count = rdr.ReadUInt16();  							exceptions = new string[count];  							for(int j = 0; j < count; j++)  							{  								exceptions[j] = classFile.GetConstantPoolClass(rdr.ReadUInt16());  							}  							if(!rdr.IsAtEnd)  							{  								throw new ClassFormatError("{0} (Exceptions attribute has wrong length)"' classFile.Name);  							}  							break;  						}  						case "Signature":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							if(br.ReadUInt32() != 2)  							{  								throw new ClassFormatError("Signature attribute has incorrect length");  							}  							signature = classFile.GetConstantPoolUtf8String(utf8_cp' br.ReadUInt16());  							break;  						case "RuntimeVisibleAnnotations":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							annotations = ReadAnnotations(br' classFile' utf8_cp);  							break;  						case "RuntimeVisibleParameterAnnotations":  						{  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							if(low == null)  							{  								low = new LowFreqData();  							}  							BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());  							byte num_parameters = rdr.ReadByte();  							low.parameterAnnotations = new object[num_parameters][];  							for(int j = 0; j < num_parameters; j++)  							{  								ushort num_annotations = rdr.ReadUInt16();  								low.parameterAnnotations[j] = new object[num_annotations];  								for(int k = 0; k < num_annotations; k++)  								{  									low.parameterAnnotations[j][k] = ReadAnnotation(rdr' classFile' utf8_cp);  								}  							}  							if(!rdr.IsAtEnd)  							{  								throw new ClassFormatError("{0} (RuntimeVisibleParameterAnnotations attribute has wrong length)"' classFile.Name);  							}  							break;  						}  						case "AnnotationDefault":  						{  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							if(low == null)  							{  								low = new LowFreqData();  							}  							BigEndianBinaryReader rdr = br.Section(br.ReadUInt32());  							low.annotationDefault = ReadAnnotationElementValue(rdr' classFile' utf8_cp);  							if(!rdr.IsAtEnd)  							{  								throw new ClassFormatError("{0} (AnnotationDefault attribute has wrong length)"' classFile.Name);  							}  							break;  						}  #if STATIC_COMPILER  						case "RuntimeInvisibleAnnotations":  							if(classFile.MajorVersion < 49)  							{  								goto default;  							}  							foreach(object[] annot in ReadAnnotations(br' classFile' utf8_cp))  							{  								if(annot[1].Equals("Likvm/lang/Internal;"))  								{  									if (classFile.IsInterface)  									{  										StaticCompiler.IssueMessage(Message.InterfaceMethodCantBeInternal' classFile.Name' this.Name' this.Signature);  									}  									else  									{  										this.access_flags &= ~Modifiers.AccessMask;  										flags |= FLAG_MASK_INTERNAL;  									}  								}  								if(annot[1].Equals("Likvm/internal/HasCallerID;"))  								{  									flags |= FLAG_HAS_CALLERID;  								}  								if(annot[1].Equals("Likvm/lang/DllExport;"))  								{  									string name = null;  									int? ordinal = null;  									for (int j = 2; j < annot.Length; j += 2)  									{  										if (annot[j].Equals("name") && annot[j + 1] is string)  										{  											name = (string)annot[j + 1];  										}  										else if (annot[j].Equals("ordinal") && annot[j + 1] is int)  										{  											ordinal = (int)annot[j + 1];  										}  									}  									if (name != null && ordinal != null)  									{  										if (!IsStatic)  										{  											StaticCompiler.IssueMessage(Message.DllExportMustBeStaticMethod' classFile.Name' this.Name' this.Signature);  										}  										else  										{  											if (low == null)  											{  												low = new LowFreqData();  											}  											low.DllExportName = name;  											low.DllExportOrdinal = ordinal.Value;  										}  									}  								}  							}  							break;  #endif  						default:  							br.Skip(br.ReadUInt32());  							break;  					}
Magic Number,IKVM.Internal,Code,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Read,The following statement contains a magic number: code_length > 65535
Magic Number,IKVM.Internal,Instruction,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Read,The following statement contains a magic number: switch(ByteCodeMetaData.GetMode(bc))  					{  						case ByteCodeMode.Simple:  							break;  						case ByteCodeMode.Constant_1:  							arg1 = br.ReadByte();  							classFile.MarkLinkRequiredConstantPoolItem(arg1);  							break;  						case ByteCodeMode.Local_1:  							arg1 = br.ReadByte();  							break;  						case ByteCodeMode.Constant_2:  							arg1 = br.ReadUInt16();  							classFile.MarkLinkRequiredConstantPoolItem(arg1);  							break;  						case ByteCodeMode.Branch_2:  							arg1 = br.ReadInt16();  							break;  						case ByteCodeMode.Branch_4:  							arg1 = br.ReadInt32();  							break;  						case ByteCodeMode.Constant_2_1_1:  							arg1 = br.ReadUInt16();  							classFile.MarkLinkRequiredConstantPoolItem(arg1);  							arg2 = br.ReadByte();  							if(br.ReadByte() != 0)  							{  								throw new ClassFormatError("invokeinterface filler must be zero");  							}  							break;  						case ByteCodeMode.Immediate_1:  							arg1 = br.ReadSByte();  							break;  						case ByteCodeMode.Immediate_2:  							arg1 = br.ReadInt16();  							break;  						case ByteCodeMode.Local_1_Immediate_1:  							arg1 = br.ReadByte();  							arg2 = br.ReadSByte();  							break;  						case ByteCodeMode.Constant_2_Immediate_1:  							arg1 = br.ReadUInt16();  							classFile.MarkLinkRequiredConstantPoolItem(arg1);  							arg2 = br.ReadSByte();  							break;  						case ByteCodeMode.Tableswitch:  						{  							// skip the padding  							uint p = pc + 1u;  							uint align = ((p + 3) & 0x7ffffffc) - p;  							br.Skip(align);  							int default_offset = br.ReadInt32();  							this.arg1 = default_offset;  							int low = br.ReadInt32();  							int high = br.ReadInt32();  							if(low > high || high > 16384L + low)  							{  								throw new ClassFormatError("Incorrect tableswitch");  							}  							SwitchEntry[] entries = new SwitchEntry[high - low + 1];  							for(int i = low; i < high; i++)  							{  								entries[i - low].value = i;  								entries[i - low].target = br.ReadInt32();  							}  							// do the last entry outside the loop' to avoid overflowing "i"' if high == int.MaxValue  							entries[high - low].value = high;  							entries[high - low].target = br.ReadInt32();  							this.switch_entries = entries;  							break;  						}  						case ByteCodeMode.Lookupswitch:  						{  							// skip the padding  							uint p = pc + 1u;  							uint align = ((p + 3) & 0x7ffffffc) - p;  							br.Skip(align);  							int default_offset = br.ReadInt32();  							this.arg1 = default_offset;  							int count = br.ReadInt32();  							if(count < 0 || count > 16384)  							{  								throw new ClassFormatError("Incorrect lookupswitch");  							}  							SwitchEntry[] entries = new SwitchEntry[count];  							for(int i = 0; i < count; i++)  							{  								entries[i].value = br.ReadInt32();  								entries[i].target = br.ReadInt32();  							}  							this.switch_entries = entries;  							break;  						}  						case ByteCodeMode.WidePrefix:  							bc = (ByteCode)br.ReadByte();  							// NOTE the PC of a wide instruction is actually the PC of the  							// wide prefix' not the following instruction (vmspec 4.9.2)  						switch(ByteCodeMetaData.GetWideMode(bc))  						{  							case ByteCodeModeWide.Local_2:  								arg1 = br.ReadUInt16();  								break;  							case ByteCodeModeWide.Local_2_Immediate_2:  								arg1 = br.ReadUInt16();  								arg2 = br.ReadInt16();  								break;  							default:  								throw new ClassFormatError("Invalid wide prefix on opcode: {0}"' bc);  						}  							break;  						default:  							throw new ClassFormatError("Invalid opcode: {0}"' bc);  					}
Magic Number,IKVM.Internal,Instruction,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Read,The following statement contains a magic number: switch(ByteCodeMetaData.GetMode(bc))  					{  						case ByteCodeMode.Simple:  							break;  						case ByteCodeMode.Constant_1:  							arg1 = br.ReadByte();  							classFile.MarkLinkRequiredConstantPoolItem(arg1);  							break;  						case ByteCodeMode.Local_1:  							arg1 = br.ReadByte();  							break;  						case ByteCodeMode.Constant_2:  							arg1 = br.ReadUInt16();  							classFile.MarkLinkRequiredConstantPoolItem(arg1);  							break;  						case ByteCodeMode.Branch_2:  							arg1 = br.ReadInt16();  							break;  						case ByteCodeMode.Branch_4:  							arg1 = br.ReadInt32();  							break;  						case ByteCodeMode.Constant_2_1_1:  							arg1 = br.ReadUInt16();  							classFile.MarkLinkRequiredConstantPoolItem(arg1);  							arg2 = br.ReadByte();  							if(br.ReadByte() != 0)  							{  								throw new ClassFormatError("invokeinterface filler must be zero");  							}  							break;  						case ByteCodeMode.Immediate_1:  							arg1 = br.ReadSByte();  							break;  						case ByteCodeMode.Immediate_2:  							arg1 = br.ReadInt16();  							break;  						case ByteCodeMode.Local_1_Immediate_1:  							arg1 = br.ReadByte();  							arg2 = br.ReadSByte();  							break;  						case ByteCodeMode.Constant_2_Immediate_1:  							arg1 = br.ReadUInt16();  							classFile.MarkLinkRequiredConstantPoolItem(arg1);  							arg2 = br.ReadSByte();  							break;  						case ByteCodeMode.Tableswitch:  						{  							// skip the padding  							uint p = pc + 1u;  							uint align = ((p + 3) & 0x7ffffffc) - p;  							br.Skip(align);  							int default_offset = br.ReadInt32();  							this.arg1 = default_offset;  							int low = br.ReadInt32();  							int high = br.ReadInt32();  							if(low > high || high > 16384L + low)  							{  								throw new ClassFormatError("Incorrect tableswitch");  							}  							SwitchEntry[] entries = new SwitchEntry[high - low + 1];  							for(int i = low; i < high; i++)  							{  								entries[i - low].value = i;  								entries[i - low].target = br.ReadInt32();  							}  							// do the last entry outside the loop' to avoid overflowing "i"' if high == int.MaxValue  							entries[high - low].value = high;  							entries[high - low].target = br.ReadInt32();  							this.switch_entries = entries;  							break;  						}  						case ByteCodeMode.Lookupswitch:  						{  							// skip the padding  							uint p = pc + 1u;  							uint align = ((p + 3) & 0x7ffffffc) - p;  							br.Skip(align);  							int default_offset = br.ReadInt32();  							this.arg1 = default_offset;  							int count = br.ReadInt32();  							if(count < 0 || count > 16384)  							{  								throw new ClassFormatError("Incorrect lookupswitch");  							}  							SwitchEntry[] entries = new SwitchEntry[count];  							for(int i = 0; i < count; i++)  							{  								entries[i].value = br.ReadInt32();  								entries[i].target = br.ReadInt32();  							}  							this.switch_entries = entries;  							break;  						}  						case ByteCodeMode.WidePrefix:  							bc = (ByteCode)br.ReadByte();  							// NOTE the PC of a wide instruction is actually the PC of the  							// wide prefix' not the following instruction (vmspec 4.9.2)  						switch(ByteCodeMetaData.GetWideMode(bc))  						{  							case ByteCodeModeWide.Local_2:  								arg1 = br.ReadUInt16();  								break;  							case ByteCodeModeWide.Local_2_Immediate_2:  								arg1 = br.ReadUInt16();  								arg2 = br.ReadInt16();  								break;  							default:  								throw new ClassFormatError("Invalid wide prefix on opcode: {0}"' bc);  						}  							break;  						default:  							throw new ClassFormatError("Invalid opcode: {0}"' bc);  					}
Magic Number,IKVM.Internal,Instruction,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Read,The following statement contains a magic number: switch(ByteCodeMetaData.GetMode(bc))  					{  						case ByteCodeMode.Simple:  							break;  						case ByteCodeMode.Constant_1:  							arg1 = br.ReadByte();  							classFile.MarkLinkRequiredConstantPoolItem(arg1);  							break;  						case ByteCodeMode.Local_1:  							arg1 = br.ReadByte();  							break;  						case ByteCodeMode.Constant_2:  							arg1 = br.ReadUInt16();  							classFile.MarkLinkRequiredConstantPoolItem(arg1);  							break;  						case ByteCodeMode.Branch_2:  							arg1 = br.ReadInt16();  							break;  						case ByteCodeMode.Branch_4:  							arg1 = br.ReadInt32();  							break;  						case ByteCodeMode.Constant_2_1_1:  							arg1 = br.ReadUInt16();  							classFile.MarkLinkRequiredConstantPoolItem(arg1);  							arg2 = br.ReadByte();  							if(br.ReadByte() != 0)  							{  								throw new ClassFormatError("invokeinterface filler must be zero");  							}  							break;  						case ByteCodeMode.Immediate_1:  							arg1 = br.ReadSByte();  							break;  						case ByteCodeMode.Immediate_2:  							arg1 = br.ReadInt16();  							break;  						case ByteCodeMode.Local_1_Immediate_1:  							arg1 = br.ReadByte();  							arg2 = br.ReadSByte();  							break;  						case ByteCodeMode.Constant_2_Immediate_1:  							arg1 = br.ReadUInt16();  							classFile.MarkLinkRequiredConstantPoolItem(arg1);  							arg2 = br.ReadSByte();  							break;  						case ByteCodeMode.Tableswitch:  						{  							// skip the padding  							uint p = pc + 1u;  							uint align = ((p + 3) & 0x7ffffffc) - p;  							br.Skip(align);  							int default_offset = br.ReadInt32();  							this.arg1 = default_offset;  							int low = br.ReadInt32();  							int high = br.ReadInt32();  							if(low > high || high > 16384L + low)  							{  								throw new ClassFormatError("Incorrect tableswitch");  							}  							SwitchEntry[] entries = new SwitchEntry[high - low + 1];  							for(int i = low; i < high; i++)  							{  								entries[i - low].value = i;  								entries[i - low].target = br.ReadInt32();  							}  							// do the last entry outside the loop' to avoid overflowing "i"' if high == int.MaxValue  							entries[high - low].value = high;  							entries[high - low].target = br.ReadInt32();  							this.switch_entries = entries;  							break;  						}  						case ByteCodeMode.Lookupswitch:  						{  							// skip the padding  							uint p = pc + 1u;  							uint align = ((p + 3) & 0x7ffffffc) - p;  							br.Skip(align);  							int default_offset = br.ReadInt32();  							this.arg1 = default_offset;  							int count = br.ReadInt32();  							if(count < 0 || count > 16384)  							{  								throw new ClassFormatError("Incorrect lookupswitch");  							}  							SwitchEntry[] entries = new SwitchEntry[count];  							for(int i = 0; i < count; i++)  							{  								entries[i].value = br.ReadInt32();  								entries[i].target = br.ReadInt32();  							}  							this.switch_entries = entries;  							break;  						}  						case ByteCodeMode.WidePrefix:  							bc = (ByteCode)br.ReadByte();  							// NOTE the PC of a wide instruction is actually the PC of the  							// wide prefix' not the following instruction (vmspec 4.9.2)  						switch(ByteCodeMetaData.GetWideMode(bc))  						{  							case ByteCodeModeWide.Local_2:  								arg1 = br.ReadUInt16();  								break;  							case ByteCodeModeWide.Local_2_Immediate_2:  								arg1 = br.ReadUInt16();  								arg2 = br.ReadInt16();  								break;  							default:  								throw new ClassFormatError("Invalid wide prefix on opcode: {0}"' bc);  						}  							break;  						default:  							throw new ClassFormatError("Invalid opcode: {0}"' bc);  					}
Magic Number,IKVM.Internal,Instruction,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Read,The following statement contains a magic number: switch(ByteCodeMetaData.GetMode(bc))  					{  						case ByteCodeMode.Simple:  							break;  						case ByteCodeMode.Constant_1:  							arg1 = br.ReadByte();  							classFile.MarkLinkRequiredConstantPoolItem(arg1);  							break;  						case ByteCodeMode.Local_1:  							arg1 = br.ReadByte();  							break;  						case ByteCodeMode.Constant_2:  							arg1 = br.ReadUInt16();  							classFile.MarkLinkRequiredConstantPoolItem(arg1);  							break;  						case ByteCodeMode.Branch_2:  							arg1 = br.ReadInt16();  							break;  						case ByteCodeMode.Branch_4:  							arg1 = br.ReadInt32();  							break;  						case ByteCodeMode.Constant_2_1_1:  							arg1 = br.ReadUInt16();  							classFile.MarkLinkRequiredConstantPoolItem(arg1);  							arg2 = br.ReadByte();  							if(br.ReadByte() != 0)  							{  								throw new ClassFormatError("invokeinterface filler must be zero");  							}  							break;  						case ByteCodeMode.Immediate_1:  							arg1 = br.ReadSByte();  							break;  						case ByteCodeMode.Immediate_2:  							arg1 = br.ReadInt16();  							break;  						case ByteCodeMode.Local_1_Immediate_1:  							arg1 = br.ReadByte();  							arg2 = br.ReadSByte();  							break;  						case ByteCodeMode.Constant_2_Immediate_1:  							arg1 = br.ReadUInt16();  							classFile.MarkLinkRequiredConstantPoolItem(arg1);  							arg2 = br.ReadSByte();  							break;  						case ByteCodeMode.Tableswitch:  						{  							// skip the padding  							uint p = pc + 1u;  							uint align = ((p + 3) & 0x7ffffffc) - p;  							br.Skip(align);  							int default_offset = br.ReadInt32();  							this.arg1 = default_offset;  							int low = br.ReadInt32();  							int high = br.ReadInt32();  							if(low > high || high > 16384L + low)  							{  								throw new ClassFormatError("Incorrect tableswitch");  							}  							SwitchEntry[] entries = new SwitchEntry[high - low + 1];  							for(int i = low; i < high; i++)  							{  								entries[i - low].value = i;  								entries[i - low].target = br.ReadInt32();  							}  							// do the last entry outside the loop' to avoid overflowing "i"' if high == int.MaxValue  							entries[high - low].value = high;  							entries[high - low].target = br.ReadInt32();  							this.switch_entries = entries;  							break;  						}  						case ByteCodeMode.Lookupswitch:  						{  							// skip the padding  							uint p = pc + 1u;  							uint align = ((p + 3) & 0x7ffffffc) - p;  							br.Skip(align);  							int default_offset = br.ReadInt32();  							this.arg1 = default_offset;  							int count = br.ReadInt32();  							if(count < 0 || count > 16384)  							{  								throw new ClassFormatError("Incorrect lookupswitch");  							}  							SwitchEntry[] entries = new SwitchEntry[count];  							for(int i = 0; i < count; i++)  							{  								entries[i].value = br.ReadInt32();  								entries[i].target = br.ReadInt32();  							}  							this.switch_entries = entries;  							break;  						}  						case ByteCodeMode.WidePrefix:  							bc = (ByteCode)br.ReadByte();  							// NOTE the PC of a wide instruction is actually the PC of the  							// wide prefix' not the following instruction (vmspec 4.9.2)  						switch(ByteCodeMetaData.GetWideMode(bc))  						{  							case ByteCodeModeWide.Local_2:  								arg1 = br.ReadUInt16();  								break;  							case ByteCodeModeWide.Local_2_Immediate_2:  								arg1 = br.ReadUInt16();  								arg2 = br.ReadInt16();  								break;  							default:  								throw new ClassFormatError("Invalid wide prefix on opcode: {0}"' bc);  						}  							break;  						default:  							throw new ClassFormatError("Invalid opcode: {0}"' bc);  					}
Magic Number,IKVM.Internal,ClassLoaderWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassLoaderWrapper.cs,LoadArrayClass,The following statement contains a magic number: !name.EndsWith(";") || name.Length <= dims + 2 || name[dims + 1] == '['
Magic Number,IKVM.Internal,ClassLoaderWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassLoaderWrapper.cs,LoadArrayClass,The following statement contains a magic number: string elemClass = name.Substring(dims + 1' name.Length - dims - 2);
Magic Number,IKVM.Internal,ClassLoaderWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassLoaderWrapper.cs,LoadGenericClass,The following statement contains a magic number: pos += 5;
Magic Number,IKVM.Internal,ClassLoaderWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassLoaderWrapper.cs,LoadGenericClass,The following statement contains a magic number: start = pos + 4;
Magic Number,IKVM.Internal,ClassLoaderWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassLoaderWrapper.cs,LoadGenericClass,The following statement contains a magic number: pos += 4;
Magic Number,IKVM.Internal,ClassLoaderWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassLoaderWrapper.cs,LoadGenericClass,The following statement contains a magic number: name.IndexOf("_$$_"' pos' 4) == pos
Magic Number,IKVM.Internal,ClassLoaderWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassLoaderWrapper.cs,GetGenericClassLoaderByName,The following statement contains a magic number: name[i + 2] == '['
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,AnnihilatePops,The following statement contains a magic number: code.RemoveRange(i - 1' 2);
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,AnnihilatePops,The following statement contains a magic number: i -= 2;
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizeBranchSizes,The following statement contains a magic number: -128 <= diff && diff <= 127
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizeBranchSizes,The following statement contains a magic number: -128 <= diff && diff <= 127
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizePatterns,The following statement contains a magic number: code.RemoveRange(i + 1' 2);
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizePatterns,The following statement contains a magic number: code[i].opcode == OpCodes.Isinst  					&& code[i + 1].opcode == OpCodes.Ldnull  					&& code[i + 2].opcode == OpCodes.Cgt_Un  					&& (code[i + 3].opcode == OpCodes.Brfalse || code[i + 3].opcode == OpCodes.Brtrue)
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizePatterns,The following statement contains a magic number: code[i].opcode == OpCodes.Isinst  					&& code[i + 1].opcode == OpCodes.Ldnull  					&& code[i + 2].opcode == OpCodes.Cgt_Un  					&& (code[i + 3].opcode == OpCodes.Brfalse || code[i + 3].opcode == OpCodes.Brtrue)
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizePatterns,The following statement contains a magic number: code[i].opcode == OpCodes.Isinst  					&& code[i + 1].opcode == OpCodes.Ldnull  					&& code[i + 2].opcode == OpCodes.Cgt_Un  					&& (code[i + 3].opcode == OpCodes.Brfalse || code[i + 3].opcode == OpCodes.Brtrue)
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizePatterns,The following statement contains a magic number: code.RemoveRange(i + 1' 5);
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizePatterns,The following statement contains a magic number: i < code.Count - 6  					&& code[i].opcode.FlowControl == FlowControl.Cond_Branch  					&& code[i + 1].opcode == OpCodes.Ldc_I4 && code[i + 1].ValueInt32 == 1  					&& code[i + 2].opcode == OpCodes.Br  					&& code[i + 3].pseudo == CodeType.Label && code[i + 3].MatchLabel(code[i]) && code[i + 3].Label.Temp == 1  					&& code[i + 4].opcode == OpCodes.Ldc_I4 && code[i + 4].ValueInt32 == 0  					&& code[i + 5].pseudo == CodeType.Label && code[i + 5].MatchLabel(code[i + 2]) && code[i + 5].Label.Temp == 1
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizePatterns,The following statement contains a magic number: i < code.Count - 6  					&& code[i].opcode.FlowControl == FlowControl.Cond_Branch  					&& code[i + 1].opcode == OpCodes.Ldc_I4 && code[i + 1].ValueInt32 == 1  					&& code[i + 2].opcode == OpCodes.Br  					&& code[i + 3].pseudo == CodeType.Label && code[i + 3].MatchLabel(code[i]) && code[i + 3].Label.Temp == 1  					&& code[i + 4].opcode == OpCodes.Ldc_I4 && code[i + 4].ValueInt32 == 0  					&& code[i + 5].pseudo == CodeType.Label && code[i + 5].MatchLabel(code[i + 2]) && code[i + 5].Label.Temp == 1
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizePatterns,The following statement contains a magic number: i < code.Count - 6  					&& code[i].opcode.FlowControl == FlowControl.Cond_Branch  					&& code[i + 1].opcode == OpCodes.Ldc_I4 && code[i + 1].ValueInt32 == 1  					&& code[i + 2].opcode == OpCodes.Br  					&& code[i + 3].pseudo == CodeType.Label && code[i + 3].MatchLabel(code[i]) && code[i + 3].Label.Temp == 1  					&& code[i + 4].opcode == OpCodes.Ldc_I4 && code[i + 4].ValueInt32 == 0  					&& code[i + 5].pseudo == CodeType.Label && code[i + 5].MatchLabel(code[i + 2]) && code[i + 5].Label.Temp == 1
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizePatterns,The following statement contains a magic number: i < code.Count - 6  					&& code[i].opcode.FlowControl == FlowControl.Cond_Branch  					&& code[i + 1].opcode == OpCodes.Ldc_I4 && code[i + 1].ValueInt32 == 1  					&& code[i + 2].opcode == OpCodes.Br  					&& code[i + 3].pseudo == CodeType.Label && code[i + 3].MatchLabel(code[i]) && code[i + 3].Label.Temp == 1  					&& code[i + 4].opcode == OpCodes.Ldc_I4 && code[i + 4].ValueInt32 == 0  					&& code[i + 5].pseudo == CodeType.Label && code[i + 5].MatchLabel(code[i + 2]) && code[i + 5].Label.Temp == 1
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizePatterns,The following statement contains a magic number: i < code.Count - 6  					&& code[i].opcode.FlowControl == FlowControl.Cond_Branch  					&& code[i + 1].opcode == OpCodes.Ldc_I4 && code[i + 1].ValueInt32 == 1  					&& code[i + 2].opcode == OpCodes.Br  					&& code[i + 3].pseudo == CodeType.Label && code[i + 3].MatchLabel(code[i]) && code[i + 3].Label.Temp == 1  					&& code[i + 4].opcode == OpCodes.Ldc_I4 && code[i + 4].ValueInt32 == 0  					&& code[i + 5].pseudo == CodeType.Label && code[i + 5].MatchLabel(code[i + 2]) && code[i + 5].Label.Temp == 1
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizePatterns,The following statement contains a magic number: i < code.Count - 6  					&& code[i].opcode.FlowControl == FlowControl.Cond_Branch  					&& code[i + 1].opcode == OpCodes.Ldc_I4 && code[i + 1].ValueInt32 == 1  					&& code[i + 2].opcode == OpCodes.Br  					&& code[i + 3].pseudo == CodeType.Label && code[i + 3].MatchLabel(code[i]) && code[i + 3].Label.Temp == 1  					&& code[i + 4].opcode == OpCodes.Ldc_I4 && code[i + 4].ValueInt32 == 0  					&& code[i + 5].pseudo == CodeType.Label && code[i + 5].MatchLabel(code[i + 2]) && code[i + 5].Label.Temp == 1
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizePatterns,The following statement contains a magic number: i < code.Count - 6  					&& code[i].opcode.FlowControl == FlowControl.Cond_Branch  					&& code[i + 1].opcode == OpCodes.Ldc_I4 && code[i + 1].ValueInt32 == 1  					&& code[i + 2].opcode == OpCodes.Br  					&& code[i + 3].pseudo == CodeType.Label && code[i + 3].MatchLabel(code[i]) && code[i + 3].Label.Temp == 1  					&& code[i + 4].opcode == OpCodes.Ldc_I4 && code[i + 4].ValueInt32 == 0  					&& code[i + 5].pseudo == CodeType.Label && code[i + 5].MatchLabel(code[i + 2]) && code[i + 5].Label.Temp == 1
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizePatterns,The following statement contains a magic number: i < code.Count - 6  					&& code[i].opcode.FlowControl == FlowControl.Cond_Branch  					&& code[i + 1].opcode == OpCodes.Ldc_I4 && code[i + 1].ValueInt32 == 1  					&& code[i + 2].opcode == OpCodes.Br  					&& code[i + 3].pseudo == CodeType.Label && code[i + 3].MatchLabel(code[i]) && code[i + 3].Label.Temp == 1  					&& code[i + 4].opcode == OpCodes.Ldc_I4 && code[i + 4].ValueInt32 == 0  					&& code[i + 5].pseudo == CodeType.Label && code[i + 5].MatchLabel(code[i + 2]) && code[i + 5].Label.Temp == 1
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizePatterns,The following statement contains a magic number: i < code.Count - 6  					&& code[i].opcode.FlowControl == FlowControl.Cond_Branch  					&& code[i + 1].opcode == OpCodes.Ldc_I4 && code[i + 1].ValueInt32 == 1  					&& code[i + 2].opcode == OpCodes.Br  					&& code[i + 3].pseudo == CodeType.Label && code[i + 3].MatchLabel(code[i]) && code[i + 3].Label.Temp == 1  					&& code[i + 4].opcode == OpCodes.Ldc_I4 && code[i + 4].ValueInt32 == 0  					&& code[i + 5].pseudo == CodeType.Label && code[i + 5].MatchLabel(code[i + 2]) && code[i + 5].Label.Temp == 1
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizePatterns,The following statement contains a magic number: i < code.Count - 6  					&& code[i].opcode.FlowControl == FlowControl.Cond_Branch  					&& code[i + 1].opcode == OpCodes.Ldc_I4 && code[i + 1].ValueInt32 == 1  					&& code[i + 2].opcode == OpCodes.Br  					&& code[i + 3].pseudo == CodeType.Label && code[i + 3].MatchLabel(code[i]) && code[i + 3].Label.Temp == 1  					&& code[i + 4].opcode == OpCodes.Ldc_I4 && code[i + 4].ValueInt32 == 0  					&& code[i + 5].pseudo == CodeType.Label && code[i + 5].MatchLabel(code[i + 2]) && code[i + 5].Label.Temp == 1
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizePatterns,The following statement contains a magic number: i < code.Count - 6  					&& code[i].opcode.FlowControl == FlowControl.Cond_Branch  					&& code[i + 1].opcode == OpCodes.Ldc_I4 && code[i + 1].ValueInt32 == 1  					&& code[i + 2].opcode == OpCodes.Br  					&& code[i + 3].pseudo == CodeType.Label && code[i + 3].MatchLabel(code[i]) && code[i + 3].Label.Temp == 1  					&& code[i + 4].opcode == OpCodes.Ldc_I4 && code[i + 4].ValueInt32 == 0  					&& code[i + 5].pseudo == CodeType.Label && code[i + 5].MatchLabel(code[i + 2]) && code[i + 5].Label.Temp == 1
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,MatchCompare,The following statement contains a magic number: return code[index].opcode == OpCodes.Stloc && code[index].Local.LocalType == type  				&& code[index + 1].opcode == OpCodes.Stloc && code[index + 1].Local.LocalType == type  				&& code[index + 2].opcode == OpCodes.Ldloc && code[index + 2].MatchLocal(code[index + 1])  				&& code[index + 3].opcode == OpCodes.Ldloc && code[index + 3].MatchLocal(code[index])  				&& code[index + 4].opcode == cmp1  				&& code[index + 5].opcode == OpCodes.Ldloc && code[index + 5].MatchLocal(code[index + 1])  				&& code[index + 6].opcode == OpCodes.Ldloc && code[index + 6].MatchLocal(code[index])  				&& code[index + 7].opcode == cmp2  				&& code[index + 8].opcode == OpCodes.Sub  				&& code[index + 9].pseudo == CodeType.ReleaseTempLocal && code[index + 9].Local == code[index].Local  				&& code[index + 10].pseudo == CodeType.ReleaseTempLocal && code[index + 10].Local == code[index + 1].Local  				&& ((code[index + 11].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 11].HasLabel) ||  					(code[index + 11].opcode == OpCodes.Ldc_I4_0  					&& (code[index + 12].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 12].HasLabel)));
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,MatchCompare,The following statement contains a magic number: return code[index].opcode == OpCodes.Stloc && code[index].Local.LocalType == type  				&& code[index + 1].opcode == OpCodes.Stloc && code[index + 1].Local.LocalType == type  				&& code[index + 2].opcode == OpCodes.Ldloc && code[index + 2].MatchLocal(code[index + 1])  				&& code[index + 3].opcode == OpCodes.Ldloc && code[index + 3].MatchLocal(code[index])  				&& code[index + 4].opcode == cmp1  				&& code[index + 5].opcode == OpCodes.Ldloc && code[index + 5].MatchLocal(code[index + 1])  				&& code[index + 6].opcode == OpCodes.Ldloc && code[index + 6].MatchLocal(code[index])  				&& code[index + 7].opcode == cmp2  				&& code[index + 8].opcode == OpCodes.Sub  				&& code[index + 9].pseudo == CodeType.ReleaseTempLocal && code[index + 9].Local == code[index].Local  				&& code[index + 10].pseudo == CodeType.ReleaseTempLocal && code[index + 10].Local == code[index + 1].Local  				&& ((code[index + 11].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 11].HasLabel) ||  					(code[index + 11].opcode == OpCodes.Ldc_I4_0  					&& (code[index + 12].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 12].HasLabel)));
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,MatchCompare,The following statement contains a magic number: return code[index].opcode == OpCodes.Stloc && code[index].Local.LocalType == type  				&& code[index + 1].opcode == OpCodes.Stloc && code[index + 1].Local.LocalType == type  				&& code[index + 2].opcode == OpCodes.Ldloc && code[index + 2].MatchLocal(code[index + 1])  				&& code[index + 3].opcode == OpCodes.Ldloc && code[index + 3].MatchLocal(code[index])  				&& code[index + 4].opcode == cmp1  				&& code[index + 5].opcode == OpCodes.Ldloc && code[index + 5].MatchLocal(code[index + 1])  				&& code[index + 6].opcode == OpCodes.Ldloc && code[index + 6].MatchLocal(code[index])  				&& code[index + 7].opcode == cmp2  				&& code[index + 8].opcode == OpCodes.Sub  				&& code[index + 9].pseudo == CodeType.ReleaseTempLocal && code[index + 9].Local == code[index].Local  				&& code[index + 10].pseudo == CodeType.ReleaseTempLocal && code[index + 10].Local == code[index + 1].Local  				&& ((code[index + 11].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 11].HasLabel) ||  					(code[index + 11].opcode == OpCodes.Ldc_I4_0  					&& (code[index + 12].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 12].HasLabel)));
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,MatchCompare,The following statement contains a magic number: return code[index].opcode == OpCodes.Stloc && code[index].Local.LocalType == type  				&& code[index + 1].opcode == OpCodes.Stloc && code[index + 1].Local.LocalType == type  				&& code[index + 2].opcode == OpCodes.Ldloc && code[index + 2].MatchLocal(code[index + 1])  				&& code[index + 3].opcode == OpCodes.Ldloc && code[index + 3].MatchLocal(code[index])  				&& code[index + 4].opcode == cmp1  				&& code[index + 5].opcode == OpCodes.Ldloc && code[index + 5].MatchLocal(code[index + 1])  				&& code[index + 6].opcode == OpCodes.Ldloc && code[index + 6].MatchLocal(code[index])  				&& code[index + 7].opcode == cmp2  				&& code[index + 8].opcode == OpCodes.Sub  				&& code[index + 9].pseudo == CodeType.ReleaseTempLocal && code[index + 9].Local == code[index].Local  				&& code[index + 10].pseudo == CodeType.ReleaseTempLocal && code[index + 10].Local == code[index + 1].Local  				&& ((code[index + 11].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 11].HasLabel) ||  					(code[index + 11].opcode == OpCodes.Ldc_I4_0  					&& (code[index + 12].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 12].HasLabel)));
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,MatchCompare,The following statement contains a magic number: return code[index].opcode == OpCodes.Stloc && code[index].Local.LocalType == type  				&& code[index + 1].opcode == OpCodes.Stloc && code[index + 1].Local.LocalType == type  				&& code[index + 2].opcode == OpCodes.Ldloc && code[index + 2].MatchLocal(code[index + 1])  				&& code[index + 3].opcode == OpCodes.Ldloc && code[index + 3].MatchLocal(code[index])  				&& code[index + 4].opcode == cmp1  				&& code[index + 5].opcode == OpCodes.Ldloc && code[index + 5].MatchLocal(code[index + 1])  				&& code[index + 6].opcode == OpCodes.Ldloc && code[index + 6].MatchLocal(code[index])  				&& code[index + 7].opcode == cmp2  				&& code[index + 8].opcode == OpCodes.Sub  				&& code[index + 9].pseudo == CodeType.ReleaseTempLocal && code[index + 9].Local == code[index].Local  				&& code[index + 10].pseudo == CodeType.ReleaseTempLocal && code[index + 10].Local == code[index + 1].Local  				&& ((code[index + 11].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 11].HasLabel) ||  					(code[index + 11].opcode == OpCodes.Ldc_I4_0  					&& (code[index + 12].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 12].HasLabel)));
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,MatchCompare,The following statement contains a magic number: return code[index].opcode == OpCodes.Stloc && code[index].Local.LocalType == type  				&& code[index + 1].opcode == OpCodes.Stloc && code[index + 1].Local.LocalType == type  				&& code[index + 2].opcode == OpCodes.Ldloc && code[index + 2].MatchLocal(code[index + 1])  				&& code[index + 3].opcode == OpCodes.Ldloc && code[index + 3].MatchLocal(code[index])  				&& code[index + 4].opcode == cmp1  				&& code[index + 5].opcode == OpCodes.Ldloc && code[index + 5].MatchLocal(code[index + 1])  				&& code[index + 6].opcode == OpCodes.Ldloc && code[index + 6].MatchLocal(code[index])  				&& code[index + 7].opcode == cmp2  				&& code[index + 8].opcode == OpCodes.Sub  				&& code[index + 9].pseudo == CodeType.ReleaseTempLocal && code[index + 9].Local == code[index].Local  				&& code[index + 10].pseudo == CodeType.ReleaseTempLocal && code[index + 10].Local == code[index + 1].Local  				&& ((code[index + 11].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 11].HasLabel) ||  					(code[index + 11].opcode == OpCodes.Ldc_I4_0  					&& (code[index + 12].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 12].HasLabel)));
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,MatchCompare,The following statement contains a magic number: return code[index].opcode == OpCodes.Stloc && code[index].Local.LocalType == type  				&& code[index + 1].opcode == OpCodes.Stloc && code[index + 1].Local.LocalType == type  				&& code[index + 2].opcode == OpCodes.Ldloc && code[index + 2].MatchLocal(code[index + 1])  				&& code[index + 3].opcode == OpCodes.Ldloc && code[index + 3].MatchLocal(code[index])  				&& code[index + 4].opcode == cmp1  				&& code[index + 5].opcode == OpCodes.Ldloc && code[index + 5].MatchLocal(code[index + 1])  				&& code[index + 6].opcode == OpCodes.Ldloc && code[index + 6].MatchLocal(code[index])  				&& code[index + 7].opcode == cmp2  				&& code[index + 8].opcode == OpCodes.Sub  				&& code[index + 9].pseudo == CodeType.ReleaseTempLocal && code[index + 9].Local == code[index].Local  				&& code[index + 10].pseudo == CodeType.ReleaseTempLocal && code[index + 10].Local == code[index + 1].Local  				&& ((code[index + 11].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 11].HasLabel) ||  					(code[index + 11].opcode == OpCodes.Ldc_I4_0  					&& (code[index + 12].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 12].HasLabel)));
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,MatchCompare,The following statement contains a magic number: return code[index].opcode == OpCodes.Stloc && code[index].Local.LocalType == type  				&& code[index + 1].opcode == OpCodes.Stloc && code[index + 1].Local.LocalType == type  				&& code[index + 2].opcode == OpCodes.Ldloc && code[index + 2].MatchLocal(code[index + 1])  				&& code[index + 3].opcode == OpCodes.Ldloc && code[index + 3].MatchLocal(code[index])  				&& code[index + 4].opcode == cmp1  				&& code[index + 5].opcode == OpCodes.Ldloc && code[index + 5].MatchLocal(code[index + 1])  				&& code[index + 6].opcode == OpCodes.Ldloc && code[index + 6].MatchLocal(code[index])  				&& code[index + 7].opcode == cmp2  				&& code[index + 8].opcode == OpCodes.Sub  				&& code[index + 9].pseudo == CodeType.ReleaseTempLocal && code[index + 9].Local == code[index].Local  				&& code[index + 10].pseudo == CodeType.ReleaseTempLocal && code[index + 10].Local == code[index + 1].Local  				&& ((code[index + 11].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 11].HasLabel) ||  					(code[index + 11].opcode == OpCodes.Ldc_I4_0  					&& (code[index + 12].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 12].HasLabel)));
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,MatchCompare,The following statement contains a magic number: return code[index].opcode == OpCodes.Stloc && code[index].Local.LocalType == type  				&& code[index + 1].opcode == OpCodes.Stloc && code[index + 1].Local.LocalType == type  				&& code[index + 2].opcode == OpCodes.Ldloc && code[index + 2].MatchLocal(code[index + 1])  				&& code[index + 3].opcode == OpCodes.Ldloc && code[index + 3].MatchLocal(code[index])  				&& code[index + 4].opcode == cmp1  				&& code[index + 5].opcode == OpCodes.Ldloc && code[index + 5].MatchLocal(code[index + 1])  				&& code[index + 6].opcode == OpCodes.Ldloc && code[index + 6].MatchLocal(code[index])  				&& code[index + 7].opcode == cmp2  				&& code[index + 8].opcode == OpCodes.Sub  				&& code[index + 9].pseudo == CodeType.ReleaseTempLocal && code[index + 9].Local == code[index].Local  				&& code[index + 10].pseudo == CodeType.ReleaseTempLocal && code[index + 10].Local == code[index + 1].Local  				&& ((code[index + 11].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 11].HasLabel) ||  					(code[index + 11].opcode == OpCodes.Ldc_I4_0  					&& (code[index + 12].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 12].HasLabel)));
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,MatchCompare,The following statement contains a magic number: return code[index].opcode == OpCodes.Stloc && code[index].Local.LocalType == type  				&& code[index + 1].opcode == OpCodes.Stloc && code[index + 1].Local.LocalType == type  				&& code[index + 2].opcode == OpCodes.Ldloc && code[index + 2].MatchLocal(code[index + 1])  				&& code[index + 3].opcode == OpCodes.Ldloc && code[index + 3].MatchLocal(code[index])  				&& code[index + 4].opcode == cmp1  				&& code[index + 5].opcode == OpCodes.Ldloc && code[index + 5].MatchLocal(code[index + 1])  				&& code[index + 6].opcode == OpCodes.Ldloc && code[index + 6].MatchLocal(code[index])  				&& code[index + 7].opcode == cmp2  				&& code[index + 8].opcode == OpCodes.Sub  				&& code[index + 9].pseudo == CodeType.ReleaseTempLocal && code[index + 9].Local == code[index].Local  				&& code[index + 10].pseudo == CodeType.ReleaseTempLocal && code[index + 10].Local == code[index + 1].Local  				&& ((code[index + 11].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 11].HasLabel) ||  					(code[index + 11].opcode == OpCodes.Ldc_I4_0  					&& (code[index + 12].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 12].HasLabel)));
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,MatchCompare,The following statement contains a magic number: return code[index].opcode == OpCodes.Stloc && code[index].Local.LocalType == type  				&& code[index + 1].opcode == OpCodes.Stloc && code[index + 1].Local.LocalType == type  				&& code[index + 2].opcode == OpCodes.Ldloc && code[index + 2].MatchLocal(code[index + 1])  				&& code[index + 3].opcode == OpCodes.Ldloc && code[index + 3].MatchLocal(code[index])  				&& code[index + 4].opcode == cmp1  				&& code[index + 5].opcode == OpCodes.Ldloc && code[index + 5].MatchLocal(code[index + 1])  				&& code[index + 6].opcode == OpCodes.Ldloc && code[index + 6].MatchLocal(code[index])  				&& code[index + 7].opcode == cmp2  				&& code[index + 8].opcode == OpCodes.Sub  				&& code[index + 9].pseudo == CodeType.ReleaseTempLocal && code[index + 9].Local == code[index].Local  				&& code[index + 10].pseudo == CodeType.ReleaseTempLocal && code[index + 10].Local == code[index + 1].Local  				&& ((code[index + 11].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 11].HasLabel) ||  					(code[index + 11].opcode == OpCodes.Ldc_I4_0  					&& (code[index + 12].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 12].HasLabel)));
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,MatchCompare,The following statement contains a magic number: return code[index].opcode == OpCodes.Stloc && code[index].Local.LocalType == type  				&& code[index + 1].opcode == OpCodes.Stloc && code[index + 1].Local.LocalType == type  				&& code[index + 2].opcode == OpCodes.Ldloc && code[index + 2].MatchLocal(code[index + 1])  				&& code[index + 3].opcode == OpCodes.Ldloc && code[index + 3].MatchLocal(code[index])  				&& code[index + 4].opcode == cmp1  				&& code[index + 5].opcode == OpCodes.Ldloc && code[index + 5].MatchLocal(code[index + 1])  				&& code[index + 6].opcode == OpCodes.Ldloc && code[index + 6].MatchLocal(code[index])  				&& code[index + 7].opcode == cmp2  				&& code[index + 8].opcode == OpCodes.Sub  				&& code[index + 9].pseudo == CodeType.ReleaseTempLocal && code[index + 9].Local == code[index].Local  				&& code[index + 10].pseudo == CodeType.ReleaseTempLocal && code[index + 10].Local == code[index + 1].Local  				&& ((code[index + 11].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 11].HasLabel) ||  					(code[index + 11].opcode == OpCodes.Ldc_I4_0  					&& (code[index + 12].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 12].HasLabel)));
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,MatchCompare,The following statement contains a magic number: return code[index].opcode == OpCodes.Stloc && code[index].Local.LocalType == type  				&& code[index + 1].opcode == OpCodes.Stloc && code[index + 1].Local.LocalType == type  				&& code[index + 2].opcode == OpCodes.Ldloc && code[index + 2].MatchLocal(code[index + 1])  				&& code[index + 3].opcode == OpCodes.Ldloc && code[index + 3].MatchLocal(code[index])  				&& code[index + 4].opcode == cmp1  				&& code[index + 5].opcode == OpCodes.Ldloc && code[index + 5].MatchLocal(code[index + 1])  				&& code[index + 6].opcode == OpCodes.Ldloc && code[index + 6].MatchLocal(code[index])  				&& code[index + 7].opcode == cmp2  				&& code[index + 8].opcode == OpCodes.Sub  				&& code[index + 9].pseudo == CodeType.ReleaseTempLocal && code[index + 9].Local == code[index].Local  				&& code[index + 10].pseudo == CodeType.ReleaseTempLocal && code[index + 10].Local == code[index + 1].Local  				&& ((code[index + 11].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 11].HasLabel) ||  					(code[index + 11].opcode == OpCodes.Ldc_I4_0  					&& (code[index + 12].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 12].HasLabel)));
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,MatchCompare,The following statement contains a magic number: return code[index].opcode == OpCodes.Stloc && code[index].Local.LocalType == type  				&& code[index + 1].opcode == OpCodes.Stloc && code[index + 1].Local.LocalType == type  				&& code[index + 2].opcode == OpCodes.Ldloc && code[index + 2].MatchLocal(code[index + 1])  				&& code[index + 3].opcode == OpCodes.Ldloc && code[index + 3].MatchLocal(code[index])  				&& code[index + 4].opcode == cmp1  				&& code[index + 5].opcode == OpCodes.Ldloc && code[index + 5].MatchLocal(code[index + 1])  				&& code[index + 6].opcode == OpCodes.Ldloc && code[index + 6].MatchLocal(code[index])  				&& code[index + 7].opcode == cmp2  				&& code[index + 8].opcode == OpCodes.Sub  				&& code[index + 9].pseudo == CodeType.ReleaseTempLocal && code[index + 9].Local == code[index].Local  				&& code[index + 10].pseudo == CodeType.ReleaseTempLocal && code[index + 10].Local == code[index + 1].Local  				&& ((code[index + 11].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 11].HasLabel) ||  					(code[index + 11].opcode == OpCodes.Ldc_I4_0  					&& (code[index + 12].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 12].HasLabel)));
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,MatchCompare,The following statement contains a magic number: return code[index].opcode == OpCodes.Stloc && code[index].Local.LocalType == type  				&& code[index + 1].opcode == OpCodes.Stloc && code[index + 1].Local.LocalType == type  				&& code[index + 2].opcode == OpCodes.Ldloc && code[index + 2].MatchLocal(code[index + 1])  				&& code[index + 3].opcode == OpCodes.Ldloc && code[index + 3].MatchLocal(code[index])  				&& code[index + 4].opcode == cmp1  				&& code[index + 5].opcode == OpCodes.Ldloc && code[index + 5].MatchLocal(code[index + 1])  				&& code[index + 6].opcode == OpCodes.Ldloc && code[index + 6].MatchLocal(code[index])  				&& code[index + 7].opcode == cmp2  				&& code[index + 8].opcode == OpCodes.Sub  				&& code[index + 9].pseudo == CodeType.ReleaseTempLocal && code[index + 9].Local == code[index].Local  				&& code[index + 10].pseudo == CodeType.ReleaseTempLocal && code[index + 10].Local == code[index + 1].Local  				&& ((code[index + 11].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 11].HasLabel) ||  					(code[index + 11].opcode == OpCodes.Ldc_I4_0  					&& (code[index + 12].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 12].HasLabel)));
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,MatchCompare,The following statement contains a magic number: return code[index].opcode == OpCodes.Stloc && code[index].Local.LocalType == type  				&& code[index + 1].opcode == OpCodes.Stloc && code[index + 1].Local.LocalType == type  				&& code[index + 2].opcode == OpCodes.Ldloc && code[index + 2].MatchLocal(code[index + 1])  				&& code[index + 3].opcode == OpCodes.Ldloc && code[index + 3].MatchLocal(code[index])  				&& code[index + 4].opcode == cmp1  				&& code[index + 5].opcode == OpCodes.Ldloc && code[index + 5].MatchLocal(code[index + 1])  				&& code[index + 6].opcode == OpCodes.Ldloc && code[index + 6].MatchLocal(code[index])  				&& code[index + 7].opcode == cmp2  				&& code[index + 8].opcode == OpCodes.Sub  				&& code[index + 9].pseudo == CodeType.ReleaseTempLocal && code[index + 9].Local == code[index].Local  				&& code[index + 10].pseudo == CodeType.ReleaseTempLocal && code[index + 10].Local == code[index + 1].Local  				&& ((code[index + 11].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 11].HasLabel) ||  					(code[index + 11].opcode == OpCodes.Ldc_I4_0  					&& (code[index + 12].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 12].HasLabel)));
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,MatchCompare,The following statement contains a magic number: return code[index].opcode == OpCodes.Stloc && code[index].Local.LocalType == type  				&& code[index + 1].opcode == OpCodes.Stloc && code[index + 1].Local.LocalType == type  				&& code[index + 2].opcode == OpCodes.Ldloc && code[index + 2].MatchLocal(code[index + 1])  				&& code[index + 3].opcode == OpCodes.Ldloc && code[index + 3].MatchLocal(code[index])  				&& code[index + 4].opcode == cmp1  				&& code[index + 5].opcode == OpCodes.Ldloc && code[index + 5].MatchLocal(code[index + 1])  				&& code[index + 6].opcode == OpCodes.Ldloc && code[index + 6].MatchLocal(code[index])  				&& code[index + 7].opcode == cmp2  				&& code[index + 8].opcode == OpCodes.Sub  				&& code[index + 9].pseudo == CodeType.ReleaseTempLocal && code[index + 9].Local == code[index].Local  				&& code[index + 10].pseudo == CodeType.ReleaseTempLocal && code[index + 10].Local == code[index + 1].Local  				&& ((code[index + 11].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 11].HasLabel) ||  					(code[index + 11].opcode == OpCodes.Ldc_I4_0  					&& (code[index + 12].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 12].HasLabel)));
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,MatchCompare,The following statement contains a magic number: return code[index].opcode == OpCodes.Stloc && code[index].Local.LocalType == type  				&& code[index + 1].opcode == OpCodes.Stloc && code[index + 1].Local.LocalType == type  				&& code[index + 2].opcode == OpCodes.Ldloc && code[index + 2].MatchLocal(code[index + 1])  				&& code[index + 3].opcode == OpCodes.Ldloc && code[index + 3].MatchLocal(code[index])  				&& code[index + 4].opcode == cmp1  				&& code[index + 5].opcode == OpCodes.Ldloc && code[index + 5].MatchLocal(code[index + 1])  				&& code[index + 6].opcode == OpCodes.Ldloc && code[index + 6].MatchLocal(code[index])  				&& code[index + 7].opcode == cmp2  				&& code[index + 8].opcode == OpCodes.Sub  				&& code[index + 9].pseudo == CodeType.ReleaseTempLocal && code[index + 9].Local == code[index].Local  				&& code[index + 10].pseudo == CodeType.ReleaseTempLocal && code[index + 10].Local == code[index + 1].Local  				&& ((code[index + 11].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 11].HasLabel) ||  					(code[index + 11].opcode == OpCodes.Ldc_I4_0  					&& (code[index + 12].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 12].HasLabel)));
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,MatchCompare,The following statement contains a magic number: return code[index].opcode == OpCodes.Stloc && code[index].Local.LocalType == type  				&& code[index + 1].opcode == OpCodes.Stloc && code[index + 1].Local.LocalType == type  				&& code[index + 2].opcode == OpCodes.Ldloc && code[index + 2].MatchLocal(code[index + 1])  				&& code[index + 3].opcode == OpCodes.Ldloc && code[index + 3].MatchLocal(code[index])  				&& code[index + 4].opcode == cmp1  				&& code[index + 5].opcode == OpCodes.Ldloc && code[index + 5].MatchLocal(code[index + 1])  				&& code[index + 6].opcode == OpCodes.Ldloc && code[index + 6].MatchLocal(code[index])  				&& code[index + 7].opcode == cmp2  				&& code[index + 8].opcode == OpCodes.Sub  				&& code[index + 9].pseudo == CodeType.ReleaseTempLocal && code[index + 9].Local == code[index].Local  				&& code[index + 10].pseudo == CodeType.ReleaseTempLocal && code[index + 10].Local == code[index + 1].Local  				&& ((code[index + 11].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 11].HasLabel) ||  					(code[index + 11].opcode == OpCodes.Ldc_I4_0  					&& (code[index + 12].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 12].HasLabel)));
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,MatchCompare,The following statement contains a magic number: return code[index].opcode == OpCodes.Stloc && code[index].Local.LocalType == type  				&& code[index + 1].opcode == OpCodes.Stloc && code[index + 1].Local.LocalType == type  				&& code[index + 2].opcode == OpCodes.Ldloc && code[index + 2].MatchLocal(code[index + 1])  				&& code[index + 3].opcode == OpCodes.Ldloc && code[index + 3].MatchLocal(code[index])  				&& code[index + 4].opcode == cmp1  				&& code[index + 5].opcode == OpCodes.Ldloc && code[index + 5].MatchLocal(code[index + 1])  				&& code[index + 6].opcode == OpCodes.Ldloc && code[index + 6].MatchLocal(code[index])  				&& code[index + 7].opcode == cmp2  				&& code[index + 8].opcode == OpCodes.Sub  				&& code[index + 9].pseudo == CodeType.ReleaseTempLocal && code[index + 9].Local == code[index].Local  				&& code[index + 10].pseudo == CodeType.ReleaseTempLocal && code[index + 10].Local == code[index + 1].Local  				&& ((code[index + 11].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 11].HasLabel) ||  					(code[index + 11].opcode == OpCodes.Ldc_I4_0  					&& (code[index + 12].opcode.FlowControl == FlowControl.Cond_Branch && code[index + 12].HasLabel)));
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,PatchCompare,The following statement contains a magic number: code[index] = new OpCodeWrapper(OpCodes.Bne_Un' code[index + 11].Label);
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,PatchCompare,The following statement contains a magic number: code.RemoveRange(index + 1' 11);
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,PatchCompare,The following statement contains a magic number: code[index + 11].opcode == OpCodes.Brtrue
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizeLdcI4,The following statement contains a magic number: switch (value)  			{  				case -1:  					return new OpCodeWrapper(OpCodes.Ldc_I4_M1' null);  				case 0:  					return new OpCodeWrapper(OpCodes.Ldc_I4_0' null);  				case 1:  					return new OpCodeWrapper(OpCodes.Ldc_I4_1' null);  				case 2:  					return new OpCodeWrapper(OpCodes.Ldc_I4_2' null);  				case 3:  					return new OpCodeWrapper(OpCodes.Ldc_I4_3' null);  				case 4:  					return new OpCodeWrapper(OpCodes.Ldc_I4_4' null);  				case 5:  					return new OpCodeWrapper(OpCodes.Ldc_I4_5' null);  				case 6:  					return new OpCodeWrapper(OpCodes.Ldc_I4_6' null);  				case 7:  					return new OpCodeWrapper(OpCodes.Ldc_I4_7' null);  				case 8:  					return new OpCodeWrapper(OpCodes.Ldc_I4_8' null);  				default:  					if (value >= -128 && value <= 127)  					{  						return new OpCodeWrapper(OpCodes.Ldc_I4_S' (sbyte)value);  					}  					else  					{  						return new OpCodeWrapper(OpCodes.Ldc_I4' value);  					}  			}
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizeLdcI4,The following statement contains a magic number: switch (value)  			{  				case -1:  					return new OpCodeWrapper(OpCodes.Ldc_I4_M1' null);  				case 0:  					return new OpCodeWrapper(OpCodes.Ldc_I4_0' null);  				case 1:  					return new OpCodeWrapper(OpCodes.Ldc_I4_1' null);  				case 2:  					return new OpCodeWrapper(OpCodes.Ldc_I4_2' null);  				case 3:  					return new OpCodeWrapper(OpCodes.Ldc_I4_3' null);  				case 4:  					return new OpCodeWrapper(OpCodes.Ldc_I4_4' null);  				case 5:  					return new OpCodeWrapper(OpCodes.Ldc_I4_5' null);  				case 6:  					return new OpCodeWrapper(OpCodes.Ldc_I4_6' null);  				case 7:  					return new OpCodeWrapper(OpCodes.Ldc_I4_7' null);  				case 8:  					return new OpCodeWrapper(OpCodes.Ldc_I4_8' null);  				default:  					if (value >= -128 && value <= 127)  					{  						return new OpCodeWrapper(OpCodes.Ldc_I4_S' (sbyte)value);  					}  					else  					{  						return new OpCodeWrapper(OpCodes.Ldc_I4' value);  					}  			}
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizeLdcI4,The following statement contains a magic number: switch (value)  			{  				case -1:  					return new OpCodeWrapper(OpCodes.Ldc_I4_M1' null);  				case 0:  					return new OpCodeWrapper(OpCodes.Ldc_I4_0' null);  				case 1:  					return new OpCodeWrapper(OpCodes.Ldc_I4_1' null);  				case 2:  					return new OpCodeWrapper(OpCodes.Ldc_I4_2' null);  				case 3:  					return new OpCodeWrapper(OpCodes.Ldc_I4_3' null);  				case 4:  					return new OpCodeWrapper(OpCodes.Ldc_I4_4' null);  				case 5:  					return new OpCodeWrapper(OpCodes.Ldc_I4_5' null);  				case 6:  					return new OpCodeWrapper(OpCodes.Ldc_I4_6' null);  				case 7:  					return new OpCodeWrapper(OpCodes.Ldc_I4_7' null);  				case 8:  					return new OpCodeWrapper(OpCodes.Ldc_I4_8' null);  				default:  					if (value >= -128 && value <= 127)  					{  						return new OpCodeWrapper(OpCodes.Ldc_I4_S' (sbyte)value);  					}  					else  					{  						return new OpCodeWrapper(OpCodes.Ldc_I4' value);  					}  			}
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizeLdcI4,The following statement contains a magic number: switch (value)  			{  				case -1:  					return new OpCodeWrapper(OpCodes.Ldc_I4_M1' null);  				case 0:  					return new OpCodeWrapper(OpCodes.Ldc_I4_0' null);  				case 1:  					return new OpCodeWrapper(OpCodes.Ldc_I4_1' null);  				case 2:  					return new OpCodeWrapper(OpCodes.Ldc_I4_2' null);  				case 3:  					return new OpCodeWrapper(OpCodes.Ldc_I4_3' null);  				case 4:  					return new OpCodeWrapper(OpCodes.Ldc_I4_4' null);  				case 5:  					return new OpCodeWrapper(OpCodes.Ldc_I4_5' null);  				case 6:  					return new OpCodeWrapper(OpCodes.Ldc_I4_6' null);  				case 7:  					return new OpCodeWrapper(OpCodes.Ldc_I4_7' null);  				case 8:  					return new OpCodeWrapper(OpCodes.Ldc_I4_8' null);  				default:  					if (value >= -128 && value <= 127)  					{  						return new OpCodeWrapper(OpCodes.Ldc_I4_S' (sbyte)value);  					}  					else  					{  						return new OpCodeWrapper(OpCodes.Ldc_I4' value);  					}  			}
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizeLdcI4,The following statement contains a magic number: switch (value)  			{  				case -1:  					return new OpCodeWrapper(OpCodes.Ldc_I4_M1' null);  				case 0:  					return new OpCodeWrapper(OpCodes.Ldc_I4_0' null);  				case 1:  					return new OpCodeWrapper(OpCodes.Ldc_I4_1' null);  				case 2:  					return new OpCodeWrapper(OpCodes.Ldc_I4_2' null);  				case 3:  					return new OpCodeWrapper(OpCodes.Ldc_I4_3' null);  				case 4:  					return new OpCodeWrapper(OpCodes.Ldc_I4_4' null);  				case 5:  					return new OpCodeWrapper(OpCodes.Ldc_I4_5' null);  				case 6:  					return new OpCodeWrapper(OpCodes.Ldc_I4_6' null);  				case 7:  					return new OpCodeWrapper(OpCodes.Ldc_I4_7' null);  				case 8:  					return new OpCodeWrapper(OpCodes.Ldc_I4_8' null);  				default:  					if (value >= -128 && value <= 127)  					{  						return new OpCodeWrapper(OpCodes.Ldc_I4_S' (sbyte)value);  					}  					else  					{  						return new OpCodeWrapper(OpCodes.Ldc_I4' value);  					}  			}
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizeLdcI4,The following statement contains a magic number: switch (value)  			{  				case -1:  					return new OpCodeWrapper(OpCodes.Ldc_I4_M1' null);  				case 0:  					return new OpCodeWrapper(OpCodes.Ldc_I4_0' null);  				case 1:  					return new OpCodeWrapper(OpCodes.Ldc_I4_1' null);  				case 2:  					return new OpCodeWrapper(OpCodes.Ldc_I4_2' null);  				case 3:  					return new OpCodeWrapper(OpCodes.Ldc_I4_3' null);  				case 4:  					return new OpCodeWrapper(OpCodes.Ldc_I4_4' null);  				case 5:  					return new OpCodeWrapper(OpCodes.Ldc_I4_5' null);  				case 6:  					return new OpCodeWrapper(OpCodes.Ldc_I4_6' null);  				case 7:  					return new OpCodeWrapper(OpCodes.Ldc_I4_7' null);  				case 8:  					return new OpCodeWrapper(OpCodes.Ldc_I4_8' null);  				default:  					if (value >= -128 && value <= 127)  					{  						return new OpCodeWrapper(OpCodes.Ldc_I4_S' (sbyte)value);  					}  					else  					{  						return new OpCodeWrapper(OpCodes.Ldc_I4' value);  					}  			}
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizeLdcI4,The following statement contains a magic number: switch (value)  			{  				case -1:  					return new OpCodeWrapper(OpCodes.Ldc_I4_M1' null);  				case 0:  					return new OpCodeWrapper(OpCodes.Ldc_I4_0' null);  				case 1:  					return new OpCodeWrapper(OpCodes.Ldc_I4_1' null);  				case 2:  					return new OpCodeWrapper(OpCodes.Ldc_I4_2' null);  				case 3:  					return new OpCodeWrapper(OpCodes.Ldc_I4_3' null);  				case 4:  					return new OpCodeWrapper(OpCodes.Ldc_I4_4' null);  				case 5:  					return new OpCodeWrapper(OpCodes.Ldc_I4_5' null);  				case 6:  					return new OpCodeWrapper(OpCodes.Ldc_I4_6' null);  				case 7:  					return new OpCodeWrapper(OpCodes.Ldc_I4_7' null);  				case 8:  					return new OpCodeWrapper(OpCodes.Ldc_I4_8' null);  				default:  					if (value >= -128 && value <= 127)  					{  						return new OpCodeWrapper(OpCodes.Ldc_I4_S' (sbyte)value);  					}  					else  					{  						return new OpCodeWrapper(OpCodes.Ldc_I4' value);  					}  			}
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizeLdcI4,The following statement contains a magic number: switch (value)  			{  				case -1:  					return new OpCodeWrapper(OpCodes.Ldc_I4_M1' null);  				case 0:  					return new OpCodeWrapper(OpCodes.Ldc_I4_0' null);  				case 1:  					return new OpCodeWrapper(OpCodes.Ldc_I4_1' null);  				case 2:  					return new OpCodeWrapper(OpCodes.Ldc_I4_2' null);  				case 3:  					return new OpCodeWrapper(OpCodes.Ldc_I4_3' null);  				case 4:  					return new OpCodeWrapper(OpCodes.Ldc_I4_4' null);  				case 5:  					return new OpCodeWrapper(OpCodes.Ldc_I4_5' null);  				case 6:  					return new OpCodeWrapper(OpCodes.Ldc_I4_6' null);  				case 7:  					return new OpCodeWrapper(OpCodes.Ldc_I4_7' null);  				case 8:  					return new OpCodeWrapper(OpCodes.Ldc_I4_8' null);  				default:  					if (value >= -128 && value <= 127)  					{  						return new OpCodeWrapper(OpCodes.Ldc_I4_S' (sbyte)value);  					}  					else  					{  						return new OpCodeWrapper(OpCodes.Ldc_I4' value);  					}  			}
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizeLdcI4,The following statement contains a magic number: switch (value)  			{  				case -1:  					return new OpCodeWrapper(OpCodes.Ldc_I4_M1' null);  				case 0:  					return new OpCodeWrapper(OpCodes.Ldc_I4_0' null);  				case 1:  					return new OpCodeWrapper(OpCodes.Ldc_I4_1' null);  				case 2:  					return new OpCodeWrapper(OpCodes.Ldc_I4_2' null);  				case 3:  					return new OpCodeWrapper(OpCodes.Ldc_I4_3' null);  				case 4:  					return new OpCodeWrapper(OpCodes.Ldc_I4_4' null);  				case 5:  					return new OpCodeWrapper(OpCodes.Ldc_I4_5' null);  				case 6:  					return new OpCodeWrapper(OpCodes.Ldc_I4_6' null);  				case 7:  					return new OpCodeWrapper(OpCodes.Ldc_I4_7' null);  				case 8:  					return new OpCodeWrapper(OpCodes.Ldc_I4_8' null);  				default:  					if (value >= -128 && value <= 127)  					{  						return new OpCodeWrapper(OpCodes.Ldc_I4_S' (sbyte)value);  					}  					else  					{  						return new OpCodeWrapper(OpCodes.Ldc_I4' value);  					}  			}
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizeLdcI8,The following statement contains a magic number: switch (value)  			{  				case -1:  					opc = OpCodes.Ldc_I4_M1;  					break;  				case 0:  					opc = OpCodes.Ldc_I4_0;  					break;  				case 1:  					opc = OpCodes.Ldc_I4_1;  					break;  				case 2:  					opc = OpCodes.Ldc_I4_2;  					break;  				case 3:  					opc = OpCodes.Ldc_I4_3;  					break;  				case 4:  					opc = OpCodes.Ldc_I4_4;  					break;  				case 5:  					opc = OpCodes.Ldc_I4_5;  					break;  				case 6:  					opc = OpCodes.Ldc_I4_6;  					break;  				case 7:  					opc = OpCodes.Ldc_I4_7;  					break;  				case 8:  					opc = OpCodes.Ldc_I4_8;  					break;  				default:  					if (value >= -2147483648L && value <= 4294967295L)  					{  						if (value >= -128 && value <= 127)  						{  							code[index] = new OpCodeWrapper(OpCodes.Ldc_I4_S' (sbyte)value);  						}  						else  						{  							code[index] = new OpCodeWrapper(OpCodes.Ldc_I4' (int)value);  						}  						if (value < 0)  						{  							code.Insert(index + 1' new OpCodeWrapper(OpCodes.Conv_I8' null));  						}  						else  						{  							code.Insert(index + 1' new OpCodeWrapper(OpCodes.Conv_U8' null));  						}  					}  					break;  			}
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizeLdcI8,The following statement contains a magic number: switch (value)  			{  				case -1:  					opc = OpCodes.Ldc_I4_M1;  					break;  				case 0:  					opc = OpCodes.Ldc_I4_0;  					break;  				case 1:  					opc = OpCodes.Ldc_I4_1;  					break;  				case 2:  					opc = OpCodes.Ldc_I4_2;  					break;  				case 3:  					opc = OpCodes.Ldc_I4_3;  					break;  				case 4:  					opc = OpCodes.Ldc_I4_4;  					break;  				case 5:  					opc = OpCodes.Ldc_I4_5;  					break;  				case 6:  					opc = OpCodes.Ldc_I4_6;  					break;  				case 7:  					opc = OpCodes.Ldc_I4_7;  					break;  				case 8:  					opc = OpCodes.Ldc_I4_8;  					break;  				default:  					if (value >= -2147483648L && value <= 4294967295L)  					{  						if (value >= -128 && value <= 127)  						{  							code[index] = new OpCodeWrapper(OpCodes.Ldc_I4_S' (sbyte)value);  						}  						else  						{  							code[index] = new OpCodeWrapper(OpCodes.Ldc_I4' (int)value);  						}  						if (value < 0)  						{  							code.Insert(index + 1' new OpCodeWrapper(OpCodes.Conv_I8' null));  						}  						else  						{  							code.Insert(index + 1' new OpCodeWrapper(OpCodes.Conv_U8' null));  						}  					}  					break;  			}
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizeLdcI8,The following statement contains a magic number: switch (value)  			{  				case -1:  					opc = OpCodes.Ldc_I4_M1;  					break;  				case 0:  					opc = OpCodes.Ldc_I4_0;  					break;  				case 1:  					opc = OpCodes.Ldc_I4_1;  					break;  				case 2:  					opc = OpCodes.Ldc_I4_2;  					break;  				case 3:  					opc = OpCodes.Ldc_I4_3;  					break;  				case 4:  					opc = OpCodes.Ldc_I4_4;  					break;  				case 5:  					opc = OpCodes.Ldc_I4_5;  					break;  				case 6:  					opc = OpCodes.Ldc_I4_6;  					break;  				case 7:  					opc = OpCodes.Ldc_I4_7;  					break;  				case 8:  					opc = OpCodes.Ldc_I4_8;  					break;  				default:  					if (value >= -2147483648L && value <= 4294967295L)  					{  						if (value >= -128 && value <= 127)  						{  							code[index] = new OpCodeWrapper(OpCodes.Ldc_I4_S' (sbyte)value);  						}  						else  						{  							code[index] = new OpCodeWrapper(OpCodes.Ldc_I4' (int)value);  						}  						if (value < 0)  						{  							code.Insert(index + 1' new OpCodeWrapper(OpCodes.Conv_I8' null));  						}  						else  						{  							code.Insert(index + 1' new OpCodeWrapper(OpCodes.Conv_U8' null));  						}  					}  					break;  			}
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizeLdcI8,The following statement contains a magic number: switch (value)  			{  				case -1:  					opc = OpCodes.Ldc_I4_M1;  					break;  				case 0:  					opc = OpCodes.Ldc_I4_0;  					break;  				case 1:  					opc = OpCodes.Ldc_I4_1;  					break;  				case 2:  					opc = OpCodes.Ldc_I4_2;  					break;  				case 3:  					opc = OpCodes.Ldc_I4_3;  					break;  				case 4:  					opc = OpCodes.Ldc_I4_4;  					break;  				case 5:  					opc = OpCodes.Ldc_I4_5;  					break;  				case 6:  					opc = OpCodes.Ldc_I4_6;  					break;  				case 7:  					opc = OpCodes.Ldc_I4_7;  					break;  				case 8:  					opc = OpCodes.Ldc_I4_8;  					break;  				default:  					if (value >= -2147483648L && value <= 4294967295L)  					{  						if (value >= -128 && value <= 127)  						{  							code[index] = new OpCodeWrapper(OpCodes.Ldc_I4_S' (sbyte)value);  						}  						else  						{  							code[index] = new OpCodeWrapper(OpCodes.Ldc_I4' (int)value);  						}  						if (value < 0)  						{  							code.Insert(index + 1' new OpCodeWrapper(OpCodes.Conv_I8' null));  						}  						else  						{  							code.Insert(index + 1' new OpCodeWrapper(OpCodes.Conv_U8' null));  						}  					}  					break;  			}
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizeLdcI8,The following statement contains a magic number: switch (value)  			{  				case -1:  					opc = OpCodes.Ldc_I4_M1;  					break;  				case 0:  					opc = OpCodes.Ldc_I4_0;  					break;  				case 1:  					opc = OpCodes.Ldc_I4_1;  					break;  				case 2:  					opc = OpCodes.Ldc_I4_2;  					break;  				case 3:  					opc = OpCodes.Ldc_I4_3;  					break;  				case 4:  					opc = OpCodes.Ldc_I4_4;  					break;  				case 5:  					opc = OpCodes.Ldc_I4_5;  					break;  				case 6:  					opc = OpCodes.Ldc_I4_6;  					break;  				case 7:  					opc = OpCodes.Ldc_I4_7;  					break;  				case 8:  					opc = OpCodes.Ldc_I4_8;  					break;  				default:  					if (value >= -2147483648L && value <= 4294967295L)  					{  						if (value >= -128 && value <= 127)  						{  							code[index] = new OpCodeWrapper(OpCodes.Ldc_I4_S' (sbyte)value);  						}  						else  						{  							code[index] = new OpCodeWrapper(OpCodes.Ldc_I4' (int)value);  						}  						if (value < 0)  						{  							code.Insert(index + 1' new OpCodeWrapper(OpCodes.Conv_I8' null));  						}  						else  						{  							code.Insert(index + 1' new OpCodeWrapper(OpCodes.Conv_U8' null));  						}  					}  					break;  			}
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizeLdcI8,The following statement contains a magic number: switch (value)  			{  				case -1:  					opc = OpCodes.Ldc_I4_M1;  					break;  				case 0:  					opc = OpCodes.Ldc_I4_0;  					break;  				case 1:  					opc = OpCodes.Ldc_I4_1;  					break;  				case 2:  					opc = OpCodes.Ldc_I4_2;  					break;  				case 3:  					opc = OpCodes.Ldc_I4_3;  					break;  				case 4:  					opc = OpCodes.Ldc_I4_4;  					break;  				case 5:  					opc = OpCodes.Ldc_I4_5;  					break;  				case 6:  					opc = OpCodes.Ldc_I4_6;  					break;  				case 7:  					opc = OpCodes.Ldc_I4_7;  					break;  				case 8:  					opc = OpCodes.Ldc_I4_8;  					break;  				default:  					if (value >= -2147483648L && value <= 4294967295L)  					{  						if (value >= -128 && value <= 127)  						{  							code[index] = new OpCodeWrapper(OpCodes.Ldc_I4_S' (sbyte)value);  						}  						else  						{  							code[index] = new OpCodeWrapper(OpCodes.Ldc_I4' (int)value);  						}  						if (value < 0)  						{  							code.Insert(index + 1' new OpCodeWrapper(OpCodes.Conv_I8' null));  						}  						else  						{  							code.Insert(index + 1' new OpCodeWrapper(OpCodes.Conv_U8' null));  						}  					}  					break;  			}
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizeLdcI8,The following statement contains a magic number: switch (value)  			{  				case -1:  					opc = OpCodes.Ldc_I4_M1;  					break;  				case 0:  					opc = OpCodes.Ldc_I4_0;  					break;  				case 1:  					opc = OpCodes.Ldc_I4_1;  					break;  				case 2:  					opc = OpCodes.Ldc_I4_2;  					break;  				case 3:  					opc = OpCodes.Ldc_I4_3;  					break;  				case 4:  					opc = OpCodes.Ldc_I4_4;  					break;  				case 5:  					opc = OpCodes.Ldc_I4_5;  					break;  				case 6:  					opc = OpCodes.Ldc_I4_6;  					break;  				case 7:  					opc = OpCodes.Ldc_I4_7;  					break;  				case 8:  					opc = OpCodes.Ldc_I4_8;  					break;  				default:  					if (value >= -2147483648L && value <= 4294967295L)  					{  						if (value >= -128 && value <= 127)  						{  							code[index] = new OpCodeWrapper(OpCodes.Ldc_I4_S' (sbyte)value);  						}  						else  						{  							code[index] = new OpCodeWrapper(OpCodes.Ldc_I4' (int)value);  						}  						if (value < 0)  						{  							code.Insert(index + 1' new OpCodeWrapper(OpCodes.Conv_I8' null));  						}  						else  						{  							code.Insert(index + 1' new OpCodeWrapper(OpCodes.Conv_U8' null));  						}  					}  					break;  			}
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizeLdcI8,The following statement contains a magic number: switch (value)  			{  				case -1:  					opc = OpCodes.Ldc_I4_M1;  					break;  				case 0:  					opc = OpCodes.Ldc_I4_0;  					break;  				case 1:  					opc = OpCodes.Ldc_I4_1;  					break;  				case 2:  					opc = OpCodes.Ldc_I4_2;  					break;  				case 3:  					opc = OpCodes.Ldc_I4_3;  					break;  				case 4:  					opc = OpCodes.Ldc_I4_4;  					break;  				case 5:  					opc = OpCodes.Ldc_I4_5;  					break;  				case 6:  					opc = OpCodes.Ldc_I4_6;  					break;  				case 7:  					opc = OpCodes.Ldc_I4_7;  					break;  				case 8:  					opc = OpCodes.Ldc_I4_8;  					break;  				default:  					if (value >= -2147483648L && value <= 4294967295L)  					{  						if (value >= -128 && value <= 127)  						{  							code[index] = new OpCodeWrapper(OpCodes.Ldc_I4_S' (sbyte)value);  						}  						else  						{  							code[index] = new OpCodeWrapper(OpCodes.Ldc_I4' (int)value);  						}  						if (value < 0)  						{  							code.Insert(index + 1' new OpCodeWrapper(OpCodes.Conv_I8' null));  						}  						else  						{  							code.Insert(index + 1' new OpCodeWrapper(OpCodes.Conv_U8' null));  						}  					}  					break;  			}
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizeLdcI8,The following statement contains a magic number: switch (value)  			{  				case -1:  					opc = OpCodes.Ldc_I4_M1;  					break;  				case 0:  					opc = OpCodes.Ldc_I4_0;  					break;  				case 1:  					opc = OpCodes.Ldc_I4_1;  					break;  				case 2:  					opc = OpCodes.Ldc_I4_2;  					break;  				case 3:  					opc = OpCodes.Ldc_I4_3;  					break;  				case 4:  					opc = OpCodes.Ldc_I4_4;  					break;  				case 5:  					opc = OpCodes.Ldc_I4_5;  					break;  				case 6:  					opc = OpCodes.Ldc_I4_6;  					break;  				case 7:  					opc = OpCodes.Ldc_I4_7;  					break;  				case 8:  					opc = OpCodes.Ldc_I4_8;  					break;  				default:  					if (value >= -2147483648L && value <= 4294967295L)  					{  						if (value >= -128 && value <= 127)  						{  							code[index] = new OpCodeWrapper(OpCodes.Ldc_I4_S' (sbyte)value);  						}  						else  						{  							code[index] = new OpCodeWrapper(OpCodes.Ldc_I4' (int)value);  						}  						if (value < 0)  						{  							code.Insert(index + 1' new OpCodeWrapper(OpCodes.Conv_I8' null));  						}  						else  						{  							code.Insert(index + 1' new OpCodeWrapper(OpCodes.Conv_U8' null));  						}  					}  					break;  			}
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizeLdcI8,The following statement contains a magic number: switch (value)  			{  				case -1:  					opc = OpCodes.Ldc_I4_M1;  					break;  				case 0:  					opc = OpCodes.Ldc_I4_0;  					break;  				case 1:  					opc = OpCodes.Ldc_I4_1;  					break;  				case 2:  					opc = OpCodes.Ldc_I4_2;  					break;  				case 3:  					opc = OpCodes.Ldc_I4_3;  					break;  				case 4:  					opc = OpCodes.Ldc_I4_4;  					break;  				case 5:  					opc = OpCodes.Ldc_I4_5;  					break;  				case 6:  					opc = OpCodes.Ldc_I4_6;  					break;  				case 7:  					opc = OpCodes.Ldc_I4_7;  					break;  				case 8:  					opc = OpCodes.Ldc_I4_8;  					break;  				default:  					if (value >= -2147483648L && value <= 4294967295L)  					{  						if (value >= -128 && value <= 127)  						{  							code[index] = new OpCodeWrapper(OpCodes.Ldc_I4_S' (sbyte)value);  						}  						else  						{  							code[index] = new OpCodeWrapper(OpCodes.Ldc_I4' (int)value);  						}  						if (value < 0)  						{  							code.Insert(index + 1' new OpCodeWrapper(OpCodes.Conv_I8' null));  						}  						else  						{  							code.Insert(index + 1' new OpCodeWrapper(OpCodes.Conv_U8' null));  						}  					}  					break;  			}
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizeLdcI8,The following statement contains a magic number: switch (value)  			{  				case -1:  					opc = OpCodes.Ldc_I4_M1;  					break;  				case 0:  					opc = OpCodes.Ldc_I4_0;  					break;  				case 1:  					opc = OpCodes.Ldc_I4_1;  					break;  				case 2:  					opc = OpCodes.Ldc_I4_2;  					break;  				case 3:  					opc = OpCodes.Ldc_I4_3;  					break;  				case 4:  					opc = OpCodes.Ldc_I4_4;  					break;  				case 5:  					opc = OpCodes.Ldc_I4_5;  					break;  				case 6:  					opc = OpCodes.Ldc_I4_6;  					break;  				case 7:  					opc = OpCodes.Ldc_I4_7;  					break;  				case 8:  					opc = OpCodes.Ldc_I4_8;  					break;  				default:  					if (value >= -2147483648L && value <= 4294967295L)  					{  						if (value >= -128 && value <= 127)  						{  							code[index] = new OpCodeWrapper(OpCodes.Ldc_I4_S' (sbyte)value);  						}  						else  						{  							code[index] = new OpCodeWrapper(OpCodes.Ldc_I4' (int)value);  						}  						if (value < 0)  						{  							code.Insert(index + 1' new OpCodeWrapper(OpCodes.Conv_I8' null));  						}  						else  						{  							code.Insert(index + 1' new OpCodeWrapper(OpCodes.Conv_U8' null));  						}  					}  					break;  			}
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,RemoveDeadCode,The following statement contains a magic number: const int ProcessedFlag = 2;
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizeStackTransfer,The following statement contains a magic number: code[i] = code[i + 2];
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizeStackTransfer,The following statement contains a magic number: code.RemoveRange(i + 2' 3);
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizeStackTransfer,The following statement contains a magic number: code.RemoveRange(i + 2' 3);
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizeStackTransfer,The following statement contains a magic number: code[i].opcode == OpCodes.Ldloc  					&& code[i + 1].opcode == OpCodes.Stloc  					&& code[i + 2].pseudo == CodeType.BeginExceptionBlock  					&& code[i + 3].opcode == OpCodes.Ldloc && code[i + 3].MatchLocal(code[i + 1])  					&& code[i + 4].pseudo == CodeType.ReleaseTempLocal && code[i + 4].MatchLocal(code[i + 3])
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizeStackTransfer,The following statement contains a magic number: code[i].opcode == OpCodes.Ldloc  					&& code[i + 1].opcode == OpCodes.Stloc  					&& code[i + 2].pseudo == CodeType.BeginExceptionBlock  					&& code[i + 3].opcode == OpCodes.Ldloc && code[i + 3].MatchLocal(code[i + 1])  					&& code[i + 4].pseudo == CodeType.ReleaseTempLocal && code[i + 4].MatchLocal(code[i + 3])
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizeStackTransfer,The following statement contains a magic number: code[i].opcode == OpCodes.Ldloc  					&& code[i + 1].opcode == OpCodes.Stloc  					&& code[i + 2].pseudo == CodeType.BeginExceptionBlock  					&& code[i + 3].opcode == OpCodes.Ldloc && code[i + 3].MatchLocal(code[i + 1])  					&& code[i + 4].pseudo == CodeType.ReleaseTempLocal && code[i + 4].MatchLocal(code[i + 3])
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizeStackTransfer,The following statement contains a magic number: code[i].opcode == OpCodes.Ldloc  					&& code[i + 1].opcode == OpCodes.Stloc  					&& code[i + 2].pseudo == CodeType.BeginExceptionBlock  					&& code[i + 3].opcode == OpCodes.Ldloc && code[i + 3].MatchLocal(code[i + 1])  					&& code[i + 4].pseudo == CodeType.ReleaseTempLocal && code[i + 4].MatchLocal(code[i + 3])
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizeStackTransfer,The following statement contains a magic number: code[i].opcode == OpCodes.Ldloc  					&& code[i + 1].opcode == OpCodes.Stloc  					&& code[i + 2].pseudo == CodeType.BeginExceptionBlock  					&& code[i + 3].opcode == OpCodes.Ldloc && code[i + 3].MatchLocal(code[i + 1])  					&& code[i + 4].pseudo == CodeType.ReleaseTempLocal && code[i + 4].MatchLocal(code[i + 3])
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,OptimizeStackTransfer,The following statement contains a magic number: code[i].opcode == OpCodes.Ldloc  					&& code[i + 1].opcode == OpCodes.Stloc  					&& code[i + 2].pseudo == CodeType.BeginExceptionBlock  					&& code[i + 3].opcode == OpCodes.Ldloc && code[i + 3].MatchLocal(code[i + 1])  					&& code[i + 4].pseudo == CodeType.ReleaseTempLocal && code[i + 4].MatchLocal(code[i + 3])
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,MergeExceptionBlocks,The following statement contains a magic number: j < i + 2
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,CLRv4_x64_JIT_Workaround,The following statement contains a magic number: i < code.Count - 2
Magic Number,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,DoEmit,The following statement contains a magic number: i < 4
Magic Number,IKVM.Internal,OpCodeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,RealEmit,The following statement contains a magic number: codeEmitter.linenums = new IKVM.Attributes.LineNumberTableAttribute.LineNumberWriter(32);
Magic Number,IKVM.Internal,AttributeAnnotationTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DotNetTypeWrapper.cs,GetConstructors,The following statement contains a magic number: constructors.Length == 2 && type.Assembly == Types.Object.Assembly
Magic Number,IKVM.Internal,DynamicClassLoader,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicClassLoader.cs,TypeNameMangleImpl,The following statement contains a magic number: const int MaxLength = 1000;
Magic Number,IKVM.Internal,DynamicTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,VerifyDelegate,The following statement contains a magic number: constructor.Instructions.Length < 3  				|| constructor.Instructions[0].NormalizedOpCode != NormalizedByteCode.__aload  				|| constructor.Instructions[0].NormalizedArg1 != 0  				|| constructor.Instructions[1].NormalizedOpCode != NormalizedByteCode.__invokespecial  				|| constructor.Instructions[2].NormalizedOpCode != NormalizedByteCode.__return
Magic Number,IKVM.Internal,DynamicTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,VerifyDelegate,The following statement contains a magic number: constructor.Instructions.Length < 3  				|| constructor.Instructions[0].NormalizedOpCode != NormalizedByteCode.__aload  				|| constructor.Instructions[0].NormalizedArg1 != 0  				|| constructor.Instructions[1].NormalizedOpCode != NormalizedByteCode.__invokespecial  				|| constructor.Instructions[2].NormalizedOpCode != NormalizedByteCode.__return
Magic Number,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,CreateStep2,The following statement contains a magic number: AttributeHelper.SetEnclosingMethodAttribute(typeBuilder' classFile.EnclosingMethod[0]' classFile.EnclosingMethod[1]' classFile.EnclosingMethod[2]);
Magic Number,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,IsValidAnnotationElementType,The following statement contains a magic number: TypeWrapper tw = wrapper.GetClassLoader().LoadClassByDottedNameFast(type.Substring(1' type.Length - 2));
Magic Number,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,FindBaseMethods,The following statement contains a magic number: return classFile.MajorVersion >= 51  					? FindBaseMethods7(m.Name' m.Signature' m.IsFinal && !m.IsPublic && !m.IsProtected' out explicitOverride)  					: FindBaseMethodsLegacy(m.Name' m.Signature' out explicitOverride);
Magic Number,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GetPropertyAccess,The following statement contains a magic number: nacc = 3;
Magic Number,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GetPropertyAccess,The following statement contains a magic number: switch (access)  				{  					case 0:  						return MethodAttributes.Private;  					case 1:  						return MethodAttributes.Assembly;  					case 2:  						return MethodAttributes.FamORAssem;  					case 3:  						return MethodAttributes.Public;  					default:  						throw new InvalidOperationException();  				}
Magic Number,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GetPropertyAccess,The following statement contains a magic number: switch (access)  				{  					case 0:  						return MethodAttributes.Private;  					case 1:  						return MethodAttributes.Assembly;  					case 2:  						return MethodAttributes.FamORAssem;  					case 3:  						return MethodAttributes.Public;  					default:  						throw new InvalidOperationException();  				}
Magic Number,IKVM.Internal,AnnotationBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Link,The following statement contains a magic number: !o.IsValidAnnotationElementType(o.methods[i].Signature.Substring(2))
Magic Number,IKVM.Internal,AnnotationBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Link,The following statement contains a magic number: switch ((string)eval[2])  													{  														case "ANNOTATION_TYPE":  															targets |= AttributeTargets.Interface;  															break;  														case "CONSTRUCTOR":  															targets |= AttributeTargets.Constructor;  															break;  														case "FIELD":  															targets |= AttributeTargets.Field;  															break;  														case "LOCAL_VARIABLE":  															break;  														case "METHOD":  															targets |= AttributeTargets.Method;  															break;  														case "PACKAGE":  															targets |= AttributeTargets.Interface;  															break;  														case "PARAMETER":  															targets |= AttributeTargets.Parameter;  															break;  														case "TYPE":  															targets |= AttributeTargets.Class | AttributeTargets.Interface | AttributeTargets.Struct | AttributeTargets.Delegate | AttributeTargets.Enum;  															break;  													}
Magic Number,IKVM.Internal,AnnotationBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Link,The following statement contains a magic number: eval != null  													&& eval.Length == 3  													&& eval[0].Equals(AnnotationDefaultAttribute.TAG_ENUM)  													&& eval[1].Equals("Ljava/lang/annotation/ElementType;")
Magic Number,IKVM.Internal,Metadata,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Create,The following statement contains a magic number: classFile.MajorVersion < 49
Magic Number,IKVM.Internal,Metadata,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Create,The following statement contains a magic number: genericMetaData = new string[4][];
Magic Number,IKVM.Internal,Metadata,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Create,The following statement contains a magic number: annotations = new object[5][];
Magic Number,IKVM.Internal,Metadata,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Create,The following statement contains a magic number: annotations = new object[5][];
Magic Number,IKVM.Internal,Metadata,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Create,The following statement contains a magic number: annotations[2] = new object[classFile.Methods.Length];
Magic Number,IKVM.Internal,Metadata,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Create,The following statement contains a magic number: annotations[2] == null
Magic Number,IKVM.Internal,Metadata,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Create,The following statement contains a magic number: annotations[2][i] = classFile.Methods[i].ParameterAnnotations;
Magic Number,IKVM.Internal,Metadata,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Create,The following statement contains a magic number: annotations = new object[5][];
Magic Number,IKVM.Internal,Metadata,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Create,The following statement contains a magic number: annotations[3] = new object[classFile.Methods.Length];
Magic Number,IKVM.Internal,Metadata,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Create,The following statement contains a magic number: annotations[3] == null
Magic Number,IKVM.Internal,Metadata,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Create,The following statement contains a magic number: annotations[3][i] = classFile.Methods[i].AnnotationDefault;
Magic Number,IKVM.Internal,Metadata,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Create,The following statement contains a magic number: genericMetaData = new string[4][];
Magic Number,IKVM.Internal,Metadata,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Create,The following statement contains a magic number: annotations = new object[5][];
Magic Number,IKVM.Internal,Metadata,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Create,The following statement contains a magic number: annotations[4] = new object[classFile.Fields.Length][];
Magic Number,IKVM.Internal,Metadata,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Create,The following statement contains a magic number: annotations[4] == null
Magic Number,IKVM.Internal,Metadata,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Create,The following statement contains a magic number: annotations[4][i] = classFile.Fields[i].Annotations;
Magic Number,IKVM.Internal,Metadata,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Create,The following statement contains a magic number: genericMetaData = new string[4][];
Magic Number,IKVM.Internal,Metadata,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Create,The following statement contains a magic number: genericMetaData[2] = classFile.EnclosingMethod;
Magic Number,IKVM.Internal,Metadata,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Create,The following statement contains a magic number: genericMetaData = new string[4][];
Magic Number,IKVM.Internal,Metadata,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Create,The following statement contains a magic number: genericMetaData[3] = new string[] { classFile.GenericSignature };
Magic Number,IKVM.Internal,Metadata,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Create,The following statement contains a magic number: annotations = new object[5][];
Magic Number,IKVM.Internal,Metadata,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GetGenericSignature,The following statement contains a magic number: return m.genericMetaData[3][0];
Magic Number,IKVM.Internal,Metadata,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GetGenericSignature,The following statement contains a magic number: m != null && m.genericMetaData != null && m.genericMetaData[3] != null
Magic Number,IKVM.Internal,Metadata,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GetEnclosingMethod,The following statement contains a magic number: return m.genericMetaData[2];
Magic Number,IKVM.Internal,Metadata,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GetMethodParameterAnnotations,The following statement contains a magic number: return (object[][])m.annotations[2][index];
Magic Number,IKVM.Internal,Metadata,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GetMethodParameterAnnotations,The following statement contains a magic number: m != null && m.annotations != null && m.annotations[2] != null
Magic Number,IKVM.Internal,Metadata,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GetMethodDefaultValue,The following statement contains a magic number: return m.annotations[3][index];
Magic Number,IKVM.Internal,Metadata,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GetMethodDefaultValue,The following statement contains a magic number: m != null && m.annotations != null && m.annotations[3] != null
Magic Number,IKVM.Internal,Metadata,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GetFieldAnnotations,The following statement contains a magic number: return (object[])m.annotations[4][index];
Magic Number,IKVM.Internal,Metadata,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GetFieldAnnotations,The following statement contains a magic number: m != null && m.annotations != null && m.annotations[4] != null
Magic Number,IKVM.Internal,JniBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Generate,The following statement contains a magic number: Type[] modargs = new Type[args.Length + 2];
Magic Number,IKVM.Internal,JniBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Generate,The following statement contains a magic number: modargs[i + 2] = args[i].TypeAsSignatureType;
Magic Number,IKVM.Internal,JniBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Generate,The following statement contains a magic number: modargs[j + 2] = Types.IntPtr;
Magic Number,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,Object_getClass,The following statement contains a magic number: eic.MatchRange(0' 2)  				&& eic.Match(1' NormalizedByteCode.__pop)
Magic Number,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,Class_desiredAssertionStatus,The following statement contains a magic number: eic.MatchRange(-1' 2)  				&& eic.Match(-1' NormalizedByteCode.__ldc)
Magic Number,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,Class_getDeclaredField,The following statement contains a magic number: eic.MatchRange(-2' 4)  				&& eic.Match(-2' NormalizedByteCode.__ldc) && eic.GetClassLiteral(-2) == eic.Caller.DeclaringType  				&& eic.Match(-1' NormalizedByteCode.__ldc_nothrow)  				&& eic.Match(1' NormalizedByteCode.__invokevirtual)
Magic Number,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,Class_getDeclaredField,The following statement contains a magic number: eic.MatchRange(-2' 4)  				&& eic.Match(-2' NormalizedByteCode.__ldc) && eic.GetClassLiteral(-2) == eic.Caller.DeclaringType  				&& eic.Match(-1' NormalizedByteCode.__ldc_nothrow)  				&& eic.Match(1' NormalizedByteCode.__invokevirtual)
Magic Number,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,Class_getDeclaredField,The following statement contains a magic number: eic.MatchRange(-2' 4)  				&& eic.Match(-2' NormalizedByteCode.__ldc) && eic.GetClassLiteral(-2) == eic.Caller.DeclaringType  				&& eic.Match(-1' NormalizedByteCode.__ldc_nothrow)  				&& eic.Match(1' NormalizedByteCode.__invokevirtual)
Magic Number,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,Class_getDeclaredField,The following statement contains a magic number: eic.MatchRange(-2' 4)  				&& eic.Match(-2' NormalizedByteCode.__ldc) && eic.GetClassLiteral(-2) == eic.Caller.DeclaringType  				&& eic.Match(-1' NormalizedByteCode.__ldc_nothrow)  				&& eic.Match(1' NormalizedByteCode.__invokevirtual)
Magic Number,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,System_arraycopy,The following statement contains a magic number: TypeWrapper dst_type = eic.GetStackTypeWrapper(0' 2);
Magic Number,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,System_arraycopy,The following statement contains a magic number: TypeWrapper src_type = eic.GetStackTypeWrapper(0' 4);
Magic Number,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,String_toCharArray,The following statement contains a magic number: str.Length > 128
Magic Number,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,String_toCharArray,The following statement contains a magic number: eic.MatchRange(-1' 2)  				&& eic.Match(-1' NormalizedByteCode.__ldc_nothrow)
Magic Number,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,EmitLoadCharArrayLiteral,The following statement contains a magic number: int length = str.Length * 2;
Magic Number,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,EmitLoadCharArrayLiteral,The following statement contains a magic number: data[j * 2 + 0] = (byte)(str[j] >> 0);
Magic Number,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,EmitLoadCharArrayLiteral,The following statement contains a magic number: data[j * 2 + 1] = (byte)(str[j] >> 8);
Magic Number,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,EmitLoadCharArrayLiteral,The following statement contains a magic number: data[j * 2 + 1] = (byte)(str[j] >> 8);
Magic Number,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,Reflection_getCallerClass,The following statement contains a magic number: eic.Caller.HasCallerID  				&& eic.MatchRange(-1' 2)  				&& eic.Match(-1' NormalizedByteCode.__iconst' 2)
Magic Number,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,Reflection_getCallerClass,The following statement contains a magic number: eic.Caller.HasCallerID  				&& eic.MatchRange(-1' 2)  				&& eic.Match(-1' NormalizedByteCode.__iconst' 2)
Magic Number,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,Util_getInstanceTypeFromClass,The following statement contains a magic number: eic.MatchRange(-1' 2)  				&& eic.Match(-1' NormalizedByteCode.__ldc)
Magic Number,IKVM.Internal,Intrinsics,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\intrinsics.cs,Unsafe_ensureClassInitialized,The following statement contains a magic number: eic.MatchRange(-1' 2)  				&& eic.Match(-1' NormalizedByteCode.__ldc)
Magic Number,IKVM.Internal,JsrInliner,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\JsrInliner.cs,Add,The following statement contains a magic number: Array.Resize(ref codeCopy' codeLength * 2);
Magic Number,IKVM.Internal,JsrInliner,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\JsrInliner.cs,Add,The following statement contains a magic number: Array.Resize(ref flags' codeLength * 2);
Magic Number,IKVM.Internal,Tracer,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\tracer.cs,SetTraceLevel,The following statement contains a magic number: trace.Length == 2
Magic Number,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,GetModifiersAttribute,The following statement contains a magic number: args.Count == 2
Magic Number,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,GetRemappedInterfaceMethods,The following statement contains a magic number: attrs.Add(new RemappedInterfaceMethodAttribute((string)args[0].Value' (string)args[1].Value' DecodeArray<string>(args[2])));
Magic Number,IKVM.Internal,AttributeHelper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,GetEnclosingMethodAttribute,The following statement contains a magic number: return new EnclosingMethodAttribute((string)cad.ConstructorArguments[0].Value' (string)cad.ConstructorArguments[1].Value' (string)cad.ConstructorArguments[2].Value);
Magic Number,IKVM.Internal,Annotation,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,ConvertValue,The following statement contains a magic number: string s = ((object[])arr[i])[2].ToString();
Magic Number,IKVM.Internal,Annotation,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,HasRetentionPolicyRuntime,The following statement contains a magic number: val != null  									&& val.Length == 3  									&& val[0].Equals(AnnotationDefaultAttribute.TAG_ENUM)  									&& val[1].Equals("Ljava/lang/annotation/RetentionPolicy;")  									&& val[2].Equals("RUNTIME")
Magic Number,IKVM.Internal,Annotation,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\TypeWrapper.cs,HasRetentionPolicyRuntime,The following statement contains a magic number: val != null  									&& val.Length == 3  									&& val[0].Equals(AnnotationDefaultAttribute.TAG_ENUM)  									&& val[1].Equals("Ljava/lang/annotation/RetentionPolicy;")  									&& val[2].Equals("RUNTIME")
Magic Number,IKVM.Internal,JVM,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\vm.cs,SafeGetAssemblyVersion,The following statement contains a magic number: start += 10;
Magic Number,IKVM.Internal,JVM,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\vm.cs,MangleResourceName,The following statement contains a magic number: StringBuilder sb = new StringBuilder("ikvm__"' name.Length + 6);
Magic Number,IKVM.Internal,JVM,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\vm.cs,PersistableHash,The following statement contains a magic number: key += (key << 12);
Magic Number,IKVM.Internal,JVM,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\vm.cs,PersistableHash,The following statement contains a magic number: key ^= (key >> 22);
Magic Number,IKVM.Internal,JVM,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\vm.cs,PersistableHash,The following statement contains a magic number: key += (key << 4);
Magic Number,IKVM.Internal,JVM,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\vm.cs,PersistableHash,The following statement contains a magic number: key ^= (key >> 9);
Magic Number,IKVM.Internal,JVM,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\vm.cs,PersistableHash,The following statement contains a magic number: key += (key << 10);
Magic Number,IKVM.Internal,JVM,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\vm.cs,PersistableHash,The following statement contains a magic number: key ^= (key >> 2);
Magic Number,IKVM.Internal,JVM,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\vm.cs,PersistableHash,The following statement contains a magic number: key += (key << 7);
Magic Number,IKVM.Internal,JVM,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\vm.cs,PersistableHash,The following statement contains a magic number: key ^= (key >> 12);
Magic Number,IKVM.Attributes,LineNumberTableAttribute,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\attributes.cs,ReadPackedInteger,The following statement contains a magic number: return b - 64;
Magic Number,IKVM.Attributes,LineNumberTableAttribute,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\attributes.cs,ReadPackedInteger,The following statement contains a magic number: b < 128
Magic Number,IKVM.Attributes,LineNumberTableAttribute,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\attributes.cs,GetLineNumber,The following statement contains a magic number: int prevLineNum = ReadPackedInteger(ref i) + (64 + 50);
Magic Number,IKVM.Attributes,LineNumberTableAttribute,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\attributes.cs,GetLineNumber,The following statement contains a magic number: int prevLineNum = ReadPackedInteger(ref i) + (64 + 50);
Magic Number,IKVM.Attributes,LineNumberTableAttribute,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\attributes.cs,GetLineNumber,The following statement contains a magic number: int deltaPC = lead & 31;
Magic Number,IKVM.Attributes,LineNumberTableAttribute,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\attributes.cs,GetLineNumber,The following statement contains a magic number: int deltaLineNo = (lead >> 5) - 2;
Magic Number,IKVM.Attributes,LineNumberTableAttribute,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\attributes.cs,GetLineNumber,The following statement contains a magic number: int deltaLineNo = (lead >> 5) - 2;
Magic Number,IKVM.Attributes,LineNumberTableAttribute,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\attributes.cs,GetLineNumber,The following statement contains a magic number: deltaPC = ReadPackedInteger(ref i) + (64 + 31);
Magic Number,IKVM.Attributes,LineNumberTableAttribute,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\attributes.cs,GetLineNumber,The following statement contains a magic number: deltaPC = ReadPackedInteger(ref i) + (64 + 31);
Magic Number,IKVM.Attributes,LineNumberTableAttribute,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\attributes.cs,GetLineNumber,The following statement contains a magic number: deltaPC == 31
Magic Number,IKVM.Attributes,LineNumberTableAttribute,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\attributes.cs,GetLineNumber,The following statement contains a magic number: deltaLineNo == 5
Magic Number,IKVM.Attributes,LineNumberWriter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\attributes.cs,LineNumberWriter,The following statement contains a magic number: stream = new System.IO.MemoryStream(estimatedCount * 2);
Magic Number,IKVM.Attributes,LineNumberWriter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\attributes.cs,AddMapping,The following statement contains a magic number: WritePackedInteger(linenumber - (64 + 50));
Magic Number,IKVM.Attributes,LineNumberWriter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\attributes.cs,AddMapping,The following statement contains a magic number: WritePackedInteger(linenumber - (64 + 50));
Magic Number,IKVM.Attributes,LineNumberWriter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\attributes.cs,AddMapping,The following statement contains a magic number: deltaPC >= 0 && deltaPC < 31
Magic Number,IKVM.Attributes,LineNumberWriter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\attributes.cs,AddMapping,The following statement contains a magic number: const int bias = 2;
Magic Number,IKVM.Attributes,LineNumberWriter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\attributes.cs,AddMapping,The following statement contains a magic number: lead |= (byte)((deltaLineNo + bias) << 5);
Magic Number,IKVM.Attributes,LineNumberWriter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\attributes.cs,AddMapping,The following statement contains a magic number: deltaLineNo >= -bias && deltaLineNo < 7 - bias
Magic Number,IKVM.Attributes,LineNumberWriter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\attributes.cs,AddMapping,The following statement contains a magic number: WritePackedInteger(deltaPC - (64 + 31));
Magic Number,IKVM.Attributes,LineNumberWriter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\attributes.cs,AddMapping,The following statement contains a magic number: WritePackedInteger(deltaPC - (64 + 31));
Magic Number,IKVM.Attributes,LineNumberWriter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\attributes.cs,WritePackedInteger,The following statement contains a magic number: val += 64;
Magic Number,IKVM.Attributes,LineNumberWriter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\attributes.cs,WritePackedInteger,The following statement contains a magic number: val >= -64 && val < 64
Magic Number,IKVM.Attributes,LineNumberWriter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\attributes.cs,WritePackedInteger,The following statement contains a magic number: val >= -64 && val < 64
Missing Default,IKVM.Internal,ConstantPoolItemMethodHandle,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Resolve,The following switch statement is missing a default case: switch ((RefKind)ref_kind)  				{  					case RefKind.getField:  					case RefKind.getStatic:  					case RefKind.putField:  					case RefKind.putStatic:  						cpi = classFile.GetConstantPoolItem(method_index) as ConstantPoolItemFieldref;  						break;  					case RefKind.invokeSpecial:  					case RefKind.invokeVirtual:  					case RefKind.invokeStatic:  					case RefKind.newInvokeSpecial:  						cpi = classFile.GetConstantPoolItem(method_index) as ConstantPoolItemMethodref;  						break;  					case RefKind.invokeInterface:  						cpi = classFile.GetConstantPoolItem(method_index) as ConstantPoolItemInterfaceMethodref;  						break;  				}
Missing Default,IKVM.Internal,Code,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Read,The following switch statement is missing a default case: switch(this.instructions[i].NormalizedOpCode)  						{  							case NormalizedByteCode.__ifeq:  							case NormalizedByteCode.__ifne:  							case NormalizedByteCode.__iflt:  							case NormalizedByteCode.__ifge:  							case NormalizedByteCode.__ifgt:  							case NormalizedByteCode.__ifle:  							case NormalizedByteCode.__if_icmpeq:  							case NormalizedByteCode.__if_icmpne:  							case NormalizedByteCode.__if_icmplt:  							case NormalizedByteCode.__if_icmpge:  							case NormalizedByteCode.__if_icmpgt:  							case NormalizedByteCode.__if_icmple:  							case NormalizedByteCode.__if_acmpeq:  							case NormalizedByteCode.__if_acmpne:  							case NormalizedByteCode.__ifnull:  							case NormalizedByteCode.__ifnonnull:  							case NormalizedByteCode.__goto:  							case NormalizedByteCode.__jsr:  								this.instructions[i].SetTargetIndex(pcIndexMap[this.instructions[i].Arg1 + this.instructions[i].PC]);  								break;  							case NormalizedByteCode.__tableswitch:  							case NormalizedByteCode.__lookupswitch:  								this.instructions[i].MapSwitchTargets(pcIndexMap);  								break;  						}
Missing Default,IKVM.Internal,Code,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\ClassFile.cs,Read,The following switch statement is missing a default case: switch(sig[i])  						{  							case 'L':  								i = sig.IndexOf(';'' i);  								break;  							case 'D':  							case 'J':  								args.Add(-1);  								break;  							case '[':  							{  								while(sig[i] == '[')  								{  									i++;  								}  								if(sig[i] == 'L')  								{  									i = sig.IndexOf(';'' i);  								}  								break;  							}  						}
Missing Default,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,SortPseudoOpCodes,The following switch statement is missing a default case: switch (code[i].pseudo)  				{  					case CodeType.LineNumber:  					case CodeType.ReleaseTempLocal:  						if (code[i + 1].opcode == OpCodes.Pop)  						{  							OpCodeWrapper temp = code[i];  							code[i] = code[i + 1];  							code[i + 1] = temp;  							i--;  						}  						break;  					case CodeType.BeginExceptionBlock:  						if (code[i + 1].pseudo == CodeType.ReleaseTempLocal)  						{  							OpCodeWrapper temp = code[i];  							code[i] = code[i + 1];  							code[i + 1] = temp;  							i--;  						}  						break;  					case CodeType.Label:  						if (code[i + 1].pseudo == CodeType.BeginExceptionBlock)  						{  							OpCodeWrapper temp = code[i];  							code[i] = code[i + 1];  							code[i + 1] = temp;  							i--;  						}  						break;  				}
Missing Default,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,RemoveDeadCode,The following switch statement is missing a default case: switch (code[i].opcode.FlowControl)  							{  								case FlowControl.Cond_Branch:  									if (!code[i].HasLabel && code[i].opcode != OpCodes.Switch)  									{  										throw new NotSupportedException();  									}  									break;  								case FlowControl.Branch:  									if (code[i].HasLabel)  									{  										reachable = false;  									}  									else if (code[i].HasValueByte && code[i].ValueByte == 0)  									{  										// it's a "leave_s 0"' so the next instruction is reachable  									}  									else  									{  										throw new NotSupportedException();  									}  									break;  								case FlowControl.Return:  								case FlowControl.Throw:  									reachable = false;  									break;  							}
Missing Default,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,RemoveDeadCode,The following switch statement is missing a default case: switch (code[i].opcode.FlowControl)  						{  							case FlowControl.Branch:  								if (code[i].HasValueByte && code[i].ValueByte == 0)  								{  									// it's a "leave_s 0"' so the next instruction is reachable  								}  								else  								{  									goto case FlowControl.Return;  								}  								break;  							case FlowControl.Return:  							case FlowControl.Throw:  								reachable = false;  								firstUnreachable = i + 1;  								break;  						}
Missing Default,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,RemoveDeadCode,The following switch statement is missing a default case: switch (code[i + k].pseudo)  						{  							case CodeType.BeginCatchBlock:  							case CodeType.BeginFaultBlock:  							case CodeType.BeginFinallyBlock:  								int depth = 0;  								for (int j = i + 1; ; j++)  								{  									switch (code[j].pseudo)  									{  										case CodeType.BeginExceptionBlock:  											depth++;  											break;  										case CodeType.EndExceptionBlock:  											if (depth == 0)  											{  												code.RemoveRange(i' (j - i) + 1);  												goto restart;  											}  											depth--;  											break;  									}  								}  							case CodeType.OpCode:  								goto next;  						}
Missing Default,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,RemoveDeadCode,The following switch statement is missing a default case: switch (code[j].pseudo)  									{  										case CodeType.BeginExceptionBlock:  											depth++;  											break;  										case CodeType.EndExceptionBlock:  											if (depth == 0)  											{  												code.RemoveRange(i' (j - i) + 1);  												goto restart;  											}  											depth--;  											break;  									}
Missing Default,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,DeduplicateBranchSourceTargetCode,The following switch statement is missing a default case: switch (code[source].opcode.FlowControl)  						{  							case FlowControl.Branch:  							case FlowControl.Cond_Branch:  								goto break_while;  						}
Missing Default,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,MergeExceptionBlocks,The following switch statement is missing a default case: switch (code[i].pseudo)  				{  					case CodeType.BeginExceptionBlock:  						stack.Push(currentBeginExceptionBlock);  						currentBeginExceptionBlock = i;  						currentLast = i;  						break;  					case CodeType.EndExceptionBlock:  						extra[currentLast] = i;  						extra[i] = currentBeginExceptionBlock;  						currentBeginExceptionBlock = stack.Pop();  						currentLast = currentBeginExceptionBlock;  						if (currentLast != -1)  						{  							while (extra[currentLast] != 0)  							{  								currentLast = extra[currentLast];  							}  						}  						break;  					case CodeType.BeginCatchBlock:  					case CodeType.BeginFaultBlock:  					case CodeType.BeginFinallyBlock:  						extra[currentLast] = i;  						currentLast = i;  						break;  				}
Missing Default,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,RemoveRedundantMemoryBarriers,The following switch statement is missing a default case: switch (code[i].pseudo)  				{  					case CodeType.MemoryBarrier:  						if (lastMemoryBarrier != -1)  						{  							code.RemoveAt(lastMemoryBarrier);  							i--;  						}  						lastMemoryBarrier = i;  						break;  					case CodeType.OpCode:  						if (code[i].opcode == OpCodes.Volatile)  						{  							if (code[i + 1].opcode != OpCodes.Stfld && code[i + 1].opcode != OpCodes.Stsfld)  							{  								lastMemoryBarrier = -1;  							}  						}  						else if (code[i].opcode.FlowControl != FlowControl.Next)  						{  							lastMemoryBarrier = -1;  						}  						break;  				}
Missing Default,IKVM.Internal,CodeEmitter,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\CodeEmitter.cs,Emit_if_le_lt_ge_gt,The following switch statement is missing a default case: switch (comp)  			{  				case Comparison.LessOrEqual:  					Emit(OpCodes.Ble' label);  					break;  				case Comparison.LessThan:  					Emit(OpCodes.Blt' label);  					break;  				case Comparison.GreaterOrEqual:  					Emit(OpCodes.Bge' label);  					break;  				case Comparison.GreaterThan:  					Emit(OpCodes.Bgt' label);  					break;  			}
Missing Default,IKVM.Internal,DynamicTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GetParameterNamesFromSig,The following switch statement is missing a default case: switch (sig[i])  						{  							case 'B':  							case 'Z':  								names.Add("barr");  								break;  							case 'C':  								names.Add("charr");  								break;  							case 'S':  								names.Add("sarr");  								break;  							case 'I':  								names.Add("iarr");  								break;  							case 'J':  								names.Add("larr");  								break;  							case 'F':  								names.Add("farr");  								break;  							case 'D':  								names.Add("darr");  								break;  						}
Missing Default,IKVM.Internal,DynamicTypeWrapper,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,GetParameterNamesFromSig,The following switch statement is missing a default case: switch (sig[i])  					{  						case 'B':  						case 'Z':  							names.Add("b");  							break;  						case 'C':  							names.Add("ch");  							break;  						case 'S':  							names.Add("s");  							break;  						case 'I':  							names.Add("i");  							break;  						case 'J':  							names.Add("l");  							break;  						case 'F':  							names.Add("f");  							break;  						case 'D':  							names.Add("d");  							break;  					}
Missing Default,IKVM.Internal,JavaTypeImpl,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,IsValidAnnotationElementType,The following switch statement is missing a default case: switch (type)  				{  					case "Z":  					case "B":  					case "S":  					case "C":  					case "I":  					case "J":  					case "F":  					case "D":  					case "Ljava.lang.String;":  					case "Ljava.lang.Class;":  						return true;  				}
Missing Default,IKVM.Internal,AnnotationBuilder,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\DynamicTypeWrapper.cs,Link,The following switch statement is missing a default case: switch ((string)eval[2])  													{  														case "ANNOTATION_TYPE":  															targets |= AttributeTargets.Interface;  															break;  														case "CONSTRUCTOR":  															targets |= AttributeTargets.Constructor;  															break;  														case "FIELD":  															targets |= AttributeTargets.Field;  															break;  														case "LOCAL_VARIABLE":  															break;  														case "METHOD":  															targets |= AttributeTargets.Method;  															break;  														case "PACKAGE":  															targets |= AttributeTargets.Interface;  															break;  														case "PARAMETER":  															targets |= AttributeTargets.Parameter;  															break;  														case "TYPE":  															targets |= AttributeTargets.Class | AttributeTargets.Interface | AttributeTargets.Struct | AttributeTargets.Delegate | AttributeTargets.Enum;  															break;  													}
Missing Default,IKVM.Internal,SubroutineCall,D:\research\architectureSmells\repos\CoEST_TraceLab\Main\external\ikvm\src\runtime\JsrInliner.cs,DoFixups,The following switch statement is missing a default case: switch (inliner.codeCopy[instructionIndex].NormalizedOpCode)  					{  						case NormalizedByteCode.__lookupswitch:  						case NormalizedByteCode.__tableswitch:  							{  								int[] targets = new int[inliner.codeCopy[instructionIndex].SwitchEntryCount];  								for (int i = 0; i < targets.Length; i++)  								{  									targets[i] = branchMap[inliner.codeCopy[instructionIndex].GetSwitchTargetIndex(i)];  								}  								inliner.codeCopy[instructionIndex].SetSwitchTargets(targets);  								inliner.codeCopy[instructionIndex].DefaultTarget = branchMap[inliner.codeCopy[instructionIndex].DefaultTarget];  							}  							break;  						case NormalizedByteCode.__ifeq:  						case NormalizedByteCode.__ifne:  						case NormalizedByteCode.__iflt:  						case NormalizedByteCode.__ifge:  						case NormalizedByteCode.__ifgt:  						case NormalizedByteCode.__ifle:  						case NormalizedByteCode.__if_icmpeq:  						case NormalizedByteCode.__if_icmpne:  						case NormalizedByteCode.__if_icmplt:  						case NormalizedByteCode.__if_icmpge:  						case NormalizedByteCode.__if_icmpgt:  						case NormalizedByteCode.__if_icmple:  						case NormalizedByteCode.__if_acmpeq:  						case NormalizedByteCode.__if_acmpne:  						case NormalizedByteCode.__ifnull:  						case NormalizedByteCode.__ifnonnull:  						case NormalizedByteCode.__goto:  						case NormalizedByteCode.__jsr:  							inliner.codeCopy[instructionIndex].TargetIndex = branchMap[inliner.codeCopy[instructionIndex].TargetIndex];  							break;  					}
