Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.Windows.Controls,Accordion,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\Accordion.cs,PrepareContainerForItemOverride,The method has 102 lines of code.
Long Method,System.Windows.Controls,Accordion,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\Accordion.cs,OnItemsChanged,The method has 114 lines of code.
Long Method,System.Windows.Controls,Accordion,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\Accordion.cs,OnSelectedIndicesCollectionChanged,The method has 109 lines of code.
Complex Method,System.Windows.Controls,Accordion,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\Accordion.cs,OnSelectionModePropertyChanged,Cyclomatic complexity of the method is 10
Complex Method,System.Windows.Controls,Accordion,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\Accordion.cs,PrepareContainerForItemOverride,Cyclomatic complexity of the method is 13
Complex Method,System.Windows.Controls,Accordion,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\Accordion.cs,UnselectItem,Cyclomatic complexity of the method is 9
Complex Method,System.Windows.Controls,Accordion,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\Accordion.cs,LayoutChildren,Cyclomatic complexity of the method is 11
Long Identifier,System.Windows.Controls,InteractionHelper,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Common\System\Windows\Controls\InteractionHelper.cs,,The length of the parameter SequentialClickThresholdInMilliseconds is 38.
Long Identifier,System.Windows.Controls,InteractionHelper,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Common\System\Windows\Controls\InteractionHelper.cs,,The length of the parameter SequentialClickThresholdInPixelsSquared is 39.
Long Identifier,System.Windows.Controls,Accordion,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\Accordion.cs,,The length of the parameter _isAllowedToWriteSelectedItems is 30.
Long Identifier,System.Windows.Controls,Accordion,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\Accordion.cs,,The length of the parameter _isAllowedToWriteSelectedIndices is 32.
Long Identifier,System.Windows.Controls,Accordion,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\Accordion.cs,,The length of the parameter _isIgnoringSelectedIndicesChanges is 33.
Long Identifier,System.Windows.Controls,Accordion,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\Accordion.cs,,The length of the parameter _isIgnoringSelectedItemsChanges is 31.
Long Identifier,System.Windows.Controls,Accordion,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\Accordion.cs,,The length of the parameter _isInSelectedItemsCollectionChanged is 35.
Long Identifier,System.Windows.Controls,Accordion,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\Accordion.cs,,The length of the parameter _isInSelectedIndicesCollectionChanged is 37.
Long Identifier,System.Windows.Controls,AccordionItem,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\AccordionItem.cs,,The length of the parameter _allowedToWriteExpandDirection is 30.
Long Identifier,System.Windows.Controls,AccordionItem,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\AccordionItem.cs,,The length of the parameter ExpandableContentControlStyleProperty is 37.
Long Identifier,System.Windows.Controls,AccordionItem,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\AccordionItem.cs,,The length of the parameter _allowedToWriteContentTargetSize is 32.
Long Identifier,System.Windows.Controls,TransitioningContentControl,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\TransitioningContentControl\System\Windows\Controls\TransitioningContentControl.cs,,The length of the parameter PreviousContentPresentationSitePartName is 39.
Long Identifier,System.Windows.Controls,TransitioningContentControl,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\TransitioningContentControl\System\Windows\Controls\TransitioningContentControl.cs,,The length of the parameter CurrentContentPresentationSitePartName is 38.
Long Identifier,System.Windows.Controls,TransitioningContentControl,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\TransitioningContentControl\System\Windows\Controls\TransitioningContentControl.cs,,The length of the parameter RestartTransitionOnContentChangeProperty is 40.
Long Statement,System.Windows.Controls,InteractionHelper,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Common\System\Windows\Controls\InteractionHelper.cs,UpdateVisualStateBase,The length of the statement  "                VisualStates.GoToState(Control' useTransitions' VisualStates.StatePressed' VisualStates.StateMouseOver' VisualStates.StateNormal); " is 130.
Long Statement,System.Windows.Controls,Accordion,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\Accordion.cs,OnSelectedItemPropertyChanged,The length of the statement  "                        IEnumerable<int> validIndices = source.SelectedIndices.Where(i => i >= 0 && i < source.Items.Count && newValue.Equals(source.Items[i])); " is 136.
Long Statement,System.Windows.Controls,Accordion,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\Accordion.cs,PrepareContainerForItemOverride,The length of the statement  "                AccordionItem.PreparePrepareHeaderedContentControlContainerForItemOverride(accordionItem' item' this' ItemContainerStyle); " is 122.
Long Statement,System.Windows.Controls,Accordion,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\Accordion.cs,OnAccordionItemUnselected,The length of the statement  "            UnselectItem(ItemContainerGenerator.IndexFromContainer(accordionItem)' ItemContainerGenerator.ItemFromContainer(accordionItem)); " is 128.
Long Statement,System.Windows.Controls,Accordion,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\Accordion.cs,UnselectItem,The length of the statement  "            AccordionItem container = index >= 0 && index < Items.Count ? ItemContainerGenerator.ContainerFromIndex(index) as AccordionItem : null; " is 135.
Long Statement,System.Windows.Controls,Accordion,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\Accordion.cs,SelectItem,The length of the statement  "            AccordionItem container = index >= 0 && index < Items.Count ? ItemContainerGenerator.ContainerFromIndex(index) as AccordionItem : null; " is 135.
Long Statement,System.Windows.Controls,Accordion,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\Accordion.cs,ChangeSelectedIndex,The length of the statement  "            AccordionItem oldAccordionItem = oldIndex >= 0 && oldIndex < Items.Count ? ItemContainerGenerator.ContainerFromIndex(oldIndex) as AccordionItem : null; " is 151.
Long Statement,System.Windows.Controls,Accordion,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\Accordion.cs,ChangeSelectedIndex,The length of the statement  "            AccordionItem newAccordionItem = newIndex >= 0 && newIndex < Items.Count ? ItemContainerGenerator.ContainerFromIndex(newIndex) as AccordionItem : null; " is 151.
Long Statement,System.Windows.Controls,Accordion,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\Accordion.cs,OnSelectedIndicesCollectionChanged,The length of the statement  "                            if (SelectedItem != null && e.NewItems.Count != 1 || ((int)e.NewItems[0] < Items.Count && !Items[(int)e.NewItems[0]].Equals(SelectedItem))) " is 139.
Long Statement,System.Windows.Controls,Accordion,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\Accordion.cs,ProposeSelectedIndexCandidate,The length of the statement  "            IEnumerable<int> validIndices = SelectedIndices.Where(i => i != nonCandidateIndex && (item == null || !item.Equals(Items[i]))); " is 127.
Long Statement,System.Windows.Controls,Accordion,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\Accordion.cs,SetPanelOrientation,The length of the statement  "                        panel.HorizontalAlignment = ExpandDirection == ExpandDirection.Left ? HorizontalAlignment.Right : HorizontalAlignment.Left; " is 123.
Long Statement,System.Windows.Controls,TransitioningContentControl,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\TransitioningContentControl\System\Windows\Controls\TransitioningContentControl.cs,OnTransitionPropertyChanged,The length of the statement  "                        string.Format(CultureInfo.CurrentCulture' Properties.Resources.TransitioningContentControl_TransitionNotFound' newTransition)); " is 127.
Long Statement,System.Windows.Controls,TransitioningContentControl,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\TransitioningContentControl\System\Windows\Controls\TransitioningContentControl.cs,OnApplyTemplate,The length of the statement  "                    string.Format(CultureInfo.CurrentCulture' Properties.Resources.TransitioningContentControl_TransitionNotFound' invalidTransition)); " is 131.
Long Statement,System.Windows.Controls.Primitives,ExpandableContentControl,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\ExpandableContentControl.cs,CalculatePercentage,The length of the statement  "                    newPercentage = expandableContentControl.ActualHeight / (double.IsNaN(value.Height) ? expandableContentControl.ContentSite.DesiredSize.Height : value.Height); " is 158.
Long Statement,System.Windows.Controls.Primitives,ExpandableContentControl,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\ExpandableContentControl.cs,CalculatePercentage,The length of the statement  "                    newPercentage = expandableContentControl.ActualWidth / (double.IsNaN(value.Width) ? expandableContentControl.ContentSite.DesiredSize.Width : value.Width); " is 154.
Complex Conditional,System.Windows.Controls,Accordion,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\Accordion.cs,OnExpandDirectionPropertyChanged,The conditional expression  "expandDirection != ExpandDirection.Down &&                  expandDirection != ExpandDirection.Up &&                  expandDirection != ExpandDirection.Left &&                  expandDirection != ExpandDirection.Right"  is complex.
Complex Conditional,System.Windows.Controls,Accordion,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\Accordion.cs,OnSelectionModePropertyChanged,The conditional expression  "newValue != AccordionSelectionMode.One &&                  newValue != AccordionSelectionMode.OneOrMore &&                  newValue != AccordionSelectionMode.ZeroOrMore &&                  newValue != AccordionSelectionMode.ZeroOrOne"  is complex.
Complex Conditional,System.Windows.Controls,Accordion,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\Accordion.cs,OnSelectedIndicesCollectionChanged,The conditional expression  "SelectedItem != null && e.NewItems.Count != 1 || ((int)e.NewItems[0] < Items.Count && !Items[(int)e.NewItems[0]].Equals(SelectedItem))"  is complex.
Complex Conditional,System.Windows.Controls,AccordionItem,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\AccordionItem.cs,OnExpandDirectionPropertyChanged,The conditional expression  "newValue != ExpandDirection.Down &&                  newValue != ExpandDirection.Left &&                  newValue != ExpandDirection.Right &&                  newValue != ExpandDirection.Up"  is complex.
Complex Conditional,System.Windows.Controls,AccordionItem,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\AccordionItem.cs,OnExpandSiteContentSizeChanged,The conditional expression  "(!ShouldFillWidth && e.PreviousSize.Width != e.NewSize.Width) ||                      (!ShouldFillHeight && e.PreviousSize.Height != e.NewSize.Height)"  is complex.
Complex Conditional,System.Windows.Controls,AccordionItem,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\AccordionItem.cs,OnKeyDown,The conditional expression  "(isSelected && e.Key == Key.Up) || (!isSelected && e.Key == Key.Down)"  is complex.
Complex Conditional,System.Windows.Controls,AccordionItem,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\AccordionItem.cs,OnKeyDown,The conditional expression  "(isSelected && e.Key == Key.Down) || (!isSelected && e.Key == Key.Up)"  is complex.
Complex Conditional,System.Windows.Controls,AccordionItem,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\AccordionItem.cs,OnKeyDown,The conditional expression  "(isSelected && e.Key == Key.Right) || (!isSelected && e.Key == Key.Left)"  is complex.
Complex Conditional,System.Windows.Controls,AccordionItem,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\AccordionItem.cs,OnKeyDown,The conditional expression  "(isSelected && e.Key == Key.Left) || (!isSelected && e.Key == Key.Right)"  is complex.
Complex Conditional,System.Windows.Controls.Primitives,ExpandableContentControl,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\ExpandableContentControl.cs,OnRevealModePropertyChanged,The conditional expression  "value != ExpandDirection.Down &&                  value != ExpandDirection.Left &&                  value != ExpandDirection.Right &&                  value != ExpandDirection.Up"  is complex.
Missing Default,System.Windows.Controls,Accordion,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\Accordion.cs,OnItemsChanged,The following switch statement is missing a default case: switch (e.Action)              {                  case NotifyCollectionChangedAction.Add:                      try                      {                          _isIgnoringSelectedIndicesChanges = true;                          for (int i = 0; i < SelectedIndices.Count; i++)                          {                              if (SelectedIndices[i] >=                                  e.NewStartingIndex)                              {                                  // add a value of one                                  SelectedIndices[i] = SelectedIndices[i] + 1;                              }                          }                      }                      finally                      {                          _isIgnoringSelectedIndicesChanges = false;                      }                        if (SelectedIndex >= e.NewStartingIndex && SelectedIndex > -1)                      {                          SelectedIndex++;                      }                        // now add the item' will also add indice at correct position.                      if (SelectedItem == null && IsMinimumOneSelected)                      {                          if (!SelectedItems.OfType<object>().Contains(e.NewItems[0]))                          {                              SelectedItems.Add(e.NewItems[0]);                          }                          SelectedItem = e.NewItems[0];                      }                      break;                  case NotifyCollectionChangedAction.Reset:                      {                          _isIgnoringSelectedIndicesChanges = true;                          _isIgnoringSelectedItemsChanges = true;                          try                          {                              // Items has been cleared.                              // so clear selecteditems as well                              SelectedItems.Clear();                              SelectedIndices.Clear();                              SelectedItem = null;                              SelectedIndex = -1;                          }                          finally                          {                              _isIgnoringSelectedIndicesChanges = false;                              _isIgnoringSelectedItemsChanges = false;                          }                            // we receive this action when an itemssource is set                          InitializeNewItemsSource();                      }                  break;                  case NotifyCollectionChangedAction.Remove:                      {                          int index = e.OldStartingIndex;                          object item = e.OldItems[0];                            try                          {                              _isIgnoringSelectedIndicesChanges = true;                                if (SelectedIndices.Contains(index))                              {                                  SelectedIndices.Remove(index);                              }                              for (int i = 0; i < SelectedIndices.Count; i++)                              {                                  if (SelectedIndices[i] > index)                                  {                                      // lower the value by one                                      SelectedIndices[i] = SelectedIndices[i] - 1;                                  }                              }                          }                          finally                          {                              _isIgnoringSelectedIndicesChanges = false;                          }                            try                          {                              _isIgnoringSelectedItemsChanges = true;                                if (SelectedItems.Contains(item))                              {                                  // check that there are no indices pointing to similar                                  // items that are still in the collection                                  if (SelectedIndices.Count(i => i < Items.Count && Items[i].Equals(item)) == 0)                                  {                                      SelectedItems.Remove(item);                                  }                              }                          }                          finally                          {                              _isIgnoringSelectedItemsChanges = false;                          }                            if (SelectedIndex == index)                          {                              // that item is no longer in the Items collection                              // so the index is incorrect as well                              SelectedIndex = -1;                          }                          if (SelectedIndex > e.OldStartingIndex && SelectedIndex > -1)                          {                              SelectedIndex -= 1;                          }                      }                      break;              }
Missing Default,System.Windows.Controls,Accordion,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\Accordion.cs,SetPanelOrientation,The following switch statement is missing a default case: switch (ExpandDirection)                  {                      case ExpandDirection.Down:                      case ExpandDirection.Up:                          panel.HorizontalAlignment = HorizontalAlignment.Stretch;                          panel.VerticalAlignment = ExpandDirection == ExpandDirection.Down ? VerticalAlignment.Top : VerticalAlignment.Bottom;                          panel.Orientation = Orientation.Vertical;                          break;                      case ExpandDirection.Left:                      case ExpandDirection.Right:                          panel.VerticalAlignment = VerticalAlignment.Stretch;                          panel.HorizontalAlignment = ExpandDirection == ExpandDirection.Left ? HorizontalAlignment.Right : HorizontalAlignment.Left;                          panel.Orientation = Orientation.Horizontal;                          break;                  }
Missing Default,System.Windows.Controls,AccordionItem,C:\repos\CoEST_TraceLab\Main\external\WPFToolkit\Source\Layout\Accordion\System\Windows\Controls\AccordionItem.cs,OnKeyDown,The following switch statement is missing a default case: switch (ExpandDirection)              {                  case ExpandDirection.Down:                      if ((isSelected && e.Key == Key.Up) || (!isSelected && e.Key == Key.Down))                      {                          IsSelected = !isSelected;                      }                      break;                  case ExpandDirection.Up:                      if ((isSelected && e.Key == Key.Down) || (!isSelected && e.Key == Key.Up))                      {                          IsSelected = !isSelected;                      }                      break;                  case ExpandDirection.Left:                      if ((isSelected && e.Key == Key.Right) || (!isSelected && e.Key == Key.Left))                      {                          IsSelected = !isSelected;                      }                      break;                  case ExpandDirection.Right:                      if ((isSelected && e.Key == Key.Left) || (!isSelected && e.Key == Key.Right))                      {                          IsSelected = !isSelected;                      }                      break;              }
