Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,GraphSharp.Controls,FadeTransition,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\Transitions\FadeTransition.cs,Run,The method has 6 parameters.
Long Parameter List,GraphSharp.Controls,IAnimation,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\IAnimation.cs,Animate,The method has 5 parameters.
Long Parameter List,GraphSharp.Controls,VertexControl,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\VertexControl.cs,ComputeProperty,The method has 5 parameters.
Long Parameter List,GraphSharp.Controls.Animations,SimpleMoveAnimation,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\Animations\SimpleMoveAnimation.cs,Animate,The method has 9 parameters.
Long Statement,GraphSharp.Controls,GraphLayout,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,OverlapRemovalAlgorithmType_PropertyChanged,The length of the statement  "	gl.OverlapRemovalParameters = gl.OverlapRemovalAlgorithmFactory.CreateParameters (newAlgoType' gl.OverlapRemovalParameters); " is 124.
Long Statement,GraphSharp.Controls,GraphLayout,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,HighlightAlgorithmType_PropertyChanged,The length of the statement  "	gl.HighlightAlgorithm = gl.HighlightAlgorithmFactory.CreateAlgorithm (newAlgoType' gl.CreateHighlightContext ()' gl' parameters); " is 129.
Long Statement,GraphSharp.Converters,CoordinatesToPointConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\CoordinatesToPointConverter.cs,Convert,The length of the statement  "	Debug.Assert (values != null && values.Length == 2' "CoordinatesToPointConverter.Convert should get 2 values as input: X and Y coordinates"); " is 141.
Long Statement,GraphSharp.Converters,EdgeRouteToPathConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The length of the statement  "		Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9)."); " is 194.
Long Statement,GraphSharp.Converters,EdgeRouteToPathConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The length of the statement  "		Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos)); " is 128.
Long Statement,GraphSharp.Converters,EdgeRouteToPathConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The length of the statement  "		Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos)); " is 154.
Long Statement,GraphSharp.Converters,EdgeRouteToPathDataConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The length of the statement  "		Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9)."); " is 194.
Long Statement,GraphSharp.Converters,EdgeRouteToPathDataConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The length of the statement  "		Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos)); " is 128.
Long Statement,GraphSharp.Converters,EdgeRouteToPathDataConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The length of the statement  "		Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos)); " is 154.
Empty Catch Block,GraphSharp.Controls,GraphLayout,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,HighlightTriggerEventHandler,The method has an empty catch block.
Magic Number,GraphSharp.Controls,CompoundVertexControl,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\CompoundVertexControl.cs,OnPositionChanged,The following statement contains a magic number: if (compoundVertexControl == args.OriginalSource) {  	//move the children with the same amount  	foreach (var childVertexControl in compoundVertexControl.Vertices) {  		GraphCanvas.SetX (childVertexControl' GraphCanvas.GetX (childVertexControl) + args.XChange);  		GraphCanvas.SetY (childVertexControl' GraphCanvas.GetY (childVertexControl) + args.YChange);  	}  }  else {  	//we are moving the parent or one of it's child  	var childVertexControl = args.OriginalSource as VertexControl;  	if (childVertexControl == null)  		return;  	if (compoundVertexControl.Vertices.Contains (childVertexControl)) {  		//update the position of all child vertices  		foreach (var cvc in compoundVertexControl.Vertices) {  			if (cvc == childVertexControl)  				continue;  			var childCenterPos = new Point (cvc.ActualWidth / 2' cvc.ActualHeight / 2);  			var translatedChildCenterPos = cvc.TranslatePoint (childCenterPos' cvc.RootCanvas);  			GraphCanvas.SetX (cvc' translatedChildCenterPos.X - cvc.RootCanvas.Translation.X);  			GraphCanvas.SetY (cvc' translatedChildCenterPos.Y - cvc.RootCanvas.Translation.Y);  		}  	}  }  
Magic Number,GraphSharp.Controls,CompoundVertexControl,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\CompoundVertexControl.cs,OnPositionChanged,The following statement contains a magic number: if (compoundVertexControl == args.OriginalSource) {  	//move the children with the same amount  	foreach (var childVertexControl in compoundVertexControl.Vertices) {  		GraphCanvas.SetX (childVertexControl' GraphCanvas.GetX (childVertexControl) + args.XChange);  		GraphCanvas.SetY (childVertexControl' GraphCanvas.GetY (childVertexControl) + args.YChange);  	}  }  else {  	//we are moving the parent or one of it's child  	var childVertexControl = args.OriginalSource as VertexControl;  	if (childVertexControl == null)  		return;  	if (compoundVertexControl.Vertices.Contains (childVertexControl)) {  		//update the position of all child vertices  		foreach (var cvc in compoundVertexControl.Vertices) {  			if (cvc == childVertexControl)  				continue;  			var childCenterPos = new Point (cvc.ActualWidth / 2' cvc.ActualHeight / 2);  			var translatedChildCenterPos = cvc.TranslatePoint (childCenterPos' cvc.RootCanvas);  			GraphCanvas.SetX (cvc' translatedChildCenterPos.X - cvc.RootCanvas.Translation.X);  			GraphCanvas.SetY (cvc' translatedChildCenterPos.Y - cvc.RootCanvas.Translation.Y);  		}  	}  }  
Magic Number,GraphSharp.Controls,CompoundVertexControl,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\CompoundVertexControl.cs,OnPositionChanged,The following statement contains a magic number: if (compoundVertexControl.Vertices.Contains (childVertexControl)) {  	//update the position of all child vertices  	foreach (var cvc in compoundVertexControl.Vertices) {  		if (cvc == childVertexControl)  			continue;  		var childCenterPos = new Point (cvc.ActualWidth / 2' cvc.ActualHeight / 2);  		var translatedChildCenterPos = cvc.TranslatePoint (childCenterPos' cvc.RootCanvas);  		GraphCanvas.SetX (cvc' translatedChildCenterPos.X - cvc.RootCanvas.Translation.X);  		GraphCanvas.SetY (cvc' translatedChildCenterPos.Y - cvc.RootCanvas.Translation.Y);  	}  }  
Magic Number,GraphSharp.Controls,CompoundVertexControl,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\CompoundVertexControl.cs,OnPositionChanged,The following statement contains a magic number: if (compoundVertexControl.Vertices.Contains (childVertexControl)) {  	//update the position of all child vertices  	foreach (var cvc in compoundVertexControl.Vertices) {  		if (cvc == childVertexControl)  			continue;  		var childCenterPos = new Point (cvc.ActualWidth / 2' cvc.ActualHeight / 2);  		var translatedChildCenterPos = cvc.TranslatePoint (childCenterPos' cvc.RootCanvas);  		GraphCanvas.SetX (cvc' translatedChildCenterPos.X - cvc.RootCanvas.Translation.X);  		GraphCanvas.SetY (cvc' translatedChildCenterPos.Y - cvc.RootCanvas.Translation.Y);  	}  }  
Magic Number,GraphSharp.Controls,CompoundVertexControl,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\CompoundVertexControl.cs,OnPositionChanged,The following statement contains a magic number: foreach (var cvc in compoundVertexControl.Vertices) {  	if (cvc == childVertexControl)  		continue;  	var childCenterPos = new Point (cvc.ActualWidth / 2' cvc.ActualHeight / 2);  	var translatedChildCenterPos = cvc.TranslatePoint (childCenterPos' cvc.RootCanvas);  	GraphCanvas.SetX (cvc' translatedChildCenterPos.X - cvc.RootCanvas.Translation.X);  	GraphCanvas.SetY (cvc' translatedChildCenterPos.Y - cvc.RootCanvas.Translation.Y);  }  
Magic Number,GraphSharp.Controls,CompoundVertexControl,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\CompoundVertexControl.cs,OnPositionChanged,The following statement contains a magic number: foreach (var cvc in compoundVertexControl.Vertices) {  	if (cvc == childVertexControl)  		continue;  	var childCenterPos = new Point (cvc.ActualWidth / 2' cvc.ActualHeight / 2);  	var translatedChildCenterPos = cvc.TranslatePoint (childCenterPos' cvc.RootCanvas);  	GraphCanvas.SetX (cvc' translatedChildCenterPos.X - cvc.RootCanvas.Translation.X);  	GraphCanvas.SetY (cvc' translatedChildCenterPos.Y - cvc.RootCanvas.Translation.Y);  }  
Magic Number,GraphSharp.Controls,FadeTransition,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\Transitions\FadeTransition.cs,Run,The following statement contains a magic number: fadeAnimation.BeginTime = TimeSpan.FromMilliseconds (duration.TotalMilliseconds * (rounds - 1) * 2);  
Magic Number,GraphSharp.Controls,VertexControl,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\VertexControl.cs,ComputeProperty,The following statement contains a magic number: if (control != null) {  	newValue = newValue - (dimension / 2);  	if (0.0001 < Math.Abs (newValue - (double)control.GetValue (prop))) {  		control.SetValue (prop' newValue);  	}  }  
Magic Number,GraphSharp.Controls,VertexControl,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\VertexControl.cs,ComputeProperty,The following statement contains a magic number: if (control != null) {  	newValue = newValue - (dimension / 2);  	if (0.0001 < Math.Abs (newValue - (double)control.GetValue (prop))) {  		control.SetValue (prop' newValue);  	}  }  
Magic Number,GraphSharp.Controls,VertexControl,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\VertexControl.cs,ComputeProperty,The following statement contains a magic number: newValue = newValue - (dimension / 2);  
Magic Number,GraphSharp.Controls,VertexControl,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\VertexControl.cs,ComputeProperty,The following statement contains a magic number: if (0.0001 < Math.Abs (newValue - (double)control.GetValue (prop))) {  	control.SetValue (prop' newValue);  }  
Magic Number,GraphSharp.Converters,CoordinatesToPointConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\CoordinatesToPointConverter.cs,Convert,The following statement contains a magic number: Debug.Assert (values != null && values.Length == 2' "CoordinatesToPointConverter.Convert should get 2 values as input: X and Y coordinates");  
Magic Number,GraphSharp.Converters,EdgeRouteToPathConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	pfc.Add (new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true));  }  catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	pfc.Add (new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true));  }  catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	pfc.Add (new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true));  }  catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	pfc.Add (new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true));  }  catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	pfc.Add (new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true));  }  catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	pfc.Add (new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true));  }  catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	pfc.Add (new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true));  }  catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	pfc.Add (new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true));  }  catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	pfc.Add (new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true));  }  catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	pfc.Add (new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true));  }  catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	pfc.Add (new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true));  }  catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	pfc.Add (new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true));  }  catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	pfc.Add (new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true));  }  catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	pfc.Add (new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true));  }  catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	pfc.Add (new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true));  }  catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	pfc.Add (new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true));  }  catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	pfc.Add (new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true));  }  catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  
Magic Number,GraphSharp.Converters,EdgeRouteToPathConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: v = v / v.Length * 6;  
Magic Number,GraphSharp.Converters,EdgeRouteToPathDataConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	var arrow = new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true);  	pfc.Add (arrow);  }  catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathDataConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	var arrow = new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true);  	pfc.Add (arrow);  }  catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathDataConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	var arrow = new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true);  	pfc.Add (arrow);  }  catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathDataConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	var arrow = new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true);  	pfc.Add (arrow);  }  catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathDataConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	var arrow = new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true);  	pfc.Add (arrow);  }  catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathDataConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	var arrow = new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true);  	pfc.Add (arrow);  }  catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathDataConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	var arrow = new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true);  	pfc.Add (arrow);  }  catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathDataConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	var arrow = new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true);  	pfc.Add (arrow);  }  catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathDataConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	var arrow = new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true);  	pfc.Add (arrow);  }  catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathDataConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	var arrow = new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true);  	pfc.Add (arrow);  }  catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathDataConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	var arrow = new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true);  	pfc.Add (arrow);  }  catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathDataConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	var arrow = new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true);  	pfc.Add (arrow);  }  catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathDataConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	var arrow = new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true);  	pfc.Add (arrow);  }  catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathDataConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	var arrow = new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true);  	pfc.Add (arrow);  }  catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathDataConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	var arrow = new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true);  	pfc.Add (arrow);  }  catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathDataConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	var arrow = new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true);  	pfc.Add (arrow);  }  catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathDataConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	var arrow = new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true);  	pfc.Add (arrow);  }  catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathDataConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The following statement contains a magic number: Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  
Magic Number,GraphSharp.Converters,EdgeRouteToPathDataConverter,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The following statement contains a magic number: v = v / v.Length * 6;  
Magic Number,GraphSharp.Converters,GraphConverterHelper,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\GraphConverterHelper.cs,CalculateAttachPoint,The following statement contains a magic number: sides [0] = (s.X - sourceSize.Width / 2.0 - t.X) / (s.X - t.X);  
Magic Number,GraphSharp.Converters,GraphConverterHelper,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\GraphConverterHelper.cs,CalculateAttachPoint,The following statement contains a magic number: sides [1] = (s.Y - sourceSize.Height / 2.0 - t.Y) / (s.Y - t.Y);  
Magic Number,GraphSharp.Converters,GraphConverterHelper,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\GraphConverterHelper.cs,CalculateAttachPoint,The following statement contains a magic number: sides [2] = (s.X + sourceSize.Width / 2.0 - t.X) / (s.X - t.X);  
Magic Number,GraphSharp.Converters,GraphConverterHelper,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\GraphConverterHelper.cs,CalculateAttachPoint,The following statement contains a magic number: sides [2] = (s.X + sourceSize.Width / 2.0 - t.X) / (s.X - t.X);  
Magic Number,GraphSharp.Converters,GraphConverterHelper,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\GraphConverterHelper.cs,CalculateAttachPoint,The following statement contains a magic number: sides [3] = (s.Y + sourceSize.Height / 2.0 - t.Y) / (s.Y - t.Y);  
Magic Number,GraphSharp.Converters,GraphConverterHelper,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\GraphConverterHelper.cs,CalculateAttachPoint,The following statement contains a magic number: sides [3] = (s.Y + sourceSize.Height / 2.0 - t.Y) / (s.Y - t.Y);  
Magic Number,GraphSharp.Converters,GraphConverterHelper,C:\repos\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\GraphConverterHelper.cs,CalculateAttachPoint,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	if (sides [i] <= 1)  		fi = Math.Max (fi' sides [i]);  }  
