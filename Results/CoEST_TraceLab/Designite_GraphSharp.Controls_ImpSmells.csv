Implementation smell,Namespace,Class,File,Method,Description
Complex Method,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,ChangeState,Cyclomatic complexity of the method is 8
Complex Method,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,RecreateGraphElements,Cyclomatic complexity of the method is 14
Long Parameter List,GraphSharp.Controls,IAnimation,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\IAnimation.cs,Animate,The method has 5 parameters.
Long Parameter List,GraphSharp.Controls,VertexControl,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\VertexControl.cs,ComputeProperty,The method has 5 parameters.
Long Parameter List,GraphSharp.Controls.Animations,SimpleMoveAnimation,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\Animations\SimpleMoveAnimation.cs,Animate,The method has 5 parameters.
Long Statement,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,OverlapRemovalAlgorithmType_PropertyChanged,The length of the statement  "	gl.OverlapRemovalParameters = gl.OverlapRemovalAlgorithmFactory.CreateParameters (newAlgoType' gl.OverlapRemovalParameters); " is 124.
Long Statement,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,HighlightAlgorithmType_PropertyChanged,The length of the statement  "	gl.HighlightAlgorithm = gl.HighlightAlgorithmFactory.CreateAlgorithm (newAlgoType' gl.CreateHighlightContext ()' gl' parameters); " is 129.
Long Statement,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,CreateLayoutContext,The length of the statement  "		return new CompoundLayoutContext<TVertex' TEdge' TGraph> (Graph' positions' sizes' ActualLayoutMode' borders' layoutTypes); " is 123.
Long Statement,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,CreateOverlapRemovalContext,The length of the statement  "		rectangles [vertex] = new Rect (position.X - size.Width * (float)0.5' position.Y - size.Height * (float)0.5' size.Width' size.Height); " is 134.
Long Statement,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,OnLayoutIterationFinished,The length of the statement  "	var state = new LayoutState<TVertex' TEdge> (vertexPositions' overlapRemovedPositions' edgeRoutingInfos' stopWatch.Elapsed' _layoutStates.Count' (message ?? string.Empty)); " is 172.
Long Statement,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,OverlapRemoval,The length of the statement  "	if (OverlapRemovalConstraint == AlgorithmConstraints.Skip || (OverlapRemovalConstraint == AlgorithmConstraints.Automatic && (!LayoutAlgorithmFactory.NeedOverlapRemoval (LayoutAlgorithmType) || !isValidAlgorithm)) || (OverlapRemovalConstraint == AlgorithmConstraints.Must && !isValidAlgorithm)) " is 293.
Long Statement,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,OverlapRemoval,The length of the statement  "	OverlapRemovalParameters = OverlapRemovalAlgorithmFactory.CreateParameters (OverlapRemovalAlgorithmType' OverlapRemovalParameters); " is 131.
Long Statement,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,OverlapRemoval,The length of the statement  "	OverlapRemovalAlgorithm = OverlapRemovalAlgorithmFactory.CreateAlgorithm (OverlapRemovalAlgorithmType' context' OverlapRemovalParameters); " is 138.
Long Statement,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,OverlapRemoval,The length of the statement  "			result [res.Key] = new Point ((res.Value.Left + res.Value.Size.Width * 0.5)' (res.Value.Top + res.Value.Size.Height * 0.5)); " is 124.
Long Statement,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,RouteEdges,The length of the statement  "		if (!LayoutAlgorithmFactory.NeedEdgeRouting (LayoutAlgorithmType) && LayoutAlgorithm is IEdgeRoutingAlgorithm<TVertex' TEdge' TGraph>) " is 134.
Long Statement,GraphSharp.Converters,CoordinatesToPointConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\CoordinatesToPointConverter.cs,Convert,The length of the statement  "	Debug.Assert (values != null && values.Length == 2' "CoordinatesToPointConverter.Convert should get 2 values as input: X and Y coordinates"); " is 141.
Long Statement,GraphSharp.Converters,EdgeRouteToPathConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The length of the statement  "		Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9)."); " is 194.
Long Statement,GraphSharp.Converters,EdgeRouteToPathConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The length of the statement  "		Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos)); " is 128.
Long Statement,GraphSharp.Converters,EdgeRouteToPathConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The length of the statement  "		Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos)); " is 154.
Long Statement,GraphSharp.Converters,EdgeRouteToPathDataConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The length of the statement  "		Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9)."); " is 194.
Long Statement,GraphSharp.Converters,EdgeRouteToPathDataConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The length of the statement  "		Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos)); " is 128.
Long Statement,GraphSharp.Converters,EdgeRouteToPathDataConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The length of the statement  "		Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos)); " is 154.
Complex Conditional,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,OverlapRemoval,The conditional expression  "OverlapRemovalConstraint == AlgorithmConstraints.Skip || (OverlapRemovalConstraint == AlgorithmConstraints.Automatic && (!LayoutAlgorithmFactory.NeedOverlapRemoval (LayoutAlgorithmType) || !isValidAlgorithm)) || (OverlapRemovalConstraint == AlgorithmConstraints.Must && !isValidAlgorithm)"  is complex.
Empty Catch Block,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,HighlightTriggerEventHandler,The method has an empty catch block.
Empty Catch Block,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,RecreateGraphElements,The method has an empty catch block.
Magic Number,GraphSharp.Controls,CompoundVertexControl,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\CompoundVertexControl.cs,OnPositionChanged,The following statement contains a magic number: if (compoundVertexControl == args.OriginalSource) {  	//move the children with the same amount  	foreach (var childVertexControl in compoundVertexControl.Vertices) {  		GraphCanvas.SetX (childVertexControl' GraphCanvas.GetX (childVertexControl) + args.XChange);  		GraphCanvas.SetY (childVertexControl' GraphCanvas.GetY (childVertexControl) + args.YChange);  	}  } else {  	//we are moving the parent or one of it's child  	var childVertexControl = args.OriginalSource as VertexControl;  	if (childVertexControl == null)  		return;  	if (compoundVertexControl.Vertices.Contains (childVertexControl)) {  		//update the position of all child vertices  		foreach (var cvc in compoundVertexControl.Vertices) {  			if (cvc == childVertexControl)  				continue;  			var childCenterPos = new Point (cvc.ActualWidth / 2' cvc.ActualHeight / 2);  			var translatedChildCenterPos = cvc.TranslatePoint (childCenterPos' cvc.RootCanvas);  			GraphCanvas.SetX (cvc' translatedChildCenterPos.X - cvc.RootCanvas.Translation.X);  			GraphCanvas.SetY (cvc' translatedChildCenterPos.Y - cvc.RootCanvas.Translation.Y);  		}  	}  }  
Magic Number,GraphSharp.Controls,CompoundVertexControl,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\CompoundVertexControl.cs,OnPositionChanged,The following statement contains a magic number: if (compoundVertexControl == args.OriginalSource) {  	//move the children with the same amount  	foreach (var childVertexControl in compoundVertexControl.Vertices) {  		GraphCanvas.SetX (childVertexControl' GraphCanvas.GetX (childVertexControl) + args.XChange);  		GraphCanvas.SetY (childVertexControl' GraphCanvas.GetY (childVertexControl) + args.YChange);  	}  } else {  	//we are moving the parent or one of it's child  	var childVertexControl = args.OriginalSource as VertexControl;  	if (childVertexControl == null)  		return;  	if (compoundVertexControl.Vertices.Contains (childVertexControl)) {  		//update the position of all child vertices  		foreach (var cvc in compoundVertexControl.Vertices) {  			if (cvc == childVertexControl)  				continue;  			var childCenterPos = new Point (cvc.ActualWidth / 2' cvc.ActualHeight / 2);  			var translatedChildCenterPos = cvc.TranslatePoint (childCenterPos' cvc.RootCanvas);  			GraphCanvas.SetX (cvc' translatedChildCenterPos.X - cvc.RootCanvas.Translation.X);  			GraphCanvas.SetY (cvc' translatedChildCenterPos.Y - cvc.RootCanvas.Translation.Y);  		}  	}  }  
Magic Number,GraphSharp.Controls,CompoundVertexControl,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\CompoundVertexControl.cs,OnPositionChanged,The following statement contains a magic number: if (compoundVertexControl.Vertices.Contains (childVertexControl)) {  	//update the position of all child vertices  	foreach (var cvc in compoundVertexControl.Vertices) {  		if (cvc == childVertexControl)  			continue;  		var childCenterPos = new Point (cvc.ActualWidth / 2' cvc.ActualHeight / 2);  		var translatedChildCenterPos = cvc.TranslatePoint (childCenterPos' cvc.RootCanvas);  		GraphCanvas.SetX (cvc' translatedChildCenterPos.X - cvc.RootCanvas.Translation.X);  		GraphCanvas.SetY (cvc' translatedChildCenterPos.Y - cvc.RootCanvas.Translation.Y);  	}  }  
Magic Number,GraphSharp.Controls,CompoundVertexControl,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\CompoundVertexControl.cs,OnPositionChanged,The following statement contains a magic number: if (compoundVertexControl.Vertices.Contains (childVertexControl)) {  	//update the position of all child vertices  	foreach (var cvc in compoundVertexControl.Vertices) {  		if (cvc == childVertexControl)  			continue;  		var childCenterPos = new Point (cvc.ActualWidth / 2' cvc.ActualHeight / 2);  		var translatedChildCenterPos = cvc.TranslatePoint (childCenterPos' cvc.RootCanvas);  		GraphCanvas.SetX (cvc' translatedChildCenterPos.X - cvc.RootCanvas.Translation.X);  		GraphCanvas.SetY (cvc' translatedChildCenterPos.Y - cvc.RootCanvas.Translation.Y);  	}  }  
Magic Number,GraphSharp.Controls,CompoundVertexControl,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\CompoundVertexControl.cs,OnPositionChanged,The following statement contains a magic number: foreach (var cvc in compoundVertexControl.Vertices) {  	if (cvc == childVertexControl)  		continue;  	var childCenterPos = new Point (cvc.ActualWidth / 2' cvc.ActualHeight / 2);  	var translatedChildCenterPos = cvc.TranslatePoint (childCenterPos' cvc.RootCanvas);  	GraphCanvas.SetX (cvc' translatedChildCenterPos.X - cvc.RootCanvas.Translation.X);  	GraphCanvas.SetY (cvc' translatedChildCenterPos.Y - cvc.RootCanvas.Translation.Y);  }  
Magic Number,GraphSharp.Controls,CompoundVertexControl,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\CompoundVertexControl.cs,OnPositionChanged,The following statement contains a magic number: foreach (var cvc in compoundVertexControl.Vertices) {  	if (cvc == childVertexControl)  		continue;  	var childCenterPos = new Point (cvc.ActualWidth / 2' cvc.ActualHeight / 2);  	var translatedChildCenterPos = cvc.TranslatePoint (childCenterPos' cvc.RootCanvas);  	GraphCanvas.SetX (cvc' translatedChildCenterPos.X - cvc.RootCanvas.Translation.X);  	GraphCanvas.SetY (cvc' translatedChildCenterPos.Y - cvc.RootCanvas.Translation.Y);  }  
Magic Number,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,GraphLayout,The following statement contains a magic number: if (System.ComponentModel.DesignerProperties.GetIsInDesignMode (this)) {  	var g = new BidirectionalGraph<object' IEdge<object>> ();  	var vertices = new object[] {  		"S"'  		"A"'  		"M"'  		"P"'  		"L"'  		"E"  	};  	var edges = new IEdge<object>[] {  		new Edge<object> (vertices [0]' vertices [1])'  		new Edge<object> (vertices [1]' vertices [2])'  		new Edge<object> (vertices [1]' vertices [3])'  		new Edge<object> (vertices [3]' vertices [4])'  		new Edge<object> (vertices [0]' vertices [4])'  		new Edge<object> (vertices [4]' vertices [5])  	};  	g.AddVerticesAndEdgeRange (edges);  	OverlapRemovalAlgorithmType = "FSA";  	LayoutAlgorithmType = "FR";  	Graph = g;  }  
Magic Number,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,GraphLayout,The following statement contains a magic number: if (System.ComponentModel.DesignerProperties.GetIsInDesignMode (this)) {  	var g = new BidirectionalGraph<object' IEdge<object>> ();  	var vertices = new object[] {  		"S"'  		"A"'  		"M"'  		"P"'  		"L"'  		"E"  	};  	var edges = new IEdge<object>[] {  		new Edge<object> (vertices [0]' vertices [1])'  		new Edge<object> (vertices [1]' vertices [2])'  		new Edge<object> (vertices [1]' vertices [3])'  		new Edge<object> (vertices [3]' vertices [4])'  		new Edge<object> (vertices [0]' vertices [4])'  		new Edge<object> (vertices [4]' vertices [5])  	};  	g.AddVerticesAndEdgeRange (edges);  	OverlapRemovalAlgorithmType = "FSA";  	LayoutAlgorithmType = "FR";  	Graph = g;  }  
Magic Number,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,GraphLayout,The following statement contains a magic number: if (System.ComponentModel.DesignerProperties.GetIsInDesignMode (this)) {  	var g = new BidirectionalGraph<object' IEdge<object>> ();  	var vertices = new object[] {  		"S"'  		"A"'  		"M"'  		"P"'  		"L"'  		"E"  	};  	var edges = new IEdge<object>[] {  		new Edge<object> (vertices [0]' vertices [1])'  		new Edge<object> (vertices [1]' vertices [2])'  		new Edge<object> (vertices [1]' vertices [3])'  		new Edge<object> (vertices [3]' vertices [4])'  		new Edge<object> (vertices [0]' vertices [4])'  		new Edge<object> (vertices [4]' vertices [5])  	};  	g.AddVerticesAndEdgeRange (edges);  	OverlapRemovalAlgorithmType = "FSA";  	LayoutAlgorithmType = "FR";  	Graph = g;  }  
Magic Number,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,GraphLayout,The following statement contains a magic number: if (System.ComponentModel.DesignerProperties.GetIsInDesignMode (this)) {  	var g = new BidirectionalGraph<object' IEdge<object>> ();  	var vertices = new object[] {  		"S"'  		"A"'  		"M"'  		"P"'  		"L"'  		"E"  	};  	var edges = new IEdge<object>[] {  		new Edge<object> (vertices [0]' vertices [1])'  		new Edge<object> (vertices [1]' vertices [2])'  		new Edge<object> (vertices [1]' vertices [3])'  		new Edge<object> (vertices [3]' vertices [4])'  		new Edge<object> (vertices [0]' vertices [4])'  		new Edge<object> (vertices [4]' vertices [5])  	};  	g.AddVerticesAndEdgeRange (edges);  	OverlapRemovalAlgorithmType = "FSA";  	LayoutAlgorithmType = "FR";  	Graph = g;  }  
Magic Number,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,GraphLayout,The following statement contains a magic number: if (System.ComponentModel.DesignerProperties.GetIsInDesignMode (this)) {  	var g = new BidirectionalGraph<object' IEdge<object>> ();  	var vertices = new object[] {  		"S"'  		"A"'  		"M"'  		"P"'  		"L"'  		"E"  	};  	var edges = new IEdge<object>[] {  		new Edge<object> (vertices [0]' vertices [1])'  		new Edge<object> (vertices [1]' vertices [2])'  		new Edge<object> (vertices [1]' vertices [3])'  		new Edge<object> (vertices [3]' vertices [4])'  		new Edge<object> (vertices [0]' vertices [4])'  		new Edge<object> (vertices [4]' vertices [5])  	};  	g.AddVerticesAndEdgeRange (edges);  	OverlapRemovalAlgorithmType = "FSA";  	LayoutAlgorithmType = "FR";  	Graph = g;  }  
Magic Number,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,GraphLayout,The following statement contains a magic number: if (System.ComponentModel.DesignerProperties.GetIsInDesignMode (this)) {  	var g = new BidirectionalGraph<object' IEdge<object>> ();  	var vertices = new object[] {  		"S"'  		"A"'  		"M"'  		"P"'  		"L"'  		"E"  	};  	var edges = new IEdge<object>[] {  		new Edge<object> (vertices [0]' vertices [1])'  		new Edge<object> (vertices [1]' vertices [2])'  		new Edge<object> (vertices [1]' vertices [3])'  		new Edge<object> (vertices [3]' vertices [4])'  		new Edge<object> (vertices [0]' vertices [4])'  		new Edge<object> (vertices [4]' vertices [5])  	};  	g.AddVerticesAndEdgeRange (edges);  	OverlapRemovalAlgorithmType = "FSA";  	LayoutAlgorithmType = "FR";  	Graph = g;  }  
Magic Number,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,GraphLayout,The following statement contains a magic number: if (System.ComponentModel.DesignerProperties.GetIsInDesignMode (this)) {  	var g = new BidirectionalGraph<object' IEdge<object>> ();  	var vertices = new object[] {  		"S"'  		"A"'  		"M"'  		"P"'  		"L"'  		"E"  	};  	var edges = new IEdge<object>[] {  		new Edge<object> (vertices [0]' vertices [1])'  		new Edge<object> (vertices [1]' vertices [2])'  		new Edge<object> (vertices [1]' vertices [3])'  		new Edge<object> (vertices [3]' vertices [4])'  		new Edge<object> (vertices [0]' vertices [4])'  		new Edge<object> (vertices [4]' vertices [5])  	};  	g.AddVerticesAndEdgeRange (edges);  	OverlapRemovalAlgorithmType = "FSA";  	LayoutAlgorithmType = "FR";  	Graph = g;  }  
Magic Number,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,CreateOverlapRemovalContext,The following statement contains a magic number: foreach (var vertex in Graph.Vertices) {  	Point position;  	Size size;  	if (!positions.TryGetValue (vertex' out position) || !sizes.TryGetValue (vertex' out size))  		continue;  	rectangles [vertex] = new Rect (position.X - size.Width * (float)0.5' position.Y - size.Height * (float)0.5' size.Width' size.Height);  }  
Magic Number,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,CreateOverlapRemovalContext,The following statement contains a magic number: foreach (var vertex in Graph.Vertices) {  	Point position;  	Size size;  	if (!positions.TryGetValue (vertex' out position) || !sizes.TryGetValue (vertex' out size))  		continue;  	rectangles [vertex] = new Rect (position.X - size.Width * (float)0.5' position.Y - size.Height * (float)0.5' size.Width' size.Height);  }  
Magic Number,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,CreateOverlapRemovalContext,The following statement contains a magic number: rectangles [vertex] = new Rect (position.X - size.Width * (float)0.5' position.Y - size.Height * (float)0.5' size.Width' size.Height);  
Magic Number,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,CreateOverlapRemovalContext,The following statement contains a magic number: rectangles [vertex] = new Rect (position.X - size.Width * (float)0.5' position.Y - size.Height * (float)0.5' size.Width' size.Height);  
Magic Number,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,GetLatestVertexPositions,The following statement contains a magic number: if (ActualLayoutMode == Algorithms.Layout.LayoutMode.Simple) {  	foreach (var vc in _vertexControls) {  		var x = GetX (vc.Value);  		var y = GetY (vc.Value);  		vertexPositions [vc.Key] = new Point (double.IsNaN (x) ? 0.0 : x' double.IsNaN (y) ? 0.0 : y);  	}  } else {  	Point topLeft = new Point (0' 0);  	foreach (var vc in _vertexControls) {  		Point position = vc.Value.TranslatePoint (topLeft' this);  		position.X += vc.Value.ActualWidth / 2;  		position.Y += vc.Value.ActualHeight / 2;  		vertexPositions [vc.Key] = position;  	}  }  
Magic Number,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,GetLatestVertexPositions,The following statement contains a magic number: if (ActualLayoutMode == Algorithms.Layout.LayoutMode.Simple) {  	foreach (var vc in _vertexControls) {  		var x = GetX (vc.Value);  		var y = GetY (vc.Value);  		vertexPositions [vc.Key] = new Point (double.IsNaN (x) ? 0.0 : x' double.IsNaN (y) ? 0.0 : y);  	}  } else {  	Point topLeft = new Point (0' 0);  	foreach (var vc in _vertexControls) {  		Point position = vc.Value.TranslatePoint (topLeft' this);  		position.X += vc.Value.ActualWidth / 2;  		position.Y += vc.Value.ActualHeight / 2;  		vertexPositions [vc.Key] = position;  	}  }  
Magic Number,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,GetLatestVertexPositions,The following statement contains a magic number: foreach (var vc in _vertexControls) {  	Point position = vc.Value.TranslatePoint (topLeft' this);  	position.X += vc.Value.ActualWidth / 2;  	position.Y += vc.Value.ActualHeight / 2;  	vertexPositions [vc.Key] = position;  }  
Magic Number,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,GetLatestVertexPositions,The following statement contains a magic number: foreach (var vc in _vertexControls) {  	Point position = vc.Value.TranslatePoint (topLeft' this);  	position.X += vc.Value.ActualWidth / 2;  	position.Y += vc.Value.ActualHeight / 2;  	vertexPositions [vc.Key] = position;  }  
Magic Number,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,GetLatestVertexPositions,The following statement contains a magic number: position.X += vc.Value.ActualWidth / 2;  
Magic Number,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,GetLatestVertexPositions,The following statement contains a magic number: position.Y += vc.Value.ActualHeight / 2;  
Magic Number,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,GetRelativePosition,The following statement contains a magic number: return vc.TranslatePoint (new Point (vc.ActualWidth / 2.0' vc.ActualHeight / 2.0)' relativeTo);  
Magic Number,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,GetRelativePosition,The following statement contains a magic number: return vc.TranslatePoint (new Point (vc.ActualWidth / 2.0' vc.ActualHeight / 2.0)' relativeTo);  
Magic Number,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,OnLayoutFinished,The following statement contains a magic number: LayoutStatusPercent = 100;  
Magic Number,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,OverlapRemoval,The following statement contains a magic number: if (OverlapRemovalAlgorithm != null) {  	OverlapRemovalAlgorithm.Compute ();  	var result = new Dictionary<TVertex' Point> ();  	foreach (var res in OverlapRemovalAlgorithm.Rectangles) {  		result [res.Key] = new Point ((res.Value.Left + res.Value.Size.Width * 0.5)' (res.Value.Top + res.Value.Size.Height * 0.5));  	}  	return result;  }  
Magic Number,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,OverlapRemoval,The following statement contains a magic number: if (OverlapRemovalAlgorithm != null) {  	OverlapRemovalAlgorithm.Compute ();  	var result = new Dictionary<TVertex' Point> ();  	foreach (var res in OverlapRemovalAlgorithm.Rectangles) {  		result [res.Key] = new Point ((res.Value.Left + res.Value.Size.Width * 0.5)' (res.Value.Top + res.Value.Size.Height * 0.5));  	}  	return result;  }  
Magic Number,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,OverlapRemoval,The following statement contains a magic number: foreach (var res in OverlapRemovalAlgorithm.Rectangles) {  	result [res.Key] = new Point ((res.Value.Left + res.Value.Size.Width * 0.5)' (res.Value.Top + res.Value.Size.Height * 0.5));  }  
Magic Number,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,OverlapRemoval,The following statement contains a magic number: foreach (var res in OverlapRemovalAlgorithm.Rectangles) {  	result [res.Key] = new Point ((res.Value.Left + res.Value.Size.Width * 0.5)' (res.Value.Top + res.Value.Size.Height * 0.5));  }  
Magic Number,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,OverlapRemoval,The following statement contains a magic number: result [res.Key] = new Point ((res.Value.Left + res.Value.Size.Width * 0.5)' (res.Value.Top + res.Value.Size.Height * 0.5));  
Magic Number,GraphSharp.Controls,GraphLayout,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\GraphLayout.DependencyProperties.cs,OverlapRemoval,The following statement contains a magic number: result [res.Key] = new Point ((res.Value.Left + res.Value.Size.Width * 0.5)' (res.Value.Top + res.Value.Size.Height * 0.5));  
Magic Number,GraphSharp.Controls,FadeTransition,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\Transitions\FadeTransition.cs,Run,The following statement contains a magic number: fadeAnimation.BeginTime = TimeSpan.FromMilliseconds (duration.TotalMilliseconds * (rounds - 1) * 2);  
Magic Number,GraphSharp.Controls,VertexControl,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\VertexControl.cs,ComputeProperty,The following statement contains a magic number: if (control != null) {  	newValue = newValue - (dimension / 2);  	if (0.0001 < Math.Abs (newValue - (double)control.GetValue (prop))) {  		control.SetValue (prop' newValue);  	}  }  
Magic Number,GraphSharp.Controls,VertexControl,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\VertexControl.cs,ComputeProperty,The following statement contains a magic number: if (control != null) {  	newValue = newValue - (dimension / 2);  	if (0.0001 < Math.Abs (newValue - (double)control.GetValue (prop))) {  		control.SetValue (prop' newValue);  	}  }  
Magic Number,GraphSharp.Controls,VertexControl,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\VertexControl.cs,ComputeProperty,The following statement contains a magic number: newValue = newValue - (dimension / 2);  
Magic Number,GraphSharp.Controls,VertexControl,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Controls\VertexControl.cs,ComputeProperty,The following statement contains a magic number: if (0.0001 < Math.Abs (newValue - (double)control.GetValue (prop))) {  	control.SetValue (prop' newValue);  }  
Magic Number,GraphSharp.Converters,CoordinatesToPointConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\CoordinatesToPointConverter.cs,Convert,The following statement contains a magic number: Debug.Assert (values != null && values.Length == 2' "CoordinatesToPointConverter.Convert should get 2 values as input: X and Y coordinates");  
Magic Number,GraphSharp.Converters,EdgeRouteToPathConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	pfc.Add (new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true));  } catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	pfc.Add (new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true));  } catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	pfc.Add (new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true));  } catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	pfc.Add (new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true));  } catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	pfc.Add (new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true));  } catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	pfc.Add (new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true));  } catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	pfc.Add (new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true));  } catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	pfc.Add (new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true));  } catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	pfc.Add (new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true));  } catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	pfc.Add (new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true));  } catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	pfc.Add (new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true));  } catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	pfc.Add (new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true));  } catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	pfc.Add (new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true));  } catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	pfc.Add (new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true));  } catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	pfc.Add (new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true));  } catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	pfc.Add (new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true));  } catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	pfc.Add (new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true));  } catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  
Magic Number,GraphSharp.Converters,EdgeRouteToPathConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathConverter.cs,Convert,The following statement contains a magic number: v = v / v.Length * 6;  
Magic Number,GraphSharp.Converters,EdgeRouteToPathDataConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	var arrow = new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true);  	pfc.Add (arrow);  } catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathDataConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	var arrow = new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true);  	pfc.Add (arrow);  } catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathDataConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	var arrow = new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true);  	pfc.Add (arrow);  } catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathDataConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	var arrow = new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true);  	pfc.Add (arrow);  } catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathDataConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	var arrow = new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true);  	pfc.Add (arrow);  } catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathDataConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	var arrow = new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true);  	pfc.Add (arrow);  } catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathDataConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	var arrow = new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true);  	pfc.Add (arrow);  } catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathDataConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	var arrow = new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true);  	pfc.Add (arrow);  } catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathDataConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	var arrow = new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true);  	pfc.Add (arrow);  } catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathDataConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	var arrow = new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true);  	pfc.Add (arrow);  } catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathDataConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	var arrow = new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true);  	pfc.Add (arrow);  } catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathDataConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	var arrow = new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true);  	pfc.Add (arrow);  } catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathDataConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	var arrow = new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true);  	pfc.Add (arrow);  } catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathDataConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	var arrow = new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true);  	pfc.Add (arrow);  } catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathDataConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	var arrow = new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true);  	pfc.Add (arrow);  } catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathDataConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	var arrow = new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true);  	pfc.Add (arrow);  } catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathDataConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The following statement contains a magic number: try {  	Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  	#region Get the inputs  	//get the position of the source  	Point sourcePos = new Point () {  		X = (values [0] != DependencyProperty.UnsetValue ? (double)values [0] : 0.0)'  		Y = (values [1] != DependencyProperty.UnsetValue ? (double)values [1] : 0.0)  	};  	//get the size of the source  	Size sourceSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [2] != DependencyProperty.UnsetValue ? (double)values [2] : 0.0)'  		Height = (values [3] != DependencyProperty.UnsetValue ? (double)values [3] : 0.0)  	};  	//get the position of the target  	Point targetPos = new Point () {  		X = (values [4] != DependencyProperty.UnsetValue ? (double)values [4] : 0.0)'  		Y = (values [5] != DependencyProperty.UnsetValue ? (double)values [5] : 0.0)  	};  	//get the size of the target  	Size targetSize = new Size () {  		//Width = 0.0'  		//Height = 0.0  		Width = (values [6] != DependencyProperty.UnsetValue ? (double)values [6] : 0.0)'  		Height = (values [7] != DependencyProperty.UnsetValue ? (double)values [7] : 0.0)  	};  	//get the route informations  	Point[] routeInformation = (values [8] != DependencyProperty.UnsetValue ? (Point[])values [8] : null);  	#endregion  	bool hasRouteInfo = routeInformation != null && routeInformation.Length > 0;  	//  	// Create the path  	//  	Point p1 = GraphConverterHelper.CalculateAttachPoint (sourcePos' sourceSize' (hasRouteInfo ? routeInformation [0] : targetPos));  	Point p2 = GraphConverterHelper.CalculateAttachPoint (targetPos' targetSize' (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : sourcePos));  	PathSegment[] segments = new PathSegment[1 + (hasRouteInfo ? routeInformation.Length : 0)];  	if (hasRouteInfo)  		//append route points  		for (int i = 0; i < routeInformation.Length; i++)  			segments [i] = new LineSegment (routeInformation [i]' true);  	Point pLast = (hasRouteInfo ? routeInformation [routeInformation.Length - 1] : p1);  	Vector v = pLast - p2;  	v = v / v.Length * 6;  	Vector n = new Vector (-v.Y' v.X) * 0.5;  	segments [segments.Length - 1] = new LineSegment (p2 + v' true);  	pfc.Add (new PathFigure (p1' segments' false));  	var arrow = new PathFigure (p2' new PathSegment[] {  		new LineSegment (p2 + v - n' true)'  		new LineSegment (p2 + v + n' true)  	}' true);  	pfc.Add (arrow);  } catch (Exception) {  	System.Windows.MessageBox.Show ("grr");  }  
Magic Number,GraphSharp.Converters,EdgeRouteToPathDataConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The following statement contains a magic number: Debug.Assert (values != null && values.Length == 9' "EdgeRouteToPathConverter should have 9 parameters: pos (1'2)' size (3'4) of source; pos (5'6)' size (7'8) of target; routeInformation (9).");  
Magic Number,GraphSharp.Converters,EdgeRouteToPathDataConverter,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\EdgeRouteToPathDataConverter.cs,Convert,The following statement contains a magic number: v = v / v.Length * 6;  
Magic Number,GraphSharp.Converters,GraphConverterHelper,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\GraphConverterHelper.cs,CalculateAttachPoint,The following statement contains a magic number: sides [0] = (s.X - sourceSize.Width / 2.0 - t.X) / (s.X - t.X);  
Magic Number,GraphSharp.Converters,GraphConverterHelper,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\GraphConverterHelper.cs,CalculateAttachPoint,The following statement contains a magic number: sides [1] = (s.Y - sourceSize.Height / 2.0 - t.Y) / (s.Y - t.Y);  
Magic Number,GraphSharp.Converters,GraphConverterHelper,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\GraphConverterHelper.cs,CalculateAttachPoint,The following statement contains a magic number: sides [2] = (s.X + sourceSize.Width / 2.0 - t.X) / (s.X - t.X);  
Magic Number,GraphSharp.Converters,GraphConverterHelper,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\GraphConverterHelper.cs,CalculateAttachPoint,The following statement contains a magic number: sides [2] = (s.X + sourceSize.Width / 2.0 - t.X) / (s.X - t.X);  
Magic Number,GraphSharp.Converters,GraphConverterHelper,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\GraphConverterHelper.cs,CalculateAttachPoint,The following statement contains a magic number: sides [3] = (s.Y + sourceSize.Height / 2.0 - t.Y) / (s.Y - t.Y);  
Magic Number,GraphSharp.Converters,GraphConverterHelper,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\GraphConverterHelper.cs,CalculateAttachPoint,The following statement contains a magic number: sides [3] = (s.Y + sourceSize.Height / 2.0 - t.Y) / (s.Y - t.Y);  
Magic Number,GraphSharp.Converters,GraphConverterHelper,F:\newReposMay17\CoEST_TraceLab\Main\external\GraphSharp\Source\GraphSharp.Controls\Converters\GraphConverterHelper.cs,CalculateAttachPoint,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	if (sides [i] <= 1)  		fi = Math.Max (fi' sides [i]);  }  
