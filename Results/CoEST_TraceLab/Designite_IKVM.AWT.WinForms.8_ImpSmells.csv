Implementation smell,Namespace,Class,File,Method,Description
Long Method,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The method has 107 lines of code.
Complex Method,ikvm.awt,CompositeHelper,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\composite.cs,Create,Cyclomatic complexity of the method is 18
Complex Method,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,Cyclomatic complexity of the method is 24
Complex Method,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,CreateFontFamily,Cyclomatic complexity of the method is 11
Complex Method,ikvm.awt,C2J,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,Cyclomatic complexity of the method is 17
Complex Method,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,Cyclomatic complexity of the method is 16
Complex Method,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,SetLineDash,Cyclomatic complexity of the method is 23
Complex Method,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setRenderingHint,Cyclomatic complexity of the method is 14
Complex Method,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,getRenderingHints,Cyclomatic complexity of the method is 19
Complex Method,ikvm.awt,WindowsRobot,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\robot.cs,mousePress,Cyclomatic complexity of the method is 9
Complex Method,ikvm.awt,WindowsRobot,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\robot.cs,mouseRelease,Cyclomatic complexity of the method is 9
Complex Method,ikvm.awt,NetComponentPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getAction,Cyclomatic complexity of the method is 15
Complex Method,ikvm.awt,NetComponentPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,GetMouseEventModifiers,Cyclomatic complexity of the method is 9
Complex Method,ikvm.awt,NetComponentPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,GetModifiers,Cyclomatic complexity of the method is 13
Complex Method,ikvm.awt,NetComponentPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getDropAction,Cyclomatic complexity of the method is 18
Complex Method,ikvm.awt,NetComponentPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,handleEvent,Cyclomatic complexity of the method is 10
Complex Method,ikvm.awt,NetComponentPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,setCursorImpl,Cyclomatic complexity of the method is 38
Complex Method,ikvm.awt,NetComponentPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,requestFocus,Cyclomatic complexity of the method is 8
Complex Method,ikvm.awt,NetLabelPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,setAlignment,Cyclomatic complexity of the method is 10
Complex Method,ikvm.awt,NetTrayIconPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,displayMessage,Cyclomatic complexity of the method is 12
Complex Method,ikvm.awt,NetDataTransferer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,translateFromClipboard,Cyclomatic complexity of the method is 14
Complex Method,ikvm.awt,NetDataTransferer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getDataObject,Cyclomatic complexity of the method is 13
Complex Method,ikvm.awt,NetDataTransferer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,imageToStandardBytes,Cyclomatic complexity of the method is 18
Complex Method,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getIconBits,Cyclomatic complexity of the method is 10
Complex Method,ikvm.awt.printing,Win32PrintPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\printing.cs,getPrinterStatus,Cyclomatic complexity of the method is 9
Complex Method,ikvm.awt.printing,Win32PrintPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\printing.cs,extractResions,Cyclomatic complexity of the method is 26
Long Parameter List,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertRoundRect,The method has 6 parameters.
Long Parameter List,ikvm.awt,BitmapGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,copyArea,The method has 6 parameters.
Long Parameter List,ikvm.awt,ComponentGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,copyArea,The method has 6 parameters.
Long Parameter List,ikvm.awt,PrintGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,copyArea,The method has 6 parameters.
Long Parameter List,ikvm.awt,PrintGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawArc,The method has 6 parameters.
Long Parameter List,ikvm.awt,PrintGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawBytes,The method has 5 parameters.
Long Parameter List,ikvm.awt,PrintGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawChars,The method has 5 parameters.
Long Parameter List,ikvm.awt,PrintGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawImage,The method has 11 parameters.
Long Parameter List,ikvm.awt,PrintGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawImage,The method has 10 parameters.
Long Parameter List,ikvm.awt,PrintGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawImage,The method has 7 parameters.
Long Parameter List,ikvm.awt,PrintGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawImage,The method has 5 parameters.
Long Parameter List,ikvm.awt,PrintGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawImage,The method has 6 parameters.
Long Parameter List,ikvm.awt,PrintGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawRoundRect,The method has 6 parameters.
Long Parameter List,ikvm.awt,PrintGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,fill3DRect,The method has 5 parameters.
Long Parameter List,ikvm.awt,PrintGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,fillArc,The method has 6 parameters.
Long Parameter List,ikvm.awt,PrintGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,fillRoundRect,The method has 6 parameters.
Long Parameter List,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawArc,The method has 6 parameters.
Long Parameter List,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawBytes,The method has 5 parameters.
Long Parameter List,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawChars,The method has 5 parameters.
Long Parameter List,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawImage,The method has 11 parameters.
Long Parameter List,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawImage,The method has 10 parameters.
Long Parameter List,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawImage,The method has 7 parameters.
Long Parameter List,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawImage,The method has 5 parameters.
Long Parameter List,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawImage,The method has 6 parameters.
Long Parameter List,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawRoundRect,The method has 6 parameters.
Long Parameter List,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,fill3DRect,The method has 5 parameters.
Long Parameter List,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,fillArc,The method has 6 parameters.
Long Parameter List,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,fillRoundRect,The method has 6 parameters.
Long Parameter List,ikvm.awt,WindowsRobot,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\robot.cs,mouse_event,The method has 5 parameters.
Long Parameter List,ikvm.awt,NetToolkit,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,createDragGestureRecognizer,The method has 5 parameters.
Long Parameter List,ikvm.awt,NetToolkit,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,outline,The method has 5 parameters.
Long Parameter List,ikvm.awt,NetDragSourceContextPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,createDragSource,The method has 6 parameters.
Long Parameter List,ikvm.awt,NetDropTargetContextPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,handleEnterMessage,The method has 7 parameters.
Long Parameter List,ikvm.awt,NetDropTargetContextPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,handleMotionMessage,The method has 7 parameters.
Long Parameter List,ikvm.awt,NetDropTargetContextPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,handleDropMessage,The method has 8 parameters.
Long Parameter List,ikvm.awt,NetDropTargetContextPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,postDropTargetEvent,The method has 9 parameters.
Long Parameter List,ikvm.awt,NetComponentPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,repaint,The method has 5 parameters.
Long Parameter List,ikvm.awt,NetComponentPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,requestFocus,The method has 5 parameters.
Long Parameter List,ikvm.awt,NetComponentPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,setBounds,The method has 5 parameters.
Long Parameter List,ikvm.awt,NetComponentPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,flip,The method has 5 parameters.
Long Parameter List,ikvm.awt,NetComponentPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,repaint,The method has 5 parameters.
Long Parameter List,ikvm.awt,NetComponentPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,setBounds,The method has 5 parameters.
Long Parameter List,ikvm.awt,NetComponentPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,requestFocus,The method has 5 parameters.
Long Parameter List,ikvm.awt,NetComponentPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,flip,The method has 5 parameters.
Long Parameter List,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,GetDIBits,The method has 7 parameters.
Long Parameter List,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,GetDIBits,The method has 7 parameters.
Long Parameter List,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,CreateWindowEx,The method has 12 parameters.
Long Parameter List,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,LoadImage,The method has 6 parameters.
Long Parameter List,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,LoadImage,The method has 6 parameters.
Long Parameter List,ikvm.awt.printing,Win32PrintPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\printing.cs,GetPrinter,The method has 5 parameters.
Long Parameter List,awt,ShellApi,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\ShellApi.cs,SHGetFileInfo,The method has 5 parameters.
Long Parameter List,awt,ShellApi,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\ShellApi.cs,SHGetFileInfo,The method has 5 parameters.
Long Statement,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertTransform,The length of the statement  "	return new Matrix ((float)tx.getScaleX ()' (float)tx.getShearY ()' (float)tx.getShearX ()' (float)tx.getScaleY ()' (float)tx.getTranslateX ()' (float)tx.getTranslateY ()); " is 171.
Long Statement,ikvm.awt,NetGraphicsState,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,restoreGraphics,The length of the statement  "		netG.setRenderingHint (java.awt.RenderingHints.KEY_TEXT_ANTIALIASING' java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_DEFAULT); " is 124.
Long Statement,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawImage,The length of the statement  "		g.DrawImage (image' new Rectangle (x' y' width' height)' 0' 0' image.Width' image.Height' GraphicsUnit.Pixel' composite.GetImageAttributes ()); " is 143.
Long Statement,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawImage,The length of the statement  "		g.DrawImage (image' new Rectangle (x' y' width' height)' 0' 0' image.Width' image.Height' GraphicsUnit.Pixel' composite.GetImageAttributes ()); " is 143.
Long Statement,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawString,The length of the statement  "	format.FormatFlags = StringFormatFlags.MeasureTrailingSpaces | StringFormatFlags.NoWrap | StringFormatFlags.FitBlackBox; " is 120.
Long Statement,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The length of the statement  "			linear = new LinearGradientBrush (J2C.ConvertPoint (gradient.getPoint1 ())' J2C.ConvertPoint (gradient.getPoint2 ())' composite.GetColor (gradient.getColor1 ())' composite.GetColor (gradient.getColor2 ())); " is 206.
Long Statement,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The length of the statement  "			linear = new LinearGradientBrush (new PointF (x1 - z * diffX' y1 - z * diffY)' new PointF (x2 + z * diffX' y2 + z * diffY)' color1' color1); " is 140.
Long Statement,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The length of the statement  "		brush = new TextureBrush (J2C.ConvertImage (texture.getImage ())' J2C.ConvertRect (texture.getAnchorRect ())' composite.GetImageAttributes ()); " is 143.
Long Statement,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setRenderingHint,The length of the statement  "		if (hintValue == java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_DEFAULT || hintValue == java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_OFF) { " is 137.
Long Statement,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setRenderingHint,The length of the statement  "		if (hintValue == java.awt.RenderingHints.VALUE_FRACTIONALMETRICS_DEFAULT || hintValue == java.awt.RenderingHints.VALUE_FRACTIONALMETRICS_OFF || hintValue == java.awt.RenderingHints.VALUE_FRACTIONALMETRICS_ON) { " is 210.
Long Statement,ikvm.awt,NetVolatileImage,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\images.cs,createGraphics,The length of the statement  "	return new BitmapGraphics (bitmap' getFont ()' J2C.ConvertColor (getForeground ())' J2C.ConvertColor (getBackground ())); " is 121.
Long Statement,ikvm.awt,NoImage,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\images.cs,getWidth,The length of the statement  "		observer.imageUpdate (this' java.awt.image.ImageObserver.__Fields.ERROR | java.awt.image.ImageObserver.__Fields.ABORT' 0' 0' -1' -1); " is 133.
Long Statement,ikvm.awt,NoImage,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\images.cs,getHeight,The length of the statement  "		observer.imageUpdate (this' java.awt.image.ImageObserver.__Fields.ERROR | java.awt.image.ImageObserver.__Fields.ABORT' 0' 0' -1' -1); " is 133.
Long Statement,ikvm.awt,NoImage,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\images.cs,getProperty,The length of the statement  "		observer.imageUpdate (this' java.awt.image.ImageObserver.__Fields.ERROR | java.awt.image.ImageObserver.__Fields.ABORT' 0' 0' -1' -1); " is 133.
Long Statement,ikvm.awt,WindowsRobot,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\robot.cs,MapKeyCode,The length of the statement  "	//http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winui/WinUI/WindowsUserInterface/UserInput/VirtualKeyCodes.asp " is 129.
Long Statement,ikvm.awt,NetToolkit,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,InstallEventQueueSynchronizationContext,The length of the statement  "		eq.postEvent (new java.awt.@event.InvocationEvent (this' Delegates.toRunnable (EventQueueSynchronizationContext.Install)' null' true)); " is 135.
Long Statement,ikvm.awt,NetToolkit,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,isWin32,The length of the statement  "	return Environment.OSVersion.Platform == PlatformID.Win32NT || Environment.OSVersion.Platform == PlatformID.Win32Windows; " is 121.
Long Statement,ikvm.awt,NetToolkit,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getImage,The length of the statement  "		using (System.IO.FileStream stream = new System.IO.FileStream (filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite)) { " is 128.
Long Statement,ikvm.awt,NetToolkit,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,initializeDesktopProperties,The length of the statement  "			//                    string dllName = (string)getRegistry("Software\\Microsoft\\Windows\\CurrentVersion\\ThemeManager"' "DllName"); " is 132.
Long Statement,ikvm.awt,NetToolkit,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,initializeDesktopProperties,The length of the statement  "			//                    string sizeName = (string)getRegistry("Software\\Microsoft\\Windows\\CurrentVersion\\ThemeManager"' "SizeName"); " is 134.
Long Statement,ikvm.awt,NetToolkit,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,initializeDesktopProperties,The length of the statement  "			//                    string colorName = (string)getRegistry("Software\\Microsoft\\Windows\\CurrentVersion\\ThemeManager"' "ColorName"); " is 136.
Long Statement,ikvm.awt,NetToolkit,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,outline,The length of the statement  "	format.FormatFlags = StringFormatFlags.MeasureTrailingSpaces | StringFormatFlags.NoWrap | StringFormatFlags.FitBlackBox; " is 120.
Long Statement,ikvm.awt,NetToolkit,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,isModalityTypeSupported,The length of the statement  "	return type.ordinal () == java.awt.Dialog.ModalityType.MODELESS.ordinal () || type.ordinal () == java.awt.Dialog.ModalityType.APPLICATION_MODAL.ordinal (); " is 155.
Long Statement,ikvm.awt,NetToolkit,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getScreenInsets,The length of the statement  "		return new java.awt.Insets (rectWorkingArea.Top - rectBounds.Top' rectWorkingArea.Left - rectBounds.Left' rectBounds.Bottom - rectWorkingArea.Bottom' rectBounds.Right - rectWorkingArea.Right); " is 192.
Long Statement,ikvm.awt,NetMenuItemPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,OnClick,The length of the statement  "		NetToolkit.postEvent (NetToolkit.targetToAppContext (target)' new java.awt.@event.ActionEvent (target' java.awt.@event.ActionEvent.ACTION_PERFORMED' target.getActionCommand ()' when' modifiers)); " is 195.
Long Statement,ikvm.awt,NetCheckboxMenuItemPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,OnClick,The length of the statement  "		NetToolkit.postEvent (NetToolkit.targetToAppContext (target)' new java.awt.@event.ItemEvent (target' java.awt.@event.ItemEvent.ITEM_STATE_CHANGED' target.getLabel ()' (state) ? java.awt.@event.ItemEvent.SELECTED : java.awt.@event.ItemEvent.DESELECTED)); " is 253.
Long Statement,ikvm.awt,NetDragSourceContextPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,startDrag,The length of the statement  "	createDragSource (getTrigger ().getComponent ()' trans' getTrigger ().getTriggerEvent ()' getTrigger ().getSourceAsDragGestureRecognizer ().getSourceActions ()' formats' formatMap); " is 181.
Long Statement,ikvm.awt,NetDragSourceContextPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,createDragSource,The length of the statement  "	while (controlOwner != null && (controlOwner.getPeer () == null || controlOwner.getPeer () is sun.awt.NullComponentPeer)) { " is 123.
Long Statement,ikvm.awt,NetDragSourceContextPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,createDragSource,The length of the statement  "				IDataObject data = NetDataTransferer.getInstanceImpl ().getDataObject (transferable' NetDataTransferer.adaptFlavorMap (dragSource.getFlavorMap ())); " is 148.
Long Statement,ikvm.awt,NetDragSourceContextPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,createDragSource,The length of the statement  "					dragDropFinished (effects != DragDropEffects.None' NetComponentPeer.getAction (effects)' Control.MousePosition.X' Control.MousePosition.Y); " is 139.
Long Statement,ikvm.awt,NetDropTargetContextPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,handleEnterMessage,The length of the statement  "	return postDropTargetEvent (component' x' y' dropAction' actions' formats' nativeCtxt' sun.awt.dnd.SunDropTargetEvent.MOUSE_ENTERED' sun.awt.dnd.SunDropTargetContextPeer.DISPATCH_SYNC); " is 185.
Long Statement,ikvm.awt,NetDropTargetContextPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,handleExitMessage,The length of the statement  "	postDropTargetEvent (component' 0' 0' java.awt.dnd.DnDConstants.ACTION_NONE' java.awt.dnd.DnDConstants.ACTION_NONE' null' nativeCtxt' sun.awt.dnd.SunDropTargetEvent.MOUSE_EXITED' sun.awt.dnd.SunDropTargetContextPeer.DISPATCH_SYNC); " is 231.
Long Statement,ikvm.awt,NetDropTargetContextPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,handleMotionMessage,The length of the statement  "	return postDropTargetEvent (component' x' y' dropAction' actions' formats' nativeCtxt' sun.awt.dnd.SunDropTargetEvent.MOUSE_DRAGGED' sun.awt.dnd.SunDropTargetContextPeer.DISPATCH_SYNC); " is 185.
Long Statement,ikvm.awt,NetDropTargetContextPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,handleDropMessage,The length of the statement  "	postDropTargetEvent (component' x' y' dropAction' actions' formats' nativeCtxt' sun.awt.dnd.SunDropTargetEvent.MOUSE_DROPPED' !sun.awt.dnd.SunDropTargetContextPeer.DISPATCH_SYNC); " is 179.
Long Statement,ikvm.awt,NetMouseDragGestureRecognizer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,mapDragOperationFromModifiers,The length of the statement  "	if (!(btns == java.awt.@event.InputEvent.BUTTON1_DOWN_MASK || btns == java.awt.@event.InputEvent.BUTTON2_DOWN_MASK || btns == java.awt.@event.InputEvent.BUTTON3_DOWN_MASK)) { " is 174.
Long Statement,ikvm.awt,NetComponentPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,OnKeyDown,The length of the statement  "		postEvent (new java.awt.@event.KeyEvent (target' java.awt.@event.KeyEvent.KEY_PRESSED' when' modifiers' keyCode' keyChar' keyLocation)); " is 136.
Long Statement,ikvm.awt,NetComponentPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,OnDragEnter,The length of the statement  "	int actions = dropTargetPeer.handleEnterMessage (target' e.X' e.Y' getDropAction (e.AllowedEffect' e.KeyState)' getAction (e.AllowedEffect)' formats' 0); " is 153.
Long Statement,ikvm.awt,NetComponentPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,OnDragOver,The length of the statement  "	int actions = dropTargetPeer.handleMotionMessage (target' e.X' e.Y' getDropAction (e.AllowedEffect' e.KeyState)' getAction (e.AllowedEffect)' formats' 0); " is 154.
Long Statement,ikvm.awt,NetComponentPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,OnDragDrop,The length of the statement  "		dropTargetPeer.handleDropMessage (target' e.X' e.Y' getAction (e.Effect)' getAction (e.AllowedEffect)' formats' 0' e.Data); " is 123.
Long Statement,ikvm.awt,NetComponentPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,OnKeyUp,The length of the statement  "		postEvent (new java.awt.@event.KeyEvent (target' java.awt.@event.KeyEvent.KEY_RELEASED' when' modifiers' keyCode' keyChar' keyLocation)); " is 137.
Long Statement,ikvm.awt,NetComponentPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,OnKeyPress,The length of the statement  "		postEvent (new java.awt.@event.KeyEvent (target' java.awt.@event.KeyEvent.KEY_TYPED' when' modifiers' keyCode' keyChar' keyLocation)); " is 134.
Long Statement,ikvm.awt,NetComponentPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,postMouseWheelEvent,The length of the statement  "		postEvent (new java.awt.@event.MouseWheelEvent (target' id' when' modifiers' x' y' clickCount' isPopup' java.awt.@event.MouseWheelEvent.WHEEL_UNIT_SCROLL' scrollAmount' scrollAmount)); " is 184.
Long Statement,ikvm.awt,NetComponentPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,handleEvent,The length of the statement  "	if (((java.awt.Component)target).isEnabled () && (e is java.awt.@event.KeyEvent) && !((java.awt.@event.KeyEvent)e).isConsumed ()) { " is 131.
Long Statement,ikvm.awt,NetComponentPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,requestFocus,The length of the statement  "				java.lang.reflect.Method method = keyboardFocusManagerCls.getDeclaredMethod ("processSynchronousLightweightTransfer"' typeof(java.awt.Component)' typeof(java.awt.Component)' java.lang.Boolean.TYPE' java.lang.Boolean.TYPE' java.lang.Long.TYPE); " is 243.
Long Statement,ikvm.awt,NetComponentPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,requestFocus,The length of the statement  "		processSynchronousLightweightTransfer.invoke (null' target' lightweightChild' java.lang.Boolean.valueOf (temporary)' java.lang.Boolean.valueOf (focusedWindowChangeAllowed)' java.lang.Long.valueOf (time)); " is 204.
Long Statement,ikvm.awt,NetComponentPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,requestFocus,The length of the statement  "			java.lang.reflect.Method method = keyboardFocusManagerCls.getDeclaredMethod ("shouldNativelyFocusHeavyweight"' typeof(java.awt.Component)' typeof(java.awt.Component)' java.lang.Boolean.TYPE' java.lang.Boolean.TYPE' java.lang.Long.TYPE' typeof(sun.awt.CausedFocusEvent.Cause)); " is 276.
Long Statement,ikvm.awt,NetComponentPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,requestFocus,The length of the statement  "	int retval = ((java.lang.Integer)shouldNativelyFocusHeavyweight.invoke (null' target' lightweightChild' java.lang.Boolean.valueOf (temporary)' java.lang.Boolean.valueOf (focusedWindowChangeAllowed)' java.lang.Long.valueOf (time)' cause)).intValue (); " is 250.
Long Statement,ikvm.awt,NetComponentPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,requestFocus,The length of the statement  "				java.lang.reflect.Method method = keyboardFocusManagerCls.getDeclaredMethod ("removeLastFocusRequest"' typeof(java.awt.Component)); " is 131.
Long Statement,ikvm.awt,NetButtonPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,OnClick,The length of the statement  "	postEvent (new java.awt.@event.ActionEvent (target' java.awt.@event.ActionEvent.ACTION_PERFORMED' cmd' when' modifiers)); " is 121.
Long Statement,ikvm.awt,NetButtonPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getMinimumSize,The length of the statement  "		return new java.awt.Dimension ((int)Math.Round (12 + g.MeasureString (control.Text' control.Font).Width) * 8 / 7' 6 + control.Font.Height * 8 / 7); " is 147.
Long Statement,ikvm.awt,NetTextComponentPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,OnKeyPress,The length of the statement  "		postEvent (new java.awt.@event.ActionEvent (target' java.awt.@event.ActionEvent.ACTION_PERFORMED' cmd' when' modifiers)); " is 121.
Long Statement,ikvm.awt,NetTextFieldPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getPreferredSize,The length of the statement  "		return new java.awt.Dimension ((int)Math.Round ((g.MeasureString ("abcdefghijklm"' control.Font).Width * len) / 13)' ((TextBox)control).PreferredHeight); " is 153.
Long Statement,ikvm.awt,NetTextFieldPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,handleJavaKeyEvent,The length of the statement  "			postEvent (new java.awt.@event.ActionEvent (target' java.awt.@event.ActionEvent.ACTION_PERFORMED' getText ()' e.getWhen ()' e.getModifiers ())); " is 144.
Long Statement,ikvm.awt,NetWindowPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,initialize,The length of the statement  "		AWTAccessor.getComponentAccessor ().setBackground (target' target is java.awt.Dialog ? java.awt.SystemColor.control : java.awt.SystemColor.window); " is 147.
Long Statement,ikvm.awt,NetWindowPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,initialize,The length of the statement  "			java.lang.reflect.Method method = component.getDeclaredMethod ("firePropertyChange"' typeof(java.lang.String)' typeof(java.lang.Object)' typeof(java.lang.Object)); " is 163.
Long Statement,ikvm.awt,NetWindowPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,OnSizeChanged,The length of the statement  "	typeof(java.awt.Component).GetField ("width"' BindingFlags.Instance | BindingFlags.NonPublic).SetValue (target' control.Width); " is 127.
Long Statement,ikvm.awt,NetWindowPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,OnSizeChanged,The length of the statement  "	typeof(java.awt.Component).GetField ("height"' BindingFlags.Instance | BindingFlags.NonPublic).SetValue (target' control.Height); " is 129.
Long Statement,ikvm.awt,NetWindowPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,SendWindowEvent,The length of the statement  "		ConstructorInfo cons = type.GetConstructor (BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public' null' new Type[] { " is 132.
Long Statement,ikvm.awt,NetWindowPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,updateFocusableWindowState,The length of the statement  "	((UndecoratedForm)control).SetWindowState (((java.awt.Window)target).isFocusableWindow ()' ((java.awt.Window)target).isAlwaysOnTop ()); " is 135.
Long Statement,ikvm.awt,NetKeyboardFocusManagerPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,removeLastFocusRequest,The length of the statement  "			m_removeLastFocusRequest = SunToolkit.getMethod (typeof(java.awt.KeyboardFocusManager)' "removeLastFocusRequest"' new java.lang.Class[] { " is 137.
Long Statement,ikvm.awt,NetDesktopPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,isSupported,The length of the statement  "	return da == java.awt.Desktop.Action.BROWSE || da == java.awt.Desktop.Action.EDIT || da == java.awt.Desktop.Action.MAIL || da == java.awt.Desktop.Action.OPEN || da == java.awt.Desktop.Action.PRINT; " is 197.
Long Statement,ikvm.awt,NetTrayIconPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,postMouseEvent,The length of the statement  "		java.awt.@event.MouseEvent mouseEvent = new java.awt.@event.MouseEvent (fake' id' when' modifiers' x' y' clickCount' isPopup' button); " is 134.
Long Statement,ikvm.awt,NetTrayIconPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,postMouseEvent,The length of the statement  "		java.awt.@event.MouseEvent mouseEvent = new java.awt.@event.MouseEvent (fake' id' when' modifiers' x' y' clickCount' isPopup' button); " is 134.
Long Statement,ikvm.awt,NetTrayIconPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,OnDoubleClick,The length of the statement  "	postEvent (new java.awt.@event.ActionEvent (target' java.awt.@event.ActionEvent.ACTION_PERFORMED' target.getActionCommand ()' when' modifiers)); " is 144.
Long Statement,ikvm.awt,NetDataTransferer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,translateFromClipboard,The length of the statement  "	java.awt.datatransfer.FlavorTable defaultFlavorMap = (java.awt.datatransfer.FlavorTable)java.awt.datatransfer.SystemFlavorMap.getDefaultFlavorMap (); " is 149.
Long Statement,ikvm.awt,NetDataTransferer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,translateFromClipboard,The length of the statement  "		java.awt.datatransfer.DataFlavor[] flavors = (java.awt.datatransfer.DataFlavor[])(flavorMap.keySet ().toArray (new java.awt.datatransfer.DataFlavor[0])); " is 153.
Long Statement,ikvm.awt,NetDataTransferer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getDataObject,The length of the statement  "	SortedMap /*<java.lang.Long'java.awt.datatransfer.DataFlavor>*/formatMap = getFormatsForTransferable (transferable' flavorMap); " is 127.
Long Statement,ikvm.awt,NetDataTransferer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getDataObject,The length of the statement  "			if (!(flavor.isMimeTypeEqual (java.awt.datatransfer.DataFlavor.javaJVMLocalObjectMimeType) && e is java.io.NotSerializableException)) { " is 135.
Long Statement,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getFolderType,The length of the statement  "	if (ShellApi.SHGetFileInfo (path' 0' out shinfo' (uint)Marshal.SizeOf (shinfo)' ShellApi.SHGFI.SHGFI_TYPENAME) == IntPtr.Zero) { " is 128.
Long Statement,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getIconBits,The length of the statement  "			BitmapData bitmapData = bitmap.LockBits (new Rectangle (0' 0' iconSize' iconSize)' ImageLockMode.WriteOnly' PixelFormat.Format32bppArgb); " is 137.
Long Statement,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getAttribute,The length of the statement  "	if (ShellApi.SHGetFileInfo (path' 0' out shinfo' (uint)Marshal.SizeOf (shinfo)' ShellApi.SHGFI.SHGFI_ATTRIBUTES) == IntPtr.Zero) { " is 130.
Long Statement,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getStandardViewButton0,The length of the statement  "		IntPtr hWndToolbar = CreateWindowEx (0' "ToolbarWindow32"' null' 0' 0' 0' 0' 0' IntPtr.Zero' IntPtr.Zero' IntPtr.Zero' IntPtr.Zero); " is 132.
Long Statement,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getFolderType,The length of the statement  "	ShellApi.SHGetFileInfo (pIDL' 0' out fileInfo' (uint)Marshal.SizeOf (fileInfo)' ShellApi.SHGFI.SHGFI_PIDL | ShellApi.SHGFI.SHGFI_TYPENAME); " is 139.
Long Statement,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getIcon,The length of the statement  "	if (ShellApi.SHGetFileInfo (absolutePath' 0' out shinfo' (uint)Marshal.SizeOf (shinfo)' ShellApi.SHGFI.SHGFI_ICON | (getLargeIcon ? ShellApi.SHGFI.SHGFI_LARGEICON : ShellApi.SHGFI.SHGFI_SMALLICON)) == IntPtr.Zero) { " is 215.
Long Statement,ikvm.awt.printing,Win32PrintPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\printing.cs,getPrinterStatus,The length of the statement  "			if ((status & (PRINTER_STATUS_ERROR | PRINTER_STATUS_NO_TONER | PRINTER_STATUS_OUT_OF_MEMORY | PRINTER_STATUS_OFFLINE | PRINTER_STATUS_USER_INTERVENTION | PRINTER_STATUS_DOOR_OPEN | PRINTER_STATUS_NOT_AVAILABLE)) > 0) { " is 219.
Long Statement,ikvm.awt.printing,Win32PrintPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\printing.cs,getPrinterStatus,The length of the statement  "			if ((status & (PRINTER_STATUS_ERROR | PRINTER_STATUS_NO_TONER | PRINTER_STATUS_OUT_OF_MEMORY | PRINTER_STATUS_OFFLINE | PRINTER_STATUS_USER_INTERVENTION | PRINTER_STATUS_DOOR_OPEN)) > 0) { " is 188.
Long Statement,ikvm.awt.printing,Win32PrintPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\printing.cs,extractResions,The length of the statement  "		reasons.put (javax.print.attribute.standard.PrinterStateReason.MEDIA_JAM' javax.print.attribute.standard.Severity.WARNING); " is 123.
Long Statement,ikvm.awt.printing,Win32PrintPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\printing.cs,extractResions,The length of the statement  "		reasons.put (javax.print.attribute.standard.PrinterStateReason.MEDIA_EMPTY' javax.print.attribute.standard.Severity.WARNING); " is 125.
Long Statement,ikvm.awt.printing,Win32PrintPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\printing.cs,extractResions,The length of the statement  "		reasons.put (javax.print.attribute.standard.PrinterStateReason.TIMED_OUT' javax.print.attribute.standard.Severity.ERROR); " is 121.
Long Statement,ikvm.awt.printing,Win32PrintPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\printing.cs,extractResions,The length of the statement  "		reasons.put (javax.print.attribute.standard.PrinterStateReason.OUTPUT_AREA_FULL' javax.print.attribute.standard.Severity.WARNING); " is 130.
Long Statement,ikvm.awt.printing,Win32PrintPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\printing.cs,extractResions,The length of the statement  "		reasons.put (javax.print.attribute.standard.PrinterStateReason.TONER_LOW' javax.print.attribute.standard.Severity.WARNING); " is 123.
Long Statement,ikvm.awt.printing,Win32PrintPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\printing.cs,extractResions,The length of the statement  "		reasons.put (javax.print.attribute.standard.PrinterStateReason.TONER_EMPTY' javax.print.attribute.standard.Severity.ERROR); " is 123.
Long Statement,ikvm.awt.printing,Win32PrintPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\printing.cs,extractResions,The length of the statement  "		reasons.put (javax.print.attribute.standard.PrinterStateReason.DOOR_OPEN' javax.print.attribute.standard.Severity.ERROR); " is 121.
Complex Conditional,ikvm.awt,NetCustomCursor,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,NetCustomCursor,The conditional expression  "hotSpot.x >= width || hotSpot.y >= height || hotSpot.x < 0 || hotSpot.y < 0"  is complex.
Virtual Method Call from Constructor,ikvm.awt,UndecoratedForm,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,UndecoratedForm,The constructor "UndecoratedForm" calls a virtual method "setBorderStyle".
Empty Catch Block,ikvm.awt,NetToolkit,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,initializeDesktopProperties,The method has an empty catch block.
Empty Catch Block,ikvm.awt,NetCustomCursor,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,NetCustomCursor,The method has an empty catch block.
Empty Catch Block,ikvm.awt,NetComponentPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,setBounds,The method has an empty catch block.
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertRoundRect,The following statement contains a magic number: if (drawArc) {  	gp.AddArc (x + w - arcWidth' y' arcWidth' arcHeight' 270' 90);  	//upper right arc  }  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertRoundRect,The following statement contains a magic number: if (drawArc) {  	gp.AddArc (x + w - arcWidth' y' arcWidth' arcHeight' 270' 90);  	//upper right arc  }  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertRoundRect,The following statement contains a magic number: gp.AddArc (x + w - arcWidth' y' arcWidth' arcHeight' 270' 90);  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertRoundRect,The following statement contains a magic number: gp.AddArc (x + w - arcWidth' y' arcWidth' arcHeight' 270' 90);  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertRoundRect,The following statement contains a magic number: if (drawArc) {  	gp.AddArc (x + w - arcWidth' y + h - arcHeight' arcWidth' arcHeight' 0' 90);  	//lower right arc  }  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertRoundRect,The following statement contains a magic number: gp.AddArc (x + w - arcWidth' y + h - arcHeight' arcWidth' arcHeight' 0' 90);  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertRoundRect,The following statement contains a magic number: if (drawArc) {  	gp.AddArc (x' y + h - arcHeight' arcWidth' arcHeight' 90' 90);  	//lower left arc  }  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertRoundRect,The following statement contains a magic number: if (drawArc) {  	gp.AddArc (x' y + h - arcHeight' arcWidth' arcHeight' 90' 90);  	//lower left arc  }  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertRoundRect,The following statement contains a magic number: gp.AddArc (x' y + h - arcHeight' arcWidth' arcHeight' 90' 90);  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertRoundRect,The following statement contains a magic number: gp.AddArc (x' y + h - arcHeight' arcWidth' arcHeight' 90' 90);  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertRoundRect,The following statement contains a magic number: if (drawArc) {  	gp.AddArc (x' y' arcWidth' arcHeight' 180' 90);  	//upper left arc  }  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertRoundRect,The following statement contains a magic number: if (drawArc) {  	gp.AddArc (x' y' arcWidth' arcHeight' 180' 90);  	//upper left arc  }  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertRoundRect,The following statement contains a magic number: gp.AddArc (x' y' arcWidth' arcHeight' 180' 90);  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertRoundRect,The following statement contains a magic number: gp.AddArc (x' y' arcWidth' arcHeight' 180' 90);  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: while (!iterator.isDone ()) {  	int type = iterator.currentSegment (coords);  	switch (type) {  	case java.awt.geom.PathIterator.__Fields.SEG_MOVETO:  		x = coords [0];  		y = coords [1];  		gp.StartFigure ();  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_LINETO:  		gp.AddLine (x' y' coords [0]' coords [1]);  		x = coords [0];  		y = coords [1];  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_QUADTO:  		gp.AddBezier (x' y' coords [0]' coords [1]' coords [0]' coords [1]' coords [2]' coords [3]);  		x = coords [2];  		y = coords [3];  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_CUBICTO:  		gp.AddBezier (x' y' coords [0]' coords [1]' coords [2]' coords [3]' coords [4]' coords [5]);  		x = coords [4];  		y = coords [5];  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_CLOSE:  		gp.CloseFigure ();  		break;  	}  	iterator.next ();  }  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: while (!iterator.isDone ()) {  	int type = iterator.currentSegment (coords);  	switch (type) {  	case java.awt.geom.PathIterator.__Fields.SEG_MOVETO:  		x = coords [0];  		y = coords [1];  		gp.StartFigure ();  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_LINETO:  		gp.AddLine (x' y' coords [0]' coords [1]);  		x = coords [0];  		y = coords [1];  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_QUADTO:  		gp.AddBezier (x' y' coords [0]' coords [1]' coords [0]' coords [1]' coords [2]' coords [3]);  		x = coords [2];  		y = coords [3];  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_CUBICTO:  		gp.AddBezier (x' y' coords [0]' coords [1]' coords [2]' coords [3]' coords [4]' coords [5]);  		x = coords [4];  		y = coords [5];  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_CLOSE:  		gp.CloseFigure ();  		break;  	}  	iterator.next ();  }  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: while (!iterator.isDone ()) {  	int type = iterator.currentSegment (coords);  	switch (type) {  	case java.awt.geom.PathIterator.__Fields.SEG_MOVETO:  		x = coords [0];  		y = coords [1];  		gp.StartFigure ();  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_LINETO:  		gp.AddLine (x' y' coords [0]' coords [1]);  		x = coords [0];  		y = coords [1];  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_QUADTO:  		gp.AddBezier (x' y' coords [0]' coords [1]' coords [0]' coords [1]' coords [2]' coords [3]);  		x = coords [2];  		y = coords [3];  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_CUBICTO:  		gp.AddBezier (x' y' coords [0]' coords [1]' coords [2]' coords [3]' coords [4]' coords [5]);  		x = coords [4];  		y = coords [5];  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_CLOSE:  		gp.CloseFigure ();  		break;  	}  	iterator.next ();  }  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: while (!iterator.isDone ()) {  	int type = iterator.currentSegment (coords);  	switch (type) {  	case java.awt.geom.PathIterator.__Fields.SEG_MOVETO:  		x = coords [0];  		y = coords [1];  		gp.StartFigure ();  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_LINETO:  		gp.AddLine (x' y' coords [0]' coords [1]);  		x = coords [0];  		y = coords [1];  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_QUADTO:  		gp.AddBezier (x' y' coords [0]' coords [1]' coords [0]' coords [1]' coords [2]' coords [3]);  		x = coords [2];  		y = coords [3];  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_CUBICTO:  		gp.AddBezier (x' y' coords [0]' coords [1]' coords [2]' coords [3]' coords [4]' coords [5]);  		x = coords [4];  		y = coords [5];  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_CLOSE:  		gp.CloseFigure ();  		break;  	}  	iterator.next ();  }  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: while (!iterator.isDone ()) {  	int type = iterator.currentSegment (coords);  	switch (type) {  	case java.awt.geom.PathIterator.__Fields.SEG_MOVETO:  		x = coords [0];  		y = coords [1];  		gp.StartFigure ();  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_LINETO:  		gp.AddLine (x' y' coords [0]' coords [1]);  		x = coords [0];  		y = coords [1];  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_QUADTO:  		gp.AddBezier (x' y' coords [0]' coords [1]' coords [0]' coords [1]' coords [2]' coords [3]);  		x = coords [2];  		y = coords [3];  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_CUBICTO:  		gp.AddBezier (x' y' coords [0]' coords [1]' coords [2]' coords [3]' coords [4]' coords [5]);  		x = coords [4];  		y = coords [5];  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_CLOSE:  		gp.CloseFigure ();  		break;  	}  	iterator.next ();  }  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: while (!iterator.isDone ()) {  	int type = iterator.currentSegment (coords);  	switch (type) {  	case java.awt.geom.PathIterator.__Fields.SEG_MOVETO:  		x = coords [0];  		y = coords [1];  		gp.StartFigure ();  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_LINETO:  		gp.AddLine (x' y' coords [0]' coords [1]);  		x = coords [0];  		y = coords [1];  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_QUADTO:  		gp.AddBezier (x' y' coords [0]' coords [1]' coords [0]' coords [1]' coords [2]' coords [3]);  		x = coords [2];  		y = coords [3];  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_CUBICTO:  		gp.AddBezier (x' y' coords [0]' coords [1]' coords [2]' coords [3]' coords [4]' coords [5]);  		x = coords [4];  		y = coords [5];  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_CLOSE:  		gp.CloseFigure ();  		break;  	}  	iterator.next ();  }  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: while (!iterator.isDone ()) {  	int type = iterator.currentSegment (coords);  	switch (type) {  	case java.awt.geom.PathIterator.__Fields.SEG_MOVETO:  		x = coords [0];  		y = coords [1];  		gp.StartFigure ();  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_LINETO:  		gp.AddLine (x' y' coords [0]' coords [1]);  		x = coords [0];  		y = coords [1];  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_QUADTO:  		gp.AddBezier (x' y' coords [0]' coords [1]' coords [0]' coords [1]' coords [2]' coords [3]);  		x = coords [2];  		y = coords [3];  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_CUBICTO:  		gp.AddBezier (x' y' coords [0]' coords [1]' coords [2]' coords [3]' coords [4]' coords [5]);  		x = coords [4];  		y = coords [5];  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_CLOSE:  		gp.CloseFigure ();  		break;  	}  	iterator.next ();  }  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: while (!iterator.isDone ()) {  	int type = iterator.currentSegment (coords);  	switch (type) {  	case java.awt.geom.PathIterator.__Fields.SEG_MOVETO:  		x = coords [0];  		y = coords [1];  		gp.StartFigure ();  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_LINETO:  		gp.AddLine (x' y' coords [0]' coords [1]);  		x = coords [0];  		y = coords [1];  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_QUADTO:  		gp.AddBezier (x' y' coords [0]' coords [1]' coords [0]' coords [1]' coords [2]' coords [3]);  		x = coords [2];  		y = coords [3];  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_CUBICTO:  		gp.AddBezier (x' y' coords [0]' coords [1]' coords [2]' coords [3]' coords [4]' coords [5]);  		x = coords [4];  		y = coords [5];  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_CLOSE:  		gp.CloseFigure ();  		break;  	}  	iterator.next ();  }  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: while (!iterator.isDone ()) {  	int type = iterator.currentSegment (coords);  	switch (type) {  	case java.awt.geom.PathIterator.__Fields.SEG_MOVETO:  		x = coords [0];  		y = coords [1];  		gp.StartFigure ();  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_LINETO:  		gp.AddLine (x' y' coords [0]' coords [1]);  		x = coords [0];  		y = coords [1];  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_QUADTO:  		gp.AddBezier (x' y' coords [0]' coords [1]' coords [0]' coords [1]' coords [2]' coords [3]);  		x = coords [2];  		y = coords [3];  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_CUBICTO:  		gp.AddBezier (x' y' coords [0]' coords [1]' coords [2]' coords [3]' coords [4]' coords [5]);  		x = coords [4];  		y = coords [5];  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_CLOSE:  		gp.CloseFigure ();  		break;  	}  	iterator.next ();  }  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: while (!iterator.isDone ()) {  	int type = iterator.currentSegment (coords);  	switch (type) {  	case java.awt.geom.PathIterator.__Fields.SEG_MOVETO:  		x = coords [0];  		y = coords [1];  		gp.StartFigure ();  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_LINETO:  		gp.AddLine (x' y' coords [0]' coords [1]);  		x = coords [0];  		y = coords [1];  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_QUADTO:  		gp.AddBezier (x' y' coords [0]' coords [1]' coords [0]' coords [1]' coords [2]' coords [3]);  		x = coords [2];  		y = coords [3];  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_CUBICTO:  		gp.AddBezier (x' y' coords [0]' coords [1]' coords [2]' coords [3]' coords [4]' coords [5]);  		x = coords [4];  		y = coords [5];  		break;  	case java.awt.geom.PathIterator.__Fields.SEG_CLOSE:  		gp.CloseFigure ();  		break;  	}  	iterator.next ();  }  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: switch (type) {  case java.awt.geom.PathIterator.__Fields.SEG_MOVETO:  	x = coords [0];  	y = coords [1];  	gp.StartFigure ();  	break;  case java.awt.geom.PathIterator.__Fields.SEG_LINETO:  	gp.AddLine (x' y' coords [0]' coords [1]);  	x = coords [0];  	y = coords [1];  	break;  case java.awt.geom.PathIterator.__Fields.SEG_QUADTO:  	gp.AddBezier (x' y' coords [0]' coords [1]' coords [0]' coords [1]' coords [2]' coords [3]);  	x = coords [2];  	y = coords [3];  	break;  case java.awt.geom.PathIterator.__Fields.SEG_CUBICTO:  	gp.AddBezier (x' y' coords [0]' coords [1]' coords [2]' coords [3]' coords [4]' coords [5]);  	x = coords [4];  	y = coords [5];  	break;  case java.awt.geom.PathIterator.__Fields.SEG_CLOSE:  	gp.CloseFigure ();  	break;  }  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: switch (type) {  case java.awt.geom.PathIterator.__Fields.SEG_MOVETO:  	x = coords [0];  	y = coords [1];  	gp.StartFigure ();  	break;  case java.awt.geom.PathIterator.__Fields.SEG_LINETO:  	gp.AddLine (x' y' coords [0]' coords [1]);  	x = coords [0];  	y = coords [1];  	break;  case java.awt.geom.PathIterator.__Fields.SEG_QUADTO:  	gp.AddBezier (x' y' coords [0]' coords [1]' coords [0]' coords [1]' coords [2]' coords [3]);  	x = coords [2];  	y = coords [3];  	break;  case java.awt.geom.PathIterator.__Fields.SEG_CUBICTO:  	gp.AddBezier (x' y' coords [0]' coords [1]' coords [2]' coords [3]' coords [4]' coords [5]);  	x = coords [4];  	y = coords [5];  	break;  case java.awt.geom.PathIterator.__Fields.SEG_CLOSE:  	gp.CloseFigure ();  	break;  }  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: switch (type) {  case java.awt.geom.PathIterator.__Fields.SEG_MOVETO:  	x = coords [0];  	y = coords [1];  	gp.StartFigure ();  	break;  case java.awt.geom.PathIterator.__Fields.SEG_LINETO:  	gp.AddLine (x' y' coords [0]' coords [1]);  	x = coords [0];  	y = coords [1];  	break;  case java.awt.geom.PathIterator.__Fields.SEG_QUADTO:  	gp.AddBezier (x' y' coords [0]' coords [1]' coords [0]' coords [1]' coords [2]' coords [3]);  	x = coords [2];  	y = coords [3];  	break;  case java.awt.geom.PathIterator.__Fields.SEG_CUBICTO:  	gp.AddBezier (x' y' coords [0]' coords [1]' coords [2]' coords [3]' coords [4]' coords [5]);  	x = coords [4];  	y = coords [5];  	break;  case java.awt.geom.PathIterator.__Fields.SEG_CLOSE:  	gp.CloseFigure ();  	break;  }  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: switch (type) {  case java.awt.geom.PathIterator.__Fields.SEG_MOVETO:  	x = coords [0];  	y = coords [1];  	gp.StartFigure ();  	break;  case java.awt.geom.PathIterator.__Fields.SEG_LINETO:  	gp.AddLine (x' y' coords [0]' coords [1]);  	x = coords [0];  	y = coords [1];  	break;  case java.awt.geom.PathIterator.__Fields.SEG_QUADTO:  	gp.AddBezier (x' y' coords [0]' coords [1]' coords [0]' coords [1]' coords [2]' coords [3]);  	x = coords [2];  	y = coords [3];  	break;  case java.awt.geom.PathIterator.__Fields.SEG_CUBICTO:  	gp.AddBezier (x' y' coords [0]' coords [1]' coords [2]' coords [3]' coords [4]' coords [5]);  	x = coords [4];  	y = coords [5];  	break;  case java.awt.geom.PathIterator.__Fields.SEG_CLOSE:  	gp.CloseFigure ();  	break;  }  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: switch (type) {  case java.awt.geom.PathIterator.__Fields.SEG_MOVETO:  	x = coords [0];  	y = coords [1];  	gp.StartFigure ();  	break;  case java.awt.geom.PathIterator.__Fields.SEG_LINETO:  	gp.AddLine (x' y' coords [0]' coords [1]);  	x = coords [0];  	y = coords [1];  	break;  case java.awt.geom.PathIterator.__Fields.SEG_QUADTO:  	gp.AddBezier (x' y' coords [0]' coords [1]' coords [0]' coords [1]' coords [2]' coords [3]);  	x = coords [2];  	y = coords [3];  	break;  case java.awt.geom.PathIterator.__Fields.SEG_CUBICTO:  	gp.AddBezier (x' y' coords [0]' coords [1]' coords [2]' coords [3]' coords [4]' coords [5]);  	x = coords [4];  	y = coords [5];  	break;  case java.awt.geom.PathIterator.__Fields.SEG_CLOSE:  	gp.CloseFigure ();  	break;  }  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: switch (type) {  case java.awt.geom.PathIterator.__Fields.SEG_MOVETO:  	x = coords [0];  	y = coords [1];  	gp.StartFigure ();  	break;  case java.awt.geom.PathIterator.__Fields.SEG_LINETO:  	gp.AddLine (x' y' coords [0]' coords [1]);  	x = coords [0];  	y = coords [1];  	break;  case java.awt.geom.PathIterator.__Fields.SEG_QUADTO:  	gp.AddBezier (x' y' coords [0]' coords [1]' coords [0]' coords [1]' coords [2]' coords [3]);  	x = coords [2];  	y = coords [3];  	break;  case java.awt.geom.PathIterator.__Fields.SEG_CUBICTO:  	gp.AddBezier (x' y' coords [0]' coords [1]' coords [2]' coords [3]' coords [4]' coords [5]);  	x = coords [4];  	y = coords [5];  	break;  case java.awt.geom.PathIterator.__Fields.SEG_CLOSE:  	gp.CloseFigure ();  	break;  }  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: switch (type) {  case java.awt.geom.PathIterator.__Fields.SEG_MOVETO:  	x = coords [0];  	y = coords [1];  	gp.StartFigure ();  	break;  case java.awt.geom.PathIterator.__Fields.SEG_LINETO:  	gp.AddLine (x' y' coords [0]' coords [1]);  	x = coords [0];  	y = coords [1];  	break;  case java.awt.geom.PathIterator.__Fields.SEG_QUADTO:  	gp.AddBezier (x' y' coords [0]' coords [1]' coords [0]' coords [1]' coords [2]' coords [3]);  	x = coords [2];  	y = coords [3];  	break;  case java.awt.geom.PathIterator.__Fields.SEG_CUBICTO:  	gp.AddBezier (x' y' coords [0]' coords [1]' coords [2]' coords [3]' coords [4]' coords [5]);  	x = coords [4];  	y = coords [5];  	break;  case java.awt.geom.PathIterator.__Fields.SEG_CLOSE:  	gp.CloseFigure ();  	break;  }  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: switch (type) {  case java.awt.geom.PathIterator.__Fields.SEG_MOVETO:  	x = coords [0];  	y = coords [1];  	gp.StartFigure ();  	break;  case java.awt.geom.PathIterator.__Fields.SEG_LINETO:  	gp.AddLine (x' y' coords [0]' coords [1]);  	x = coords [0];  	y = coords [1];  	break;  case java.awt.geom.PathIterator.__Fields.SEG_QUADTO:  	gp.AddBezier (x' y' coords [0]' coords [1]' coords [0]' coords [1]' coords [2]' coords [3]);  	x = coords [2];  	y = coords [3];  	break;  case java.awt.geom.PathIterator.__Fields.SEG_CUBICTO:  	gp.AddBezier (x' y' coords [0]' coords [1]' coords [2]' coords [3]' coords [4]' coords [5]);  	x = coords [4];  	y = coords [5];  	break;  case java.awt.geom.PathIterator.__Fields.SEG_CLOSE:  	gp.CloseFigure ();  	break;  }  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: switch (type) {  case java.awt.geom.PathIterator.__Fields.SEG_MOVETO:  	x = coords [0];  	y = coords [1];  	gp.StartFigure ();  	break;  case java.awt.geom.PathIterator.__Fields.SEG_LINETO:  	gp.AddLine (x' y' coords [0]' coords [1]);  	x = coords [0];  	y = coords [1];  	break;  case java.awt.geom.PathIterator.__Fields.SEG_QUADTO:  	gp.AddBezier (x' y' coords [0]' coords [1]' coords [0]' coords [1]' coords [2]' coords [3]);  	x = coords [2];  	y = coords [3];  	break;  case java.awt.geom.PathIterator.__Fields.SEG_CUBICTO:  	gp.AddBezier (x' y' coords [0]' coords [1]' coords [2]' coords [3]' coords [4]' coords [5]);  	x = coords [4];  	y = coords [5];  	break;  case java.awt.geom.PathIterator.__Fields.SEG_CLOSE:  	gp.CloseFigure ();  	break;  }  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: switch (type) {  case java.awt.geom.PathIterator.__Fields.SEG_MOVETO:  	x = coords [0];  	y = coords [1];  	gp.StartFigure ();  	break;  case java.awt.geom.PathIterator.__Fields.SEG_LINETO:  	gp.AddLine (x' y' coords [0]' coords [1]);  	x = coords [0];  	y = coords [1];  	break;  case java.awt.geom.PathIterator.__Fields.SEG_QUADTO:  	gp.AddBezier (x' y' coords [0]' coords [1]' coords [0]' coords [1]' coords [2]' coords [3]);  	x = coords [2];  	y = coords [3];  	break;  case java.awt.geom.PathIterator.__Fields.SEG_CUBICTO:  	gp.AddBezier (x' y' coords [0]' coords [1]' coords [2]' coords [3]' coords [4]' coords [5]);  	x = coords [4];  	y = coords [5];  	break;  case java.awt.geom.PathIterator.__Fields.SEG_CLOSE:  	gp.CloseFigure ();  	break;  }  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: gp.AddBezier (x' y' coords [0]' coords [1]' coords [0]' coords [1]' coords [2]' coords [3]);  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: gp.AddBezier (x' y' coords [0]' coords [1]' coords [0]' coords [1]' coords [2]' coords [3]);  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: x = coords [2];  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: y = coords [3];  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: gp.AddBezier (x' y' coords [0]' coords [1]' coords [2]' coords [3]' coords [4]' coords [5]);  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: gp.AddBezier (x' y' coords [0]' coords [1]' coords [2]' coords [3]' coords [4]' coords [5]);  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: gp.AddBezier (x' y' coords [0]' coords [1]' coords [2]' coords [3]' coords [4]' coords [5]);  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: gp.AddBezier (x' y' coords [0]' coords [1]' coords [2]' coords [3]' coords [4]' coords [5]);  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: x = coords [4];  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: y = coords [5];  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertRegion,The following statement contains a magic number: if (shape.isRectangular ()) {  	int x = shape.getLoX ();  	int y = shape.getLoY ();  	int w = shape.getHiX () - x;  	int h = shape.getHiY () - y;  	if (w < 0 || h < 0) {  		return new Region ();  	} else {  		return new Region (new Rectangle (x' y' w' h));  	}  } else {  	using (GraphicsPath path = new GraphicsPath ()) {  		sun.java2d.pipe.SpanIterator iter = shape.getSpanIterator ();  		int[] box = new int[4];  		while (iter.nextSpan (box)) {  			path.AddRectangle (new Rectangle (box [0]' box [1]' box [2] - box [0]' box [3] - box [1]));  		}  		return new Region (path);  	}  }  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertRegion,The following statement contains a magic number: if (shape.isRectangular ()) {  	int x = shape.getLoX ();  	int y = shape.getLoY ();  	int w = shape.getHiX () - x;  	int h = shape.getHiY () - y;  	if (w < 0 || h < 0) {  		return new Region ();  	} else {  		return new Region (new Rectangle (x' y' w' h));  	}  } else {  	using (GraphicsPath path = new GraphicsPath ()) {  		sun.java2d.pipe.SpanIterator iter = shape.getSpanIterator ();  		int[] box = new int[4];  		while (iter.nextSpan (box)) {  			path.AddRectangle (new Rectangle (box [0]' box [1]' box [2] - box [0]' box [3] - box [1]));  		}  		return new Region (path);  	}  }  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertRegion,The following statement contains a magic number: if (shape.isRectangular ()) {  	int x = shape.getLoX ();  	int y = shape.getLoY ();  	int w = shape.getHiX () - x;  	int h = shape.getHiY () - y;  	if (w < 0 || h < 0) {  		return new Region ();  	} else {  		return new Region (new Rectangle (x' y' w' h));  	}  } else {  	using (GraphicsPath path = new GraphicsPath ()) {  		sun.java2d.pipe.SpanIterator iter = shape.getSpanIterator ();  		int[] box = new int[4];  		while (iter.nextSpan (box)) {  			path.AddRectangle (new Rectangle (box [0]' box [1]' box [2] - box [0]' box [3] - box [1]));  		}  		return new Region (path);  	}  }  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertRegion,The following statement contains a magic number: using (GraphicsPath path = new GraphicsPath ()) {  	sun.java2d.pipe.SpanIterator iter = shape.getSpanIterator ();  	int[] box = new int[4];  	while (iter.nextSpan (box)) {  		path.AddRectangle (new Rectangle (box [0]' box [1]' box [2] - box [0]' box [3] - box [1]));  	}  	return new Region (path);  }  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertRegion,The following statement contains a magic number: using (GraphicsPath path = new GraphicsPath ()) {  	sun.java2d.pipe.SpanIterator iter = shape.getSpanIterator ();  	int[] box = new int[4];  	while (iter.nextSpan (box)) {  		path.AddRectangle (new Rectangle (box [0]' box [1]' box [2] - box [0]' box [3] - box [1]));  	}  	return new Region (path);  }  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertRegion,The following statement contains a magic number: using (GraphicsPath path = new GraphicsPath ()) {  	sun.java2d.pipe.SpanIterator iter = shape.getSpanIterator ();  	int[] box = new int[4];  	while (iter.nextSpan (box)) {  		path.AddRectangle (new Rectangle (box [0]' box [1]' box [2] - box [0]' box [3] - box [1]));  	}  	return new Region (path);  }  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertRegion,The following statement contains a magic number: while (iter.nextSpan (box)) {  	path.AddRectangle (new Rectangle (box [0]' box [1]' box [2] - box [0]' box [3] - box [1]));  }  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertRegion,The following statement contains a magic number: while (iter.nextSpan (box)) {  	path.AddRectangle (new Rectangle (box [0]' box [1]' box [2] - box [0]' box [3] - box [1]));  }  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertRegion,The following statement contains a magic number: path.AddRectangle (new Rectangle (box [0]' box [1]' box [2] - box [0]' box [3] - box [1]));  
Magic Number,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertRegion,The following statement contains a magic number: path.AddRectangle (new Rectangle (box [0]' box [1]' box [2] - box [0]' box [3] - box [1]));  
Magic Number,ikvm.awt,C2J,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertFont,The following statement contains a magic number: if (font.Unit != GraphicsUnit.Pixel) {  	size = font.SizeInPoints * java.awt.Toolkit.getDefaultToolkit ().getScreenResolution () / 72;  }  
Magic Number,ikvm.awt,C2J,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertFont,The following statement contains a magic number: size = font.SizeInPoints * java.awt.Toolkit.getDefaultToolkit ().getScreenResolution () / 72;  
Magic Number,ikvm.awt,C2J,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: for (int i = 0; i < path.PointCount; i++) {  	byte pathType = path.PathTypes [i];  	int type = pathType & 0x07;  	PointF point = path.PathPoints [i];  	switch (type) {  	case 0:  		// Indicates that the point is the start of a figure.   		shape.moveTo (point.X' point.Y);  		break;  	case 1:  		// Indicates that the point is one of the two endpoints of a line.   		shape.lineTo (point.X' point.Y);  		break;  	case 3:  		// Indicates that the point is an endpoint or control point of a cubic B�zier spline.   		PointF point2 = path.PathPoints [++i];  		PointF point3 = path.PathPoints [++i];  		shape.curveTo (point.X' point.Y' point2.X' point2.Y' point3.X' point3.Y);  		pathType = path.PathTypes [i];  		break;  	default:  		Console.WriteLine ("Unknown GraphicsPath type: " + type);  		break;  	}  	if ((pathType & 0x80) > 0) {  		// Specifies that the point is the last point in a closed subpath (figure).  		shape.closePath ();  	}  }  
Magic Number,ikvm.awt,C2J,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: switch (type) {  case 0:  	// Indicates that the point is the start of a figure.   	shape.moveTo (point.X' point.Y);  	break;  case 1:  	// Indicates that the point is one of the two endpoints of a line.   	shape.lineTo (point.X' point.Y);  	break;  case 3:  	// Indicates that the point is an endpoint or control point of a cubic B�zier spline.   	PointF point2 = path.PathPoints [++i];  	PointF point3 = path.PathPoints [++i];  	shape.curveTo (point.X' point.Y' point2.X' point2.Y' point3.X' point3.Y);  	pathType = path.PathTypes [i];  	break;  default:  	Console.WriteLine ("Unknown GraphicsPath type: " + type);  	break;  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,NetGraphics,The following statement contains a magic number: if (font == null) {  	font = new java.awt.Font ("Dialog"' java.awt.Font.PLAIN' 12);  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,NetGraphics,The following statement contains a magic number: font = new java.awt.Font ("Dialog"' java.awt.Font.PLAIN' 12);  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawArc,The following statement contains a magic number: g.DrawArc (pen' x' y' width' height' 360 - startAngle - arcAngle' arcAngle);  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,fill3DRect,The following statement contains a magic number: fillRect (x + 1' y + 1' width - 2' height - 2);  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,fill3DRect,The following statement contains a magic number: fillRect (x + 1' y + 1' width - 2' height - 2);  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,fill3DRect,The following statement contains a magic number: fillRect (x + 1' y' width - 2' 1);  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,fillArc,The following statement contains a magic number: g.FillPie (brush' x' y' width' height' 360 - startAngle - arcAngle' arcAngle);  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: if (paint is java.awt.GradientPaint) {  	java.awt.GradientPaint gradient = (java.awt.GradientPaint)paint;  	LinearGradientBrush linear;  	if (gradient.isCyclic ()) {  		linear = new LinearGradientBrush (J2C.ConvertPoint (gradient.getPoint1 ())' J2C.ConvertPoint (gradient.getPoint2 ())' composite.GetColor (gradient.getColor1 ())' composite.GetColor (gradient.getColor2 ()));  	} else {  		//HACK because .NET does not support continue gradient like Java else Tile Gradient  		//that we receize the rectangle very large (factor z) and set 4 color values  		// a exact solution will calculate the size of the Graphics with the current transform  		Color color1 = composite.GetColor (gradient.getColor1 ());  		Color color2 = composite.GetColor (gradient.getColor2 ());  		float x1 = (float)gradient.getPoint1 ().getX ();  		float x2 = (float)gradient.getPoint2 ().getX ();  		float y1 = (float)gradient.getPoint1 ().getY ();  		float y2 = (float)gradient.getPoint2 ().getY ();  		float diffX = x2 - x1;  		float diffY = y2 - y1;  		const float z = 60;  		//HACK zoom factor' with a larger factor .NET will make the gradient wider.  		linear = new LinearGradientBrush (new PointF (x1 - z * diffX' y1 - z * diffY)' new PointF (x2 + z * diffX' y2 + z * diffY)' color1' color1);  		ColorBlend colorBlend = new ColorBlend (4);  		Color[] colors = colorBlend.Colors;  		colors [0] = colors [1] = color1;  		colors [2] = colors [3] = color2;  		float[] positions = colorBlend.Positions;  		positions [1] = z / (2 * z + 1);  		positions [2] = (z + 1) / (2 * z + 1);  		positions [3] = 1.0f;  		linear.InterpolationColors = colorBlend;  	}  	linear.WrapMode = WrapMode.TileFlipXY;  	brush = linear;  	pen.Brush = brush;  	return;  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: if (paint is java.awt.GradientPaint) {  	java.awt.GradientPaint gradient = (java.awt.GradientPaint)paint;  	LinearGradientBrush linear;  	if (gradient.isCyclic ()) {  		linear = new LinearGradientBrush (J2C.ConvertPoint (gradient.getPoint1 ())' J2C.ConvertPoint (gradient.getPoint2 ())' composite.GetColor (gradient.getColor1 ())' composite.GetColor (gradient.getColor2 ()));  	} else {  		//HACK because .NET does not support continue gradient like Java else Tile Gradient  		//that we receize the rectangle very large (factor z) and set 4 color values  		// a exact solution will calculate the size of the Graphics with the current transform  		Color color1 = composite.GetColor (gradient.getColor1 ());  		Color color2 = composite.GetColor (gradient.getColor2 ());  		float x1 = (float)gradient.getPoint1 ().getX ();  		float x2 = (float)gradient.getPoint2 ().getX ();  		float y1 = (float)gradient.getPoint1 ().getY ();  		float y2 = (float)gradient.getPoint2 ().getY ();  		float diffX = x2 - x1;  		float diffY = y2 - y1;  		const float z = 60;  		//HACK zoom factor' with a larger factor .NET will make the gradient wider.  		linear = new LinearGradientBrush (new PointF (x1 - z * diffX' y1 - z * diffY)' new PointF (x2 + z * diffX' y2 + z * diffY)' color1' color1);  		ColorBlend colorBlend = new ColorBlend (4);  		Color[] colors = colorBlend.Colors;  		colors [0] = colors [1] = color1;  		colors [2] = colors [3] = color2;  		float[] positions = colorBlend.Positions;  		positions [1] = z / (2 * z + 1);  		positions [2] = (z + 1) / (2 * z + 1);  		positions [3] = 1.0f;  		linear.InterpolationColors = colorBlend;  	}  	linear.WrapMode = WrapMode.TileFlipXY;  	brush = linear;  	pen.Brush = brush;  	return;  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: if (paint is java.awt.GradientPaint) {  	java.awt.GradientPaint gradient = (java.awt.GradientPaint)paint;  	LinearGradientBrush linear;  	if (gradient.isCyclic ()) {  		linear = new LinearGradientBrush (J2C.ConvertPoint (gradient.getPoint1 ())' J2C.ConvertPoint (gradient.getPoint2 ())' composite.GetColor (gradient.getColor1 ())' composite.GetColor (gradient.getColor2 ()));  	} else {  		//HACK because .NET does not support continue gradient like Java else Tile Gradient  		//that we receize the rectangle very large (factor z) and set 4 color values  		// a exact solution will calculate the size of the Graphics with the current transform  		Color color1 = composite.GetColor (gradient.getColor1 ());  		Color color2 = composite.GetColor (gradient.getColor2 ());  		float x1 = (float)gradient.getPoint1 ().getX ();  		float x2 = (float)gradient.getPoint2 ().getX ();  		float y1 = (float)gradient.getPoint1 ().getY ();  		float y2 = (float)gradient.getPoint2 ().getY ();  		float diffX = x2 - x1;  		float diffY = y2 - y1;  		const float z = 60;  		//HACK zoom factor' with a larger factor .NET will make the gradient wider.  		linear = new LinearGradientBrush (new PointF (x1 - z * diffX' y1 - z * diffY)' new PointF (x2 + z * diffX' y2 + z * diffY)' color1' color1);  		ColorBlend colorBlend = new ColorBlend (4);  		Color[] colors = colorBlend.Colors;  		colors [0] = colors [1] = color1;  		colors [2] = colors [3] = color2;  		float[] positions = colorBlend.Positions;  		positions [1] = z / (2 * z + 1);  		positions [2] = (z + 1) / (2 * z + 1);  		positions [3] = 1.0f;  		linear.InterpolationColors = colorBlend;  	}  	linear.WrapMode = WrapMode.TileFlipXY;  	brush = linear;  	pen.Brush = brush;  	return;  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: if (paint is java.awt.GradientPaint) {  	java.awt.GradientPaint gradient = (java.awt.GradientPaint)paint;  	LinearGradientBrush linear;  	if (gradient.isCyclic ()) {  		linear = new LinearGradientBrush (J2C.ConvertPoint (gradient.getPoint1 ())' J2C.ConvertPoint (gradient.getPoint2 ())' composite.GetColor (gradient.getColor1 ())' composite.GetColor (gradient.getColor2 ()));  	} else {  		//HACK because .NET does not support continue gradient like Java else Tile Gradient  		//that we receize the rectangle very large (factor z) and set 4 color values  		// a exact solution will calculate the size of the Graphics with the current transform  		Color color1 = composite.GetColor (gradient.getColor1 ());  		Color color2 = composite.GetColor (gradient.getColor2 ());  		float x1 = (float)gradient.getPoint1 ().getX ();  		float x2 = (float)gradient.getPoint2 ().getX ();  		float y1 = (float)gradient.getPoint1 ().getY ();  		float y2 = (float)gradient.getPoint2 ().getY ();  		float diffX = x2 - x1;  		float diffY = y2 - y1;  		const float z = 60;  		//HACK zoom factor' with a larger factor .NET will make the gradient wider.  		linear = new LinearGradientBrush (new PointF (x1 - z * diffX' y1 - z * diffY)' new PointF (x2 + z * diffX' y2 + z * diffY)' color1' color1);  		ColorBlend colorBlend = new ColorBlend (4);  		Color[] colors = colorBlend.Colors;  		colors [0] = colors [1] = color1;  		colors [2] = colors [3] = color2;  		float[] positions = colorBlend.Positions;  		positions [1] = z / (2 * z + 1);  		positions [2] = (z + 1) / (2 * z + 1);  		positions [3] = 1.0f;  		linear.InterpolationColors = colorBlend;  	}  	linear.WrapMode = WrapMode.TileFlipXY;  	brush = linear;  	pen.Brush = brush;  	return;  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: if (paint is java.awt.GradientPaint) {  	java.awt.GradientPaint gradient = (java.awt.GradientPaint)paint;  	LinearGradientBrush linear;  	if (gradient.isCyclic ()) {  		linear = new LinearGradientBrush (J2C.ConvertPoint (gradient.getPoint1 ())' J2C.ConvertPoint (gradient.getPoint2 ())' composite.GetColor (gradient.getColor1 ())' composite.GetColor (gradient.getColor2 ()));  	} else {  		//HACK because .NET does not support continue gradient like Java else Tile Gradient  		//that we receize the rectangle very large (factor z) and set 4 color values  		// a exact solution will calculate the size of the Graphics with the current transform  		Color color1 = composite.GetColor (gradient.getColor1 ());  		Color color2 = composite.GetColor (gradient.getColor2 ());  		float x1 = (float)gradient.getPoint1 ().getX ();  		float x2 = (float)gradient.getPoint2 ().getX ();  		float y1 = (float)gradient.getPoint1 ().getY ();  		float y2 = (float)gradient.getPoint2 ().getY ();  		float diffX = x2 - x1;  		float diffY = y2 - y1;  		const float z = 60;  		//HACK zoom factor' with a larger factor .NET will make the gradient wider.  		linear = new LinearGradientBrush (new PointF (x1 - z * diffX' y1 - z * diffY)' new PointF (x2 + z * diffX' y2 + z * diffY)' color1' color1);  		ColorBlend colorBlend = new ColorBlend (4);  		Color[] colors = colorBlend.Colors;  		colors [0] = colors [1] = color1;  		colors [2] = colors [3] = color2;  		float[] positions = colorBlend.Positions;  		positions [1] = z / (2 * z + 1);  		positions [2] = (z + 1) / (2 * z + 1);  		positions [3] = 1.0f;  		linear.InterpolationColors = colorBlend;  	}  	linear.WrapMode = WrapMode.TileFlipXY;  	brush = linear;  	pen.Brush = brush;  	return;  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: if (paint is java.awt.GradientPaint) {  	java.awt.GradientPaint gradient = (java.awt.GradientPaint)paint;  	LinearGradientBrush linear;  	if (gradient.isCyclic ()) {  		linear = new LinearGradientBrush (J2C.ConvertPoint (gradient.getPoint1 ())' J2C.ConvertPoint (gradient.getPoint2 ())' composite.GetColor (gradient.getColor1 ())' composite.GetColor (gradient.getColor2 ()));  	} else {  		//HACK because .NET does not support continue gradient like Java else Tile Gradient  		//that we receize the rectangle very large (factor z) and set 4 color values  		// a exact solution will calculate the size of the Graphics with the current transform  		Color color1 = composite.GetColor (gradient.getColor1 ());  		Color color2 = composite.GetColor (gradient.getColor2 ());  		float x1 = (float)gradient.getPoint1 ().getX ();  		float x2 = (float)gradient.getPoint2 ().getX ();  		float y1 = (float)gradient.getPoint1 ().getY ();  		float y2 = (float)gradient.getPoint2 ().getY ();  		float diffX = x2 - x1;  		float diffY = y2 - y1;  		const float z = 60;  		//HACK zoom factor' with a larger factor .NET will make the gradient wider.  		linear = new LinearGradientBrush (new PointF (x1 - z * diffX' y1 - z * diffY)' new PointF (x2 + z * diffX' y2 + z * diffY)' color1' color1);  		ColorBlend colorBlend = new ColorBlend (4);  		Color[] colors = colorBlend.Colors;  		colors [0] = colors [1] = color1;  		colors [2] = colors [3] = color2;  		float[] positions = colorBlend.Positions;  		positions [1] = z / (2 * z + 1);  		positions [2] = (z + 1) / (2 * z + 1);  		positions [3] = 1.0f;  		linear.InterpolationColors = colorBlend;  	}  	linear.WrapMode = WrapMode.TileFlipXY;  	brush = linear;  	pen.Brush = brush;  	return;  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: if (paint is java.awt.GradientPaint) {  	java.awt.GradientPaint gradient = (java.awt.GradientPaint)paint;  	LinearGradientBrush linear;  	if (gradient.isCyclic ()) {  		linear = new LinearGradientBrush (J2C.ConvertPoint (gradient.getPoint1 ())' J2C.ConvertPoint (gradient.getPoint2 ())' composite.GetColor (gradient.getColor1 ())' composite.GetColor (gradient.getColor2 ()));  	} else {  		//HACK because .NET does not support continue gradient like Java else Tile Gradient  		//that we receize the rectangle very large (factor z) and set 4 color values  		// a exact solution will calculate the size of the Graphics with the current transform  		Color color1 = composite.GetColor (gradient.getColor1 ());  		Color color2 = composite.GetColor (gradient.getColor2 ());  		float x1 = (float)gradient.getPoint1 ().getX ();  		float x2 = (float)gradient.getPoint2 ().getX ();  		float y1 = (float)gradient.getPoint1 ().getY ();  		float y2 = (float)gradient.getPoint2 ().getY ();  		float diffX = x2 - x1;  		float diffY = y2 - y1;  		const float z = 60;  		//HACK zoom factor' with a larger factor .NET will make the gradient wider.  		linear = new LinearGradientBrush (new PointF (x1 - z * diffX' y1 - z * diffY)' new PointF (x2 + z * diffX' y2 + z * diffY)' color1' color1);  		ColorBlend colorBlend = new ColorBlend (4);  		Color[] colors = colorBlend.Colors;  		colors [0] = colors [1] = color1;  		colors [2] = colors [3] = color2;  		float[] positions = colorBlend.Positions;  		positions [1] = z / (2 * z + 1);  		positions [2] = (z + 1) / (2 * z + 1);  		positions [3] = 1.0f;  		linear.InterpolationColors = colorBlend;  	}  	linear.WrapMode = WrapMode.TileFlipXY;  	brush = linear;  	pen.Brush = brush;  	return;  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: if (paint is java.awt.GradientPaint) {  	java.awt.GradientPaint gradient = (java.awt.GradientPaint)paint;  	LinearGradientBrush linear;  	if (gradient.isCyclic ()) {  		linear = new LinearGradientBrush (J2C.ConvertPoint (gradient.getPoint1 ())' J2C.ConvertPoint (gradient.getPoint2 ())' composite.GetColor (gradient.getColor1 ())' composite.GetColor (gradient.getColor2 ()));  	} else {  		//HACK because .NET does not support continue gradient like Java else Tile Gradient  		//that we receize the rectangle very large (factor z) and set 4 color values  		// a exact solution will calculate the size of the Graphics with the current transform  		Color color1 = composite.GetColor (gradient.getColor1 ());  		Color color2 = composite.GetColor (gradient.getColor2 ());  		float x1 = (float)gradient.getPoint1 ().getX ();  		float x2 = (float)gradient.getPoint2 ().getX ();  		float y1 = (float)gradient.getPoint1 ().getY ();  		float y2 = (float)gradient.getPoint2 ().getY ();  		float diffX = x2 - x1;  		float diffY = y2 - y1;  		const float z = 60;  		//HACK zoom factor' with a larger factor .NET will make the gradient wider.  		linear = new LinearGradientBrush (new PointF (x1 - z * diffX' y1 - z * diffY)' new PointF (x2 + z * diffX' y2 + z * diffY)' color1' color1);  		ColorBlend colorBlend = new ColorBlend (4);  		Color[] colors = colorBlend.Colors;  		colors [0] = colors [1] = color1;  		colors [2] = colors [3] = color2;  		float[] positions = colorBlend.Positions;  		positions [1] = z / (2 * z + 1);  		positions [2] = (z + 1) / (2 * z + 1);  		positions [3] = 1.0f;  		linear.InterpolationColors = colorBlend;  	}  	linear.WrapMode = WrapMode.TileFlipXY;  	brush = linear;  	pen.Brush = brush;  	return;  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: if (gradient.isCyclic ()) {  	linear = new LinearGradientBrush (J2C.ConvertPoint (gradient.getPoint1 ())' J2C.ConvertPoint (gradient.getPoint2 ())' composite.GetColor (gradient.getColor1 ())' composite.GetColor (gradient.getColor2 ()));  } else {  	//HACK because .NET does not support continue gradient like Java else Tile Gradient  	//that we receize the rectangle very large (factor z) and set 4 color values  	// a exact solution will calculate the size of the Graphics with the current transform  	Color color1 = composite.GetColor (gradient.getColor1 ());  	Color color2 = composite.GetColor (gradient.getColor2 ());  	float x1 = (float)gradient.getPoint1 ().getX ();  	float x2 = (float)gradient.getPoint2 ().getX ();  	float y1 = (float)gradient.getPoint1 ().getY ();  	float y2 = (float)gradient.getPoint2 ().getY ();  	float diffX = x2 - x1;  	float diffY = y2 - y1;  	const float z = 60;  	//HACK zoom factor' with a larger factor .NET will make the gradient wider.  	linear = new LinearGradientBrush (new PointF (x1 - z * diffX' y1 - z * diffY)' new PointF (x2 + z * diffX' y2 + z * diffY)' color1' color1);  	ColorBlend colorBlend = new ColorBlend (4);  	Color[] colors = colorBlend.Colors;  	colors [0] = colors [1] = color1;  	colors [2] = colors [3] = color2;  	float[] positions = colorBlend.Positions;  	positions [1] = z / (2 * z + 1);  	positions [2] = (z + 1) / (2 * z + 1);  	positions [3] = 1.0f;  	linear.InterpolationColors = colorBlend;  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: if (gradient.isCyclic ()) {  	linear = new LinearGradientBrush (J2C.ConvertPoint (gradient.getPoint1 ())' J2C.ConvertPoint (gradient.getPoint2 ())' composite.GetColor (gradient.getColor1 ())' composite.GetColor (gradient.getColor2 ()));  } else {  	//HACK because .NET does not support continue gradient like Java else Tile Gradient  	//that we receize the rectangle very large (factor z) and set 4 color values  	// a exact solution will calculate the size of the Graphics with the current transform  	Color color1 = composite.GetColor (gradient.getColor1 ());  	Color color2 = composite.GetColor (gradient.getColor2 ());  	float x1 = (float)gradient.getPoint1 ().getX ();  	float x2 = (float)gradient.getPoint2 ().getX ();  	float y1 = (float)gradient.getPoint1 ().getY ();  	float y2 = (float)gradient.getPoint2 ().getY ();  	float diffX = x2 - x1;  	float diffY = y2 - y1;  	const float z = 60;  	//HACK zoom factor' with a larger factor .NET will make the gradient wider.  	linear = new LinearGradientBrush (new PointF (x1 - z * diffX' y1 - z * diffY)' new PointF (x2 + z * diffX' y2 + z * diffY)' color1' color1);  	ColorBlend colorBlend = new ColorBlend (4);  	Color[] colors = colorBlend.Colors;  	colors [0] = colors [1] = color1;  	colors [2] = colors [3] = color2;  	float[] positions = colorBlend.Positions;  	positions [1] = z / (2 * z + 1);  	positions [2] = (z + 1) / (2 * z + 1);  	positions [3] = 1.0f;  	linear.InterpolationColors = colorBlend;  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: if (gradient.isCyclic ()) {  	linear = new LinearGradientBrush (J2C.ConvertPoint (gradient.getPoint1 ())' J2C.ConvertPoint (gradient.getPoint2 ())' composite.GetColor (gradient.getColor1 ())' composite.GetColor (gradient.getColor2 ()));  } else {  	//HACK because .NET does not support continue gradient like Java else Tile Gradient  	//that we receize the rectangle very large (factor z) and set 4 color values  	// a exact solution will calculate the size of the Graphics with the current transform  	Color color1 = composite.GetColor (gradient.getColor1 ());  	Color color2 = composite.GetColor (gradient.getColor2 ());  	float x1 = (float)gradient.getPoint1 ().getX ();  	float x2 = (float)gradient.getPoint2 ().getX ();  	float y1 = (float)gradient.getPoint1 ().getY ();  	float y2 = (float)gradient.getPoint2 ().getY ();  	float diffX = x2 - x1;  	float diffY = y2 - y1;  	const float z = 60;  	//HACK zoom factor' with a larger factor .NET will make the gradient wider.  	linear = new LinearGradientBrush (new PointF (x1 - z * diffX' y1 - z * diffY)' new PointF (x2 + z * diffX' y2 + z * diffY)' color1' color1);  	ColorBlend colorBlend = new ColorBlend (4);  	Color[] colors = colorBlend.Colors;  	colors [0] = colors [1] = color1;  	colors [2] = colors [3] = color2;  	float[] positions = colorBlend.Positions;  	positions [1] = z / (2 * z + 1);  	positions [2] = (z + 1) / (2 * z + 1);  	positions [3] = 1.0f;  	linear.InterpolationColors = colorBlend;  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: if (gradient.isCyclic ()) {  	linear = new LinearGradientBrush (J2C.ConvertPoint (gradient.getPoint1 ())' J2C.ConvertPoint (gradient.getPoint2 ())' composite.GetColor (gradient.getColor1 ())' composite.GetColor (gradient.getColor2 ()));  } else {  	//HACK because .NET does not support continue gradient like Java else Tile Gradient  	//that we receize the rectangle very large (factor z) and set 4 color values  	// a exact solution will calculate the size of the Graphics with the current transform  	Color color1 = composite.GetColor (gradient.getColor1 ());  	Color color2 = composite.GetColor (gradient.getColor2 ());  	float x1 = (float)gradient.getPoint1 ().getX ();  	float x2 = (float)gradient.getPoint2 ().getX ();  	float y1 = (float)gradient.getPoint1 ().getY ();  	float y2 = (float)gradient.getPoint2 ().getY ();  	float diffX = x2 - x1;  	float diffY = y2 - y1;  	const float z = 60;  	//HACK zoom factor' with a larger factor .NET will make the gradient wider.  	linear = new LinearGradientBrush (new PointF (x1 - z * diffX' y1 - z * diffY)' new PointF (x2 + z * diffX' y2 + z * diffY)' color1' color1);  	ColorBlend colorBlend = new ColorBlend (4);  	Color[] colors = colorBlend.Colors;  	colors [0] = colors [1] = color1;  	colors [2] = colors [3] = color2;  	float[] positions = colorBlend.Positions;  	positions [1] = z / (2 * z + 1);  	positions [2] = (z + 1) / (2 * z + 1);  	positions [3] = 1.0f;  	linear.InterpolationColors = colorBlend;  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: if (gradient.isCyclic ()) {  	linear = new LinearGradientBrush (J2C.ConvertPoint (gradient.getPoint1 ())' J2C.ConvertPoint (gradient.getPoint2 ())' composite.GetColor (gradient.getColor1 ())' composite.GetColor (gradient.getColor2 ()));  } else {  	//HACK because .NET does not support continue gradient like Java else Tile Gradient  	//that we receize the rectangle very large (factor z) and set 4 color values  	// a exact solution will calculate the size of the Graphics with the current transform  	Color color1 = composite.GetColor (gradient.getColor1 ());  	Color color2 = composite.GetColor (gradient.getColor2 ());  	float x1 = (float)gradient.getPoint1 ().getX ();  	float x2 = (float)gradient.getPoint2 ().getX ();  	float y1 = (float)gradient.getPoint1 ().getY ();  	float y2 = (float)gradient.getPoint2 ().getY ();  	float diffX = x2 - x1;  	float diffY = y2 - y1;  	const float z = 60;  	//HACK zoom factor' with a larger factor .NET will make the gradient wider.  	linear = new LinearGradientBrush (new PointF (x1 - z * diffX' y1 - z * diffY)' new PointF (x2 + z * diffX' y2 + z * diffY)' color1' color1);  	ColorBlend colorBlend = new ColorBlend (4);  	Color[] colors = colorBlend.Colors;  	colors [0] = colors [1] = color1;  	colors [2] = colors [3] = color2;  	float[] positions = colorBlend.Positions;  	positions [1] = z / (2 * z + 1);  	positions [2] = (z + 1) / (2 * z + 1);  	positions [3] = 1.0f;  	linear.InterpolationColors = colorBlend;  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: if (gradient.isCyclic ()) {  	linear = new LinearGradientBrush (J2C.ConvertPoint (gradient.getPoint1 ())' J2C.ConvertPoint (gradient.getPoint2 ())' composite.GetColor (gradient.getColor1 ())' composite.GetColor (gradient.getColor2 ()));  } else {  	//HACK because .NET does not support continue gradient like Java else Tile Gradient  	//that we receize the rectangle very large (factor z) and set 4 color values  	// a exact solution will calculate the size of the Graphics with the current transform  	Color color1 = composite.GetColor (gradient.getColor1 ());  	Color color2 = composite.GetColor (gradient.getColor2 ());  	float x1 = (float)gradient.getPoint1 ().getX ();  	float x2 = (float)gradient.getPoint2 ().getX ();  	float y1 = (float)gradient.getPoint1 ().getY ();  	float y2 = (float)gradient.getPoint2 ().getY ();  	float diffX = x2 - x1;  	float diffY = y2 - y1;  	const float z = 60;  	//HACK zoom factor' with a larger factor .NET will make the gradient wider.  	linear = new LinearGradientBrush (new PointF (x1 - z * diffX' y1 - z * diffY)' new PointF (x2 + z * diffX' y2 + z * diffY)' color1' color1);  	ColorBlend colorBlend = new ColorBlend (4);  	Color[] colors = colorBlend.Colors;  	colors [0] = colors [1] = color1;  	colors [2] = colors [3] = color2;  	float[] positions = colorBlend.Positions;  	positions [1] = z / (2 * z + 1);  	positions [2] = (z + 1) / (2 * z + 1);  	positions [3] = 1.0f;  	linear.InterpolationColors = colorBlend;  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: if (gradient.isCyclic ()) {  	linear = new LinearGradientBrush (J2C.ConvertPoint (gradient.getPoint1 ())' J2C.ConvertPoint (gradient.getPoint2 ())' composite.GetColor (gradient.getColor1 ())' composite.GetColor (gradient.getColor2 ()));  } else {  	//HACK because .NET does not support continue gradient like Java else Tile Gradient  	//that we receize the rectangle very large (factor z) and set 4 color values  	// a exact solution will calculate the size of the Graphics with the current transform  	Color color1 = composite.GetColor (gradient.getColor1 ());  	Color color2 = composite.GetColor (gradient.getColor2 ());  	float x1 = (float)gradient.getPoint1 ().getX ();  	float x2 = (float)gradient.getPoint2 ().getX ();  	float y1 = (float)gradient.getPoint1 ().getY ();  	float y2 = (float)gradient.getPoint2 ().getY ();  	float diffX = x2 - x1;  	float diffY = y2 - y1;  	const float z = 60;  	//HACK zoom factor' with a larger factor .NET will make the gradient wider.  	linear = new LinearGradientBrush (new PointF (x1 - z * diffX' y1 - z * diffY)' new PointF (x2 + z * diffX' y2 + z * diffY)' color1' color1);  	ColorBlend colorBlend = new ColorBlend (4);  	Color[] colors = colorBlend.Colors;  	colors [0] = colors [1] = color1;  	colors [2] = colors [3] = color2;  	float[] positions = colorBlend.Positions;  	positions [1] = z / (2 * z + 1);  	positions [2] = (z + 1) / (2 * z + 1);  	positions [3] = 1.0f;  	linear.InterpolationColors = colorBlend;  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: if (gradient.isCyclic ()) {  	linear = new LinearGradientBrush (J2C.ConvertPoint (gradient.getPoint1 ())' J2C.ConvertPoint (gradient.getPoint2 ())' composite.GetColor (gradient.getColor1 ())' composite.GetColor (gradient.getColor2 ()));  } else {  	//HACK because .NET does not support continue gradient like Java else Tile Gradient  	//that we receize the rectangle very large (factor z) and set 4 color values  	// a exact solution will calculate the size of the Graphics with the current transform  	Color color1 = composite.GetColor (gradient.getColor1 ());  	Color color2 = composite.GetColor (gradient.getColor2 ());  	float x1 = (float)gradient.getPoint1 ().getX ();  	float x2 = (float)gradient.getPoint2 ().getX ();  	float y1 = (float)gradient.getPoint1 ().getY ();  	float y2 = (float)gradient.getPoint2 ().getY ();  	float diffX = x2 - x1;  	float diffY = y2 - y1;  	const float z = 60;  	//HACK zoom factor' with a larger factor .NET will make the gradient wider.  	linear = new LinearGradientBrush (new PointF (x1 - z * diffX' y1 - z * diffY)' new PointF (x2 + z * diffX' y2 + z * diffY)' color1' color1);  	ColorBlend colorBlend = new ColorBlend (4);  	Color[] colors = colorBlend.Colors;  	colors [0] = colors [1] = color1;  	colors [2] = colors [3] = color2;  	float[] positions = colorBlend.Positions;  	positions [1] = z / (2 * z + 1);  	positions [2] = (z + 1) / (2 * z + 1);  	positions [3] = 1.0f;  	linear.InterpolationColors = colorBlend;  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: colors [2] = colors [3] = color2;  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: colors [2] = colors [3] = color2;  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: positions [1] = z / (2 * z + 1);  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: positions [2] = (z + 1) / (2 * z + 1);  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: positions [2] = (z + 1) / (2 * z + 1);  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: positions [3] = 1.0f;  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: if (paint is java.awt.LinearGradientPaint) {  	java.awt.LinearGradientPaint gradient = (java.awt.LinearGradientPaint)paint;  	PointF start = J2C.ConvertPoint (gradient.getStartPoint ());  	PointF end = J2C.ConvertPoint (gradient.getEndPoint ());  	java.awt.Color[] javaColors = gradient.getColors ();  	ColorBlend colorBlend;  	Color[] colors;  	bool noCycle = gradient.getCycleMethod () == java.awt.MultipleGradientPaint.CycleMethod.NO_CYCLE;  	if (noCycle) {  		//HACK because .NET does not support continue gradient like Java else Tile Gradient  		//that we receize the rectangle very large (factor z) and set 2 additional color values  		//an exact solution will calculate the size of the Graphics with the current transform  		float diffX = end.X - start.X;  		float diffY = end.Y - start.Y;  		SizeF size = GetSize ();  		//HACK zoom factor' with a larger factor .NET will make the gradient wider.  		float z = Math.Min (10' Math.Max (size.Width / diffX' size.Height / diffY));  		start.X -= z * diffX;  		start.Y -= z * diffY;  		end.X += z * diffX;  		end.Y += z * diffY;  		colorBlend = new ColorBlend (javaColors.Length + 2);  		colors = colorBlend.Colors;  		float[] fractions = gradient.getFractions ();  		float[] positions = colorBlend.Positions;  		for (int i = 0; i < javaColors.Length; i++) {  			colors [i + 1] = composite.GetColor (javaColors [i]);  			positions [i + 1] = (z + fractions [i]) / (2 * z + 1);  		}  		colors [0] = colors [1];  		colors [colors.Length - 1] = colors [colors.Length - 2];  		positions [positions.Length - 1] = 1.0f;  	} else {  		colorBlend = new ColorBlend (javaColors.Length);  		colors = colorBlend.Colors;  		colorBlend.Positions = gradient.getFractions ();  		for (int i = 0; i < javaColors.Length; i++) {  			colors [i] = composite.GetColor (javaColors [i]);  		}  	}  	LinearGradientBrush linear = new LinearGradientBrush (start' end' colors [0]' colors [colors.Length - 1]);  	linear.InterpolationColors = colorBlend;  	switch (gradient.getCycleMethod ().ordinal ()) {  	case (int)java.awt.MultipleGradientPaint.CycleMethod.__Enum.NO_CYCLE:  	case (int)java.awt.MultipleGradientPaint.CycleMethod.__Enum.REFLECT:  		linear.WrapMode = WrapMode.TileFlipXY;  		break;  	case (int)java.awt.MultipleGradientPaint.CycleMethod.__Enum.REPEAT:  		linear.WrapMode = WrapMode.Tile;  		break;  	}  	brush = linear;  	pen.Brush = brush;  	return;  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: if (paint is java.awt.LinearGradientPaint) {  	java.awt.LinearGradientPaint gradient = (java.awt.LinearGradientPaint)paint;  	PointF start = J2C.ConvertPoint (gradient.getStartPoint ());  	PointF end = J2C.ConvertPoint (gradient.getEndPoint ());  	java.awt.Color[] javaColors = gradient.getColors ();  	ColorBlend colorBlend;  	Color[] colors;  	bool noCycle = gradient.getCycleMethod () == java.awt.MultipleGradientPaint.CycleMethod.NO_CYCLE;  	if (noCycle) {  		//HACK because .NET does not support continue gradient like Java else Tile Gradient  		//that we receize the rectangle very large (factor z) and set 2 additional color values  		//an exact solution will calculate the size of the Graphics with the current transform  		float diffX = end.X - start.X;  		float diffY = end.Y - start.Y;  		SizeF size = GetSize ();  		//HACK zoom factor' with a larger factor .NET will make the gradient wider.  		float z = Math.Min (10' Math.Max (size.Width / diffX' size.Height / diffY));  		start.X -= z * diffX;  		start.Y -= z * diffY;  		end.X += z * diffX;  		end.Y += z * diffY;  		colorBlend = new ColorBlend (javaColors.Length + 2);  		colors = colorBlend.Colors;  		float[] fractions = gradient.getFractions ();  		float[] positions = colorBlend.Positions;  		for (int i = 0; i < javaColors.Length; i++) {  			colors [i + 1] = composite.GetColor (javaColors [i]);  			positions [i + 1] = (z + fractions [i]) / (2 * z + 1);  		}  		colors [0] = colors [1];  		colors [colors.Length - 1] = colors [colors.Length - 2];  		positions [positions.Length - 1] = 1.0f;  	} else {  		colorBlend = new ColorBlend (javaColors.Length);  		colors = colorBlend.Colors;  		colorBlend.Positions = gradient.getFractions ();  		for (int i = 0; i < javaColors.Length; i++) {  			colors [i] = composite.GetColor (javaColors [i]);  		}  	}  	LinearGradientBrush linear = new LinearGradientBrush (start' end' colors [0]' colors [colors.Length - 1]);  	linear.InterpolationColors = colorBlend;  	switch (gradient.getCycleMethod ().ordinal ()) {  	case (int)java.awt.MultipleGradientPaint.CycleMethod.__Enum.NO_CYCLE:  	case (int)java.awt.MultipleGradientPaint.CycleMethod.__Enum.REFLECT:  		linear.WrapMode = WrapMode.TileFlipXY;  		break;  	case (int)java.awt.MultipleGradientPaint.CycleMethod.__Enum.REPEAT:  		linear.WrapMode = WrapMode.Tile;  		break;  	}  	brush = linear;  	pen.Brush = brush;  	return;  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: if (paint is java.awt.LinearGradientPaint) {  	java.awt.LinearGradientPaint gradient = (java.awt.LinearGradientPaint)paint;  	PointF start = J2C.ConvertPoint (gradient.getStartPoint ());  	PointF end = J2C.ConvertPoint (gradient.getEndPoint ());  	java.awt.Color[] javaColors = gradient.getColors ();  	ColorBlend colorBlend;  	Color[] colors;  	bool noCycle = gradient.getCycleMethod () == java.awt.MultipleGradientPaint.CycleMethod.NO_CYCLE;  	if (noCycle) {  		//HACK because .NET does not support continue gradient like Java else Tile Gradient  		//that we receize the rectangle very large (factor z) and set 2 additional color values  		//an exact solution will calculate the size of the Graphics with the current transform  		float diffX = end.X - start.X;  		float diffY = end.Y - start.Y;  		SizeF size = GetSize ();  		//HACK zoom factor' with a larger factor .NET will make the gradient wider.  		float z = Math.Min (10' Math.Max (size.Width / diffX' size.Height / diffY));  		start.X -= z * diffX;  		start.Y -= z * diffY;  		end.X += z * diffX;  		end.Y += z * diffY;  		colorBlend = new ColorBlend (javaColors.Length + 2);  		colors = colorBlend.Colors;  		float[] fractions = gradient.getFractions ();  		float[] positions = colorBlend.Positions;  		for (int i = 0; i < javaColors.Length; i++) {  			colors [i + 1] = composite.GetColor (javaColors [i]);  			positions [i + 1] = (z + fractions [i]) / (2 * z + 1);  		}  		colors [0] = colors [1];  		colors [colors.Length - 1] = colors [colors.Length - 2];  		positions [positions.Length - 1] = 1.0f;  	} else {  		colorBlend = new ColorBlend (javaColors.Length);  		colors = colorBlend.Colors;  		colorBlend.Positions = gradient.getFractions ();  		for (int i = 0; i < javaColors.Length; i++) {  			colors [i] = composite.GetColor (javaColors [i]);  		}  	}  	LinearGradientBrush linear = new LinearGradientBrush (start' end' colors [0]' colors [colors.Length - 1]);  	linear.InterpolationColors = colorBlend;  	switch (gradient.getCycleMethod ().ordinal ()) {  	case (int)java.awt.MultipleGradientPaint.CycleMethod.__Enum.NO_CYCLE:  	case (int)java.awt.MultipleGradientPaint.CycleMethod.__Enum.REFLECT:  		linear.WrapMode = WrapMode.TileFlipXY;  		break;  	case (int)java.awt.MultipleGradientPaint.CycleMethod.__Enum.REPEAT:  		linear.WrapMode = WrapMode.Tile;  		break;  	}  	brush = linear;  	pen.Brush = brush;  	return;  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: if (paint is java.awt.LinearGradientPaint) {  	java.awt.LinearGradientPaint gradient = (java.awt.LinearGradientPaint)paint;  	PointF start = J2C.ConvertPoint (gradient.getStartPoint ());  	PointF end = J2C.ConvertPoint (gradient.getEndPoint ());  	java.awt.Color[] javaColors = gradient.getColors ();  	ColorBlend colorBlend;  	Color[] colors;  	bool noCycle = gradient.getCycleMethod () == java.awt.MultipleGradientPaint.CycleMethod.NO_CYCLE;  	if (noCycle) {  		//HACK because .NET does not support continue gradient like Java else Tile Gradient  		//that we receize the rectangle very large (factor z) and set 2 additional color values  		//an exact solution will calculate the size of the Graphics with the current transform  		float diffX = end.X - start.X;  		float diffY = end.Y - start.Y;  		SizeF size = GetSize ();  		//HACK zoom factor' with a larger factor .NET will make the gradient wider.  		float z = Math.Min (10' Math.Max (size.Width / diffX' size.Height / diffY));  		start.X -= z * diffX;  		start.Y -= z * diffY;  		end.X += z * diffX;  		end.Y += z * diffY;  		colorBlend = new ColorBlend (javaColors.Length + 2);  		colors = colorBlend.Colors;  		float[] fractions = gradient.getFractions ();  		float[] positions = colorBlend.Positions;  		for (int i = 0; i < javaColors.Length; i++) {  			colors [i + 1] = composite.GetColor (javaColors [i]);  			positions [i + 1] = (z + fractions [i]) / (2 * z + 1);  		}  		colors [0] = colors [1];  		colors [colors.Length - 1] = colors [colors.Length - 2];  		positions [positions.Length - 1] = 1.0f;  	} else {  		colorBlend = new ColorBlend (javaColors.Length);  		colors = colorBlend.Colors;  		colorBlend.Positions = gradient.getFractions ();  		for (int i = 0; i < javaColors.Length; i++) {  			colors [i] = composite.GetColor (javaColors [i]);  		}  	}  	LinearGradientBrush linear = new LinearGradientBrush (start' end' colors [0]' colors [colors.Length - 1]);  	linear.InterpolationColors = colorBlend;  	switch (gradient.getCycleMethod ().ordinal ()) {  	case (int)java.awt.MultipleGradientPaint.CycleMethod.__Enum.NO_CYCLE:  	case (int)java.awt.MultipleGradientPaint.CycleMethod.__Enum.REFLECT:  		linear.WrapMode = WrapMode.TileFlipXY;  		break;  	case (int)java.awt.MultipleGradientPaint.CycleMethod.__Enum.REPEAT:  		linear.WrapMode = WrapMode.Tile;  		break;  	}  	brush = linear;  	pen.Brush = brush;  	return;  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: if (noCycle) {  	//HACK because .NET does not support continue gradient like Java else Tile Gradient  	//that we receize the rectangle very large (factor z) and set 2 additional color values  	//an exact solution will calculate the size of the Graphics with the current transform  	float diffX = end.X - start.X;  	float diffY = end.Y - start.Y;  	SizeF size = GetSize ();  	//HACK zoom factor' with a larger factor .NET will make the gradient wider.  	float z = Math.Min (10' Math.Max (size.Width / diffX' size.Height / diffY));  	start.X -= z * diffX;  	start.Y -= z * diffY;  	end.X += z * diffX;  	end.Y += z * diffY;  	colorBlend = new ColorBlend (javaColors.Length + 2);  	colors = colorBlend.Colors;  	float[] fractions = gradient.getFractions ();  	float[] positions = colorBlend.Positions;  	for (int i = 0; i < javaColors.Length; i++) {  		colors [i + 1] = composite.GetColor (javaColors [i]);  		positions [i + 1] = (z + fractions [i]) / (2 * z + 1);  	}  	colors [0] = colors [1];  	colors [colors.Length - 1] = colors [colors.Length - 2];  	positions [positions.Length - 1] = 1.0f;  } else {  	colorBlend = new ColorBlend (javaColors.Length);  	colors = colorBlend.Colors;  	colorBlend.Positions = gradient.getFractions ();  	for (int i = 0; i < javaColors.Length; i++) {  		colors [i] = composite.GetColor (javaColors [i]);  	}  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: if (noCycle) {  	//HACK because .NET does not support continue gradient like Java else Tile Gradient  	//that we receize the rectangle very large (factor z) and set 2 additional color values  	//an exact solution will calculate the size of the Graphics with the current transform  	float diffX = end.X - start.X;  	float diffY = end.Y - start.Y;  	SizeF size = GetSize ();  	//HACK zoom factor' with a larger factor .NET will make the gradient wider.  	float z = Math.Min (10' Math.Max (size.Width / diffX' size.Height / diffY));  	start.X -= z * diffX;  	start.Y -= z * diffY;  	end.X += z * diffX;  	end.Y += z * diffY;  	colorBlend = new ColorBlend (javaColors.Length + 2);  	colors = colorBlend.Colors;  	float[] fractions = gradient.getFractions ();  	float[] positions = colorBlend.Positions;  	for (int i = 0; i < javaColors.Length; i++) {  		colors [i + 1] = composite.GetColor (javaColors [i]);  		positions [i + 1] = (z + fractions [i]) / (2 * z + 1);  	}  	colors [0] = colors [1];  	colors [colors.Length - 1] = colors [colors.Length - 2];  	positions [positions.Length - 1] = 1.0f;  } else {  	colorBlend = new ColorBlend (javaColors.Length);  	colors = colorBlend.Colors;  	colorBlend.Positions = gradient.getFractions ();  	for (int i = 0; i < javaColors.Length; i++) {  		colors [i] = composite.GetColor (javaColors [i]);  	}  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: if (noCycle) {  	//HACK because .NET does not support continue gradient like Java else Tile Gradient  	//that we receize the rectangle very large (factor z) and set 2 additional color values  	//an exact solution will calculate the size of the Graphics with the current transform  	float diffX = end.X - start.X;  	float diffY = end.Y - start.Y;  	SizeF size = GetSize ();  	//HACK zoom factor' with a larger factor .NET will make the gradient wider.  	float z = Math.Min (10' Math.Max (size.Width / diffX' size.Height / diffY));  	start.X -= z * diffX;  	start.Y -= z * diffY;  	end.X += z * diffX;  	end.Y += z * diffY;  	colorBlend = new ColorBlend (javaColors.Length + 2);  	colors = colorBlend.Colors;  	float[] fractions = gradient.getFractions ();  	float[] positions = colorBlend.Positions;  	for (int i = 0; i < javaColors.Length; i++) {  		colors [i + 1] = composite.GetColor (javaColors [i]);  		positions [i + 1] = (z + fractions [i]) / (2 * z + 1);  	}  	colors [0] = colors [1];  	colors [colors.Length - 1] = colors [colors.Length - 2];  	positions [positions.Length - 1] = 1.0f;  } else {  	colorBlend = new ColorBlend (javaColors.Length);  	colors = colorBlend.Colors;  	colorBlend.Positions = gradient.getFractions ();  	for (int i = 0; i < javaColors.Length; i++) {  		colors [i] = composite.GetColor (javaColors [i]);  	}  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: if (noCycle) {  	//HACK because .NET does not support continue gradient like Java else Tile Gradient  	//that we receize the rectangle very large (factor z) and set 2 additional color values  	//an exact solution will calculate the size of the Graphics with the current transform  	float diffX = end.X - start.X;  	float diffY = end.Y - start.Y;  	SizeF size = GetSize ();  	//HACK zoom factor' with a larger factor .NET will make the gradient wider.  	float z = Math.Min (10' Math.Max (size.Width / diffX' size.Height / diffY));  	start.X -= z * diffX;  	start.Y -= z * diffY;  	end.X += z * diffX;  	end.Y += z * diffY;  	colorBlend = new ColorBlend (javaColors.Length + 2);  	colors = colorBlend.Colors;  	float[] fractions = gradient.getFractions ();  	float[] positions = colorBlend.Positions;  	for (int i = 0; i < javaColors.Length; i++) {  		colors [i + 1] = composite.GetColor (javaColors [i]);  		positions [i + 1] = (z + fractions [i]) / (2 * z + 1);  	}  	colors [0] = colors [1];  	colors [colors.Length - 1] = colors [colors.Length - 2];  	positions [positions.Length - 1] = 1.0f;  } else {  	colorBlend = new ColorBlend (javaColors.Length);  	colors = colorBlend.Colors;  	colorBlend.Positions = gradient.getFractions ();  	for (int i = 0; i < javaColors.Length; i++) {  		colors [i] = composite.GetColor (javaColors [i]);  	}  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: colorBlend = new ColorBlend (javaColors.Length + 2);  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: for (int i = 0; i < javaColors.Length; i++) {  	colors [i + 1] = composite.GetColor (javaColors [i]);  	positions [i + 1] = (z + fractions [i]) / (2 * z + 1);  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: positions [i + 1] = (z + fractions [i]) / (2 * z + 1);  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: colors [colors.Length - 1] = colors [colors.Length - 2];  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,SetLineDash,The following statement contains a magic number: if (dash == null) {  	pen.DashStyle = DashStyle.Solid;  } else {  	if (dash.Length % 2 == 1) {  		int len = dash.Length;  		Array.Resize (ref dash' len * 2);  		Array.Copy (dash' 0' dash' len' len);  	}  	float lineWidth = s.getLineWidth ();  	if (lineWidth > 1)// for values < 0 there is no correctur needed  	 {  		for (int i = 0; i < dash.Length; i++) {  			//dividing by line thickness because of the representation difference  			dash [i] = dash [i] / lineWidth;  		}  	}  	// To fix the problem where solid style in Java can be represented at { 1.0' 0.0 }.  	// In .NET' however' array can only have positive value  	if (dash.Length == 2 && dash [dash.Length - 1] == 0) {  		Array.Resize (ref dash' 1);  	}  	float dashPhase = s.getDashPhase ();  	// correct the dash cap  	switch (s.getEndCap ()) {  	case java.awt.BasicStroke.CAP_BUTT:  		pen.DashCap = DashCap.Flat;  		break;  	case java.awt.BasicStroke.CAP_ROUND:  		pen.DashCap = DashCap.Round;  		break;  	case java.awt.BasicStroke.CAP_SQUARE:  		pen.DashCap = DashCap.Flat;  		// there is no equals DashCap in .NET' we need to emulate it  		dashPhase += lineWidth / 2;  		for (int i = 0; i < dash.Length; i++) {  			if (i % 2 == 0) {  				dash [i] += 1;  			} else {  				dash [i] = Math.Max (0.00001F' dash [i] - 1);  			}  		}  		break;  	default:  		Console.WriteLine ("Unknown dash cap type:" + s.getEndCap ());  		break;  	}  	// calc the dash offset  	if (lineWidth > 0) {  		//dividing by line thickness because of the representation difference  		pen.DashOffset = dashPhase / lineWidth;  	} else {  		// thickness == 0  		if (dashPhase > 0) {  			pen.Width = lineWidth = 0.001F;  			// hack to prevent a division with 0  			pen.DashOffset = dashPhase / lineWidth;  		} else {  			pen.DashOffset = 0;  		}  	}  	// set the final dash pattern   	pen.DashPattern = dash;  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,SetLineDash,The following statement contains a magic number: if (dash == null) {  	pen.DashStyle = DashStyle.Solid;  } else {  	if (dash.Length % 2 == 1) {  		int len = dash.Length;  		Array.Resize (ref dash' len * 2);  		Array.Copy (dash' 0' dash' len' len);  	}  	float lineWidth = s.getLineWidth ();  	if (lineWidth > 1)// for values < 0 there is no correctur needed  	 {  		for (int i = 0; i < dash.Length; i++) {  			//dividing by line thickness because of the representation difference  			dash [i] = dash [i] / lineWidth;  		}  	}  	// To fix the problem where solid style in Java can be represented at { 1.0' 0.0 }.  	// In .NET' however' array can only have positive value  	if (dash.Length == 2 && dash [dash.Length - 1] == 0) {  		Array.Resize (ref dash' 1);  	}  	float dashPhase = s.getDashPhase ();  	// correct the dash cap  	switch (s.getEndCap ()) {  	case java.awt.BasicStroke.CAP_BUTT:  		pen.DashCap = DashCap.Flat;  		break;  	case java.awt.BasicStroke.CAP_ROUND:  		pen.DashCap = DashCap.Round;  		break;  	case java.awt.BasicStroke.CAP_SQUARE:  		pen.DashCap = DashCap.Flat;  		// there is no equals DashCap in .NET' we need to emulate it  		dashPhase += lineWidth / 2;  		for (int i = 0; i < dash.Length; i++) {  			if (i % 2 == 0) {  				dash [i] += 1;  			} else {  				dash [i] = Math.Max (0.00001F' dash [i] - 1);  			}  		}  		break;  	default:  		Console.WriteLine ("Unknown dash cap type:" + s.getEndCap ());  		break;  	}  	// calc the dash offset  	if (lineWidth > 0) {  		//dividing by line thickness because of the representation difference  		pen.DashOffset = dashPhase / lineWidth;  	} else {  		// thickness == 0  		if (dashPhase > 0) {  			pen.Width = lineWidth = 0.001F;  			// hack to prevent a division with 0  			pen.DashOffset = dashPhase / lineWidth;  		} else {  			pen.DashOffset = 0;  		}  	}  	// set the final dash pattern   	pen.DashPattern = dash;  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,SetLineDash,The following statement contains a magic number: if (dash == null) {  	pen.DashStyle = DashStyle.Solid;  } else {  	if (dash.Length % 2 == 1) {  		int len = dash.Length;  		Array.Resize (ref dash' len * 2);  		Array.Copy (dash' 0' dash' len' len);  	}  	float lineWidth = s.getLineWidth ();  	if (lineWidth > 1)// for values < 0 there is no correctur needed  	 {  		for (int i = 0; i < dash.Length; i++) {  			//dividing by line thickness because of the representation difference  			dash [i] = dash [i] / lineWidth;  		}  	}  	// To fix the problem where solid style in Java can be represented at { 1.0' 0.0 }.  	// In .NET' however' array can only have positive value  	if (dash.Length == 2 && dash [dash.Length - 1] == 0) {  		Array.Resize (ref dash' 1);  	}  	float dashPhase = s.getDashPhase ();  	// correct the dash cap  	switch (s.getEndCap ()) {  	case java.awt.BasicStroke.CAP_BUTT:  		pen.DashCap = DashCap.Flat;  		break;  	case java.awt.BasicStroke.CAP_ROUND:  		pen.DashCap = DashCap.Round;  		break;  	case java.awt.BasicStroke.CAP_SQUARE:  		pen.DashCap = DashCap.Flat;  		// there is no equals DashCap in .NET' we need to emulate it  		dashPhase += lineWidth / 2;  		for (int i = 0; i < dash.Length; i++) {  			if (i % 2 == 0) {  				dash [i] += 1;  			} else {  				dash [i] = Math.Max (0.00001F' dash [i] - 1);  			}  		}  		break;  	default:  		Console.WriteLine ("Unknown dash cap type:" + s.getEndCap ());  		break;  	}  	// calc the dash offset  	if (lineWidth > 0) {  		//dividing by line thickness because of the representation difference  		pen.DashOffset = dashPhase / lineWidth;  	} else {  		// thickness == 0  		if (dashPhase > 0) {  			pen.Width = lineWidth = 0.001F;  			// hack to prevent a division with 0  			pen.DashOffset = dashPhase / lineWidth;  		} else {  			pen.DashOffset = 0;  		}  	}  	// set the final dash pattern   	pen.DashPattern = dash;  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,SetLineDash,The following statement contains a magic number: if (dash == null) {  	pen.DashStyle = DashStyle.Solid;  } else {  	if (dash.Length % 2 == 1) {  		int len = dash.Length;  		Array.Resize (ref dash' len * 2);  		Array.Copy (dash' 0' dash' len' len);  	}  	float lineWidth = s.getLineWidth ();  	if (lineWidth > 1)// for values < 0 there is no correctur needed  	 {  		for (int i = 0; i < dash.Length; i++) {  			//dividing by line thickness because of the representation difference  			dash [i] = dash [i] / lineWidth;  		}  	}  	// To fix the problem where solid style in Java can be represented at { 1.0' 0.0 }.  	// In .NET' however' array can only have positive value  	if (dash.Length == 2 && dash [dash.Length - 1] == 0) {  		Array.Resize (ref dash' 1);  	}  	float dashPhase = s.getDashPhase ();  	// correct the dash cap  	switch (s.getEndCap ()) {  	case java.awt.BasicStroke.CAP_BUTT:  		pen.DashCap = DashCap.Flat;  		break;  	case java.awt.BasicStroke.CAP_ROUND:  		pen.DashCap = DashCap.Round;  		break;  	case java.awt.BasicStroke.CAP_SQUARE:  		pen.DashCap = DashCap.Flat;  		// there is no equals DashCap in .NET' we need to emulate it  		dashPhase += lineWidth / 2;  		for (int i = 0; i < dash.Length; i++) {  			if (i % 2 == 0) {  				dash [i] += 1;  			} else {  				dash [i] = Math.Max (0.00001F' dash [i] - 1);  			}  		}  		break;  	default:  		Console.WriteLine ("Unknown dash cap type:" + s.getEndCap ());  		break;  	}  	// calc the dash offset  	if (lineWidth > 0) {  		//dividing by line thickness because of the representation difference  		pen.DashOffset = dashPhase / lineWidth;  	} else {  		// thickness == 0  		if (dashPhase > 0) {  			pen.Width = lineWidth = 0.001F;  			// hack to prevent a division with 0  			pen.DashOffset = dashPhase / lineWidth;  		} else {  			pen.DashOffset = 0;  		}  	}  	// set the final dash pattern   	pen.DashPattern = dash;  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,SetLineDash,The following statement contains a magic number: if (dash == null) {  	pen.DashStyle = DashStyle.Solid;  } else {  	if (dash.Length % 2 == 1) {  		int len = dash.Length;  		Array.Resize (ref dash' len * 2);  		Array.Copy (dash' 0' dash' len' len);  	}  	float lineWidth = s.getLineWidth ();  	if (lineWidth > 1)// for values < 0 there is no correctur needed  	 {  		for (int i = 0; i < dash.Length; i++) {  			//dividing by line thickness because of the representation difference  			dash [i] = dash [i] / lineWidth;  		}  	}  	// To fix the problem where solid style in Java can be represented at { 1.0' 0.0 }.  	// In .NET' however' array can only have positive value  	if (dash.Length == 2 && dash [dash.Length - 1] == 0) {  		Array.Resize (ref dash' 1);  	}  	float dashPhase = s.getDashPhase ();  	// correct the dash cap  	switch (s.getEndCap ()) {  	case java.awt.BasicStroke.CAP_BUTT:  		pen.DashCap = DashCap.Flat;  		break;  	case java.awt.BasicStroke.CAP_ROUND:  		pen.DashCap = DashCap.Round;  		break;  	case java.awt.BasicStroke.CAP_SQUARE:  		pen.DashCap = DashCap.Flat;  		// there is no equals DashCap in .NET' we need to emulate it  		dashPhase += lineWidth / 2;  		for (int i = 0; i < dash.Length; i++) {  			if (i % 2 == 0) {  				dash [i] += 1;  			} else {  				dash [i] = Math.Max (0.00001F' dash [i] - 1);  			}  		}  		break;  	default:  		Console.WriteLine ("Unknown dash cap type:" + s.getEndCap ());  		break;  	}  	// calc the dash offset  	if (lineWidth > 0) {  		//dividing by line thickness because of the representation difference  		pen.DashOffset = dashPhase / lineWidth;  	} else {  		// thickness == 0  		if (dashPhase > 0) {  			pen.Width = lineWidth = 0.001F;  			// hack to prevent a division with 0  			pen.DashOffset = dashPhase / lineWidth;  		} else {  			pen.DashOffset = 0;  		}  	}  	// set the final dash pattern   	pen.DashPattern = dash;  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,SetLineDash,The following statement contains a magic number: if (dash.Length % 2 == 1) {  	int len = dash.Length;  	Array.Resize (ref dash' len * 2);  	Array.Copy (dash' 0' dash' len' len);  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,SetLineDash,The following statement contains a magic number: if (dash.Length % 2 == 1) {  	int len = dash.Length;  	Array.Resize (ref dash' len * 2);  	Array.Copy (dash' 0' dash' len' len);  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,SetLineDash,The following statement contains a magic number: Array.Resize (ref dash' len * 2);  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,SetLineDash,The following statement contains a magic number: if (dash.Length == 2 && dash [dash.Length - 1] == 0) {  	Array.Resize (ref dash' 1);  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,SetLineDash,The following statement contains a magic number: switch (s.getEndCap ()) {  case java.awt.BasicStroke.CAP_BUTT:  	pen.DashCap = DashCap.Flat;  	break;  case java.awt.BasicStroke.CAP_ROUND:  	pen.DashCap = DashCap.Round;  	break;  case java.awt.BasicStroke.CAP_SQUARE:  	pen.DashCap = DashCap.Flat;  	// there is no equals DashCap in .NET' we need to emulate it  	dashPhase += lineWidth / 2;  	for (int i = 0; i < dash.Length; i++) {  		if (i % 2 == 0) {  			dash [i] += 1;  		} else {  			dash [i] = Math.Max (0.00001F' dash [i] - 1);  		}  	}  	break;  default:  	Console.WriteLine ("Unknown dash cap type:" + s.getEndCap ());  	break;  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,SetLineDash,The following statement contains a magic number: switch (s.getEndCap ()) {  case java.awt.BasicStroke.CAP_BUTT:  	pen.DashCap = DashCap.Flat;  	break;  case java.awt.BasicStroke.CAP_ROUND:  	pen.DashCap = DashCap.Round;  	break;  case java.awt.BasicStroke.CAP_SQUARE:  	pen.DashCap = DashCap.Flat;  	// there is no equals DashCap in .NET' we need to emulate it  	dashPhase += lineWidth / 2;  	for (int i = 0; i < dash.Length; i++) {  		if (i % 2 == 0) {  			dash [i] += 1;  		} else {  			dash [i] = Math.Max (0.00001F' dash [i] - 1);  		}  	}  	break;  default:  	Console.WriteLine ("Unknown dash cap type:" + s.getEndCap ());  	break;  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,SetLineDash,The following statement contains a magic number: dashPhase += lineWidth / 2;  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,SetLineDash,The following statement contains a magic number: for (int i = 0; i < dash.Length; i++) {  	if (i % 2 == 0) {  		dash [i] += 1;  	} else {  		dash [i] = Math.Max (0.00001F' dash [i] - 1);  	}  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,SetLineDash,The following statement contains a magic number: if (i % 2 == 0) {  	dash [i] += 1;  } else {  	dash [i] = Math.Max (0.00001F' dash [i] - 1);  }  
Magic Number,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,RadiansToDegrees,The following statement contains a magic number: return radians * (180 / Math.PI);  
Magic Number,ikvm.awt,NetVolatileImage,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\images.cs,getFont,The following statement contains a magic number: if (component != null) {  	return component.getFont ();  } else {  	if (defaultFont == null) {  		defaultFont = new java.awt.Font ("Dialog"' java.awt.Font.PLAIN' 12);  	}  	return defaultFont;  }  
Magic Number,ikvm.awt,NetVolatileImage,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\images.cs,getFont,The following statement contains a magic number: if (defaultFont == null) {  	defaultFont = new java.awt.Font ("Dialog"' java.awt.Font.PLAIN' 12);  }  
Magic Number,ikvm.awt,NetVolatileImage,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\images.cs,getFont,The following statement contains a magic number: defaultFont = new java.awt.Font ("Dialog"' java.awt.Font.PLAIN' 12);  
Magic Number,ikvm.awt,NetToolkit,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,initializeDesktopProperties,The following statement contains a magic number: desktopProperties.put ("DnD.Autoscroll.initialDelay"' java.lang.Integer.valueOf (50));  
Magic Number,ikvm.awt,NetToolkit,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,initializeDesktopProperties,The following statement contains a magic number: desktopProperties.put ("DnD.Autoscroll.interval"' java.lang.Integer.valueOf (50));  
Magic Number,ikvm.awt,NetMouseDragGestureRecognizer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,mousePressed,The following statement contains a magic number: if (mapDragOperationFromModifiers (e) != java.awt.dnd.DnDConstants.ACTION_NONE) {  	try {  		motionThreshold = java.awt.dnd.DragSource.getDragThreshold ();  	} catch {  		motionThreshold = 5;  	}  	appendEvent (e);  }  
Magic Number,ikvm.awt,NetMouseDragGestureRecognizer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,mousePressed,The following statement contains a magic number: try {  	motionThreshold = java.awt.dnd.DragSource.getDragThreshold ();  } catch {  	motionThreshold = 5;  }  
Magic Number,ikvm.awt,NetMouseDragGestureRecognizer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,mousePressed,The following statement contains a magic number: motionThreshold = 5;  
Magic Number,ikvm.awt,NetComponentPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,OnMouseUp,The following statement contains a magic number: if (isMouseClick || isDoubleClick)// there can only be an Click OR an DoubleClick event - both count as click here   {  	//We make our own mouse click event because the event order is different in .NET  	//in .NET the click occured before MouseUp  	int clicks = ev.Clicks;  	if (isDoubleClick) {  		clicks = 2;  	}  	postMouseEvent (ev' java.awt.@event.MouseEvent.MOUSE_CLICKED' clicks);  }  
Magic Number,ikvm.awt,NetComponentPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,OnMouseUp,The following statement contains a magic number: if (isDoubleClick) {  	clicks = 2;  }  
Magic Number,ikvm.awt,NetComponentPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,OnMouseUp,The following statement contains a magic number: clicks = 2;  
Magic Number,ikvm.awt,NetButtonPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getMinimumSize,The following statement contains a magic number: using (Graphics g = control.CreateGraphics ()) {  	// TODO get these fudge factors from somewhere  	return new java.awt.Dimension ((int)Math.Round (12 + g.MeasureString (control.Text' control.Font).Width) * 8 / 7' 6 + control.Font.Height * 8 / 7);  }  
Magic Number,ikvm.awt,NetButtonPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getMinimumSize,The following statement contains a magic number: using (Graphics g = control.CreateGraphics ()) {  	// TODO get these fudge factors from somewhere  	return new java.awt.Dimension ((int)Math.Round (12 + g.MeasureString (control.Text' control.Font).Width) * 8 / 7' 6 + control.Font.Height * 8 / 7);  }  
Magic Number,ikvm.awt,NetButtonPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getMinimumSize,The following statement contains a magic number: using (Graphics g = control.CreateGraphics ()) {  	// TODO get these fudge factors from somewhere  	return new java.awt.Dimension ((int)Math.Round (12 + g.MeasureString (control.Text' control.Font).Width) * 8 / 7' 6 + control.Font.Height * 8 / 7);  }  
Magic Number,ikvm.awt,NetButtonPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getMinimumSize,The following statement contains a magic number: using (Graphics g = control.CreateGraphics ()) {  	// TODO get these fudge factors from somewhere  	return new java.awt.Dimension ((int)Math.Round (12 + g.MeasureString (control.Text' control.Font).Width) * 8 / 7' 6 + control.Font.Height * 8 / 7);  }  
Magic Number,ikvm.awt,NetButtonPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getMinimumSize,The following statement contains a magic number: using (Graphics g = control.CreateGraphics ()) {  	// TODO get these fudge factors from somewhere  	return new java.awt.Dimension ((int)Math.Round (12 + g.MeasureString (control.Text' control.Font).Width) * 8 / 7' 6 + control.Font.Height * 8 / 7);  }  
Magic Number,ikvm.awt,NetButtonPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getMinimumSize,The following statement contains a magic number: using (Graphics g = control.CreateGraphics ()) {  	// TODO get these fudge factors from somewhere  	return new java.awt.Dimension ((int)Math.Round (12 + g.MeasureString (control.Text' control.Font).Width) * 8 / 7' 6 + control.Font.Height * 8 / 7);  }  
Magic Number,ikvm.awt,NetButtonPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getMinimumSize,The following statement contains a magic number: return new java.awt.Dimension ((int)Math.Round (12 + g.MeasureString (control.Text' control.Font).Width) * 8 / 7' 6 + control.Font.Height * 8 / 7);  
Magic Number,ikvm.awt,NetButtonPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getMinimumSize,The following statement contains a magic number: return new java.awt.Dimension ((int)Math.Round (12 + g.MeasureString (control.Text' control.Font).Width) * 8 / 7' 6 + control.Font.Height * 8 / 7);  
Magic Number,ikvm.awt,NetButtonPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getMinimumSize,The following statement contains a magic number: return new java.awt.Dimension ((int)Math.Round (12 + g.MeasureString (control.Text' control.Font).Width) * 8 / 7' 6 + control.Font.Height * 8 / 7);  
Magic Number,ikvm.awt,NetButtonPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getMinimumSize,The following statement contains a magic number: return new java.awt.Dimension ((int)Math.Round (12 + g.MeasureString (control.Text' control.Font).Width) * 8 / 7' 6 + control.Font.Height * 8 / 7);  
Magic Number,ikvm.awt,NetButtonPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getMinimumSize,The following statement contains a magic number: return new java.awt.Dimension ((int)Math.Round (12 + g.MeasureString (control.Text' control.Font).Width) * 8 / 7' 6 + control.Font.Height * 8 / 7);  
Magic Number,ikvm.awt,NetButtonPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getMinimumSize,The following statement contains a magic number: return new java.awt.Dimension ((int)Math.Round (12 + g.MeasureString (control.Text' control.Font).Width) * 8 / 7' 6 + control.Font.Height * 8 / 7);  
Magic Number,ikvm.awt,NetLabelPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getPreferredSizeImpl,The following statement contains a magic number: return new java.awt.Dimension (control.PreferredWidth' 2 + control.PreferredHeight);  
Magic Number,ikvm.awt,NetTextFieldPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getPreferredSize,The following statement contains a magic number: using (Graphics g = control.CreateGraphics ()) {  	return new java.awt.Dimension ((int)Math.Round ((g.MeasureString ("abcdefghijklm"' control.Font).Width * len) / 13)' ((TextBox)control).PreferredHeight);  }  
Magic Number,ikvm.awt,NetTextFieldPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getPreferredSize,The following statement contains a magic number: return new java.awt.Dimension ((int)Math.Round ((g.MeasureString ("abcdefghijklm"' control.Font).Width * len) / 13)' ((TextBox)control).PreferredHeight);  
Magic Number,ikvm.awt,NetTextAreaPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getMinimumSize,The following statement contains a magic number: return getMinimumSize (10' 60);  
Magic Number,ikvm.awt,NetTextAreaPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getMinimumSize,The following statement contains a magic number: return getMinimumSize (10' 60);  
Magic Number,ikvm.awt,NetTextAreaPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getMinimumSize,The following statement contains a magic number: return new java.awt.Dimension (fm.charWidth ('0') * cols + 20' fm.getHeight () * rows + 20);  
Magic Number,ikvm.awt,NetTextAreaPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getMinimumSize,The following statement contains a magic number: return new java.awt.Dimension (fm.charWidth ('0') * cols + 20' fm.getHeight () * rows + 20);  
Magic Number,ikvm.awt,NetListPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getMinimumSize,The following statement contains a magic number: return new java.awt.Dimension (100' 100);  
Magic Number,ikvm.awt,NetListPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getMinimumSize,The following statement contains a magic number: return new java.awt.Dimension (100' 100);  
Magic Number,ikvm.awt,NetTrayIconPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,displayMessage,The following statement contains a magic number: NetToolkit.BeginInvoke (delegate {  	notifyIcon.ShowBalloonTip (10000' caption' text' icon);  });  
Magic Number,ikvm.awt,NetTrayIconPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,displayMessage,The following statement contains a magic number: notifyIcon.ShowBalloonTip (10000' caption' text' icon);  
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,Win32ShellFolder2,The following statement contains a magic number: isXP = Environment.OSVersion.Version >= new Version (5' 1);  
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getExecutableType,The following statement contains a magic number: if (result >= 32) {  	return objResultBuffer.ToString ();  }  
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getIconBits,The following statement contains a magic number: if (GetIconInfo (hIcon' out iconInfo)) {  	using (SafeDeviceContextHandle dc = SafeDeviceContextHandle.Get ()) {  		BITMAPINFO bmi = new BITMAPINFO ();  		bmi.biSize = 40;  		bmi.biWidth = iconSize;  		bmi.biHeight = -iconSize;  		bmi.biPlanes = 1;  		bmi.biBitCount = 32;  		bmi.biCompression = 0;  		int intArrSize = iconSize * iconSize;  		int[] iconBits = new int[intArrSize];  		GetDIBits (dc' iconInfo.hbmColor' 0' (uint)iconSize' iconBits' ref bmi' 0);  		bool hasAlpha = false;  		if (isXP) {  			for (int i = 0; i < iconBits.Length; i++) {  				if ((iconBits [i] & 0xFF000000) != 0) {  					hasAlpha = true;  					break;  				}  			}  		}  		if (!hasAlpha) {  			int[] maskBits = new int[intArrSize];  			GetDIBits (dc' iconInfo.hbmMask' 0' (uint)iconSize' maskBits' ref bmi' 0);  			for (int i = 0; i < iconBits.Length; i++) {  				if (maskBits [i] == 0) {  					iconBits [i] = (int)((uint)iconBits [i] | 0xFF000000);  				}  			}  		}  		DeleteObject (iconInfo.hbmColor);  		DeleteObject (iconInfo.hbmMask);  		DeleteObject (hIcon);  		Bitmap bitmap = new Bitmap (iconSize' iconSize' PixelFormat.Format32bppArgb);  		BitmapData bitmapData = bitmap.LockBits (new Rectangle (0' 0' iconSize' iconSize)' ImageLockMode.WriteOnly' PixelFormat.Format32bppArgb);  		Marshal.Copy (iconBits' 0' bitmapData.Scan0' iconBits.Length);  		bitmap.UnlockBits (bitmapData);  		return bitmap;  	}  }  
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getIconBits,The following statement contains a magic number: if (GetIconInfo (hIcon' out iconInfo)) {  	using (SafeDeviceContextHandle dc = SafeDeviceContextHandle.Get ()) {  		BITMAPINFO bmi = new BITMAPINFO ();  		bmi.biSize = 40;  		bmi.biWidth = iconSize;  		bmi.biHeight = -iconSize;  		bmi.biPlanes = 1;  		bmi.biBitCount = 32;  		bmi.biCompression = 0;  		int intArrSize = iconSize * iconSize;  		int[] iconBits = new int[intArrSize];  		GetDIBits (dc' iconInfo.hbmColor' 0' (uint)iconSize' iconBits' ref bmi' 0);  		bool hasAlpha = false;  		if (isXP) {  			for (int i = 0; i < iconBits.Length; i++) {  				if ((iconBits [i] & 0xFF000000) != 0) {  					hasAlpha = true;  					break;  				}  			}  		}  		if (!hasAlpha) {  			int[] maskBits = new int[intArrSize];  			GetDIBits (dc' iconInfo.hbmMask' 0' (uint)iconSize' maskBits' ref bmi' 0);  			for (int i = 0; i < iconBits.Length; i++) {  				if (maskBits [i] == 0) {  					iconBits [i] = (int)((uint)iconBits [i] | 0xFF000000);  				}  			}  		}  		DeleteObject (iconInfo.hbmColor);  		DeleteObject (iconInfo.hbmMask);  		DeleteObject (hIcon);  		Bitmap bitmap = new Bitmap (iconSize' iconSize' PixelFormat.Format32bppArgb);  		BitmapData bitmapData = bitmap.LockBits (new Rectangle (0' 0' iconSize' iconSize)' ImageLockMode.WriteOnly' PixelFormat.Format32bppArgb);  		Marshal.Copy (iconBits' 0' bitmapData.Scan0' iconBits.Length);  		bitmap.UnlockBits (bitmapData);  		return bitmap;  	}  }  
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getIconBits,The following statement contains a magic number: using (SafeDeviceContextHandle dc = SafeDeviceContextHandle.Get ()) {  	BITMAPINFO bmi = new BITMAPINFO ();  	bmi.biSize = 40;  	bmi.biWidth = iconSize;  	bmi.biHeight = -iconSize;  	bmi.biPlanes = 1;  	bmi.biBitCount = 32;  	bmi.biCompression = 0;  	int intArrSize = iconSize * iconSize;  	int[] iconBits = new int[intArrSize];  	GetDIBits (dc' iconInfo.hbmColor' 0' (uint)iconSize' iconBits' ref bmi' 0);  	bool hasAlpha = false;  	if (isXP) {  		for (int i = 0; i < iconBits.Length; i++) {  			if ((iconBits [i] & 0xFF000000) != 0) {  				hasAlpha = true;  				break;  			}  		}  	}  	if (!hasAlpha) {  		int[] maskBits = new int[intArrSize];  		GetDIBits (dc' iconInfo.hbmMask' 0' (uint)iconSize' maskBits' ref bmi' 0);  		for (int i = 0; i < iconBits.Length; i++) {  			if (maskBits [i] == 0) {  				iconBits [i] = (int)((uint)iconBits [i] | 0xFF000000);  			}  		}  	}  	DeleteObject (iconInfo.hbmColor);  	DeleteObject (iconInfo.hbmMask);  	DeleteObject (hIcon);  	Bitmap bitmap = new Bitmap (iconSize' iconSize' PixelFormat.Format32bppArgb);  	BitmapData bitmapData = bitmap.LockBits (new Rectangle (0' 0' iconSize' iconSize)' ImageLockMode.WriteOnly' PixelFormat.Format32bppArgb);  	Marshal.Copy (iconBits' 0' bitmapData.Scan0' iconBits.Length);  	bitmap.UnlockBits (bitmapData);  	return bitmap;  }  
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getIconBits,The following statement contains a magic number: using (SafeDeviceContextHandle dc = SafeDeviceContextHandle.Get ()) {  	BITMAPINFO bmi = new BITMAPINFO ();  	bmi.biSize = 40;  	bmi.biWidth = iconSize;  	bmi.biHeight = -iconSize;  	bmi.biPlanes = 1;  	bmi.biBitCount = 32;  	bmi.biCompression = 0;  	int intArrSize = iconSize * iconSize;  	int[] iconBits = new int[intArrSize];  	GetDIBits (dc' iconInfo.hbmColor' 0' (uint)iconSize' iconBits' ref bmi' 0);  	bool hasAlpha = false;  	if (isXP) {  		for (int i = 0; i < iconBits.Length; i++) {  			if ((iconBits [i] & 0xFF000000) != 0) {  				hasAlpha = true;  				break;  			}  		}  	}  	if (!hasAlpha) {  		int[] maskBits = new int[intArrSize];  		GetDIBits (dc' iconInfo.hbmMask' 0' (uint)iconSize' maskBits' ref bmi' 0);  		for (int i = 0; i < iconBits.Length; i++) {  			if (maskBits [i] == 0) {  				iconBits [i] = (int)((uint)iconBits [i] | 0xFF000000);  			}  		}  	}  	DeleteObject (iconInfo.hbmColor);  	DeleteObject (iconInfo.hbmMask);  	DeleteObject (hIcon);  	Bitmap bitmap = new Bitmap (iconSize' iconSize' PixelFormat.Format32bppArgb);  	BitmapData bitmapData = bitmap.LockBits (new Rectangle (0' 0' iconSize' iconSize)' ImageLockMode.WriteOnly' PixelFormat.Format32bppArgb);  	Marshal.Copy (iconBits' 0' bitmapData.Scan0' iconBits.Length);  	bitmap.UnlockBits (bitmapData);  	return bitmap;  }  
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getIconBits,The following statement contains a magic number: bmi.biSize = 40;  
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getIconBits,The following statement contains a magic number: bmi.biBitCount = 32;  
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getShell32IconResourceAsBitmap,The following statement contains a magic number: using (SafeGdiObjectHandle hicon = LoadImage (hmodShell32' (IntPtr)iconID' IMAGE_ICON' size' size' 0)) {  	if (hicon != null) {  		return getIconBits (hicon.DangerousGetHandle ()' 16);  	}  }  
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getShell32IconResourceAsBitmap,The following statement contains a magic number: if (hicon != null) {  	return getIconBits (hicon.DangerousGetHandle ()' 16);  }  
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getShell32IconResourceAsBitmap,The following statement contains a magic number: return getIconBits (hicon.DangerousGetHandle ()' 16);  
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,copyFirstPIDLEntry,The following statement contains a magic number: Marshal.Copy (pIDL' buffer' 0' length - 2);  
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getDisplayNameOf,The following statement contains a magic number: if (hRes == 0) {  	StringBuilder name = new StringBuilder (1024);  	StrRetToBuf (ref result' relativePIDL' name' 1024);  	string stringName = name.ToString ();  	return stringName;  }  
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getDisplayNameOf,The following statement contains a magic number: if (hRes == 0) {  	StringBuilder name = new StringBuilder (1024);  	StrRetToBuf (ref result' relativePIDL' name' 1024);  	string stringName = name.ToString ();  	return stringName;  }  
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getDisplayNameOf,The following statement contains a magic number: StrRetToBuf (ref result' relativePIDL' name' 1024);  
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,extractIcon,The following statement contains a magic number: if (folder.GetUIObjectOf (IntPtr.Zero' 1' new IntPtr[] {  	relativePIDL  }' ref guid' IntPtr.Zero' out ppv) == 0) {  	ShellApi.IExtractIcon extractor = (ShellApi.IExtractIcon)ppv;  	int size = 1024;  	StringBuilder path = new StringBuilder (size);  	int piIndex;  	uint pwFlags;  	if (extractor.GetIconLocation ((uint)ShellApi.GIL.GIL_FORSHELL' path' size' out piIndex' out pwFlags) == 0) {  		IntPtr hIconL = new IntPtr ();  		IntPtr hIconS = new IntPtr ();  		if (extractor.Extract (path.ToString ()' (uint)piIndex' out hIconL' out hIconS' (16 << 16) + 32) == 0) {  			if (getLargeIcon) {  				ShellApi.DestroyIcon (hIconS);  				return hIconL;  			} else {  				ShellApi.DestroyIcon (hIconL);  				return hIconS;  			}  		}  	}  }  
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,extractIcon,The following statement contains a magic number: if (folder.GetUIObjectOf (IntPtr.Zero' 1' new IntPtr[] {  	relativePIDL  }' ref guid' IntPtr.Zero' out ppv) == 0) {  	ShellApi.IExtractIcon extractor = (ShellApi.IExtractIcon)ppv;  	int size = 1024;  	StringBuilder path = new StringBuilder (size);  	int piIndex;  	uint pwFlags;  	if (extractor.GetIconLocation ((uint)ShellApi.GIL.GIL_FORSHELL' path' size' out piIndex' out pwFlags) == 0) {  		IntPtr hIconL = new IntPtr ();  		IntPtr hIconS = new IntPtr ();  		if (extractor.Extract (path.ToString ()' (uint)piIndex' out hIconL' out hIconS' (16 << 16) + 32) == 0) {  			if (getLargeIcon) {  				ShellApi.DestroyIcon (hIconS);  				return hIconL;  			} else {  				ShellApi.DestroyIcon (hIconL);  				return hIconS;  			}  		}  	}  }  
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,extractIcon,The following statement contains a magic number: if (folder.GetUIObjectOf (IntPtr.Zero' 1' new IntPtr[] {  	relativePIDL  }' ref guid' IntPtr.Zero' out ppv) == 0) {  	ShellApi.IExtractIcon extractor = (ShellApi.IExtractIcon)ppv;  	int size = 1024;  	StringBuilder path = new StringBuilder (size);  	int piIndex;  	uint pwFlags;  	if (extractor.GetIconLocation ((uint)ShellApi.GIL.GIL_FORSHELL' path' size' out piIndex' out pwFlags) == 0) {  		IntPtr hIconL = new IntPtr ();  		IntPtr hIconS = new IntPtr ();  		if (extractor.Extract (path.ToString ()' (uint)piIndex' out hIconL' out hIconS' (16 << 16) + 32) == 0) {  			if (getLargeIcon) {  				ShellApi.DestroyIcon (hIconS);  				return hIconL;  			} else {  				ShellApi.DestroyIcon (hIconL);  				return hIconS;  			}  		}  	}  }  
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,extractIcon,The following statement contains a magic number: if (folder.GetUIObjectOf (IntPtr.Zero' 1' new IntPtr[] {  	relativePIDL  }' ref guid' IntPtr.Zero' out ppv) == 0) {  	ShellApi.IExtractIcon extractor = (ShellApi.IExtractIcon)ppv;  	int size = 1024;  	StringBuilder path = new StringBuilder (size);  	int piIndex;  	uint pwFlags;  	if (extractor.GetIconLocation ((uint)ShellApi.GIL.GIL_FORSHELL' path' size' out piIndex' out pwFlags) == 0) {  		IntPtr hIconL = new IntPtr ();  		IntPtr hIconS = new IntPtr ();  		if (extractor.Extract (path.ToString ()' (uint)piIndex' out hIconL' out hIconS' (16 << 16) + 32) == 0) {  			if (getLargeIcon) {  				ShellApi.DestroyIcon (hIconS);  				return hIconL;  			} else {  				ShellApi.DestroyIcon (hIconL);  				return hIconS;  			}  		}  	}  }  
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,extractIcon,The following statement contains a magic number: if (extractor.GetIconLocation ((uint)ShellApi.GIL.GIL_FORSHELL' path' size' out piIndex' out pwFlags) == 0) {  	IntPtr hIconL = new IntPtr ();  	IntPtr hIconS = new IntPtr ();  	if (extractor.Extract (path.ToString ()' (uint)piIndex' out hIconL' out hIconS' (16 << 16) + 32) == 0) {  		if (getLargeIcon) {  			ShellApi.DestroyIcon (hIconS);  			return hIconL;  		} else {  			ShellApi.DestroyIcon (hIconL);  			return hIconS;  		}  	}  }  
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,extractIcon,The following statement contains a magic number: if (extractor.GetIconLocation ((uint)ShellApi.GIL.GIL_FORSHELL' path' size' out piIndex' out pwFlags) == 0) {  	IntPtr hIconL = new IntPtr ();  	IntPtr hIconS = new IntPtr ();  	if (extractor.Extract (path.ToString ()' (uint)piIndex' out hIconL' out hIconS' (16 << 16) + 32) == 0) {  		if (getLargeIcon) {  			ShellApi.DestroyIcon (hIconS);  			return hIconL;  		} else {  			ShellApi.DestroyIcon (hIconL);  			return hIconS;  		}  	}  }  
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,extractIcon,The following statement contains a magic number: if (extractor.GetIconLocation ((uint)ShellApi.GIL.GIL_FORSHELL' path' size' out piIndex' out pwFlags) == 0) {  	IntPtr hIconL = new IntPtr ();  	IntPtr hIconS = new IntPtr ();  	if (extractor.Extract (path.ToString ()' (uint)piIndex' out hIconL' out hIconS' (16 << 16) + 32) == 0) {  		if (getLargeIcon) {  			ShellApi.DestroyIcon (hIconS);  			return hIconL;  		} else {  			ShellApi.DestroyIcon (hIconL);  			return hIconS;  		}  	}  }  
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,extractIcon,The following statement contains a magic number: if (extractor.Extract (path.ToString ()' (uint)piIndex' out hIconL' out hIconS' (16 << 16) + 32) == 0) {  	if (getLargeIcon) {  		ShellApi.DestroyIcon (hIconS);  		return hIconL;  	} else {  		ShellApi.DestroyIcon (hIconL);  		return hIconS;  	}  }  
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,extractIcon,The following statement contains a magic number: if (extractor.Extract (path.ToString ()' (uint)piIndex' out hIconL' out hIconS' (16 << 16) + 32) == 0) {  	if (getLargeIcon) {  		ShellApi.DestroyIcon (hIconS);  		return hIconL;  	} else {  		ShellApi.DestroyIcon (hIconL);  		return hIconS;  	}  }  
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,extractIcon,The following statement contains a magic number: if (extractor.Extract (path.ToString ()' (uint)piIndex' out hIconL' out hIconS' (16 << 16) + 32) == 0) {  	if (getLargeIcon) {  		ShellApi.DestroyIcon (hIconS);  		return hIconL;  	} else {  		ShellApi.DestroyIcon (hIconL);  		return hIconS;  	}  }  
Magic Number,ikvm.awt.printing,Win32PrintPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\printing.cs,GetPrinterInfo2,The following statement contains a magic number: try {  	int needed = 0;  	if (OpenPrinter (printerName' out printer' IntPtr.Zero) && !GetPrinter (printer' 2' IntPtr.Zero' 0' out needed)) {  		int lastWin32Error = Marshal.GetLastWin32Error ();  		if (lastWin32Error == ERROR_INSUFFICIENT_BUFFER) {  			IntPtr pPrinter = Marshal.AllocHGlobal ((int)needed);  			try {  				if (GetPrinter (printer' 2' pPrinter' needed' out needed)) {  					PRINTER_INFO_2 printerInfo2 = (PRINTER_INFO_2)Marshal.PtrToStructure (pPrinter' typeof(PRINTER_INFO_2));  					cJobs = printerInfo2.cJobs;  					status = printerInfo2.Status;  					return true;  				}  			} finally {  				Marshal.FreeHGlobal (pPrinter);  			}  		}  	}  } finally {  	if (printer != null) {  		printer.Close ();  	}  }  
Magic Number,ikvm.awt.printing,Win32PrintPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\printing.cs,GetPrinterInfo2,The following statement contains a magic number: try {  	int needed = 0;  	if (OpenPrinter (printerName' out printer' IntPtr.Zero) && !GetPrinter (printer' 2' IntPtr.Zero' 0' out needed)) {  		int lastWin32Error = Marshal.GetLastWin32Error ();  		if (lastWin32Error == ERROR_INSUFFICIENT_BUFFER) {  			IntPtr pPrinter = Marshal.AllocHGlobal ((int)needed);  			try {  				if (GetPrinter (printer' 2' pPrinter' needed' out needed)) {  					PRINTER_INFO_2 printerInfo2 = (PRINTER_INFO_2)Marshal.PtrToStructure (pPrinter' typeof(PRINTER_INFO_2));  					cJobs = printerInfo2.cJobs;  					status = printerInfo2.Status;  					return true;  				}  			} finally {  				Marshal.FreeHGlobal (pPrinter);  			}  		}  	}  } finally {  	if (printer != null) {  		printer.Close ();  	}  }  
Magic Number,ikvm.awt.printing,Win32PrintPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\printing.cs,GetPrinterInfo2,The following statement contains a magic number: if (OpenPrinter (printerName' out printer' IntPtr.Zero) && !GetPrinter (printer' 2' IntPtr.Zero' 0' out needed)) {  	int lastWin32Error = Marshal.GetLastWin32Error ();  	if (lastWin32Error == ERROR_INSUFFICIENT_BUFFER) {  		IntPtr pPrinter = Marshal.AllocHGlobal ((int)needed);  		try {  			if (GetPrinter (printer' 2' pPrinter' needed' out needed)) {  				PRINTER_INFO_2 printerInfo2 = (PRINTER_INFO_2)Marshal.PtrToStructure (pPrinter' typeof(PRINTER_INFO_2));  				cJobs = printerInfo2.cJobs;  				status = printerInfo2.Status;  				return true;  			}  		} finally {  			Marshal.FreeHGlobal (pPrinter);  		}  	}  }  
Magic Number,ikvm.awt.printing,Win32PrintPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\printing.cs,GetPrinterInfo2,The following statement contains a magic number: if (OpenPrinter (printerName' out printer' IntPtr.Zero) && !GetPrinter (printer' 2' IntPtr.Zero' 0' out needed)) {  	int lastWin32Error = Marshal.GetLastWin32Error ();  	if (lastWin32Error == ERROR_INSUFFICIENT_BUFFER) {  		IntPtr pPrinter = Marshal.AllocHGlobal ((int)needed);  		try {  			if (GetPrinter (printer' 2' pPrinter' needed' out needed)) {  				PRINTER_INFO_2 printerInfo2 = (PRINTER_INFO_2)Marshal.PtrToStructure (pPrinter' typeof(PRINTER_INFO_2));  				cJobs = printerInfo2.cJobs;  				status = printerInfo2.Status;  				return true;  			}  		} finally {  			Marshal.FreeHGlobal (pPrinter);  		}  	}  }  
Magic Number,ikvm.awt.printing,Win32PrintPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\printing.cs,GetPrinterInfo2,The following statement contains a magic number: if (lastWin32Error == ERROR_INSUFFICIENT_BUFFER) {  	IntPtr pPrinter = Marshal.AllocHGlobal ((int)needed);  	try {  		if (GetPrinter (printer' 2' pPrinter' needed' out needed)) {  			PRINTER_INFO_2 printerInfo2 = (PRINTER_INFO_2)Marshal.PtrToStructure (pPrinter' typeof(PRINTER_INFO_2));  			cJobs = printerInfo2.cJobs;  			status = printerInfo2.Status;  			return true;  		}  	} finally {  		Marshal.FreeHGlobal (pPrinter);  	}  }  
Magic Number,ikvm.awt.printing,Win32PrintPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\printing.cs,GetPrinterInfo2,The following statement contains a magic number: try {  	if (GetPrinter (printer' 2' pPrinter' needed' out needed)) {  		PRINTER_INFO_2 printerInfo2 = (PRINTER_INFO_2)Marshal.PtrToStructure (pPrinter' typeof(PRINTER_INFO_2));  		cJobs = printerInfo2.cJobs;  		status = printerInfo2.Status;  		return true;  	}  } finally {  	Marshal.FreeHGlobal (pPrinter);  }  
Magic Number,ikvm.awt.printing,Win32PrintPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\printing.cs,GetPrinterInfo2,The following statement contains a magic number: if (GetPrinter (printer' 2' pPrinter' needed' out needed)) {  	PRINTER_INFO_2 printerInfo2 = (PRINTER_INFO_2)Marshal.PtrToStructure (pPrinter' typeof(PRINTER_INFO_2));  	cJobs = printerInfo2.cJobs;  	status = printerInfo2.Status;  	return true;  }  
Missing Default,ikvm.awt,J2C,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following switch statement is missing a default case: switch (type) {  case java.awt.geom.PathIterator.__Fields.SEG_MOVETO:  	x = coords [0];  	y = coords [1];  	gp.StartFigure ();  	break;  case java.awt.geom.PathIterator.__Fields.SEG_LINETO:  	gp.AddLine (x' y' coords [0]' coords [1]);  	x = coords [0];  	y = coords [1];  	break;  case java.awt.geom.PathIterator.__Fields.SEG_QUADTO:  	gp.AddBezier (x' y' coords [0]' coords [1]' coords [0]' coords [1]' coords [2]' coords [3]);  	x = coords [2];  	y = coords [3];  	break;  case java.awt.geom.PathIterator.__Fields.SEG_CUBICTO:  	gp.AddBezier (x' y' coords [0]' coords [1]' coords [2]' coords [3]' coords [4]' coords [5]);  	x = coords [4];  	y = coords [5];  	break;  case java.awt.geom.PathIterator.__Fields.SEG_CLOSE:  	gp.CloseFigure ();  	break;  }  
Missing Default,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following switch statement is missing a default case: switch (gradient.getCycleMethod ().ordinal ()) {  case (int)java.awt.MultipleGradientPaint.CycleMethod.__Enum.NO_CYCLE:  case (int)java.awt.MultipleGradientPaint.CycleMethod.__Enum.REFLECT:  	linear.WrapMode = WrapMode.TileFlipXY;  	break;  case (int)java.awt.MultipleGradientPaint.CycleMethod.__Enum.REPEAT:  	linear.WrapMode = WrapMode.Tile;  	break;  }  
Missing Default,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,getRenderingHints,The following switch statement is missing a default case: switch (g.SmoothingMode) {  case SmoothingMode.Default:  	hints.put (java.awt.RenderingHints.KEY_ANTIALIASING' java.awt.RenderingHints.VALUE_ANTIALIAS_DEFAULT);  	break;  case SmoothingMode.None:  	hints.put (java.awt.RenderingHints.KEY_ANTIALIASING' java.awt.RenderingHints.VALUE_ANTIALIAS_OFF);  	break;  case SmoothingMode.AntiAlias:  	hints.put (java.awt.RenderingHints.KEY_ANTIALIASING' java.awt.RenderingHints.VALUE_ANTIALIAS_ON);  	break;  }  
Missing Default,ikvm.awt,NetGraphics,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,getRenderingHints,The following switch statement is missing a default case: switch (g.InterpolationMode) {  case InterpolationMode.Bilinear:  case InterpolationMode.HighQualityBilinear:  	hints.put (java.awt.RenderingHints.KEY_INTERPOLATION' java.awt.RenderingHints.VALUE_INTERPOLATION_BILINEAR);  	break;  case InterpolationMode.Bicubic:  case InterpolationMode.HighQualityBicubic:  	hints.put (java.awt.RenderingHints.KEY_INTERPOLATION' java.awt.RenderingHints.VALUE_INTERPOLATION_BICUBIC);  	break;  case InterpolationMode.NearestNeighbor:  	hints.put (java.awt.RenderingHints.KEY_INTERPOLATION' java.awt.RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR);  	break;  }  
Missing Default,ikvm.awt,WindowsRobot,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\robot.cs,mousePress,The following switch statement is missing a default case: switch (button) {  case InputEvent.BUTTON1_MASK:  	dwFlags |= MOUSEEVENTF_LEFTDOWN;  	break;  case InputEvent.BUTTON2_MASK:  	dwFlags |= MOUSEEVENTF_MIDDLEDOWN;  	break;  case InputEvent.BUTTON3_MASK:  	dwFlags |= MOUSEEVENTF_RIGHTDOWN;  	break;  }  
Missing Default,ikvm.awt,WindowsRobot,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\robot.cs,mouseRelease,The following switch statement is missing a default case: switch (button) {  case InputEvent.BUTTON1_MASK:  	dwFlags |= MOUSEEVENTF_LEFTUP;  	break;  case InputEvent.BUTTON2_MASK:  	dwFlags |= MOUSEEVENTF_MIDDLEUP;  	break;  case InputEvent.BUTTON3_MASK:  	dwFlags |= MOUSEEVENTF_RIGHTUP;  	break;  }  
Missing Default,ikvm.awt,NetComponentPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getAction,The following switch statement is missing a default case: switch (effects) {  case DragDropEffects.None:  	actions = java.awt.dnd.DnDConstants.ACTION_NONE;  	break;  case DragDropEffects.Copy:  	actions = java.awt.dnd.DnDConstants.ACTION_COPY;  	break;  case DragDropEffects.Move:  	actions = java.awt.dnd.DnDConstants.ACTION_MOVE;  	break;  case DragDropEffects.Move | DragDropEffects.Copy:  	actions = java.awt.dnd.DnDConstants.ACTION_COPY_OR_MOVE;  	break;  case DragDropEffects.Link:  	actions = java.awt.dnd.DnDConstants.ACTION_LINK;  	break;  }  
Missing Default,ikvm.awt,NetComponentPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,GetMouseEventModifiers,The following switch statement is missing a default case: switch (button) {  case MouseButtons.Left:  	modifiers |= java.awt.@event.InputEvent.BUTTON1_MASK;  	break;  case MouseButtons.Middle:  	modifiers |= java.awt.@event.InputEvent.BUTTON2_MASK;  	break;  case MouseButtons.Right:  	modifiers |= java.awt.@event.InputEvent.BUTTON3_MASK;  	break;  }  
Missing Default,ikvm.awt,NetComponentPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,GetModifiers,The following switch statement is missing a default case: switch (keys & (Keys.Control | Keys.Alt)) {  case Keys.Control:  	modifiers |= java.awt.@event.InputEvent.CTRL_DOWN_MASK;  	break;  case Keys.Alt:  	modifiers |= java.awt.@event.InputEvent.ALT_DOWN_MASK;  	break;  case Keys.Control | Keys.Alt:  	modifiers |= java.awt.@event.InputEvent.ALT_GRAPH_DOWN_MASK;  	break;  }  
Missing Default,ikvm.awt,NetTextFieldPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,handleJavaKeyEvent,The following switch statement is missing a default case: switch (e.getID ()) {  case java.awt.@event.KeyEvent.KEY_TYPED:  	if ((e.getKeyChar () == '\n') && !e.isAltDown () && !e.isControlDown ()) {  		postEvent (new java.awt.@event.ActionEvent (target' java.awt.@event.ActionEvent.ACTION_PERFORMED' getText ()' e.getWhen ()' e.getModifiers ()));  		return true;  	}  	break;  }  
Missing Default,ikvm.awt,NetFramePeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,setState,The following switch statement is missing a default case: switch (state) {  case java.awt.Frame.NORMAL:  	form.WindowState = FormWindowState.Normal;  	break;  case java.awt.Frame.MAXIMIZED_BOTH:  	form.WindowState = FormWindowState.Maximized;  	break;  case java.awt.Frame.ICONIFIED:  	form.WindowState = FormWindowState.Minimized;  	break;  }  
Missing Default,ikvm.awt,NetTrayIconPeer,F:\newReposMay17\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,displayMessage,The following switch statement is missing a default case: switch (messageType) {  case "ERROR":  	icon = ToolTipIcon.Error;  	break;  case "WARNING":  	icon = ToolTipIcon.Warning;  	break;  case "INFO":  	icon = ToolTipIcon.Info;  	break;  case "NONE":  	icon = ToolTipIcon.None;  	break;  }  
