Implementation smell,Namespace,Class,File,Method,Description
Long Method,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The method has 124 lines of code.
Complex Method,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,Cyclomatic complexity of the method is 10
Complex Method,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setRenderingHint,Cyclomatic complexity of the method is 14
Complex Method,ikvm.awt,NetDataTransferer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,translateFromClipboard,Cyclomatic complexity of the method is 9
Complex Method,ikvm.awt.printing,Win32PrintPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\printing.cs,getPrinterStatus,Cyclomatic complexity of the method is 9
Complex Method,ikvm.awt.printing,Win32PrintPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\printing.cs,extractResions,Cyclomatic complexity of the method is 26
Long Parameter List,ikvm.awt,J2C,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertRoundRect,The method has 6 parameters. Parameters: x' y' w' h' arcWidth' arcHeight
Long Parameter List,ikvm.awt,BitmapGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,copyArea,The method has 6 parameters. Parameters: x' y' width' height' dx' dy
Long Parameter List,ikvm.awt,ComponentGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,copyArea,The method has 6 parameters. Parameters: x' y' width' height' dx' dy
Long Parameter List,ikvm.awt,PrintGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,copyArea,The method has 6 parameters. Parameters: x' y' width' height' dx' dy
Long Parameter List,ikvm.awt,PrintGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawArc,The method has 6 parameters. Parameters: x' y' width' height' startAngle' arcAngle
Long Parameter List,ikvm.awt,PrintGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawBytes,The method has 5 parameters. Parameters: data' offset' length' x' y
Long Parameter List,ikvm.awt,PrintGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawChars,The method has 5 parameters. Parameters: data' offset' length' x' y
Long Parameter List,ikvm.awt,PrintGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawImage,The method has 11 parameters. Parameters: img' dx1' dy1' dx2' dy2' sx1' sy1' sx2' sy2' color' observer
Long Parameter List,ikvm.awt,PrintGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawImage,The method has 10 parameters. Parameters: img' dx1' dy1' dx2' dy2' sx1' sy1' sx2' sy2' observer
Long Parameter List,ikvm.awt,PrintGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawImage,The method has 7 parameters. Parameters: img' x' y' width' height' bgcolor' observer
Long Parameter List,ikvm.awt,PrintGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawImage,The method has 5 parameters. Parameters: img' x' y' bgcolor' observer
Long Parameter List,ikvm.awt,PrintGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawImage,The method has 6 parameters. Parameters: img' x' y' width' height' observer
Long Parameter List,ikvm.awt,PrintGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawRoundRect,The method has 6 parameters. Parameters: x' y' w' h' arcWidth' arcHeight
Long Parameter List,ikvm.awt,PrintGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,fill3DRect,The method has 5 parameters. Parameters: x' y' width' height' raised
Long Parameter List,ikvm.awt,PrintGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,fillArc,The method has 6 parameters. Parameters: x' y' width' height' startAngle' arcAngle
Long Parameter List,ikvm.awt,PrintGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,fillRoundRect,The method has 6 parameters. Parameters: x' y' w' h' arcWidth' arcHeight
Long Parameter List,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawArc,The method has 6 parameters. Parameters: x' y' width' height' startAngle' arcAngle
Long Parameter List,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawBytes,The method has 5 parameters. Parameters: data' offset' length' x' y
Long Parameter List,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawChars,The method has 5 parameters. Parameters: data' offset' length' x' y
Long Parameter List,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawImage,The method has 11 parameters. Parameters: img' dx1' dy1' dx2' dy2' sx1' sy1' sx2' sy2' color' observer
Long Parameter List,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawImage,The method has 10 parameters. Parameters: img' dx1' dy1' dx2' dy2' sx1' sy1' sx2' sy2' observer
Long Parameter List,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawImage,The method has 7 parameters. Parameters: img' x' y' width' height' bgcolor' observer
Long Parameter List,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawImage,The method has 5 parameters. Parameters: img' x' y' bgcolor' observer
Long Parameter List,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawImage,The method has 6 parameters. Parameters: img' x' y' width' height' observer
Long Parameter List,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawRoundRect,The method has 6 parameters. Parameters: x' y' w' h' arcWidth' arcHeight
Long Parameter List,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,fill3DRect,The method has 5 parameters. Parameters: x' y' width' height' raised
Long Parameter List,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,fillArc,The method has 6 parameters. Parameters: x' y' width' height' startAngle' arcAngle
Long Parameter List,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,fillRoundRect,The method has 6 parameters. Parameters: x' y' w' h' arcWidth' arcHeight
Long Parameter List,ikvm.awt,WindowsRobot,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\robot.cs,mouse_event,The method has 5 parameters. Parameters: dwFlags' dx' dy' dwData' dwExtraInfo
Long Parameter List,ikvm.awt,NetToolkit,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,createDragGestureRecognizer,The method has 5 parameters. Parameters: abstractRecognizerClass' ds' c' srcActions' dgl
Long Parameter List,ikvm.awt,NetToolkit,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,outline,The method has 5 parameters. Parameters: javaFont' frc' text' x' y
Long Parameter List,ikvm.awt,NetDragSourceContextPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,createDragSource,The method has 6 parameters. Parameters: component' transferable' nativeTrigger' actions' formats' formatMap
Long Parameter List,ikvm.awt,NetDropTargetContextPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,handleEnterMessage,The method has 7 parameters. Parameters: component' x' y' dropAction' actions' formats' nativeCtxt
Long Parameter List,ikvm.awt,NetDropTargetContextPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,handleMotionMessage,The method has 7 parameters. Parameters: component' x' y' dropAction' actions' formats' nativeCtxt
Long Parameter List,ikvm.awt,NetDropTargetContextPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,handleDropMessage,The method has 8 parameters. Parameters: component' x' y' dropAction' actions' formats' nativeCtxt' data
Long Parameter List,ikvm.awt,NetDropTargetContextPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,postDropTargetEvent,The method has 9 parameters. Parameters: component' x' y' dropAction' actions' formats' nativeCtxt' eventID' dispatchType
Long Parameter List,ikvm.awt,NetComponentPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,repaint,The method has 5 parameters. Parameters: l' i1' i2' i3' i4
Long Parameter List,ikvm.awt,NetComponentPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,requestFocus,The method has 5 parameters. Parameters: c' b1' b2' l' cfec
Long Parameter List,ikvm.awt,NetComponentPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,setBounds,The method has 5 parameters. Parameters: i1' i2' i3' i4' i5
Long Parameter List,ikvm.awt,NetComponentPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,flip,The method has 5 parameters. Parameters: x1' y1' x2' y2' flipAction
Long Parameter List,ikvm.awt,NetComponentPeer<T;C>,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,repaint,The method has 5 parameters. Parameters: tm' x' y' width' height
Long Parameter List,ikvm.awt,NetComponentPeer<T;C>,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,setBounds,The method has 5 parameters. Parameters: x' y' width' height' op
Long Parameter List,ikvm.awt,NetComponentPeer<T;C>,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,requestFocus,The method has 5 parameters. Parameters: lightweightChild' temporary' focusedWindowChangeAllowed' time' cause
Long Parameter List,ikvm.awt,NetComponentPeer<T;C>,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,flip,The method has 5 parameters. Parameters: x1' y1' x2' y2' flipAction
Long Parameter List,IKVM.NativeCode.sun.awt,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,GetDIBits,The method has 7 parameters. Parameters: hdc' hbmp' uStartScan' cScanLines' lpvBits' lpbmi' uUsage
Long Parameter List,IKVM.NativeCode.sun.awt,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,GetDIBits,The method has 7 parameters. Parameters: hdc' hbmp' uStartScan' cScanLines' lpvBits' lpbmi' uUsage
Long Parameter List,IKVM.NativeCode.sun.awt,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,CreateWindowEx,The method has 12 parameters. Parameters: dwExStyle' lpClassName' lpWindowName' dwStyle' x' y' nWidth' nHeight' hWndParent' hMenu' hInstance' lpParam
Long Parameter List,IKVM.NativeCode.sun.awt,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,LoadImage,The method has 6 parameters. Parameters: hInstance' uID' type' width' height' load
Long Parameter List,IKVM.NativeCode.sun.awt,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,LoadImage,The method has 6 parameters. Parameters: hInstance' lpszName' type' width' height' load
Long Parameter List,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,GetDIBits,The method has 7 parameters. Parameters: hdc' hbmp' uStartScan' cScanLines' lpvBits' lpbmi' uUsage
Long Parameter List,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,GetDIBits,The method has 7 parameters. Parameters: hdc' hbmp' uStartScan' cScanLines' lpvBits' lpbmi' uUsage
Long Parameter List,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,CreateWindowEx,The method has 12 parameters. Parameters: dwExStyle' lpClassName' lpWindowName' dwStyle' x' y' nWidth' nHeight' hWndParent' hMenu' hInstance' lpParam
Long Parameter List,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,LoadImage,The method has 6 parameters. Parameters: hInstance' uID' type' width' height' load
Long Parameter List,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,LoadImage,The method has 6 parameters. Parameters: hInstance' lpszName' type' width' height' load
Long Parameter List,IKVM.NativeCode.sun.java2d,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,GetDIBits,The method has 7 parameters. Parameters: hdc' hbmp' uStartScan' cScanLines' lpvBits' lpbmi' uUsage
Long Parameter List,IKVM.NativeCode.sun.java2d,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,GetDIBits,The method has 7 parameters. Parameters: hdc' hbmp' uStartScan' cScanLines' lpvBits' lpbmi' uUsage
Long Parameter List,IKVM.NativeCode.sun.java2d,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,CreateWindowEx,The method has 12 parameters. Parameters: dwExStyle' lpClassName' lpWindowName' dwStyle' x' y' nWidth' nHeight' hWndParent' hMenu' hInstance' lpParam
Long Parameter List,IKVM.NativeCode.sun.java2d,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,LoadImage,The method has 6 parameters. Parameters: hInstance' uID' type' width' height' load
Long Parameter List,IKVM.NativeCode.sun.java2d,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,LoadImage,The method has 6 parameters. Parameters: hInstance' lpszName' type' width' height' load
Long Parameter List,IKVM.NativeCode.sun.java2d.pipe,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,GetDIBits,The method has 7 parameters. Parameters: hdc' hbmp' uStartScan' cScanLines' lpvBits' lpbmi' uUsage
Long Parameter List,IKVM.NativeCode.sun.java2d.pipe,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,GetDIBits,The method has 7 parameters. Parameters: hdc' hbmp' uStartScan' cScanLines' lpvBits' lpbmi' uUsage
Long Parameter List,IKVM.NativeCode.sun.java2d.pipe,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,CreateWindowEx,The method has 12 parameters. Parameters: dwExStyle' lpClassName' lpWindowName' dwStyle' x' y' nWidth' nHeight' hWndParent' hMenu' hInstance' lpParam
Long Parameter List,IKVM.NativeCode.sun.java2d.pipe,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,LoadImage,The method has 6 parameters. Parameters: hInstance' uID' type' width' height' load
Long Parameter List,IKVM.NativeCode.sun.java2d.pipe,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,LoadImage,The method has 6 parameters. Parameters: hInstance' lpszName' type' width' height' load
Long Parameter List,ikvm.awt.printing,Win32PrintPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\printing.cs,GetPrinter,The method has 5 parameters. Parameters: hPrinter' dwLevel' pPrinter' cbBuf' pcbNeeded
Long Parameter List,awt,ShellApi,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\ShellApi.cs,SHGetFileInfo,The method has 5 parameters. Parameters: pszPath' dwFileAttribs' psfi' cbFileInfo' uFlags
Long Parameter List,awt,ShellApi,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\ShellApi.cs,SHGetFileInfo,The method has 5 parameters. Parameters: pIDL' dwFileAttributes' psfi' cbFileInfo' uFlags
Long Parameter List,awt,IShellFolder,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\ShellApi.cs,ParseDisplayName,The method has 6 parameters. Parameters: hwnd' pbc' pszDisplayName' pchEaten' ppidl' pdwAttributes
Long Parameter List,awt,IShellFolder,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\ShellApi.cs,GetUIObjectOf,The method has 6 parameters. Parameters: hwndOwner' cidl' apidl' riid' rgfReserved' ppv
Long Parameter List,awt,IShellFolder,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\ShellApi.cs,SetNameOf,The method has 5 parameters. Parameters: hwnd' pidl' pszName' uFlags' ppidlOut
Long Parameter List,awt,IExtractIcon,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\ShellApi.cs,GetIconLocation,The method has 5 parameters. Parameters: uFlags' szIconFile' cchMax' piIndex' pwFlags
Long Parameter List,awt,IExtractIcon,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\ShellApi.cs,Extract,The method has 5 parameters. Parameters: pstFile' nIconIndex' phiconLarge' phiconSmall' nIconSize
Long Identifier,ikvm.awt,NetToolkit,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,,The length of the parameter eventQueueSynchronizationContext is 32.
Long Identifier,ikvm.awt,NetComponentPeer<T;C>,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,,The length of the parameter shouldNativelyFocusHeavyweight is 30.
Long Identifier,ikvm.awt,NetComponentPeer<T;C>,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,,The length of the parameter processSynchronousLightweightTransfer is 37.
Long Identifier,ikvm.awt.printing,Win32PrintPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\printing.cs,,The length of the parameter PRINTER_STATUS_PENDING_DELETION is 31.
Long Identifier,ikvm.awt.printing,Win32PrintPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\printing.cs,,The length of the parameter PRINTER_STATUS_OUTPUT_BIN_FULL is 30.
Long Identifier,ikvm.awt.printing,Win32PrintPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\printing.cs,,The length of the parameter PRINTER_STATUS_USER_INTERVENTION is 32.
Long Statement,ikvm.awt,NetGraphicsState,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,restoreGraphics,The length of the statement  "                netG.setRenderingHint(java.awt.RenderingHints.KEY_TEXT_ANTIALIASING' java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_DEFAULT); " is 123.
Long Statement,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawImage,The length of the statement  "                g.DrawImage(image' new Rectangle( x' y' width' height)' 0' 0' image.Width' image.Height' GraphicsUnit.Pixel' composite.GetImageAttributes()); " is 141.
Long Statement,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawImage,The length of the statement  "                g.DrawImage(image' new Rectangle(x' y' width' height)' 0' 0' image.Width' image.Height' GraphicsUnit.Pixel' composite.GetImageAttributes()); " is 140.
Long Statement,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawString,The length of the statement  "            format.FormatFlags = StringFormatFlags.MeasureTrailingSpaces | StringFormatFlags.NoWrap | StringFormatFlags.FitBlackBox; " is 120.
Long Statement,ikvm.awt,NoImage,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\images.cs,getWidth,The length of the statement  "                observer.imageUpdate(this' java.awt.image.ImageObserver.__Fields.ERROR | java.awt.image.ImageObserver.__Fields.ABORT' 0' 0' -1' -1); " is 132.
Long Statement,ikvm.awt,NoImage,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\images.cs,getHeight,The length of the statement  "                observer.imageUpdate(this' java.awt.image.ImageObserver.__Fields.ERROR | java.awt.image.ImageObserver.__Fields.ABORT' 0' 0' -1' -1); " is 132.
Long Statement,ikvm.awt,NoImage,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\images.cs,getProperty,The length of the statement  "                observer.imageUpdate(this' java.awt.image.ImageObserver.__Fields.ERROR | java.awt.image.ImageObserver.__Fields.ABORT' 0' 0' -1' -1); " is 132.
Long Statement,ikvm.awt,WindowsRobot,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\robot.cs,MapKeyCode,The length of the statement  "            //http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winui/WinUI/WindowsUserInterface/UserInput/VirtualKeyCodes.asp " is 129.
Long Statement,ikvm.awt,NetToolkit,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,InstallEventQueueSynchronizationContext,The length of the statement  "				eq.postEvent(new java.awt.@event.InvocationEvent(this' Delegates.toRunnable(EventQueueSynchronizationContext.Install)' null' true)); " is 132.
Long Statement,ikvm.awt,NetToolkit,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,isWin32,The length of the statement  "            return Environment.OSVersion.Platform == PlatformID.Win32NT || Environment.OSVersion.Platform == PlatformID.Win32Windows; " is 121.
Long Statement,ikvm.awt,NetToolkit,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,createFrame,The length of the statement  "            java.awt.peer.FramePeer peer = Invoke<NetFramePeer>(delegate { return new NetFramePeer(target' isFocusableWindow' isAlwaysOnTop); }); " is 133.
Long Statement,ikvm.awt,NetToolkit,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,createWindow,The length of the statement  "			java.awt.peer.WindowPeer peer = Invoke<NetWindowPeer>(delegate { return new NetWindowPeer(target' isFocusableWindow' isAlwaysOnTop); }); " is 136.
Long Statement,ikvm.awt,NetToolkit,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,createDialog,The length of the statement  "			java.awt.peer.DialogPeer peer = Invoke<NetDialogPeer>(delegate { return new NetDialogPeer(target' isFocusableWindow' isAlwaysOnTop); }); " is 136.
Long Statement,ikvm.awt,NetToolkit,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,createFileDialog,The length of the statement  "			java.awt.peer.FileDialogPeer peer = Invoke<NetFileDialogPeer>(delegate { return new NetFileDialogPeer(target' isFocusableWindow' isAlwaysOnTop); }); " is 148.
Long Statement,ikvm.awt,NetToolkit,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getImage,The length of the statement  "                filename = new java.io.File(filename).getPath(); //convert a Java file name to .NET filename (slahes' backslasches' etc) " is 120.
Long Statement,ikvm.awt,NetToolkit,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getImage,The length of the statement  "                using (System.IO.FileStream stream = new System.IO.FileStream(filename' FileMode.Open' FileAccess.Read' FileShare.ReadWrite)) " is 125.
Long Statement,ikvm.awt,NetToolkit,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,initializeDesktopProperties,The length of the statement  "//                    string dllName = (string)getRegistry("Software\\Microsoft\\Windows\\CurrentVersion\\ThemeManager"' "DllName"); " is 132.
Long Statement,ikvm.awt,NetToolkit,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,initializeDesktopProperties,The length of the statement  "//                    string sizeName = (string)getRegistry("Software\\Microsoft\\Windows\\CurrentVersion\\ThemeManager"' "SizeName"); " is 134.
Long Statement,ikvm.awt,NetToolkit,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,initializeDesktopProperties,The length of the statement  "//                    string colorName = (string)getRegistry("Software\\Microsoft\\Windows\\CurrentVersion\\ThemeManager"' "ColorName"); " is 136.
Long Statement,ikvm.awt,NetToolkit,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,outline,The length of the statement  "            format.FormatFlags = StringFormatFlags.MeasureTrailingSpaces | StringFormatFlags.NoWrap | StringFormatFlags.FitBlackBox; " is 120.
Long Statement,ikvm.awt,NetMenuItemPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,OnClick,The length of the statement  "				NetToolkit.postEvent(NetToolkit.targetToAppContext(target)' new java.awt.@event.ActionEvent(target' java.awt.@event.ActionEvent.ACTION_PERFORMED' " is 145.
Long Statement,ikvm.awt,NetCheckboxMenuItemPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,OnClick,The length of the statement  "				NetToolkit.postEvent(NetToolkit.targetToAppContext(target)' new java.awt.@event.ItemEvent(target' java.awt.@event.ItemEvent.ITEM_STATE_CHANGED' " is 143.
Long Statement,ikvm.awt,NetComponentPeer<T;C>,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,OnKeyDown,The length of the statement  "				postEvent(new java.awt.@event.KeyEvent(target' java.awt.@event.KeyEvent.KEY_PRESSED' when' modifiers' keyCode' keyChar' keyLocation)); " is 134.
Long Statement,ikvm.awt,NetComponentPeer<T;C>,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,OnDragEnter,The length of the statement  "            int actions = dropTargetPeer.handleEnterMessage(target' e.X' e.Y' getDropAction(e.AllowedEffect' e.KeyState)' getAction(e.AllowedEffect)' " is 137.
Long Statement,ikvm.awt,NetComponentPeer<T;C>,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,OnDragOver,The length of the statement  "            int actions = dropTargetPeer.handleMotionMessage(target' e.X' e.Y' getDropAction(e.AllowedEffect' e.KeyState)' getAction(e.AllowedEffect)' " is 138.
Long Statement,ikvm.awt,NetComponentPeer<T;C>,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,OnKeyUp,The length of the statement  "				postEvent(new java.awt.@event.KeyEvent(target' java.awt.@event.KeyEvent.KEY_RELEASED' when' modifiers' keyCode' keyChar' keyLocation)); " is 135.
Long Statement,ikvm.awt,NetComponentPeer<T;C>,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,OnKeyPress,The length of the statement  "				postEvent(new java.awt.@event.KeyEvent(target' java.awt.@event.KeyEvent.KEY_TYPED' when' modifiers' keyCode' keyChar' keyLocation)); " is 132.
Long Statement,ikvm.awt,NetComponentPeer<T;C>,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,postMouseWheelEvent,The length of the statement  "                postEvent(new java.awt.@event.MouseWheelEvent(target' id' when' modifiers' x' y' clickCount' isPopup' java.awt.@event.MouseWheelEvent.WHEEL_UNIT_SCROLL' scrollAmount' scrollAmount)); " is 182.
Long Statement,ikvm.awt,NetComponentPeer<T;C>,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,handleEvent,The length of the statement  "			if (((java.awt.Component)target).isEnabled() && (e is java.awt.@event.KeyEvent) && !((java.awt.@event.KeyEvent)e).isConsumed()) " is 127.
Long Statement,ikvm.awt,NetButtonPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getMinimumSize,The length of the statement  "				return new java.awt.Dimension((int)Math.Round(12 + g.MeasureString(control.Text' control.Font).Width) * 8 / 7' 6 + control.Font.Height * 8 / 7); " is 144.
Long Statement,ikvm.awt,NetTextFieldPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getPreferredSize,The length of the statement  "				return new java.awt.Dimension((int)Math.Round((g.MeasureString("abcdefghijklm"' control.Font).Width * len) / 13)' ((TextBox)control).PreferredHeight); " is 150.
Long Statement,ikvm.awt,NetWindowPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,initialize,The length of the statement  "                AWTAccessor.getComponentAccessor().setBackground(target' target is java.awt.Dialog ? java.awt.SystemColor.control : java.awt.SystemColor.window); " is 145.
Long Statement,ikvm.awt,NetWindowPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,OnSizeChanged,The length of the statement  "			typeof(java.awt.Component).GetField("width"' BindingFlags.Instance | BindingFlags.NonPublic).SetValue(target' control.Width); " is 125.
Long Statement,ikvm.awt,NetWindowPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,OnSizeChanged,The length of the statement  "			typeof(java.awt.Component).GetField("height"' BindingFlags.Instance | BindingFlags.NonPublic).SetValue(target' control.Height); " is 127.
Long Statement,ikvm.awt,NetWindowPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,SendWindowEvent,The length of the statement  "				ConstructorInfo cons = type.GetConstructor(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public' null' new Type[] { typeof(java.awt.AWTEvent) }' null); " is 167.
Long Statement,ikvm.awt,NetWindowPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,updateFocusableWindowState,The length of the statement  "            ((UndecoratedForm)control).SetWindowState(((java.awt.Window)target).isFocusableWindow()' ((java.awt.Window)target).isAlwaysOnTop()); " is 132.
Long Statement,ikvm.awt,NetTrayIconPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,postMouseEvent,The length of the statement  "                java.awt.@event.MouseEvent mouseEvent = new java.awt.@event.MouseEvent(fake' id' when' modifiers' x' y' clickCount' isPopup' button); " is 133.
Long Statement,ikvm.awt,NetTrayIconPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,postMouseEvent,The length of the statement  "                java.awt.@event.MouseEvent mouseEvent = new java.awt.@event.MouseEvent(fake' id' when' modifiers' x' y' clickCount' isPopup' button); " is 133.
Long Statement,ikvm.awt,NetTrayIconPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,OnDoubleClick,The length of the statement  "            postEvent(new java.awt.@event.ActionEvent(target' java.awt.@event.ActionEvent.ACTION_PERFORMED' target.getActionCommand()' when' modifiers)); " is 141.
Long Statement,ikvm.awt,NetDataTransferer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,translateFromClipboard,The length of the statement  "            java.awt.datatransfer.FlavorTable defaultFlavorMap = (java.awt.datatransfer.FlavorTable)java.awt.datatransfer.SystemFlavorMap.getDefaultFlavorMap(); " is 148.
Long Statement,ikvm.awt,NetDataTransferer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getDataObject,The length of the statement  "            SortedMap/*<java.lang.Long'java.awt.datatransfer.DataFlavor>*/ formatMap = getFormatsForTransferable(transferable' flavorMap); " is 126.
Long Statement,IKVM.NativeCode.sun.awt,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getFolderType,The length of the statement  "			if (ShellApi.SHGetFileInfo(path' 0' out shinfo' (uint)Marshal.SizeOf(shinfo)' ShellApi.SHGFI.SHGFI_TYPENAME) == IntPtr.Zero) " is 124.
Long Statement,IKVM.NativeCode.sun.awt,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getIconBits,The length of the statement  "                    BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' iconSize' iconSize)' ImageLockMode.WriteOnly' PixelFormat.Format32bppArgb); " is 135.
Long Statement,IKVM.NativeCode.sun.awt,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getAttribute,The length of the statement  "            if (ShellApi.SHGetFileInfo(path' 0' out shinfo' (uint)Marshal.SizeOf(shinfo)' ShellApi.SHGFI.SHGFI_ATTRIBUTES) == IntPtr.Zero) " is 126.
Long Statement,IKVM.NativeCode.sun.awt,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getStandardViewButton0,The length of the statement  "                IntPtr hWndToolbar = CreateWindowEx(0' "ToolbarWindow32"' null' 0' 0' 0' 0' 0' IntPtr.Zero' IntPtr.Zero' IntPtr.Zero' IntPtr.Zero); " is 131.
Long Statement,IKVM.NativeCode.sun.awt,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getFolderType,The length of the statement  "            ShellApi.SHGetFileInfo(pIDL' 0' out fileInfo' (uint)Marshal.SizeOf(fileInfo)' ShellApi.SHGFI.SHGFI_PIDL | ShellApi.SHGFI.SHGFI_TYPENAME); " is 137.
Long Statement,IKVM.NativeCode.sun.awt,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getIcon,The length of the statement  "            if (ShellApi.SHGetFileInfo(absolutePath' 0' out shinfo' (uint)Marshal.SizeOf(shinfo)' ShellApi.SHGFI.SHGFI_ICON | (getLargeIcon ? ShellApi.SHGFI.SHGFI_LARGEICON : ShellApi.SHGFI.SHGFI_SMALLICON)) == IntPtr.Zero) " is 211.
Long Statement,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getFolderType,The length of the statement  "			if (ShellApi.SHGetFileInfo(path' 0' out shinfo' (uint)Marshal.SizeOf(shinfo)' ShellApi.SHGFI.SHGFI_TYPENAME) == IntPtr.Zero) " is 124.
Long Statement,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getIconBits,The length of the statement  "                    BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' iconSize' iconSize)' ImageLockMode.WriteOnly' PixelFormat.Format32bppArgb); " is 135.
Long Statement,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getAttribute,The length of the statement  "            if (ShellApi.SHGetFileInfo(path' 0' out shinfo' (uint)Marshal.SizeOf(shinfo)' ShellApi.SHGFI.SHGFI_ATTRIBUTES) == IntPtr.Zero) " is 126.
Long Statement,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getStandardViewButton0,The length of the statement  "                IntPtr hWndToolbar = CreateWindowEx(0' "ToolbarWindow32"' null' 0' 0' 0' 0' 0' IntPtr.Zero' IntPtr.Zero' IntPtr.Zero' IntPtr.Zero); " is 131.
Long Statement,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getFolderType,The length of the statement  "            ShellApi.SHGetFileInfo(pIDL' 0' out fileInfo' (uint)Marshal.SizeOf(fileInfo)' ShellApi.SHGFI.SHGFI_PIDL | ShellApi.SHGFI.SHGFI_TYPENAME); " is 137.
Long Statement,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getIcon,The length of the statement  "            if (ShellApi.SHGetFileInfo(absolutePath' 0' out shinfo' (uint)Marshal.SizeOf(shinfo)' ShellApi.SHGFI.SHGFI_ICON | (getLargeIcon ? ShellApi.SHGFI.SHGFI_LARGEICON : ShellApi.SHGFI.SHGFI_SMALLICON)) == IntPtr.Zero) " is 211.
Long Statement,IKVM.NativeCode.sun.java2d,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getFolderType,The length of the statement  "			if (ShellApi.SHGetFileInfo(path' 0' out shinfo' (uint)Marshal.SizeOf(shinfo)' ShellApi.SHGFI.SHGFI_TYPENAME) == IntPtr.Zero) " is 124.
Long Statement,IKVM.NativeCode.sun.java2d,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getIconBits,The length of the statement  "                    BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' iconSize' iconSize)' ImageLockMode.WriteOnly' PixelFormat.Format32bppArgb); " is 135.
Long Statement,IKVM.NativeCode.sun.java2d,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getAttribute,The length of the statement  "            if (ShellApi.SHGetFileInfo(path' 0' out shinfo' (uint)Marshal.SizeOf(shinfo)' ShellApi.SHGFI.SHGFI_ATTRIBUTES) == IntPtr.Zero) " is 126.
Long Statement,IKVM.NativeCode.sun.java2d,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getStandardViewButton0,The length of the statement  "                IntPtr hWndToolbar = CreateWindowEx(0' "ToolbarWindow32"' null' 0' 0' 0' 0' 0' IntPtr.Zero' IntPtr.Zero' IntPtr.Zero' IntPtr.Zero); " is 131.
Long Statement,IKVM.NativeCode.sun.java2d,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getFolderType,The length of the statement  "            ShellApi.SHGetFileInfo(pIDL' 0' out fileInfo' (uint)Marshal.SizeOf(fileInfo)' ShellApi.SHGFI.SHGFI_PIDL | ShellApi.SHGFI.SHGFI_TYPENAME); " is 137.
Long Statement,IKVM.NativeCode.sun.java2d,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getIcon,The length of the statement  "            if (ShellApi.SHGetFileInfo(absolutePath' 0' out shinfo' (uint)Marshal.SizeOf(shinfo)' ShellApi.SHGFI.SHGFI_ICON | (getLargeIcon ? ShellApi.SHGFI.SHGFI_LARGEICON : ShellApi.SHGFI.SHGFI_SMALLICON)) == IntPtr.Zero) " is 211.
Long Statement,IKVM.NativeCode.sun.java2d.pipe,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getFolderType,The length of the statement  "			if (ShellApi.SHGetFileInfo(path' 0' out shinfo' (uint)Marshal.SizeOf(shinfo)' ShellApi.SHGFI.SHGFI_TYPENAME) == IntPtr.Zero) " is 124.
Long Statement,IKVM.NativeCode.sun.java2d.pipe,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getIconBits,The length of the statement  "                    BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' iconSize' iconSize)' ImageLockMode.WriteOnly' PixelFormat.Format32bppArgb); " is 135.
Long Statement,IKVM.NativeCode.sun.java2d.pipe,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getAttribute,The length of the statement  "            if (ShellApi.SHGetFileInfo(path' 0' out shinfo' (uint)Marshal.SizeOf(shinfo)' ShellApi.SHGFI.SHGFI_ATTRIBUTES) == IntPtr.Zero) " is 126.
Long Statement,IKVM.NativeCode.sun.java2d.pipe,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getStandardViewButton0,The length of the statement  "                IntPtr hWndToolbar = CreateWindowEx(0' "ToolbarWindow32"' null' 0' 0' 0' 0' 0' IntPtr.Zero' IntPtr.Zero' IntPtr.Zero' IntPtr.Zero); " is 131.
Long Statement,IKVM.NativeCode.sun.java2d.pipe,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getFolderType,The length of the statement  "            ShellApi.SHGetFileInfo(pIDL' 0' out fileInfo' (uint)Marshal.SizeOf(fileInfo)' ShellApi.SHGFI.SHGFI_PIDL | ShellApi.SHGFI.SHGFI_TYPENAME); " is 137.
Long Statement,IKVM.NativeCode.sun.java2d.pipe,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getIcon,The length of the statement  "            if (ShellApi.SHGetFileInfo(absolutePath' 0' out shinfo' (uint)Marshal.SizeOf(shinfo)' ShellApi.SHGFI.SHGFI_ICON | (getLargeIcon ? ShellApi.SHGFI.SHGFI_LARGEICON : ShellApi.SHGFI.SHGFI_SMALLICON)) == IntPtr.Zero) " is 211.
Long Statement,ikvm.awt.printing,Win32PrintPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\printing.cs,extractResions,The length of the statement  "                reasons.put(javax.print.attribute.standard.PrinterStateReason.MEDIA_JAM' javax.print.attribute.standard.Severity.WARNING); " is 122.
Long Statement,ikvm.awt.printing,Win32PrintPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\printing.cs,extractResions,The length of the statement  "                reasons.put(javax.print.attribute.standard.PrinterStateReason.MEDIA_EMPTY' javax.print.attribute.standard.Severity.WARNING); " is 124.
Long Statement,ikvm.awt.printing,Win32PrintPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\printing.cs,extractResions,The length of the statement  "                reasons.put(javax.print.attribute.standard.PrinterStateReason.TIMED_OUT' javax.print.attribute.standard.Severity.ERROR); " is 120.
Long Statement,ikvm.awt.printing,Win32PrintPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\printing.cs,extractResions,The length of the statement  "                reasons.put(javax.print.attribute.standard.PrinterStateReason.OUTPUT_AREA_FULL' javax.print.attribute.standard.Severity.WARNING); " is 129.
Long Statement,ikvm.awt.printing,Win32PrintPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\printing.cs,extractResions,The length of the statement  "                reasons.put(javax.print.attribute.standard.PrinterStateReason.TONER_LOW' javax.print.attribute.standard.Severity.WARNING); " is 122.
Long Statement,ikvm.awt.printing,Win32PrintPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\printing.cs,extractResions,The length of the statement  "                reasons.put(javax.print.attribute.standard.PrinterStateReason.TONER_EMPTY' javax.print.attribute.standard.Severity.ERROR); " is 122.
Long Statement,ikvm.awt.printing,Win32PrintPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\printing.cs,extractResions,The length of the statement  "                reasons.put(javax.print.attribute.standard.PrinterStateReason.DOOR_OPEN' javax.print.attribute.standard.Severity.ERROR); " is 120.
Complex Conditional,ikvm.awt,NetCustomCursor,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,NetCustomCursor,The conditional expression  "hotSpot.x >= width || hotSpot.y >= height || hotSpot.x < 0 || hotSpot.y < 0"  is complex.
Virtual Method Call from Constructor,ikvm.awt,AlphaCompositeHelper,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\composite.cs,AlphaCompositeHelper,The constructor "AlphaCompositeHelper" calls a virtual method "GetImageAttributes".
Virtual Method Call from Constructor,ikvm.awt,ClearCompositeHelper,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\composite.cs,ClearCompositeHelper,The constructor "ClearCompositeHelper" calls a virtual method "GetImageAttributes".
Virtual Method Call from Constructor,ikvm.awt,UndecoratedForm,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,UndecoratedForm,The constructor "UndecoratedForm" calls a virtual method "setBorderStyle".
Empty Catch Block,ikvm.awt,NetToolkit,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,initializeDesktopProperties,The method has an empty catch block.
Empty Catch Block,ikvm.awt,NetCustomCursor,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,NetCustomCursor,The method has an empty catch block.
Empty Catch Block,ikvm.awt,NetComponentPeer<T;C>,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,setBounds,The method has an empty catch block.
Empty Catch Block,ikvm.awt,NetToolkitThreadBlockedHandler,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,lock,The method has an empty catch block.
Magic Number,ikvm.awt,J2C,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertRoundRect,The following statement contains a magic number: int a = arcWidth / 2;
Magic Number,ikvm.awt,J2C,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertRoundRect,The following statement contains a magic number: int b = arcHeight / 2;
Magic Number,ikvm.awt,J2C,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertRoundRect,The following statement contains a magic number: if (drawArc)              {                  gp.AddArc(x + w - arcWidth' y' arcWidth' arcHeight' 270' 90); //upper right arc              }
Magic Number,ikvm.awt,J2C,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertRoundRect,The following statement contains a magic number: if (drawArc)              {                  gp.AddArc(x + w - arcWidth' y' arcWidth' arcHeight' 270' 90); //upper right arc              }
Magic Number,ikvm.awt,J2C,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertRoundRect,The following statement contains a magic number: if (drawArc)              {                  gp.AddArc(x + w - arcWidth' y + h - arcHeight' arcWidth' arcHeight' 0' 90); //lower right arc              }
Magic Number,ikvm.awt,J2C,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertRoundRect,The following statement contains a magic number: if (drawArc)              {                  gp.AddArc(x' y + h - arcHeight' arcWidth' arcHeight' 90' 90);//lower left arc              }
Magic Number,ikvm.awt,J2C,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertRoundRect,The following statement contains a magic number: if (drawArc)              {                  gp.AddArc(x' y + h - arcHeight' arcWidth' arcHeight' 90' 90);//lower left arc              }
Magic Number,ikvm.awt,J2C,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertRoundRect,The following statement contains a magic number: if (drawArc)              {                  gp.AddArc(x' y' arcWidth' arcHeight' 180' 90); //upper left arc              }
Magic Number,ikvm.awt,J2C,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertRoundRect,The following statement contains a magic number: if (drawArc)              {                  gp.AddArc(x' y' arcWidth' arcHeight' 180' 90); //upper left arc              }
Magic Number,ikvm.awt,J2C,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: float[] coords = new float[6];
Magic Number,ikvm.awt,J2C,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: while (!iterator.isDone())              {                  int type = iterator.currentSegment(coords);                  switch (type)                  {                      case java.awt.geom.PathIterator.__Fields.SEG_MOVETO:                          x = coords[0];                          y = coords[1];                          gp.StartFigure();                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_LINETO:                          gp.AddLine(x' y' coords[0]' coords[1]);                          x = coords[0];                          y = coords[1];                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_QUADTO:                          gp.AddBezier(x' y' coords[0]' coords[1]' coords[0]' coords[1]' coords[2]' coords[3]);                          x = coords[2];                          y = coords[3];                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_CUBICTO:                          gp.AddBezier(x' y' coords[0]' coords[1]' coords[2]' coords[3]' coords[4]' coords[5]);                          x = coords[4];                          y = coords[5];                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_CLOSE:                          gp.CloseFigure();                          break;                  }                  iterator.next();              }
Magic Number,ikvm.awt,J2C,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: while (!iterator.isDone())              {                  int type = iterator.currentSegment(coords);                  switch (type)                  {                      case java.awt.geom.PathIterator.__Fields.SEG_MOVETO:                          x = coords[0];                          y = coords[1];                          gp.StartFigure();                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_LINETO:                          gp.AddLine(x' y' coords[0]' coords[1]);                          x = coords[0];                          y = coords[1];                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_QUADTO:                          gp.AddBezier(x' y' coords[0]' coords[1]' coords[0]' coords[1]' coords[2]' coords[3]);                          x = coords[2];                          y = coords[3];                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_CUBICTO:                          gp.AddBezier(x' y' coords[0]' coords[1]' coords[2]' coords[3]' coords[4]' coords[5]);                          x = coords[4];                          y = coords[5];                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_CLOSE:                          gp.CloseFigure();                          break;                  }                  iterator.next();              }
Magic Number,ikvm.awt,J2C,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: while (!iterator.isDone())              {                  int type = iterator.currentSegment(coords);                  switch (type)                  {                      case java.awt.geom.PathIterator.__Fields.SEG_MOVETO:                          x = coords[0];                          y = coords[1];                          gp.StartFigure();                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_LINETO:                          gp.AddLine(x' y' coords[0]' coords[1]);                          x = coords[0];                          y = coords[1];                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_QUADTO:                          gp.AddBezier(x' y' coords[0]' coords[1]' coords[0]' coords[1]' coords[2]' coords[3]);                          x = coords[2];                          y = coords[3];                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_CUBICTO:                          gp.AddBezier(x' y' coords[0]' coords[1]' coords[2]' coords[3]' coords[4]' coords[5]);                          x = coords[4];                          y = coords[5];                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_CLOSE:                          gp.CloseFigure();                          break;                  }                  iterator.next();              }
Magic Number,ikvm.awt,J2C,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: while (!iterator.isDone())              {                  int type = iterator.currentSegment(coords);                  switch (type)                  {                      case java.awt.geom.PathIterator.__Fields.SEG_MOVETO:                          x = coords[0];                          y = coords[1];                          gp.StartFigure();                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_LINETO:                          gp.AddLine(x' y' coords[0]' coords[1]);                          x = coords[0];                          y = coords[1];                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_QUADTO:                          gp.AddBezier(x' y' coords[0]' coords[1]' coords[0]' coords[1]' coords[2]' coords[3]);                          x = coords[2];                          y = coords[3];                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_CUBICTO:                          gp.AddBezier(x' y' coords[0]' coords[1]' coords[2]' coords[3]' coords[4]' coords[5]);                          x = coords[4];                          y = coords[5];                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_CLOSE:                          gp.CloseFigure();                          break;                  }                  iterator.next();              }
Magic Number,ikvm.awt,J2C,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: while (!iterator.isDone())              {                  int type = iterator.currentSegment(coords);                  switch (type)                  {                      case java.awt.geom.PathIterator.__Fields.SEG_MOVETO:                          x = coords[0];                          y = coords[1];                          gp.StartFigure();                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_LINETO:                          gp.AddLine(x' y' coords[0]' coords[1]);                          x = coords[0];                          y = coords[1];                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_QUADTO:                          gp.AddBezier(x' y' coords[0]' coords[1]' coords[0]' coords[1]' coords[2]' coords[3]);                          x = coords[2];                          y = coords[3];                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_CUBICTO:                          gp.AddBezier(x' y' coords[0]' coords[1]' coords[2]' coords[3]' coords[4]' coords[5]);                          x = coords[4];                          y = coords[5];                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_CLOSE:                          gp.CloseFigure();                          break;                  }                  iterator.next();              }
Magic Number,ikvm.awt,J2C,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: while (!iterator.isDone())              {                  int type = iterator.currentSegment(coords);                  switch (type)                  {                      case java.awt.geom.PathIterator.__Fields.SEG_MOVETO:                          x = coords[0];                          y = coords[1];                          gp.StartFigure();                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_LINETO:                          gp.AddLine(x' y' coords[0]' coords[1]);                          x = coords[0];                          y = coords[1];                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_QUADTO:                          gp.AddBezier(x' y' coords[0]' coords[1]' coords[0]' coords[1]' coords[2]' coords[3]);                          x = coords[2];                          y = coords[3];                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_CUBICTO:                          gp.AddBezier(x' y' coords[0]' coords[1]' coords[2]' coords[3]' coords[4]' coords[5]);                          x = coords[4];                          y = coords[5];                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_CLOSE:                          gp.CloseFigure();                          break;                  }                  iterator.next();              }
Magic Number,ikvm.awt,J2C,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: while (!iterator.isDone())              {                  int type = iterator.currentSegment(coords);                  switch (type)                  {                      case java.awt.geom.PathIterator.__Fields.SEG_MOVETO:                          x = coords[0];                          y = coords[1];                          gp.StartFigure();                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_LINETO:                          gp.AddLine(x' y' coords[0]' coords[1]);                          x = coords[0];                          y = coords[1];                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_QUADTO:                          gp.AddBezier(x' y' coords[0]' coords[1]' coords[0]' coords[1]' coords[2]' coords[3]);                          x = coords[2];                          y = coords[3];                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_CUBICTO:                          gp.AddBezier(x' y' coords[0]' coords[1]' coords[2]' coords[3]' coords[4]' coords[5]);                          x = coords[4];                          y = coords[5];                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_CLOSE:                          gp.CloseFigure();                          break;                  }                  iterator.next();              }
Magic Number,ikvm.awt,J2C,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: while (!iterator.isDone())              {                  int type = iterator.currentSegment(coords);                  switch (type)                  {                      case java.awt.geom.PathIterator.__Fields.SEG_MOVETO:                          x = coords[0];                          y = coords[1];                          gp.StartFigure();                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_LINETO:                          gp.AddLine(x' y' coords[0]' coords[1]);                          x = coords[0];                          y = coords[1];                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_QUADTO:                          gp.AddBezier(x' y' coords[0]' coords[1]' coords[0]' coords[1]' coords[2]' coords[3]);                          x = coords[2];                          y = coords[3];                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_CUBICTO:                          gp.AddBezier(x' y' coords[0]' coords[1]' coords[2]' coords[3]' coords[4]' coords[5]);                          x = coords[4];                          y = coords[5];                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_CLOSE:                          gp.CloseFigure();                          break;                  }                  iterator.next();              }
Magic Number,ikvm.awt,J2C,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: while (!iterator.isDone())              {                  int type = iterator.currentSegment(coords);                  switch (type)                  {                      case java.awt.geom.PathIterator.__Fields.SEG_MOVETO:                          x = coords[0];                          y = coords[1];                          gp.StartFigure();                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_LINETO:                          gp.AddLine(x' y' coords[0]' coords[1]);                          x = coords[0];                          y = coords[1];                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_QUADTO:                          gp.AddBezier(x' y' coords[0]' coords[1]' coords[0]' coords[1]' coords[2]' coords[3]);                          x = coords[2];                          y = coords[3];                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_CUBICTO:                          gp.AddBezier(x' y' coords[0]' coords[1]' coords[2]' coords[3]' coords[4]' coords[5]);                          x = coords[4];                          y = coords[5];                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_CLOSE:                          gp.CloseFigure();                          break;                  }                  iterator.next();              }
Magic Number,ikvm.awt,J2C,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: while (!iterator.isDone())              {                  int type = iterator.currentSegment(coords);                  switch (type)                  {                      case java.awt.geom.PathIterator.__Fields.SEG_MOVETO:                          x = coords[0];                          y = coords[1];                          gp.StartFigure();                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_LINETO:                          gp.AddLine(x' y' coords[0]' coords[1]);                          x = coords[0];                          y = coords[1];                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_QUADTO:                          gp.AddBezier(x' y' coords[0]' coords[1]' coords[0]' coords[1]' coords[2]' coords[3]);                          x = coords[2];                          y = coords[3];                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_CUBICTO:                          gp.AddBezier(x' y' coords[0]' coords[1]' coords[2]' coords[3]' coords[4]' coords[5]);                          x = coords[4];                          y = coords[5];                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_CLOSE:                          gp.CloseFigure();                          break;                  }                  iterator.next();              }
Magic Number,ikvm.awt,J2C,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertRegion,The following statement contains a magic number: if (shape.isRectangular())  			{  				int x = shape.getLoX();  				int y = shape.getLoY();  				int w = shape.getHiX() - x;  				int h = shape.getHiY() - y;  				if (w < 0 || h < 0)  				{  					return new Region();  				}  				else  				{  					return new Region(new Rectangle(x' y' w' h));  				}  			}  			else  			{  				using (GraphicsPath path = new GraphicsPath())  				{  					sun.java2d.pipe.SpanIterator iter = shape.getSpanIterator();  					int[] box = new int[4];  					while (iter.nextSpan(box))  					{  						path.AddRectangle(new Rectangle(box[0]' box[1]' box[2] - box[0]' box[3] - box[1]));  					}  					return new Region(path);  				}  			}
Magic Number,ikvm.awt,J2C,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertRegion,The following statement contains a magic number: if (shape.isRectangular())  			{  				int x = shape.getLoX();  				int y = shape.getLoY();  				int w = shape.getHiX() - x;  				int h = shape.getHiY() - y;  				if (w < 0 || h < 0)  				{  					return new Region();  				}  				else  				{  					return new Region(new Rectangle(x' y' w' h));  				}  			}  			else  			{  				using (GraphicsPath path = new GraphicsPath())  				{  					sun.java2d.pipe.SpanIterator iter = shape.getSpanIterator();  					int[] box = new int[4];  					while (iter.nextSpan(box))  					{  						path.AddRectangle(new Rectangle(box[0]' box[1]' box[2] - box[0]' box[3] - box[1]));  					}  					return new Region(path);  				}  			}
Magic Number,ikvm.awt,J2C,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertRegion,The following statement contains a magic number: if (shape.isRectangular())  			{  				int x = shape.getLoX();  				int y = shape.getLoY();  				int w = shape.getHiX() - x;  				int h = shape.getHiY() - y;  				if (w < 0 || h < 0)  				{  					return new Region();  				}  				else  				{  					return new Region(new Rectangle(x' y' w' h));  				}  			}  			else  			{  				using (GraphicsPath path = new GraphicsPath())  				{  					sun.java2d.pipe.SpanIterator iter = shape.getSpanIterator();  					int[] box = new int[4];  					while (iter.nextSpan(box))  					{  						path.AddRectangle(new Rectangle(box[0]' box[1]' box[2] - box[0]' box[3] - box[1]));  					}  					return new Region(path);  				}  			}
Magic Number,ikvm.awt,C2J,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertFont,The following statement contains a magic number: if (font.Unit != GraphicsUnit.Pixel)              {                  size = font.SizeInPoints * java.awt.Toolkit.getDefaultToolkit().getScreenResolution() / 72;              }
Magic Number,ikvm.awt,C2J,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following statement contains a magic number: for (int i = 0; i < path.PointCount; i++) {                  byte pathType = path.PathTypes[i];                  int type = pathType & 0x07;                  PointF point = path.PathPoints[i];                  switch (type) {                      case 0:                          // Indicates that the point is the start of a figure.                           shape.moveTo(point.X' point.Y);                          break;                      case 1:                          // Indicates that the point is one of the two endpoints of a line.                           shape.lineTo(point.X' point.Y);                          break;                      case 3:                          // Indicates that the point is an endpoint or control point of a cubic Bzier spline.                           PointF point2 = path.PathPoints[++i];                          PointF point3 = path.PathPoints[++i];                          shape.curveTo(point.X' point.Y' point2.X' point2.Y' point3.X' point3.Y);                          pathType = path.PathTypes[i];                          break;                      default:                          Console.WriteLine("Unknown GraphicsPath type: " + type);                          break;                  }                  if ((pathType & 0x80) > 0) {                      // Specifies that the point is the last point in a closed subpath (figure).                      shape.closePath();                  }              }
Magic Number,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,NetGraphics,The following statement contains a magic number: if (font == null)              {                  font = new java.awt.Font("Dialog"' java.awt.Font.PLAIN' 12);              }
Magic Number,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,drawArc,The following statement contains a magic number: g.DrawArc(pen' x' y' width' height' 360 - startAngle - arcAngle' arcAngle);
Magic Number,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,fill3DRect,The following statement contains a magic number: fillRect(x + 1' y + 1' width - 2' height - 2);
Magic Number,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,fill3DRect,The following statement contains a magic number: fillRect(x + 1' y + 1' width - 2' height - 2);
Magic Number,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,fill3DRect,The following statement contains a magic number: fillRect(x + 1' y' width - 2' 1);
Magic Number,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,fillArc,The following statement contains a magic number: g.FillPie(brush' x' y' width' height' 360 - startAngle - arcAngle' arcAngle);
Magic Number,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: if (paint is java.awt.GradientPaint)              {                  java.awt.GradientPaint gradient = (java.awt.GradientPaint)paint;                  LinearGradientBrush linear;                  if (gradient.isCyclic())                  {                      linear = new LinearGradientBrush(                          J2C.ConvertPoint(gradient.getPoint1())'                          J2C.ConvertPoint(gradient.getPoint2())'                          composite.GetColor(gradient.getColor1())'                          composite.GetColor(gradient.getColor2()));                  }                  else                  {                      //HACK because .NET does not support continue gradient like Java else Tile Gradient                      //that we receize the rectangle very large (factor z) and set 4 color values                      // a exact solution will calculate the size of the Graphics with the current transform                      Color color1 = composite.GetColor(gradient.getColor1());                      Color color2 = composite.GetColor(gradient.getColor2());                      float x1 = (float)gradient.getPoint1().getX();                      float x2 = (float)gradient.getPoint2().getX();                      float y1 = (float)gradient.getPoint1().getY();                      float y2 = (float)gradient.getPoint2().getY();                      float diffX = x2 - x1;                      float diffY = y2 - y1;                      const float z = 60; //HACK zoom factor' with a larger factor .NET will make the gradient wider.                      linear = new LinearGradientBrush(                          new PointF(x1 - z * diffX' y1 - z * diffY)'                          new PointF(x2 + z * diffX' y2 + z * diffY)'                          color1'                          color1);                      ColorBlend colorBlend = new ColorBlend(4);                      Color[] colors = colorBlend.Colors;                      colors[0] = colors[1] = color1;                      colors[2] = colors[3] = color2;                      float[] positions = colorBlend.Positions;                      positions[1] = z / (2 * z + 1);                      positions[2] = (z + 1) / (2 * z + 1);                      positions[3] = 1.0f;                      linear.InterpolationColors = colorBlend;                  }                  linear.WrapMode = WrapMode.TileFlipXY;                  brush = linear;                  pen.Brush = brush;                  return;              }
Magic Number,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: if (paint is java.awt.GradientPaint)              {                  java.awt.GradientPaint gradient = (java.awt.GradientPaint)paint;                  LinearGradientBrush linear;                  if (gradient.isCyclic())                  {                      linear = new LinearGradientBrush(                          J2C.ConvertPoint(gradient.getPoint1())'                          J2C.ConvertPoint(gradient.getPoint2())'                          composite.GetColor(gradient.getColor1())'                          composite.GetColor(gradient.getColor2()));                  }                  else                  {                      //HACK because .NET does not support continue gradient like Java else Tile Gradient                      //that we receize the rectangle very large (factor z) and set 4 color values                      // a exact solution will calculate the size of the Graphics with the current transform                      Color color1 = composite.GetColor(gradient.getColor1());                      Color color2 = composite.GetColor(gradient.getColor2());                      float x1 = (float)gradient.getPoint1().getX();                      float x2 = (float)gradient.getPoint2().getX();                      float y1 = (float)gradient.getPoint1().getY();                      float y2 = (float)gradient.getPoint2().getY();                      float diffX = x2 - x1;                      float diffY = y2 - y1;                      const float z = 60; //HACK zoom factor' with a larger factor .NET will make the gradient wider.                      linear = new LinearGradientBrush(                          new PointF(x1 - z * diffX' y1 - z * diffY)'                          new PointF(x2 + z * diffX' y2 + z * diffY)'                          color1'                          color1);                      ColorBlend colorBlend = new ColorBlend(4);                      Color[] colors = colorBlend.Colors;                      colors[0] = colors[1] = color1;                      colors[2] = colors[3] = color2;                      float[] positions = colorBlend.Positions;                      positions[1] = z / (2 * z + 1);                      positions[2] = (z + 1) / (2 * z + 1);                      positions[3] = 1.0f;                      linear.InterpolationColors = colorBlend;                  }                  linear.WrapMode = WrapMode.TileFlipXY;                  brush = linear;                  pen.Brush = brush;                  return;              }
Magic Number,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: if (paint is java.awt.GradientPaint)              {                  java.awt.GradientPaint gradient = (java.awt.GradientPaint)paint;                  LinearGradientBrush linear;                  if (gradient.isCyclic())                  {                      linear = new LinearGradientBrush(                          J2C.ConvertPoint(gradient.getPoint1())'                          J2C.ConvertPoint(gradient.getPoint2())'                          composite.GetColor(gradient.getColor1())'                          composite.GetColor(gradient.getColor2()));                  }                  else                  {                      //HACK because .NET does not support continue gradient like Java else Tile Gradient                      //that we receize the rectangle very large (factor z) and set 4 color values                      // a exact solution will calculate the size of the Graphics with the current transform                      Color color1 = composite.GetColor(gradient.getColor1());                      Color color2 = composite.GetColor(gradient.getColor2());                      float x1 = (float)gradient.getPoint1().getX();                      float x2 = (float)gradient.getPoint2().getX();                      float y1 = (float)gradient.getPoint1().getY();                      float y2 = (float)gradient.getPoint2().getY();                      float diffX = x2 - x1;                      float diffY = y2 - y1;                      const float z = 60; //HACK zoom factor' with a larger factor .NET will make the gradient wider.                      linear = new LinearGradientBrush(                          new PointF(x1 - z * diffX' y1 - z * diffY)'                          new PointF(x2 + z * diffX' y2 + z * diffY)'                          color1'                          color1);                      ColorBlend colorBlend = new ColorBlend(4);                      Color[] colors = colorBlend.Colors;                      colors[0] = colors[1] = color1;                      colors[2] = colors[3] = color2;                      float[] positions = colorBlend.Positions;                      positions[1] = z / (2 * z + 1);                      positions[2] = (z + 1) / (2 * z + 1);                      positions[3] = 1.0f;                      linear.InterpolationColors = colorBlend;                  }                  linear.WrapMode = WrapMode.TileFlipXY;                  brush = linear;                  pen.Brush = brush;                  return;              }
Magic Number,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: if (paint is java.awt.GradientPaint)              {                  java.awt.GradientPaint gradient = (java.awt.GradientPaint)paint;                  LinearGradientBrush linear;                  if (gradient.isCyclic())                  {                      linear = new LinearGradientBrush(                          J2C.ConvertPoint(gradient.getPoint1())'                          J2C.ConvertPoint(gradient.getPoint2())'                          composite.GetColor(gradient.getColor1())'                          composite.GetColor(gradient.getColor2()));                  }                  else                  {                      //HACK because .NET does not support continue gradient like Java else Tile Gradient                      //that we receize the rectangle very large (factor z) and set 4 color values                      // a exact solution will calculate the size of the Graphics with the current transform                      Color color1 = composite.GetColor(gradient.getColor1());                      Color color2 = composite.GetColor(gradient.getColor2());                      float x1 = (float)gradient.getPoint1().getX();                      float x2 = (float)gradient.getPoint2().getX();                      float y1 = (float)gradient.getPoint1().getY();                      float y2 = (float)gradient.getPoint2().getY();                      float diffX = x2 - x1;                      float diffY = y2 - y1;                      const float z = 60; //HACK zoom factor' with a larger factor .NET will make the gradient wider.                      linear = new LinearGradientBrush(                          new PointF(x1 - z * diffX' y1 - z * diffY)'                          new PointF(x2 + z * diffX' y2 + z * diffY)'                          color1'                          color1);                      ColorBlend colorBlend = new ColorBlend(4);                      Color[] colors = colorBlend.Colors;                      colors[0] = colors[1] = color1;                      colors[2] = colors[3] = color2;                      float[] positions = colorBlend.Positions;                      positions[1] = z / (2 * z + 1);                      positions[2] = (z + 1) / (2 * z + 1);                      positions[3] = 1.0f;                      linear.InterpolationColors = colorBlend;                  }                  linear.WrapMode = WrapMode.TileFlipXY;                  brush = linear;                  pen.Brush = brush;                  return;              }
Magic Number,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: if (paint is java.awt.GradientPaint)              {                  java.awt.GradientPaint gradient = (java.awt.GradientPaint)paint;                  LinearGradientBrush linear;                  if (gradient.isCyclic())                  {                      linear = new LinearGradientBrush(                          J2C.ConvertPoint(gradient.getPoint1())'                          J2C.ConvertPoint(gradient.getPoint2())'                          composite.GetColor(gradient.getColor1())'                          composite.GetColor(gradient.getColor2()));                  }                  else                  {                      //HACK because .NET does not support continue gradient like Java else Tile Gradient                      //that we receize the rectangle very large (factor z) and set 4 color values                      // a exact solution will calculate the size of the Graphics with the current transform                      Color color1 = composite.GetColor(gradient.getColor1());                      Color color2 = composite.GetColor(gradient.getColor2());                      float x1 = (float)gradient.getPoint1().getX();                      float x2 = (float)gradient.getPoint2().getX();                      float y1 = (float)gradient.getPoint1().getY();                      float y2 = (float)gradient.getPoint2().getY();                      float diffX = x2 - x1;                      float diffY = y2 - y1;                      const float z = 60; //HACK zoom factor' with a larger factor .NET will make the gradient wider.                      linear = new LinearGradientBrush(                          new PointF(x1 - z * diffX' y1 - z * diffY)'                          new PointF(x2 + z * diffX' y2 + z * diffY)'                          color1'                          color1);                      ColorBlend colorBlend = new ColorBlend(4);                      Color[] colors = colorBlend.Colors;                      colors[0] = colors[1] = color1;                      colors[2] = colors[3] = color2;                      float[] positions = colorBlend.Positions;                      positions[1] = z / (2 * z + 1);                      positions[2] = (z + 1) / (2 * z + 1);                      positions[3] = 1.0f;                      linear.InterpolationColors = colorBlend;                  }                  linear.WrapMode = WrapMode.TileFlipXY;                  brush = linear;                  pen.Brush = brush;                  return;              }
Magic Number,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: if (paint is java.awt.GradientPaint)              {                  java.awt.GradientPaint gradient = (java.awt.GradientPaint)paint;                  LinearGradientBrush linear;                  if (gradient.isCyclic())                  {                      linear = new LinearGradientBrush(                          J2C.ConvertPoint(gradient.getPoint1())'                          J2C.ConvertPoint(gradient.getPoint2())'                          composite.GetColor(gradient.getColor1())'                          composite.GetColor(gradient.getColor2()));                  }                  else                  {                      //HACK because .NET does not support continue gradient like Java else Tile Gradient                      //that we receize the rectangle very large (factor z) and set 4 color values                      // a exact solution will calculate the size of the Graphics with the current transform                      Color color1 = composite.GetColor(gradient.getColor1());                      Color color2 = composite.GetColor(gradient.getColor2());                      float x1 = (float)gradient.getPoint1().getX();                      float x2 = (float)gradient.getPoint2().getX();                      float y1 = (float)gradient.getPoint1().getY();                      float y2 = (float)gradient.getPoint2().getY();                      float diffX = x2 - x1;                      float diffY = y2 - y1;                      const float z = 60; //HACK zoom factor' with a larger factor .NET will make the gradient wider.                      linear = new LinearGradientBrush(                          new PointF(x1 - z * diffX' y1 - z * diffY)'                          new PointF(x2 + z * diffX' y2 + z * diffY)'                          color1'                          color1);                      ColorBlend colorBlend = new ColorBlend(4);                      Color[] colors = colorBlend.Colors;                      colors[0] = colors[1] = color1;                      colors[2] = colors[3] = color2;                      float[] positions = colorBlend.Positions;                      positions[1] = z / (2 * z + 1);                      positions[2] = (z + 1) / (2 * z + 1);                      positions[3] = 1.0f;                      linear.InterpolationColors = colorBlend;                  }                  linear.WrapMode = WrapMode.TileFlipXY;                  brush = linear;                  pen.Brush = brush;                  return;              }
Magic Number,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: if (paint is java.awt.GradientPaint)              {                  java.awt.GradientPaint gradient = (java.awt.GradientPaint)paint;                  LinearGradientBrush linear;                  if (gradient.isCyclic())                  {                      linear = new LinearGradientBrush(                          J2C.ConvertPoint(gradient.getPoint1())'                          J2C.ConvertPoint(gradient.getPoint2())'                          composite.GetColor(gradient.getColor1())'                          composite.GetColor(gradient.getColor2()));                  }                  else                  {                      //HACK because .NET does not support continue gradient like Java else Tile Gradient                      //that we receize the rectangle very large (factor z) and set 4 color values                      // a exact solution will calculate the size of the Graphics with the current transform                      Color color1 = composite.GetColor(gradient.getColor1());                      Color color2 = composite.GetColor(gradient.getColor2());                      float x1 = (float)gradient.getPoint1().getX();                      float x2 = (float)gradient.getPoint2().getX();                      float y1 = (float)gradient.getPoint1().getY();                      float y2 = (float)gradient.getPoint2().getY();                      float diffX = x2 - x1;                      float diffY = y2 - y1;                      const float z = 60; //HACK zoom factor' with a larger factor .NET will make the gradient wider.                      linear = new LinearGradientBrush(                          new PointF(x1 - z * diffX' y1 - z * diffY)'                          new PointF(x2 + z * diffX' y2 + z * diffY)'                          color1'                          color1);                      ColorBlend colorBlend = new ColorBlend(4);                      Color[] colors = colorBlend.Colors;                      colors[0] = colors[1] = color1;                      colors[2] = colors[3] = color2;                      float[] positions = colorBlend.Positions;                      positions[1] = z / (2 * z + 1);                      positions[2] = (z + 1) / (2 * z + 1);                      positions[3] = 1.0f;                      linear.InterpolationColors = colorBlend;                  }                  linear.WrapMode = WrapMode.TileFlipXY;                  brush = linear;                  pen.Brush = brush;                  return;              }
Magic Number,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: if (paint is java.awt.GradientPaint)              {                  java.awt.GradientPaint gradient = (java.awt.GradientPaint)paint;                  LinearGradientBrush linear;                  if (gradient.isCyclic())                  {                      linear = new LinearGradientBrush(                          J2C.ConvertPoint(gradient.getPoint1())'                          J2C.ConvertPoint(gradient.getPoint2())'                          composite.GetColor(gradient.getColor1())'                          composite.GetColor(gradient.getColor2()));                  }                  else                  {                      //HACK because .NET does not support continue gradient like Java else Tile Gradient                      //that we receize the rectangle very large (factor z) and set 4 color values                      // a exact solution will calculate the size of the Graphics with the current transform                      Color color1 = composite.GetColor(gradient.getColor1());                      Color color2 = composite.GetColor(gradient.getColor2());                      float x1 = (float)gradient.getPoint1().getX();                      float x2 = (float)gradient.getPoint2().getX();                      float y1 = (float)gradient.getPoint1().getY();                      float y2 = (float)gradient.getPoint2().getY();                      float diffX = x2 - x1;                      float diffY = y2 - y1;                      const float z = 60; //HACK zoom factor' with a larger factor .NET will make the gradient wider.                      linear = new LinearGradientBrush(                          new PointF(x1 - z * diffX' y1 - z * diffY)'                          new PointF(x2 + z * diffX' y2 + z * diffY)'                          color1'                          color1);                      ColorBlend colorBlend = new ColorBlend(4);                      Color[] colors = colorBlend.Colors;                      colors[0] = colors[1] = color1;                      colors[2] = colors[3] = color2;                      float[] positions = colorBlend.Positions;                      positions[1] = z / (2 * z + 1);                      positions[2] = (z + 1) / (2 * z + 1);                      positions[3] = 1.0f;                      linear.InterpolationColors = colorBlend;                  }                  linear.WrapMode = WrapMode.TileFlipXY;                  brush = linear;                  pen.Brush = brush;                  return;              }
Magic Number,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: if (paint is java.awt.LinearGradientPaint) {                  java.awt.LinearGradientPaint gradient = (java.awt.LinearGradientPaint)paint;                  PointF start = J2C.ConvertPoint(gradient.getStartPoint());                  PointF end = J2C.ConvertPoint(gradient.getEndPoint());                    java.awt.Color[] javaColors = gradient.getColors();                  ColorBlend colorBlend;                  Color[] colors;                  bool noCycle = gradient.getCycleMethod() == java.awt.MultipleGradientPaint.CycleMethod.NO_CYCLE;                  if (noCycle) {                      //HACK because .NET does not support continue gradient like Java else Tile Gradient                      //that we receize the rectangle very large (factor z) and set 2 additional color values                      //an exact solution will calculate the size of the Graphics with the current transform                      float diffX = end.X - start.X;                      float diffY = end.Y - start.Y;                      SizeF size = GetSize();                      //HACK zoom factor' with a larger factor .NET will make the gradient wider.                      float z = Math.Min(10' Math.Max(size.Width / diffX' size.Height / diffY));                      start.X -= z * diffX;                      start.Y -= z * diffY;                      end.X += z * diffX;                      end.Y += z * diffY;                        colorBlend = new ColorBlend(javaColors.Length + 2);                      colors = colorBlend.Colors;                      float[] fractions = gradient.getFractions();                      float[] positions = colorBlend.Positions;                      for (int i = 0; i < javaColors.Length; i++) {                          colors[i + 1] = composite.GetColor(javaColors[i]);                          positions[i + 1] = (z + fractions[i]) / (2 * z + 1);                      }                      colors[0] = colors[1];                      colors[colors.Length - 1] = colors[colors.Length - 2];                      positions[positions.Length - 1] = 1.0f;                  } else {                      colorBlend = new ColorBlend(javaColors.Length);                      colors = colorBlend.Colors;                      colorBlend.Positions = gradient.getFractions();                      for (int i = 0; i < javaColors.Length; i++) {                          colors[i] = composite.GetColor(javaColors[i]);                      }                  }                  LinearGradientBrush linear = new LinearGradientBrush(start' end' colors[0]' colors[colors.Length - 1]);                  linear.InterpolationColors = colorBlend;                  switch (gradient.getCycleMethod().ordinal()) {                      case (int)java.awt.MultipleGradientPaint.CycleMethod.__Enum.NO_CYCLE:                      case (int)java.awt.MultipleGradientPaint.CycleMethod.__Enum.REFLECT:                          linear.WrapMode = WrapMode.TileFlipXY;                          break;                      case (int)java.awt.MultipleGradientPaint.CycleMethod.__Enum.REPEAT:                          linear.WrapMode = WrapMode.Tile;                          break;                  }                  brush = linear;                  pen.Brush = brush;                  return;              }
Magic Number,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: if (paint is java.awt.LinearGradientPaint) {                  java.awt.LinearGradientPaint gradient = (java.awt.LinearGradientPaint)paint;                  PointF start = J2C.ConvertPoint(gradient.getStartPoint());                  PointF end = J2C.ConvertPoint(gradient.getEndPoint());                    java.awt.Color[] javaColors = gradient.getColors();                  ColorBlend colorBlend;                  Color[] colors;                  bool noCycle = gradient.getCycleMethod() == java.awt.MultipleGradientPaint.CycleMethod.NO_CYCLE;                  if (noCycle) {                      //HACK because .NET does not support continue gradient like Java else Tile Gradient                      //that we receize the rectangle very large (factor z) and set 2 additional color values                      //an exact solution will calculate the size of the Graphics with the current transform                      float diffX = end.X - start.X;                      float diffY = end.Y - start.Y;                      SizeF size = GetSize();                      //HACK zoom factor' with a larger factor .NET will make the gradient wider.                      float z = Math.Min(10' Math.Max(size.Width / diffX' size.Height / diffY));                      start.X -= z * diffX;                      start.Y -= z * diffY;                      end.X += z * diffX;                      end.Y += z * diffY;                        colorBlend = new ColorBlend(javaColors.Length + 2);                      colors = colorBlend.Colors;                      float[] fractions = gradient.getFractions();                      float[] positions = colorBlend.Positions;                      for (int i = 0; i < javaColors.Length; i++) {                          colors[i + 1] = composite.GetColor(javaColors[i]);                          positions[i + 1] = (z + fractions[i]) / (2 * z + 1);                      }                      colors[0] = colors[1];                      colors[colors.Length - 1] = colors[colors.Length - 2];                      positions[positions.Length - 1] = 1.0f;                  } else {                      colorBlend = new ColorBlend(javaColors.Length);                      colors = colorBlend.Colors;                      colorBlend.Positions = gradient.getFractions();                      for (int i = 0; i < javaColors.Length; i++) {                          colors[i] = composite.GetColor(javaColors[i]);                      }                  }                  LinearGradientBrush linear = new LinearGradientBrush(start' end' colors[0]' colors[colors.Length - 1]);                  linear.InterpolationColors = colorBlend;                  switch (gradient.getCycleMethod().ordinal()) {                      case (int)java.awt.MultipleGradientPaint.CycleMethod.__Enum.NO_CYCLE:                      case (int)java.awt.MultipleGradientPaint.CycleMethod.__Enum.REFLECT:                          linear.WrapMode = WrapMode.TileFlipXY;                          break;                      case (int)java.awt.MultipleGradientPaint.CycleMethod.__Enum.REPEAT:                          linear.WrapMode = WrapMode.Tile;                          break;                  }                  brush = linear;                  pen.Brush = brush;                  return;              }
Magic Number,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: if (paint is java.awt.LinearGradientPaint) {                  java.awt.LinearGradientPaint gradient = (java.awt.LinearGradientPaint)paint;                  PointF start = J2C.ConvertPoint(gradient.getStartPoint());                  PointF end = J2C.ConvertPoint(gradient.getEndPoint());                    java.awt.Color[] javaColors = gradient.getColors();                  ColorBlend colorBlend;                  Color[] colors;                  bool noCycle = gradient.getCycleMethod() == java.awt.MultipleGradientPaint.CycleMethod.NO_CYCLE;                  if (noCycle) {                      //HACK because .NET does not support continue gradient like Java else Tile Gradient                      //that we receize the rectangle very large (factor z) and set 2 additional color values                      //an exact solution will calculate the size of the Graphics with the current transform                      float diffX = end.X - start.X;                      float diffY = end.Y - start.Y;                      SizeF size = GetSize();                      //HACK zoom factor' with a larger factor .NET will make the gradient wider.                      float z = Math.Min(10' Math.Max(size.Width / diffX' size.Height / diffY));                      start.X -= z * diffX;                      start.Y -= z * diffY;                      end.X += z * diffX;                      end.Y += z * diffY;                        colorBlend = new ColorBlend(javaColors.Length + 2);                      colors = colorBlend.Colors;                      float[] fractions = gradient.getFractions();                      float[] positions = colorBlend.Positions;                      for (int i = 0; i < javaColors.Length; i++) {                          colors[i + 1] = composite.GetColor(javaColors[i]);                          positions[i + 1] = (z + fractions[i]) / (2 * z + 1);                      }                      colors[0] = colors[1];                      colors[colors.Length - 1] = colors[colors.Length - 2];                      positions[positions.Length - 1] = 1.0f;                  } else {                      colorBlend = new ColorBlend(javaColors.Length);                      colors = colorBlend.Colors;                      colorBlend.Positions = gradient.getFractions();                      for (int i = 0; i < javaColors.Length; i++) {                          colors[i] = composite.GetColor(javaColors[i]);                      }                  }                  LinearGradientBrush linear = new LinearGradientBrush(start' end' colors[0]' colors[colors.Length - 1]);                  linear.InterpolationColors = colorBlend;                  switch (gradient.getCycleMethod().ordinal()) {                      case (int)java.awt.MultipleGradientPaint.CycleMethod.__Enum.NO_CYCLE:                      case (int)java.awt.MultipleGradientPaint.CycleMethod.__Enum.REFLECT:                          linear.WrapMode = WrapMode.TileFlipXY;                          break;                      case (int)java.awt.MultipleGradientPaint.CycleMethod.__Enum.REPEAT:                          linear.WrapMode = WrapMode.Tile;                          break;                  }                  brush = linear;                  pen.Brush = brush;                  return;              }
Magic Number,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following statement contains a magic number: if (paint is java.awt.LinearGradientPaint) {                  java.awt.LinearGradientPaint gradient = (java.awt.LinearGradientPaint)paint;                  PointF start = J2C.ConvertPoint(gradient.getStartPoint());                  PointF end = J2C.ConvertPoint(gradient.getEndPoint());                    java.awt.Color[] javaColors = gradient.getColors();                  ColorBlend colorBlend;                  Color[] colors;                  bool noCycle = gradient.getCycleMethod() == java.awt.MultipleGradientPaint.CycleMethod.NO_CYCLE;                  if (noCycle) {                      //HACK because .NET does not support continue gradient like Java else Tile Gradient                      //that we receize the rectangle very large (factor z) and set 2 additional color values                      //an exact solution will calculate the size of the Graphics with the current transform                      float diffX = end.X - start.X;                      float diffY = end.Y - start.Y;                      SizeF size = GetSize();                      //HACK zoom factor' with a larger factor .NET will make the gradient wider.                      float z = Math.Min(10' Math.Max(size.Width / diffX' size.Height / diffY));                      start.X -= z * diffX;                      start.Y -= z * diffY;                      end.X += z * diffX;                      end.Y += z * diffY;                        colorBlend = new ColorBlend(javaColors.Length + 2);                      colors = colorBlend.Colors;                      float[] fractions = gradient.getFractions();                      float[] positions = colorBlend.Positions;                      for (int i = 0; i < javaColors.Length; i++) {                          colors[i + 1] = composite.GetColor(javaColors[i]);                          positions[i + 1] = (z + fractions[i]) / (2 * z + 1);                      }                      colors[0] = colors[1];                      colors[colors.Length - 1] = colors[colors.Length - 2];                      positions[positions.Length - 1] = 1.0f;                  } else {                      colorBlend = new ColorBlend(javaColors.Length);                      colors = colorBlend.Colors;                      colorBlend.Positions = gradient.getFractions();                      for (int i = 0; i < javaColors.Length; i++) {                          colors[i] = composite.GetColor(javaColors[i]);                      }                  }                  LinearGradientBrush linear = new LinearGradientBrush(start' end' colors[0]' colors[colors.Length - 1]);                  linear.InterpolationColors = colorBlend;                  switch (gradient.getCycleMethod().ordinal()) {                      case (int)java.awt.MultipleGradientPaint.CycleMethod.__Enum.NO_CYCLE:                      case (int)java.awt.MultipleGradientPaint.CycleMethod.__Enum.REFLECT:                          linear.WrapMode = WrapMode.TileFlipXY;                          break;                      case (int)java.awt.MultipleGradientPaint.CycleMethod.__Enum.REPEAT:                          linear.WrapMode = WrapMode.Tile;                          break;                  }                  brush = linear;                  pen.Brush = brush;                  return;              }
Magic Number,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,SetLineDash,The following statement contains a magic number: if (dash == null)              {                  pen.DashStyle = DashStyle.Solid;              } else {                  if (dash.Length % 2 == 1)                  {                      int len = dash.Length;                      Array.Resize(ref dash' len * 2);                      Array.Copy(dash' 0' dash' len' len);                  }                  float lineWidth = s.getLineWidth();                  if (lineWidth > 1) // for values < 0 there is no correctur needed                  {                      for (int i = 0; i < dash.Length; i++)                      {                          //dividing by line thickness because of the representation difference                          dash[i] = dash[i] / lineWidth;                      }                  }                  // To fix the problem where solid style in Java can be represented at { 1.0' 0.0 }.                  // In .NET' however' array can only have positive value                  if (dash.Length == 2 && dash[dash.Length - 1] == 0)                  {                      Array.Resize(ref dash' 1);                  }                    float dashPhase = s.getDashPhase();                  // correct the dash cap                  switch (s.getEndCap())                  {                      case java.awt.BasicStroke.CAP_BUTT:                          pen.DashCap = DashCap.Flat;                          break;                      case java.awt.BasicStroke.CAP_ROUND:                          pen.DashCap = DashCap.Round;                          break;                      case java.awt.BasicStroke.CAP_SQUARE:                          pen.DashCap = DashCap.Flat;                          // there is no equals DashCap in .NET' we need to emulate it                          dashPhase += lineWidth / 2;                          for (int i = 0; i < dash.Length; i++)                          {                              if (i % 2 == 0)                              {                                  dash[i] += 1;                              }                              else                              {                                  dash[i] = Math.Max(0.00001F' dash[i] - 1);                              }                          }                          break;                      default:                          Console.WriteLine("Unknown dash cap type:" + s.getEndCap());                          break;                  }                    // calc the dash offset                  if (lineWidth > 0)                  {                      //dividing by line thickness because of the representation difference                      pen.DashOffset = dashPhase / lineWidth;                  }                  else                  {                      // thickness == 0                      if (dashPhase > 0)                      {                          pen.Width = lineWidth = 0.001F; // hack to prevent a division with 0                          pen.DashOffset = dashPhase / lineWidth;                      }                      else                      {                          pen.DashOffset = 0;                      }                  }                    // set the final dash pattern                   pen.DashPattern = dash;              }
Magic Number,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,SetLineDash,The following statement contains a magic number: if (dash == null)              {                  pen.DashStyle = DashStyle.Solid;              } else {                  if (dash.Length % 2 == 1)                  {                      int len = dash.Length;                      Array.Resize(ref dash' len * 2);                      Array.Copy(dash' 0' dash' len' len);                  }                  float lineWidth = s.getLineWidth();                  if (lineWidth > 1) // for values < 0 there is no correctur needed                  {                      for (int i = 0; i < dash.Length; i++)                      {                          //dividing by line thickness because of the representation difference                          dash[i] = dash[i] / lineWidth;                      }                  }                  // To fix the problem where solid style in Java can be represented at { 1.0' 0.0 }.                  // In .NET' however' array can only have positive value                  if (dash.Length == 2 && dash[dash.Length - 1] == 0)                  {                      Array.Resize(ref dash' 1);                  }                    float dashPhase = s.getDashPhase();                  // correct the dash cap                  switch (s.getEndCap())                  {                      case java.awt.BasicStroke.CAP_BUTT:                          pen.DashCap = DashCap.Flat;                          break;                      case java.awt.BasicStroke.CAP_ROUND:                          pen.DashCap = DashCap.Round;                          break;                      case java.awt.BasicStroke.CAP_SQUARE:                          pen.DashCap = DashCap.Flat;                          // there is no equals DashCap in .NET' we need to emulate it                          dashPhase += lineWidth / 2;                          for (int i = 0; i < dash.Length; i++)                          {                              if (i % 2 == 0)                              {                                  dash[i] += 1;                              }                              else                              {                                  dash[i] = Math.Max(0.00001F' dash[i] - 1);                              }                          }                          break;                      default:                          Console.WriteLine("Unknown dash cap type:" + s.getEndCap());                          break;                  }                    // calc the dash offset                  if (lineWidth > 0)                  {                      //dividing by line thickness because of the representation difference                      pen.DashOffset = dashPhase / lineWidth;                  }                  else                  {                      // thickness == 0                      if (dashPhase > 0)                      {                          pen.Width = lineWidth = 0.001F; // hack to prevent a division with 0                          pen.DashOffset = dashPhase / lineWidth;                      }                      else                      {                          pen.DashOffset = 0;                      }                  }                    // set the final dash pattern                   pen.DashPattern = dash;              }
Magic Number,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,SetLineDash,The following statement contains a magic number: if (dash == null)              {                  pen.DashStyle = DashStyle.Solid;              } else {                  if (dash.Length % 2 == 1)                  {                      int len = dash.Length;                      Array.Resize(ref dash' len * 2);                      Array.Copy(dash' 0' dash' len' len);                  }                  float lineWidth = s.getLineWidth();                  if (lineWidth > 1) // for values < 0 there is no correctur needed                  {                      for (int i = 0; i < dash.Length; i++)                      {                          //dividing by line thickness because of the representation difference                          dash[i] = dash[i] / lineWidth;                      }                  }                  // To fix the problem where solid style in Java can be represented at { 1.0' 0.0 }.                  // In .NET' however' array can only have positive value                  if (dash.Length == 2 && dash[dash.Length - 1] == 0)                  {                      Array.Resize(ref dash' 1);                  }                    float dashPhase = s.getDashPhase();                  // correct the dash cap                  switch (s.getEndCap())                  {                      case java.awt.BasicStroke.CAP_BUTT:                          pen.DashCap = DashCap.Flat;                          break;                      case java.awt.BasicStroke.CAP_ROUND:                          pen.DashCap = DashCap.Round;                          break;                      case java.awt.BasicStroke.CAP_SQUARE:                          pen.DashCap = DashCap.Flat;                          // there is no equals DashCap in .NET' we need to emulate it                          dashPhase += lineWidth / 2;                          for (int i = 0; i < dash.Length; i++)                          {                              if (i % 2 == 0)                              {                                  dash[i] += 1;                              }                              else                              {                                  dash[i] = Math.Max(0.00001F' dash[i] - 1);                              }                          }                          break;                      default:                          Console.WriteLine("Unknown dash cap type:" + s.getEndCap());                          break;                  }                    // calc the dash offset                  if (lineWidth > 0)                  {                      //dividing by line thickness because of the representation difference                      pen.DashOffset = dashPhase / lineWidth;                  }                  else                  {                      // thickness == 0                      if (dashPhase > 0)                      {                          pen.Width = lineWidth = 0.001F; // hack to prevent a division with 0                          pen.DashOffset = dashPhase / lineWidth;                      }                      else                      {                          pen.DashOffset = 0;                      }                  }                    // set the final dash pattern                   pen.DashPattern = dash;              }
Magic Number,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,SetLineDash,The following statement contains a magic number: if (dash == null)              {                  pen.DashStyle = DashStyle.Solid;              } else {                  if (dash.Length % 2 == 1)                  {                      int len = dash.Length;                      Array.Resize(ref dash' len * 2);                      Array.Copy(dash' 0' dash' len' len);                  }                  float lineWidth = s.getLineWidth();                  if (lineWidth > 1) // for values < 0 there is no correctur needed                  {                      for (int i = 0; i < dash.Length; i++)                      {                          //dividing by line thickness because of the representation difference                          dash[i] = dash[i] / lineWidth;                      }                  }                  // To fix the problem where solid style in Java can be represented at { 1.0' 0.0 }.                  // In .NET' however' array can only have positive value                  if (dash.Length == 2 && dash[dash.Length - 1] == 0)                  {                      Array.Resize(ref dash' 1);                  }                    float dashPhase = s.getDashPhase();                  // correct the dash cap                  switch (s.getEndCap())                  {                      case java.awt.BasicStroke.CAP_BUTT:                          pen.DashCap = DashCap.Flat;                          break;                      case java.awt.BasicStroke.CAP_ROUND:                          pen.DashCap = DashCap.Round;                          break;                      case java.awt.BasicStroke.CAP_SQUARE:                          pen.DashCap = DashCap.Flat;                          // there is no equals DashCap in .NET' we need to emulate it                          dashPhase += lineWidth / 2;                          for (int i = 0; i < dash.Length; i++)                          {                              if (i % 2 == 0)                              {                                  dash[i] += 1;                              }                              else                              {                                  dash[i] = Math.Max(0.00001F' dash[i] - 1);                              }                          }                          break;                      default:                          Console.WriteLine("Unknown dash cap type:" + s.getEndCap());                          break;                  }                    // calc the dash offset                  if (lineWidth > 0)                  {                      //dividing by line thickness because of the representation difference                      pen.DashOffset = dashPhase / lineWidth;                  }                  else                  {                      // thickness == 0                      if (dashPhase > 0)                      {                          pen.Width = lineWidth = 0.001F; // hack to prevent a division with 0                          pen.DashOffset = dashPhase / lineWidth;                      }                      else                      {                          pen.DashOffset = 0;                      }                  }                    // set the final dash pattern                   pen.DashPattern = dash;              }
Magic Number,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,SetLineDash,The following statement contains a magic number: if (dash == null)              {                  pen.DashStyle = DashStyle.Solid;              } else {                  if (dash.Length % 2 == 1)                  {                      int len = dash.Length;                      Array.Resize(ref dash' len * 2);                      Array.Copy(dash' 0' dash' len' len);                  }                  float lineWidth = s.getLineWidth();                  if (lineWidth > 1) // for values < 0 there is no correctur needed                  {                      for (int i = 0; i < dash.Length; i++)                      {                          //dividing by line thickness because of the representation difference                          dash[i] = dash[i] / lineWidth;                      }                  }                  // To fix the problem where solid style in Java can be represented at { 1.0' 0.0 }.                  // In .NET' however' array can only have positive value                  if (dash.Length == 2 && dash[dash.Length - 1] == 0)                  {                      Array.Resize(ref dash' 1);                  }                    float dashPhase = s.getDashPhase();                  // correct the dash cap                  switch (s.getEndCap())                  {                      case java.awt.BasicStroke.CAP_BUTT:                          pen.DashCap = DashCap.Flat;                          break;                      case java.awt.BasicStroke.CAP_ROUND:                          pen.DashCap = DashCap.Round;                          break;                      case java.awt.BasicStroke.CAP_SQUARE:                          pen.DashCap = DashCap.Flat;                          // there is no equals DashCap in .NET' we need to emulate it                          dashPhase += lineWidth / 2;                          for (int i = 0; i < dash.Length; i++)                          {                              if (i % 2 == 0)                              {                                  dash[i] += 1;                              }                              else                              {                                  dash[i] = Math.Max(0.00001F' dash[i] - 1);                              }                          }                          break;                      default:                          Console.WriteLine("Unknown dash cap type:" + s.getEndCap());                          break;                  }                    // calc the dash offset                  if (lineWidth > 0)                  {                      //dividing by line thickness because of the representation difference                      pen.DashOffset = dashPhase / lineWidth;                  }                  else                  {                      // thickness == 0                      if (dashPhase > 0)                      {                          pen.Width = lineWidth = 0.001F; // hack to prevent a division with 0                          pen.DashOffset = dashPhase / lineWidth;                      }                      else                      {                          pen.DashOffset = 0;                      }                  }                    // set the final dash pattern                   pen.DashPattern = dash;              }
Magic Number,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,RadiansToDegrees,The following statement contains a magic number: return radians * (180 / Math.PI);
Magic Number,ikvm.awt,NetGraphicsEnvironment,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,getAvailableFontFamilyNames,The following statement contains a magic number: String[] results = new String[families.Length + 5];
Magic Number,ikvm.awt,NetVolatileImage,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\images.cs,getFont,The following statement contains a magic number: if (component != null)              {                  return component.getFont();              }              else              {                  if (defaultFont == null)                  {                      defaultFont = new java.awt.Font("Dialog"' java.awt.Font.PLAIN' 12);                  }                  return defaultFont;              }
Magic Number,ikvm.awt,NetToolkit,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,initializeDesktopProperties,The following statement contains a magic number: desktopProperties.put("DnD.Autoscroll.initialDelay"' java.lang.Integer.valueOf(50));
Magic Number,ikvm.awt,NetToolkit,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,initializeDesktopProperties,The following statement contains a magic number: desktopProperties.put("DnD.Autoscroll.interval"' java.lang.Integer.valueOf(50));
Magic Number,ikvm.awt,NetMouseDragGestureRecognizer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,mousePressed,The following statement contains a magic number: if (mapDragOperationFromModifiers(e) != java.awt.dnd.DnDConstants.ACTION_NONE)              {                  try                  {                      motionThreshold = java.awt.dnd.DragSource.getDragThreshold();                  }                  catch                   {                      motionThreshold = 5;                  }                  appendEvent(e);              }
Magic Number,ikvm.awt,NetComponentPeer<T;C>,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,postMouseWheelEvent,The following statement contains a magic number: int scrollAmount = -delta * SystemInformation.MouseWheelScrollLines / 120;
Magic Number,ikvm.awt,NetComponentPeer<T;C>,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,OnMouseUp,The following statement contains a magic number: if (isMouseClick || isDoubleClick) // there can only be an Click OR an DoubleClick event - both count as click here  			{  				//We make our own mouse click event because the event order is different in .NET  				//in .NET the click occured before MouseUp  				int clicks = ev.Clicks;  				if (isDoubleClick)  				{  					clicks = 2;  				}  				postMouseEvent(ev' java.awt.@event.MouseEvent.MOUSE_CLICKED' clicks);  			}
Magic Number,ikvm.awt,NetButtonPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getMinimumSize,The following statement contains a magic number: using(Graphics g = control.CreateGraphics())  			{  				// TODO get these fudge factors from somewhere  				return new java.awt.Dimension((int)Math.Round(12 + g.MeasureString(control.Text' control.Font).Width) * 8 / 7' 6 + control.Font.Height * 8 / 7);  			}
Magic Number,ikvm.awt,NetButtonPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getMinimumSize,The following statement contains a magic number: using(Graphics g = control.CreateGraphics())  			{  				// TODO get these fudge factors from somewhere  				return new java.awt.Dimension((int)Math.Round(12 + g.MeasureString(control.Text' control.Font).Width) * 8 / 7' 6 + control.Font.Height * 8 / 7);  			}
Magic Number,ikvm.awt,NetButtonPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getMinimumSize,The following statement contains a magic number: using(Graphics g = control.CreateGraphics())  			{  				// TODO get these fudge factors from somewhere  				return new java.awt.Dimension((int)Math.Round(12 + g.MeasureString(control.Text' control.Font).Width) * 8 / 7' 6 + control.Font.Height * 8 / 7);  			}
Magic Number,ikvm.awt,NetButtonPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getMinimumSize,The following statement contains a magic number: using(Graphics g = control.CreateGraphics())  			{  				// TODO get these fudge factors from somewhere  				return new java.awt.Dimension((int)Math.Round(12 + g.MeasureString(control.Text' control.Font).Width) * 8 / 7' 6 + control.Font.Height * 8 / 7);  			}
Magic Number,ikvm.awt,NetButtonPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getMinimumSize,The following statement contains a magic number: using(Graphics g = control.CreateGraphics())  			{  				// TODO get these fudge factors from somewhere  				return new java.awt.Dimension((int)Math.Round(12 + g.MeasureString(control.Text' control.Font).Width) * 8 / 7' 6 + control.Font.Height * 8 / 7);  			}
Magic Number,ikvm.awt,NetButtonPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getMinimumSize,The following statement contains a magic number: using(Graphics g = control.CreateGraphics())  			{  				// TODO get these fudge factors from somewhere  				return new java.awt.Dimension((int)Math.Round(12 + g.MeasureString(control.Text' control.Font).Width) * 8 / 7' 6 + control.Font.Height * 8 / 7);  			}
Magic Number,ikvm.awt,NetLabelPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getPreferredSizeImpl,The following statement contains a magic number: return new java.awt.Dimension(control.PreferredWidth' 2 + control.PreferredHeight);
Magic Number,ikvm.awt,NetTextFieldPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getPreferredSize,The following statement contains a magic number: using(Graphics g = control.CreateGraphics())  			{  				return new java.awt.Dimension((int)Math.Round((g.MeasureString("abcdefghijklm"' control.Font).Width * len) / 13)' ((TextBox)control).PreferredHeight);  			}
Magic Number,ikvm.awt,NetTextAreaPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getMinimumSize,The following statement contains a magic number: return getMinimumSize(10' 60);
Magic Number,ikvm.awt,NetTextAreaPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getMinimumSize,The following statement contains a magic number: return getMinimumSize(10' 60);
Magic Number,ikvm.awt,NetTextAreaPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getMinimumSize,The following statement contains a magic number: return new java.awt.Dimension(fm.charWidth('0') * cols + 20' fm.getHeight() * rows + 20);
Magic Number,ikvm.awt,NetTextAreaPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getMinimumSize,The following statement contains a magic number: return new java.awt.Dimension(fm.charWidth('0') * cols + 20' fm.getHeight() * rows + 20);
Magic Number,ikvm.awt,NetListPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getMinimumSize,The following statement contains a magic number: return new java.awt.Dimension(100' 100);
Magic Number,ikvm.awt,NetListPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getMinimumSize,The following statement contains a magic number: return new java.awt.Dimension(100' 100);
Magic Number,ikvm.awt,NetTrayIconPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,displayMessage,The following statement contains a magic number: NetToolkit.BeginInvoke(delegate                                    {                                        notifyIcon.ShowBalloonTip(10000' caption' text' icon);                                    });
Magic Number,IKVM.NativeCode.sun.awt,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,Win32ShellFolder2,The following statement contains a magic number: isXP = Environment.OSVersion.Version >= new Version(5' 1);
Magic Number,IKVM.NativeCode.sun.awt,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getExecutableType,The following statement contains a magic number: StringBuilder objResultBuffer = new StringBuilder(1024);
Magic Number,IKVM.NativeCode.sun.awt,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getExecutableType,The following statement contains a magic number: if (result >= 32)  			{  				return objResultBuffer.ToString();  			}
Magic Number,IKVM.NativeCode.sun.awt,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getIconBits,The following statement contains a magic number: if (GetIconInfo(hIcon' out iconInfo))  			{  				using (SafeDeviceContextHandle dc = SafeDeviceContextHandle.Get())  				{  					BITMAPINFO bmi = new BITMAPINFO();  					bmi.biSize = 40;  					bmi.biWidth = iconSize;  					bmi.biHeight = -iconSize;  					bmi.biPlanes = 1;  					bmi.biBitCount = 32;  					bmi.biCompression = 0;  					int intArrSize = iconSize * iconSize;  					int[] iconBits = new int[intArrSize];  					GetDIBits(dc' iconInfo.hbmColor' 0' (uint)iconSize' iconBits' ref bmi' 0);  					bool hasAlpha = false;  					if (isXP)  					{  						for (int i = 0; i < iconBits.Length; i++)  						{  							if ((iconBits[i] & 0xFF000000) != 0)  							{  								hasAlpha = true;  								break;  							}  						}  					}  					if (!hasAlpha)  					{  						int[] maskBits = new int[intArrSize];  						GetDIBits(dc' iconInfo.hbmMask' 0' (uint)iconSize' maskBits' ref bmi' 0);  						for (int i = 0; i < iconBits.Length; i++)  						{  							if (maskBits[i] == 0)  							{  								iconBits[i] = (int)((uint)iconBits[i] | 0xFF000000);  							}  						}  					}  					DeleteObject(iconInfo.hbmColor);  					DeleteObject(iconInfo.hbmMask);                        DeleteObject(hIcon);                      Bitmap bitmap = new Bitmap(iconSize' iconSize' PixelFormat.Format32bppArgb);                      BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' iconSize' iconSize)' ImageLockMode.WriteOnly' PixelFormat.Format32bppArgb);                      Marshal.Copy(iconBits' 0' bitmapData.Scan0' iconBits.Length);                      bitmap.UnlockBits(bitmapData);                      return bitmap;  				}  			}
Magic Number,IKVM.NativeCode.sun.awt,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getIconBits,The following statement contains a magic number: if (GetIconInfo(hIcon' out iconInfo))  			{  				using (SafeDeviceContextHandle dc = SafeDeviceContextHandle.Get())  				{  					BITMAPINFO bmi = new BITMAPINFO();  					bmi.biSize = 40;  					bmi.biWidth = iconSize;  					bmi.biHeight = -iconSize;  					bmi.biPlanes = 1;  					bmi.biBitCount = 32;  					bmi.biCompression = 0;  					int intArrSize = iconSize * iconSize;  					int[] iconBits = new int[intArrSize];  					GetDIBits(dc' iconInfo.hbmColor' 0' (uint)iconSize' iconBits' ref bmi' 0);  					bool hasAlpha = false;  					if (isXP)  					{  						for (int i = 0; i < iconBits.Length; i++)  						{  							if ((iconBits[i] & 0xFF000000) != 0)  							{  								hasAlpha = true;  								break;  							}  						}  					}  					if (!hasAlpha)  					{  						int[] maskBits = new int[intArrSize];  						GetDIBits(dc' iconInfo.hbmMask' 0' (uint)iconSize' maskBits' ref bmi' 0);  						for (int i = 0; i < iconBits.Length; i++)  						{  							if (maskBits[i] == 0)  							{  								iconBits[i] = (int)((uint)iconBits[i] | 0xFF000000);  							}  						}  					}  					DeleteObject(iconInfo.hbmColor);  					DeleteObject(iconInfo.hbmMask);                        DeleteObject(hIcon);                      Bitmap bitmap = new Bitmap(iconSize' iconSize' PixelFormat.Format32bppArgb);                      BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' iconSize' iconSize)' ImageLockMode.WriteOnly' PixelFormat.Format32bppArgb);                      Marshal.Copy(iconBits' 0' bitmapData.Scan0' iconBits.Length);                      bitmap.UnlockBits(bitmapData);                      return bitmap;  				}  			}
Magic Number,IKVM.NativeCode.sun.awt,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getShell32IconResourceAsBitmap,The following statement contains a magic number: int size = getLargeIcon ? 32 : 16;
Magic Number,IKVM.NativeCode.sun.awt,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getShell32IconResourceAsBitmap,The following statement contains a magic number: int size = getLargeIcon ? 32 : 16;
Magic Number,IKVM.NativeCode.sun.awt,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getShell32IconResourceAsBitmap,The following statement contains a magic number: using (SafeGdiObjectHandle hicon = LoadImage(hmodShell32' (IntPtr)iconID' IMAGE_ICON' size' size' 0))  			{  				if (hicon != null)  				{                      return getIconBits(hicon.DangerousGetHandle()' 16);  				}  			}
Magic Number,IKVM.NativeCode.sun.awt,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,copyFirstPIDLEntry,The following statement contains a magic number: int length = Marshal.ReadInt16(pIDL) + 2;
Magic Number,IKVM.NativeCode.sun.awt,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,copyFirstPIDLEntry,The following statement contains a magic number: Marshal.Copy(pIDL' buffer' 0' length - 2);
Magic Number,IKVM.NativeCode.sun.awt,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,combinePIDLs,The following statement contains a magic number: byte[] newPIDL = new byte[lengthP + lengthR + 2];
Magic Number,IKVM.NativeCode.sun.awt,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,combinePIDLs,The following statement contains a magic number: IntPtr newpIDLptr = Marshal.AllocCoTaskMem(lengthP + lengthR + 2);
Magic Number,IKVM.NativeCode.sun.awt,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getFileSystemPath,The following statement contains a magic number: StringBuilder builder = new StringBuilder( 1024 );
Magic Number,IKVM.NativeCode.sun.awt,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getDisplayNameOf,The following statement contains a magic number: if ( hRes == 0 )              {                  StringBuilder name = new StringBuilder( 1024 );                  StrRetToBuf(ref result' relativePIDL' name' 1024);                  string stringName = name.ToString();                  return stringName;              }
Magic Number,IKVM.NativeCode.sun.awt,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getDisplayNameOf,The following statement contains a magic number: if ( hRes == 0 )              {                  StringBuilder name = new StringBuilder( 1024 );                  StrRetToBuf(ref result' relativePIDL' name' 1024);                  string stringName = name.ToString();                  return stringName;              }
Magic Number,IKVM.NativeCode.sun.awt,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,extractIcon,The following statement contains a magic number: if (folder.GetUIObjectOf(IntPtr.Zero' 1' new IntPtr[] { relativePIDL }' ref guid' IntPtr.Zero' out ppv) == 0)              {                  ShellApi.IExtractIcon extractor = (ShellApi.IExtractIcon)ppv;                  int size = 1024;                  StringBuilder path = new StringBuilder( size );                  int piIndex;                  uint pwFlags;                  if (extractor.GetIconLocation((uint)ShellApi.GIL.GIL_FORSHELL' path' size' out piIndex' out pwFlags) == 0)                  {                      IntPtr hIconL = new IntPtr();                      IntPtr hIconS = new IntPtr();                      if (extractor.Extract(path.ToString()' (uint)piIndex' out hIconL' out hIconS' (16 << 16) + 32) == 0)                      {                          if (getLargeIcon)                          {                              ShellApi.DestroyIcon(hIconS);                              return hIconL;                          }                          else                          {                              ShellApi.DestroyIcon(hIconL);                              return hIconS;                          }                      }                  }              }
Magic Number,IKVM.NativeCode.sun.awt,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,extractIcon,The following statement contains a magic number: if (folder.GetUIObjectOf(IntPtr.Zero' 1' new IntPtr[] { relativePIDL }' ref guid' IntPtr.Zero' out ppv) == 0)              {                  ShellApi.IExtractIcon extractor = (ShellApi.IExtractIcon)ppv;                  int size = 1024;                  StringBuilder path = new StringBuilder( size );                  int piIndex;                  uint pwFlags;                  if (extractor.GetIconLocation((uint)ShellApi.GIL.GIL_FORSHELL' path' size' out piIndex' out pwFlags) == 0)                  {                      IntPtr hIconL = new IntPtr();                      IntPtr hIconS = new IntPtr();                      if (extractor.Extract(path.ToString()' (uint)piIndex' out hIconL' out hIconS' (16 << 16) + 32) == 0)                      {                          if (getLargeIcon)                          {                              ShellApi.DestroyIcon(hIconS);                              return hIconL;                          }                          else                          {                              ShellApi.DestroyIcon(hIconL);                              return hIconS;                          }                      }                  }              }
Magic Number,IKVM.NativeCode.sun.awt,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,extractIcon,The following statement contains a magic number: if (folder.GetUIObjectOf(IntPtr.Zero' 1' new IntPtr[] { relativePIDL }' ref guid' IntPtr.Zero' out ppv) == 0)              {                  ShellApi.IExtractIcon extractor = (ShellApi.IExtractIcon)ppv;                  int size = 1024;                  StringBuilder path = new StringBuilder( size );                  int piIndex;                  uint pwFlags;                  if (extractor.GetIconLocation((uint)ShellApi.GIL.GIL_FORSHELL' path' size' out piIndex' out pwFlags) == 0)                  {                      IntPtr hIconL = new IntPtr();                      IntPtr hIconS = new IntPtr();                      if (extractor.Extract(path.ToString()' (uint)piIndex' out hIconL' out hIconS' (16 << 16) + 32) == 0)                      {                          if (getLargeIcon)                          {                              ShellApi.DestroyIcon(hIconS);                              return hIconL;                          }                          else                          {                              ShellApi.DestroyIcon(hIconL);                              return hIconS;                          }                      }                  }              }
Magic Number,IKVM.NativeCode.sun.awt,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,extractIcon,The following statement contains a magic number: if (folder.GetUIObjectOf(IntPtr.Zero' 1' new IntPtr[] { relativePIDL }' ref guid' IntPtr.Zero' out ppv) == 0)              {                  ShellApi.IExtractIcon extractor = (ShellApi.IExtractIcon)ppv;                  int size = 1024;                  StringBuilder path = new StringBuilder( size );                  int piIndex;                  uint pwFlags;                  if (extractor.GetIconLocation((uint)ShellApi.GIL.GIL_FORSHELL' path' size' out piIndex' out pwFlags) == 0)                  {                      IntPtr hIconL = new IntPtr();                      IntPtr hIconS = new IntPtr();                      if (extractor.Extract(path.ToString()' (uint)piIndex' out hIconL' out hIconS' (16 << 16) + 32) == 0)                      {                          if (getLargeIcon)                          {                              ShellApi.DestroyIcon(hIconS);                              return hIconL;                          }                          else                          {                              ShellApi.DestroyIcon(hIconL);                              return hIconS;                          }                      }                  }              }
Magic Number,IKVM.NativeCode.sun.awt,ShellLink,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,GetArguments,The following statement contains a magic number: StringBuilder sb = new StringBuilder(512);
Magic Number,IKVM.NativeCode.sun.awt,ShellLink,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,GetPath,The following statement contains a magic number: StringBuilder sb = new StringBuilder(512);
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,Win32ShellFolder2,The following statement contains a magic number: isXP = Environment.OSVersion.Version >= new Version(5' 1);
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getExecutableType,The following statement contains a magic number: StringBuilder objResultBuffer = new StringBuilder(1024);
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getExecutableType,The following statement contains a magic number: if (result >= 32)  			{  				return objResultBuffer.ToString();  			}
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getIconBits,The following statement contains a magic number: if (GetIconInfo(hIcon' out iconInfo))  			{  				using (SafeDeviceContextHandle dc = SafeDeviceContextHandle.Get())  				{  					BITMAPINFO bmi = new BITMAPINFO();  					bmi.biSize = 40;  					bmi.biWidth = iconSize;  					bmi.biHeight = -iconSize;  					bmi.biPlanes = 1;  					bmi.biBitCount = 32;  					bmi.biCompression = 0;  					int intArrSize = iconSize * iconSize;  					int[] iconBits = new int[intArrSize];  					GetDIBits(dc' iconInfo.hbmColor' 0' (uint)iconSize' iconBits' ref bmi' 0);  					bool hasAlpha = false;  					if (isXP)  					{  						for (int i = 0; i < iconBits.Length; i++)  						{  							if ((iconBits[i] & 0xFF000000) != 0)  							{  								hasAlpha = true;  								break;  							}  						}  					}  					if (!hasAlpha)  					{  						int[] maskBits = new int[intArrSize];  						GetDIBits(dc' iconInfo.hbmMask' 0' (uint)iconSize' maskBits' ref bmi' 0);  						for (int i = 0; i < iconBits.Length; i++)  						{  							if (maskBits[i] == 0)  							{  								iconBits[i] = (int)((uint)iconBits[i] | 0xFF000000);  							}  						}  					}  					DeleteObject(iconInfo.hbmColor);  					DeleteObject(iconInfo.hbmMask);                        DeleteObject(hIcon);                      Bitmap bitmap = new Bitmap(iconSize' iconSize' PixelFormat.Format32bppArgb);                      BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' iconSize' iconSize)' ImageLockMode.WriteOnly' PixelFormat.Format32bppArgb);                      Marshal.Copy(iconBits' 0' bitmapData.Scan0' iconBits.Length);                      bitmap.UnlockBits(bitmapData);                      return bitmap;  				}  			}
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getIconBits,The following statement contains a magic number: if (GetIconInfo(hIcon' out iconInfo))  			{  				using (SafeDeviceContextHandle dc = SafeDeviceContextHandle.Get())  				{  					BITMAPINFO bmi = new BITMAPINFO();  					bmi.biSize = 40;  					bmi.biWidth = iconSize;  					bmi.biHeight = -iconSize;  					bmi.biPlanes = 1;  					bmi.biBitCount = 32;  					bmi.biCompression = 0;  					int intArrSize = iconSize * iconSize;  					int[] iconBits = new int[intArrSize];  					GetDIBits(dc' iconInfo.hbmColor' 0' (uint)iconSize' iconBits' ref bmi' 0);  					bool hasAlpha = false;  					if (isXP)  					{  						for (int i = 0; i < iconBits.Length; i++)  						{  							if ((iconBits[i] & 0xFF000000) != 0)  							{  								hasAlpha = true;  								break;  							}  						}  					}  					if (!hasAlpha)  					{  						int[] maskBits = new int[intArrSize];  						GetDIBits(dc' iconInfo.hbmMask' 0' (uint)iconSize' maskBits' ref bmi' 0);  						for (int i = 0; i < iconBits.Length; i++)  						{  							if (maskBits[i] == 0)  							{  								iconBits[i] = (int)((uint)iconBits[i] | 0xFF000000);  							}  						}  					}  					DeleteObject(iconInfo.hbmColor);  					DeleteObject(iconInfo.hbmMask);                        DeleteObject(hIcon);                      Bitmap bitmap = new Bitmap(iconSize' iconSize' PixelFormat.Format32bppArgb);                      BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' iconSize' iconSize)' ImageLockMode.WriteOnly' PixelFormat.Format32bppArgb);                      Marshal.Copy(iconBits' 0' bitmapData.Scan0' iconBits.Length);                      bitmap.UnlockBits(bitmapData);                      return bitmap;  				}  			}
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getShell32IconResourceAsBitmap,The following statement contains a magic number: int size = getLargeIcon ? 32 : 16;
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getShell32IconResourceAsBitmap,The following statement contains a magic number: int size = getLargeIcon ? 32 : 16;
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getShell32IconResourceAsBitmap,The following statement contains a magic number: using (SafeGdiObjectHandle hicon = LoadImage(hmodShell32' (IntPtr)iconID' IMAGE_ICON' size' size' 0))  			{  				if (hicon != null)  				{                      return getIconBits(hicon.DangerousGetHandle()' 16);  				}  			}
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,copyFirstPIDLEntry,The following statement contains a magic number: int length = Marshal.ReadInt16(pIDL) + 2;
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,copyFirstPIDLEntry,The following statement contains a magic number: Marshal.Copy(pIDL' buffer' 0' length - 2);
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,combinePIDLs,The following statement contains a magic number: byte[] newPIDL = new byte[lengthP + lengthR + 2];
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,combinePIDLs,The following statement contains a magic number: IntPtr newpIDLptr = Marshal.AllocCoTaskMem(lengthP + lengthR + 2);
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getFileSystemPath,The following statement contains a magic number: StringBuilder builder = new StringBuilder( 1024 );
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getDisplayNameOf,The following statement contains a magic number: if ( hRes == 0 )              {                  StringBuilder name = new StringBuilder( 1024 );                  StrRetToBuf(ref result' relativePIDL' name' 1024);                  string stringName = name.ToString();                  return stringName;              }
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getDisplayNameOf,The following statement contains a magic number: if ( hRes == 0 )              {                  StringBuilder name = new StringBuilder( 1024 );                  StrRetToBuf(ref result' relativePIDL' name' 1024);                  string stringName = name.ToString();                  return stringName;              }
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,extractIcon,The following statement contains a magic number: if (folder.GetUIObjectOf(IntPtr.Zero' 1' new IntPtr[] { relativePIDL }' ref guid' IntPtr.Zero' out ppv) == 0)              {                  ShellApi.IExtractIcon extractor = (ShellApi.IExtractIcon)ppv;                  int size = 1024;                  StringBuilder path = new StringBuilder( size );                  int piIndex;                  uint pwFlags;                  if (extractor.GetIconLocation((uint)ShellApi.GIL.GIL_FORSHELL' path' size' out piIndex' out pwFlags) == 0)                  {                      IntPtr hIconL = new IntPtr();                      IntPtr hIconS = new IntPtr();                      if (extractor.Extract(path.ToString()' (uint)piIndex' out hIconL' out hIconS' (16 << 16) + 32) == 0)                      {                          if (getLargeIcon)                          {                              ShellApi.DestroyIcon(hIconS);                              return hIconL;                          }                          else                          {                              ShellApi.DestroyIcon(hIconL);                              return hIconS;                          }                      }                  }              }
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,extractIcon,The following statement contains a magic number: if (folder.GetUIObjectOf(IntPtr.Zero' 1' new IntPtr[] { relativePIDL }' ref guid' IntPtr.Zero' out ppv) == 0)              {                  ShellApi.IExtractIcon extractor = (ShellApi.IExtractIcon)ppv;                  int size = 1024;                  StringBuilder path = new StringBuilder( size );                  int piIndex;                  uint pwFlags;                  if (extractor.GetIconLocation((uint)ShellApi.GIL.GIL_FORSHELL' path' size' out piIndex' out pwFlags) == 0)                  {                      IntPtr hIconL = new IntPtr();                      IntPtr hIconS = new IntPtr();                      if (extractor.Extract(path.ToString()' (uint)piIndex' out hIconL' out hIconS' (16 << 16) + 32) == 0)                      {                          if (getLargeIcon)                          {                              ShellApi.DestroyIcon(hIconS);                              return hIconL;                          }                          else                          {                              ShellApi.DestroyIcon(hIconL);                              return hIconS;                          }                      }                  }              }
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,extractIcon,The following statement contains a magic number: if (folder.GetUIObjectOf(IntPtr.Zero' 1' new IntPtr[] { relativePIDL }' ref guid' IntPtr.Zero' out ppv) == 0)              {                  ShellApi.IExtractIcon extractor = (ShellApi.IExtractIcon)ppv;                  int size = 1024;                  StringBuilder path = new StringBuilder( size );                  int piIndex;                  uint pwFlags;                  if (extractor.GetIconLocation((uint)ShellApi.GIL.GIL_FORSHELL' path' size' out piIndex' out pwFlags) == 0)                  {                      IntPtr hIconL = new IntPtr();                      IntPtr hIconS = new IntPtr();                      if (extractor.Extract(path.ToString()' (uint)piIndex' out hIconL' out hIconS' (16 << 16) + 32) == 0)                      {                          if (getLargeIcon)                          {                              ShellApi.DestroyIcon(hIconS);                              return hIconL;                          }                          else                          {                              ShellApi.DestroyIcon(hIconL);                              return hIconS;                          }                      }                  }              }
Magic Number,IKVM.NativeCode.sun.awt.shell,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,extractIcon,The following statement contains a magic number: if (folder.GetUIObjectOf(IntPtr.Zero' 1' new IntPtr[] { relativePIDL }' ref guid' IntPtr.Zero' out ppv) == 0)              {                  ShellApi.IExtractIcon extractor = (ShellApi.IExtractIcon)ppv;                  int size = 1024;                  StringBuilder path = new StringBuilder( size );                  int piIndex;                  uint pwFlags;                  if (extractor.GetIconLocation((uint)ShellApi.GIL.GIL_FORSHELL' path' size' out piIndex' out pwFlags) == 0)                  {                      IntPtr hIconL = new IntPtr();                      IntPtr hIconS = new IntPtr();                      if (extractor.Extract(path.ToString()' (uint)piIndex' out hIconL' out hIconS' (16 << 16) + 32) == 0)                      {                          if (getLargeIcon)                          {                              ShellApi.DestroyIcon(hIconS);                              return hIconL;                          }                          else                          {                              ShellApi.DestroyIcon(hIconL);                              return hIconS;                          }                      }                  }              }
Magic Number,IKVM.NativeCode.sun.awt.shell,ShellLink,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,GetArguments,The following statement contains a magic number: StringBuilder sb = new StringBuilder(512);
Magic Number,IKVM.NativeCode.sun.awt.shell,ShellLink,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,GetPath,The following statement contains a magic number: StringBuilder sb = new StringBuilder(512);
Magic Number,IKVM.NativeCode.sun.java2d,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,Win32ShellFolder2,The following statement contains a magic number: isXP = Environment.OSVersion.Version >= new Version(5' 1);
Magic Number,IKVM.NativeCode.sun.java2d,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getExecutableType,The following statement contains a magic number: StringBuilder objResultBuffer = new StringBuilder(1024);
Magic Number,IKVM.NativeCode.sun.java2d,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getExecutableType,The following statement contains a magic number: if (result >= 32)  			{  				return objResultBuffer.ToString();  			}
Magic Number,IKVM.NativeCode.sun.java2d,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getIconBits,The following statement contains a magic number: if (GetIconInfo(hIcon' out iconInfo))  			{  				using (SafeDeviceContextHandle dc = SafeDeviceContextHandle.Get())  				{  					BITMAPINFO bmi = new BITMAPINFO();  					bmi.biSize = 40;  					bmi.biWidth = iconSize;  					bmi.biHeight = -iconSize;  					bmi.biPlanes = 1;  					bmi.biBitCount = 32;  					bmi.biCompression = 0;  					int intArrSize = iconSize * iconSize;  					int[] iconBits = new int[intArrSize];  					GetDIBits(dc' iconInfo.hbmColor' 0' (uint)iconSize' iconBits' ref bmi' 0);  					bool hasAlpha = false;  					if (isXP)  					{  						for (int i = 0; i < iconBits.Length; i++)  						{  							if ((iconBits[i] & 0xFF000000) != 0)  							{  								hasAlpha = true;  								break;  							}  						}  					}  					if (!hasAlpha)  					{  						int[] maskBits = new int[intArrSize];  						GetDIBits(dc' iconInfo.hbmMask' 0' (uint)iconSize' maskBits' ref bmi' 0);  						for (int i = 0; i < iconBits.Length; i++)  						{  							if (maskBits[i] == 0)  							{  								iconBits[i] = (int)((uint)iconBits[i] | 0xFF000000);  							}  						}  					}  					DeleteObject(iconInfo.hbmColor);  					DeleteObject(iconInfo.hbmMask);                        DeleteObject(hIcon);                      Bitmap bitmap = new Bitmap(iconSize' iconSize' PixelFormat.Format32bppArgb);                      BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' iconSize' iconSize)' ImageLockMode.WriteOnly' PixelFormat.Format32bppArgb);                      Marshal.Copy(iconBits' 0' bitmapData.Scan0' iconBits.Length);                      bitmap.UnlockBits(bitmapData);                      return bitmap;  				}  			}
Magic Number,IKVM.NativeCode.sun.java2d,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getIconBits,The following statement contains a magic number: if (GetIconInfo(hIcon' out iconInfo))  			{  				using (SafeDeviceContextHandle dc = SafeDeviceContextHandle.Get())  				{  					BITMAPINFO bmi = new BITMAPINFO();  					bmi.biSize = 40;  					bmi.biWidth = iconSize;  					bmi.biHeight = -iconSize;  					bmi.biPlanes = 1;  					bmi.biBitCount = 32;  					bmi.biCompression = 0;  					int intArrSize = iconSize * iconSize;  					int[] iconBits = new int[intArrSize];  					GetDIBits(dc' iconInfo.hbmColor' 0' (uint)iconSize' iconBits' ref bmi' 0);  					bool hasAlpha = false;  					if (isXP)  					{  						for (int i = 0; i < iconBits.Length; i++)  						{  							if ((iconBits[i] & 0xFF000000) != 0)  							{  								hasAlpha = true;  								break;  							}  						}  					}  					if (!hasAlpha)  					{  						int[] maskBits = new int[intArrSize];  						GetDIBits(dc' iconInfo.hbmMask' 0' (uint)iconSize' maskBits' ref bmi' 0);  						for (int i = 0; i < iconBits.Length; i++)  						{  							if (maskBits[i] == 0)  							{  								iconBits[i] = (int)((uint)iconBits[i] | 0xFF000000);  							}  						}  					}  					DeleteObject(iconInfo.hbmColor);  					DeleteObject(iconInfo.hbmMask);                        DeleteObject(hIcon);                      Bitmap bitmap = new Bitmap(iconSize' iconSize' PixelFormat.Format32bppArgb);                      BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' iconSize' iconSize)' ImageLockMode.WriteOnly' PixelFormat.Format32bppArgb);                      Marshal.Copy(iconBits' 0' bitmapData.Scan0' iconBits.Length);                      bitmap.UnlockBits(bitmapData);                      return bitmap;  				}  			}
Magic Number,IKVM.NativeCode.sun.java2d,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getShell32IconResourceAsBitmap,The following statement contains a magic number: int size = getLargeIcon ? 32 : 16;
Magic Number,IKVM.NativeCode.sun.java2d,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getShell32IconResourceAsBitmap,The following statement contains a magic number: int size = getLargeIcon ? 32 : 16;
Magic Number,IKVM.NativeCode.sun.java2d,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getShell32IconResourceAsBitmap,The following statement contains a magic number: using (SafeGdiObjectHandle hicon = LoadImage(hmodShell32' (IntPtr)iconID' IMAGE_ICON' size' size' 0))  			{  				if (hicon != null)  				{                      return getIconBits(hicon.DangerousGetHandle()' 16);  				}  			}
Magic Number,IKVM.NativeCode.sun.java2d,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,copyFirstPIDLEntry,The following statement contains a magic number: int length = Marshal.ReadInt16(pIDL) + 2;
Magic Number,IKVM.NativeCode.sun.java2d,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,copyFirstPIDLEntry,The following statement contains a magic number: Marshal.Copy(pIDL' buffer' 0' length - 2);
Magic Number,IKVM.NativeCode.sun.java2d,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,combinePIDLs,The following statement contains a magic number: byte[] newPIDL = new byte[lengthP + lengthR + 2];
Magic Number,IKVM.NativeCode.sun.java2d,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,combinePIDLs,The following statement contains a magic number: IntPtr newpIDLptr = Marshal.AllocCoTaskMem(lengthP + lengthR + 2);
Magic Number,IKVM.NativeCode.sun.java2d,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getFileSystemPath,The following statement contains a magic number: StringBuilder builder = new StringBuilder( 1024 );
Magic Number,IKVM.NativeCode.sun.java2d,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getDisplayNameOf,The following statement contains a magic number: if ( hRes == 0 )              {                  StringBuilder name = new StringBuilder( 1024 );                  StrRetToBuf(ref result' relativePIDL' name' 1024);                  string stringName = name.ToString();                  return stringName;              }
Magic Number,IKVM.NativeCode.sun.java2d,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getDisplayNameOf,The following statement contains a magic number: if ( hRes == 0 )              {                  StringBuilder name = new StringBuilder( 1024 );                  StrRetToBuf(ref result' relativePIDL' name' 1024);                  string stringName = name.ToString();                  return stringName;              }
Magic Number,IKVM.NativeCode.sun.java2d,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,extractIcon,The following statement contains a magic number: if (folder.GetUIObjectOf(IntPtr.Zero' 1' new IntPtr[] { relativePIDL }' ref guid' IntPtr.Zero' out ppv) == 0)              {                  ShellApi.IExtractIcon extractor = (ShellApi.IExtractIcon)ppv;                  int size = 1024;                  StringBuilder path = new StringBuilder( size );                  int piIndex;                  uint pwFlags;                  if (extractor.GetIconLocation((uint)ShellApi.GIL.GIL_FORSHELL' path' size' out piIndex' out pwFlags) == 0)                  {                      IntPtr hIconL = new IntPtr();                      IntPtr hIconS = new IntPtr();                      if (extractor.Extract(path.ToString()' (uint)piIndex' out hIconL' out hIconS' (16 << 16) + 32) == 0)                      {                          if (getLargeIcon)                          {                              ShellApi.DestroyIcon(hIconS);                              return hIconL;                          }                          else                          {                              ShellApi.DestroyIcon(hIconL);                              return hIconS;                          }                      }                  }              }
Magic Number,IKVM.NativeCode.sun.java2d,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,extractIcon,The following statement contains a magic number: if (folder.GetUIObjectOf(IntPtr.Zero' 1' new IntPtr[] { relativePIDL }' ref guid' IntPtr.Zero' out ppv) == 0)              {                  ShellApi.IExtractIcon extractor = (ShellApi.IExtractIcon)ppv;                  int size = 1024;                  StringBuilder path = new StringBuilder( size );                  int piIndex;                  uint pwFlags;                  if (extractor.GetIconLocation((uint)ShellApi.GIL.GIL_FORSHELL' path' size' out piIndex' out pwFlags) == 0)                  {                      IntPtr hIconL = new IntPtr();                      IntPtr hIconS = new IntPtr();                      if (extractor.Extract(path.ToString()' (uint)piIndex' out hIconL' out hIconS' (16 << 16) + 32) == 0)                      {                          if (getLargeIcon)                          {                              ShellApi.DestroyIcon(hIconS);                              return hIconL;                          }                          else                          {                              ShellApi.DestroyIcon(hIconL);                              return hIconS;                          }                      }                  }              }
Magic Number,IKVM.NativeCode.sun.java2d,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,extractIcon,The following statement contains a magic number: if (folder.GetUIObjectOf(IntPtr.Zero' 1' new IntPtr[] { relativePIDL }' ref guid' IntPtr.Zero' out ppv) == 0)              {                  ShellApi.IExtractIcon extractor = (ShellApi.IExtractIcon)ppv;                  int size = 1024;                  StringBuilder path = new StringBuilder( size );                  int piIndex;                  uint pwFlags;                  if (extractor.GetIconLocation((uint)ShellApi.GIL.GIL_FORSHELL' path' size' out piIndex' out pwFlags) == 0)                  {                      IntPtr hIconL = new IntPtr();                      IntPtr hIconS = new IntPtr();                      if (extractor.Extract(path.ToString()' (uint)piIndex' out hIconL' out hIconS' (16 << 16) + 32) == 0)                      {                          if (getLargeIcon)                          {                              ShellApi.DestroyIcon(hIconS);                              return hIconL;                          }                          else                          {                              ShellApi.DestroyIcon(hIconL);                              return hIconS;                          }                      }                  }              }
Magic Number,IKVM.NativeCode.sun.java2d,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,extractIcon,The following statement contains a magic number: if (folder.GetUIObjectOf(IntPtr.Zero' 1' new IntPtr[] { relativePIDL }' ref guid' IntPtr.Zero' out ppv) == 0)              {                  ShellApi.IExtractIcon extractor = (ShellApi.IExtractIcon)ppv;                  int size = 1024;                  StringBuilder path = new StringBuilder( size );                  int piIndex;                  uint pwFlags;                  if (extractor.GetIconLocation((uint)ShellApi.GIL.GIL_FORSHELL' path' size' out piIndex' out pwFlags) == 0)                  {                      IntPtr hIconL = new IntPtr();                      IntPtr hIconS = new IntPtr();                      if (extractor.Extract(path.ToString()' (uint)piIndex' out hIconL' out hIconS' (16 << 16) + 32) == 0)                      {                          if (getLargeIcon)                          {                              ShellApi.DestroyIcon(hIconS);                              return hIconL;                          }                          else                          {                              ShellApi.DestroyIcon(hIconL);                              return hIconS;                          }                      }                  }              }
Magic Number,IKVM.NativeCode.sun.java2d,ShellLink,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,GetArguments,The following statement contains a magic number: StringBuilder sb = new StringBuilder(512);
Magic Number,IKVM.NativeCode.sun.java2d,ShellLink,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,GetPath,The following statement contains a magic number: StringBuilder sb = new StringBuilder(512);
Magic Number,IKVM.NativeCode.sun.java2d.pipe,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,Win32ShellFolder2,The following statement contains a magic number: isXP = Environment.OSVersion.Version >= new Version(5' 1);
Magic Number,IKVM.NativeCode.sun.java2d.pipe,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getExecutableType,The following statement contains a magic number: StringBuilder objResultBuffer = new StringBuilder(1024);
Magic Number,IKVM.NativeCode.sun.java2d.pipe,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getExecutableType,The following statement contains a magic number: if (result >= 32)  			{  				return objResultBuffer.ToString();  			}
Magic Number,IKVM.NativeCode.sun.java2d.pipe,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getIconBits,The following statement contains a magic number: if (GetIconInfo(hIcon' out iconInfo))  			{  				using (SafeDeviceContextHandle dc = SafeDeviceContextHandle.Get())  				{  					BITMAPINFO bmi = new BITMAPINFO();  					bmi.biSize = 40;  					bmi.biWidth = iconSize;  					bmi.biHeight = -iconSize;  					bmi.biPlanes = 1;  					bmi.biBitCount = 32;  					bmi.biCompression = 0;  					int intArrSize = iconSize * iconSize;  					int[] iconBits = new int[intArrSize];  					GetDIBits(dc' iconInfo.hbmColor' 0' (uint)iconSize' iconBits' ref bmi' 0);  					bool hasAlpha = false;  					if (isXP)  					{  						for (int i = 0; i < iconBits.Length; i++)  						{  							if ((iconBits[i] & 0xFF000000) != 0)  							{  								hasAlpha = true;  								break;  							}  						}  					}  					if (!hasAlpha)  					{  						int[] maskBits = new int[intArrSize];  						GetDIBits(dc' iconInfo.hbmMask' 0' (uint)iconSize' maskBits' ref bmi' 0);  						for (int i = 0; i < iconBits.Length; i++)  						{  							if (maskBits[i] == 0)  							{  								iconBits[i] = (int)((uint)iconBits[i] | 0xFF000000);  							}  						}  					}  					DeleteObject(iconInfo.hbmColor);  					DeleteObject(iconInfo.hbmMask);                        DeleteObject(hIcon);                      Bitmap bitmap = new Bitmap(iconSize' iconSize' PixelFormat.Format32bppArgb);                      BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' iconSize' iconSize)' ImageLockMode.WriteOnly' PixelFormat.Format32bppArgb);                      Marshal.Copy(iconBits' 0' bitmapData.Scan0' iconBits.Length);                      bitmap.UnlockBits(bitmapData);                      return bitmap;  				}  			}
Magic Number,IKVM.NativeCode.sun.java2d.pipe,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getIconBits,The following statement contains a magic number: if (GetIconInfo(hIcon' out iconInfo))  			{  				using (SafeDeviceContextHandle dc = SafeDeviceContextHandle.Get())  				{  					BITMAPINFO bmi = new BITMAPINFO();  					bmi.biSize = 40;  					bmi.biWidth = iconSize;  					bmi.biHeight = -iconSize;  					bmi.biPlanes = 1;  					bmi.biBitCount = 32;  					bmi.biCompression = 0;  					int intArrSize = iconSize * iconSize;  					int[] iconBits = new int[intArrSize];  					GetDIBits(dc' iconInfo.hbmColor' 0' (uint)iconSize' iconBits' ref bmi' 0);  					bool hasAlpha = false;  					if (isXP)  					{  						for (int i = 0; i < iconBits.Length; i++)  						{  							if ((iconBits[i] & 0xFF000000) != 0)  							{  								hasAlpha = true;  								break;  							}  						}  					}  					if (!hasAlpha)  					{  						int[] maskBits = new int[intArrSize];  						GetDIBits(dc' iconInfo.hbmMask' 0' (uint)iconSize' maskBits' ref bmi' 0);  						for (int i = 0; i < iconBits.Length; i++)  						{  							if (maskBits[i] == 0)  							{  								iconBits[i] = (int)((uint)iconBits[i] | 0xFF000000);  							}  						}  					}  					DeleteObject(iconInfo.hbmColor);  					DeleteObject(iconInfo.hbmMask);                        DeleteObject(hIcon);                      Bitmap bitmap = new Bitmap(iconSize' iconSize' PixelFormat.Format32bppArgb);                      BitmapData bitmapData = bitmap.LockBits(new Rectangle(0' 0' iconSize' iconSize)' ImageLockMode.WriteOnly' PixelFormat.Format32bppArgb);                      Marshal.Copy(iconBits' 0' bitmapData.Scan0' iconBits.Length);                      bitmap.UnlockBits(bitmapData);                      return bitmap;  				}  			}
Magic Number,IKVM.NativeCode.sun.java2d.pipe,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getShell32IconResourceAsBitmap,The following statement contains a magic number: int size = getLargeIcon ? 32 : 16;
Magic Number,IKVM.NativeCode.sun.java2d.pipe,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getShell32IconResourceAsBitmap,The following statement contains a magic number: int size = getLargeIcon ? 32 : 16;
Magic Number,IKVM.NativeCode.sun.java2d.pipe,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getShell32IconResourceAsBitmap,The following statement contains a magic number: using (SafeGdiObjectHandle hicon = LoadImage(hmodShell32' (IntPtr)iconID' IMAGE_ICON' size' size' 0))  			{  				if (hicon != null)  				{                      return getIconBits(hicon.DangerousGetHandle()' 16);  				}  			}
Magic Number,IKVM.NativeCode.sun.java2d.pipe,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,copyFirstPIDLEntry,The following statement contains a magic number: int length = Marshal.ReadInt16(pIDL) + 2;
Magic Number,IKVM.NativeCode.sun.java2d.pipe,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,copyFirstPIDLEntry,The following statement contains a magic number: Marshal.Copy(pIDL' buffer' 0' length - 2);
Magic Number,IKVM.NativeCode.sun.java2d.pipe,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,combinePIDLs,The following statement contains a magic number: byte[] newPIDL = new byte[lengthP + lengthR + 2];
Magic Number,IKVM.NativeCode.sun.java2d.pipe,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,combinePIDLs,The following statement contains a magic number: IntPtr newpIDLptr = Marshal.AllocCoTaskMem(lengthP + lengthR + 2);
Magic Number,IKVM.NativeCode.sun.java2d.pipe,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getFileSystemPath,The following statement contains a magic number: StringBuilder builder = new StringBuilder( 1024 );
Magic Number,IKVM.NativeCode.sun.java2d.pipe,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getDisplayNameOf,The following statement contains a magic number: if ( hRes == 0 )              {                  StringBuilder name = new StringBuilder( 1024 );                  StrRetToBuf(ref result' relativePIDL' name' 1024);                  string stringName = name.ToString();                  return stringName;              }
Magic Number,IKVM.NativeCode.sun.java2d.pipe,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,getDisplayNameOf,The following statement contains a magic number: if ( hRes == 0 )              {                  StringBuilder name = new StringBuilder( 1024 );                  StrRetToBuf(ref result' relativePIDL' name' 1024);                  string stringName = name.ToString();                  return stringName;              }
Magic Number,IKVM.NativeCode.sun.java2d.pipe,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,extractIcon,The following statement contains a magic number: if (folder.GetUIObjectOf(IntPtr.Zero' 1' new IntPtr[] { relativePIDL }' ref guid' IntPtr.Zero' out ppv) == 0)              {                  ShellApi.IExtractIcon extractor = (ShellApi.IExtractIcon)ppv;                  int size = 1024;                  StringBuilder path = new StringBuilder( size );                  int piIndex;                  uint pwFlags;                  if (extractor.GetIconLocation((uint)ShellApi.GIL.GIL_FORSHELL' path' size' out piIndex' out pwFlags) == 0)                  {                      IntPtr hIconL = new IntPtr();                      IntPtr hIconS = new IntPtr();                      if (extractor.Extract(path.ToString()' (uint)piIndex' out hIconL' out hIconS' (16 << 16) + 32) == 0)                      {                          if (getLargeIcon)                          {                              ShellApi.DestroyIcon(hIconS);                              return hIconL;                          }                          else                          {                              ShellApi.DestroyIcon(hIconL);                              return hIconS;                          }                      }                  }              }
Magic Number,IKVM.NativeCode.sun.java2d.pipe,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,extractIcon,The following statement contains a magic number: if (folder.GetUIObjectOf(IntPtr.Zero' 1' new IntPtr[] { relativePIDL }' ref guid' IntPtr.Zero' out ppv) == 0)              {                  ShellApi.IExtractIcon extractor = (ShellApi.IExtractIcon)ppv;                  int size = 1024;                  StringBuilder path = new StringBuilder( size );                  int piIndex;                  uint pwFlags;                  if (extractor.GetIconLocation((uint)ShellApi.GIL.GIL_FORSHELL' path' size' out piIndex' out pwFlags) == 0)                  {                      IntPtr hIconL = new IntPtr();                      IntPtr hIconS = new IntPtr();                      if (extractor.Extract(path.ToString()' (uint)piIndex' out hIconL' out hIconS' (16 << 16) + 32) == 0)                      {                          if (getLargeIcon)                          {                              ShellApi.DestroyIcon(hIconS);                              return hIconL;                          }                          else                          {                              ShellApi.DestroyIcon(hIconL);                              return hIconS;                          }                      }                  }              }
Magic Number,IKVM.NativeCode.sun.java2d.pipe,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,extractIcon,The following statement contains a magic number: if (folder.GetUIObjectOf(IntPtr.Zero' 1' new IntPtr[] { relativePIDL }' ref guid' IntPtr.Zero' out ppv) == 0)              {                  ShellApi.IExtractIcon extractor = (ShellApi.IExtractIcon)ppv;                  int size = 1024;                  StringBuilder path = new StringBuilder( size );                  int piIndex;                  uint pwFlags;                  if (extractor.GetIconLocation((uint)ShellApi.GIL.GIL_FORSHELL' path' size' out piIndex' out pwFlags) == 0)                  {                      IntPtr hIconL = new IntPtr();                      IntPtr hIconS = new IntPtr();                      if (extractor.Extract(path.ToString()' (uint)piIndex' out hIconL' out hIconS' (16 << 16) + 32) == 0)                      {                          if (getLargeIcon)                          {                              ShellApi.DestroyIcon(hIconS);                              return hIconL;                          }                          else                          {                              ShellApi.DestroyIcon(hIconL);                              return hIconS;                          }                      }                  }              }
Magic Number,IKVM.NativeCode.sun.java2d.pipe,Win32ShellFolder2,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,extractIcon,The following statement contains a magic number: if (folder.GetUIObjectOf(IntPtr.Zero' 1' new IntPtr[] { relativePIDL }' ref guid' IntPtr.Zero' out ppv) == 0)              {                  ShellApi.IExtractIcon extractor = (ShellApi.IExtractIcon)ppv;                  int size = 1024;                  StringBuilder path = new StringBuilder( size );                  int piIndex;                  uint pwFlags;                  if (extractor.GetIconLocation((uint)ShellApi.GIL.GIL_FORSHELL' path' size' out piIndex' out pwFlags) == 0)                  {                      IntPtr hIconL = new IntPtr();                      IntPtr hIconS = new IntPtr();                      if (extractor.Extract(path.ToString()' (uint)piIndex' out hIconL' out hIconS' (16 << 16) + 32) == 0)                      {                          if (getLargeIcon)                          {                              ShellApi.DestroyIcon(hIconS);                              return hIconL;                          }                          else                          {                              ShellApi.DestroyIcon(hIconL);                              return hIconS;                          }                      }                  }              }
Magic Number,IKVM.NativeCode.sun.java2d.pipe,ShellLink,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,GetArguments,The following statement contains a magic number: StringBuilder sb = new StringBuilder(512);
Magic Number,IKVM.NativeCode.sun.java2d.pipe,ShellLink,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\native.cs,GetPath,The following statement contains a magic number: StringBuilder sb = new StringBuilder(512);
Magic Number,ikvm.awt.printing,Win32PrintPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\printing.cs,GetPrinterInfo2,The following statement contains a magic number: try              {                  int needed = 0;                  if (OpenPrinter(printerName' out printer' IntPtr.Zero)                      && !GetPrinter(printer' 2' IntPtr.Zero' 0' out needed))                  {                      int lastWin32Error = Marshal.GetLastWin32Error();                      if (lastWin32Error == ERROR_INSUFFICIENT_BUFFER)                      {                          IntPtr pPrinter = Marshal.AllocHGlobal((int)needed);                          try                          {                              if (GetPrinter(printer' 2' pPrinter' needed' out needed))                              {                                  PRINTER_INFO_2 printerInfo2 = (PRINTER_INFO_2)Marshal.PtrToStructure(pPrinter' typeof(PRINTER_INFO_2));                                  cJobs = printerInfo2.cJobs;                                  status = printerInfo2.Status;                                  return true;                              }                          }                          finally                          {                              Marshal.FreeHGlobal(pPrinter);                          }                      }                  }              }              finally              {                  if (printer != null)                  {                      printer.Close();                  }              }
Magic Number,ikvm.awt.printing,Win32PrintPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\printing.cs,GetPrinterInfo2,The following statement contains a magic number: try              {                  int needed = 0;                  if (OpenPrinter(printerName' out printer' IntPtr.Zero)                      && !GetPrinter(printer' 2' IntPtr.Zero' 0' out needed))                  {                      int lastWin32Error = Marshal.GetLastWin32Error();                      if (lastWin32Error == ERROR_INSUFFICIENT_BUFFER)                      {                          IntPtr pPrinter = Marshal.AllocHGlobal((int)needed);                          try                          {                              if (GetPrinter(printer' 2' pPrinter' needed' out needed))                              {                                  PRINTER_INFO_2 printerInfo2 = (PRINTER_INFO_2)Marshal.PtrToStructure(pPrinter' typeof(PRINTER_INFO_2));                                  cJobs = printerInfo2.cJobs;                                  status = printerInfo2.Status;                                  return true;                              }                          }                          finally                          {                              Marshal.FreeHGlobal(pPrinter);                          }                      }                  }              }              finally              {                  if (printer != null)                  {                      printer.Close();                  }              }
Missing Default,ikvm.awt,J2C,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\converter.cs,ConvertShape,The following switch statement is missing a default case: switch (type)                  {                      case java.awt.geom.PathIterator.__Fields.SEG_MOVETO:                          x = coords[0];                          y = coords[1];                          gp.StartFigure();                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_LINETO:                          gp.AddLine(x' y' coords[0]' coords[1]);                          x = coords[0];                          y = coords[1];                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_QUADTO:                          gp.AddBezier(x' y' coords[0]' coords[1]' coords[0]' coords[1]' coords[2]' coords[3]);                          x = coords[2];                          y = coords[3];                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_CUBICTO:                          gp.AddBezier(x' y' coords[0]' coords[1]' coords[2]' coords[3]' coords[4]' coords[5]);                          x = coords[4];                          y = coords[5];                          break;                      case java.awt.geom.PathIterator.__Fields.SEG_CLOSE:                          gp.CloseFigure();                          break;                  }
Missing Default,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,setPaint,The following switch statement is missing a default case: switch (gradient.getCycleMethod().ordinal()) {                      case (int)java.awt.MultipleGradientPaint.CycleMethod.__Enum.NO_CYCLE:                      case (int)java.awt.MultipleGradientPaint.CycleMethod.__Enum.REFLECT:                          linear.WrapMode = WrapMode.TileFlipXY;                          break;                      case (int)java.awt.MultipleGradientPaint.CycleMethod.__Enum.REPEAT:                          linear.WrapMode = WrapMode.Tile;                          break;                  }
Missing Default,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,getRenderingHints,The following switch statement is missing a default case: switch (g.SmoothingMode)              {                  case SmoothingMode.Default:                      hints.put(java.awt.RenderingHints.KEY_ANTIALIASING' java.awt.RenderingHints.VALUE_ANTIALIAS_DEFAULT);                      break;                  case SmoothingMode.None:                      hints.put(java.awt.RenderingHints.KEY_ANTIALIASING' java.awt.RenderingHints.VALUE_ANTIALIAS_OFF);                      break;                  case SmoothingMode.AntiAlias:                      hints.put(java.awt.RenderingHints.KEY_ANTIALIASING' java.awt.RenderingHints.VALUE_ANTIALIAS_ON);                      break;              }
Missing Default,ikvm.awt,NetGraphics,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\graphics.cs,getRenderingHints,The following switch statement is missing a default case: switch (g.InterpolationMode)              {                  case InterpolationMode.Bilinear:                  case InterpolationMode.HighQualityBilinear:                      hints.put(java.awt.RenderingHints.KEY_INTERPOLATION' java.awt.RenderingHints.VALUE_INTERPOLATION_BILINEAR);                      break;                  case InterpolationMode.Bicubic:                  case InterpolationMode.HighQualityBicubic:                      hints.put(java.awt.RenderingHints.KEY_INTERPOLATION' java.awt.RenderingHints.VALUE_INTERPOLATION_BICUBIC);                      break;                  case InterpolationMode.NearestNeighbor:                      hints.put(java.awt.RenderingHints.KEY_INTERPOLATION' java.awt.RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR);                      break;              }
Missing Default,ikvm.awt,WindowsRobot,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\robot.cs,mousePress,The following switch statement is missing a default case: switch (button)              {                  case InputEvent.BUTTON1_MASK:                      dwFlags |= MOUSEEVENTF_LEFTDOWN;                      break;                  case InputEvent.BUTTON2_MASK:                      dwFlags |= MOUSEEVENTF_MIDDLEDOWN;                      break;                  case InputEvent.BUTTON3_MASK:                      dwFlags |= MOUSEEVENTF_RIGHTDOWN;                      break;              }
Missing Default,ikvm.awt,WindowsRobot,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\robot.cs,mouseRelease,The following switch statement is missing a default case: switch (button)              {                  case InputEvent.BUTTON1_MASK:                      dwFlags |= MOUSEEVENTF_LEFTUP;                      break;                  case InputEvent.BUTTON2_MASK:                      dwFlags |= MOUSEEVENTF_MIDDLEUP;                      break;                  case InputEvent.BUTTON3_MASK:                      dwFlags |= MOUSEEVENTF_RIGHTUP;                      break;              }
Missing Default,ikvm.awt,NetComponentPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,getAction,The following switch statement is missing a default case: switch (effects)  			{  				case DragDropEffects.None:  					actions = java.awt.dnd.DnDConstants.ACTION_NONE;  					break;  				case DragDropEffects.Copy:  					actions = java.awt.dnd.DnDConstants.ACTION_COPY;  					break;  				case DragDropEffects.Move:  					actions = java.awt.dnd.DnDConstants.ACTION_MOVE;  					break;  				case DragDropEffects.Move | DragDropEffects.Copy:  					actions = java.awt.dnd.DnDConstants.ACTION_COPY_OR_MOVE;  					break;  				case DragDropEffects.Link:  					actions = java.awt.dnd.DnDConstants.ACTION_LINK;  					break;  			}
Missing Default,ikvm.awt,NetComponentPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,GetMouseEventModifiers,The following switch statement is missing a default case: switch (button)  			{  				case MouseButtons.Left:  					modifiers |= java.awt.@event.InputEvent.BUTTON1_MASK;  					break;  				case MouseButtons.Middle:  					modifiers |= java.awt.@event.InputEvent.BUTTON2_MASK;  					break;  				case MouseButtons.Right:  					modifiers |= java.awt.@event.InputEvent.BUTTON3_MASK;  					break;  			}
Missing Default,ikvm.awt,NetComponentPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,GetModifiers,The following switch statement is missing a default case: switch (keys & (Keys.Control | Keys.Alt))              {                  case Keys.Control:                      modifiers |= java.awt.@event.InputEvent.CTRL_DOWN_MASK;                      break;                  case Keys.Alt:                      modifiers |= java.awt.@event.InputEvent.ALT_DOWN_MASK;                      break;                  case Keys.Control | Keys.Alt:                      modifiers |= java.awt.@event.InputEvent.ALT_GRAPH_DOWN_MASK;                      break;              }
Missing Default,ikvm.awt,NetTextFieldPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,handleJavaKeyEvent,The following switch statement is missing a default case: switch (e.getID())              {                  case java.awt.@event.KeyEvent.KEY_TYPED:                      if ((e.getKeyChar() == '\n') && !e.isAltDown() && !e.isControlDown())                      {                          postEvent(new java.awt.@event.ActionEvent(target' java.awt.@event.ActionEvent.ACTION_PERFORMED'                                                    getText()' e.getWhen()' e.getModifiers()));                          return true;                      }                      break;              }
Missing Default,ikvm.awt,NetFramePeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,setState,The following switch statement is missing a default case: switch(state)  			       {                         case java.awt.Frame.NORMAL:                             form.WindowState = FormWindowState.Normal;                             break;                         case java.awt.Frame.MAXIMIZED_BOTH:  			               form.WindowState = FormWindowState.Maximized;  			               break;                         case java.awt.Frame.ICONIFIED:                             form.WindowState = FormWindowState.Minimized;                             break;                     }
Missing Default,ikvm.awt,NetTrayIconPeer,C:\repos\CoEST_TraceLab\Main\external\ikvm\src\awt\toolkit-0.95.cs,displayMessage,The following switch statement is missing a default case: switch(messageType)              {                  case "ERROR" :                      icon = ToolTipIcon.Error;                      break;                  case "WARNING" :                      icon = ToolTipIcon.Warning;                      break;                  case "INFO" :                      icon = ToolTipIcon.Info;                      break;                  case "NONE" :                      icon = ToolTipIcon.None;                      break;              }
