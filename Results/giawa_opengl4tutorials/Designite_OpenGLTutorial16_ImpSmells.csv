Implementation smell,Namespace,Class,File,Method,Description
Long Method,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjObject,The method has 62 lines of code.
Long Method,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The method has 60 lines of code.
Complex Method,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,BMFont,Cyclomatic complexity of the method is 14
Complex Method,OpenGLTutorial16,ObjLoader,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjLoader,Cyclomatic complexity of the method is 14
Complex Method,OpenGLTutorial16,ObjLoader,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,LoadMaterials,Cyclomatic complexity of the method is 11
Complex Method,OpenGLTutorial16,ObjMaterial,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjMaterial,Cyclomatic complexity of the method is 24
Complex Method,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjObject,Cyclomatic complexity of the method is 20
Complex Method,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,Cyclomatic complexity of the method is 11
Complex Method,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnRenderFrame,Cyclomatic complexity of the method is 8
Complex Method,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnKeyboardDown,Cyclomatic complexity of the method is 7
Complex Method,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnKeyboardUp,Cyclomatic complexity of the method is 10
Long Parameter List,OpenGLTutorial16,FontVAO,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,FontVAO,The method has 4 parameters.
Long Parameter List,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjObject,The method has 4 parameters.
Long Parameter List,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The method has 8 parameters.
Long Parameter List,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnMouse,The method has 4 parameters.
Long Statement,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The length of the statement  "	return new FontVAO (program' new VBO<Vector3> (vertices)' new VBO<Vector2> (uvs)' new VBO<int> (indices' BufferTarget.ElementArrayBuffer)); " is 139.
Long Statement,OpenGLTutorial16,ObjLoader,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,LoadMaterials,The length of the statement  "		// If the obj has just one material would not execute the ObjMaterial function up' so I added (if the there are lines still not processed' process them) " is 152.
Long Statement,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,Main,The length of the statement  "	Glut.glutInitDisplayMode (Glut.GLUT_DOUBLE | Glut.GLUT_DEPTH | Glut.GLUT_ALPHA | Glut.GLUT_STENCIL | Glut.GLUT_MULTISAMPLE); " is 124.
Long Statement,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,Main,The length of the statement  "	program ["projection_matrix"].SetValue (Matrix4.CreatePerspectiveFieldOfView (0.45f' (float)width / height' 0.1f' 1000f)); " is 122.
Long Statement,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnReshape,The length of the statement  "	program ["projection_matrix"].SetValue (Matrix4.CreatePerspectiveFieldOfView (0.45f' (float)width / height' 0.1f' 1000f)); " is 122.
Complex Conditional,OpenGLTutorial16,ObjLoader,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjLoader,The conditional expression  "(line [0] == 'o' && lines.Count != 0) || (line [0] == 'g' && objLines.Count != 0)"  is complex.
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: if (justification != Justification.Left) {  	for (int i = 0; i < text.Length; i++)  		width += (int)characters [characters.ContainsKey (text [i]) ? text [i] : ' '].width;  	if (justification == Justification.Right)  		xpos = -width;  	else  		xpos = -width / 2;  }  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: if (justification == Justification.Right)  	xpos = -width;  else  	xpos = -width / 2;  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: xpos = -width / 2;  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < text.Length; i++) {  	// grab the character' replacing with ' ' if the character isn't loaded  	Character ch = characters [characters.ContainsKey (text [i]) ? text [i] : ' '];  	vertices [i * 4 + 0] = new Vector3 (xpos' ch.height' 0);  	vertices [i * 4 + 1] = new Vector3 (xpos' 0' 0);  	vertices [i * 4 + 2] = new Vector3 (xpos + ch.width' ch.height' 0);  	vertices [i * 4 + 3] = new Vector3 (xpos + ch.width' 0' 0);  	xpos += (int)ch.width;  	uvs [i * 4 + 0] = new Vector2 (ch.x1' ch.y1);  	uvs [i * 4 + 1] = new Vector2 (ch.x1' ch.y2);  	uvs [i * 4 + 2] = new Vector2 (ch.x2' ch.y1);  	uvs [i * 4 + 3] = new Vector2 (ch.x2' ch.y2);  	indices [i * 6 + 0] = i * 4 + 2;  	indices [i * 6 + 1] = i * 4 + 0;  	indices [i * 6 + 2] = i * 4 + 1;  	indices [i * 6 + 3] = i * 4 + 3;  	indices [i * 6 + 4] = i * 4 + 2;  	indices [i * 6 + 5] = i * 4 + 1;  }  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < text.Length; i++) {  	// grab the character' replacing with ' ' if the character isn't loaded  	Character ch = characters [characters.ContainsKey (text [i]) ? text [i] : ' '];  	vertices [i * 4 + 0] = new Vector3 (xpos' ch.height' 0);  	vertices [i * 4 + 1] = new Vector3 (xpos' 0' 0);  	vertices [i * 4 + 2] = new Vector3 (xpos + ch.width' ch.height' 0);  	vertices [i * 4 + 3] = new Vector3 (xpos + ch.width' 0' 0);  	xpos += (int)ch.width;  	uvs [i * 4 + 0] = new Vector2 (ch.x1' ch.y1);  	uvs [i * 4 + 1] = new Vector2 (ch.x1' ch.y2);  	uvs [i * 4 + 2] = new Vector2 (ch.x2' ch.y1);  	uvs [i * 4 + 3] = new Vector2 (ch.x2' ch.y2);  	indices [i * 6 + 0] = i * 4 + 2;  	indices [i * 6 + 1] = i * 4 + 0;  	indices [i * 6 + 2] = i * 4 + 1;  	indices [i * 6 + 3] = i * 4 + 3;  	indices [i * 6 + 4] = i * 4 + 2;  	indices [i * 6 + 5] = i * 4 + 1;  }  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < text.Length; i++) {  	// grab the character' replacing with ' ' if the character isn't loaded  	Character ch = characters [characters.ContainsKey (text [i]) ? text [i] : ' '];  	vertices [i * 4 + 0] = new Vector3 (xpos' ch.height' 0);  	vertices [i * 4 + 1] = new Vector3 (xpos' 0' 0);  	vertices [i * 4 + 2] = new Vector3 (xpos + ch.width' ch.height' 0);  	vertices [i * 4 + 3] = new Vector3 (xpos + ch.width' 0' 0);  	xpos += (int)ch.width;  	uvs [i * 4 + 0] = new Vector2 (ch.x1' ch.y1);  	uvs [i * 4 + 1] = new Vector2 (ch.x1' ch.y2);  	uvs [i * 4 + 2] = new Vector2 (ch.x2' ch.y1);  	uvs [i * 4 + 3] = new Vector2 (ch.x2' ch.y2);  	indices [i * 6 + 0] = i * 4 + 2;  	indices [i * 6 + 1] = i * 4 + 0;  	indices [i * 6 + 2] = i * 4 + 1;  	indices [i * 6 + 3] = i * 4 + 3;  	indices [i * 6 + 4] = i * 4 + 2;  	indices [i * 6 + 5] = i * 4 + 1;  }  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < text.Length; i++) {  	// grab the character' replacing with ' ' if the character isn't loaded  	Character ch = characters [characters.ContainsKey (text [i]) ? text [i] : ' '];  	vertices [i * 4 + 0] = new Vector3 (xpos' ch.height' 0);  	vertices [i * 4 + 1] = new Vector3 (xpos' 0' 0);  	vertices [i * 4 + 2] = new Vector3 (xpos + ch.width' ch.height' 0);  	vertices [i * 4 + 3] = new Vector3 (xpos + ch.width' 0' 0);  	xpos += (int)ch.width;  	uvs [i * 4 + 0] = new Vector2 (ch.x1' ch.y1);  	uvs [i * 4 + 1] = new Vector2 (ch.x1' ch.y2);  	uvs [i * 4 + 2] = new Vector2 (ch.x2' ch.y1);  	uvs [i * 4 + 3] = new Vector2 (ch.x2' ch.y2);  	indices [i * 6 + 0] = i * 4 + 2;  	indices [i * 6 + 1] = i * 4 + 0;  	indices [i * 6 + 2] = i * 4 + 1;  	indices [i * 6 + 3] = i * 4 + 3;  	indices [i * 6 + 4] = i * 4 + 2;  	indices [i * 6 + 5] = i * 4 + 1;  }  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < text.Length; i++) {  	// grab the character' replacing with ' ' if the character isn't loaded  	Character ch = characters [characters.ContainsKey (text [i]) ? text [i] : ' '];  	vertices [i * 4 + 0] = new Vector3 (xpos' ch.height' 0);  	vertices [i * 4 + 1] = new Vector3 (xpos' 0' 0);  	vertices [i * 4 + 2] = new Vector3 (xpos + ch.width' ch.height' 0);  	vertices [i * 4 + 3] = new Vector3 (xpos + ch.width' 0' 0);  	xpos += (int)ch.width;  	uvs [i * 4 + 0] = new Vector2 (ch.x1' ch.y1);  	uvs [i * 4 + 1] = new Vector2 (ch.x1' ch.y2);  	uvs [i * 4 + 2] = new Vector2 (ch.x2' ch.y1);  	uvs [i * 4 + 3] = new Vector2 (ch.x2' ch.y2);  	indices [i * 6 + 0] = i * 4 + 2;  	indices [i * 6 + 1] = i * 4 + 0;  	indices [i * 6 + 2] = i * 4 + 1;  	indices [i * 6 + 3] = i * 4 + 3;  	indices [i * 6 + 4] = i * 4 + 2;  	indices [i * 6 + 5] = i * 4 + 1;  }  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < text.Length; i++) {  	// grab the character' replacing with ' ' if the character isn't loaded  	Character ch = characters [characters.ContainsKey (text [i]) ? text [i] : ' '];  	vertices [i * 4 + 0] = new Vector3 (xpos' ch.height' 0);  	vertices [i * 4 + 1] = new Vector3 (xpos' 0' 0);  	vertices [i * 4 + 2] = new Vector3 (xpos + ch.width' ch.height' 0);  	vertices [i * 4 + 3] = new Vector3 (xpos + ch.width' 0' 0);  	xpos += (int)ch.width;  	uvs [i * 4 + 0] = new Vector2 (ch.x1' ch.y1);  	uvs [i * 4 + 1] = new Vector2 (ch.x1' ch.y2);  	uvs [i * 4 + 2] = new Vector2 (ch.x2' ch.y1);  	uvs [i * 4 + 3] = new Vector2 (ch.x2' ch.y2);  	indices [i * 6 + 0] = i * 4 + 2;  	indices [i * 6 + 1] = i * 4 + 0;  	indices [i * 6 + 2] = i * 4 + 1;  	indices [i * 6 + 3] = i * 4 + 3;  	indices [i * 6 + 4] = i * 4 + 2;  	indices [i * 6 + 5] = i * 4 + 1;  }  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < text.Length; i++) {  	// grab the character' replacing with ' ' if the character isn't loaded  	Character ch = characters [characters.ContainsKey (text [i]) ? text [i] : ' '];  	vertices [i * 4 + 0] = new Vector3 (xpos' ch.height' 0);  	vertices [i * 4 + 1] = new Vector3 (xpos' 0' 0);  	vertices [i * 4 + 2] = new Vector3 (xpos + ch.width' ch.height' 0);  	vertices [i * 4 + 3] = new Vector3 (xpos + ch.width' 0' 0);  	xpos += (int)ch.width;  	uvs [i * 4 + 0] = new Vector2 (ch.x1' ch.y1);  	uvs [i * 4 + 1] = new Vector2 (ch.x1' ch.y2);  	uvs [i * 4 + 2] = new Vector2 (ch.x2' ch.y1);  	uvs [i * 4 + 3] = new Vector2 (ch.x2' ch.y2);  	indices [i * 6 + 0] = i * 4 + 2;  	indices [i * 6 + 1] = i * 4 + 0;  	indices [i * 6 + 2] = i * 4 + 1;  	indices [i * 6 + 3] = i * 4 + 3;  	indices [i * 6 + 4] = i * 4 + 2;  	indices [i * 6 + 5] = i * 4 + 1;  }  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < text.Length; i++) {  	// grab the character' replacing with ' ' if the character isn't loaded  	Character ch = characters [characters.ContainsKey (text [i]) ? text [i] : ' '];  	vertices [i * 4 + 0] = new Vector3 (xpos' ch.height' 0);  	vertices [i * 4 + 1] = new Vector3 (xpos' 0' 0);  	vertices [i * 4 + 2] = new Vector3 (xpos + ch.width' ch.height' 0);  	vertices [i * 4 + 3] = new Vector3 (xpos + ch.width' 0' 0);  	xpos += (int)ch.width;  	uvs [i * 4 + 0] = new Vector2 (ch.x1' ch.y1);  	uvs [i * 4 + 1] = new Vector2 (ch.x1' ch.y2);  	uvs [i * 4 + 2] = new Vector2 (ch.x2' ch.y1);  	uvs [i * 4 + 3] = new Vector2 (ch.x2' ch.y2);  	indices [i * 6 + 0] = i * 4 + 2;  	indices [i * 6 + 1] = i * 4 + 0;  	indices [i * 6 + 2] = i * 4 + 1;  	indices [i * 6 + 3] = i * 4 + 3;  	indices [i * 6 + 4] = i * 4 + 2;  	indices [i * 6 + 5] = i * 4 + 1;  }  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < text.Length; i++) {  	// grab the character' replacing with ' ' if the character isn't loaded  	Character ch = characters [characters.ContainsKey (text [i]) ? text [i] : ' '];  	vertices [i * 4 + 0] = new Vector3 (xpos' ch.height' 0);  	vertices [i * 4 + 1] = new Vector3 (xpos' 0' 0);  	vertices [i * 4 + 2] = new Vector3 (xpos + ch.width' ch.height' 0);  	vertices [i * 4 + 3] = new Vector3 (xpos + ch.width' 0' 0);  	xpos += (int)ch.width;  	uvs [i * 4 + 0] = new Vector2 (ch.x1' ch.y1);  	uvs [i * 4 + 1] = new Vector2 (ch.x1' ch.y2);  	uvs [i * 4 + 2] = new Vector2 (ch.x2' ch.y1);  	uvs [i * 4 + 3] = new Vector2 (ch.x2' ch.y2);  	indices [i * 6 + 0] = i * 4 + 2;  	indices [i * 6 + 1] = i * 4 + 0;  	indices [i * 6 + 2] = i * 4 + 1;  	indices [i * 6 + 3] = i * 4 + 3;  	indices [i * 6 + 4] = i * 4 + 2;  	indices [i * 6 + 5] = i * 4 + 1;  }  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < text.Length; i++) {  	// grab the character' replacing with ' ' if the character isn't loaded  	Character ch = characters [characters.ContainsKey (text [i]) ? text [i] : ' '];  	vertices [i * 4 + 0] = new Vector3 (xpos' ch.height' 0);  	vertices [i * 4 + 1] = new Vector3 (xpos' 0' 0);  	vertices [i * 4 + 2] = new Vector3 (xpos + ch.width' ch.height' 0);  	vertices [i * 4 + 3] = new Vector3 (xpos + ch.width' 0' 0);  	xpos += (int)ch.width;  	uvs [i * 4 + 0] = new Vector2 (ch.x1' ch.y1);  	uvs [i * 4 + 1] = new Vector2 (ch.x1' ch.y2);  	uvs [i * 4 + 2] = new Vector2 (ch.x2' ch.y1);  	uvs [i * 4 + 3] = new Vector2 (ch.x2' ch.y2);  	indices [i * 6 + 0] = i * 4 + 2;  	indices [i * 6 + 1] = i * 4 + 0;  	indices [i * 6 + 2] = i * 4 + 1;  	indices [i * 6 + 3] = i * 4 + 3;  	indices [i * 6 + 4] = i * 4 + 2;  	indices [i * 6 + 5] = i * 4 + 1;  }  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < text.Length; i++) {  	// grab the character' replacing with ' ' if the character isn't loaded  	Character ch = characters [characters.ContainsKey (text [i]) ? text [i] : ' '];  	vertices [i * 4 + 0] = new Vector3 (xpos' ch.height' 0);  	vertices [i * 4 + 1] = new Vector3 (xpos' 0' 0);  	vertices [i * 4 + 2] = new Vector3 (xpos + ch.width' ch.height' 0);  	vertices [i * 4 + 3] = new Vector3 (xpos + ch.width' 0' 0);  	xpos += (int)ch.width;  	uvs [i * 4 + 0] = new Vector2 (ch.x1' ch.y1);  	uvs [i * 4 + 1] = new Vector2 (ch.x1' ch.y2);  	uvs [i * 4 + 2] = new Vector2 (ch.x2' ch.y1);  	uvs [i * 4 + 3] = new Vector2 (ch.x2' ch.y2);  	indices [i * 6 + 0] = i * 4 + 2;  	indices [i * 6 + 1] = i * 4 + 0;  	indices [i * 6 + 2] = i * 4 + 1;  	indices [i * 6 + 3] = i * 4 + 3;  	indices [i * 6 + 4] = i * 4 + 2;  	indices [i * 6 + 5] = i * 4 + 1;  }  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < text.Length; i++) {  	// grab the character' replacing with ' ' if the character isn't loaded  	Character ch = characters [characters.ContainsKey (text [i]) ? text [i] : ' '];  	vertices [i * 4 + 0] = new Vector3 (xpos' ch.height' 0);  	vertices [i * 4 + 1] = new Vector3 (xpos' 0' 0);  	vertices [i * 4 + 2] = new Vector3 (xpos + ch.width' ch.height' 0);  	vertices [i * 4 + 3] = new Vector3 (xpos + ch.width' 0' 0);  	xpos += (int)ch.width;  	uvs [i * 4 + 0] = new Vector2 (ch.x1' ch.y1);  	uvs [i * 4 + 1] = new Vector2 (ch.x1' ch.y2);  	uvs [i * 4 + 2] = new Vector2 (ch.x2' ch.y1);  	uvs [i * 4 + 3] = new Vector2 (ch.x2' ch.y2);  	indices [i * 6 + 0] = i * 4 + 2;  	indices [i * 6 + 1] = i * 4 + 0;  	indices [i * 6 + 2] = i * 4 + 1;  	indices [i * 6 + 3] = i * 4 + 3;  	indices [i * 6 + 4] = i * 4 + 2;  	indices [i * 6 + 5] = i * 4 + 1;  }  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < text.Length; i++) {  	// grab the character' replacing with ' ' if the character isn't loaded  	Character ch = characters [characters.ContainsKey (text [i]) ? text [i] : ' '];  	vertices [i * 4 + 0] = new Vector3 (xpos' ch.height' 0);  	vertices [i * 4 + 1] = new Vector3 (xpos' 0' 0);  	vertices [i * 4 + 2] = new Vector3 (xpos + ch.width' ch.height' 0);  	vertices [i * 4 + 3] = new Vector3 (xpos + ch.width' 0' 0);  	xpos += (int)ch.width;  	uvs [i * 4 + 0] = new Vector2 (ch.x1' ch.y1);  	uvs [i * 4 + 1] = new Vector2 (ch.x1' ch.y2);  	uvs [i * 4 + 2] = new Vector2 (ch.x2' ch.y1);  	uvs [i * 4 + 3] = new Vector2 (ch.x2' ch.y2);  	indices [i * 6 + 0] = i * 4 + 2;  	indices [i * 6 + 1] = i * 4 + 0;  	indices [i * 6 + 2] = i * 4 + 1;  	indices [i * 6 + 3] = i * 4 + 3;  	indices [i * 6 + 4] = i * 4 + 2;  	indices [i * 6 + 5] = i * 4 + 1;  }  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < text.Length; i++) {  	// grab the character' replacing with ' ' if the character isn't loaded  	Character ch = characters [characters.ContainsKey (text [i]) ? text [i] : ' '];  	vertices [i * 4 + 0] = new Vector3 (xpos' ch.height' 0);  	vertices [i * 4 + 1] = new Vector3 (xpos' 0' 0);  	vertices [i * 4 + 2] = new Vector3 (xpos + ch.width' ch.height' 0);  	vertices [i * 4 + 3] = new Vector3 (xpos + ch.width' 0' 0);  	xpos += (int)ch.width;  	uvs [i * 4 + 0] = new Vector2 (ch.x1' ch.y1);  	uvs [i * 4 + 1] = new Vector2 (ch.x1' ch.y2);  	uvs [i * 4 + 2] = new Vector2 (ch.x2' ch.y1);  	uvs [i * 4 + 3] = new Vector2 (ch.x2' ch.y2);  	indices [i * 6 + 0] = i * 4 + 2;  	indices [i * 6 + 1] = i * 4 + 0;  	indices [i * 6 + 2] = i * 4 + 1;  	indices [i * 6 + 3] = i * 4 + 3;  	indices [i * 6 + 4] = i * 4 + 2;  	indices [i * 6 + 5] = i * 4 + 1;  }  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < text.Length; i++) {  	// grab the character' replacing with ' ' if the character isn't loaded  	Character ch = characters [characters.ContainsKey (text [i]) ? text [i] : ' '];  	vertices [i * 4 + 0] = new Vector3 (xpos' ch.height' 0);  	vertices [i * 4 + 1] = new Vector3 (xpos' 0' 0);  	vertices [i * 4 + 2] = new Vector3 (xpos + ch.width' ch.height' 0);  	vertices [i * 4 + 3] = new Vector3 (xpos + ch.width' 0' 0);  	xpos += (int)ch.width;  	uvs [i * 4 + 0] = new Vector2 (ch.x1' ch.y1);  	uvs [i * 4 + 1] = new Vector2 (ch.x1' ch.y2);  	uvs [i * 4 + 2] = new Vector2 (ch.x2' ch.y1);  	uvs [i * 4 + 3] = new Vector2 (ch.x2' ch.y2);  	indices [i * 6 + 0] = i * 4 + 2;  	indices [i * 6 + 1] = i * 4 + 0;  	indices [i * 6 + 2] = i * 4 + 1;  	indices [i * 6 + 3] = i * 4 + 3;  	indices [i * 6 + 4] = i * 4 + 2;  	indices [i * 6 + 5] = i * 4 + 1;  }  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < text.Length; i++) {  	// grab the character' replacing with ' ' if the character isn't loaded  	Character ch = characters [characters.ContainsKey (text [i]) ? text [i] : ' '];  	vertices [i * 4 + 0] = new Vector3 (xpos' ch.height' 0);  	vertices [i * 4 + 1] = new Vector3 (xpos' 0' 0);  	vertices [i * 4 + 2] = new Vector3 (xpos + ch.width' ch.height' 0);  	vertices [i * 4 + 3] = new Vector3 (xpos + ch.width' 0' 0);  	xpos += (int)ch.width;  	uvs [i * 4 + 0] = new Vector2 (ch.x1' ch.y1);  	uvs [i * 4 + 1] = new Vector2 (ch.x1' ch.y2);  	uvs [i * 4 + 2] = new Vector2 (ch.x2' ch.y1);  	uvs [i * 4 + 3] = new Vector2 (ch.x2' ch.y2);  	indices [i * 6 + 0] = i * 4 + 2;  	indices [i * 6 + 1] = i * 4 + 0;  	indices [i * 6 + 2] = i * 4 + 1;  	indices [i * 6 + 3] = i * 4 + 3;  	indices [i * 6 + 4] = i * 4 + 2;  	indices [i * 6 + 5] = i * 4 + 1;  }  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < text.Length; i++) {  	// grab the character' replacing with ' ' if the character isn't loaded  	Character ch = characters [characters.ContainsKey (text [i]) ? text [i] : ' '];  	vertices [i * 4 + 0] = new Vector3 (xpos' ch.height' 0);  	vertices [i * 4 + 1] = new Vector3 (xpos' 0' 0);  	vertices [i * 4 + 2] = new Vector3 (xpos + ch.width' ch.height' 0);  	vertices [i * 4 + 3] = new Vector3 (xpos + ch.width' 0' 0);  	xpos += (int)ch.width;  	uvs [i * 4 + 0] = new Vector2 (ch.x1' ch.y1);  	uvs [i * 4 + 1] = new Vector2 (ch.x1' ch.y2);  	uvs [i * 4 + 2] = new Vector2 (ch.x2' ch.y1);  	uvs [i * 4 + 3] = new Vector2 (ch.x2' ch.y2);  	indices [i * 6 + 0] = i * 4 + 2;  	indices [i * 6 + 1] = i * 4 + 0;  	indices [i * 6 + 2] = i * 4 + 1;  	indices [i * 6 + 3] = i * 4 + 3;  	indices [i * 6 + 4] = i * 4 + 2;  	indices [i * 6 + 5] = i * 4 + 1;  }  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < text.Length; i++) {  	// grab the character' replacing with ' ' if the character isn't loaded  	Character ch = characters [characters.ContainsKey (text [i]) ? text [i] : ' '];  	vertices [i * 4 + 0] = new Vector3 (xpos' ch.height' 0);  	vertices [i * 4 + 1] = new Vector3 (xpos' 0' 0);  	vertices [i * 4 + 2] = new Vector3 (xpos + ch.width' ch.height' 0);  	vertices [i * 4 + 3] = new Vector3 (xpos + ch.width' 0' 0);  	xpos += (int)ch.width;  	uvs [i * 4 + 0] = new Vector2 (ch.x1' ch.y1);  	uvs [i * 4 + 1] = new Vector2 (ch.x1' ch.y2);  	uvs [i * 4 + 2] = new Vector2 (ch.x2' ch.y1);  	uvs [i * 4 + 3] = new Vector2 (ch.x2' ch.y2);  	indices [i * 6 + 0] = i * 4 + 2;  	indices [i * 6 + 1] = i * 4 + 0;  	indices [i * 6 + 2] = i * 4 + 1;  	indices [i * 6 + 3] = i * 4 + 3;  	indices [i * 6 + 4] = i * 4 + 2;  	indices [i * 6 + 5] = i * 4 + 1;  }  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < text.Length; i++) {  	// grab the character' replacing with ' ' if the character isn't loaded  	Character ch = characters [characters.ContainsKey (text [i]) ? text [i] : ' '];  	vertices [i * 4 + 0] = new Vector3 (xpos' ch.height' 0);  	vertices [i * 4 + 1] = new Vector3 (xpos' 0' 0);  	vertices [i * 4 + 2] = new Vector3 (xpos + ch.width' ch.height' 0);  	vertices [i * 4 + 3] = new Vector3 (xpos + ch.width' 0' 0);  	xpos += (int)ch.width;  	uvs [i * 4 + 0] = new Vector2 (ch.x1' ch.y1);  	uvs [i * 4 + 1] = new Vector2 (ch.x1' ch.y2);  	uvs [i * 4 + 2] = new Vector2 (ch.x2' ch.y1);  	uvs [i * 4 + 3] = new Vector2 (ch.x2' ch.y2);  	indices [i * 6 + 0] = i * 4 + 2;  	indices [i * 6 + 1] = i * 4 + 0;  	indices [i * 6 + 2] = i * 4 + 1;  	indices [i * 6 + 3] = i * 4 + 3;  	indices [i * 6 + 4] = i * 4 + 2;  	indices [i * 6 + 5] = i * 4 + 1;  }  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < text.Length; i++) {  	// grab the character' replacing with ' ' if the character isn't loaded  	Character ch = characters [characters.ContainsKey (text [i]) ? text [i] : ' '];  	vertices [i * 4 + 0] = new Vector3 (xpos' ch.height' 0);  	vertices [i * 4 + 1] = new Vector3 (xpos' 0' 0);  	vertices [i * 4 + 2] = new Vector3 (xpos + ch.width' ch.height' 0);  	vertices [i * 4 + 3] = new Vector3 (xpos + ch.width' 0' 0);  	xpos += (int)ch.width;  	uvs [i * 4 + 0] = new Vector2 (ch.x1' ch.y1);  	uvs [i * 4 + 1] = new Vector2 (ch.x1' ch.y2);  	uvs [i * 4 + 2] = new Vector2 (ch.x2' ch.y1);  	uvs [i * 4 + 3] = new Vector2 (ch.x2' ch.y2);  	indices [i * 6 + 0] = i * 4 + 2;  	indices [i * 6 + 1] = i * 4 + 0;  	indices [i * 6 + 2] = i * 4 + 1;  	indices [i * 6 + 3] = i * 4 + 3;  	indices [i * 6 + 4] = i * 4 + 2;  	indices [i * 6 + 5] = i * 4 + 1;  }  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < text.Length; i++) {  	// grab the character' replacing with ' ' if the character isn't loaded  	Character ch = characters [characters.ContainsKey (text [i]) ? text [i] : ' '];  	vertices [i * 4 + 0] = new Vector3 (xpos' ch.height' 0);  	vertices [i * 4 + 1] = new Vector3 (xpos' 0' 0);  	vertices [i * 4 + 2] = new Vector3 (xpos + ch.width' ch.height' 0);  	vertices [i * 4 + 3] = new Vector3 (xpos + ch.width' 0' 0);  	xpos += (int)ch.width;  	uvs [i * 4 + 0] = new Vector2 (ch.x1' ch.y1);  	uvs [i * 4 + 1] = new Vector2 (ch.x1' ch.y2);  	uvs [i * 4 + 2] = new Vector2 (ch.x2' ch.y1);  	uvs [i * 4 + 3] = new Vector2 (ch.x2' ch.y2);  	indices [i * 6 + 0] = i * 4 + 2;  	indices [i * 6 + 1] = i * 4 + 0;  	indices [i * 6 + 2] = i * 4 + 1;  	indices [i * 6 + 3] = i * 4 + 3;  	indices [i * 6 + 4] = i * 4 + 2;  	indices [i * 6 + 5] = i * 4 + 1;  }  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < text.Length; i++) {  	// grab the character' replacing with ' ' if the character isn't loaded  	Character ch = characters [characters.ContainsKey (text [i]) ? text [i] : ' '];  	vertices [i * 4 + 0] = new Vector3 (xpos' ch.height' 0);  	vertices [i * 4 + 1] = new Vector3 (xpos' 0' 0);  	vertices [i * 4 + 2] = new Vector3 (xpos + ch.width' ch.height' 0);  	vertices [i * 4 + 3] = new Vector3 (xpos + ch.width' 0' 0);  	xpos += (int)ch.width;  	uvs [i * 4 + 0] = new Vector2 (ch.x1' ch.y1);  	uvs [i * 4 + 1] = new Vector2 (ch.x1' ch.y2);  	uvs [i * 4 + 2] = new Vector2 (ch.x2' ch.y1);  	uvs [i * 4 + 3] = new Vector2 (ch.x2' ch.y2);  	indices [i * 6 + 0] = i * 4 + 2;  	indices [i * 6 + 1] = i * 4 + 0;  	indices [i * 6 + 2] = i * 4 + 1;  	indices [i * 6 + 3] = i * 4 + 3;  	indices [i * 6 + 4] = i * 4 + 2;  	indices [i * 6 + 5] = i * 4 + 1;  }  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < text.Length; i++) {  	// grab the character' replacing with ' ' if the character isn't loaded  	Character ch = characters [characters.ContainsKey (text [i]) ? text [i] : ' '];  	vertices [i * 4 + 0] = new Vector3 (xpos' ch.height' 0);  	vertices [i * 4 + 1] = new Vector3 (xpos' 0' 0);  	vertices [i * 4 + 2] = new Vector3 (xpos + ch.width' ch.height' 0);  	vertices [i * 4 + 3] = new Vector3 (xpos + ch.width' 0' 0);  	xpos += (int)ch.width;  	uvs [i * 4 + 0] = new Vector2 (ch.x1' ch.y1);  	uvs [i * 4 + 1] = new Vector2 (ch.x1' ch.y2);  	uvs [i * 4 + 2] = new Vector2 (ch.x2' ch.y1);  	uvs [i * 4 + 3] = new Vector2 (ch.x2' ch.y2);  	indices [i * 6 + 0] = i * 4 + 2;  	indices [i * 6 + 1] = i * 4 + 0;  	indices [i * 6 + 2] = i * 4 + 1;  	indices [i * 6 + 3] = i * 4 + 3;  	indices [i * 6 + 4] = i * 4 + 2;  	indices [i * 6 + 5] = i * 4 + 1;  }  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < text.Length; i++) {  	// grab the character' replacing with ' ' if the character isn't loaded  	Character ch = characters [characters.ContainsKey (text [i]) ? text [i] : ' '];  	vertices [i * 4 + 0] = new Vector3 (xpos' ch.height' 0);  	vertices [i * 4 + 1] = new Vector3 (xpos' 0' 0);  	vertices [i * 4 + 2] = new Vector3 (xpos + ch.width' ch.height' 0);  	vertices [i * 4 + 3] = new Vector3 (xpos + ch.width' 0' 0);  	xpos += (int)ch.width;  	uvs [i * 4 + 0] = new Vector2 (ch.x1' ch.y1);  	uvs [i * 4 + 1] = new Vector2 (ch.x1' ch.y2);  	uvs [i * 4 + 2] = new Vector2 (ch.x2' ch.y1);  	uvs [i * 4 + 3] = new Vector2 (ch.x2' ch.y2);  	indices [i * 6 + 0] = i * 4 + 2;  	indices [i * 6 + 1] = i * 4 + 0;  	indices [i * 6 + 2] = i * 4 + 1;  	indices [i * 6 + 3] = i * 4 + 3;  	indices [i * 6 + 4] = i * 4 + 2;  	indices [i * 6 + 5] = i * 4 + 1;  }  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < text.Length; i++) {  	// grab the character' replacing with ' ' if the character isn't loaded  	Character ch = characters [characters.ContainsKey (text [i]) ? text [i] : ' '];  	vertices [i * 4 + 0] = new Vector3 (xpos' ch.height' 0);  	vertices [i * 4 + 1] = new Vector3 (xpos' 0' 0);  	vertices [i * 4 + 2] = new Vector3 (xpos + ch.width' ch.height' 0);  	vertices [i * 4 + 3] = new Vector3 (xpos + ch.width' 0' 0);  	xpos += (int)ch.width;  	uvs [i * 4 + 0] = new Vector2 (ch.x1' ch.y1);  	uvs [i * 4 + 1] = new Vector2 (ch.x1' ch.y2);  	uvs [i * 4 + 2] = new Vector2 (ch.x2' ch.y1);  	uvs [i * 4 + 3] = new Vector2 (ch.x2' ch.y2);  	indices [i * 6 + 0] = i * 4 + 2;  	indices [i * 6 + 1] = i * 4 + 0;  	indices [i * 6 + 2] = i * 4 + 1;  	indices [i * 6 + 3] = i * 4 + 3;  	indices [i * 6 + 4] = i * 4 + 2;  	indices [i * 6 + 5] = i * 4 + 1;  }  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < text.Length; i++) {  	// grab the character' replacing with ' ' if the character isn't loaded  	Character ch = characters [characters.ContainsKey (text [i]) ? text [i] : ' '];  	vertices [i * 4 + 0] = new Vector3 (xpos' ch.height' 0);  	vertices [i * 4 + 1] = new Vector3 (xpos' 0' 0);  	vertices [i * 4 + 2] = new Vector3 (xpos + ch.width' ch.height' 0);  	vertices [i * 4 + 3] = new Vector3 (xpos + ch.width' 0' 0);  	xpos += (int)ch.width;  	uvs [i * 4 + 0] = new Vector2 (ch.x1' ch.y1);  	uvs [i * 4 + 1] = new Vector2 (ch.x1' ch.y2);  	uvs [i * 4 + 2] = new Vector2 (ch.x2' ch.y1);  	uvs [i * 4 + 3] = new Vector2 (ch.x2' ch.y2);  	indices [i * 6 + 0] = i * 4 + 2;  	indices [i * 6 + 1] = i * 4 + 0;  	indices [i * 6 + 2] = i * 4 + 1;  	indices [i * 6 + 3] = i * 4 + 3;  	indices [i * 6 + 4] = i * 4 + 2;  	indices [i * 6 + 5] = i * 4 + 1;  }  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < text.Length; i++) {  	// grab the character' replacing with ' ' if the character isn't loaded  	Character ch = characters [characters.ContainsKey (text [i]) ? text [i] : ' '];  	vertices [i * 4 + 0] = new Vector3 (xpos' ch.height' 0);  	vertices [i * 4 + 1] = new Vector3 (xpos' 0' 0);  	vertices [i * 4 + 2] = new Vector3 (xpos + ch.width' ch.height' 0);  	vertices [i * 4 + 3] = new Vector3 (xpos + ch.width' 0' 0);  	xpos += (int)ch.width;  	uvs [i * 4 + 0] = new Vector2 (ch.x1' ch.y1);  	uvs [i * 4 + 1] = new Vector2 (ch.x1' ch.y2);  	uvs [i * 4 + 2] = new Vector2 (ch.x2' ch.y1);  	uvs [i * 4 + 3] = new Vector2 (ch.x2' ch.y2);  	indices [i * 6 + 0] = i * 4 + 2;  	indices [i * 6 + 1] = i * 4 + 0;  	indices [i * 6 + 2] = i * 4 + 1;  	indices [i * 6 + 3] = i * 4 + 3;  	indices [i * 6 + 4] = i * 4 + 2;  	indices [i * 6 + 5] = i * 4 + 1;  }  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < text.Length; i++) {  	// grab the character' replacing with ' ' if the character isn't loaded  	Character ch = characters [characters.ContainsKey (text [i]) ? text [i] : ' '];  	vertices [i * 4 + 0] = new Vector3 (xpos' ch.height' 0);  	vertices [i * 4 + 1] = new Vector3 (xpos' 0' 0);  	vertices [i * 4 + 2] = new Vector3 (xpos + ch.width' ch.height' 0);  	vertices [i * 4 + 3] = new Vector3 (xpos + ch.width' 0' 0);  	xpos += (int)ch.width;  	uvs [i * 4 + 0] = new Vector2 (ch.x1' ch.y1);  	uvs [i * 4 + 1] = new Vector2 (ch.x1' ch.y2);  	uvs [i * 4 + 2] = new Vector2 (ch.x2' ch.y1);  	uvs [i * 4 + 3] = new Vector2 (ch.x2' ch.y2);  	indices [i * 6 + 0] = i * 4 + 2;  	indices [i * 6 + 1] = i * 4 + 0;  	indices [i * 6 + 2] = i * 4 + 1;  	indices [i * 6 + 3] = i * 4 + 3;  	indices [i * 6 + 4] = i * 4 + 2;  	indices [i * 6 + 5] = i * 4 + 1;  }  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < text.Length; i++) {  	// grab the character' replacing with ' ' if the character isn't loaded  	Character ch = characters [characters.ContainsKey (text [i]) ? text [i] : ' '];  	vertices [i * 4 + 0] = new Vector3 (xpos' ch.height' 0);  	vertices [i * 4 + 1] = new Vector3 (xpos' 0' 0);  	vertices [i * 4 + 2] = new Vector3 (xpos + ch.width' ch.height' 0);  	vertices [i * 4 + 3] = new Vector3 (xpos + ch.width' 0' 0);  	xpos += (int)ch.width;  	uvs [i * 4 + 0] = new Vector2 (ch.x1' ch.y1);  	uvs [i * 4 + 1] = new Vector2 (ch.x1' ch.y2);  	uvs [i * 4 + 2] = new Vector2 (ch.x2' ch.y1);  	uvs [i * 4 + 3] = new Vector2 (ch.x2' ch.y2);  	indices [i * 6 + 0] = i * 4 + 2;  	indices [i * 6 + 1] = i * 4 + 0;  	indices [i * 6 + 2] = i * 4 + 1;  	indices [i * 6 + 3] = i * 4 + 3;  	indices [i * 6 + 4] = i * 4 + 2;  	indices [i * 6 + 5] = i * 4 + 1;  }  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < text.Length; i++) {  	// grab the character' replacing with ' ' if the character isn't loaded  	Character ch = characters [characters.ContainsKey (text [i]) ? text [i] : ' '];  	vertices [i * 4 + 0] = new Vector3 (xpos' ch.height' 0);  	vertices [i * 4 + 1] = new Vector3 (xpos' 0' 0);  	vertices [i * 4 + 2] = new Vector3 (xpos + ch.width' ch.height' 0);  	vertices [i * 4 + 3] = new Vector3 (xpos + ch.width' 0' 0);  	xpos += (int)ch.width;  	uvs [i * 4 + 0] = new Vector2 (ch.x1' ch.y1);  	uvs [i * 4 + 1] = new Vector2 (ch.x1' ch.y2);  	uvs [i * 4 + 2] = new Vector2 (ch.x2' ch.y1);  	uvs [i * 4 + 3] = new Vector2 (ch.x2' ch.y2);  	indices [i * 6 + 0] = i * 4 + 2;  	indices [i * 6 + 1] = i * 4 + 0;  	indices [i * 6 + 2] = i * 4 + 1;  	indices [i * 6 + 3] = i * 4 + 3;  	indices [i * 6 + 4] = i * 4 + 2;  	indices [i * 6 + 5] = i * 4 + 1;  }  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: for (int i = 0; i < text.Length; i++) {  	// grab the character' replacing with ' ' if the character isn't loaded  	Character ch = characters [characters.ContainsKey (text [i]) ? text [i] : ' '];  	vertices [i * 4 + 0] = new Vector3 (xpos' ch.height' 0);  	vertices [i * 4 + 1] = new Vector3 (xpos' 0' 0);  	vertices [i * 4 + 2] = new Vector3 (xpos + ch.width' ch.height' 0);  	vertices [i * 4 + 3] = new Vector3 (xpos + ch.width' 0' 0);  	xpos += (int)ch.width;  	uvs [i * 4 + 0] = new Vector2 (ch.x1' ch.y1);  	uvs [i * 4 + 1] = new Vector2 (ch.x1' ch.y2);  	uvs [i * 4 + 2] = new Vector2 (ch.x2' ch.y1);  	uvs [i * 4 + 3] = new Vector2 (ch.x2' ch.y2);  	indices [i * 6 + 0] = i * 4 + 2;  	indices [i * 6 + 1] = i * 4 + 0;  	indices [i * 6 + 2] = i * 4 + 1;  	indices [i * 6 + 3] = i * 4 + 3;  	indices [i * 6 + 4] = i * 4 + 2;  	indices [i * 6 + 5] = i * 4 + 1;  }  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: vertices [i * 4 + 0] = new Vector3 (xpos' ch.height' 0);  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: vertices [i * 4 + 1] = new Vector3 (xpos' 0' 0);  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: vertices [i * 4 + 2] = new Vector3 (xpos + ch.width' ch.height' 0);  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: vertices [i * 4 + 2] = new Vector3 (xpos + ch.width' ch.height' 0);  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: vertices [i * 4 + 3] = new Vector3 (xpos + ch.width' 0' 0);  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: vertices [i * 4 + 3] = new Vector3 (xpos + ch.width' 0' 0);  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: uvs [i * 4 + 0] = new Vector2 (ch.x1' ch.y1);  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: uvs [i * 4 + 1] = new Vector2 (ch.x1' ch.y2);  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: uvs [i * 4 + 2] = new Vector2 (ch.x2' ch.y1);  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: uvs [i * 4 + 2] = new Vector2 (ch.x2' ch.y1);  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: uvs [i * 4 + 3] = new Vector2 (ch.x2' ch.y2);  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: uvs [i * 4 + 3] = new Vector2 (ch.x2' ch.y2);  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: indices [i * 6 + 0] = i * 4 + 2;  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: indices [i * 6 + 0] = i * 4 + 2;  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: indices [i * 6 + 0] = i * 4 + 2;  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: indices [i * 6 + 1] = i * 4 + 0;  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: indices [i * 6 + 1] = i * 4 + 0;  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: indices [i * 6 + 2] = i * 4 + 1;  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: indices [i * 6 + 2] = i * 4 + 1;  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: indices [i * 6 + 2] = i * 4 + 1;  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: indices [i * 6 + 3] = i * 4 + 3;  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: indices [i * 6 + 3] = i * 4 + 3;  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: indices [i * 6 + 3] = i * 4 + 3;  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: indices [i * 6 + 3] = i * 4 + 3;  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: indices [i * 6 + 4] = i * 4 + 2;  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: indices [i * 6 + 4] = i * 4 + 2;  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: indices [i * 6 + 4] = i * 4 + 2;  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: indices [i * 6 + 4] = i * 4 + 2;  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: indices [i * 6 + 5] = i * 4 + 1;  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: indices [i * 6 + 5] = i * 4 + 1;  
Magic Number,OpenGLTutorial16,BMFont,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Font.cs,CreateString,The following statement contains a magic number: indices [i * 6 + 5] = i * 4 + 1;  
Magic Number,OpenGLTutorial16,ObjMaterial,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjMaterial,The following statement contains a magic number: this.Name = lines [0].Substring (7);  
Magic Number,OpenGLTutorial16,ObjMaterial,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjMaterial,The following statement contains a magic number: for (int i = 1; i < lines.Count; i++) {  	string[] split = lines [i].Split (new char[] {  		' '  	}' StringSplitOptions.RemoveEmptyEntries);  	// Some object exporters export the material with a tab character in front' so I am removing it  	if (split [0].Contains ("\t")) {  		split [0] = split [0].Replace ("\t"' string.Empty);  	}  	switch (split [0]) {  	case "Ns":  		this.SpecularCoefficient = float.Parse (split [1]);  		break;  	case "Ka":  		this.Ambient = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  		break;  	case "Kd":  		this.Diffuse = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  		break;  	case "Ks":  		this.Specular = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  		break;  	case "d":  		this.Transparency = float.Parse (split [1]);  		break;  	case "illum":  		this.Illumination = (IlluminationMode)int.Parse (split [1]);  		break;  	case "map_Kd":  		if (File.Exists (lines [i].Split (new char[] {  			' '  		}' 2) [1]))  			this.DiffuseMap = new Texture (lines [i].Split (new char[] {  				' '  			}' 2) [1]);  		break;  	}  }  
Magic Number,OpenGLTutorial16,ObjMaterial,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjMaterial,The following statement contains a magic number: for (int i = 1; i < lines.Count; i++) {  	string[] split = lines [i].Split (new char[] {  		' '  	}' StringSplitOptions.RemoveEmptyEntries);  	// Some object exporters export the material with a tab character in front' so I am removing it  	if (split [0].Contains ("\t")) {  		split [0] = split [0].Replace ("\t"' string.Empty);  	}  	switch (split [0]) {  	case "Ns":  		this.SpecularCoefficient = float.Parse (split [1]);  		break;  	case "Ka":  		this.Ambient = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  		break;  	case "Kd":  		this.Diffuse = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  		break;  	case "Ks":  		this.Specular = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  		break;  	case "d":  		this.Transparency = float.Parse (split [1]);  		break;  	case "illum":  		this.Illumination = (IlluminationMode)int.Parse (split [1]);  		break;  	case "map_Kd":  		if (File.Exists (lines [i].Split (new char[] {  			' '  		}' 2) [1]))  			this.DiffuseMap = new Texture (lines [i].Split (new char[] {  				' '  			}' 2) [1]);  		break;  	}  }  
Magic Number,OpenGLTutorial16,ObjMaterial,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjMaterial,The following statement contains a magic number: for (int i = 1; i < lines.Count; i++) {  	string[] split = lines [i].Split (new char[] {  		' '  	}' StringSplitOptions.RemoveEmptyEntries);  	// Some object exporters export the material with a tab character in front' so I am removing it  	if (split [0].Contains ("\t")) {  		split [0] = split [0].Replace ("\t"' string.Empty);  	}  	switch (split [0]) {  	case "Ns":  		this.SpecularCoefficient = float.Parse (split [1]);  		break;  	case "Ka":  		this.Ambient = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  		break;  	case "Kd":  		this.Diffuse = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  		break;  	case "Ks":  		this.Specular = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  		break;  	case "d":  		this.Transparency = float.Parse (split [1]);  		break;  	case "illum":  		this.Illumination = (IlluminationMode)int.Parse (split [1]);  		break;  	case "map_Kd":  		if (File.Exists (lines [i].Split (new char[] {  			' '  		}' 2) [1]))  			this.DiffuseMap = new Texture (lines [i].Split (new char[] {  				' '  			}' 2) [1]);  		break;  	}  }  
Magic Number,OpenGLTutorial16,ObjMaterial,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjMaterial,The following statement contains a magic number: for (int i = 1; i < lines.Count; i++) {  	string[] split = lines [i].Split (new char[] {  		' '  	}' StringSplitOptions.RemoveEmptyEntries);  	// Some object exporters export the material with a tab character in front' so I am removing it  	if (split [0].Contains ("\t")) {  		split [0] = split [0].Replace ("\t"' string.Empty);  	}  	switch (split [0]) {  	case "Ns":  		this.SpecularCoefficient = float.Parse (split [1]);  		break;  	case "Ka":  		this.Ambient = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  		break;  	case "Kd":  		this.Diffuse = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  		break;  	case "Ks":  		this.Specular = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  		break;  	case "d":  		this.Transparency = float.Parse (split [1]);  		break;  	case "illum":  		this.Illumination = (IlluminationMode)int.Parse (split [1]);  		break;  	case "map_Kd":  		if (File.Exists (lines [i].Split (new char[] {  			' '  		}' 2) [1]))  			this.DiffuseMap = new Texture (lines [i].Split (new char[] {  				' '  			}' 2) [1]);  		break;  	}  }  
Magic Number,OpenGLTutorial16,ObjMaterial,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjMaterial,The following statement contains a magic number: for (int i = 1; i < lines.Count; i++) {  	string[] split = lines [i].Split (new char[] {  		' '  	}' StringSplitOptions.RemoveEmptyEntries);  	// Some object exporters export the material with a tab character in front' so I am removing it  	if (split [0].Contains ("\t")) {  		split [0] = split [0].Replace ("\t"' string.Empty);  	}  	switch (split [0]) {  	case "Ns":  		this.SpecularCoefficient = float.Parse (split [1]);  		break;  	case "Ka":  		this.Ambient = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  		break;  	case "Kd":  		this.Diffuse = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  		break;  	case "Ks":  		this.Specular = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  		break;  	case "d":  		this.Transparency = float.Parse (split [1]);  		break;  	case "illum":  		this.Illumination = (IlluminationMode)int.Parse (split [1]);  		break;  	case "map_Kd":  		if (File.Exists (lines [i].Split (new char[] {  			' '  		}' 2) [1]))  			this.DiffuseMap = new Texture (lines [i].Split (new char[] {  				' '  			}' 2) [1]);  		break;  	}  }  
Magic Number,OpenGLTutorial16,ObjMaterial,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjMaterial,The following statement contains a magic number: for (int i = 1; i < lines.Count; i++) {  	string[] split = lines [i].Split (new char[] {  		' '  	}' StringSplitOptions.RemoveEmptyEntries);  	// Some object exporters export the material with a tab character in front' so I am removing it  	if (split [0].Contains ("\t")) {  		split [0] = split [0].Replace ("\t"' string.Empty);  	}  	switch (split [0]) {  	case "Ns":  		this.SpecularCoefficient = float.Parse (split [1]);  		break;  	case "Ka":  		this.Ambient = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  		break;  	case "Kd":  		this.Diffuse = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  		break;  	case "Ks":  		this.Specular = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  		break;  	case "d":  		this.Transparency = float.Parse (split [1]);  		break;  	case "illum":  		this.Illumination = (IlluminationMode)int.Parse (split [1]);  		break;  	case "map_Kd":  		if (File.Exists (lines [i].Split (new char[] {  			' '  		}' 2) [1]))  			this.DiffuseMap = new Texture (lines [i].Split (new char[] {  				' '  			}' 2) [1]);  		break;  	}  }  
Magic Number,OpenGLTutorial16,ObjMaterial,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjMaterial,The following statement contains a magic number: for (int i = 1; i < lines.Count; i++) {  	string[] split = lines [i].Split (new char[] {  		' '  	}' StringSplitOptions.RemoveEmptyEntries);  	// Some object exporters export the material with a tab character in front' so I am removing it  	if (split [0].Contains ("\t")) {  		split [0] = split [0].Replace ("\t"' string.Empty);  	}  	switch (split [0]) {  	case "Ns":  		this.SpecularCoefficient = float.Parse (split [1]);  		break;  	case "Ka":  		this.Ambient = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  		break;  	case "Kd":  		this.Diffuse = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  		break;  	case "Ks":  		this.Specular = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  		break;  	case "d":  		this.Transparency = float.Parse (split [1]);  		break;  	case "illum":  		this.Illumination = (IlluminationMode)int.Parse (split [1]);  		break;  	case "map_Kd":  		if (File.Exists (lines [i].Split (new char[] {  			' '  		}' 2) [1]))  			this.DiffuseMap = new Texture (lines [i].Split (new char[] {  				' '  			}' 2) [1]);  		break;  	}  }  
Magic Number,OpenGLTutorial16,ObjMaterial,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjMaterial,The following statement contains a magic number: for (int i = 1; i < lines.Count; i++) {  	string[] split = lines [i].Split (new char[] {  		' '  	}' StringSplitOptions.RemoveEmptyEntries);  	// Some object exporters export the material with a tab character in front' so I am removing it  	if (split [0].Contains ("\t")) {  		split [0] = split [0].Replace ("\t"' string.Empty);  	}  	switch (split [0]) {  	case "Ns":  		this.SpecularCoefficient = float.Parse (split [1]);  		break;  	case "Ka":  		this.Ambient = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  		break;  	case "Kd":  		this.Diffuse = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  		break;  	case "Ks":  		this.Specular = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  		break;  	case "d":  		this.Transparency = float.Parse (split [1]);  		break;  	case "illum":  		this.Illumination = (IlluminationMode)int.Parse (split [1]);  		break;  	case "map_Kd":  		if (File.Exists (lines [i].Split (new char[] {  			' '  		}' 2) [1]))  			this.DiffuseMap = new Texture (lines [i].Split (new char[] {  				' '  			}' 2) [1]);  		break;  	}  }  
Magic Number,OpenGLTutorial16,ObjMaterial,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjMaterial,The following statement contains a magic number: switch (split [0]) {  case "Ns":  	this.SpecularCoefficient = float.Parse (split [1]);  	break;  case "Ka":  	this.Ambient = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  	break;  case "Kd":  	this.Diffuse = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  	break;  case "Ks":  	this.Specular = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  	break;  case "d":  	this.Transparency = float.Parse (split [1]);  	break;  case "illum":  	this.Illumination = (IlluminationMode)int.Parse (split [1]);  	break;  case "map_Kd":  	if (File.Exists (lines [i].Split (new char[] {  		' '  	}' 2) [1]))  		this.DiffuseMap = new Texture (lines [i].Split (new char[] {  			' '  		}' 2) [1]);  	break;  }  
Magic Number,OpenGLTutorial16,ObjMaterial,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjMaterial,The following statement contains a magic number: switch (split [0]) {  case "Ns":  	this.SpecularCoefficient = float.Parse (split [1]);  	break;  case "Ka":  	this.Ambient = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  	break;  case "Kd":  	this.Diffuse = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  	break;  case "Ks":  	this.Specular = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  	break;  case "d":  	this.Transparency = float.Parse (split [1]);  	break;  case "illum":  	this.Illumination = (IlluminationMode)int.Parse (split [1]);  	break;  case "map_Kd":  	if (File.Exists (lines [i].Split (new char[] {  		' '  	}' 2) [1]))  		this.DiffuseMap = new Texture (lines [i].Split (new char[] {  			' '  		}' 2) [1]);  	break;  }  
Magic Number,OpenGLTutorial16,ObjMaterial,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjMaterial,The following statement contains a magic number: switch (split [0]) {  case "Ns":  	this.SpecularCoefficient = float.Parse (split [1]);  	break;  case "Ka":  	this.Ambient = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  	break;  case "Kd":  	this.Diffuse = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  	break;  case "Ks":  	this.Specular = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  	break;  case "d":  	this.Transparency = float.Parse (split [1]);  	break;  case "illum":  	this.Illumination = (IlluminationMode)int.Parse (split [1]);  	break;  case "map_Kd":  	if (File.Exists (lines [i].Split (new char[] {  		' '  	}' 2) [1]))  		this.DiffuseMap = new Texture (lines [i].Split (new char[] {  			' '  		}' 2) [1]);  	break;  }  
Magic Number,OpenGLTutorial16,ObjMaterial,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjMaterial,The following statement contains a magic number: switch (split [0]) {  case "Ns":  	this.SpecularCoefficient = float.Parse (split [1]);  	break;  case "Ka":  	this.Ambient = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  	break;  case "Kd":  	this.Diffuse = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  	break;  case "Ks":  	this.Specular = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  	break;  case "d":  	this.Transparency = float.Parse (split [1]);  	break;  case "illum":  	this.Illumination = (IlluminationMode)int.Parse (split [1]);  	break;  case "map_Kd":  	if (File.Exists (lines [i].Split (new char[] {  		' '  	}' 2) [1]))  		this.DiffuseMap = new Texture (lines [i].Split (new char[] {  			' '  		}' 2) [1]);  	break;  }  
Magic Number,OpenGLTutorial16,ObjMaterial,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjMaterial,The following statement contains a magic number: switch (split [0]) {  case "Ns":  	this.SpecularCoefficient = float.Parse (split [1]);  	break;  case "Ka":  	this.Ambient = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  	break;  case "Kd":  	this.Diffuse = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  	break;  case "Ks":  	this.Specular = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  	break;  case "d":  	this.Transparency = float.Parse (split [1]);  	break;  case "illum":  	this.Illumination = (IlluminationMode)int.Parse (split [1]);  	break;  case "map_Kd":  	if (File.Exists (lines [i].Split (new char[] {  		' '  	}' 2) [1]))  		this.DiffuseMap = new Texture (lines [i].Split (new char[] {  			' '  		}' 2) [1]);  	break;  }  
Magic Number,OpenGLTutorial16,ObjMaterial,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjMaterial,The following statement contains a magic number: switch (split [0]) {  case "Ns":  	this.SpecularCoefficient = float.Parse (split [1]);  	break;  case "Ka":  	this.Ambient = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  	break;  case "Kd":  	this.Diffuse = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  	break;  case "Ks":  	this.Specular = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  	break;  case "d":  	this.Transparency = float.Parse (split [1]);  	break;  case "illum":  	this.Illumination = (IlluminationMode)int.Parse (split [1]);  	break;  case "map_Kd":  	if (File.Exists (lines [i].Split (new char[] {  		' '  	}' 2) [1]))  		this.DiffuseMap = new Texture (lines [i].Split (new char[] {  			' '  		}' 2) [1]);  	break;  }  
Magic Number,OpenGLTutorial16,ObjMaterial,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjMaterial,The following statement contains a magic number: switch (split [0]) {  case "Ns":  	this.SpecularCoefficient = float.Parse (split [1]);  	break;  case "Ka":  	this.Ambient = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  	break;  case "Kd":  	this.Diffuse = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  	break;  case "Ks":  	this.Specular = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  	break;  case "d":  	this.Transparency = float.Parse (split [1]);  	break;  case "illum":  	this.Illumination = (IlluminationMode)int.Parse (split [1]);  	break;  case "map_Kd":  	if (File.Exists (lines [i].Split (new char[] {  		' '  	}' 2) [1]))  		this.DiffuseMap = new Texture (lines [i].Split (new char[] {  			' '  		}' 2) [1]);  	break;  }  
Magic Number,OpenGLTutorial16,ObjMaterial,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjMaterial,The following statement contains a magic number: switch (split [0]) {  case "Ns":  	this.SpecularCoefficient = float.Parse (split [1]);  	break;  case "Ka":  	this.Ambient = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  	break;  case "Kd":  	this.Diffuse = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  	break;  case "Ks":  	this.Specular = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  	break;  case "d":  	this.Transparency = float.Parse (split [1]);  	break;  case "illum":  	this.Illumination = (IlluminationMode)int.Parse (split [1]);  	break;  case "map_Kd":  	if (File.Exists (lines [i].Split (new char[] {  		' '  	}' 2) [1]))  		this.DiffuseMap = new Texture (lines [i].Split (new char[] {  			' '  		}' 2) [1]);  	break;  }  
Magic Number,OpenGLTutorial16,ObjMaterial,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjMaterial,The following statement contains a magic number: this.Ambient = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  
Magic Number,OpenGLTutorial16,ObjMaterial,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjMaterial,The following statement contains a magic number: this.Ambient = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  
Magic Number,OpenGLTutorial16,ObjMaterial,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjMaterial,The following statement contains a magic number: this.Diffuse = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  
Magic Number,OpenGLTutorial16,ObjMaterial,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjMaterial,The following statement contains a magic number: this.Diffuse = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  
Magic Number,OpenGLTutorial16,ObjMaterial,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjMaterial,The following statement contains a magic number: this.Specular = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  
Magic Number,OpenGLTutorial16,ObjMaterial,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjMaterial,The following statement contains a magic number: this.Specular = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  
Magic Number,OpenGLTutorial16,ObjMaterial,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjMaterial,The following statement contains a magic number: if (File.Exists (lines [i].Split (new char[] {  	' '  }' 2) [1]))  	this.DiffuseMap = new Texture (lines [i].Split (new char[] {  		' '  	}' 2) [1]);  
Magic Number,OpenGLTutorial16,ObjMaterial,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjMaterial,The following statement contains a magic number: if (File.Exists (lines [i].Split (new char[] {  	' '  }' 2) [1]))  	this.DiffuseMap = new Texture (lines [i].Split (new char[] {  		' '  	}' 2) [1]);  
Magic Number,OpenGLTutorial16,ObjMaterial,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjMaterial,The following statement contains a magic number: this.DiffuseMap = new Texture (lines [i].Split (new char[] {  	' '  }' 2) [1]);  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjObject,The following statement contains a magic number: for (int i = 0; i < lines.Count; i++) {  	string[] split = lines [i].Split (new char[] {  		' '  	}' StringSplitOptions.RemoveEmptyEntries);  	switch (split [0]) {  	case "o":  	case "g":  		this.Name = lines [i].Substring (2);  		break;  	case "v":  		vertexList.Add (new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3])));  		break;  	case "vt":  		uvList.Add (new Vector2 (float.Parse (split [1])' float.Parse (split [2])));  		break;  	case "f":  		if (split.Length == 5)// this is a quad' so split it up  		 {  			string[] split1 = new string[] {  				split [0]'  				split [1]'  				split [2]'  				split [3]  			};  			UnpackFace (split1' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  			string[] split2 = new string[] {  				split [0]'  				split [1]'  				split [3]'  				split [4]  			};  			UnpackFace (split2' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  		} else  			UnpackFace (split' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  		break;  	case "usemtl":  		if (materials.ContainsKey (split [1]))  			Material = materials [split [1]];  		break;  	}  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjObject,The following statement contains a magic number: for (int i = 0; i < lines.Count; i++) {  	string[] split = lines [i].Split (new char[] {  		' '  	}' StringSplitOptions.RemoveEmptyEntries);  	switch (split [0]) {  	case "o":  	case "g":  		this.Name = lines [i].Substring (2);  		break;  	case "v":  		vertexList.Add (new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3])));  		break;  	case "vt":  		uvList.Add (new Vector2 (float.Parse (split [1])' float.Parse (split [2])));  		break;  	case "f":  		if (split.Length == 5)// this is a quad' so split it up  		 {  			string[] split1 = new string[] {  				split [0]'  				split [1]'  				split [2]'  				split [3]  			};  			UnpackFace (split1' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  			string[] split2 = new string[] {  				split [0]'  				split [1]'  				split [3]'  				split [4]  			};  			UnpackFace (split2' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  		} else  			UnpackFace (split' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  		break;  	case "usemtl":  		if (materials.ContainsKey (split [1]))  			Material = materials [split [1]];  		break;  	}  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjObject,The following statement contains a magic number: for (int i = 0; i < lines.Count; i++) {  	string[] split = lines [i].Split (new char[] {  		' '  	}' StringSplitOptions.RemoveEmptyEntries);  	switch (split [0]) {  	case "o":  	case "g":  		this.Name = lines [i].Substring (2);  		break;  	case "v":  		vertexList.Add (new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3])));  		break;  	case "vt":  		uvList.Add (new Vector2 (float.Parse (split [1])' float.Parse (split [2])));  		break;  	case "f":  		if (split.Length == 5)// this is a quad' so split it up  		 {  			string[] split1 = new string[] {  				split [0]'  				split [1]'  				split [2]'  				split [3]  			};  			UnpackFace (split1' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  			string[] split2 = new string[] {  				split [0]'  				split [1]'  				split [3]'  				split [4]  			};  			UnpackFace (split2' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  		} else  			UnpackFace (split' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  		break;  	case "usemtl":  		if (materials.ContainsKey (split [1]))  			Material = materials [split [1]];  		break;  	}  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjObject,The following statement contains a magic number: for (int i = 0; i < lines.Count; i++) {  	string[] split = lines [i].Split (new char[] {  		' '  	}' StringSplitOptions.RemoveEmptyEntries);  	switch (split [0]) {  	case "o":  	case "g":  		this.Name = lines [i].Substring (2);  		break;  	case "v":  		vertexList.Add (new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3])));  		break;  	case "vt":  		uvList.Add (new Vector2 (float.Parse (split [1])' float.Parse (split [2])));  		break;  	case "f":  		if (split.Length == 5)// this is a quad' so split it up  		 {  			string[] split1 = new string[] {  				split [0]'  				split [1]'  				split [2]'  				split [3]  			};  			UnpackFace (split1' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  			string[] split2 = new string[] {  				split [0]'  				split [1]'  				split [3]'  				split [4]  			};  			UnpackFace (split2' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  		} else  			UnpackFace (split' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  		break;  	case "usemtl":  		if (materials.ContainsKey (split [1]))  			Material = materials [split [1]];  		break;  	}  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjObject,The following statement contains a magic number: for (int i = 0; i < lines.Count; i++) {  	string[] split = lines [i].Split (new char[] {  		' '  	}' StringSplitOptions.RemoveEmptyEntries);  	switch (split [0]) {  	case "o":  	case "g":  		this.Name = lines [i].Substring (2);  		break;  	case "v":  		vertexList.Add (new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3])));  		break;  	case "vt":  		uvList.Add (new Vector2 (float.Parse (split [1])' float.Parse (split [2])));  		break;  	case "f":  		if (split.Length == 5)// this is a quad' so split it up  		 {  			string[] split1 = new string[] {  				split [0]'  				split [1]'  				split [2]'  				split [3]  			};  			UnpackFace (split1' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  			string[] split2 = new string[] {  				split [0]'  				split [1]'  				split [3]'  				split [4]  			};  			UnpackFace (split2' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  		} else  			UnpackFace (split' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  		break;  	case "usemtl":  		if (materials.ContainsKey (split [1]))  			Material = materials [split [1]];  		break;  	}  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjObject,The following statement contains a magic number: for (int i = 0; i < lines.Count; i++) {  	string[] split = lines [i].Split (new char[] {  		' '  	}' StringSplitOptions.RemoveEmptyEntries);  	switch (split [0]) {  	case "o":  	case "g":  		this.Name = lines [i].Substring (2);  		break;  	case "v":  		vertexList.Add (new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3])));  		break;  	case "vt":  		uvList.Add (new Vector2 (float.Parse (split [1])' float.Parse (split [2])));  		break;  	case "f":  		if (split.Length == 5)// this is a quad' so split it up  		 {  			string[] split1 = new string[] {  				split [0]'  				split [1]'  				split [2]'  				split [3]  			};  			UnpackFace (split1' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  			string[] split2 = new string[] {  				split [0]'  				split [1]'  				split [3]'  				split [4]  			};  			UnpackFace (split2' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  		} else  			UnpackFace (split' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  		break;  	case "usemtl":  		if (materials.ContainsKey (split [1]))  			Material = materials [split [1]];  		break;  	}  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjObject,The following statement contains a magic number: for (int i = 0; i < lines.Count; i++) {  	string[] split = lines [i].Split (new char[] {  		' '  	}' StringSplitOptions.RemoveEmptyEntries);  	switch (split [0]) {  	case "o":  	case "g":  		this.Name = lines [i].Substring (2);  		break;  	case "v":  		vertexList.Add (new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3])));  		break;  	case "vt":  		uvList.Add (new Vector2 (float.Parse (split [1])' float.Parse (split [2])));  		break;  	case "f":  		if (split.Length == 5)// this is a quad' so split it up  		 {  			string[] split1 = new string[] {  				split [0]'  				split [1]'  				split [2]'  				split [3]  			};  			UnpackFace (split1' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  			string[] split2 = new string[] {  				split [0]'  				split [1]'  				split [3]'  				split [4]  			};  			UnpackFace (split2' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  		} else  			UnpackFace (split' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  		break;  	case "usemtl":  		if (materials.ContainsKey (split [1]))  			Material = materials [split [1]];  		break;  	}  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjObject,The following statement contains a magic number: for (int i = 0; i < lines.Count; i++) {  	string[] split = lines [i].Split (new char[] {  		' '  	}' StringSplitOptions.RemoveEmptyEntries);  	switch (split [0]) {  	case "o":  	case "g":  		this.Name = lines [i].Substring (2);  		break;  	case "v":  		vertexList.Add (new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3])));  		break;  	case "vt":  		uvList.Add (new Vector2 (float.Parse (split [1])' float.Parse (split [2])));  		break;  	case "f":  		if (split.Length == 5)// this is a quad' so split it up  		 {  			string[] split1 = new string[] {  				split [0]'  				split [1]'  				split [2]'  				split [3]  			};  			UnpackFace (split1' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  			string[] split2 = new string[] {  				split [0]'  				split [1]'  				split [3]'  				split [4]  			};  			UnpackFace (split2' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  		} else  			UnpackFace (split' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  		break;  	case "usemtl":  		if (materials.ContainsKey (split [1]))  			Material = materials [split [1]];  		break;  	}  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjObject,The following statement contains a magic number: for (int i = 0; i < lines.Count; i++) {  	string[] split = lines [i].Split (new char[] {  		' '  	}' StringSplitOptions.RemoveEmptyEntries);  	switch (split [0]) {  	case "o":  	case "g":  		this.Name = lines [i].Substring (2);  		break;  	case "v":  		vertexList.Add (new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3])));  		break;  	case "vt":  		uvList.Add (new Vector2 (float.Parse (split [1])' float.Parse (split [2])));  		break;  	case "f":  		if (split.Length == 5)// this is a quad' so split it up  		 {  			string[] split1 = new string[] {  				split [0]'  				split [1]'  				split [2]'  				split [3]  			};  			UnpackFace (split1' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  			string[] split2 = new string[] {  				split [0]'  				split [1]'  				split [3]'  				split [4]  			};  			UnpackFace (split2' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  		} else  			UnpackFace (split' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  		break;  	case "usemtl":  		if (materials.ContainsKey (split [1]))  			Material = materials [split [1]];  		break;  	}  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjObject,The following statement contains a magic number: switch (split [0]) {  case "o":  case "g":  	this.Name = lines [i].Substring (2);  	break;  case "v":  	vertexList.Add (new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3])));  	break;  case "vt":  	uvList.Add (new Vector2 (float.Parse (split [1])' float.Parse (split [2])));  	break;  case "f":  	if (split.Length == 5)// this is a quad' so split it up  	 {  		string[] split1 = new string[] {  			split [0]'  			split [1]'  			split [2]'  			split [3]  		};  		UnpackFace (split1' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  		string[] split2 = new string[] {  			split [0]'  			split [1]'  			split [3]'  			split [4]  		};  		UnpackFace (split2' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  	} else  		UnpackFace (split' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  	break;  case "usemtl":  	if (materials.ContainsKey (split [1]))  		Material = materials [split [1]];  	break;  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjObject,The following statement contains a magic number: switch (split [0]) {  case "o":  case "g":  	this.Name = lines [i].Substring (2);  	break;  case "v":  	vertexList.Add (new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3])));  	break;  case "vt":  	uvList.Add (new Vector2 (float.Parse (split [1])' float.Parse (split [2])));  	break;  case "f":  	if (split.Length == 5)// this is a quad' so split it up  	 {  		string[] split1 = new string[] {  			split [0]'  			split [1]'  			split [2]'  			split [3]  		};  		UnpackFace (split1' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  		string[] split2 = new string[] {  			split [0]'  			split [1]'  			split [3]'  			split [4]  		};  		UnpackFace (split2' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  	} else  		UnpackFace (split' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  	break;  case "usemtl":  	if (materials.ContainsKey (split [1]))  		Material = materials [split [1]];  	break;  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjObject,The following statement contains a magic number: switch (split [0]) {  case "o":  case "g":  	this.Name = lines [i].Substring (2);  	break;  case "v":  	vertexList.Add (new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3])));  	break;  case "vt":  	uvList.Add (new Vector2 (float.Parse (split [1])' float.Parse (split [2])));  	break;  case "f":  	if (split.Length == 5)// this is a quad' so split it up  	 {  		string[] split1 = new string[] {  			split [0]'  			split [1]'  			split [2]'  			split [3]  		};  		UnpackFace (split1' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  		string[] split2 = new string[] {  			split [0]'  			split [1]'  			split [3]'  			split [4]  		};  		UnpackFace (split2' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  	} else  		UnpackFace (split' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  	break;  case "usemtl":  	if (materials.ContainsKey (split [1]))  		Material = materials [split [1]];  	break;  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjObject,The following statement contains a magic number: switch (split [0]) {  case "o":  case "g":  	this.Name = lines [i].Substring (2);  	break;  case "v":  	vertexList.Add (new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3])));  	break;  case "vt":  	uvList.Add (new Vector2 (float.Parse (split [1])' float.Parse (split [2])));  	break;  case "f":  	if (split.Length == 5)// this is a quad' so split it up  	 {  		string[] split1 = new string[] {  			split [0]'  			split [1]'  			split [2]'  			split [3]  		};  		UnpackFace (split1' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  		string[] split2 = new string[] {  			split [0]'  			split [1]'  			split [3]'  			split [4]  		};  		UnpackFace (split2' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  	} else  		UnpackFace (split' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  	break;  case "usemtl":  	if (materials.ContainsKey (split [1]))  		Material = materials [split [1]];  	break;  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjObject,The following statement contains a magic number: switch (split [0]) {  case "o":  case "g":  	this.Name = lines [i].Substring (2);  	break;  case "v":  	vertexList.Add (new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3])));  	break;  case "vt":  	uvList.Add (new Vector2 (float.Parse (split [1])' float.Parse (split [2])));  	break;  case "f":  	if (split.Length == 5)// this is a quad' so split it up  	 {  		string[] split1 = new string[] {  			split [0]'  			split [1]'  			split [2]'  			split [3]  		};  		UnpackFace (split1' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  		string[] split2 = new string[] {  			split [0]'  			split [1]'  			split [3]'  			split [4]  		};  		UnpackFace (split2' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  	} else  		UnpackFace (split' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  	break;  case "usemtl":  	if (materials.ContainsKey (split [1]))  		Material = materials [split [1]];  	break;  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjObject,The following statement contains a magic number: switch (split [0]) {  case "o":  case "g":  	this.Name = lines [i].Substring (2);  	break;  case "v":  	vertexList.Add (new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3])));  	break;  case "vt":  	uvList.Add (new Vector2 (float.Parse (split [1])' float.Parse (split [2])));  	break;  case "f":  	if (split.Length == 5)// this is a quad' so split it up  	 {  		string[] split1 = new string[] {  			split [0]'  			split [1]'  			split [2]'  			split [3]  		};  		UnpackFace (split1' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  		string[] split2 = new string[] {  			split [0]'  			split [1]'  			split [3]'  			split [4]  		};  		UnpackFace (split2' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  	} else  		UnpackFace (split' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  	break;  case "usemtl":  	if (materials.ContainsKey (split [1]))  		Material = materials [split [1]];  	break;  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjObject,The following statement contains a magic number: switch (split [0]) {  case "o":  case "g":  	this.Name = lines [i].Substring (2);  	break;  case "v":  	vertexList.Add (new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3])));  	break;  case "vt":  	uvList.Add (new Vector2 (float.Parse (split [1])' float.Parse (split [2])));  	break;  case "f":  	if (split.Length == 5)// this is a quad' so split it up  	 {  		string[] split1 = new string[] {  			split [0]'  			split [1]'  			split [2]'  			split [3]  		};  		UnpackFace (split1' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  		string[] split2 = new string[] {  			split [0]'  			split [1]'  			split [3]'  			split [4]  		};  		UnpackFace (split2' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  	} else  		UnpackFace (split' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  	break;  case "usemtl":  	if (materials.ContainsKey (split [1]))  		Material = materials [split [1]];  	break;  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjObject,The following statement contains a magic number: switch (split [0]) {  case "o":  case "g":  	this.Name = lines [i].Substring (2);  	break;  case "v":  	vertexList.Add (new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3])));  	break;  case "vt":  	uvList.Add (new Vector2 (float.Parse (split [1])' float.Parse (split [2])));  	break;  case "f":  	if (split.Length == 5)// this is a quad' so split it up  	 {  		string[] split1 = new string[] {  			split [0]'  			split [1]'  			split [2]'  			split [3]  		};  		UnpackFace (split1' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  		string[] split2 = new string[] {  			split [0]'  			split [1]'  			split [3]'  			split [4]  		};  		UnpackFace (split2' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  	} else  		UnpackFace (split' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  	break;  case "usemtl":  	if (materials.ContainsKey (split [1]))  		Material = materials [split [1]];  	break;  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjObject,The following statement contains a magic number: switch (split [0]) {  case "o":  case "g":  	this.Name = lines [i].Substring (2);  	break;  case "v":  	vertexList.Add (new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3])));  	break;  case "vt":  	uvList.Add (new Vector2 (float.Parse (split [1])' float.Parse (split [2])));  	break;  case "f":  	if (split.Length == 5)// this is a quad' so split it up  	 {  		string[] split1 = new string[] {  			split [0]'  			split [1]'  			split [2]'  			split [3]  		};  		UnpackFace (split1' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  		string[] split2 = new string[] {  			split [0]'  			split [1]'  			split [3]'  			split [4]  		};  		UnpackFace (split2' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  	} else  		UnpackFace (split' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  	break;  case "usemtl":  	if (materials.ContainsKey (split [1]))  		Material = materials [split [1]];  	break;  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjObject,The following statement contains a magic number: this.Name = lines [i].Substring (2);  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjObject,The following statement contains a magic number: vertexList.Add (new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3])));  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjObject,The following statement contains a magic number: vertexList.Add (new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3])));  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjObject,The following statement contains a magic number: uvList.Add (new Vector2 (float.Parse (split [1])' float.Parse (split [2])));  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjObject,The following statement contains a magic number: if (split.Length == 5)// this is a quad' so split it up   {  	string[] split1 = new string[] {  		split [0]'  		split [1]'  		split [2]'  		split [3]  	};  	UnpackFace (split1' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  	string[] split2 = new string[] {  		split [0]'  		split [1]'  		split [3]'  		split [4]  	};  	UnpackFace (split2' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  } else  	UnpackFace (split' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjObject,The following statement contains a magic number: if (split.Length == 5)// this is a quad' so split it up   {  	string[] split1 = new string[] {  		split [0]'  		split [1]'  		split [2]'  		split [3]  	};  	UnpackFace (split1' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  	string[] split2 = new string[] {  		split [0]'  		split [1]'  		split [3]'  		split [4]  	};  	UnpackFace (split2' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  } else  	UnpackFace (split' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjObject,The following statement contains a magic number: if (split.Length == 5)// this is a quad' so split it up   {  	string[] split1 = new string[] {  		split [0]'  		split [1]'  		split [2]'  		split [3]  	};  	UnpackFace (split1' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  	string[] split2 = new string[] {  		split [0]'  		split [1]'  		split [3]'  		split [4]  	};  	UnpackFace (split2' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  } else  	UnpackFace (split' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjObject,The following statement contains a magic number: if (split.Length == 5)// this is a quad' so split it up   {  	string[] split1 = new string[] {  		split [0]'  		split [1]'  		split [2]'  		split [3]  	};  	UnpackFace (split1' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  	string[] split2 = new string[] {  		split [0]'  		split [1]'  		split [3]'  		split [4]  	};  	UnpackFace (split2' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  } else  	UnpackFace (split' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjObject,The following statement contains a magic number: if (split.Length == 5)// this is a quad' so split it up   {  	string[] split1 = new string[] {  		split [0]'  		split [1]'  		split [2]'  		split [3]  	};  	UnpackFace (split1' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  	string[] split2 = new string[] {  		split [0]'  		split [1]'  		split [3]'  		split [4]  	};  	UnpackFace (split2' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  } else  	UnpackFace (split' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: if (split [1].Contains ("/")) {  	indices [0] = split [1].Substring (0' split [1].IndexOf ("/"));  	indices [1] = split [2].Substring (0' split [2].IndexOf ("/"));  	indices [2] = split [3].Substring (0' split [3].IndexOf ("/"));  	string[] uvs = new string[3];  	uvs [0] = split [1].Substring (split [1].IndexOf ("/") + 1);  	uvs [1] = split [2].Substring (split [2].IndexOf ("/") + 1);  	uvs [2] = split [3].Substring (split [3].IndexOf ("/") + 1);  	int[] triangle = new int[] {  		int.Parse (indices [0]) - vertexOffset'  		int.Parse (indices [1]) - vertexOffset'  		int.Parse (indices [2]) - vertexOffset  	};  	if (unpackedUvs.Count == 0)  		for (int j = 0; j < vertexList.Count; j++)  			unpackedUvs.Add (Vector2.Zero);  	if (uvs [0].Contains ("/")) {  		for (int i = 0; i < uvs.Length; i++)  			uvs [i] = uvs [i].Substring (0' uvs [i].IndexOf ("/"));  	} else {  		normalsList.Add (triangle [0]);  		normalsList.Add (triangle [1]);  		normalsList.Add (triangle [2]);  	}  	if (unpackedUvs [triangle [0]] == Vector2.Zero)  		unpackedUvs [triangle [0]] = uvList [int.Parse (uvs [0]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [0]) - uvOffset]);  		vertexList.Add (vertexList [triangle [0]]);  		triangle [0] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [1]] == Vector2.Zero)  		unpackedUvs [triangle [1]] = uvList [int.Parse (uvs [1]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [1]) - uvOffset]);  		vertexList.Add (vertexList [triangle [1]]);  		triangle [1] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [2]] == Vector2.Zero)  		unpackedUvs [triangle [2]] = uvList [int.Parse (uvs [2]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [2]) - uvOffset]);  		vertexList.Add (vertexList [triangle [2]]);  		triangle [2] = unpackedUvs.Count - 1;  	}  	triangleList.Add (triangle [0]);  	triangleList.Add (triangle [1]);  	triangleList.Add (triangle [2]);  } else {  	triangleList.Add (int.Parse (indices [0]) - vertexOffset);  	triangleList.Add (int.Parse (indices [1]) - vertexOffset);  	triangleList.Add (int.Parse (indices [2]) - vertexOffset);  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: if (split [1].Contains ("/")) {  	indices [0] = split [1].Substring (0' split [1].IndexOf ("/"));  	indices [1] = split [2].Substring (0' split [2].IndexOf ("/"));  	indices [2] = split [3].Substring (0' split [3].IndexOf ("/"));  	string[] uvs = new string[3];  	uvs [0] = split [1].Substring (split [1].IndexOf ("/") + 1);  	uvs [1] = split [2].Substring (split [2].IndexOf ("/") + 1);  	uvs [2] = split [3].Substring (split [3].IndexOf ("/") + 1);  	int[] triangle = new int[] {  		int.Parse (indices [0]) - vertexOffset'  		int.Parse (indices [1]) - vertexOffset'  		int.Parse (indices [2]) - vertexOffset  	};  	if (unpackedUvs.Count == 0)  		for (int j = 0; j < vertexList.Count; j++)  			unpackedUvs.Add (Vector2.Zero);  	if (uvs [0].Contains ("/")) {  		for (int i = 0; i < uvs.Length; i++)  			uvs [i] = uvs [i].Substring (0' uvs [i].IndexOf ("/"));  	} else {  		normalsList.Add (triangle [0]);  		normalsList.Add (triangle [1]);  		normalsList.Add (triangle [2]);  	}  	if (unpackedUvs [triangle [0]] == Vector2.Zero)  		unpackedUvs [triangle [0]] = uvList [int.Parse (uvs [0]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [0]) - uvOffset]);  		vertexList.Add (vertexList [triangle [0]]);  		triangle [0] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [1]] == Vector2.Zero)  		unpackedUvs [triangle [1]] = uvList [int.Parse (uvs [1]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [1]) - uvOffset]);  		vertexList.Add (vertexList [triangle [1]]);  		triangle [1] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [2]] == Vector2.Zero)  		unpackedUvs [triangle [2]] = uvList [int.Parse (uvs [2]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [2]) - uvOffset]);  		vertexList.Add (vertexList [triangle [2]]);  		triangle [2] = unpackedUvs.Count - 1;  	}  	triangleList.Add (triangle [0]);  	triangleList.Add (triangle [1]);  	triangleList.Add (triangle [2]);  } else {  	triangleList.Add (int.Parse (indices [0]) - vertexOffset);  	triangleList.Add (int.Parse (indices [1]) - vertexOffset);  	triangleList.Add (int.Parse (indices [2]) - vertexOffset);  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: if (split [1].Contains ("/")) {  	indices [0] = split [1].Substring (0' split [1].IndexOf ("/"));  	indices [1] = split [2].Substring (0' split [2].IndexOf ("/"));  	indices [2] = split [3].Substring (0' split [3].IndexOf ("/"));  	string[] uvs = new string[3];  	uvs [0] = split [1].Substring (split [1].IndexOf ("/") + 1);  	uvs [1] = split [2].Substring (split [2].IndexOf ("/") + 1);  	uvs [2] = split [3].Substring (split [3].IndexOf ("/") + 1);  	int[] triangle = new int[] {  		int.Parse (indices [0]) - vertexOffset'  		int.Parse (indices [1]) - vertexOffset'  		int.Parse (indices [2]) - vertexOffset  	};  	if (unpackedUvs.Count == 0)  		for (int j = 0; j < vertexList.Count; j++)  			unpackedUvs.Add (Vector2.Zero);  	if (uvs [0].Contains ("/")) {  		for (int i = 0; i < uvs.Length; i++)  			uvs [i] = uvs [i].Substring (0' uvs [i].IndexOf ("/"));  	} else {  		normalsList.Add (triangle [0]);  		normalsList.Add (triangle [1]);  		normalsList.Add (triangle [2]);  	}  	if (unpackedUvs [triangle [0]] == Vector2.Zero)  		unpackedUvs [triangle [0]] = uvList [int.Parse (uvs [0]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [0]) - uvOffset]);  		vertexList.Add (vertexList [triangle [0]]);  		triangle [0] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [1]] == Vector2.Zero)  		unpackedUvs [triangle [1]] = uvList [int.Parse (uvs [1]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [1]) - uvOffset]);  		vertexList.Add (vertexList [triangle [1]]);  		triangle [1] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [2]] == Vector2.Zero)  		unpackedUvs [triangle [2]] = uvList [int.Parse (uvs [2]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [2]) - uvOffset]);  		vertexList.Add (vertexList [triangle [2]]);  		triangle [2] = unpackedUvs.Count - 1;  	}  	triangleList.Add (triangle [0]);  	triangleList.Add (triangle [1]);  	triangleList.Add (triangle [2]);  } else {  	triangleList.Add (int.Parse (indices [0]) - vertexOffset);  	triangleList.Add (int.Parse (indices [1]) - vertexOffset);  	triangleList.Add (int.Parse (indices [2]) - vertexOffset);  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: if (split [1].Contains ("/")) {  	indices [0] = split [1].Substring (0' split [1].IndexOf ("/"));  	indices [1] = split [2].Substring (0' split [2].IndexOf ("/"));  	indices [2] = split [3].Substring (0' split [3].IndexOf ("/"));  	string[] uvs = new string[3];  	uvs [0] = split [1].Substring (split [1].IndexOf ("/") + 1);  	uvs [1] = split [2].Substring (split [2].IndexOf ("/") + 1);  	uvs [2] = split [3].Substring (split [3].IndexOf ("/") + 1);  	int[] triangle = new int[] {  		int.Parse (indices [0]) - vertexOffset'  		int.Parse (indices [1]) - vertexOffset'  		int.Parse (indices [2]) - vertexOffset  	};  	if (unpackedUvs.Count == 0)  		for (int j = 0; j < vertexList.Count; j++)  			unpackedUvs.Add (Vector2.Zero);  	if (uvs [0].Contains ("/")) {  		for (int i = 0; i < uvs.Length; i++)  			uvs [i] = uvs [i].Substring (0' uvs [i].IndexOf ("/"));  	} else {  		normalsList.Add (triangle [0]);  		normalsList.Add (triangle [1]);  		normalsList.Add (triangle [2]);  	}  	if (unpackedUvs [triangle [0]] == Vector2.Zero)  		unpackedUvs [triangle [0]] = uvList [int.Parse (uvs [0]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [0]) - uvOffset]);  		vertexList.Add (vertexList [triangle [0]]);  		triangle [0] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [1]] == Vector2.Zero)  		unpackedUvs [triangle [1]] = uvList [int.Parse (uvs [1]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [1]) - uvOffset]);  		vertexList.Add (vertexList [triangle [1]]);  		triangle [1] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [2]] == Vector2.Zero)  		unpackedUvs [triangle [2]] = uvList [int.Parse (uvs [2]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [2]) - uvOffset]);  		vertexList.Add (vertexList [triangle [2]]);  		triangle [2] = unpackedUvs.Count - 1;  	}  	triangleList.Add (triangle [0]);  	triangleList.Add (triangle [1]);  	triangleList.Add (triangle [2]);  } else {  	triangleList.Add (int.Parse (indices [0]) - vertexOffset);  	triangleList.Add (int.Parse (indices [1]) - vertexOffset);  	triangleList.Add (int.Parse (indices [2]) - vertexOffset);  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: if (split [1].Contains ("/")) {  	indices [0] = split [1].Substring (0' split [1].IndexOf ("/"));  	indices [1] = split [2].Substring (0' split [2].IndexOf ("/"));  	indices [2] = split [3].Substring (0' split [3].IndexOf ("/"));  	string[] uvs = new string[3];  	uvs [0] = split [1].Substring (split [1].IndexOf ("/") + 1);  	uvs [1] = split [2].Substring (split [2].IndexOf ("/") + 1);  	uvs [2] = split [3].Substring (split [3].IndexOf ("/") + 1);  	int[] triangle = new int[] {  		int.Parse (indices [0]) - vertexOffset'  		int.Parse (indices [1]) - vertexOffset'  		int.Parse (indices [2]) - vertexOffset  	};  	if (unpackedUvs.Count == 0)  		for (int j = 0; j < vertexList.Count; j++)  			unpackedUvs.Add (Vector2.Zero);  	if (uvs [0].Contains ("/")) {  		for (int i = 0; i < uvs.Length; i++)  			uvs [i] = uvs [i].Substring (0' uvs [i].IndexOf ("/"));  	} else {  		normalsList.Add (triangle [0]);  		normalsList.Add (triangle [1]);  		normalsList.Add (triangle [2]);  	}  	if (unpackedUvs [triangle [0]] == Vector2.Zero)  		unpackedUvs [triangle [0]] = uvList [int.Parse (uvs [0]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [0]) - uvOffset]);  		vertexList.Add (vertexList [triangle [0]]);  		triangle [0] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [1]] == Vector2.Zero)  		unpackedUvs [triangle [1]] = uvList [int.Parse (uvs [1]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [1]) - uvOffset]);  		vertexList.Add (vertexList [triangle [1]]);  		triangle [1] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [2]] == Vector2.Zero)  		unpackedUvs [triangle [2]] = uvList [int.Parse (uvs [2]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [2]) - uvOffset]);  		vertexList.Add (vertexList [triangle [2]]);  		triangle [2] = unpackedUvs.Count - 1;  	}  	triangleList.Add (triangle [0]);  	triangleList.Add (triangle [1]);  	triangleList.Add (triangle [2]);  } else {  	triangleList.Add (int.Parse (indices [0]) - vertexOffset);  	triangleList.Add (int.Parse (indices [1]) - vertexOffset);  	triangleList.Add (int.Parse (indices [2]) - vertexOffset);  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: if (split [1].Contains ("/")) {  	indices [0] = split [1].Substring (0' split [1].IndexOf ("/"));  	indices [1] = split [2].Substring (0' split [2].IndexOf ("/"));  	indices [2] = split [3].Substring (0' split [3].IndexOf ("/"));  	string[] uvs = new string[3];  	uvs [0] = split [1].Substring (split [1].IndexOf ("/") + 1);  	uvs [1] = split [2].Substring (split [2].IndexOf ("/") + 1);  	uvs [2] = split [3].Substring (split [3].IndexOf ("/") + 1);  	int[] triangle = new int[] {  		int.Parse (indices [0]) - vertexOffset'  		int.Parse (indices [1]) - vertexOffset'  		int.Parse (indices [2]) - vertexOffset  	};  	if (unpackedUvs.Count == 0)  		for (int j = 0; j < vertexList.Count; j++)  			unpackedUvs.Add (Vector2.Zero);  	if (uvs [0].Contains ("/")) {  		for (int i = 0; i < uvs.Length; i++)  			uvs [i] = uvs [i].Substring (0' uvs [i].IndexOf ("/"));  	} else {  		normalsList.Add (triangle [0]);  		normalsList.Add (triangle [1]);  		normalsList.Add (triangle [2]);  	}  	if (unpackedUvs [triangle [0]] == Vector2.Zero)  		unpackedUvs [triangle [0]] = uvList [int.Parse (uvs [0]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [0]) - uvOffset]);  		vertexList.Add (vertexList [triangle [0]]);  		triangle [0] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [1]] == Vector2.Zero)  		unpackedUvs [triangle [1]] = uvList [int.Parse (uvs [1]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [1]) - uvOffset]);  		vertexList.Add (vertexList [triangle [1]]);  		triangle [1] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [2]] == Vector2.Zero)  		unpackedUvs [triangle [2]] = uvList [int.Parse (uvs [2]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [2]) - uvOffset]);  		vertexList.Add (vertexList [triangle [2]]);  		triangle [2] = unpackedUvs.Count - 1;  	}  	triangleList.Add (triangle [0]);  	triangleList.Add (triangle [1]);  	triangleList.Add (triangle [2]);  } else {  	triangleList.Add (int.Parse (indices [0]) - vertexOffset);  	triangleList.Add (int.Parse (indices [1]) - vertexOffset);  	triangleList.Add (int.Parse (indices [2]) - vertexOffset);  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: if (split [1].Contains ("/")) {  	indices [0] = split [1].Substring (0' split [1].IndexOf ("/"));  	indices [1] = split [2].Substring (0' split [2].IndexOf ("/"));  	indices [2] = split [3].Substring (0' split [3].IndexOf ("/"));  	string[] uvs = new string[3];  	uvs [0] = split [1].Substring (split [1].IndexOf ("/") + 1);  	uvs [1] = split [2].Substring (split [2].IndexOf ("/") + 1);  	uvs [2] = split [3].Substring (split [3].IndexOf ("/") + 1);  	int[] triangle = new int[] {  		int.Parse (indices [0]) - vertexOffset'  		int.Parse (indices [1]) - vertexOffset'  		int.Parse (indices [2]) - vertexOffset  	};  	if (unpackedUvs.Count == 0)  		for (int j = 0; j < vertexList.Count; j++)  			unpackedUvs.Add (Vector2.Zero);  	if (uvs [0].Contains ("/")) {  		for (int i = 0; i < uvs.Length; i++)  			uvs [i] = uvs [i].Substring (0' uvs [i].IndexOf ("/"));  	} else {  		normalsList.Add (triangle [0]);  		normalsList.Add (triangle [1]);  		normalsList.Add (triangle [2]);  	}  	if (unpackedUvs [triangle [0]] == Vector2.Zero)  		unpackedUvs [triangle [0]] = uvList [int.Parse (uvs [0]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [0]) - uvOffset]);  		vertexList.Add (vertexList [triangle [0]]);  		triangle [0] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [1]] == Vector2.Zero)  		unpackedUvs [triangle [1]] = uvList [int.Parse (uvs [1]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [1]) - uvOffset]);  		vertexList.Add (vertexList [triangle [1]]);  		triangle [1] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [2]] == Vector2.Zero)  		unpackedUvs [triangle [2]] = uvList [int.Parse (uvs [2]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [2]) - uvOffset]);  		vertexList.Add (vertexList [triangle [2]]);  		triangle [2] = unpackedUvs.Count - 1;  	}  	triangleList.Add (triangle [0]);  	triangleList.Add (triangle [1]);  	triangleList.Add (triangle [2]);  } else {  	triangleList.Add (int.Parse (indices [0]) - vertexOffset);  	triangleList.Add (int.Parse (indices [1]) - vertexOffset);  	triangleList.Add (int.Parse (indices [2]) - vertexOffset);  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: if (split [1].Contains ("/")) {  	indices [0] = split [1].Substring (0' split [1].IndexOf ("/"));  	indices [1] = split [2].Substring (0' split [2].IndexOf ("/"));  	indices [2] = split [3].Substring (0' split [3].IndexOf ("/"));  	string[] uvs = new string[3];  	uvs [0] = split [1].Substring (split [1].IndexOf ("/") + 1);  	uvs [1] = split [2].Substring (split [2].IndexOf ("/") + 1);  	uvs [2] = split [3].Substring (split [3].IndexOf ("/") + 1);  	int[] triangle = new int[] {  		int.Parse (indices [0]) - vertexOffset'  		int.Parse (indices [1]) - vertexOffset'  		int.Parse (indices [2]) - vertexOffset  	};  	if (unpackedUvs.Count == 0)  		for (int j = 0; j < vertexList.Count; j++)  			unpackedUvs.Add (Vector2.Zero);  	if (uvs [0].Contains ("/")) {  		for (int i = 0; i < uvs.Length; i++)  			uvs [i] = uvs [i].Substring (0' uvs [i].IndexOf ("/"));  	} else {  		normalsList.Add (triangle [0]);  		normalsList.Add (triangle [1]);  		normalsList.Add (triangle [2]);  	}  	if (unpackedUvs [triangle [0]] == Vector2.Zero)  		unpackedUvs [triangle [0]] = uvList [int.Parse (uvs [0]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [0]) - uvOffset]);  		vertexList.Add (vertexList [triangle [0]]);  		triangle [0] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [1]] == Vector2.Zero)  		unpackedUvs [triangle [1]] = uvList [int.Parse (uvs [1]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [1]) - uvOffset]);  		vertexList.Add (vertexList [triangle [1]]);  		triangle [1] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [2]] == Vector2.Zero)  		unpackedUvs [triangle [2]] = uvList [int.Parse (uvs [2]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [2]) - uvOffset]);  		vertexList.Add (vertexList [triangle [2]]);  		triangle [2] = unpackedUvs.Count - 1;  	}  	triangleList.Add (triangle [0]);  	triangleList.Add (triangle [1]);  	triangleList.Add (triangle [2]);  } else {  	triangleList.Add (int.Parse (indices [0]) - vertexOffset);  	triangleList.Add (int.Parse (indices [1]) - vertexOffset);  	triangleList.Add (int.Parse (indices [2]) - vertexOffset);  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: if (split [1].Contains ("/")) {  	indices [0] = split [1].Substring (0' split [1].IndexOf ("/"));  	indices [1] = split [2].Substring (0' split [2].IndexOf ("/"));  	indices [2] = split [3].Substring (0' split [3].IndexOf ("/"));  	string[] uvs = new string[3];  	uvs [0] = split [1].Substring (split [1].IndexOf ("/") + 1);  	uvs [1] = split [2].Substring (split [2].IndexOf ("/") + 1);  	uvs [2] = split [3].Substring (split [3].IndexOf ("/") + 1);  	int[] triangle = new int[] {  		int.Parse (indices [0]) - vertexOffset'  		int.Parse (indices [1]) - vertexOffset'  		int.Parse (indices [2]) - vertexOffset  	};  	if (unpackedUvs.Count == 0)  		for (int j = 0; j < vertexList.Count; j++)  			unpackedUvs.Add (Vector2.Zero);  	if (uvs [0].Contains ("/")) {  		for (int i = 0; i < uvs.Length; i++)  			uvs [i] = uvs [i].Substring (0' uvs [i].IndexOf ("/"));  	} else {  		normalsList.Add (triangle [0]);  		normalsList.Add (triangle [1]);  		normalsList.Add (triangle [2]);  	}  	if (unpackedUvs [triangle [0]] == Vector2.Zero)  		unpackedUvs [triangle [0]] = uvList [int.Parse (uvs [0]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [0]) - uvOffset]);  		vertexList.Add (vertexList [triangle [0]]);  		triangle [0] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [1]] == Vector2.Zero)  		unpackedUvs [triangle [1]] = uvList [int.Parse (uvs [1]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [1]) - uvOffset]);  		vertexList.Add (vertexList [triangle [1]]);  		triangle [1] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [2]] == Vector2.Zero)  		unpackedUvs [triangle [2]] = uvList [int.Parse (uvs [2]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [2]) - uvOffset]);  		vertexList.Add (vertexList [triangle [2]]);  		triangle [2] = unpackedUvs.Count - 1;  	}  	triangleList.Add (triangle [0]);  	triangleList.Add (triangle [1]);  	triangleList.Add (triangle [2]);  } else {  	triangleList.Add (int.Parse (indices [0]) - vertexOffset);  	triangleList.Add (int.Parse (indices [1]) - vertexOffset);  	triangleList.Add (int.Parse (indices [2]) - vertexOffset);  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: if (split [1].Contains ("/")) {  	indices [0] = split [1].Substring (0' split [1].IndexOf ("/"));  	indices [1] = split [2].Substring (0' split [2].IndexOf ("/"));  	indices [2] = split [3].Substring (0' split [3].IndexOf ("/"));  	string[] uvs = new string[3];  	uvs [0] = split [1].Substring (split [1].IndexOf ("/") + 1);  	uvs [1] = split [2].Substring (split [2].IndexOf ("/") + 1);  	uvs [2] = split [3].Substring (split [3].IndexOf ("/") + 1);  	int[] triangle = new int[] {  		int.Parse (indices [0]) - vertexOffset'  		int.Parse (indices [1]) - vertexOffset'  		int.Parse (indices [2]) - vertexOffset  	};  	if (unpackedUvs.Count == 0)  		for (int j = 0; j < vertexList.Count; j++)  			unpackedUvs.Add (Vector2.Zero);  	if (uvs [0].Contains ("/")) {  		for (int i = 0; i < uvs.Length; i++)  			uvs [i] = uvs [i].Substring (0' uvs [i].IndexOf ("/"));  	} else {  		normalsList.Add (triangle [0]);  		normalsList.Add (triangle [1]);  		normalsList.Add (triangle [2]);  	}  	if (unpackedUvs [triangle [0]] == Vector2.Zero)  		unpackedUvs [triangle [0]] = uvList [int.Parse (uvs [0]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [0]) - uvOffset]);  		vertexList.Add (vertexList [triangle [0]]);  		triangle [0] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [1]] == Vector2.Zero)  		unpackedUvs [triangle [1]] = uvList [int.Parse (uvs [1]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [1]) - uvOffset]);  		vertexList.Add (vertexList [triangle [1]]);  		triangle [1] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [2]] == Vector2.Zero)  		unpackedUvs [triangle [2]] = uvList [int.Parse (uvs [2]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [2]) - uvOffset]);  		vertexList.Add (vertexList [triangle [2]]);  		triangle [2] = unpackedUvs.Count - 1;  	}  	triangleList.Add (triangle [0]);  	triangleList.Add (triangle [1]);  	triangleList.Add (triangle [2]);  } else {  	triangleList.Add (int.Parse (indices [0]) - vertexOffset);  	triangleList.Add (int.Parse (indices [1]) - vertexOffset);  	triangleList.Add (int.Parse (indices [2]) - vertexOffset);  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: if (split [1].Contains ("/")) {  	indices [0] = split [1].Substring (0' split [1].IndexOf ("/"));  	indices [1] = split [2].Substring (0' split [2].IndexOf ("/"));  	indices [2] = split [3].Substring (0' split [3].IndexOf ("/"));  	string[] uvs = new string[3];  	uvs [0] = split [1].Substring (split [1].IndexOf ("/") + 1);  	uvs [1] = split [2].Substring (split [2].IndexOf ("/") + 1);  	uvs [2] = split [3].Substring (split [3].IndexOf ("/") + 1);  	int[] triangle = new int[] {  		int.Parse (indices [0]) - vertexOffset'  		int.Parse (indices [1]) - vertexOffset'  		int.Parse (indices [2]) - vertexOffset  	};  	if (unpackedUvs.Count == 0)  		for (int j = 0; j < vertexList.Count; j++)  			unpackedUvs.Add (Vector2.Zero);  	if (uvs [0].Contains ("/")) {  		for (int i = 0; i < uvs.Length; i++)  			uvs [i] = uvs [i].Substring (0' uvs [i].IndexOf ("/"));  	} else {  		normalsList.Add (triangle [0]);  		normalsList.Add (triangle [1]);  		normalsList.Add (triangle [2]);  	}  	if (unpackedUvs [triangle [0]] == Vector2.Zero)  		unpackedUvs [triangle [0]] = uvList [int.Parse (uvs [0]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [0]) - uvOffset]);  		vertexList.Add (vertexList [triangle [0]]);  		triangle [0] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [1]] == Vector2.Zero)  		unpackedUvs [triangle [1]] = uvList [int.Parse (uvs [1]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [1]) - uvOffset]);  		vertexList.Add (vertexList [triangle [1]]);  		triangle [1] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [2]] == Vector2.Zero)  		unpackedUvs [triangle [2]] = uvList [int.Parse (uvs [2]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [2]) - uvOffset]);  		vertexList.Add (vertexList [triangle [2]]);  		triangle [2] = unpackedUvs.Count - 1;  	}  	triangleList.Add (triangle [0]);  	triangleList.Add (triangle [1]);  	triangleList.Add (triangle [2]);  } else {  	triangleList.Add (int.Parse (indices [0]) - vertexOffset);  	triangleList.Add (int.Parse (indices [1]) - vertexOffset);  	triangleList.Add (int.Parse (indices [2]) - vertexOffset);  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: if (split [1].Contains ("/")) {  	indices [0] = split [1].Substring (0' split [1].IndexOf ("/"));  	indices [1] = split [2].Substring (0' split [2].IndexOf ("/"));  	indices [2] = split [3].Substring (0' split [3].IndexOf ("/"));  	string[] uvs = new string[3];  	uvs [0] = split [1].Substring (split [1].IndexOf ("/") + 1);  	uvs [1] = split [2].Substring (split [2].IndexOf ("/") + 1);  	uvs [2] = split [3].Substring (split [3].IndexOf ("/") + 1);  	int[] triangle = new int[] {  		int.Parse (indices [0]) - vertexOffset'  		int.Parse (indices [1]) - vertexOffset'  		int.Parse (indices [2]) - vertexOffset  	};  	if (unpackedUvs.Count == 0)  		for (int j = 0; j < vertexList.Count; j++)  			unpackedUvs.Add (Vector2.Zero);  	if (uvs [0].Contains ("/")) {  		for (int i = 0; i < uvs.Length; i++)  			uvs [i] = uvs [i].Substring (0' uvs [i].IndexOf ("/"));  	} else {  		normalsList.Add (triangle [0]);  		normalsList.Add (triangle [1]);  		normalsList.Add (triangle [2]);  	}  	if (unpackedUvs [triangle [0]] == Vector2.Zero)  		unpackedUvs [triangle [0]] = uvList [int.Parse (uvs [0]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [0]) - uvOffset]);  		vertexList.Add (vertexList [triangle [0]]);  		triangle [0] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [1]] == Vector2.Zero)  		unpackedUvs [triangle [1]] = uvList [int.Parse (uvs [1]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [1]) - uvOffset]);  		vertexList.Add (vertexList [triangle [1]]);  		triangle [1] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [2]] == Vector2.Zero)  		unpackedUvs [triangle [2]] = uvList [int.Parse (uvs [2]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [2]) - uvOffset]);  		vertexList.Add (vertexList [triangle [2]]);  		triangle [2] = unpackedUvs.Count - 1;  	}  	triangleList.Add (triangle [0]);  	triangleList.Add (triangle [1]);  	triangleList.Add (triangle [2]);  } else {  	triangleList.Add (int.Parse (indices [0]) - vertexOffset);  	triangleList.Add (int.Parse (indices [1]) - vertexOffset);  	triangleList.Add (int.Parse (indices [2]) - vertexOffset);  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: if (split [1].Contains ("/")) {  	indices [0] = split [1].Substring (0' split [1].IndexOf ("/"));  	indices [1] = split [2].Substring (0' split [2].IndexOf ("/"));  	indices [2] = split [3].Substring (0' split [3].IndexOf ("/"));  	string[] uvs = new string[3];  	uvs [0] = split [1].Substring (split [1].IndexOf ("/") + 1);  	uvs [1] = split [2].Substring (split [2].IndexOf ("/") + 1);  	uvs [2] = split [3].Substring (split [3].IndexOf ("/") + 1);  	int[] triangle = new int[] {  		int.Parse (indices [0]) - vertexOffset'  		int.Parse (indices [1]) - vertexOffset'  		int.Parse (indices [2]) - vertexOffset  	};  	if (unpackedUvs.Count == 0)  		for (int j = 0; j < vertexList.Count; j++)  			unpackedUvs.Add (Vector2.Zero);  	if (uvs [0].Contains ("/")) {  		for (int i = 0; i < uvs.Length; i++)  			uvs [i] = uvs [i].Substring (0' uvs [i].IndexOf ("/"));  	} else {  		normalsList.Add (triangle [0]);  		normalsList.Add (triangle [1]);  		normalsList.Add (triangle [2]);  	}  	if (unpackedUvs [triangle [0]] == Vector2.Zero)  		unpackedUvs [triangle [0]] = uvList [int.Parse (uvs [0]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [0]) - uvOffset]);  		vertexList.Add (vertexList [triangle [0]]);  		triangle [0] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [1]] == Vector2.Zero)  		unpackedUvs [triangle [1]] = uvList [int.Parse (uvs [1]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [1]) - uvOffset]);  		vertexList.Add (vertexList [triangle [1]]);  		triangle [1] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [2]] == Vector2.Zero)  		unpackedUvs [triangle [2]] = uvList [int.Parse (uvs [2]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [2]) - uvOffset]);  		vertexList.Add (vertexList [triangle [2]]);  		triangle [2] = unpackedUvs.Count - 1;  	}  	triangleList.Add (triangle [0]);  	triangleList.Add (triangle [1]);  	triangleList.Add (triangle [2]);  } else {  	triangleList.Add (int.Parse (indices [0]) - vertexOffset);  	triangleList.Add (int.Parse (indices [1]) - vertexOffset);  	triangleList.Add (int.Parse (indices [2]) - vertexOffset);  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: if (split [1].Contains ("/")) {  	indices [0] = split [1].Substring (0' split [1].IndexOf ("/"));  	indices [1] = split [2].Substring (0' split [2].IndexOf ("/"));  	indices [2] = split [3].Substring (0' split [3].IndexOf ("/"));  	string[] uvs = new string[3];  	uvs [0] = split [1].Substring (split [1].IndexOf ("/") + 1);  	uvs [1] = split [2].Substring (split [2].IndexOf ("/") + 1);  	uvs [2] = split [3].Substring (split [3].IndexOf ("/") + 1);  	int[] triangle = new int[] {  		int.Parse (indices [0]) - vertexOffset'  		int.Parse (indices [1]) - vertexOffset'  		int.Parse (indices [2]) - vertexOffset  	};  	if (unpackedUvs.Count == 0)  		for (int j = 0; j < vertexList.Count; j++)  			unpackedUvs.Add (Vector2.Zero);  	if (uvs [0].Contains ("/")) {  		for (int i = 0; i < uvs.Length; i++)  			uvs [i] = uvs [i].Substring (0' uvs [i].IndexOf ("/"));  	} else {  		normalsList.Add (triangle [0]);  		normalsList.Add (triangle [1]);  		normalsList.Add (triangle [2]);  	}  	if (unpackedUvs [triangle [0]] == Vector2.Zero)  		unpackedUvs [triangle [0]] = uvList [int.Parse (uvs [0]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [0]) - uvOffset]);  		vertexList.Add (vertexList [triangle [0]]);  		triangle [0] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [1]] == Vector2.Zero)  		unpackedUvs [triangle [1]] = uvList [int.Parse (uvs [1]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [1]) - uvOffset]);  		vertexList.Add (vertexList [triangle [1]]);  		triangle [1] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [2]] == Vector2.Zero)  		unpackedUvs [triangle [2]] = uvList [int.Parse (uvs [2]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [2]) - uvOffset]);  		vertexList.Add (vertexList [triangle [2]]);  		triangle [2] = unpackedUvs.Count - 1;  	}  	triangleList.Add (triangle [0]);  	triangleList.Add (triangle [1]);  	triangleList.Add (triangle [2]);  } else {  	triangleList.Add (int.Parse (indices [0]) - vertexOffset);  	triangleList.Add (int.Parse (indices [1]) - vertexOffset);  	triangleList.Add (int.Parse (indices [2]) - vertexOffset);  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: if (split [1].Contains ("/")) {  	indices [0] = split [1].Substring (0' split [1].IndexOf ("/"));  	indices [1] = split [2].Substring (0' split [2].IndexOf ("/"));  	indices [2] = split [3].Substring (0' split [3].IndexOf ("/"));  	string[] uvs = new string[3];  	uvs [0] = split [1].Substring (split [1].IndexOf ("/") + 1);  	uvs [1] = split [2].Substring (split [2].IndexOf ("/") + 1);  	uvs [2] = split [3].Substring (split [3].IndexOf ("/") + 1);  	int[] triangle = new int[] {  		int.Parse (indices [0]) - vertexOffset'  		int.Parse (indices [1]) - vertexOffset'  		int.Parse (indices [2]) - vertexOffset  	};  	if (unpackedUvs.Count == 0)  		for (int j = 0; j < vertexList.Count; j++)  			unpackedUvs.Add (Vector2.Zero);  	if (uvs [0].Contains ("/")) {  		for (int i = 0; i < uvs.Length; i++)  			uvs [i] = uvs [i].Substring (0' uvs [i].IndexOf ("/"));  	} else {  		normalsList.Add (triangle [0]);  		normalsList.Add (triangle [1]);  		normalsList.Add (triangle [2]);  	}  	if (unpackedUvs [triangle [0]] == Vector2.Zero)  		unpackedUvs [triangle [0]] = uvList [int.Parse (uvs [0]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [0]) - uvOffset]);  		vertexList.Add (vertexList [triangle [0]]);  		triangle [0] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [1]] == Vector2.Zero)  		unpackedUvs [triangle [1]] = uvList [int.Parse (uvs [1]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [1]) - uvOffset]);  		vertexList.Add (vertexList [triangle [1]]);  		triangle [1] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [2]] == Vector2.Zero)  		unpackedUvs [triangle [2]] = uvList [int.Parse (uvs [2]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [2]) - uvOffset]);  		vertexList.Add (vertexList [triangle [2]]);  		triangle [2] = unpackedUvs.Count - 1;  	}  	triangleList.Add (triangle [0]);  	triangleList.Add (triangle [1]);  	triangleList.Add (triangle [2]);  } else {  	triangleList.Add (int.Parse (indices [0]) - vertexOffset);  	triangleList.Add (int.Parse (indices [1]) - vertexOffset);  	triangleList.Add (int.Parse (indices [2]) - vertexOffset);  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: if (split [1].Contains ("/")) {  	indices [0] = split [1].Substring (0' split [1].IndexOf ("/"));  	indices [1] = split [2].Substring (0' split [2].IndexOf ("/"));  	indices [2] = split [3].Substring (0' split [3].IndexOf ("/"));  	string[] uvs = new string[3];  	uvs [0] = split [1].Substring (split [1].IndexOf ("/") + 1);  	uvs [1] = split [2].Substring (split [2].IndexOf ("/") + 1);  	uvs [2] = split [3].Substring (split [3].IndexOf ("/") + 1);  	int[] triangle = new int[] {  		int.Parse (indices [0]) - vertexOffset'  		int.Parse (indices [1]) - vertexOffset'  		int.Parse (indices [2]) - vertexOffset  	};  	if (unpackedUvs.Count == 0)  		for (int j = 0; j < vertexList.Count; j++)  			unpackedUvs.Add (Vector2.Zero);  	if (uvs [0].Contains ("/")) {  		for (int i = 0; i < uvs.Length; i++)  			uvs [i] = uvs [i].Substring (0' uvs [i].IndexOf ("/"));  	} else {  		normalsList.Add (triangle [0]);  		normalsList.Add (triangle [1]);  		normalsList.Add (triangle [2]);  	}  	if (unpackedUvs [triangle [0]] == Vector2.Zero)  		unpackedUvs [triangle [0]] = uvList [int.Parse (uvs [0]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [0]) - uvOffset]);  		vertexList.Add (vertexList [triangle [0]]);  		triangle [0] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [1]] == Vector2.Zero)  		unpackedUvs [triangle [1]] = uvList [int.Parse (uvs [1]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [1]) - uvOffset]);  		vertexList.Add (vertexList [triangle [1]]);  		triangle [1] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [2]] == Vector2.Zero)  		unpackedUvs [triangle [2]] = uvList [int.Parse (uvs [2]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [2]) - uvOffset]);  		vertexList.Add (vertexList [triangle [2]]);  		triangle [2] = unpackedUvs.Count - 1;  	}  	triangleList.Add (triangle [0]);  	triangleList.Add (triangle [1]);  	triangleList.Add (triangle [2]);  } else {  	triangleList.Add (int.Parse (indices [0]) - vertexOffset);  	triangleList.Add (int.Parse (indices [1]) - vertexOffset);  	triangleList.Add (int.Parse (indices [2]) - vertexOffset);  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: if (split [1].Contains ("/")) {  	indices [0] = split [1].Substring (0' split [1].IndexOf ("/"));  	indices [1] = split [2].Substring (0' split [2].IndexOf ("/"));  	indices [2] = split [3].Substring (0' split [3].IndexOf ("/"));  	string[] uvs = new string[3];  	uvs [0] = split [1].Substring (split [1].IndexOf ("/") + 1);  	uvs [1] = split [2].Substring (split [2].IndexOf ("/") + 1);  	uvs [2] = split [3].Substring (split [3].IndexOf ("/") + 1);  	int[] triangle = new int[] {  		int.Parse (indices [0]) - vertexOffset'  		int.Parse (indices [1]) - vertexOffset'  		int.Parse (indices [2]) - vertexOffset  	};  	if (unpackedUvs.Count == 0)  		for (int j = 0; j < vertexList.Count; j++)  			unpackedUvs.Add (Vector2.Zero);  	if (uvs [0].Contains ("/")) {  		for (int i = 0; i < uvs.Length; i++)  			uvs [i] = uvs [i].Substring (0' uvs [i].IndexOf ("/"));  	} else {  		normalsList.Add (triangle [0]);  		normalsList.Add (triangle [1]);  		normalsList.Add (triangle [2]);  	}  	if (unpackedUvs [triangle [0]] == Vector2.Zero)  		unpackedUvs [triangle [0]] = uvList [int.Parse (uvs [0]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [0]) - uvOffset]);  		vertexList.Add (vertexList [triangle [0]]);  		triangle [0] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [1]] == Vector2.Zero)  		unpackedUvs [triangle [1]] = uvList [int.Parse (uvs [1]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [1]) - uvOffset]);  		vertexList.Add (vertexList [triangle [1]]);  		triangle [1] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [2]] == Vector2.Zero)  		unpackedUvs [triangle [2]] = uvList [int.Parse (uvs [2]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [2]) - uvOffset]);  		vertexList.Add (vertexList [triangle [2]]);  		triangle [2] = unpackedUvs.Count - 1;  	}  	triangleList.Add (triangle [0]);  	triangleList.Add (triangle [1]);  	triangleList.Add (triangle [2]);  } else {  	triangleList.Add (int.Parse (indices [0]) - vertexOffset);  	triangleList.Add (int.Parse (indices [1]) - vertexOffset);  	triangleList.Add (int.Parse (indices [2]) - vertexOffset);  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: if (split [1].Contains ("/")) {  	indices [0] = split [1].Substring (0' split [1].IndexOf ("/"));  	indices [1] = split [2].Substring (0' split [2].IndexOf ("/"));  	indices [2] = split [3].Substring (0' split [3].IndexOf ("/"));  	string[] uvs = new string[3];  	uvs [0] = split [1].Substring (split [1].IndexOf ("/") + 1);  	uvs [1] = split [2].Substring (split [2].IndexOf ("/") + 1);  	uvs [2] = split [3].Substring (split [3].IndexOf ("/") + 1);  	int[] triangle = new int[] {  		int.Parse (indices [0]) - vertexOffset'  		int.Parse (indices [1]) - vertexOffset'  		int.Parse (indices [2]) - vertexOffset  	};  	if (unpackedUvs.Count == 0)  		for (int j = 0; j < vertexList.Count; j++)  			unpackedUvs.Add (Vector2.Zero);  	if (uvs [0].Contains ("/")) {  		for (int i = 0; i < uvs.Length; i++)  			uvs [i] = uvs [i].Substring (0' uvs [i].IndexOf ("/"));  	} else {  		normalsList.Add (triangle [0]);  		normalsList.Add (triangle [1]);  		normalsList.Add (triangle [2]);  	}  	if (unpackedUvs [triangle [0]] == Vector2.Zero)  		unpackedUvs [triangle [0]] = uvList [int.Parse (uvs [0]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [0]) - uvOffset]);  		vertexList.Add (vertexList [triangle [0]]);  		triangle [0] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [1]] == Vector2.Zero)  		unpackedUvs [triangle [1]] = uvList [int.Parse (uvs [1]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [1]) - uvOffset]);  		vertexList.Add (vertexList [triangle [1]]);  		triangle [1] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [2]] == Vector2.Zero)  		unpackedUvs [triangle [2]] = uvList [int.Parse (uvs [2]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [2]) - uvOffset]);  		vertexList.Add (vertexList [triangle [2]]);  		triangle [2] = unpackedUvs.Count - 1;  	}  	triangleList.Add (triangle [0]);  	triangleList.Add (triangle [1]);  	triangleList.Add (triangle [2]);  } else {  	triangleList.Add (int.Parse (indices [0]) - vertexOffset);  	triangleList.Add (int.Parse (indices [1]) - vertexOffset);  	triangleList.Add (int.Parse (indices [2]) - vertexOffset);  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: if (split [1].Contains ("/")) {  	indices [0] = split [1].Substring (0' split [1].IndexOf ("/"));  	indices [1] = split [2].Substring (0' split [2].IndexOf ("/"));  	indices [2] = split [3].Substring (0' split [3].IndexOf ("/"));  	string[] uvs = new string[3];  	uvs [0] = split [1].Substring (split [1].IndexOf ("/") + 1);  	uvs [1] = split [2].Substring (split [2].IndexOf ("/") + 1);  	uvs [2] = split [3].Substring (split [3].IndexOf ("/") + 1);  	int[] triangle = new int[] {  		int.Parse (indices [0]) - vertexOffset'  		int.Parse (indices [1]) - vertexOffset'  		int.Parse (indices [2]) - vertexOffset  	};  	if (unpackedUvs.Count == 0)  		for (int j = 0; j < vertexList.Count; j++)  			unpackedUvs.Add (Vector2.Zero);  	if (uvs [0].Contains ("/")) {  		for (int i = 0; i < uvs.Length; i++)  			uvs [i] = uvs [i].Substring (0' uvs [i].IndexOf ("/"));  	} else {  		normalsList.Add (triangle [0]);  		normalsList.Add (triangle [1]);  		normalsList.Add (triangle [2]);  	}  	if (unpackedUvs [triangle [0]] == Vector2.Zero)  		unpackedUvs [triangle [0]] = uvList [int.Parse (uvs [0]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [0]) - uvOffset]);  		vertexList.Add (vertexList [triangle [0]]);  		triangle [0] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [1]] == Vector2.Zero)  		unpackedUvs [triangle [1]] = uvList [int.Parse (uvs [1]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [1]) - uvOffset]);  		vertexList.Add (vertexList [triangle [1]]);  		triangle [1] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [2]] == Vector2.Zero)  		unpackedUvs [triangle [2]] = uvList [int.Parse (uvs [2]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [2]) - uvOffset]);  		vertexList.Add (vertexList [triangle [2]]);  		triangle [2] = unpackedUvs.Count - 1;  	}  	triangleList.Add (triangle [0]);  	triangleList.Add (triangle [1]);  	triangleList.Add (triangle [2]);  } else {  	triangleList.Add (int.Parse (indices [0]) - vertexOffset);  	triangleList.Add (int.Parse (indices [1]) - vertexOffset);  	triangleList.Add (int.Parse (indices [2]) - vertexOffset);  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: if (split [1].Contains ("/")) {  	indices [0] = split [1].Substring (0' split [1].IndexOf ("/"));  	indices [1] = split [2].Substring (0' split [2].IndexOf ("/"));  	indices [2] = split [3].Substring (0' split [3].IndexOf ("/"));  	string[] uvs = new string[3];  	uvs [0] = split [1].Substring (split [1].IndexOf ("/") + 1);  	uvs [1] = split [2].Substring (split [2].IndexOf ("/") + 1);  	uvs [2] = split [3].Substring (split [3].IndexOf ("/") + 1);  	int[] triangle = new int[] {  		int.Parse (indices [0]) - vertexOffset'  		int.Parse (indices [1]) - vertexOffset'  		int.Parse (indices [2]) - vertexOffset  	};  	if (unpackedUvs.Count == 0)  		for (int j = 0; j < vertexList.Count; j++)  			unpackedUvs.Add (Vector2.Zero);  	if (uvs [0].Contains ("/")) {  		for (int i = 0; i < uvs.Length; i++)  			uvs [i] = uvs [i].Substring (0' uvs [i].IndexOf ("/"));  	} else {  		normalsList.Add (triangle [0]);  		normalsList.Add (triangle [1]);  		normalsList.Add (triangle [2]);  	}  	if (unpackedUvs [triangle [0]] == Vector2.Zero)  		unpackedUvs [triangle [0]] = uvList [int.Parse (uvs [0]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [0]) - uvOffset]);  		vertexList.Add (vertexList [triangle [0]]);  		triangle [0] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [1]] == Vector2.Zero)  		unpackedUvs [triangle [1]] = uvList [int.Parse (uvs [1]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [1]) - uvOffset]);  		vertexList.Add (vertexList [triangle [1]]);  		triangle [1] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [2]] == Vector2.Zero)  		unpackedUvs [triangle [2]] = uvList [int.Parse (uvs [2]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [2]) - uvOffset]);  		vertexList.Add (vertexList [triangle [2]]);  		triangle [2] = unpackedUvs.Count - 1;  	}  	triangleList.Add (triangle [0]);  	triangleList.Add (triangle [1]);  	triangleList.Add (triangle [2]);  } else {  	triangleList.Add (int.Parse (indices [0]) - vertexOffset);  	triangleList.Add (int.Parse (indices [1]) - vertexOffset);  	triangleList.Add (int.Parse (indices [2]) - vertexOffset);  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: if (split [1].Contains ("/")) {  	indices [0] = split [1].Substring (0' split [1].IndexOf ("/"));  	indices [1] = split [2].Substring (0' split [2].IndexOf ("/"));  	indices [2] = split [3].Substring (0' split [3].IndexOf ("/"));  	string[] uvs = new string[3];  	uvs [0] = split [1].Substring (split [1].IndexOf ("/") + 1);  	uvs [1] = split [2].Substring (split [2].IndexOf ("/") + 1);  	uvs [2] = split [3].Substring (split [3].IndexOf ("/") + 1);  	int[] triangle = new int[] {  		int.Parse (indices [0]) - vertexOffset'  		int.Parse (indices [1]) - vertexOffset'  		int.Parse (indices [2]) - vertexOffset  	};  	if (unpackedUvs.Count == 0)  		for (int j = 0; j < vertexList.Count; j++)  			unpackedUvs.Add (Vector2.Zero);  	if (uvs [0].Contains ("/")) {  		for (int i = 0; i < uvs.Length; i++)  			uvs [i] = uvs [i].Substring (0' uvs [i].IndexOf ("/"));  	} else {  		normalsList.Add (triangle [0]);  		normalsList.Add (triangle [1]);  		normalsList.Add (triangle [2]);  	}  	if (unpackedUvs [triangle [0]] == Vector2.Zero)  		unpackedUvs [triangle [0]] = uvList [int.Parse (uvs [0]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [0]) - uvOffset]);  		vertexList.Add (vertexList [triangle [0]]);  		triangle [0] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [1]] == Vector2.Zero)  		unpackedUvs [triangle [1]] = uvList [int.Parse (uvs [1]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [1]) - uvOffset]);  		vertexList.Add (vertexList [triangle [1]]);  		triangle [1] = unpackedUvs.Count - 1;  	}  	if (unpackedUvs [triangle [2]] == Vector2.Zero)  		unpackedUvs [triangle [2]] = uvList [int.Parse (uvs [2]) - uvOffset];  	else {  		unpackedUvs.Add (uvList [int.Parse (uvs [2]) - uvOffset]);  		vertexList.Add (vertexList [triangle [2]]);  		triangle [2] = unpackedUvs.Count - 1;  	}  	triangleList.Add (triangle [0]);  	triangleList.Add (triangle [1]);  	triangleList.Add (triangle [2]);  } else {  	triangleList.Add (int.Parse (indices [0]) - vertexOffset);  	triangleList.Add (int.Parse (indices [1]) - vertexOffset);  	triangleList.Add (int.Parse (indices [2]) - vertexOffset);  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: indices [1] = split [2].Substring (0' split [2].IndexOf ("/"));  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: indices [1] = split [2].Substring (0' split [2].IndexOf ("/"));  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: indices [2] = split [3].Substring (0' split [3].IndexOf ("/"));  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: indices [2] = split [3].Substring (0' split [3].IndexOf ("/"));  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: indices [2] = split [3].Substring (0' split [3].IndexOf ("/"));  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: uvs [1] = split [2].Substring (split [2].IndexOf ("/") + 1);  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: uvs [1] = split [2].Substring (split [2].IndexOf ("/") + 1);  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: uvs [2] = split [3].Substring (split [3].IndexOf ("/") + 1);  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: uvs [2] = split [3].Substring (split [3].IndexOf ("/") + 1);  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: uvs [2] = split [3].Substring (split [3].IndexOf ("/") + 1);  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: if (uvs [0].Contains ("/")) {  	for (int i = 0; i < uvs.Length; i++)  		uvs [i] = uvs [i].Substring (0' uvs [i].IndexOf ("/"));  } else {  	normalsList.Add (triangle [0]);  	normalsList.Add (triangle [1]);  	normalsList.Add (triangle [2]);  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: normalsList.Add (triangle [2]);  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: if (unpackedUvs [triangle [2]] == Vector2.Zero)  	unpackedUvs [triangle [2]] = uvList [int.Parse (uvs [2]) - uvOffset];  else {  	unpackedUvs.Add (uvList [int.Parse (uvs [2]) - uvOffset]);  	vertexList.Add (vertexList [triangle [2]]);  	triangle [2] = unpackedUvs.Count - 1;  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: if (unpackedUvs [triangle [2]] == Vector2.Zero)  	unpackedUvs [triangle [2]] = uvList [int.Parse (uvs [2]) - uvOffset];  else {  	unpackedUvs.Add (uvList [int.Parse (uvs [2]) - uvOffset]);  	vertexList.Add (vertexList [triangle [2]]);  	triangle [2] = unpackedUvs.Count - 1;  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: if (unpackedUvs [triangle [2]] == Vector2.Zero)  	unpackedUvs [triangle [2]] = uvList [int.Parse (uvs [2]) - uvOffset];  else {  	unpackedUvs.Add (uvList [int.Parse (uvs [2]) - uvOffset]);  	vertexList.Add (vertexList [triangle [2]]);  	triangle [2] = unpackedUvs.Count - 1;  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: if (unpackedUvs [triangle [2]] == Vector2.Zero)  	unpackedUvs [triangle [2]] = uvList [int.Parse (uvs [2]) - uvOffset];  else {  	unpackedUvs.Add (uvList [int.Parse (uvs [2]) - uvOffset]);  	vertexList.Add (vertexList [triangle [2]]);  	triangle [2] = unpackedUvs.Count - 1;  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: if (unpackedUvs [triangle [2]] == Vector2.Zero)  	unpackedUvs [triangle [2]] = uvList [int.Parse (uvs [2]) - uvOffset];  else {  	unpackedUvs.Add (uvList [int.Parse (uvs [2]) - uvOffset]);  	vertexList.Add (vertexList [triangle [2]]);  	triangle [2] = unpackedUvs.Count - 1;  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: if (unpackedUvs [triangle [2]] == Vector2.Zero)  	unpackedUvs [triangle [2]] = uvList [int.Parse (uvs [2]) - uvOffset];  else {  	unpackedUvs.Add (uvList [int.Parse (uvs [2]) - uvOffset]);  	vertexList.Add (vertexList [triangle [2]]);  	triangle [2] = unpackedUvs.Count - 1;  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: unpackedUvs [triangle [2]] = uvList [int.Parse (uvs [2]) - uvOffset];  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: unpackedUvs [triangle [2]] = uvList [int.Parse (uvs [2]) - uvOffset];  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: unpackedUvs.Add (uvList [int.Parse (uvs [2]) - uvOffset]);  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: vertexList.Add (vertexList [triangle [2]]);  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: triangle [2] = unpackedUvs.Count - 1;  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: triangleList.Add (triangle [2]);  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,UnpackFace,The following statement contains a magic number: triangleList.Add (int.Parse (indices [2]) - vertexOffset);  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,CalculateNormals,The following statement contains a magic number: for (int i = 0; i < elementData.Length / 3; i++) {  	int cornerA = elementData [i * 3];  	int cornerB = elementData [i * 3 + 1];  	int cornerC = elementData [i * 3 + 2];  	b1 = vertexData [cornerB] - vertexData [cornerA];  	b2 = vertexData [cornerC] - vertexData [cornerA];  	normal = Vector3.Cross (b1' b2).Normalize ();  	normalData [cornerA] += normal;  	normalData [cornerB] += normal;  	normalData [cornerC] += normal;  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,CalculateNormals,The following statement contains a magic number: for (int i = 0; i < elementData.Length / 3; i++) {  	int cornerA = elementData [i * 3];  	int cornerB = elementData [i * 3 + 1];  	int cornerC = elementData [i * 3 + 2];  	b1 = vertexData [cornerB] - vertexData [cornerA];  	b2 = vertexData [cornerC] - vertexData [cornerA];  	normal = Vector3.Cross (b1' b2).Normalize ();  	normalData [cornerA] += normal;  	normalData [cornerB] += normal;  	normalData [cornerC] += normal;  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,CalculateNormals,The following statement contains a magic number: for (int i = 0; i < elementData.Length / 3; i++) {  	int cornerA = elementData [i * 3];  	int cornerB = elementData [i * 3 + 1];  	int cornerC = elementData [i * 3 + 2];  	b1 = vertexData [cornerB] - vertexData [cornerA];  	b2 = vertexData [cornerC] - vertexData [cornerA];  	normal = Vector3.Cross (b1' b2).Normalize ();  	normalData [cornerA] += normal;  	normalData [cornerB] += normal;  	normalData [cornerC] += normal;  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,CalculateNormals,The following statement contains a magic number: for (int i = 0; i < elementData.Length / 3; i++) {  	int cornerA = elementData [i * 3];  	int cornerB = elementData [i * 3 + 1];  	int cornerC = elementData [i * 3 + 2];  	b1 = vertexData [cornerB] - vertexData [cornerA];  	b2 = vertexData [cornerC] - vertexData [cornerA];  	normal = Vector3.Cross (b1' b2).Normalize ();  	normalData [cornerA] += normal;  	normalData [cornerB] += normal;  	normalData [cornerC] += normal;  }  
Magic Number,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,CalculateNormals,The following statement contains a magic number: for (int i = 0; i < elementData.Length / 3; i++) {  	int cornerA = elementData [i * 3];  	int cornerB = elementData [i * 3 + 1];  	int cornerC = elementData [i * 3 + 2];  	b1 = vertexData [cornerB] - vertexData [cornerA];  	b2 = vertexData [cornerC] - vertexData [cornerA];  	normal = Vector3.Cross (b1' b2).Normalize ();  	normalData [cornerA] += normal;  	normalData [cornerB] += normal;  	normalData [cornerC] += normal;  }  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,Main,The following statement contains a magic number: camera = new Camera (new Vector3 (0' 0' 50)' Quaternion.Identity);  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,Main,The following statement contains a magic number: fontProgram ["ortho_matrix"].SetValue (Matrix4.CreateOrthographic (width' height' 0' 1000));  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnRenderFrame,The following statement contains a magic number: if (down)  	camera.MoveRelative (Vector3.UnitZ * deltaTime * 5);  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnRenderFrame,The following statement contains a magic number: camera.MoveRelative (Vector3.UnitZ * deltaTime * 5);  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnRenderFrame,The following statement contains a magic number: if (up)  	camera.MoveRelative (-Vector3.UnitZ * deltaTime * 5);  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnRenderFrame,The following statement contains a magic number: camera.MoveRelative (-Vector3.UnitZ * deltaTime * 5);  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnRenderFrame,The following statement contains a magic number: if (left)  	camera.MoveRelative (-Vector3.UnitX * deltaTime * 5);  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnRenderFrame,The following statement contains a magic number: camera.MoveRelative (-Vector3.UnitX * deltaTime * 5);  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnRenderFrame,The following statement contains a magic number: if (right)  	camera.MoveRelative (Vector3.UnitX * deltaTime * 5);  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnRenderFrame,The following statement contains a magic number: camera.MoveRelative (Vector3.UnitX * deltaTime * 5);  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnRenderFrame,The following statement contains a magic number: if (space)  	camera.MoveRelative (Vector3.UnitY * deltaTime * 3);  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnRenderFrame,The following statement contains a magic number: camera.MoveRelative (Vector3.UnitY * deltaTime * 3);  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnReshape,The following statement contains a magic number: fontProgram ["ortho_matrix"].SetValue (Matrix4.CreateOrthographic (width' height' 0' 1000));  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnReshape,The following statement contains a magic number: information.Position = new Vector2 (-width / 2 + 10' height / 2 - font.Height - 10);  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnReshape,The following statement contains a magic number: information.Position = new Vector2 (-width / 2 + 10' height / 2 - font.Height - 10);  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnReshape,The following statement contains a magic number: information.Position = new Vector2 (-width / 2 + 10' height / 2 - font.Height - 10);  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnReshape,The following statement contains a magic number: information.Position = new Vector2 (-width / 2 + 10' height / 2 - font.Height - 10);  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnKeyboardDown,The following statement contains a magic number: if (key == 'w')  	up = true;  else if (key == 's')  	down = true;  else if (key == 'd')  	right = true;  else if (key == 'a')  	left = true;  else if (key == ' ')  	space = true;  else if (key == 27)  	Glut.glutLeaveMainLoop ();  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnKeyboardDown,The following statement contains a magic number: if (key == 's')  	down = true;  else if (key == 'd')  	right = true;  else if (key == 'a')  	left = true;  else if (key == ' ')  	space = true;  else if (key == 27)  	Glut.glutLeaveMainLoop ();  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnKeyboardDown,The following statement contains a magic number: if (key == 'd')  	right = true;  else if (key == 'a')  	left = true;  else if (key == ' ')  	space = true;  else if (key == 27)  	Glut.glutLeaveMainLoop ();  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnKeyboardDown,The following statement contains a magic number: if (key == 'a')  	left = true;  else if (key == ' ')  	space = true;  else if (key == 27)  	Glut.glutLeaveMainLoop ();  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnKeyboardDown,The following statement contains a magic number: if (key == ' ')  	space = true;  else if (key == 27)  	Glut.glutLeaveMainLoop ();  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnKeyboardDown,The following statement contains a magic number: if (key == 27)  	Glut.glutLeaveMainLoop ();  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnKeyboardUp,The following statement contains a magic number: if (key == 'w')  	up = false;  else if (key == 's')  	down = false;  else if (key == 'd')  	right = false;  else if (key == 'a')  	left = false;  else if (key == ' ')  	space = false;  else if (key == 'q')  	wireframe = !wireframe;  else if (key == 'm')  	msaa = !msaa;  else if (key == 'f') {  	fullscreen = !fullscreen;  	if (fullscreen)  		Glut.glutFullScreen ();  	else {  		Glut.glutPositionWindow (0' 0);  		Glut.glutReshapeWindow (1280' 720);  	}  }  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnKeyboardUp,The following statement contains a magic number: if (key == 'w')  	up = false;  else if (key == 's')  	down = false;  else if (key == 'd')  	right = false;  else if (key == 'a')  	left = false;  else if (key == ' ')  	space = false;  else if (key == 'q')  	wireframe = !wireframe;  else if (key == 'm')  	msaa = !msaa;  else if (key == 'f') {  	fullscreen = !fullscreen;  	if (fullscreen)  		Glut.glutFullScreen ();  	else {  		Glut.glutPositionWindow (0' 0);  		Glut.glutReshapeWindow (1280' 720);  	}  }  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnKeyboardUp,The following statement contains a magic number: if (key == 's')  	down = false;  else if (key == 'd')  	right = false;  else if (key == 'a')  	left = false;  else if (key == ' ')  	space = false;  else if (key == 'q')  	wireframe = !wireframe;  else if (key == 'm')  	msaa = !msaa;  else if (key == 'f') {  	fullscreen = !fullscreen;  	if (fullscreen)  		Glut.glutFullScreen ();  	else {  		Glut.glutPositionWindow (0' 0);  		Glut.glutReshapeWindow (1280' 720);  	}  }  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnKeyboardUp,The following statement contains a magic number: if (key == 's')  	down = false;  else if (key == 'd')  	right = false;  else if (key == 'a')  	left = false;  else if (key == ' ')  	space = false;  else if (key == 'q')  	wireframe = !wireframe;  else if (key == 'm')  	msaa = !msaa;  else if (key == 'f') {  	fullscreen = !fullscreen;  	if (fullscreen)  		Glut.glutFullScreen ();  	else {  		Glut.glutPositionWindow (0' 0);  		Glut.glutReshapeWindow (1280' 720);  	}  }  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnKeyboardUp,The following statement contains a magic number: if (key == 'd')  	right = false;  else if (key == 'a')  	left = false;  else if (key == ' ')  	space = false;  else if (key == 'q')  	wireframe = !wireframe;  else if (key == 'm')  	msaa = !msaa;  else if (key == 'f') {  	fullscreen = !fullscreen;  	if (fullscreen)  		Glut.glutFullScreen ();  	else {  		Glut.glutPositionWindow (0' 0);  		Glut.glutReshapeWindow (1280' 720);  	}  }  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnKeyboardUp,The following statement contains a magic number: if (key == 'd')  	right = false;  else if (key == 'a')  	left = false;  else if (key == ' ')  	space = false;  else if (key == 'q')  	wireframe = !wireframe;  else if (key == 'm')  	msaa = !msaa;  else if (key == 'f') {  	fullscreen = !fullscreen;  	if (fullscreen)  		Glut.glutFullScreen ();  	else {  		Glut.glutPositionWindow (0' 0);  		Glut.glutReshapeWindow (1280' 720);  	}  }  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnKeyboardUp,The following statement contains a magic number: if (key == 'a')  	left = false;  else if (key == ' ')  	space = false;  else if (key == 'q')  	wireframe = !wireframe;  else if (key == 'm')  	msaa = !msaa;  else if (key == 'f') {  	fullscreen = !fullscreen;  	if (fullscreen)  		Glut.glutFullScreen ();  	else {  		Glut.glutPositionWindow (0' 0);  		Glut.glutReshapeWindow (1280' 720);  	}  }  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnKeyboardUp,The following statement contains a magic number: if (key == 'a')  	left = false;  else if (key == ' ')  	space = false;  else if (key == 'q')  	wireframe = !wireframe;  else if (key == 'm')  	msaa = !msaa;  else if (key == 'f') {  	fullscreen = !fullscreen;  	if (fullscreen)  		Glut.glutFullScreen ();  	else {  		Glut.glutPositionWindow (0' 0);  		Glut.glutReshapeWindow (1280' 720);  	}  }  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnKeyboardUp,The following statement contains a magic number: if (key == ' ')  	space = false;  else if (key == 'q')  	wireframe = !wireframe;  else if (key == 'm')  	msaa = !msaa;  else if (key == 'f') {  	fullscreen = !fullscreen;  	if (fullscreen)  		Glut.glutFullScreen ();  	else {  		Glut.glutPositionWindow (0' 0);  		Glut.glutReshapeWindow (1280' 720);  	}  }  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnKeyboardUp,The following statement contains a magic number: if (key == ' ')  	space = false;  else if (key == 'q')  	wireframe = !wireframe;  else if (key == 'm')  	msaa = !msaa;  else if (key == 'f') {  	fullscreen = !fullscreen;  	if (fullscreen)  		Glut.glutFullScreen ();  	else {  		Glut.glutPositionWindow (0' 0);  		Glut.glutReshapeWindow (1280' 720);  	}  }  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnKeyboardUp,The following statement contains a magic number: if (key == 'q')  	wireframe = !wireframe;  else if (key == 'm')  	msaa = !msaa;  else if (key == 'f') {  	fullscreen = !fullscreen;  	if (fullscreen)  		Glut.glutFullScreen ();  	else {  		Glut.glutPositionWindow (0' 0);  		Glut.glutReshapeWindow (1280' 720);  	}  }  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnKeyboardUp,The following statement contains a magic number: if (key == 'q')  	wireframe = !wireframe;  else if (key == 'm')  	msaa = !msaa;  else if (key == 'f') {  	fullscreen = !fullscreen;  	if (fullscreen)  		Glut.glutFullScreen ();  	else {  		Glut.glutPositionWindow (0' 0);  		Glut.glutReshapeWindow (1280' 720);  	}  }  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnKeyboardUp,The following statement contains a magic number: if (key == 'm')  	msaa = !msaa;  else if (key == 'f') {  	fullscreen = !fullscreen;  	if (fullscreen)  		Glut.glutFullScreen ();  	else {  		Glut.glutPositionWindow (0' 0);  		Glut.glutReshapeWindow (1280' 720);  	}  }  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnKeyboardUp,The following statement contains a magic number: if (key == 'm')  	msaa = !msaa;  else if (key == 'f') {  	fullscreen = !fullscreen;  	if (fullscreen)  		Glut.glutFullScreen ();  	else {  		Glut.glutPositionWindow (0' 0);  		Glut.glutReshapeWindow (1280' 720);  	}  }  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnKeyboardUp,The following statement contains a magic number: if (key == 'f') {  	fullscreen = !fullscreen;  	if (fullscreen)  		Glut.glutFullScreen ();  	else {  		Glut.glutPositionWindow (0' 0);  		Glut.glutReshapeWindow (1280' 720);  	}  }  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnKeyboardUp,The following statement contains a magic number: if (key == 'f') {  	fullscreen = !fullscreen;  	if (fullscreen)  		Glut.glutFullScreen ();  	else {  		Glut.glutPositionWindow (0' 0);  		Glut.glutReshapeWindow (1280' 720);  	}  }  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnKeyboardUp,The following statement contains a magic number: if (fullscreen)  	Glut.glutFullScreen ();  else {  	Glut.glutPositionWindow (0' 0);  	Glut.glutReshapeWindow (1280' 720);  }  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnKeyboardUp,The following statement contains a magic number: if (fullscreen)  	Glut.glutFullScreen ();  else {  	Glut.glutPositionWindow (0' 0);  	Glut.glutReshapeWindow (1280' 720);  }  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnKeyboardUp,The following statement contains a magic number: Glut.glutReshapeWindow (1280' 720);  
Magic Number,OpenGLTutorial16,Program,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\Program.cs,OnKeyboardUp,The following statement contains a magic number: Glut.glutReshapeWindow (1280' 720);  
Missing Default,OpenGLTutorial16,ObjMaterial,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjMaterial,The following switch statement is missing a default case: switch (split [0]) {  case "Ns":  	this.SpecularCoefficient = float.Parse (split [1]);  	break;  case "Ka":  	this.Ambient = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  	break;  case "Kd":  	this.Diffuse = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  	break;  case "Ks":  	this.Specular = new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3]));  	break;  case "d":  	this.Transparency = float.Parse (split [1]);  	break;  case "illum":  	this.Illumination = (IlluminationMode)int.Parse (split [1]);  	break;  case "map_Kd":  	if (File.Exists (lines [i].Split (new char[] {  		' '  	}' 2) [1]))  		this.DiffuseMap = new Texture (lines [i].Split (new char[] {  			' '  		}' 2) [1]);  	break;  }  
Missing Default,OpenGLTutorial16,ObjObject,D:\newReposJune17\giawa_opengl4tutorials\OpenGLTutorial16\OpenGLTutorial16\ObjLoader.cs,ObjObject,The following switch statement is missing a default case: switch (split [0]) {  case "o":  case "g":  	this.Name = lines [i].Substring (2);  	break;  case "v":  	vertexList.Add (new Vector3 (float.Parse (split [1])' float.Parse (split [2])' float.Parse (split [3])));  	break;  case "vt":  	uvList.Add (new Vector2 (float.Parse (split [1])' float.Parse (split [2])));  	break;  case "f":  	if (split.Length == 5)// this is a quad' so split it up  	 {  		string[] split1 = new string[] {  			split [0]'  			split [1]'  			split [2]'  			split [3]  		};  		UnpackFace (split1' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  		string[] split2 = new string[] {  			split [0]'  			split [1]'  			split [3]'  			split [4]  		};  		UnpackFace (split2' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  	} else  		UnpackFace (split' vertexOffset' uvOffset' vertexList' uvList' triangleList' unpackedUvs' normalsList);  	break;  case "usemtl":  	if (materials.ContainsKey (split [1]))  		Material = materials [split [1]];  	break;  }  
