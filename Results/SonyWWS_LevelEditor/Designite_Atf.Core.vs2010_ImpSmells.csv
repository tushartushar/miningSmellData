Implementation smell,Namespace,Class,File,Method,Description
Long Method,Sce.Atf.Dom,DomXmlReader,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Dom\DomXmlReader.cs,ReadElement,The method has 132 lines of code.
Long Method,Sce.Atf.Dom,AttributeType,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Dom\AttributeType.cs,Convert,The method has 161 lines of code.
Long Method,Sce.Atf.Dom,XmlSchemaTypeLoader,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Dom\XmlSchemaTypeLoader.cs,Load,The method has 155 lines of code.
Long Method,Sce.Atf.VectorMath,Box,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Box.cs,Intersects,The method has 137 lines of code.
Long Method,Sce.Atf.VectorMath,EulerAngles3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\EulerAngles.cs,CalculateMatrix,The method has 112 lines of code.
Complex Method,Sce.Atf,AtfVersion,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\AtfVersion.cs,GetVersion,Cyclomatic complexity of the method is 10
Complex Method,Sce.Atf,DependencySystem<T>,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\DependencySystem.cs,GetInvalidDependents,Cyclomatic complexity of the method is 12
Complex Method,Sce.Atf,Selection<T>,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Selection.cs,SetRange,Cyclomatic complexity of the method is 9
Complex Method,Sce.Atf,StringUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\StringUtil.cs,CompareNaturalOrder,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf,PathUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\PathUtil.cs,IsValidPath,Cyclomatic complexity of the method is 9
Complex Method,Sce.Atf.Dom,TransactionReporter,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Dom\TransactionReporter.cs,OnChildRemoved,Cyclomatic complexity of the method is 10
Complex Method,Sce.Atf.Dom,DomXmlWriter,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Dom\DomXmlWriter.cs,WriteAttributes,Cyclomatic complexity of the method is 10
Complex Method,Sce.Atf.Dom,DomXmlReader,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Dom\DomXmlReader.cs,ReadElement,Cyclomatic complexity of the method is 18
Complex Method,Sce.Atf.Dom,DomNodeSerializer,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Dom\DomNodeSerializer.cs,Deserialize,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Dom,NumericMaxRule,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Dom\NumericMaxRule.cs,Validate,Cyclomatic complexity of the method is 11
Complex Method,Sce.Atf.Dom,NumericMinRule,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Dom\NumericMinRule.cs,Validate,Cyclomatic complexity of the method is 11
Complex Method,Sce.Atf.Dom,UniquePathIdValidator,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Dom\UniquePathIdValidator.cs,RenameNodes,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Dom,DomNodeType,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Dom\DomNodeType.cs,FreezeExtensions,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Dom,XmlSchemaTypeLoader,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Dom\XmlSchemaTypeLoader.cs,Load,Cyclomatic complexity of the method is 31
Complex Method,Sce.Atf.Dom,XmlSchemaTypeLoader,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Dom\XmlSchemaTypeLoader.cs,GetAttributeType,Cyclomatic complexity of the method is 19
Complex Method,Sce.Atf.Dom,XmlSchemaTypeLoader,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Dom\XmlSchemaTypeLoader.cs,GetNodeType,Cyclomatic complexity of the method is 9
Complex Method,Sce.Atf.Dom,XmlSchemaTypeLoader,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Dom\XmlSchemaTypeLoader.cs,GetLocalTypeName,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Dom,XmlSchemaTypeLoader,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Dom\XmlSchemaTypeLoader.cs,GetRules,Cyclomatic complexity of the method is 13
Complex Method,Sce.Atf.Dom,XmlSchemaTypeLoader,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Dom\XmlSchemaTypeLoader.cs,MergeRedefinedTypeAnnotations,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.VectorMath,Box,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Box.cs,Intersects,Cyclomatic complexity of the method is 12
Complex Method,Sce.Atf.VectorMath,Frustum,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Frustum.cs,ContainsPolygon,Cyclomatic complexity of the method is 9
Complex Method,Sce.Atf.VectorMath,Ray3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Ray3F.cs,IntersectPolygon,Cyclomatic complexity of the method is 10
Long Parameter List,Sce.Atf,LiveConnectService,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\LiveConnectService.cs,GotMessage,The method has 6 parameters. Parameters: status' senderId' groupId' messageId' data' context
Long Parameter List,Sce.Atf,IntSet,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\IntSet.cs,FindRanges,The method has 5 parameters. Parameters: begin' end' rangeBeginIndex' rangeEndIndex' newRangeIndex
Long Parameter List,Sce.Atf,MathUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\MathUtil.cs,CatmullRomInterp,The method has 5 parameters. Parameters: p1' p2' p3' p4' t
Long Parameter List,Sce.Atf,MathUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\MathUtil.cs,HermiteInterp,The method has 5 parameters. Parameters: p1' tan1' p2' tan2' t
Long Parameter List,Sce.Atf,MathUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\MathUtil.cs,Remap,The method has 5 parameters. Parameters: value' min' max' newMin' newMax
Long Parameter List,Sce.Atf,PathUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\PathUtil.cs,PathRelativePathTo,The method has 5 parameters. Parameters: path' from' attrFrom' to' attrTo
Long Parameter List,Sce.Atf,Shell32,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Shell32.cs,SHGetFileInfo,The method has 5 parameters. Parameters: pszPath' dwFileAttributes' psfi' cbFileInfo' uFlags
Long Parameter List,Sce.Atf.Dom,DomNodeType,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Dom\DomNodeType.cs,DomNodeType,The method has 5 parameters. Parameters: name' baseType' attributes' children' extensions
Long Parameter List,Sce.Atf.VectorMath,Frustum,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Frustum.cs,Frustum,The method has 6 parameters. Parameters: right' left' top' bottom' near' far
Long Parameter List,Sce.Atf.VectorMath,Frustum,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Frustum.cs,SetOrtho,The method has 6 parameters. Parameters: right' left' top' bottom' near' far
Long Parameter List,Sce.Atf.VectorMath,Matrix3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix3F.cs,Matrix3F,The method has 9 parameters. Parameters: m00' m01' m02' m10' m11' m12' m20' m21' m22
Long Parameter List,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Matrix4F,The method has 16 parameters. Parameters: m11' m12' m13' m14' m21' m22' m23' m24' m31' m32' m33' m34' m41' m42' m43' m44
Long Parameter List,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Set,The method has 16 parameters. Parameters: m11' m12' m13' m14' m21' m22' m23' m24' m31' m32' m33' m34' m41' m42' m43' m44
Long Parameter List,Sce.Atf.VectorMath,Ray2F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Ray2F.cs,SlabIntersect,The method has 6 parameters. Parameters: direction' origin' min' max' tmin' tmax
Long Parameter List,Sce.Atf.VectorMath,Ray3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Ray3F.cs,IntersectPolygon,The method has 5 parameters. Parameters: vertices' intersectionPoint' nearestVert' normal' backFaceCull
Long Identifier,Sce.Atf.Adaptation,DomBindingAdapterObject,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Adaptation\BindingAdapterObject.cs,DomBindingAdapterObject,The length of the parameter enableNodeTypeExtensionOptimisation is 35.
Long Identifier,Sce.Atf.Dom,PropertyDescriptorQueryable,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\SearchAndReplace\DomNodePropertyPredicate.cs,,The length of the parameter m_propertyDescriptorCollection is 30.
Long Statement,Sce.Atf,LiveConnectService,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\LiveConnectService.cs,CommonInit,The length of the statement  "                    msg = "The Live Connect Service failed to initialize because Bonjour is either not installed or the Windows service' 'Bonjour Service'' is not running.".Localize(); " is 164.
Long Statement,Sce.Atf,LinqQueryPredicate,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\SearchAndReplace\LinqQueryPredicate.cs,AddStringSearchExpression,The length of the statement  "            MethodCallExpression regexMatchTest = Expression.Call(typeof(Regex)' "Match"' null' new Expression[3] { sourceStringExp' patternStringExp' optionsExp }); " is 153.
Long Statement,Sce.Atf,XmlStringLocalizer,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\XmlStringLocalizer.cs,AddLocalizedStrings,The length of the statement  "                throw new InvalidOperationException("Conflicting translations in a localized XML file: \n\t" + string.Join("\n\t"' duplicates)); " is 128.
Long Statement,Sce.Atf.Adaptation,BindingAdapterObject,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Adaptation\BindingAdapterObject.cs,GetDescriptorsFromBaseTypes,The length of the statement  "                        System.Diagnostics.Debug.WriteLine("Binding Adapter Warning: Ignoring multiple base types with the same simple name: " + baseType.Name); " is 136.
Long Statement,Sce.Atf.Dom,TransactionReporter,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Dom\TransactionReporter.cs,OnAttributeChanged,The length of the statement  "                var domNodeAndAttributeInfo = new Pair<DomNode' AttributeInfo>(attributeEventArgs.DomNode' attributeEventArgs.AttributeInfo); " is 125.
Long Statement,Sce.Atf.Dom,DomNodeNamePredicate,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\SearchAndReplace\DomNodeNamePredicate.cs,GetDomNodeProperties,The length of the statement  "            ICustomTypeDescriptor iCustomTypeDescriptor = node.GetAdapter(typeof(CustomTypeDescriptorNodeAdapter)) as ICustomTypeDescriptor; " is 128.
Long Statement,Sce.Atf.Dom,DomNodeNamePredicate,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\SearchAndReplace\DomNodeNamePredicate.cs,Replace,The length of the statement  "                queryMatch.SetValue(Regex.Replace(value' StringToMatch' replaceValue.ToString()' RegexOptions.IgnoreCase | RegexOptions.CultureInvariant)); " is 139.
Long Statement,Sce.Atf.Dom,DomNodePropertyPredicate,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\SearchAndReplace\DomNodePropertyPredicate.cs,GetQueryableElements,The length of the statement  "                ICustomTypeDescriptor iCustomTypeDescriptor = m_domNode.GetAdapter(typeof(ICustomTypeDescriptor)) as ICustomTypeDescriptor; " is 123.
Long Statement,Sce.Atf.Dom,DataValidator,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Dom\DataValidator.cs,OnChildInserted,The length of the statement  "                m_childChanges.Add(new Pair<Pair<DomNode' DomNode>' ChildInfo>(new Pair<DomNode' DomNode>(e.Parent' e.Child)' e.ChildInfo)); " is 124.
Long Statement,Sce.Atf.Dom,DataValidator,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Dom\DataValidator.cs,OnChildRemoved,The length of the statement  "                m_childChanges.Add(new Pair<Pair<DomNode' DomNode>' ChildInfo>(new Pair<DomNode' DomNode>(e.Parent' e.Child)' e.ChildInfo)); " is 124.
Long Statement,Sce.Atf.Dom,XmlSchemaTypeLoader,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Dom\XmlSchemaTypeLoader.cs,WalkParticle,The length of the statement  "                            throw new InvalidOperationException(string.Format("Schema element {0} cannot have both a default value and a fixed value"' element.QualifiedName)); " is 147.
Long Statement,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Invert,The length of the statement  "            float m11 = m.M23 * m.M34 * m.M42 - m.M24 * m.M33 * m.M42 + m.M24 * m.M32 * m.M43 - m.M22 * m.M34 * m.M43 - m.M23 * m.M32 * m.M44 + m.M22 * m.M33 * m.M44; " is 154.
Long Statement,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Invert,The length of the statement  "            float m12 = m.M14 * m.M33 * m.M42 - m.M13 * m.M34 * m.M42 - m.M14 * m.M32 * m.M43 + m.M12 * m.M34 * m.M43 + m.M13 * m.M32 * m.M44 - m.M12 * m.M33 * m.M44; " is 154.
Long Statement,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Invert,The length of the statement  "            float m13 = m.M13 * m.M24 * m.M42 - m.M14 * m.M23 * m.M42 + m.M14 * m.M22 * m.M43 - m.M12 * m.M24 * m.M43 - m.M13 * m.M22 * m.M44 + m.M12 * m.M23 * m.M44; " is 154.
Long Statement,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Invert,The length of the statement  "            float m14 = m.M14 * m.M23 * m.M32 - m.M13 * m.M24 * m.M32 - m.M14 * m.M22 * m.M33 + m.M12 * m.M24 * m.M33 + m.M13 * m.M22 * m.M34 - m.M12 * m.M23 * m.M34; " is 154.
Long Statement,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Invert,The length of the statement  "            float m21 = m.M24 * m.M33 * m.M41 - m.M23 * m.M34 * m.M41 - m.M24 * m.M31 * m.M43 + m.M21 * m.M34 * m.M43 + m.M23 * m.M31 * m.M44 - m.M21 * m.M33 * m.M44; " is 154.
Long Statement,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Invert,The length of the statement  "            float m22 = m.M13 * m.M34 * m.M41 - m.M14 * m.M33 * m.M41 + m.M14 * m.M31 * m.M43 - m.M11 * m.M34 * m.M43 - m.M13 * m.M31 * m.M44 + m.M11 * m.M33 * m.M44; " is 154.
Long Statement,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Invert,The length of the statement  "            float m23 = m.M14 * m.M23 * m.M41 - m.M13 * m.M24 * m.M41 - m.M14 * m.M21 * m.M43 + m.M11 * m.M24 * m.M43 + m.M13 * m.M21 * m.M44 - m.M11 * m.M23 * m.M44; " is 154.
Long Statement,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Invert,The length of the statement  "            float m24 = m.M13 * m.M24 * m.M31 - m.M14 * m.M23 * m.M31 + m.M14 * m.M21 * m.M33 - m.M11 * m.M24 * m.M33 - m.M13 * m.M21 * m.M34 + m.M11 * m.M23 * m.M34; " is 154.
Long Statement,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Invert,The length of the statement  "            float m31 = m.M22 * m.M34 * m.M41 - m.M24 * m.M32 * m.M41 + m.M24 * m.M31 * m.M42 - m.M21 * m.M34 * m.M42 - m.M22 * m.M31 * m.M44 + m.M21 * m.M32 * m.M44; " is 154.
Long Statement,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Invert,The length of the statement  "            float m32 = m.M14 * m.M32 * m.M41 - m.M12 * m.M34 * m.M41 - m.M14 * m.M31 * m.M42 + m.M11 * m.M34 * m.M42 + m.M12 * m.M31 * m.M44 - m.M11 * m.M32 * m.M44; " is 154.
Long Statement,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Invert,The length of the statement  "            float m33 = m.M12 * m.M24 * m.M41 - m.M14 * m.M22 * m.M41 + m.M14 * m.M21 * m.M42 - m.M11 * m.M24 * m.M42 - m.M12 * m.M21 * m.M44 + m.M11 * m.M22 * m.M44; " is 154.
Long Statement,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Invert,The length of the statement  "            float m34 = m.M14 * m.M22 * m.M31 - m.M12 * m.M24 * m.M31 - m.M14 * m.M21 * m.M32 + m.M11 * m.M24 * m.M32 + m.M12 * m.M21 * m.M34 - m.M11 * m.M22 * m.M34; " is 154.
Long Statement,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Invert,The length of the statement  "            float m41 = m.M23 * m.M32 * m.M41 - m.M22 * m.M33 * m.M41 - m.M23 * m.M31 * m.M42 + m.M21 * m.M33 * m.M42 + m.M22 * m.M31 * m.M43 - m.M21 * m.M32 * m.M43; " is 154.
Long Statement,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Invert,The length of the statement  "            float m42 = m.M12 * m.M33 * m.M41 - m.M13 * m.M32 * m.M41 + m.M13 * m.M31 * m.M42 - m.M11 * m.M33 * m.M42 - m.M12 * m.M31 * m.M43 + m.M11 * m.M32 * m.M43; " is 154.
Long Statement,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Invert,The length of the statement  "            float m43 = m.M13 * m.M22 * m.M41 - m.M12 * m.M23 * m.M41 - m.M13 * m.M21 * m.M42 + m.M11 * m.M23 * m.M42 + m.M12 * m.M21 * m.M43 - m.M11 * m.M22 * m.M43; " is 154.
Long Statement,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Invert,The length of the statement  "            float m44 = m.M12 * m.M23 * m.M31 - m.M13 * m.M22 * m.M31 + m.M13 * m.M21 * m.M32 - m.M11 * m.M23 * m.M32 - m.M12 * m.M21 * m.M33 + m.M11 * m.M22 * m.M33; " is 154.
Complex Conditional,Sce.Atf,UniqueNamer,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\UniqueNamer.cs,UniqueNamer,The conditional expression  "suffixSeparator != ' ' &&                  suffixSeparator != '-' &&                  suffixSeparator != '_' &&                  suffixSeparator != '/' &&                  suffixSeparator != '\\' &&                  suffixSeparator != '('"  is complex.
Complex Conditional,Sce.Atf.VectorMath,Polygon3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Polygon3F.cs,IsEar,The conditional expression  "v.IsReflex && v != v0 && v != v1 && v != v2"  is complex.
Virtual Method Call from Constructor,Sce.Atf.Dom,DomNode,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Dom\DomNode.cs,DomNode,The constructor "DomNode" calls a virtual method "Create".
Empty Catch Block,Sce.Atf,FileMoveService,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\FileMoveService.cs,ClearDirectory,The method has an empty catch block.
Empty Catch Block,Sce.Atf,FileMoveService,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\FileMoveService.cs,ClearDirectory,The method has an empty catch block.
Magic Number,Sce.Atf,NumericUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\NumericUtil.cs,IsZero,The following statement contains a magic number: return Math.Abs(value) < 2.2204460492503131E-15;
Magic Number,Sce.Atf,NumericUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\NumericUtil.cs,AreClose,The following statement contains a magic number: double a = (Math.Abs(left) + Math.Abs(right) + 10.0) * 2.2204460492503131E-16;
Magic Number,Sce.Atf,NumericUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\NumericUtil.cs,AreClose,The following statement contains a magic number: double a = (Math.Abs(left) + Math.Abs(right) + 10.0) * 2.2204460492503131E-16;
Magic Number,Sce.Atf,LinqQueryPredicate,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\SearchAndReplace\LinqQueryPredicate.cs,AddStringSearchExpression,The following statement contains a magic number: MethodCallExpression regexMatchTest = Expression.Call(typeof(Regex)' "Match"' null' new Expression[3] { sourceStringExp' patternStringExp' optionsExp });
Magic Number,Sce.Atf,EnumUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\EnumUtil.cs,ParseFlagDefinitions,The following statement contains a magic number: for (int i = 0; i < flagDefinitions.Length; i++)              {                  string displayName;                  names[i] = ParseDefinition(flagDefinitions[i]' out displayName' ref flagValue);                  displayNames[i] = displayName;                    values[i] = flagValue;                  flagValue *= 2;              }
Magic Number,Sce.Atf,EnumUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\EnumUtil.cs,ParseDefinition,The following statement contains a magic number: if (sections.Length == 1)              {                  displayName = name;              }              else if (sections.Length == 2)              {                  // e.g.' "A=2"                  displayName = name;                  value = int.Parse(sections[1]);              }              else if (sections.Length == 3)              {                  // e.g.' "A==Big A"                  displayName = sections[2];              }              else if (sections.Length == 4)              {                  // e.g.' "A==Big A=2"                  displayName = sections[2];                  value = int.Parse(sections[3]);              }              else                  throw new FormatException(string.Format("This enum or flag definition is bad:{0}"' definition));
Magic Number,Sce.Atf,EnumUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\EnumUtil.cs,ParseDefinition,The following statement contains a magic number: if (sections.Length == 1)              {                  displayName = name;              }              else if (sections.Length == 2)              {                  // e.g.' "A=2"                  displayName = name;                  value = int.Parse(sections[1]);              }              else if (sections.Length == 3)              {                  // e.g.' "A==Big A"                  displayName = sections[2];              }              else if (sections.Length == 4)              {                  // e.g.' "A==Big A=2"                  displayName = sections[2];                  value = int.Parse(sections[3]);              }              else                  throw new FormatException(string.Format("This enum or flag definition is bad:{0}"' definition));
Magic Number,Sce.Atf,EnumUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\EnumUtil.cs,ParseDefinition,The following statement contains a magic number: if (sections.Length == 1)              {                  displayName = name;              }              else if (sections.Length == 2)              {                  // e.g.' "A=2"                  displayName = name;                  value = int.Parse(sections[1]);              }              else if (sections.Length == 3)              {                  // e.g.' "A==Big A"                  displayName = sections[2];              }              else if (sections.Length == 4)              {                  // e.g.' "A==Big A=2"                  displayName = sections[2];                  value = int.Parse(sections[3]);              }              else                  throw new FormatException(string.Format("This enum or flag definition is bad:{0}"' definition));
Magic Number,Sce.Atf,EnumUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\EnumUtil.cs,ParseDefinition,The following statement contains a magic number: if (sections.Length == 1)              {                  displayName = name;              }              else if (sections.Length == 2)              {                  // e.g.' "A=2"                  displayName = name;                  value = int.Parse(sections[1]);              }              else if (sections.Length == 3)              {                  // e.g.' "A==Big A"                  displayName = sections[2];              }              else if (sections.Length == 4)              {                  // e.g.' "A==Big A=2"                  displayName = sections[2];                  value = int.Parse(sections[3]);              }              else                  throw new FormatException(string.Format("This enum or flag definition is bad:{0}"' definition));
Magic Number,Sce.Atf,EnumUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\EnumUtil.cs,ParseDefinition,The following statement contains a magic number: if (sections.Length == 1)              {                  displayName = name;              }              else if (sections.Length == 2)              {                  // e.g.' "A=2"                  displayName = name;                  value = int.Parse(sections[1]);              }              else if (sections.Length == 3)              {                  // e.g.' "A==Big A"                  displayName = sections[2];              }              else if (sections.Length == 4)              {                  // e.g.' "A==Big A=2"                  displayName = sections[2];                  value = int.Parse(sections[3]);              }              else                  throw new FormatException(string.Format("This enum or flag definition is bad:{0}"' definition));
Magic Number,Sce.Atf,EnumUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\EnumUtil.cs,ParseDefinition,The following statement contains a magic number: if (sections.Length == 1)              {                  displayName = name;              }              else if (sections.Length == 2)              {                  // e.g.' "A=2"                  displayName = name;                  value = int.Parse(sections[1]);              }              else if (sections.Length == 3)              {                  // e.g.' "A==Big A"                  displayName = sections[2];              }              else if (sections.Length == 4)              {                  // e.g.' "A==Big A=2"                  displayName = sections[2];                  value = int.Parse(sections[3]);              }              else                  throw new FormatException(string.Format("This enum or flag definition is bad:{0}"' definition));
Magic Number,Sce.Atf,IntSet,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\IntSet.cs,FindRange,The following statement contains a magic number: while (low <= high)              {                  int middle = (low + high) / 2;                  Range range = m_ranges[middle];                    if (range.Contains(value))                  {                      return middle;                  }                  else if (range.Min > value)                  {                      high = middle - 1;                  }                  else if (range.Max < value)                  {                      low = middle + 1;                  }                  else                  {                      return -middle;                  }              }
Magic Number,Sce.Atf,MathUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\MathUtil.cs,LogBase2,The following statement contains a magic number: int bitFieldRight16 = bitField >> 16;
Magic Number,Sce.Atf,MathUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\MathUtil.cs,LogBase2,The following statement contains a magic number: int bitFieldRight24 = bitField >> 24;
Magic Number,Sce.Atf,MathUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\MathUtil.cs,LogBase2,The following statement contains a magic number: int bitFieldRight8 = bitField >> 8;
Magic Number,Sce.Atf,MathUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\MathUtil.cs,LogBase2,The following statement contains a magic number: if (bitFieldRight16 > 0)              {                  if (bitFieldRight24 > 0)                      result = 24 + s_logBase2Table[bitFieldRight24];                  else                      result = 16 + s_logBase2Table[bitFieldRight16 & 0xFF];              }              else              {                  if (bitFieldRight8 > 0)                      result = 8 + s_logBase2Table[bitFieldRight8];                  else                      result = s_logBase2Table[bitField];              }
Magic Number,Sce.Atf,MathUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\MathUtil.cs,LogBase2,The following statement contains a magic number: if (bitFieldRight16 > 0)              {                  if (bitFieldRight24 > 0)                      result = 24 + s_logBase2Table[bitFieldRight24];                  else                      result = 16 + s_logBase2Table[bitFieldRight16 & 0xFF];              }              else              {                  if (bitFieldRight8 > 0)                      result = 8 + s_logBase2Table[bitFieldRight8];                  else                      result = s_logBase2Table[bitField];              }
Magic Number,Sce.Atf,MathUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\MathUtil.cs,LogBase2,The following statement contains a magic number: if (bitFieldRight16 > 0)              {                  if (bitFieldRight24 > 0)                      result = 24 + s_logBase2Table[bitFieldRight24];                  else                      result = 16 + s_logBase2Table[bitFieldRight16 & 0xFF];              }              else              {                  if (bitFieldRight8 > 0)                      result = 8 + s_logBase2Table[bitFieldRight8];                  else                      result = s_logBase2Table[bitField];              }
Magic Number,Sce.Atf,MathUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\MathUtil.cs,Snap,The following statement contains a magic number: const double MinFraction = 1.0 / (double.MaxValue / 2);
Magic Number,Sce.Atf,MathUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\MathUtil.cs,Snap,The following statement contains a magic number: if (Math.Abs(result) * MinFraction < step) // safe to divide?              {                  result = result / step;                  result = Math.Floor(result + 0.5);                  result = result * step;              }
Magic Number,Sce.Atf,MathUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\MathUtil.cs,Snap,The following statement contains a magic number: if (x >= 0)                  result = x + step / 2;              else                  result = x - step / 2;
Magic Number,Sce.Atf,MathUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\MathUtil.cs,Snap,The following statement contains a magic number: if (x >= 0)                  result = x + step / 2;              else                  result = x - step / 2;
Magic Number,Sce.Atf,MathUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\MathUtil.cs,HermiteInterp,The following statement contains a magic number: return                  (2 * tCubed - 3 * tSquared + 1) * p1 +                  (tCubed - 2 * tSquared + t) * tan1 +                  (-2 * tCubed + 3 * tSquared) * p2 +                  (tCubed - tSquared) * tan2;
Magic Number,Sce.Atf,MathUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\MathUtil.cs,HermiteInterp,The following statement contains a magic number: return                  (2 * tCubed - 3 * tSquared + 1) * p1 +                  (tCubed - 2 * tSquared + t) * tan1 +                  (-2 * tCubed + 3 * tSquared) * p2 +                  (tCubed - tSquared) * tan2;
Magic Number,Sce.Atf,MathUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\MathUtil.cs,HermiteInterp,The following statement contains a magic number: return                  (2 * tCubed - 3 * tSquared + 1) * p1 +                  (tCubed - 2 * tSquared + t) * tan1 +                  (-2 * tCubed + 3 * tSquared) * p2 +                  (tCubed - tSquared) * tan2;
Magic Number,Sce.Atf,MathUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\MathUtil.cs,HermiteInterp,The following statement contains a magic number: return                  (2 * tCubed - 3 * tSquared + 1) * p1 +                  (tCubed - 2 * tSquared + t) * tan1 +                  (-2 * tCubed + 3 * tSquared) * p2 +                  (tCubed - tSquared) * tan2;
Magic Number,Sce.Atf,MathUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\MathUtil.cs,HermiteInterp,The following statement contains a magic number: return                  (2 * tCubed - 3 * tSquared + 1) * p1 +                  (tCubed - 2 * tSquared + t) * tan1 +                  (-2 * tCubed + 3 * tSquared) * p2 +                  (tCubed - tSquared) * tan2;
Magic Number,Sce.Atf,MathUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\MathUtil.cs,MathUtil,The following statement contains a magic number: s_logBase2Table = new byte[256];
Magic Number,Sce.Atf,MathUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\MathUtil.cs,MathUtil,The following statement contains a magic number: for (int i = 2; i < 256; i++)                  s_logBase2Table[i] = (byte)(1 + s_logBase2Table[i / 2]);
Magic Number,Sce.Atf,MathUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\MathUtil.cs,MathUtil,The following statement contains a magic number: for (int i = 2; i < 256; i++)                  s_logBase2Table[i] = (byte)(1 + s_logBase2Table[i / 2]);
Magic Number,Sce.Atf,MathUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\MathUtil.cs,MathUtil,The following statement contains a magic number: for (int i = 2; i < 256; i++)                  s_logBase2Table[i] = (byte)(1 + s_logBase2Table[i / 2]);
Magic Number,Sce.Atf,Kernel32,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Kernel32.cs,GetPhysicalMemoryMB,The following statement contains a magic number: return (int)(memoryStatus.ullTotalPhys / (1024 * 1024));
Magic Number,Sce.Atf,Kernel32,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Kernel32.cs,GetPhysicalMemoryMB,The following statement contains a magic number: return (int)(memoryStatus.ullTotalPhys / (1024 * 1024));
Magic Number,Sce.Atf,PathUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\PathUtil.cs,GetCanonicalPath,The following statement contains a magic number: string drive = path.Substring(0' 2);
Magic Number,Sce.Atf,PathUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\PathUtil.cs,GetCanonicalPath,The following statement contains a magic number: StringBuilder sb = new StringBuilder(256);
Magic Number,Sce.Atf,PathUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\PathUtil.cs,GetCanonicalPath,The following statement contains a magic number: Kernel32.QueryDosDeviceW(drive' sb' 256);
Magic Number,Sce.Atf,PathUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\PathUtil.cs,GetCanonicalPath,The following statement contains a magic number: if (device.StartsWith(cSubstDrivePrefix))              {                  path = device.Substring(cSubstDrivePrefix.Length) + path.Substring(2);              }
Magic Number,Sce.Atf.Dom,AttributeType,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Dom\AttributeType.cs,GetUnescapedChar,The following statement contains a magic number: if (s[index] == '\\' &&                  index + 1 < s.Length &&                  s[index+1] == '"')              {                  result = '"';                  index += 2;                  return true;              }
Magic Number,Sce.Atf.Dom,StringIndex,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Dom\DomNodeType.cs,StringIndex,The following statement contains a magic number: if (m_strings.Length >= 2)                  {                      string prev = m_strings[0].String;                      for (i = 1; i < m_strings.Length; i++)                      {                          string curr = m_strings[i].String;                          if (curr.Equals(prev))                              m_strings[i].Duplicate = true;                            prev = curr;                      }                  }
Magic Number,Sce.Atf.Dom,StringIndex,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Dom\DomNodeType.cs,FindIndex,The following statement contains a magic number: while (lo != hi)                  {                      int mid = (lo + hi) / 2;                      int compare = m_strings[mid].String.CompareTo(searchString);                      if (compare < 0)                      {                          lo = mid + 1;                      }                      else if (compare > 0)                      {                          hi = mid;                      }                      else                      {                          // Duplicate FieldMetaData names are acceptable when searching using the method                          //  DomNode.GetExtension(ExtensionInfo)' but not when searching by the name.                          // See this tracker item: http://sf.ship.scea.com/sf/go/artf38078                          if (m_strings[mid].Duplicate)                              throw new InvalidOperationException(                                  "FieldMetaData named '" + searchString + "' was not unique on its DomNodeType");                            return m_strings[mid].Index;                      }                  }
Magic Number,Sce.Atf.Dom,XmlSchemaTypeLoader,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Dom\XmlSchemaTypeLoader.cs,Load,The following statement contains a magic number: try              {                  m_annotations = new Dictionary<NamedMetadata' IList<XmlNode>>();                  m_typeNameSet = new HashSet<string>();                  m_localElementSet = new Dictionary<XmlSchemaElement' XmlQualifiedName>();                  // collect global element & type names so we do not generate local type names that collides with those                  foreach (XmlSchemaElement element in schemaSet.GlobalElements.Values)                      m_typeNameSet.Add(element.QualifiedName.Name);                    foreach (XmlSchemaType type in schemaSet.GlobalTypes.Values)                  {                      if (type is XmlSchemaComplexType)                      {                          m_typeNameSet.Add(type.Name);                      }                  }                    var substitutionGroups = new Multimap<XmlQualifiedName' ChildInfo>();                    // Get types reachable from global elements                  foreach (XmlSchemaElement element in schemaSet.GlobalElements.Values)                  {                      XmlSchemaType type = element.ElementSchemaType;                      DomNodeType nodeType = GetNodeType(type' element);                      ChildInfo childInfo = new ChildInfo(GetFieldName(element.QualifiedName)' nodeType);                      m_annotations.Add(childInfo' GetAnnotation(element));                        // Keep list of substitution groups                      if (!element.SubstitutionGroup.IsEmpty)                      {                          substitutionGroups.Add(element.SubstitutionGroup' childInfo);                      }                        // only add root elements once; root element names must be globally unique                      string name = element.QualifiedName.ToString();                      if (!m_rootElements.ContainsKey(name))                      {                          m_rootElements[name] = childInfo;                      }                  }                    // Get global complex type definitions                  foreach (XmlSchemaType type in schemaSet.GlobalTypes.Values)                  {                      if (type is XmlSchemaComplexType)                      {                          GetNodeType(type' null);                      }                  }                    // Parse substitution groups                  foreach (var kvp in m_refElements)                  {                      XmlQualifiedName refName = kvp.Value;                      ChildInfo childInfo = kvp.Key;                        var substitutions = CreateSubstitutions(substitutionGroups' refName).ToArray();                      if (substitutions.Length > 0)                      {                          childInfo.AddRule(new SubstitutionGroupChildRule(substitutions));                      }                  }                    // Preserve annotation from any types that were redefined                  foreach (XmlSchema schema in schemas)                  {                      foreach (XmlSchemaObject schemaInclude in schema.Includes)                      {                          XmlSchemaRedefine schemaRedefine = schemaInclude as XmlSchemaRedefine;                          if (schemaRedefine != null)                              MergeRedefinedTypeAnnotations(schemaRedefine);                      }                  }                    // Sort DomNodeTypes' so that base types are always before derived types                  // Bucket sort by depth in the inheritance tree                   // Time: O(n * d) with n = number of DomNodeTypes' d = depth of inheritance tree                  var sortedTypes = new List<List<DomNodeType>>();                  foreach (DomNodeType type in GetNodeTypes())                  {                      // Get inheritance depth of current type                      int depth = 0;                      DomNodeType curType = type;                      while (curType != null && curType != DomNodeType.BaseOfAllTypes)                      {                          depth++;                          curType = curType.BaseType;                      }                        // We don't need to merge annotations for BaseAllTypes (level 0)                      // and its immediate child types (level 1)                      int idx = depth - 2;                      if (idx >= 0)                      {                          while (sortedTypes.Count <= idx)                              sortedTypes.Add(new List<DomNodeType>());                          sortedTypes[idx].Add(type);                      }                  }                    // Merge type annotations with base type annotations                  foreach (var list in sortedTypes)                  {                      foreach (DomNodeType type in list)                      {                          if (type.BaseType != null && type.BaseType != DomNodeType.BaseOfAllTypes)                          {                              IList<XmlNode> baseAnnotations;                              IList<XmlNode> annotations;                              if (m_annotations.TryGetValue(type.BaseType' out baseAnnotations)                                  && m_annotations.TryGetValue(type' out annotations))                              {                                  // Call protected virtual merge method - allowing clients to define if & how annotations are being merged                                  IEnumerable<XmlNode> mergedAnnotations = MergeInheritedTypeAnnotations(baseAnnotations' annotations);                                  m_annotations[type] = mergedAnnotations as IList<XmlNode> ?? mergedAnnotations.ToList();                              }                          }                      }                  }                    // Call before the DomNodeTypes are frozen. Note that iterating through Attributes or                  //  calling 'SetIdAttribute' freezes the attributes on DomNodeType.                  OnSchemaSetLoaded(schemaSet);                    // Set up ID attributes where xs:ID has been specified                  foreach (DomNodeType nodeType in GetNodeTypes())                  {                      foreach (var attribute in nodeType.Attributes.OfType<XmlAttributeInfo>())                      {                          if (((XmlAttributeType)attribute.Type).XmlTypeCode == XmlTypeCode.Id)                              nodeType.SetIdAttribute(attribute.Name);                      }                  }                    // Attach annotation as metadata to the associated type so that other classes can find it                  foreach (var keyValuePair in m_annotations)                  {                      if (keyValuePair.Value.Count > 0)                      {                          keyValuePair.Key.SetTag<IEnumerable<XmlNode>>(keyValuePair.Value);                       }                  }                  ParseAnnotations(schemaSet' m_annotations);                    // Call this after the ID attributes have been set and after the DomNodeTypes are frozen.                  OnDomNodeTypesFrozen(schemaSet);              }              finally              {                  m_annotations = null;                  m_typeNameSet = null;                  m_localElementSet = null;              }
Magic Number,Sce.Atf.Rendering,DomNodeUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Rendering\DomNodeUtil.cs,GetSphere,The following statement contains a magic number: if (value != null)              {                  s.Center = new Vec3F(value[0]' value[1]' value[2]);                  s.Radius = value[3];              }
Magic Number,Sce.Atf.Rendering,DomNodeUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Rendering\DomNodeUtil.cs,GetSphere,The following statement contains a magic number: if (value != null)              {                  s.Center = new Vec3F(value[0]' value[1]' value[2]);                  s.Radius = value[3];              }
Magic Number,Sce.Atf.Rendering,DomNodeUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Rendering\DomNodeUtil.cs,SetSphere,The following statement contains a magic number: float[] value = new float[4];
Magic Number,Sce.Atf.Rendering,DomNodeUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Rendering\DomNodeUtil.cs,SetSphere,The following statement contains a magic number: value[2] = s.Center.Z;
Magic Number,Sce.Atf.Rendering,DomNodeUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Rendering\DomNodeUtil.cs,SetSphere,The following statement contains a magic number: value[3] = s.Radius;
Magic Number,Sce.Atf.Rendering,DomNodeUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Rendering\DomNodeUtil.cs,GetBox,The following statement contains a magic number: if (value != null)              {                  return new Box(new Vec3F(value[0]' value[1]' value[2])'                                 new Vec3F(value[3]' value[4]' value[5]));              }              else return new Box();
Magic Number,Sce.Atf.Rendering,DomNodeUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Rendering\DomNodeUtil.cs,GetBox,The following statement contains a magic number: if (value != null)              {                  return new Box(new Vec3F(value[0]' value[1]' value[2])'                                 new Vec3F(value[3]' value[4]' value[5]));              }              else return new Box();
Magic Number,Sce.Atf.Rendering,DomNodeUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Rendering\DomNodeUtil.cs,GetBox,The following statement contains a magic number: if (value != null)              {                  return new Box(new Vec3F(value[0]' value[1]' value[2])'                                 new Vec3F(value[3]' value[4]' value[5]));              }              else return new Box();
Magic Number,Sce.Atf.Rendering,DomNodeUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Rendering\DomNodeUtil.cs,GetBox,The following statement contains a magic number: if (value != null)              {                  return new Box(new Vec3F(value[0]' value[1]' value[2])'                                 new Vec3F(value[3]' value[4]' value[5]));              }              else return new Box();
Magic Number,Sce.Atf.Rendering,DomNodeUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Rendering\DomNodeUtil.cs,SetBox,The following statement contains a magic number: float[] value = new float[6];
Magic Number,Sce.Atf.Rendering,DomNodeUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Rendering\DomNodeUtil.cs,SetBox,The following statement contains a magic number: value[2] = b.Min.Z;
Magic Number,Sce.Atf.Rendering,DomNodeUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Rendering\DomNodeUtil.cs,SetBox,The following statement contains a magic number: value[3] = b.Max.X;
Magic Number,Sce.Atf.Rendering,DomNodeUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Rendering\DomNodeUtil.cs,SetBox,The following statement contains a magic number: value[4] = b.Max.Y;
Magic Number,Sce.Atf.Rendering,DomNodeUtil,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Rendering\DomNodeUtil.cs,SetBox,The following statement contains a magic number: value[5] = b.Max.Z;
Magic Number,Sce.Atf.VectorMath,AngleAxisF,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\AngleAxisF.cs,Set,The following statement contains a magic number: if (mag > EPS)              {                  mag = Math.Sqrt(mag);                    double sin = 0.5 * mag;                  double cos = 0.5 * (m.M11 + m.M22 + m.M33 - 1.0);                  Angle = (float)Math.Atan2(sin' cos);                    double ooMag = 1.0 / mag;                  Axis.X = (float)(x * ooMag);                  Axis.Y = (float)(y * ooMag);                  Axis.Z = (float)(z * ooMag);              }              else              {                  Axis.X = 0;                  Axis.Y = 1;                  Axis.Z = 0;                  Angle = 0;              }
Magic Number,Sce.Atf.VectorMath,AngleAxisF,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\AngleAxisF.cs,Set,The following statement contains a magic number: if (mag > EPS)              {                  mag = Math.Sqrt(mag);                    double sin = 0.5 * mag;                  double cos = 0.5 * (m.M11 + m.M22 + m.M33 - 1.0);                  Angle = (float)Math.Atan2(sin' cos);                    double ooMag = 1.0 / mag;                  Axis.X = (float)(x * ooMag);                  Axis.Y = (float)(y * ooMag);                  Axis.Z = (float)(z * ooMag);              }              else              {                  Axis.X = 0;                  Axis.Y = 1;                  Axis.Z = 0;                  Angle = 0;              }
Magic Number,Sce.Atf.VectorMath,AngleAxisF,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\AngleAxisF.cs,Set,The following statement contains a magic number: if (mag > EPS)              {                  mag = Math.Sqrt(mag);                  double ooMag = 1.0 / mag;                    Axis.X = (float)(q.X * ooMag);                  Axis.Y = (float)(q.Y * ooMag);                  Axis.Z = (float)(q.Z * ooMag);                  Angle = (float)(2.0 * Math.Atan2(mag' q.W));              }              else              {                  Axis.X = 0;                  Axis.Y = 1;                  Axis.Z = 0;                  Angle = 0;              }
Magic Number,Sce.Atf.VectorMath,AngleAxisF,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\AngleAxisF.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + Angle.GetHashCode();
Magic Number,Sce.Atf.VectorMath,AngleAxisF,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\AngleAxisF.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + Axis.GetHashCode();
Magic Number,Sce.Atf.VectorMath,AngleAxisF,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\AngleAxisF.cs,GetHashCode,The following statement contains a magic number: return (int)(bits ^ (bits >> 32));
Magic Number,Sce.Atf.VectorMath,BezierCurve,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\BezierCurve.cs,BezierCurve,The following statement contains a magic number: m_coefficients = new Vec3F[3];
Magic Number,Sce.Atf.VectorMath,BezierCurve,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\BezierCurve.cs,BezierCurve,The following statement contains a magic number: m_coefficients[2] = 3.0f * (m_ctrlPoints[1] - m_ctrlPoints[0]);
Magic Number,Sce.Atf.VectorMath,BezierCurve,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\BezierCurve.cs,BezierCurve,The following statement contains a magic number: m_coefficients[1] = 3.0f * (m_ctrlPoints[2] - m_ctrlPoints[1]) - m_coefficients[2];
Magic Number,Sce.Atf.VectorMath,BezierCurve,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\BezierCurve.cs,BezierCurve,The following statement contains a magic number: m_coefficients[1] = 3.0f * (m_ctrlPoints[2] - m_ctrlPoints[1]) - m_coefficients[2];
Magic Number,Sce.Atf.VectorMath,BezierCurve,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\BezierCurve.cs,BezierCurve,The following statement contains a magic number: m_coefficients[0] = m_ctrlPoints[3] - m_ctrlPoints[0] - m_coefficients[2] - m_coefficients[1];
Magic Number,Sce.Atf.VectorMath,BezierCurve,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\BezierCurve.cs,BezierCurve,The following statement contains a magic number: m_coefficients[0] = m_ctrlPoints[3] - m_ctrlPoints[0] - m_coefficients[2] - m_coefficients[1];
Magic Number,Sce.Atf.VectorMath,BezierCurve,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\BezierCurve.cs,Evaluate,The following statement contains a magic number: result = (m_coefficients[0] * tCubed) + (m_coefficients[1] * tSquared) + (m_coefficients[2] * t) + m_ctrlPoints[0];
Magic Number,Sce.Atf.VectorMath,BezierCurve,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\BezierCurve.cs,ToString,The following statement contains a magic number: return String.Format(                  "{1}{0} {2}{0} {3}{0} {4}{0} {5}{0} {6}{0} {7}{0} {8}{0} {9}{0} {10}{0} {11}{0} {12}"'                  listSeparator'                  m_ctrlPoints[0].X.ToString(format' formatProvider)'                  m_ctrlPoints[0].Y.ToString(format' formatProvider)'                  m_ctrlPoints[0].Z.ToString(format' formatProvider)'                  m_ctrlPoints[1].X.ToString(format' formatProvider)'                  m_ctrlPoints[1].Y.ToString(format' formatProvider)'                  m_ctrlPoints[1].Z.ToString(format' formatProvider)'                  m_ctrlPoints[2].X.ToString(format' formatProvider)'                  m_ctrlPoints[2].Y.ToString(format' formatProvider)'                  m_ctrlPoints[2].Z.ToString(format' formatProvider)'                  m_ctrlPoints[3].X.ToString(format' formatProvider)'                  m_ctrlPoints[3].Y.ToString(format' formatProvider)'                  m_ctrlPoints[3].Z.ToString(format' formatProvider));
Magic Number,Sce.Atf.VectorMath,BezierCurve,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\BezierCurve.cs,ToString,The following statement contains a magic number: return String.Format(                  "{1}{0} {2}{0} {3}{0} {4}{0} {5}{0} {6}{0} {7}{0} {8}{0} {9}{0} {10}{0} {11}{0} {12}"'                  listSeparator'                  m_ctrlPoints[0].X.ToString(format' formatProvider)'                  m_ctrlPoints[0].Y.ToString(format' formatProvider)'                  m_ctrlPoints[0].Z.ToString(format' formatProvider)'                  m_ctrlPoints[1].X.ToString(format' formatProvider)'                  m_ctrlPoints[1].Y.ToString(format' formatProvider)'                  m_ctrlPoints[1].Z.ToString(format' formatProvider)'                  m_ctrlPoints[2].X.ToString(format' formatProvider)'                  m_ctrlPoints[2].Y.ToString(format' formatProvider)'                  m_ctrlPoints[2].Z.ToString(format' formatProvider)'                  m_ctrlPoints[3].X.ToString(format' formatProvider)'                  m_ctrlPoints[3].Y.ToString(format' formatProvider)'                  m_ctrlPoints[3].Z.ToString(format' formatProvider));
Magic Number,Sce.Atf.VectorMath,BezierCurve,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\BezierCurve.cs,ToString,The following statement contains a magic number: return String.Format(                  "{1}{0} {2}{0} {3}{0} {4}{0} {5}{0} {6}{0} {7}{0} {8}{0} {9}{0} {10}{0} {11}{0} {12}"'                  listSeparator'                  m_ctrlPoints[0].X.ToString(format' formatProvider)'                  m_ctrlPoints[0].Y.ToString(format' formatProvider)'                  m_ctrlPoints[0].Z.ToString(format' formatProvider)'                  m_ctrlPoints[1].X.ToString(format' formatProvider)'                  m_ctrlPoints[1].Y.ToString(format' formatProvider)'                  m_ctrlPoints[1].Z.ToString(format' formatProvider)'                  m_ctrlPoints[2].X.ToString(format' formatProvider)'                  m_ctrlPoints[2].Y.ToString(format' formatProvider)'                  m_ctrlPoints[2].Z.ToString(format' formatProvider)'                  m_ctrlPoints[3].X.ToString(format' formatProvider)'                  m_ctrlPoints[3].Y.ToString(format' formatProvider)'                  m_ctrlPoints[3].Z.ToString(format' formatProvider));
Magic Number,Sce.Atf.VectorMath,BezierCurve,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\BezierCurve.cs,ToString,The following statement contains a magic number: return String.Format(                  "{1}{0} {2}{0} {3}{0} {4}{0} {5}{0} {6}{0} {7}{0} {8}{0} {9}{0} {10}{0} {11}{0} {12}"'                  listSeparator'                  m_ctrlPoints[0].X.ToString(format' formatProvider)'                  m_ctrlPoints[0].Y.ToString(format' formatProvider)'                  m_ctrlPoints[0].Z.ToString(format' formatProvider)'                  m_ctrlPoints[1].X.ToString(format' formatProvider)'                  m_ctrlPoints[1].Y.ToString(format' formatProvider)'                  m_ctrlPoints[1].Z.ToString(format' formatProvider)'                  m_ctrlPoints[2].X.ToString(format' formatProvider)'                  m_ctrlPoints[2].Y.ToString(format' formatProvider)'                  m_ctrlPoints[2].Z.ToString(format' formatProvider)'                  m_ctrlPoints[3].X.ToString(format' formatProvider)'                  m_ctrlPoints[3].Y.ToString(format' formatProvider)'                  m_ctrlPoints[3].Z.ToString(format' formatProvider));
Magic Number,Sce.Atf.VectorMath,BezierCurve,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\BezierCurve.cs,ToString,The following statement contains a magic number: return String.Format(                  "{1}{0} {2}{0} {3}{0} {4}{0} {5}{0} {6}{0} {7}{0} {8}{0} {9}{0} {10}{0} {11}{0} {12}"'                  listSeparator'                  m_ctrlPoints[0].X.ToString(format' formatProvider)'                  m_ctrlPoints[0].Y.ToString(format' formatProvider)'                  m_ctrlPoints[0].Z.ToString(format' formatProvider)'                  m_ctrlPoints[1].X.ToString(format' formatProvider)'                  m_ctrlPoints[1].Y.ToString(format' formatProvider)'                  m_ctrlPoints[1].Z.ToString(format' formatProvider)'                  m_ctrlPoints[2].X.ToString(format' formatProvider)'                  m_ctrlPoints[2].Y.ToString(format' formatProvider)'                  m_ctrlPoints[2].Z.ToString(format' formatProvider)'                  m_ctrlPoints[3].X.ToString(format' formatProvider)'                  m_ctrlPoints[3].Y.ToString(format' formatProvider)'                  m_ctrlPoints[3].Z.ToString(format' formatProvider));
Magic Number,Sce.Atf.VectorMath,BezierCurve,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\BezierCurve.cs,ToString,The following statement contains a magic number: return String.Format(                  "{1}{0} {2}{0} {3}{0} {4}{0} {5}{0} {6}{0} {7}{0} {8}{0} {9}{0} {10}{0} {11}{0} {12}"'                  listSeparator'                  m_ctrlPoints[0].X.ToString(format' formatProvider)'                  m_ctrlPoints[0].Y.ToString(format' formatProvider)'                  m_ctrlPoints[0].Z.ToString(format' formatProvider)'                  m_ctrlPoints[1].X.ToString(format' formatProvider)'                  m_ctrlPoints[1].Y.ToString(format' formatProvider)'                  m_ctrlPoints[1].Z.ToString(format' formatProvider)'                  m_ctrlPoints[2].X.ToString(format' formatProvider)'                  m_ctrlPoints[2].Y.ToString(format' formatProvider)'                  m_ctrlPoints[2].Z.ToString(format' formatProvider)'                  m_ctrlPoints[3].X.ToString(format' formatProvider)'                  m_ctrlPoints[3].Y.ToString(format' formatProvider)'                  m_ctrlPoints[3].Z.ToString(format' formatProvider));
Magic Number,Sce.Atf.VectorMath,BezierSpline,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\BezierSpline.cs,BuildCurves,The following statement contains a magic number: if (Count > 1)              {                  if (Count == 2)                      BuildInitialCurveFrom2Points();                  else                  {                      Vec3F zeroVec = new Vec3F(0' 0' 0);                      Vec3F[] tangents = CalcPointTangents();                        for (int i = 1; i < Count; i++)                      {                          Vec3F chord = this[i].Position - this[i - 1].Position;                          float segLen = chord.Length * 0.333f;                            Vec3F[] points = new Vec3F[4];                          points[0] = this[i - 1].Position;                          points[3] = this[i].Position;                            // calc points[1]                          if (this[i - 1].Tangent2 != zeroVec)                          {                              points[1] = this[i - 1].Position + this[i - 1].Tangent2;                          }                          else                          {                              Vec3F tangent = tangents[i - 1];                              if (Vec3F.Dot(chord' tangent) < 0)                                  tangent = -tangent;                                points[1] = this[i - 1].Position + (tangent * segLen);                          }                            // calc points[2]                          if (this[i].Tangent1 != zeroVec)                          {                              points[2] = this[i].Position + this[i].Tangent1;                          }                          else                          {                              Vec3F tangent = tangents[i];                              if (Vec3F.Dot(-chord' tangent) < 0)                                  tangent = -tangent;                                points[2] = this[i].Position + (tangent * segLen);                          }                            BezierCurve curve = new BezierCurve(points);                          m_curves.Add(curve);                      }                        // Calculate last curve if is closed                      if (m_isClosed)                      {                          Vec3F[] points = new Vec3F[4];                          points[0] = this[Count - 1].Position;                          points[3] = this[0].Position;                          float tanLen = (points[3] - points[0]).Length / 3.0f;                            Vec3F v = m_curves[m_curves.Count - 1].ControlPoints[2] - points[0];                          v = v / v.Length;                          points[1] = points[0] - (v * tanLen);                            v = m_curves[0].ControlPoints[1] - points[3];                          v = v / v.Length;                          points[2] = points[3] - (v * tanLen);                            BezierCurve curve = new BezierCurve(points);                          m_curves.Add(curve);                      }                  }              }
Magic Number,Sce.Atf.VectorMath,BezierSpline,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\BezierSpline.cs,BuildCurves,The following statement contains a magic number: if (Count > 1)              {                  if (Count == 2)                      BuildInitialCurveFrom2Points();                  else                  {                      Vec3F zeroVec = new Vec3F(0' 0' 0);                      Vec3F[] tangents = CalcPointTangents();                        for (int i = 1; i < Count; i++)                      {                          Vec3F chord = this[i].Position - this[i - 1].Position;                          float segLen = chord.Length * 0.333f;                            Vec3F[] points = new Vec3F[4];                          points[0] = this[i - 1].Position;                          points[3] = this[i].Position;                            // calc points[1]                          if (this[i - 1].Tangent2 != zeroVec)                          {                              points[1] = this[i - 1].Position + this[i - 1].Tangent2;                          }                          else                          {                              Vec3F tangent = tangents[i - 1];                              if (Vec3F.Dot(chord' tangent) < 0)                                  tangent = -tangent;                                points[1] = this[i - 1].Position + (tangent * segLen);                          }                            // calc points[2]                          if (this[i].Tangent1 != zeroVec)                          {                              points[2] = this[i].Position + this[i].Tangent1;                          }                          else                          {                              Vec3F tangent = tangents[i];                              if (Vec3F.Dot(-chord' tangent) < 0)                                  tangent = -tangent;                                points[2] = this[i].Position + (tangent * segLen);                          }                            BezierCurve curve = new BezierCurve(points);                          m_curves.Add(curve);                      }                        // Calculate last curve if is closed                      if (m_isClosed)                      {                          Vec3F[] points = new Vec3F[4];                          points[0] = this[Count - 1].Position;                          points[3] = this[0].Position;                          float tanLen = (points[3] - points[0]).Length / 3.0f;                            Vec3F v = m_curves[m_curves.Count - 1].ControlPoints[2] - points[0];                          v = v / v.Length;                          points[1] = points[0] - (v * tanLen);                            v = m_curves[0].ControlPoints[1] - points[3];                          v = v / v.Length;                          points[2] = points[3] - (v * tanLen);                            BezierCurve curve = new BezierCurve(points);                          m_curves.Add(curve);                      }                  }              }
Magic Number,Sce.Atf.VectorMath,BezierSpline,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\BezierSpline.cs,BuildCurves,The following statement contains a magic number: if (Count > 1)              {                  if (Count == 2)                      BuildInitialCurveFrom2Points();                  else                  {                      Vec3F zeroVec = new Vec3F(0' 0' 0);                      Vec3F[] tangents = CalcPointTangents();                        for (int i = 1; i < Count; i++)                      {                          Vec3F chord = this[i].Position - this[i - 1].Position;                          float segLen = chord.Length * 0.333f;                            Vec3F[] points = new Vec3F[4];                          points[0] = this[i - 1].Position;                          points[3] = this[i].Position;                            // calc points[1]                          if (this[i - 1].Tangent2 != zeroVec)                          {                              points[1] = this[i - 1].Position + this[i - 1].Tangent2;                          }                          else                          {                              Vec3F tangent = tangents[i - 1];                              if (Vec3F.Dot(chord' tangent) < 0)                                  tangent = -tangent;                                points[1] = this[i - 1].Position + (tangent * segLen);                          }                            // calc points[2]                          if (this[i].Tangent1 != zeroVec)                          {                              points[2] = this[i].Position + this[i].Tangent1;                          }                          else                          {                              Vec3F tangent = tangents[i];                              if (Vec3F.Dot(-chord' tangent) < 0)                                  tangent = -tangent;                                points[2] = this[i].Position + (tangent * segLen);                          }                            BezierCurve curve = new BezierCurve(points);                          m_curves.Add(curve);                      }                        // Calculate last curve if is closed                      if (m_isClosed)                      {                          Vec3F[] points = new Vec3F[4];                          points[0] = this[Count - 1].Position;                          points[3] = this[0].Position;                          float tanLen = (points[3] - points[0]).Length / 3.0f;                            Vec3F v = m_curves[m_curves.Count - 1].ControlPoints[2] - points[0];                          v = v / v.Length;                          points[1] = points[0] - (v * tanLen);                            v = m_curves[0].ControlPoints[1] - points[3];                          v = v / v.Length;                          points[2] = points[3] - (v * tanLen);                            BezierCurve curve = new BezierCurve(points);                          m_curves.Add(curve);                      }                  }              }
Magic Number,Sce.Atf.VectorMath,BezierSpline,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\BezierSpline.cs,BuildCurves,The following statement contains a magic number: if (Count > 1)              {                  if (Count == 2)                      BuildInitialCurveFrom2Points();                  else                  {                      Vec3F zeroVec = new Vec3F(0' 0' 0);                      Vec3F[] tangents = CalcPointTangents();                        for (int i = 1; i < Count; i++)                      {                          Vec3F chord = this[i].Position - this[i - 1].Position;                          float segLen = chord.Length * 0.333f;                            Vec3F[] points = new Vec3F[4];                          points[0] = this[i - 1].Position;                          points[3] = this[i].Position;                            // calc points[1]                          if (this[i - 1].Tangent2 != zeroVec)                          {                              points[1] = this[i - 1].Position + this[i - 1].Tangent2;                          }                          else                          {                              Vec3F tangent = tangents[i - 1];                              if (Vec3F.Dot(chord' tangent) < 0)                                  tangent = -tangent;                                points[1] = this[i - 1].Position + (tangent * segLen);                          }                            // calc points[2]                          if (this[i].Tangent1 != zeroVec)                          {                              points[2] = this[i].Position + this[i].Tangent1;                          }                          else                          {                              Vec3F tangent = tangents[i];                              if (Vec3F.Dot(-chord' tangent) < 0)                                  tangent = -tangent;                                points[2] = this[i].Position + (tangent * segLen);                          }                            BezierCurve curve = new BezierCurve(points);                          m_curves.Add(curve);                      }                        // Calculate last curve if is closed                      if (m_isClosed)                      {                          Vec3F[] points = new Vec3F[4];                          points[0] = this[Count - 1].Position;                          points[3] = this[0].Position;                          float tanLen = (points[3] - points[0]).Length / 3.0f;                            Vec3F v = m_curves[m_curves.Count - 1].ControlPoints[2] - points[0];                          v = v / v.Length;                          points[1] = points[0] - (v * tanLen);                            v = m_curves[0].ControlPoints[1] - points[3];                          v = v / v.Length;                          points[2] = points[3] - (v * tanLen);                            BezierCurve curve = new BezierCurve(points);                          m_curves.Add(curve);                      }                  }              }
Magic Number,Sce.Atf.VectorMath,BezierSpline,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\BezierSpline.cs,BuildCurves,The following statement contains a magic number: if (Count > 1)              {                  if (Count == 2)                      BuildInitialCurveFrom2Points();                  else                  {                      Vec3F zeroVec = new Vec3F(0' 0' 0);                      Vec3F[] tangents = CalcPointTangents();                        for (int i = 1; i < Count; i++)                      {                          Vec3F chord = this[i].Position - this[i - 1].Position;                          float segLen = chord.Length * 0.333f;                            Vec3F[] points = new Vec3F[4];                          points[0] = this[i - 1].Position;                          points[3] = this[i].Position;                            // calc points[1]                          if (this[i - 1].Tangent2 != zeroVec)                          {                              points[1] = this[i - 1].Position + this[i - 1].Tangent2;                          }                          else                          {                              Vec3F tangent = tangents[i - 1];                              if (Vec3F.Dot(chord' tangent) < 0)                                  tangent = -tangent;                                points[1] = this[i - 1].Position + (tangent * segLen);                          }                            // calc points[2]                          if (this[i].Tangent1 != zeroVec)                          {                              points[2] = this[i].Position + this[i].Tangent1;                          }                          else                          {                              Vec3F tangent = tangents[i];                              if (Vec3F.Dot(-chord' tangent) < 0)                                  tangent = -tangent;                                points[2] = this[i].Position + (tangent * segLen);                          }                            BezierCurve curve = new BezierCurve(points);                          m_curves.Add(curve);                      }                        // Calculate last curve if is closed                      if (m_isClosed)                      {                          Vec3F[] points = new Vec3F[4];                          points[0] = this[Count - 1].Position;                          points[3] = this[0].Position;                          float tanLen = (points[3] - points[0]).Length / 3.0f;                            Vec3F v = m_curves[m_curves.Count - 1].ControlPoints[2] - points[0];                          v = v / v.Length;                          points[1] = points[0] - (v * tanLen);                            v = m_curves[0].ControlPoints[1] - points[3];                          v = v / v.Length;                          points[2] = points[3] - (v * tanLen);                            BezierCurve curve = new BezierCurve(points);                          m_curves.Add(curve);                      }                  }              }
Magic Number,Sce.Atf.VectorMath,BezierSpline,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\BezierSpline.cs,BuildCurves,The following statement contains a magic number: if (Count > 1)              {                  if (Count == 2)                      BuildInitialCurveFrom2Points();                  else                  {                      Vec3F zeroVec = new Vec3F(0' 0' 0);                      Vec3F[] tangents = CalcPointTangents();                        for (int i = 1; i < Count; i++)                      {                          Vec3F chord = this[i].Position - this[i - 1].Position;                          float segLen = chord.Length * 0.333f;                            Vec3F[] points = new Vec3F[4];                          points[0] = this[i - 1].Position;                          points[3] = this[i].Position;                            // calc points[1]                          if (this[i - 1].Tangent2 != zeroVec)                          {                              points[1] = this[i - 1].Position + this[i - 1].Tangent2;                          }                          else                          {                              Vec3F tangent = tangents[i - 1];                              if (Vec3F.Dot(chord' tangent) < 0)                                  tangent = -tangent;                                points[1] = this[i - 1].Position + (tangent * segLen);                          }                            // calc points[2]                          if (this[i].Tangent1 != zeroVec)                          {                              points[2] = this[i].Position + this[i].Tangent1;                          }                          else                          {                              Vec3F tangent = tangents[i];                              if (Vec3F.Dot(-chord' tangent) < 0)                                  tangent = -tangent;                                points[2] = this[i].Position + (tangent * segLen);                          }                            BezierCurve curve = new BezierCurve(points);                          m_curves.Add(curve);                      }                        // Calculate last curve if is closed                      if (m_isClosed)                      {                          Vec3F[] points = new Vec3F[4];                          points[0] = this[Count - 1].Position;                          points[3] = this[0].Position;                          float tanLen = (points[3] - points[0]).Length / 3.0f;                            Vec3F v = m_curves[m_curves.Count - 1].ControlPoints[2] - points[0];                          v = v / v.Length;                          points[1] = points[0] - (v * tanLen);                            v = m_curves[0].ControlPoints[1] - points[3];                          v = v / v.Length;                          points[2] = points[3] - (v * tanLen);                            BezierCurve curve = new BezierCurve(points);                          m_curves.Add(curve);                      }                  }              }
Magic Number,Sce.Atf.VectorMath,BezierSpline,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\BezierSpline.cs,BuildCurves,The following statement contains a magic number: if (Count > 1)              {                  if (Count == 2)                      BuildInitialCurveFrom2Points();                  else                  {                      Vec3F zeroVec = new Vec3F(0' 0' 0);                      Vec3F[] tangents = CalcPointTangents();                        for (int i = 1; i < Count; i++)                      {                          Vec3F chord = this[i].Position - this[i - 1].Position;                          float segLen = chord.Length * 0.333f;                            Vec3F[] points = new Vec3F[4];                          points[0] = this[i - 1].Position;                          points[3] = this[i].Position;                            // calc points[1]                          if (this[i - 1].Tangent2 != zeroVec)                          {                              points[1] = this[i - 1].Position + this[i - 1].Tangent2;                          }                          else                          {                              Vec3F tangent = tangents[i - 1];                              if (Vec3F.Dot(chord' tangent) < 0)                                  tangent = -tangent;                                points[1] = this[i - 1].Position + (tangent * segLen);                          }                            // calc points[2]                          if (this[i].Tangent1 != zeroVec)                          {                              points[2] = this[i].Position + this[i].Tangent1;                          }                          else                          {                              Vec3F tangent = tangents[i];                              if (Vec3F.Dot(-chord' tangent) < 0)                                  tangent = -tangent;                                points[2] = this[i].Position + (tangent * segLen);                          }                            BezierCurve curve = new BezierCurve(points);                          m_curves.Add(curve);                      }                        // Calculate last curve if is closed                      if (m_isClosed)                      {                          Vec3F[] points = new Vec3F[4];                          points[0] = this[Count - 1].Position;                          points[3] = this[0].Position;                          float tanLen = (points[3] - points[0]).Length / 3.0f;                            Vec3F v = m_curves[m_curves.Count - 1].ControlPoints[2] - points[0];                          v = v / v.Length;                          points[1] = points[0] - (v * tanLen);                            v = m_curves[0].ControlPoints[1] - points[3];                          v = v / v.Length;                          points[2] = points[3] - (v * tanLen);                            BezierCurve curve = new BezierCurve(points);                          m_curves.Add(curve);                      }                  }              }
Magic Number,Sce.Atf.VectorMath,BezierSpline,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\BezierSpline.cs,BuildCurves,The following statement contains a magic number: if (Count > 1)              {                  if (Count == 2)                      BuildInitialCurveFrom2Points();                  else                  {                      Vec3F zeroVec = new Vec3F(0' 0' 0);                      Vec3F[] tangents = CalcPointTangents();                        for (int i = 1; i < Count; i++)                      {                          Vec3F chord = this[i].Position - this[i - 1].Position;                          float segLen = chord.Length * 0.333f;                            Vec3F[] points = new Vec3F[4];                          points[0] = this[i - 1].Position;                          points[3] = this[i].Position;                            // calc points[1]                          if (this[i - 1].Tangent2 != zeroVec)                          {                              points[1] = this[i - 1].Position + this[i - 1].Tangent2;                          }                          else                          {                              Vec3F tangent = tangents[i - 1];                              if (Vec3F.Dot(chord' tangent) < 0)                                  tangent = -tangent;                                points[1] = this[i - 1].Position + (tangent * segLen);                          }                            // calc points[2]                          if (this[i].Tangent1 != zeroVec)                          {                              points[2] = this[i].Position + this[i].Tangent1;                          }                          else                          {                              Vec3F tangent = tangents[i];                              if (Vec3F.Dot(-chord' tangent) < 0)                                  tangent = -tangent;                                points[2] = this[i].Position + (tangent * segLen);                          }                            BezierCurve curve = new BezierCurve(points);                          m_curves.Add(curve);                      }                        // Calculate last curve if is closed                      if (m_isClosed)                      {                          Vec3F[] points = new Vec3F[4];                          points[0] = this[Count - 1].Position;                          points[3] = this[0].Position;                          float tanLen = (points[3] - points[0]).Length / 3.0f;                            Vec3F v = m_curves[m_curves.Count - 1].ControlPoints[2] - points[0];                          v = v / v.Length;                          points[1] = points[0] - (v * tanLen);                            v = m_curves[0].ControlPoints[1] - points[3];                          v = v / v.Length;                          points[2] = points[3] - (v * tanLen);                            BezierCurve curve = new BezierCurve(points);                          m_curves.Add(curve);                      }                  }              }
Magic Number,Sce.Atf.VectorMath,BezierSpline,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\BezierSpline.cs,BuildCurves,The following statement contains a magic number: if (Count > 1)              {                  if (Count == 2)                      BuildInitialCurveFrom2Points();                  else                  {                      Vec3F zeroVec = new Vec3F(0' 0' 0);                      Vec3F[] tangents = CalcPointTangents();                        for (int i = 1; i < Count; i++)                      {                          Vec3F chord = this[i].Position - this[i - 1].Position;                          float segLen = chord.Length * 0.333f;                            Vec3F[] points = new Vec3F[4];                          points[0] = this[i - 1].Position;                          points[3] = this[i].Position;                            // calc points[1]                          if (this[i - 1].Tangent2 != zeroVec)                          {                              points[1] = this[i - 1].Position + this[i - 1].Tangent2;                          }                          else                          {                              Vec3F tangent = tangents[i - 1];                              if (Vec3F.Dot(chord' tangent) < 0)                                  tangent = -tangent;                                points[1] = this[i - 1].Position + (tangent * segLen);                          }                            // calc points[2]                          if (this[i].Tangent1 != zeroVec)                          {                              points[2] = this[i].Position + this[i].Tangent1;                          }                          else                          {                              Vec3F tangent = tangents[i];                              if (Vec3F.Dot(-chord' tangent) < 0)                                  tangent = -tangent;                                points[2] = this[i].Position + (tangent * segLen);                          }                            BezierCurve curve = new BezierCurve(points);                          m_curves.Add(curve);                      }                        // Calculate last curve if is closed                      if (m_isClosed)                      {                          Vec3F[] points = new Vec3F[4];                          points[0] = this[Count - 1].Position;                          points[3] = this[0].Position;                          float tanLen = (points[3] - points[0]).Length / 3.0f;                            Vec3F v = m_curves[m_curves.Count - 1].ControlPoints[2] - points[0];                          v = v / v.Length;                          points[1] = points[0] - (v * tanLen);                            v = m_curves[0].ControlPoints[1] - points[3];                          v = v / v.Length;                          points[2] = points[3] - (v * tanLen);                            BezierCurve curve = new BezierCurve(points);                          m_curves.Add(curve);                      }                  }              }
Magic Number,Sce.Atf.VectorMath,BezierSpline,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\BezierSpline.cs,BuildCurves,The following statement contains a magic number: if (Count > 1)              {                  if (Count == 2)                      BuildInitialCurveFrom2Points();                  else                  {                      Vec3F zeroVec = new Vec3F(0' 0' 0);                      Vec3F[] tangents = CalcPointTangents();                        for (int i = 1; i < Count; i++)                      {                          Vec3F chord = this[i].Position - this[i - 1].Position;                          float segLen = chord.Length * 0.333f;                            Vec3F[] points = new Vec3F[4];                          points[0] = this[i - 1].Position;                          points[3] = this[i].Position;                            // calc points[1]                          if (this[i - 1].Tangent2 != zeroVec)                          {                              points[1] = this[i - 1].Position + this[i - 1].Tangent2;                          }                          else                          {                              Vec3F tangent = tangents[i - 1];                              if (Vec3F.Dot(chord' tangent) < 0)                                  tangent = -tangent;                                points[1] = this[i - 1].Position + (tangent * segLen);                          }                            // calc points[2]                          if (this[i].Tangent1 != zeroVec)                          {                              points[2] = this[i].Position + this[i].Tangent1;                          }                          else                          {                              Vec3F tangent = tangents[i];                              if (Vec3F.Dot(-chord' tangent) < 0)                                  tangent = -tangent;                                points[2] = this[i].Position + (tangent * segLen);                          }                            BezierCurve curve = new BezierCurve(points);                          m_curves.Add(curve);                      }                        // Calculate last curve if is closed                      if (m_isClosed)                      {                          Vec3F[] points = new Vec3F[4];                          points[0] = this[Count - 1].Position;                          points[3] = this[0].Position;                          float tanLen = (points[3] - points[0]).Length / 3.0f;                            Vec3F v = m_curves[m_curves.Count - 1].ControlPoints[2] - points[0];                          v = v / v.Length;                          points[1] = points[0] - (v * tanLen);                            v = m_curves[0].ControlPoints[1] - points[3];                          v = v / v.Length;                          points[2] = points[3] - (v * tanLen);                            BezierCurve curve = new BezierCurve(points);                          m_curves.Add(curve);                      }                  }              }
Magic Number,Sce.Atf.VectorMath,BezierSpline,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\BezierSpline.cs,BuildCurves,The following statement contains a magic number: if (Count > 1)              {                  if (Count == 2)                      BuildInitialCurveFrom2Points();                  else                  {                      Vec3F zeroVec = new Vec3F(0' 0' 0);                      Vec3F[] tangents = CalcPointTangents();                        for (int i = 1; i < Count; i++)                      {                          Vec3F chord = this[i].Position - this[i - 1].Position;                          float segLen = chord.Length * 0.333f;                            Vec3F[] points = new Vec3F[4];                          points[0] = this[i - 1].Position;                          points[3] = this[i].Position;                            // calc points[1]                          if (this[i - 1].Tangent2 != zeroVec)                          {                              points[1] = this[i - 1].Position + this[i - 1].Tangent2;                          }                          else                          {                              Vec3F tangent = tangents[i - 1];                              if (Vec3F.Dot(chord' tangent) < 0)                                  tangent = -tangent;                                points[1] = this[i - 1].Position + (tangent * segLen);                          }                            // calc points[2]                          if (this[i].Tangent1 != zeroVec)                          {                              points[2] = this[i].Position + this[i].Tangent1;                          }                          else                          {                              Vec3F tangent = tangents[i];                              if (Vec3F.Dot(-chord' tangent) < 0)                                  tangent = -tangent;                                points[2] = this[i].Position + (tangent * segLen);                          }                            BezierCurve curve = new BezierCurve(points);                          m_curves.Add(curve);                      }                        // Calculate last curve if is closed                      if (m_isClosed)                      {                          Vec3F[] points = new Vec3F[4];                          points[0] = this[Count - 1].Position;                          points[3] = this[0].Position;                          float tanLen = (points[3] - points[0]).Length / 3.0f;                            Vec3F v = m_curves[m_curves.Count - 1].ControlPoints[2] - points[0];                          v = v / v.Length;                          points[1] = points[0] - (v * tanLen);                            v = m_curves[0].ControlPoints[1] - points[3];                          v = v / v.Length;                          points[2] = points[3] - (v * tanLen);                            BezierCurve curve = new BezierCurve(points);                          m_curves.Add(curve);                      }                  }              }
Magic Number,Sce.Atf.VectorMath,BezierSpline,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\BezierSpline.cs,BuildCurves,The following statement contains a magic number: if (Count > 1)              {                  if (Count == 2)                      BuildInitialCurveFrom2Points();                  else                  {                      Vec3F zeroVec = new Vec3F(0' 0' 0);                      Vec3F[] tangents = CalcPointTangents();                        for (int i = 1; i < Count; i++)                      {                          Vec3F chord = this[i].Position - this[i - 1].Position;                          float segLen = chord.Length * 0.333f;                            Vec3F[] points = new Vec3F[4];                          points[0] = this[i - 1].Position;                          points[3] = this[i].Position;                            // calc points[1]                          if (this[i - 1].Tangent2 != zeroVec)                          {                              points[1] = this[i - 1].Position + this[i - 1].Tangent2;                          }                          else                          {                              Vec3F tangent = tangents[i - 1];                              if (Vec3F.Dot(chord' tangent) < 0)                                  tangent = -tangent;                                points[1] = this[i - 1].Position + (tangent * segLen);                          }                            // calc points[2]                          if (this[i].Tangent1 != zeroVec)                          {                              points[2] = this[i].Position + this[i].Tangent1;                          }                          else                          {                              Vec3F tangent = tangents[i];                              if (Vec3F.Dot(-chord' tangent) < 0)                                  tangent = -tangent;                                points[2] = this[i].Position + (tangent * segLen);                          }                            BezierCurve curve = new BezierCurve(points);                          m_curves.Add(curve);                      }                        // Calculate last curve if is closed                      if (m_isClosed)                      {                          Vec3F[] points = new Vec3F[4];                          points[0] = this[Count - 1].Position;                          points[3] = this[0].Position;                          float tanLen = (points[3] - points[0]).Length / 3.0f;                            Vec3F v = m_curves[m_curves.Count - 1].ControlPoints[2] - points[0];                          v = v / v.Length;                          points[1] = points[0] - (v * tanLen);                            v = m_curves[0].ControlPoints[1] - points[3];                          v = v / v.Length;                          points[2] = points[3] - (v * tanLen);                            BezierCurve curve = new BezierCurve(points);                          m_curves.Add(curve);                      }                  }              }
Magic Number,Sce.Atf.VectorMath,BezierSpline,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\BezierSpline.cs,BuildInitialCurveFrom2Points,The following statement contains a magic number: Vec3F[] points = new Vec3F[4];
Magic Number,Sce.Atf.VectorMath,BezierSpline,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\BezierSpline.cs,BuildInitialCurveFrom2Points,The following statement contains a magic number: points[3] = this[1].Position;
Magic Number,Sce.Atf.VectorMath,BezierSpline,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\BezierSpline.cs,BuildInitialCurveFrom2Points,The following statement contains a magic number: points[1] = points[0] + (points[3] - points[0]) * 0.333f;
Magic Number,Sce.Atf.VectorMath,BezierSpline,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\BezierSpline.cs,BuildInitialCurveFrom2Points,The following statement contains a magic number: points[2] = points[0] + (points[3] - points[0]) * 0.666f;
Magic Number,Sce.Atf.VectorMath,BezierSpline,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\BezierSpline.cs,BuildInitialCurveFrom2Points,The following statement contains a magic number: points[2] = points[0] + (points[3] - points[0]) * 0.666f;
Magic Number,Sce.Atf.VectorMath,BezierSpline,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\BezierSpline.cs,CalcPointTangents,The following statement contains a magic number: if (m_isClosed)              {                  tangents[0] = CalcTangent(this[n - 1].Position' this[0].Position' this[1].Position);                  tangents[n - 1] = CalcTangent(this[n - 2].Position' this[n - 1].Position' this[0].Position);              }              else              {                  tangents[0] = CalcEndTangents(this[0].Position' this[1].Position' tangents[1]);                  tangents[n - 1] = CalcEndTangents(this[n - 2].Position' this[n - 1].Position' tangents[n - 2]);              }
Magic Number,Sce.Atf.VectorMath,BezierSpline,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\BezierSpline.cs,CalcPointTangents,The following statement contains a magic number: if (m_isClosed)              {                  tangents[0] = CalcTangent(this[n - 1].Position' this[0].Position' this[1].Position);                  tangents[n - 1] = CalcTangent(this[n - 2].Position' this[n - 1].Position' this[0].Position);              }              else              {                  tangents[0] = CalcEndTangents(this[0].Position' this[1].Position' tangents[1]);                  tangents[n - 1] = CalcEndTangents(this[n - 2].Position' this[n - 1].Position' tangents[n - 2]);              }
Magic Number,Sce.Atf.VectorMath,BezierSpline,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\BezierSpline.cs,CalcPointTangents,The following statement contains a magic number: if (m_isClosed)              {                  tangents[0] = CalcTangent(this[n - 1].Position' this[0].Position' this[1].Position);                  tangents[n - 1] = CalcTangent(this[n - 2].Position' this[n - 1].Position' this[0].Position);              }              else              {                  tangents[0] = CalcEndTangents(this[0].Position' this[1].Position' tangents[1]);                  tangents[n - 1] = CalcEndTangents(this[n - 2].Position' this[n - 1].Position' tangents[n - 2]);              }
Magic Number,Sce.Atf.VectorMath,Box,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Box.cs,Extend,The following statement contains a magic number: if (v.Count >= 3)              {                  if (!m_initialized)                  {                      Max.X = Min.X = v[0];                      Max.Y = Min.Y = v[1];                      Max.Z = Min.Z = v[2];                        m_initialized = true;                  }                    for (int i = 0; i < v.Count; i += 3)                  {                      Min.X = Math.Min(Min.X' v[i]);                      Min.Y = Math.Min(Min.Y' v[i + 1]);                      Min.Z = Math.Min(Min.Z' v[i + 2]);                        Max.X = Math.Max(Max.X' v[i]);                      Max.Y = Math.Max(Max.Y' v[i + 1]);                      Max.Z = Math.Max(Max.Z' v[i + 2]);                  }              }
Magic Number,Sce.Atf.VectorMath,Box,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Box.cs,Extend,The following statement contains a magic number: if (v.Count >= 3)              {                  if (!m_initialized)                  {                      Max.X = Min.X = v[0];                      Max.Y = Min.Y = v[1];                      Max.Z = Min.Z = v[2];                        m_initialized = true;                  }                    for (int i = 0; i < v.Count; i += 3)                  {                      Min.X = Math.Min(Min.X' v[i]);                      Min.Y = Math.Min(Min.Y' v[i + 1]);                      Min.Z = Math.Min(Min.Z' v[i + 2]);                        Max.X = Math.Max(Max.X' v[i]);                      Max.Y = Math.Max(Max.Y' v[i + 1]);                      Max.Z = Math.Max(Max.Z' v[i + 2]);                  }              }
Magic Number,Sce.Atf.VectorMath,Box,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Box.cs,Extend,The following statement contains a magic number: if (v.Count >= 3)              {                  if (!m_initialized)                  {                      Max.X = Min.X = v[0];                      Max.Y = Min.Y = v[1];                      Max.Z = Min.Z = v[2];                        m_initialized = true;                  }                    for (int i = 0; i < v.Count; i += 3)                  {                      Min.X = Math.Min(Min.X' v[i]);                      Min.Y = Math.Min(Min.Y' v[i + 1]);                      Min.Z = Math.Min(Min.Z' v[i + 2]);                        Max.X = Math.Max(Max.X' v[i]);                      Max.Y = Math.Max(Max.Y' v[i + 1]);                      Max.Z = Math.Max(Max.Z' v[i + 2]);                  }              }
Magic Number,Sce.Atf.VectorMath,Box,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Box.cs,Extend,The following statement contains a magic number: if (v.Count >= 3)              {                  if (!m_initialized)                  {                      Max.X = Min.X = v[0];                      Max.Y = Min.Y = v[1];                      Max.Z = Min.Z = v[2];                        m_initialized = true;                  }                    for (int i = 0; i < v.Count; i += 3)                  {                      Min.X = Math.Min(Min.X' v[i]);                      Min.Y = Math.Min(Min.Y' v[i + 1]);                      Min.Z = Math.Min(Min.Z' v[i + 2]);                        Max.X = Math.Max(Max.X' v[i]);                      Max.Y = Math.Max(Max.Y' v[i + 1]);                      Max.Z = Math.Max(Max.Z' v[i + 2]);                  }              }
Magic Number,Sce.Atf.VectorMath,Box,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Box.cs,Extend,The following statement contains a magic number: if (v.Count >= 3)              {                  if (!m_initialized)                  {                      Max.X = Min.X = v[0];                      Max.Y = Min.Y = v[1];                      Max.Z = Min.Z = v[2];                        m_initialized = true;                  }                    for (int i = 0; i < v.Count; i += 3)                  {                      Min.X = Math.Min(Min.X' v[i]);                      Min.Y = Math.Min(Min.Y' v[i + 1]);                      Min.Z = Math.Min(Min.Z' v[i + 2]);                        Max.X = Math.Max(Max.X' v[i]);                      Max.Y = Math.Max(Max.Y' v[i + 1]);                      Max.Z = Math.Max(Max.Z' v[i + 2]);                  }              }
Magic Number,Sce.Atf.VectorMath,Box,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Box.cs,Transform,The following statement contains a magic number: float[] newMax = new[] { newMin[0]' newMin[1]' newMin[2] };
Magic Number,Sce.Atf.VectorMath,Box,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Box.cs,Transform,The following statement contains a magic number: for (int i = 0; i < 3; ++i)              {                  for (int j = 0; j < 3; ++j)                  {                      a = mArray[j * 4 + i] * oldMin[j];                      b = mArray[j * 4 + i] * oldMax[j];                        if (a < b)                      {                          newMin[i] += a;                          newMax[i] += b;                      }                      else                      {                          newMin[i] += b;                          newMax[i] += a;                      }                  }              }
Magic Number,Sce.Atf.VectorMath,Box,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Box.cs,Transform,The following statement contains a magic number: for (int i = 0; i < 3; ++i)              {                  for (int j = 0; j < 3; ++j)                  {                      a = mArray[j * 4 + i] * oldMin[j];                      b = mArray[j * 4 + i] * oldMax[j];                        if (a < b)                      {                          newMin[i] += a;                          newMax[i] += b;                      }                      else                      {                          newMin[i] += b;                          newMax[i] += a;                      }                  }              }
Magic Number,Sce.Atf.VectorMath,Box,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Box.cs,Transform,The following statement contains a magic number: for (int i = 0; i < 3; ++i)              {                  for (int j = 0; j < 3; ++j)                  {                      a = mArray[j * 4 + i] * oldMin[j];                      b = mArray[j * 4 + i] * oldMax[j];                        if (a < b)                      {                          newMin[i] += a;                          newMax[i] += b;                      }                      else                      {                          newMin[i] += b;                          newMax[i] += a;                      }                  }              }
Magic Number,Sce.Atf.VectorMath,Box,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Box.cs,Transform,The following statement contains a magic number: for (int i = 0; i < 3; ++i)              {                  for (int j = 0; j < 3; ++j)                  {                      a = mArray[j * 4 + i] * oldMin[j];                      b = mArray[j * 4 + i] * oldMax[j];                        if (a < b)                      {                          newMin[i] += a;                          newMax[i] += b;                      }                      else                      {                          newMin[i] += b;                          newMax[i] += a;                      }                  }              }
Magic Number,Sce.Atf.VectorMath,Box,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Box.cs,Transform,The following statement contains a magic number: Min.Z = newMin[2];
Magic Number,Sce.Atf.VectorMath,Box,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Box.cs,Transform,The following statement contains a magic number: Max.Z = newMax[2];
Magic Number,Sce.Atf.VectorMath,Box,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Box.cs,ToArray,The following statement contains a magic number: float[] temp = new float[6];
Magic Number,Sce.Atf.VectorMath,Box,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Box.cs,ToArray,The following statement contains a magic number: temp[2] = Min.Z;
Magic Number,Sce.Atf.VectorMath,Box,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Box.cs,ToArray,The following statement contains a magic number: temp[3] = Max.X;
Magic Number,Sce.Atf.VectorMath,Box,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Box.cs,ToArray,The following statement contains a magic number: temp[4] = Max.Y;
Magic Number,Sce.Atf.VectorMath,Box,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Box.cs,ToArray,The following statement contains a magic number: temp[5] = Max.Z;
Magic Number,Sce.Atf.VectorMath,Box2F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Box2F.cs,Extend,The following statement contains a magic number: if (v.Length >= 2)              {                  if (m_empty)                  {                      Max.X = Min.X = v[0];                      Max.Y = Min.Y = v[1];                  }                    for (int i = 0; i < v.Length; i += 3)                  {                      Min.X = Math.Min(Min.X' v[i]);                      Min.Y = Math.Min(Min.Y' v[i + 1]);                        Max.X = Math.Max(Max.X' v[i]);                      Max.Y = Math.Max(Max.Y' v[i + 1]);                  }              }
Magic Number,Sce.Atf.VectorMath,Box2F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Box2F.cs,Extend,The following statement contains a magic number: if (v.Length >= 2)              {                  if (m_empty)                  {                      Max.X = Min.X = v[0];                      Max.Y = Min.Y = v[1];                  }                    for (int i = 0; i < v.Length; i += 3)                  {                      Min.X = Math.Min(Min.X' v[i]);                      Min.Y = Math.Min(Min.Y' v[i + 1]);                        Max.X = Math.Max(Max.X' v[i]);                      Max.Y = Math.Max(Max.Y' v[i + 1]);                  }              }
Magic Number,Sce.Atf.VectorMath,CircleF,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\CircleF.cs,Intersect,The following statement contains a magic number: const double EPS = 1.0e-6;
Magic Number,Sce.Atf.VectorMath,CircleF,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\CircleF.cs,Intersect,The following statement contains a magic number: double cos = (d * d + c1.Radius * c1.Radius - c2.Radius * c2.Radius) / (2 * c1.Radius * d);
Magic Number,Sce.Atf.VectorMath,Frustum,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Frustum.cs,Frustum,The following statement contains a magic number: m_planes = new Plane3F[6];
Magic Number,Sce.Atf.VectorMath,Frustum,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Frustum.cs,Set,The following statement contains a magic number: for (int i = 0; i < 6; i++)              {                  m_planes[i] = other.m_planes[i];              }
Magic Number,Sce.Atf.VectorMath,Frustum,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Frustum.cs,SetPerspective,The following statement contains a magic number: float tanY = (float)Math.Tan((double)fovY / 2.0);
Magic Number,Sce.Atf.VectorMath,Frustum,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Frustum.cs,Contains,The following statement contains a magic number: for (int i = 0; i < 6; i++)              {                  float distance = m_planes[i].SignedDistance(sphere.Center);                  if (distance < -sphere.Radius)                  {                      return false;                  }              }
Magic Number,Sce.Atf.VectorMath,Frustum,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Frustum.cs,Contains,The following statement contains a magic number: for (int i = 0; i < 6; i++)              {                  // Compute the distance from the plane to the center. A negative distance means that                  // the center point is on the "out" side of the plane and is thus outside the frustum.                  float center_dist = m_planes[i].SignedDistance(center);                    // Now we need the distance to the plane that the nearest corner contributes.                  // Map the plane's normal to be in the positive octant along with 'center_to_max'.                  // Note that 'center_to_max' is guaranteed to have all 3 coordinates be positive                  // (because box.Max is greater than box.Min for all 3). To transform the plane's                  // normal' we simply take the absolute value of each coordinate. This plane's normal                  // must be unit length so that the distance is correct. 'nearest_corner_dist' is                  // always non-negative. (It could be zero if the box has zero size.)                  float nearest_corner_dist =                      center_to_max.X * Math.Abs(m_planes[i].Normal.X) +                      center_to_max.Y * Math.Abs(m_planes[i].Normal.Y) +                      center_to_max.Z * Math.Abs(m_planes[i].Normal.Z);                    if (center_dist + nearest_corner_dist < 0)                  {                      return false;                  }              }
Magic Number,Sce.Atf.VectorMath,Frustum,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Frustum.cs,ContainsPolygon,The following statement contains a magic number: for (int p = 0; p < 6; p++)              {                  int v = 0;                  for (; v < vertices.Length; v++)                  {                      float dist = m_planes[p].SignedDistance(vertices[v]);                      if (dist > 0.0f)                          break;                  }                  if (v == vertices.Length)                      return false;              }
Magic Number,Sce.Atf.VectorMath,Frustum,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Frustum.cs,ContainsPolygon,The following statement contains a magic number: if (backfaceCull)              {                  // First calculate polygon normal' pointing "out from" the visible side.                  Vec3F normal = new Vec3F();                  for (int i = 2; i < vertices.Length; i++)                  {                      normal = Vec3F.Cross(vertices[0] - vertices[1]'                          vertices[i] - vertices[1]);                        // Make sure that these 3 verts are not collinear                      if (normal.LengthSquared != 0)                          break;                  }                    // We can't use the near plane's normal' since it may no longer be pointing in the correct                  // direction (due to non-uniform scalings' shear transforms' etc.).                  if (Vec3F.Dot(normal' vertices[0] - eye) <= 0)                  {                      return false;                  }              }
Magic Number,Sce.Atf.VectorMath,Frustum,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Frustum.cs,Transform,The following statement contains a magic number: for (int i = 0; i < 6; i++)              {                  m.Transform(m_planes[i]' transposeOfInverse' out m_planes[i]);              }
Magic Number,Sce.Atf.VectorMath,Matrix3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix3F.cs,Matrix3F,The following statement contains a magic number: M13 = m[2];
Magic Number,Sce.Atf.VectorMath,Matrix3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix3F.cs,Matrix3F,The following statement contains a magic number: M21 = m[3];
Magic Number,Sce.Atf.VectorMath,Matrix3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix3F.cs,Matrix3F,The following statement contains a magic number: M22 = m[4];
Magic Number,Sce.Atf.VectorMath,Matrix3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix3F.cs,Matrix3F,The following statement contains a magic number: M23 = m[5];
Magic Number,Sce.Atf.VectorMath,Matrix3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix3F.cs,Matrix3F,The following statement contains a magic number: M31 = m[6];
Magic Number,Sce.Atf.VectorMath,Matrix3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix3F.cs,Matrix3F,The following statement contains a magic number: M32 = m[7];
Magic Number,Sce.Atf.VectorMath,Matrix3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix3F.cs,Matrix3F,The following statement contains a magic number: M33 = m[8];
Magic Number,Sce.Atf.VectorMath,Matrix3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix3F.cs,Set,The following statement contains a magic number: M11 = (float)(1.0 - 2.0 * q.Y * q.Y - 2.0 * q.Z * q.Z);
Magic Number,Sce.Atf.VectorMath,Matrix3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix3F.cs,Set,The following statement contains a magic number: M11 = (float)(1.0 - 2.0 * q.Y * q.Y - 2.0 * q.Z * q.Z);
Magic Number,Sce.Atf.VectorMath,Matrix3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix3F.cs,Set,The following statement contains a magic number: M21 = (float)(2.0 * (q.X * q.Y + q.W * q.Z));
Magic Number,Sce.Atf.VectorMath,Matrix3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix3F.cs,Set,The following statement contains a magic number: M31 = (float)(2.0 * (q.X * q.Z - q.W * q.Y));
Magic Number,Sce.Atf.VectorMath,Matrix3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix3F.cs,Set,The following statement contains a magic number: M12 = (float)(2.0 * (q.X * q.Y - q.W * q.Z));
Magic Number,Sce.Atf.VectorMath,Matrix3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix3F.cs,Set,The following statement contains a magic number: M22 = (float)(1.0 - 2.0 * q.X * q.X - 2.0 * q.Z * q.Z);
Magic Number,Sce.Atf.VectorMath,Matrix3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix3F.cs,Set,The following statement contains a magic number: M22 = (float)(1.0 - 2.0 * q.X * q.X - 2.0 * q.Z * q.Z);
Magic Number,Sce.Atf.VectorMath,Matrix3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix3F.cs,Set,The following statement contains a magic number: M32 = (float)(2.0 * (q.Y * q.Z + q.W * q.X));
Magic Number,Sce.Atf.VectorMath,Matrix3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix3F.cs,Set,The following statement contains a magic number: M13 = (float)(2.0 * (q.X * q.Z + q.W * q.Y));
Magic Number,Sce.Atf.VectorMath,Matrix3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix3F.cs,Set,The following statement contains a magic number: M23 = (float)(2.0 * (q.Y * q.Z - q.W * q.X));
Magic Number,Sce.Atf.VectorMath,Matrix3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix3F.cs,Set,The following statement contains a magic number: M33 = (float)(1.0 - 2.0 * q.X * q.X - 2.0 * q.Y * q.Y);
Magic Number,Sce.Atf.VectorMath,Matrix3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix3F.cs,Set,The following statement contains a magic number: M33 = (float)(1.0 - 2.0 * q.X * q.X - 2.0 * q.Y * q.Y);
Magic Number,Sce.Atf.VectorMath,Matrix3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix3F.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + M11.GetHashCode();
Magic Number,Sce.Atf.VectorMath,Matrix3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix3F.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + M12.GetHashCode();
Magic Number,Sce.Atf.VectorMath,Matrix3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix3F.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + M13.GetHashCode();
Magic Number,Sce.Atf.VectorMath,Matrix3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix3F.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + M21.GetHashCode();
Magic Number,Sce.Atf.VectorMath,Matrix3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix3F.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + M22.GetHashCode();
Magic Number,Sce.Atf.VectorMath,Matrix3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix3F.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + M23.GetHashCode();
Magic Number,Sce.Atf.VectorMath,Matrix3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix3F.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + M31.GetHashCode();
Magic Number,Sce.Atf.VectorMath,Matrix3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix3F.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + M32.GetHashCode();
Magic Number,Sce.Atf.VectorMath,Matrix3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix3F.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + M33.GetHashCode();
Magic Number,Sce.Atf.VectorMath,Matrix3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix3F.cs,GetHashCode,The following statement contains a magic number: return (int)(bits ^ (bits >> 32));
Magic Number,Sce.Atf.VectorMath,Matrix3x2F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix3x2F.cs,CreateRotation,The following statement contains a magic number: double radians = (angle * 3.1415926535897931) / 180.0;
Magic Number,Sce.Atf.VectorMath,Matrix3x2F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix3x2F.cs,CreateRotation,The following statement contains a magic number: double radians = (angle * 3.1415926535897931) / 180.0;
Magic Number,Sce.Atf.VectorMath,Matrix3x2F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix3x2F.cs,CreateRotation,The following statement contains a magic number: double radians = (angle * 3.1415926535897931) / 180.0;
Magic Number,Sce.Atf.VectorMath,Matrix3x2F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix3x2F.cs,CreateRotation,The following statement contains a magic number: double radians = (angle * 3.1415926535897931) / 180.0;
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Set,The following statement contains a magic number: M13 = m[2];
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Set,The following statement contains a magic number: M14 = m[3];
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Set,The following statement contains a magic number: M21 = m[4];
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Set,The following statement contains a magic number: M22 = m[5];
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Set,The following statement contains a magic number: M23 = m[6];
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Set,The following statement contains a magic number: M24 = m[7];
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Set,The following statement contains a magic number: M31 = m[8];
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Set,The following statement contains a magic number: M32 = m[9];
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Set,The following statement contains a magic number: M33 = m[10];
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Set,The following statement contains a magic number: M34 = m[11];
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Set,The following statement contains a magic number: M41 = m[12];
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Set,The following statement contains a magic number: M42 = m[13];
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Set,The following statement contains a magic number: M43 = m[14];
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Set,The following statement contains a magic number: M44 = m[15];
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Set,The following statement contains a magic number: M11 = (float)(1.0 - 2.0 * q.Y * q.Y - 2.0 * q.Z * q.Z);
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Set,The following statement contains a magic number: M11 = (float)(1.0 - 2.0 * q.Y * q.Y - 2.0 * q.Z * q.Z);
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Set,The following statement contains a magic number: M21 = (float)(2.0 * (q.X * q.Y + q.W * q.Z));
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Set,The following statement contains a magic number: M31 = (float)(2.0 * (q.X * q.Z - q.W * q.Y));
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Set,The following statement contains a magic number: M12 = (float)(2.0 * (q.X * q.Y - q.W * q.Z));
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Set,The following statement contains a magic number: M22 = (float)(1.0 - 2.0 * q.X * q.X - 2.0 * q.Z * q.Z);
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Set,The following statement contains a magic number: M22 = (float)(1.0 - 2.0 * q.X * q.X - 2.0 * q.Z * q.Z);
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Set,The following statement contains a magic number: M32 = (float)(2.0 * (q.Y * q.Z + q.W * q.X));
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Set,The following statement contains a magic number: M13 = (float)(2.0 * (q.X * q.Z + q.W * q.Y));
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Set,The following statement contains a magic number: M23 = (float)(2.0 * (q.Y * q.Z - q.W * q.X));
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Set,The following statement contains a magic number: M33 = (float)(1.0 - 2.0 * q.X * q.X - 2.0 * q.Y * q.Y);
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,Set,The following statement contains a magic number: M33 = (float)(1.0 - 2.0 * q.X * q.X - 2.0 * q.Y * q.Y);
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + M11.GetHashCode();
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + M12.GetHashCode();
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + M13.GetHashCode();
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + M14.GetHashCode();
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + M21.GetHashCode();
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + M22.GetHashCode();
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + M23.GetHashCode();
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + M24.GetHashCode();
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + M31.GetHashCode();
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + M32.GetHashCode();
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + M33.GetHashCode();
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + M34.GetHashCode();
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + M41.GetHashCode();
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + M42.GetHashCode();
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + M43.GetHashCode();
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + M44.GetHashCode();
Magic Number,Sce.Atf.VectorMath,Matrix4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Matrix4F.cs,GetHashCode,The following statement contains a magic number: return (int)(bits ^ (bits >> 32));
Magic Number,Sce.Atf.VectorMath,Polygon3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Polygon3F.cs,Triangulate,The following statement contains a magic number: if (polygon.Count < 3)                  throw new InvalidOperationException("Polygon has less than 3 vertices");
Magic Number,Sce.Atf.VectorMath,Polygon3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Polygon3F.cs,Triangulate,The following statement contains a magic number: if (polygon.Count == 3)              {                  // This is a triangle so just add any arbitrary vertex as an ear                  polygon.First.Value.IsEar = true;                  ears.Add(polygon.First);              }              else              {                  LinkedListNode<TriVx> current = null;                    // Update reflex flag                  for (current = polygon.First; current != null; current = current.Next)                      current.Value.IsReflex = IsReflex(current' normal);                    // Construct ears from all convex vertices                  for (current = polygon.First; current != null; current = current.Next)                  {                      if (!current.Value.IsReflex && IsEar(current' normal))                      {                          current.Value.IsEar = true;                          ears.Add(current);                      }                  }              }
Magic Number,Sce.Atf.VectorMath,Polygon3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Polygon3F.cs,Triangulate,The following statement contains a magic number: while (polygon.Count > 0 && ears.Count > 0)              {                  LinkedListNode<TriVx> node = ears[0];                  LinkedListNode<TriVx> prev = PrevNode(node);                  LinkedListNode<TriVx> next = NextNode(node);                    tris.Add(new Triangle3F(prev.Value.V' node.Value.V' next.Value.V));                    if (polygon.Count == 3)                      polygon.Clear();                  else                  {                      ears.Remove(node);                      polygon.Remove(node);                        // Now test adjacent vertices                      // If adjacent vertex is convex it remains convex' otherwise it needs testing                      if (prev.Value.IsReflex)                          prev.Value.IsReflex = IsReflex(prev' normal);                        if (!prev.Value.IsReflex)                          UpdateEar(prev' ears' normal);                        // Do the same for next                       if (next.Value.IsReflex)                          next.Value.IsReflex = IsReflex(next' normal);                        if (!next.Value.IsReflex)                          UpdateEar(next' ears' normal);                  }              }
Magic Number,Sce.Atf.VectorMath,QuatF,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\QuatF.cs,QuatF,The following statement contains a magic number: if (coords.Length < 4)                  throw new ArgumentException("not enough coords");
Magic Number,Sce.Atf.VectorMath,QuatF,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\QuatF.cs,QuatF,The following statement contains a magic number: Z = coords[2];
Magic Number,Sce.Atf.VectorMath,QuatF,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\QuatF.cs,QuatF,The following statement contains a magic number: W = coords[3];
Magic Number,Sce.Atf.VectorMath,QuatF,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\QuatF.cs,Set,The following statement contains a magic number: double ww = 0.25 * (m.M11 + m.M22 + m.M33 + 1.0f);
Magic Number,Sce.Atf.VectorMath,QuatF,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\QuatF.cs,Set,The following statement contains a magic number: if (ww >= 0)              {                  if (ww >= EPS2)                  {                      double wwSqrt = Math.Sqrt(ww);                      W = (float)wwSqrt;                      ww = 0.25 / wwSqrt;                      X = (float)((m.M32 - m.M23) * ww);                      Y = (float)((m.M13 - m.M31) * ww);                      Z = (float)((m.M21 - m.M12) * ww);                      return;                  }              }              else              {                  W = 0;                  X = 0;                  Y = 0;                  Z = 1;                  return;              }
Magic Number,Sce.Atf.VectorMath,QuatF,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\QuatF.cs,Set,The following statement contains a magic number: ww = -0.5 * (m.M22 + m.M33);
Magic Number,Sce.Atf.VectorMath,QuatF,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\QuatF.cs,Set,The following statement contains a magic number: if (ww >= 0)              {                  if (ww >= EPS2)                  {                      double wwSqrt = Math.Sqrt(ww);                      X = (float)wwSqrt;                      ww = 0.5 / wwSqrt;                      Y = (float)(m.M21 * ww);                      Z = (float)(m.M31 * ww);                      return;                  }              }              else              {                  X = 0;                  Y = 0;                  Z = 1;                  return;              }
Magic Number,Sce.Atf.VectorMath,QuatF,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\QuatF.cs,Set,The following statement contains a magic number: ww = 0.5 * (1.0f - m.M33);
Magic Number,Sce.Atf.VectorMath,QuatF,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\QuatF.cs,Set,The following statement contains a magic number: if (ww >= EPS2)              {                  double wwSqrt = Math.Sqrt(ww);                  Y = (float)wwSqrt;                  Z = (float)(m.M32 / (2.0 * wwSqrt));              }              else              {                  Y = 0;                  Z = 1;              }
Magic Number,Sce.Atf.VectorMath,QuatF,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\QuatF.cs,FromAxisAngle,The following statement contains a magic number: if (mag < EPS)              {                  temp = new QuatF(0' 0' 0' 0);              }              else              {                  double sin = Math.Sin(angle / 2.0);                  double scale = sin / mag;                  temp.W = (float)Math.Cos(angle / 2.0);                  temp.X = (float)(axis.X * scale);                  temp.Y = (float)(axis.Y * scale);                  temp.Z = (float)(axis.Z * scale);              }
Magic Number,Sce.Atf.VectorMath,QuatF,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\QuatF.cs,FromAxisAngle,The following statement contains a magic number: if (mag < EPS)              {                  temp = new QuatF(0' 0' 0' 0);              }              else              {                  double sin = Math.Sin(angle / 2.0);                  double scale = sin / mag;                  temp.W = (float)Math.Cos(angle / 2.0);                  temp.X = (float)(axis.X * scale);                  temp.Y = (float)(axis.Y * scale);                  temp.Z = (float)(axis.Z * scale);              }
Magic Number,Sce.Atf.VectorMath,QuatF,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\QuatF.cs,Set,The following statement contains a magic number: if (mag < EPS)              {                  X = Y = Z = W = 0;              }              else              {                  double sin = Math.Sin(a.Angle / 2.0);                  double scale = sin / mag;                  W = (float)Math.Cos(a.Angle / 2.0);                  X = (float)(a.Axis.X * scale);                  Y = (float)(a.Axis.Y * scale);                  Z = (float)(a.Axis.Z * scale);              }
Magic Number,Sce.Atf.VectorMath,QuatF,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\QuatF.cs,Set,The following statement contains a magic number: if (mag < EPS)              {                  X = Y = Z = W = 0;              }              else              {                  double sin = Math.Sin(a.Angle / 2.0);                  double scale = sin / mag;                  W = (float)Math.Cos(a.Angle / 2.0);                  X = (float)(a.Axis.X * scale);                  Y = (float)(a.Axis.Y * scale);                  Z = (float)(a.Axis.Z * scale);              }
Magic Number,Sce.Atf.VectorMath,QuatF,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\QuatF.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + W.GetHashCode();
Magic Number,Sce.Atf.VectorMath,QuatF,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\QuatF.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + X.GetHashCode();
Magic Number,Sce.Atf.VectorMath,QuatF,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\QuatF.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + Y.GetHashCode();
Magic Number,Sce.Atf.VectorMath,QuatF,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\QuatF.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + Z.GetHashCode();
Magic Number,Sce.Atf.VectorMath,QuatF,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\QuatF.cs,GetHashCode,The following statement contains a magic number: return (int)(bits ^ (bits >> 32));
Magic Number,Sce.Atf.VectorMath,Ray3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Ray3F.cs,IntersectPolygon,The following statement contains a magic number: for (int i = 2; i < vertices.Length; i++)              {                  normal = Vec3F.Cross(vertices[i] - vertices[1]' vertices[0] - vertices[1]);                    // Make sure that these 3 verts are not collinear                  float lengthSquared = normal.LengthSquared;                  if (lengthSquared != 0)                  {                      normal *= (1.0f / (float)Math.Sqrt(lengthSquared));                      break;                  }              }
Magic Number,Sce.Atf.VectorMath,Vec2F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Vec2F.cs,Vec2F,The following statement contains a magic number: if (coords.Length < 2)                  throw new ArgumentException("not enough coords");
Magic Number,Sce.Atf.VectorMath,Vec2F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Vec2F.cs,Set,The following statement contains a magic number: if (coords.Length < 2)                  throw new ArgumentException("not enough coords");
Magic Number,Sce.Atf.VectorMath,Vec2F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Vec2F.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + X.GetHashCode();
Magic Number,Sce.Atf.VectorMath,Vec2F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Vec2F.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + Y.GetHashCode();
Magic Number,Sce.Atf.VectorMath,Vec2F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Vec2F.cs,GetHashCode,The following statement contains a magic number: return (int)(bits ^ (bits >> 32));
Magic Number,Sce.Atf.VectorMath,Vec3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Vec3F.cs,Vec3F,The following statement contains a magic number: Z = coords[2];
Magic Number,Sce.Atf.VectorMath,Vec3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Vec3F.cs,Set,The following statement contains a magic number: Z = coords[2];
Magic Number,Sce.Atf.VectorMath,Vec3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Vec3F.cs,Parse,The following statement contains a magic number: if (components.Length != 3)                  throw new System.FormatException();
Magic Number,Sce.Atf.VectorMath,Vec3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Vec3F.cs,Parse,The following statement contains a magic number: for (int i = 0; i < 3; i++)                  result[i] = float.Parse(components[i]);
Magic Number,Sce.Atf.VectorMath,Vec3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Vec3F.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + X.GetHashCode();
Magic Number,Sce.Atf.VectorMath,Vec3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Vec3F.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + Y.GetHashCode();
Magic Number,Sce.Atf.VectorMath,Vec3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Vec3F.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + Z.GetHashCode();
Magic Number,Sce.Atf.VectorMath,Vec3F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Vec3F.cs,GetHashCode,The following statement contains a magic number: return (int)(bits ^ (bits >> 32));
Magic Number,Sce.Atf.VectorMath,Vec4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Vec4F.cs,Vec4F,The following statement contains a magic number: if (coords.Length < 4)                  throw new ArgumentException("not enough coords");
Magic Number,Sce.Atf.VectorMath,Vec4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Vec4F.cs,Vec4F,The following statement contains a magic number: Z = coords[2];
Magic Number,Sce.Atf.VectorMath,Vec4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Vec4F.cs,Vec4F,The following statement contains a magic number: W = coords[3];
Magic Number,Sce.Atf.VectorMath,Vec4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Vec4F.cs,Set,The following statement contains a magic number: if (coords.Length < 4)                  throw new ArgumentException("not enough coords");
Magic Number,Sce.Atf.VectorMath,Vec4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Vec4F.cs,Set,The following statement contains a magic number: Z = coords[2];
Magic Number,Sce.Atf.VectorMath,Vec4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Vec4F.cs,Set,The following statement contains a magic number: W = coords[3];
Magic Number,Sce.Atf.VectorMath,Vec4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Vec4F.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + X.GetHashCode();
Magic Number,Sce.Atf.VectorMath,Vec4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Vec4F.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + Y.GetHashCode();
Magic Number,Sce.Atf.VectorMath,Vec4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Vec4F.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + Z.GetHashCode();
Magic Number,Sce.Atf.VectorMath,Vec4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Vec4F.cs,GetHashCode,The following statement contains a magic number: bits = 31 * bits + W.GetHashCode();
Magic Number,Sce.Atf.VectorMath,Vec4F,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\VectorMath\Vec4F.cs,GetHashCode,The following statement contains a magic number: return (int)(bits ^ (bits >> 32));
Missing Default,Sce.Atf,Outputs,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Outputs.cs,Write,The following switch statement is missing a default case: switch (type)              {                  case OutputMessageType.Error:                      s_atfOutputTracer.TraceEvent(TraceEventType.Error' id' message);                      break;                  case OutputMessageType.Warning:                      s_atfOutputTracer.TraceEvent(TraceEventType.Warning' id' message);                      break;                  case OutputMessageType.Info:                      s_atfOutputTracer.TraceEvent(TraceEventType.Information' id' message);                      break;              }
Missing Default,Sce.Atf.Dom,AttributeType,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Dom\AttributeType.cs,GetDefault,The following switch statement is missing a default case: switch (m_type)              {                  case AttributeTypes.Boolean:                      result = s_defaultBoolean;                      break;                    case AttributeTypes.BooleanArray:                      result = GetDefaultArrayValue<Boolean>();                      break;                    case AttributeTypes.Int8:                      result = s_defaultInt8;                      break;                    case AttributeTypes.Int8Array:                      result = GetDefaultArrayValue<SByte>();                      break;                    case AttributeTypes.UInt8:                      result = s_defaultUInt8;                      break;                    case AttributeTypes.UInt8Array:                      result = GetDefaultArrayValue<Byte>();                      break;                    case AttributeTypes.Int16:                      result = s_defaultInt16;                      break;                    case AttributeTypes.Int16Array:                      result = GetDefaultArrayValue<Int16>();                      break;                    case AttributeTypes.UInt16:                      result = s_defaultUInt16;                      break;                    case AttributeTypes.UInt16Array:                      result = GetDefaultArrayValue<UInt16>();                      break;                    case AttributeTypes.Int32:                      result = s_defaultInt32;                      break;                    case AttributeTypes.Int32Array:                      result = GetDefaultArrayValue<Int32>();                      break;                    case AttributeTypes.UInt32:                      result = s_defaultUInt32;                      break;                    case AttributeTypes.UInt32Array:                      result = GetDefaultArrayValue<UInt32>();                      break;                    case AttributeTypes.Int64:                      result = s_defaultInt64;                      break;                    case AttributeTypes.Int64Array:                      result = GetDefaultArrayValue<Int64>();                      break;                    case AttributeTypes.UInt64:                      result = s_defaultUInt64;                      break;                    case AttributeTypes.UInt64Array:                      result = GetDefaultArrayValue<UInt64>();                      break;                    case AttributeTypes.Single:                      result = s_defaultSingle;                      break;                    case AttributeTypes.SingleArray:                      result = GetDefaultArrayValue<Single>();                      break;                    case AttributeTypes.Double:                      result = s_defaultDouble;                      break;                    case AttributeTypes.DoubleArray:                      result = GetDefaultArrayValue<Double>();                      break;                    case AttributeTypes.Decimal:                      result = s_defaultDecimal;                      break;                    case AttributeTypes.DecimalArray:                      result = GetDefaultArrayValue<Decimal>();                      break;                    case AttributeTypes.String:                      result = string.Empty;                      break;                    case AttributeTypes.StringArray:                      result = GetDefaultArrayValue<String>();                      break;                    case AttributeTypes.Reference:                      break;                    //case AttributeTypes.Uri: // null' no good default value for URI                  //    break;                    case AttributeTypes.DateTime:                      result = s_defaultDateTime;                      break;              }
Missing Default,Sce.Atf.Dom,AttributeType,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Dom\AttributeType.cs,AreEqual,The following switch statement is missing a default case: switch (m_type)              {                  case AttributeTypes.Boolean:                  case AttributeTypes.Int8:                  case AttributeTypes.UInt8:                  case AttributeTypes.Int16:                  case AttributeTypes.UInt16:                  case AttributeTypes.Int32:                  case AttributeTypes.UInt32:                  case AttributeTypes.Int64:                  case AttributeTypes.UInt64:                  case AttributeTypes.Single:                  case AttributeTypes.Double:                  case AttributeTypes.Decimal:                  case AttributeTypes.String:                  case AttributeTypes.Reference:                  case AttributeTypes.Uri:                  case AttributeTypes.DateTime:                      result = val1.Equals(val2);                      break;                    case AttributeTypes.BooleanArray:                      result = AreEqualArraysOf<Boolean>(val1' val2);                      break;                    case AttributeTypes.Int8Array:                      result = AreEqualArraysOf<SByte>(val1' val2);                      break;                    case AttributeTypes.UInt8Array:                      result = AreEqualArraysOf<Byte>(val1' val2);                      break;                    case AttributeTypes.Int16Array:                      result = AreEqualArraysOf<Int16>(val1' val2);                      break;                    case AttributeTypes.UInt16Array:                      result = AreEqualArraysOf<UInt16>(val1' val2);                      break;                    case AttributeTypes.Int32Array:                      result = AreEqualArraysOf<Int32>(val1' val2);                      break;                    case AttributeTypes.UInt32Array:                      result = AreEqualArraysOf<UInt32>(val1' val2);                      break;                    case AttributeTypes.Int64Array:                      result = AreEqualArraysOf<Int64>(val1' val2);                      break;                    case AttributeTypes.UInt64Array:                      result = AreEqualArraysOf<UInt64>(val1' val2);                      break;                    case AttributeTypes.SingleArray:                      result = AreEqualArraysOf<Single>(val1' val2);                      break;                    case AttributeTypes.DoubleArray:                      result = AreEqualArraysOf<Double>(val1' val2);                      break;                    case AttributeTypes.DecimalArray:                      result = AreEqualArraysOf<Decimal>(val1' val2);                      break;                    case AttributeTypes.StringArray:                      result = AreEqualArraysOf<String>(val1' val2);                      break;              }
Missing Default,Sce.Atf.Dom,AttributeType,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Dom\AttributeType.cs,Clone,The following switch statement is missing a default case: switch (m_type)                  {                      case AttributeTypes.Boolean:                      case AttributeTypes.Int8:                      case AttributeTypes.UInt8:                      case AttributeTypes.Int16:                      case AttributeTypes.UInt16:                      case AttributeTypes.Int32:                      case AttributeTypes.UInt32:                      case AttributeTypes.Int64:                      case AttributeTypes.UInt64:                      case AttributeTypes.Single:                      case AttributeTypes.Double:                      case AttributeTypes.Decimal:                      case AttributeTypes.String:                      case AttributeTypes.Reference:                      case AttributeTypes.Uri:                      case AttributeTypes.DateTime:                          result = value; // immutable types don't need to be cloned                          break;                        case AttributeTypes.BooleanArray:                          result = ((Boolean[])value).Clone();                          break;                        case AttributeTypes.Int8Array:                          result = ((SByte[])value).Clone();                          break;                        case AttributeTypes.UInt8Array:                          result = ((Byte[])value).Clone();                          break;                        case AttributeTypes.Int16Array:                          result = ((Int16[])value).Clone();                          break;                        case AttributeTypes.UInt16Array:                          result = ((UInt16[])value).Clone();                          break;                        case AttributeTypes.Int32Array:                          result = ((Int32[])value).Clone();                          break;                        case AttributeTypes.UInt32Array:                          result = ((UInt32[])value).Clone();                          break;                        case AttributeTypes.Int64Array:                          result = ((Int64[])value).Clone();                          break;                        case AttributeTypes.UInt64Array:                          result = ((UInt64[])value).Clone();                          break;                        case AttributeTypes.SingleArray:                          result = ((Single[])value).Clone();                          break;                        case AttributeTypes.DoubleArray:                          result = ((Double[])value).Clone();                          break;                        case AttributeTypes.DecimalArray:                          result = ((Decimal[])value).Clone();                          break;                        case AttributeTypes.StringArray:                          result = ((String[])value).Clone();                          break;                  }
Missing Default,Sce.Atf.Dom,AttributeType,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Dom\AttributeType.cs,Convert,The following switch statement is missing a default case: switch (m_type)              {                  case AttributeTypes.Int8:                  case AttributeTypes.UInt8:                  case AttributeTypes.Int16:                  case AttributeTypes.UInt16:                  case AttributeTypes.Int32:                  case AttributeTypes.UInt32:                  case AttributeTypes.Int64:                  case AttributeTypes.UInt64:                  case AttributeTypes.Decimal:                      result = ((IFormattable)value).ToString(null' CultureInfo.InvariantCulture);                      break;                  case AttributeTypes.DateTime:                      // Persist in UTC.                      DateTime utc = ((DateTime)value).ToUniversalTime();                      result = utc.ToString("o"' DateTimeFormatInfo.InvariantInfo); //round-trip                      break;                  case AttributeTypes.Single:                  case AttributeTypes.Double:                      result = ((IFormattable)value).ToString("R"' CultureInfo.InvariantCulture);                      break;                    case AttributeTypes.String:                      result = value.ToString();                      break;                  case AttributeTypes.Uri:                      result = Uri.EscapeUriString(Uri.UnescapeDataString(value.ToString()));                      break;                    //case AttributeTypes.Reference: // references require special handling by persisters                  //    break;                    // we need to convert "True" and "False" to lower case to be valid xs:boolean values                  case AttributeTypes.Boolean:                      result = (bool)value ? "true" : "false";                      break;                    case AttributeTypes.Int8Array:                      result = Convert<SByte>(value);                      break;                    case AttributeTypes.UInt8Array:                      result = Convert<Byte>(value);                      break;                    case AttributeTypes.Int16Array:                      result = Convert<Int16>(value);                      break;                    case AttributeTypes.UInt16Array:                      result = Convert<UInt16>(value);                      break;                    case AttributeTypes.Int32Array:                      result = Convert<Int32>(value);                      break;                    case AttributeTypes.UInt32Array:                      result = Convert<UInt32>(value);                      break;                    case AttributeTypes.Int64Array:                      result = Convert<Int64>(value);                      break;                    case AttributeTypes.UInt64Array:                      result = Convert<UInt64>(value);                      break;                    case AttributeTypes.SingleArray:                      result = Convert<Single>(value);                      break;                    case AttributeTypes.DoubleArray:                      result = Convert<Double>(value);                      break;                    case AttributeTypes.DecimalArray:                      result = Convert<Decimal>(value);                      break;                    case AttributeTypes.StringArray:                      result = ConvertStringArrayToString((string[])value);                      break;                    case AttributeTypes.BooleanArray:                      sb = new StringBuilder();                      foreach (bool b in value as bool[])                      {                          sb.Append(b ? "true" : "false");                          sb.Append(" ");                      }                      if (sb.Length > 0)                          sb.Length -= 1; // remove trailing space                      result = sb.ToString();                      break;              }
Missing Default,Sce.Atf.Dom,AttributeType,C:\repos\SonyWWS_LevelEditor\ATF\Framework\Atf.Core\Dom\AttributeType.cs,Convert,The following switch statement is missing a default case: switch (m_type)              {                  case AttributeTypes.Boolean:                      Boolean boolResult;                      if (Boolean.TryParse(s' out boolResult))                          result = boolResult;                      break;                    case AttributeTypes.Int8:                      SByte int8Result;                      if (SByte.TryParse(s' NumberStyles.Integer' CultureInfo.InvariantCulture' out int8Result))                          result = int8Result;                      break;                    case AttributeTypes.UInt8:                      Byte uint8Result;                      if (Byte.TryParse(s' NumberStyles.Integer' CultureInfo.InvariantCulture' out uint8Result))                          result = uint8Result;                      break;                    case AttributeTypes.Int16:                      Int16 int16Result;                      if (Int16.TryParse(s' NumberStyles.Integer' CultureInfo.InvariantCulture' out int16Result))                          result = int16Result;                      break;                    case AttributeTypes.UInt16:                      UInt16 uint16Result;                      if (UInt16.TryParse(s' NumberStyles.Integer' CultureInfo.InvariantCulture' out uint16Result))                          result = uint16Result;                      break;                    case AttributeTypes.Int32:                      Int32 int32Result;                      if (Int32.TryParse(s' NumberStyles.Integer' CultureInfo.InvariantCulture' out int32Result))                          result = int32Result;                      break;                    case AttributeTypes.UInt32:                      UInt32 uint32Result;                      if (UInt32.TryParse(s' NumberStyles.Integer' CultureInfo.InvariantCulture' out uint32Result))                          result = uint32Result;                      break;                    case AttributeTypes.Int64:                      Int64 int64Result;                      if (Int64.TryParse(s' NumberStyles.Integer' CultureInfo.InvariantCulture' out int64Result))                          result = int64Result;                      break;                    case AttributeTypes.UInt64:                      UInt64 uint64Result;                      if (UInt64.TryParse(s' NumberStyles.Integer' CultureInfo.InvariantCulture' out uint64Result))                          result = uint64Result;                      break;                    case AttributeTypes.Single:                      Single singleResult;                      if (Single.TryParse(s' NumberStyles.Float' CultureInfo.InvariantCulture' out singleResult))                          result = singleResult;                      break;                    case AttributeTypes.Double:                      Double doubleResult;                      if (Double.TryParse(s' NumberStyles.Float' CultureInfo.InvariantCulture' out doubleResult))                          result = doubleResult;                      break;                    case AttributeTypes.Decimal:                      Decimal decimalResult;                      if (Decimal.TryParse(s' NumberStyles.Number' CultureInfo.InvariantCulture' out decimalResult))                          result = decimalResult;                      break;                    case AttributeTypes.String:                      result = s;                      break;                    case AttributeTypes.Uri:                      Uri uri;                      Uri.TryCreate(s' UriKind.RelativeOrAbsolute' out uri);                      result = uri;                      break;                    //case AttributeTypes.Reference: // references require special handling by persisters                  //    break;                    case AttributeTypes.DateTime:                      // Use local time in the client app.                      DateTime dateTimeResult;                      if (DateTime.TryParse(s' DateTimeFormatInfo.InvariantInfo' DateTimeStyles.RoundtripKind' out dateTimeResult))                          dateTimeResult = dateTimeResult.ToLocalTime();                      result = dateTimeResult;                      break;                    case AttributeTypes.BooleanArray:                      Boolean[] booleans = CreateArrayValue<Boolean>(s' out strings' out stringsToParse);                      for (int i = 0; i < stringsToParse; i++)                          Boolean.TryParse(strings[i]' out booleans[i]);                      result = booleans;                      break;                    case AttributeTypes.Int8Array:                      SByte[] int8s = CreateArrayValue<SByte>(s' out strings' out stringsToParse);                      for (int i = 0; i < stringsToParse; i++)                          SByte.TryParse(strings[i]' NumberStyles.Integer' CultureInfo.InvariantCulture' out int8s[i]);                      result = int8s;                      break;                    case AttributeTypes.UInt8Array:                      Byte[] uint8s = CreateArrayValue<Byte>(s' out strings' out stringsToParse);                      for (int i = 0; i < stringsToParse; i++)                          Byte.TryParse(strings[i]' NumberStyles.Integer' CultureInfo.InvariantCulture' out uint8s[i]);                      result = uint8s;                      break;                    case AttributeTypes.Int16Array:                      Int16[] int16s = CreateArrayValue<Int16>(s' out strings' out stringsToParse);                      for (int i = 0; i < stringsToParse; i++)                          Int16.TryParse(strings[i]' NumberStyles.Integer' CultureInfo.InvariantCulture' out int16s[i]);                      result = int16s;                      break;                    case AttributeTypes.UInt16Array:                      UInt16[] uint16s = CreateArrayValue<UInt16>(s' out strings' out stringsToParse);                      for (int i = 0; i < stringsToParse; i++)                          UInt16.TryParse(strings[i]' NumberStyles.Integer' CultureInfo.InvariantCulture' out uint16s[i]);                      result = uint16s;                      break;                    case AttributeTypes.Int32Array:                      Int32[] int32s = CreateArrayValue<Int32>(s' out strings' out stringsToParse);                      for (int i = 0; i < stringsToParse; i++)                          Int32.TryParse(strings[i]' NumberStyles.Integer' CultureInfo.InvariantCulture' out int32s[i]);                      result = int32s;                      break;                    case AttributeTypes.UInt32Array:                      UInt32[] uint32s = CreateArrayValue<UInt32>(s' out strings' out stringsToParse);                      for (int i = 0; i < stringsToParse; i++)                          UInt32.TryParse(strings[i]' NumberStyles.Integer' CultureInfo.InvariantCulture' out uint32s[i]);                      result = uint32s;                      break;                    case AttributeTypes.Int64Array:                      Int64[] int64s = CreateArrayValue<Int64>(s' out strings' out stringsToParse);                      for (int i = 0; i < stringsToParse; i++)                          Int64.TryParse(strings[i]' NumberStyles.Integer' CultureInfo.InvariantCulture' out int64s[i]);                      result = int64s;                      break;                    case AttributeTypes.UInt64Array:                      UInt64[] uint64s = CreateArrayValue<UInt64>(s' out strings' out stringsToParse);                      for (int i = 0; i < stringsToParse; i++)                          UInt64.TryParse(strings[i]' NumberStyles.Integer' CultureInfo.InvariantCulture' out uint64s[i]);                      result = uint64s;                      break;                    case AttributeTypes.SingleArray:                      Single[] singles = CreateArrayValue<Single>(s' out strings' out stringsToParse);                      for (int i = 0; i < stringsToParse; i++)                          Single.TryParse(strings[i]' NumberStyles.Float' CultureInfo.InvariantCulture' out singles[i]);                      result = singles;                      break;                    case AttributeTypes.DoubleArray:                      Double[] doubles = CreateArrayValue<Double>(s' out strings' out stringsToParse);                      for (int i = 0; i < stringsToParse; i++)                          Double.TryParse(strings[i]' NumberStyles.Float' CultureInfo.InvariantCulture' out doubles[i]);                      result = doubles;                      break;                    case AttributeTypes.DecimalArray:                      Decimal[] decimals = CreateArrayValue<Decimal>(s' out strings' out stringsToParse);                      for (int i = 0; i < stringsToParse; i++)                          Decimal.TryParse(strings[i]' NumberStyles.Number' CultureInfo.InvariantCulture' out decimals[i]);                      result = decimals;                      break;                    case AttributeTypes.StringArray:                      result = ConvertStringToStringArray(s);                      break;              }
