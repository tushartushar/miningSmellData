Implementation smell,Namespace,Class,File,Method,Description
Long Method,DemoInfo,Equipment,C:\repos\EHVAG_demoinfo\DemoInfo\Events.cs,MapEquipment,The method has 163 lines of code.
Long Method,DemoInfo.DP.Handler,GameEventHandler,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Handler\GameEventHandler.cs,Apply,The method has 281 lines of code.
Complex Method,DemoInfo,DemoParser,C:\repos\EHVAG_demoinfo\DemoInfo\DemoParser.cs,ParseNextTick,Cyclomatic complexity of the method is 10
Complex Method,DemoInfo.DP.Handler,GameEventHandler,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Handler\GameEventHandler.cs,Apply,Cyclomatic complexity of the method is 16
Complex Method,DemoInfo.DP.Handler,CreateStringTableUserInfoHandler,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Handler\CreateStringTableUserInfoHandler.cs,Apply,Cyclomatic complexity of the method is 16
Complex Method,DemoInfo.ST,StringTableParser,C:\repos\EHVAG_demoinfo\DemoInfo\ST\StringTableParser.cs,ParseStringTable,Cyclomatic complexity of the method is 9
Long Identifier,DemoInfo,NETTick,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\NETTick.cs,,The length of the parameter HostComputationTimeStdDeviation is 31.
Long Identifier,DemoInfo,NETTick,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\NETTick.cs,,The length of the parameter HostFramestartTimeStdDeviation is 30.
Long Identifier,DemoInfo.DP.Handler,PropDecoder,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Handler\PropDecoder.cs,,The length of the parameter COORD_FRACTIONAL_BITS_MP_LOWPRECISION is 37.
Long Identifier,DemoInfo.DP.Handler,PropDecoder,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Handler\PropDecoder.cs,,The length of the parameter COORD_DENOMINATOR_LOWPRECISION is 30.
Long Statement,DemoInfo,DemoParser,C:\repos\EHVAG_demoinfo\DemoInfo\DemoParser.cs,ParseNextTick,The length of the statement  "				throw new InvalidOperationException ("You need to call ParseHeader first before you call ParseToEnd or ParseNextTick!"); " is 120.
Long Statement,DemoInfo,DemoParser,C:\repos\EHVAG_demoinfo\DemoInfo\DemoParser.cs,HandlePlayers,The length of the statement  "			SendTableParser.FindByName("CCSPlayer").OnNewEntity += (object sender' EntityCreatedEventArgs e) => HandleNewPlayer (e.Entity); " is 127.
Long Statement,DemoInfo,DemoParser,C:\repos\EHVAG_demoinfo\DemoInfo\DemoParser.cs,HandleNewPlayer,The length of the statement  "			playerEntity.FindProperty("m_unRoundStartEquipmentValue").IntRecived += (sender' e) => p.RoundStartEquipmentValue = e.Value; " is 124.
Long Statement,DemoInfo,DemoParser,C:\repos\EHVAG_demoinfo\DemoInfo\DemoParser.cs,HandleNewPlayer,The length of the statement  "			playerEntity.FindProperty("m_unFreezetimeEndEquipmentValue").IntRecived += (sender' e) => p.FreezetimeEndEquipmentValue = e.Value; " is 130.
Long Statement,DemoInfo.DP,PropertyEntry,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Entity.cs,CheckBindings,The length of the statement  "			if (VectorRecived != null && (this.Entry.Prop.Type != SendPropertyType.Vector && this.Entry.Prop.Type != SendPropertyType.VectorXY)) " is 132.
Long Statement,DemoInfo.DP.Handler,GameEventHandler,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Handler\GameEventHandler.cs,Apply,The length of the statement  "			//if (eventDescriptor.Name != "player_footstep" && eventDescriptor.Name != "weapon_fire" && eventDescriptor.Name != "player_jump") { " is 132.
Long Statement,DemoInfo.DT,DataTableParser,C:\repos\EHVAG_demoinfo\DemoInfo\DT\DataTableParser.cs,GatherProps_IterateProps,The length of the statement  "                if (property.Flags.HasFlagFast(SendPropertyFlags.InsideArray) || property.Flags.HasFlagFast(SendPropertyFlags.Exclude) || IsPropExcluded(table' property)) " is 154.
Long Statement,DemoInfo.DT,FlattenedPropEntry,C:\repos\EHVAG_demoinfo\DemoInfo\DT\ServerClass.cs,ToString,The length of the statement  "			return string.Format("[FlattenedPropEntry: PropertyName={2}' Prop={0}' ArrayElementProp={1}]"' Prop' ArrayElementProp' PropertyName); " is 133.
Long Statement,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,PeekInt,The length of the statement  "			Debug.Assert(mayOverflow || ((Offset + numBits) <= (BitsInBuffer + (SLED * 8)))' "gg"' "This code just fell apart. We're all dead. Offset={0} numBits={1} BitsInBuffer={2}"' Offset' numBits' BitsInBuffer); " is 204.
Long Statement,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,PeekInt,The length of the statement  "			return (uint)((BitConverter.ToUInt64(Buffer' (Offset / 8) & ~3) << ((8 * 8) - (Offset % (8 * 4)) - numBits)) >> ((8 * 8) - numBits)); " is 133.
Long Statement,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,ReadSignedInt,The length of the statement  "			var result = (int)(((long)(BitConverter.ToUInt64(Buffer' (Offset / 8) & ~3) << ((8 * 8) - (Offset % (8 * 4)) - numBits))) >> ((8 * 8) - numBits)); " is 146.
Long Statement,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,PeekInt,The length of the statement  "			Debug.Assert(mayOverflow || ((Offset + numBits) <= (BitsInBuffer + (SLED * 8)))' "gg"' "This code just fell apart. We're all dead. Offset={0} numBits={1} BitsInBuffer={2}"' Offset' numBits' BitsInBuffer); " is 204.
Long Statement,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,PeekInt,The length of the statement  "			return (uint)(((*(ulong*)(PBuffer + ((Offset >> 3) & ~3))) << ((8 * 8) - ((Offset & ((8 * 4) - 1))) - numBits)) >> ((8 * 8) - numBits)); " is 136.
Long Statement,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadSignedInt,The length of the statement  "			var result = (int)(((long)((*(ulong*)(PBuffer + ((Offset >> 3) & ~3))) << ((8 * 8) - (Offset & ((8 * 4) - 1)) - numBits))) >> ((8 * 8) - numBits)); " is 147.
Complex Conditional,DemoInfo,BitStreamUtil,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitStreamUtil.cs,ReadProtobufVarIntStub,The conditional expression  "(count < 4) || ((count == 4) && (((b & 0xF8) == 0) || ((b & 0xF8) == 0xF8)))"  is complex.
Complex Conditional,DemoInfo.DP.Handler,GameEventHandler,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Handler\GameEventHandler.cs,Apply,The conditional expression  "kill.Killer != null && kill.Weapon.Class != EquipmentClass.Grenade  						&& kill.Weapon.Weapon != EquipmentElement.Revolver  						&& kill.Killer.Weapons.Any() && kill.Weapon.Weapon != EquipmentElement.World"  is complex.
Magic Number,DemoInfo,DemoParser,C:\repos\EHVAG_demoinfo\DemoInfo\DemoParser.cs,ParseHeader,The following statement contains a magic number: if (header.Protocol != 4)  				throw new InvalidDataException("Invalid Demo-Protocol");
Magic Number,DemoInfo,DemoParser,C:\repos\EHVAG_demoinfo\DemoInfo\DemoParser.cs,ParseTick,The following statement contains a magic number: IngameTick = (int)BitStream.ReadInt(32);
Magic Number,DemoInfo,DemoParser,C:\repos\EHVAG_demoinfo\DemoInfo\DemoParser.cs,ParseTick,The following statement contains a magic number: switch (command) {  			case DemoCommand.Synctick:  				break;  			case DemoCommand.Stop:  				return false;  			case DemoCommand.ConsoleCommand:  				BitStream.BeginChunk(BitStream.ReadSignedInt(32) * 8);  				BitStream.EndChunk();  				break;  			case DemoCommand.DataTables:  				BitStream.BeginChunk (BitStream.ReadSignedInt (32) * 8);  				SendTableParser.ParsePacket (BitStream);  				BitStream.EndChunk ();    				//Map the weapons in the equipmentMapping-Dictionary.  				MapEquipment ();    				//And now we have the entities' we can bind events on them.   				BindEntites();    				break;  			case DemoCommand.StringTables:  				BitStream.BeginChunk(BitStream.ReadSignedInt(32) * 8);  				StringTables.ParsePacket(BitStream' this);  				BitStream.EndChunk();  				break;  			case DemoCommand.UserCommand:  				BitStream.ReadInt(32);  				BitStream.BeginChunk(BitStream.ReadSignedInt(32) * 8);  				BitStream.EndChunk();  				break;  			case DemoCommand.Signon:  			case DemoCommand.Packet:  				ParseDemoPacket();  				break;  			default:  				throw new Exception("Can't handle Demo-Command " + command);  			}
Magic Number,DemoInfo,DemoParser,C:\repos\EHVAG_demoinfo\DemoInfo\DemoParser.cs,ParseTick,The following statement contains a magic number: switch (command) {  			case DemoCommand.Synctick:  				break;  			case DemoCommand.Stop:  				return false;  			case DemoCommand.ConsoleCommand:  				BitStream.BeginChunk(BitStream.ReadSignedInt(32) * 8);  				BitStream.EndChunk();  				break;  			case DemoCommand.DataTables:  				BitStream.BeginChunk (BitStream.ReadSignedInt (32) * 8);  				SendTableParser.ParsePacket (BitStream);  				BitStream.EndChunk ();    				//Map the weapons in the equipmentMapping-Dictionary.  				MapEquipment ();    				//And now we have the entities' we can bind events on them.   				BindEntites();    				break;  			case DemoCommand.StringTables:  				BitStream.BeginChunk(BitStream.ReadSignedInt(32) * 8);  				StringTables.ParsePacket(BitStream' this);  				BitStream.EndChunk();  				break;  			case DemoCommand.UserCommand:  				BitStream.ReadInt(32);  				BitStream.BeginChunk(BitStream.ReadSignedInt(32) * 8);  				BitStream.EndChunk();  				break;  			case DemoCommand.Signon:  			case DemoCommand.Packet:  				ParseDemoPacket();  				break;  			default:  				throw new Exception("Can't handle Demo-Command " + command);  			}
Magic Number,DemoInfo,DemoParser,C:\repos\EHVAG_demoinfo\DemoInfo\DemoParser.cs,ParseTick,The following statement contains a magic number: switch (command) {  			case DemoCommand.Synctick:  				break;  			case DemoCommand.Stop:  				return false;  			case DemoCommand.ConsoleCommand:  				BitStream.BeginChunk(BitStream.ReadSignedInt(32) * 8);  				BitStream.EndChunk();  				break;  			case DemoCommand.DataTables:  				BitStream.BeginChunk (BitStream.ReadSignedInt (32) * 8);  				SendTableParser.ParsePacket (BitStream);  				BitStream.EndChunk ();    				//Map the weapons in the equipmentMapping-Dictionary.  				MapEquipment ();    				//And now we have the entities' we can bind events on them.   				BindEntites();    				break;  			case DemoCommand.StringTables:  				BitStream.BeginChunk(BitStream.ReadSignedInt(32) * 8);  				StringTables.ParsePacket(BitStream' this);  				BitStream.EndChunk();  				break;  			case DemoCommand.UserCommand:  				BitStream.ReadInt(32);  				BitStream.BeginChunk(BitStream.ReadSignedInt(32) * 8);  				BitStream.EndChunk();  				break;  			case DemoCommand.Signon:  			case DemoCommand.Packet:  				ParseDemoPacket();  				break;  			default:  				throw new Exception("Can't handle Demo-Command " + command);  			}
Magic Number,DemoInfo,DemoParser,C:\repos\EHVAG_demoinfo\DemoInfo\DemoParser.cs,ParseTick,The following statement contains a magic number: switch (command) {  			case DemoCommand.Synctick:  				break;  			case DemoCommand.Stop:  				return false;  			case DemoCommand.ConsoleCommand:  				BitStream.BeginChunk(BitStream.ReadSignedInt(32) * 8);  				BitStream.EndChunk();  				break;  			case DemoCommand.DataTables:  				BitStream.BeginChunk (BitStream.ReadSignedInt (32) * 8);  				SendTableParser.ParsePacket (BitStream);  				BitStream.EndChunk ();    				//Map the weapons in the equipmentMapping-Dictionary.  				MapEquipment ();    				//And now we have the entities' we can bind events on them.   				BindEntites();    				break;  			case DemoCommand.StringTables:  				BitStream.BeginChunk(BitStream.ReadSignedInt(32) * 8);  				StringTables.ParsePacket(BitStream' this);  				BitStream.EndChunk();  				break;  			case DemoCommand.UserCommand:  				BitStream.ReadInt(32);  				BitStream.BeginChunk(BitStream.ReadSignedInt(32) * 8);  				BitStream.EndChunk();  				break;  			case DemoCommand.Signon:  			case DemoCommand.Packet:  				ParseDemoPacket();  				break;  			default:  				throw new Exception("Can't handle Demo-Command " + command);  			}
Magic Number,DemoInfo,DemoParser,C:\repos\EHVAG_demoinfo\DemoInfo\DemoParser.cs,ParseTick,The following statement contains a magic number: switch (command) {  			case DemoCommand.Synctick:  				break;  			case DemoCommand.Stop:  				return false;  			case DemoCommand.ConsoleCommand:  				BitStream.BeginChunk(BitStream.ReadSignedInt(32) * 8);  				BitStream.EndChunk();  				break;  			case DemoCommand.DataTables:  				BitStream.BeginChunk (BitStream.ReadSignedInt (32) * 8);  				SendTableParser.ParsePacket (BitStream);  				BitStream.EndChunk ();    				//Map the weapons in the equipmentMapping-Dictionary.  				MapEquipment ();    				//And now we have the entities' we can bind events on them.   				BindEntites();    				break;  			case DemoCommand.StringTables:  				BitStream.BeginChunk(BitStream.ReadSignedInt(32) * 8);  				StringTables.ParsePacket(BitStream' this);  				BitStream.EndChunk();  				break;  			case DemoCommand.UserCommand:  				BitStream.ReadInt(32);  				BitStream.BeginChunk(BitStream.ReadSignedInt(32) * 8);  				BitStream.EndChunk();  				break;  			case DemoCommand.Signon:  			case DemoCommand.Packet:  				ParseDemoPacket();  				break;  			default:  				throw new Exception("Can't handle Demo-Command " + command);  			}
Magic Number,DemoInfo,DemoParser,C:\repos\EHVAG_demoinfo\DemoInfo\DemoParser.cs,ParseTick,The following statement contains a magic number: switch (command) {  			case DemoCommand.Synctick:  				break;  			case DemoCommand.Stop:  				return false;  			case DemoCommand.ConsoleCommand:  				BitStream.BeginChunk(BitStream.ReadSignedInt(32) * 8);  				BitStream.EndChunk();  				break;  			case DemoCommand.DataTables:  				BitStream.BeginChunk (BitStream.ReadSignedInt (32) * 8);  				SendTableParser.ParsePacket (BitStream);  				BitStream.EndChunk ();    				//Map the weapons in the equipmentMapping-Dictionary.  				MapEquipment ();    				//And now we have the entities' we can bind events on them.   				BindEntites();    				break;  			case DemoCommand.StringTables:  				BitStream.BeginChunk(BitStream.ReadSignedInt(32) * 8);  				StringTables.ParsePacket(BitStream' this);  				BitStream.EndChunk();  				break;  			case DemoCommand.UserCommand:  				BitStream.ReadInt(32);  				BitStream.BeginChunk(BitStream.ReadSignedInt(32) * 8);  				BitStream.EndChunk();  				break;  			case DemoCommand.Signon:  			case DemoCommand.Packet:  				ParseDemoPacket();  				break;  			default:  				throw new Exception("Can't handle Demo-Command " + command);  			}
Magic Number,DemoInfo,DemoParser,C:\repos\EHVAG_demoinfo\DemoInfo\DemoParser.cs,ParseTick,The following statement contains a magic number: switch (command) {  			case DemoCommand.Synctick:  				break;  			case DemoCommand.Stop:  				return false;  			case DemoCommand.ConsoleCommand:  				BitStream.BeginChunk(BitStream.ReadSignedInt(32) * 8);  				BitStream.EndChunk();  				break;  			case DemoCommand.DataTables:  				BitStream.BeginChunk (BitStream.ReadSignedInt (32) * 8);  				SendTableParser.ParsePacket (BitStream);  				BitStream.EndChunk ();    				//Map the weapons in the equipmentMapping-Dictionary.  				MapEquipment ();    				//And now we have the entities' we can bind events on them.   				BindEntites();    				break;  			case DemoCommand.StringTables:  				BitStream.BeginChunk(BitStream.ReadSignedInt(32) * 8);  				StringTables.ParsePacket(BitStream' this);  				BitStream.EndChunk();  				break;  			case DemoCommand.UserCommand:  				BitStream.ReadInt(32);  				BitStream.BeginChunk(BitStream.ReadSignedInt(32) * 8);  				BitStream.EndChunk();  				break;  			case DemoCommand.Signon:  			case DemoCommand.Packet:  				ParseDemoPacket();  				break;  			default:  				throw new Exception("Can't handle Demo-Command " + command);  			}
Magic Number,DemoInfo,DemoParser,C:\repos\EHVAG_demoinfo\DemoInfo\DemoParser.cs,ParseTick,The following statement contains a magic number: switch (command) {  			case DemoCommand.Synctick:  				break;  			case DemoCommand.Stop:  				return false;  			case DemoCommand.ConsoleCommand:  				BitStream.BeginChunk(BitStream.ReadSignedInt(32) * 8);  				BitStream.EndChunk();  				break;  			case DemoCommand.DataTables:  				BitStream.BeginChunk (BitStream.ReadSignedInt (32) * 8);  				SendTableParser.ParsePacket (BitStream);  				BitStream.EndChunk ();    				//Map the weapons in the equipmentMapping-Dictionary.  				MapEquipment ();    				//And now we have the entities' we can bind events on them.   				BindEntites();    				break;  			case DemoCommand.StringTables:  				BitStream.BeginChunk(BitStream.ReadSignedInt(32) * 8);  				StringTables.ParsePacket(BitStream' this);  				BitStream.EndChunk();  				break;  			case DemoCommand.UserCommand:  				BitStream.ReadInt(32);  				BitStream.BeginChunk(BitStream.ReadSignedInt(32) * 8);  				BitStream.EndChunk();  				break;  			case DemoCommand.Signon:  			case DemoCommand.Packet:  				ParseDemoPacket();  				break;  			default:  				throw new Exception("Can't handle Demo-Command " + command);  			}
Magic Number,DemoInfo,DemoParser,C:\repos\EHVAG_demoinfo\DemoInfo\DemoParser.cs,ParseTick,The following statement contains a magic number: switch (command) {  			case DemoCommand.Synctick:  				break;  			case DemoCommand.Stop:  				return false;  			case DemoCommand.ConsoleCommand:  				BitStream.BeginChunk(BitStream.ReadSignedInt(32) * 8);  				BitStream.EndChunk();  				break;  			case DemoCommand.DataTables:  				BitStream.BeginChunk (BitStream.ReadSignedInt (32) * 8);  				SendTableParser.ParsePacket (BitStream);  				BitStream.EndChunk ();    				//Map the weapons in the equipmentMapping-Dictionary.  				MapEquipment ();    				//And now we have the entities' we can bind events on them.   				BindEntites();    				break;  			case DemoCommand.StringTables:  				BitStream.BeginChunk(BitStream.ReadSignedInt(32) * 8);  				StringTables.ParsePacket(BitStream' this);  				BitStream.EndChunk();  				break;  			case DemoCommand.UserCommand:  				BitStream.ReadInt(32);  				BitStream.BeginChunk(BitStream.ReadSignedInt(32) * 8);  				BitStream.EndChunk();  				break;  			case DemoCommand.Signon:  			case DemoCommand.Packet:  				ParseDemoPacket();  				break;  			default:  				throw new Exception("Can't handle Demo-Command " + command);  			}
Magic Number,DemoInfo,DemoParser,C:\repos\EHVAG_demoinfo\DemoInfo\DemoParser.cs,ParseDemoPacket,The following statement contains a magic number: BitStream.ReadInt(32);
Magic Number,DemoInfo,DemoParser,C:\repos\EHVAG_demoinfo\DemoInfo\DemoParser.cs,ParseDemoPacket,The following statement contains a magic number: BitStream.ReadInt(32);
Magic Number,DemoInfo,DemoParser,C:\repos\EHVAG_demoinfo\DemoInfo\DemoParser.cs,ParseDemoPacket,The following statement contains a magic number: BitStream.BeginChunk(BitStream.ReadSignedInt(32) * 8);
Magic Number,DemoInfo,DemoParser,C:\repos\EHVAG_demoinfo\DemoInfo\DemoParser.cs,ParseDemoPacket,The following statement contains a magic number: BitStream.BeginChunk(BitStream.ReadSignedInt(32) * 8);
Magic Number,DemoInfo,DemoParser,C:\repos\EHVAG_demoinfo\DemoInfo\DemoParser.cs,HandlePlayers,The following statement contains a magic number: SendTableParser.FindByName("CCSPlayerResource").OnNewEntity += (blahblah' playerResources) => {  				for(int i = 0; i < 64; i++)  				{  					//Since this is passed as reference to the delegates  					int iForTheMethod = i;  					string iString = i.ToString().PadLeft(3' '0');    					playerResources.Entity.FindProperty("m_szClan."+iString).StringRecived += (sender' e) => {  						additionalInformations[iForTheMethod].Clantag = e.Value;  					};    					playerResources.Entity.FindProperty("m_iPing."+iString).IntRecived += (sender' e) => {  						additionalInformations[iForTheMethod].Ping = e.Value;  					};    					playerResources.Entity.FindProperty("m_iScore."+iString).IntRecived += (sender' e) => {  						additionalInformations[iForTheMethod].Score = e.Value;  					};    					playerResources.Entity.FindProperty("m_iKills."+iString).IntRecived += (sender' e) => {  						additionalInformations[iForTheMethod].Kills = e.Value;  					};    					playerResources.Entity.FindProperty("m_iDeaths."+iString).IntRecived += (sender' e) => {  						additionalInformations[iForTheMethod].Deaths = e.Value;  					};      					playerResources.Entity.FindProperty("m_iAssists."+iString).IntRecived += (sender' e) => {  						additionalInformations[iForTheMethod].Assists = e.Value;  					};    					playerResources.Entity.FindProperty("m_iMVPs."+iString).IntRecived += (sender' e) => {  						additionalInformations[iForTheMethod].MVPs = e.Value;  					};    					playerResources.Entity.FindProperty("m_iTotalCashSpent."+iString).IntRecived += (sender' e) => {  						additionalInformations[iForTheMethod].TotalCashSpent = e.Value;  					};    					#if DEBUG  					playerResources.Entity.FindProperty("m_iArmor."+iString).IntRecived += (sender' e) => {  						additionalInformations[iForTheMethod].ScoreboardArmor = e.Value;  					};    					playerResources.Entity.FindProperty("m_iHealth."+iString).IntRecived += (sender' e) => {  						additionalInformations[iForTheMethod].ScoreboardHP = e.Value;  					};    					#endif  				}  			};
Magic Number,DemoInfo,DemoParser,C:\repos\EHVAG_demoinfo\DemoInfo\DemoParser.cs,HandlePlayers,The following statement contains a magic number: SendTableParser.FindByName("CCSPlayerResource").OnNewEntity += (blahblah' playerResources) => {  				for(int i = 0; i < 64; i++)  				{  					//Since this is passed as reference to the delegates  					int iForTheMethod = i;  					string iString = i.ToString().PadLeft(3' '0');    					playerResources.Entity.FindProperty("m_szClan."+iString).StringRecived += (sender' e) => {  						additionalInformations[iForTheMethod].Clantag = e.Value;  					};    					playerResources.Entity.FindProperty("m_iPing."+iString).IntRecived += (sender' e) => {  						additionalInformations[iForTheMethod].Ping = e.Value;  					};    					playerResources.Entity.FindProperty("m_iScore."+iString).IntRecived += (sender' e) => {  						additionalInformations[iForTheMethod].Score = e.Value;  					};    					playerResources.Entity.FindProperty("m_iKills."+iString).IntRecived += (sender' e) => {  						additionalInformations[iForTheMethod].Kills = e.Value;  					};    					playerResources.Entity.FindProperty("m_iDeaths."+iString).IntRecived += (sender' e) => {  						additionalInformations[iForTheMethod].Deaths = e.Value;  					};      					playerResources.Entity.FindProperty("m_iAssists."+iString).IntRecived += (sender' e) => {  						additionalInformations[iForTheMethod].Assists = e.Value;  					};    					playerResources.Entity.FindProperty("m_iMVPs."+iString).IntRecived += (sender' e) => {  						additionalInformations[iForTheMethod].MVPs = e.Value;  					};    					playerResources.Entity.FindProperty("m_iTotalCashSpent."+iString).IntRecived += (sender' e) => {  						additionalInformations[iForTheMethod].TotalCashSpent = e.Value;  					};    					#if DEBUG  					playerResources.Entity.FindProperty("m_iArmor."+iString).IntRecived += (sender' e) => {  						additionalInformations[iForTheMethod].ScoreboardArmor = e.Value;  					};    					playerResources.Entity.FindProperty("m_iHealth."+iString).IntRecived += (sender' e) => {  						additionalInformations[iForTheMethod].ScoreboardHP = e.Value;  					};    					#endif  				}  			};
Magic Number,DemoInfo,DemoParser,C:\repos\EHVAG_demoinfo\DemoInfo\DemoParser.cs,HandleNewPlayer,The following statement contains a magic number: for(int i = 0; i < MAXWEAPONS; i++)  			{  				int iForTheMethod = i; //Because else i is passed as reference to the delegate.     				playerEntity.FindProperty(weaponPrefix + i.ToString().PadLeft(3' '0')).IntRecived += (sender' e) => {    					int index = e.Value & INDEX_MASK;    					if (index != INDEX_MASK) {  						if(cache[iForTheMethod] != 0) //Player already has a weapon in this slot.   						{  							p.rawWeapons.Remove(cache[iForTheMethod]);  							cache[iForTheMethod] = 0;  						}  						cache[iForTheMethod] = index;    						AttributeWeapon(index' p);  					} else {  						if (cache[iForTheMethod] != 0 && p.rawWeapons.ContainsKey(cache[iForTheMethod]))  						{  							p.rawWeapons[cache[iForTheMethod]].Owner = null;  						}  						p.rawWeapons.Remove(cache[iForTheMethod]);    						cache[iForTheMethod] = 0;  					}  				};  			}
Magic Number,DemoInfo,DemoParser,C:\repos\EHVAG_demoinfo\DemoInfo\DemoParser.cs,HandleNewPlayer,The following statement contains a magic number: for (int i = 0; i < 32; i++) {  				int iForTheMethod = i;    				playerEntity.FindProperty ("m_iAmmo." + i.ToString ().PadLeft (3' '0')).IntRecived += (sender' e) => {  					p.AmmoLeft [iForTheMethod] = e.Value;  				};  			}
Magic Number,DemoInfo,DemoParser,C:\repos\EHVAG_demoinfo\DemoInfo\DemoParser.cs,HandleNewPlayer,The following statement contains a magic number: for (int i = 0; i < 32; i++) {  				int iForTheMethod = i;    				playerEntity.FindProperty ("m_iAmmo." + i.ToString ().PadLeft (3' '0')).IntRecived += (sender' e) => {  					p.AmmoLeft [iForTheMethod] = e.Value;  				};  			}
Magic Number,DemoInfo,DemoParser,C:\repos\EHVAG_demoinfo\DemoInfo\DemoParser.cs,MapEquipment,The following statement contains a magic number: for (int i = 0; i < SendTableParser.ServerClasses.Count; i++) {  				var sc = SendTableParser.ServerClasses[i];    				if (sc.BaseClasses.Count > 6 && sc.BaseClasses [6].Name == "CWeaponCSBase") {   					//It is a "weapon" (Gun' C4' ... (...is the cz still a "weapon" after the nerf? (fml' it was buffed again)))  					if (sc.BaseClasses.Count > 7) {  						if (sc.BaseClasses [7].Name == "CWeaponCSBaseGun") {  							//it is a ratatatata-weapon.  							var s = sc.DTName.Substring (9).ToLower ();  							equipmentMapping.Add (sc' Equipment.MapEquipment (s));  						} else if (sc.BaseClasses [7].Name == "CBaseCSGrenade") {  							//"boom"-weapon.   							equipmentMapping.Add (sc' Equipment.MapEquipment (sc.DTName.Substring (3).ToLower ()));  						}   					} else if (sc.Name == "CC4") {  						//Bomb is neither "ratatata" nor "boom"' its "booooooom".  						equipmentMapping.Add (sc' EquipmentElement.Bomb);  					} else if (sc.Name == "CKnife" || (sc.BaseClasses.Count > 6 && sc.BaseClasses [6].Name == "CKnife")) {  						//tsching weapon  						equipmentMapping.Add (sc' EquipmentElement.Knife);  					} else if (sc.Name == "CWeaponNOVA" || sc.Name == "CWeaponSawedoff" || sc.Name == "CWeaponXM1014") {  						equipmentMapping.Add (sc' Equipment.MapEquipment (sc.Name.Substring (7).ToLower()));  					}  				}  			}
Magic Number,DemoInfo,DemoParser,C:\repos\EHVAG_demoinfo\DemoInfo\DemoParser.cs,MapEquipment,The following statement contains a magic number: for (int i = 0; i < SendTableParser.ServerClasses.Count; i++) {  				var sc = SendTableParser.ServerClasses[i];    				if (sc.BaseClasses.Count > 6 && sc.BaseClasses [6].Name == "CWeaponCSBase") {   					//It is a "weapon" (Gun' C4' ... (...is the cz still a "weapon" after the nerf? (fml' it was buffed again)))  					if (sc.BaseClasses.Count > 7) {  						if (sc.BaseClasses [7].Name == "CWeaponCSBaseGun") {  							//it is a ratatatata-weapon.  							var s = sc.DTName.Substring (9).ToLower ();  							equipmentMapping.Add (sc' Equipment.MapEquipment (s));  						} else if (sc.BaseClasses [7].Name == "CBaseCSGrenade") {  							//"boom"-weapon.   							equipmentMapping.Add (sc' Equipment.MapEquipment (sc.DTName.Substring (3).ToLower ()));  						}   					} else if (sc.Name == "CC4") {  						//Bomb is neither "ratatata" nor "boom"' its "booooooom".  						equipmentMapping.Add (sc' EquipmentElement.Bomb);  					} else if (sc.Name == "CKnife" || (sc.BaseClasses.Count > 6 && sc.BaseClasses [6].Name == "CKnife")) {  						//tsching weapon  						equipmentMapping.Add (sc' EquipmentElement.Knife);  					} else if (sc.Name == "CWeaponNOVA" || sc.Name == "CWeaponSawedoff" || sc.Name == "CWeaponXM1014") {  						equipmentMapping.Add (sc' Equipment.MapEquipment (sc.Name.Substring (7).ToLower()));  					}  				}  			}
Magic Number,DemoInfo,DemoParser,C:\repos\EHVAG_demoinfo\DemoInfo\DemoParser.cs,MapEquipment,The following statement contains a magic number: for (int i = 0; i < SendTableParser.ServerClasses.Count; i++) {  				var sc = SendTableParser.ServerClasses[i];    				if (sc.BaseClasses.Count > 6 && sc.BaseClasses [6].Name == "CWeaponCSBase") {   					//It is a "weapon" (Gun' C4' ... (...is the cz still a "weapon" after the nerf? (fml' it was buffed again)))  					if (sc.BaseClasses.Count > 7) {  						if (sc.BaseClasses [7].Name == "CWeaponCSBaseGun") {  							//it is a ratatatata-weapon.  							var s = sc.DTName.Substring (9).ToLower ();  							equipmentMapping.Add (sc' Equipment.MapEquipment (s));  						} else if (sc.BaseClasses [7].Name == "CBaseCSGrenade") {  							//"boom"-weapon.   							equipmentMapping.Add (sc' Equipment.MapEquipment (sc.DTName.Substring (3).ToLower ()));  						}   					} else if (sc.Name == "CC4") {  						//Bomb is neither "ratatata" nor "boom"' its "booooooom".  						equipmentMapping.Add (sc' EquipmentElement.Bomb);  					} else if (sc.Name == "CKnife" || (sc.BaseClasses.Count > 6 && sc.BaseClasses [6].Name == "CKnife")) {  						//tsching weapon  						equipmentMapping.Add (sc' EquipmentElement.Knife);  					} else if (sc.Name == "CWeaponNOVA" || sc.Name == "CWeaponSawedoff" || sc.Name == "CWeaponXM1014") {  						equipmentMapping.Add (sc' Equipment.MapEquipment (sc.Name.Substring (7).ToLower()));  					}  				}  			}
Magic Number,DemoInfo,DemoParser,C:\repos\EHVAG_demoinfo\DemoInfo\DemoParser.cs,MapEquipment,The following statement contains a magic number: for (int i = 0; i < SendTableParser.ServerClasses.Count; i++) {  				var sc = SendTableParser.ServerClasses[i];    				if (sc.BaseClasses.Count > 6 && sc.BaseClasses [6].Name == "CWeaponCSBase") {   					//It is a "weapon" (Gun' C4' ... (...is the cz still a "weapon" after the nerf? (fml' it was buffed again)))  					if (sc.BaseClasses.Count > 7) {  						if (sc.BaseClasses [7].Name == "CWeaponCSBaseGun") {  							//it is a ratatatata-weapon.  							var s = sc.DTName.Substring (9).ToLower ();  							equipmentMapping.Add (sc' Equipment.MapEquipment (s));  						} else if (sc.BaseClasses [7].Name == "CBaseCSGrenade") {  							//"boom"-weapon.   							equipmentMapping.Add (sc' Equipment.MapEquipment (sc.DTName.Substring (3).ToLower ()));  						}   					} else if (sc.Name == "CC4") {  						//Bomb is neither "ratatata" nor "boom"' its "booooooom".  						equipmentMapping.Add (sc' EquipmentElement.Bomb);  					} else if (sc.Name == "CKnife" || (sc.BaseClasses.Count > 6 && sc.BaseClasses [6].Name == "CKnife")) {  						//tsching weapon  						equipmentMapping.Add (sc' EquipmentElement.Knife);  					} else if (sc.Name == "CWeaponNOVA" || sc.Name == "CWeaponSawedoff" || sc.Name == "CWeaponXM1014") {  						equipmentMapping.Add (sc' Equipment.MapEquipment (sc.Name.Substring (7).ToLower()));  					}  				}  			}
Magic Number,DemoInfo,DemoParser,C:\repos\EHVAG_demoinfo\DemoInfo\DemoParser.cs,MapEquipment,The following statement contains a magic number: for (int i = 0; i < SendTableParser.ServerClasses.Count; i++) {  				var sc = SendTableParser.ServerClasses[i];    				if (sc.BaseClasses.Count > 6 && sc.BaseClasses [6].Name == "CWeaponCSBase") {   					//It is a "weapon" (Gun' C4' ... (...is the cz still a "weapon" after the nerf? (fml' it was buffed again)))  					if (sc.BaseClasses.Count > 7) {  						if (sc.BaseClasses [7].Name == "CWeaponCSBaseGun") {  							//it is a ratatatata-weapon.  							var s = sc.DTName.Substring (9).ToLower ();  							equipmentMapping.Add (sc' Equipment.MapEquipment (s));  						} else if (sc.BaseClasses [7].Name == "CBaseCSGrenade") {  							//"boom"-weapon.   							equipmentMapping.Add (sc' Equipment.MapEquipment (sc.DTName.Substring (3).ToLower ()));  						}   					} else if (sc.Name == "CC4") {  						//Bomb is neither "ratatata" nor "boom"' its "booooooom".  						equipmentMapping.Add (sc' EquipmentElement.Bomb);  					} else if (sc.Name == "CKnife" || (sc.BaseClasses.Count > 6 && sc.BaseClasses [6].Name == "CKnife")) {  						//tsching weapon  						equipmentMapping.Add (sc' EquipmentElement.Knife);  					} else if (sc.Name == "CWeaponNOVA" || sc.Name == "CWeaponSawedoff" || sc.Name == "CWeaponXM1014") {  						equipmentMapping.Add (sc' Equipment.MapEquipment (sc.Name.Substring (7).ToLower()));  					}  				}  			}
Magic Number,DemoInfo,DemoParser,C:\repos\EHVAG_demoinfo\DemoInfo\DemoParser.cs,MapEquipment,The following statement contains a magic number: for (int i = 0; i < SendTableParser.ServerClasses.Count; i++) {  				var sc = SendTableParser.ServerClasses[i];    				if (sc.BaseClasses.Count > 6 && sc.BaseClasses [6].Name == "CWeaponCSBase") {   					//It is a "weapon" (Gun' C4' ... (...is the cz still a "weapon" after the nerf? (fml' it was buffed again)))  					if (sc.BaseClasses.Count > 7) {  						if (sc.BaseClasses [7].Name == "CWeaponCSBaseGun") {  							//it is a ratatatata-weapon.  							var s = sc.DTName.Substring (9).ToLower ();  							equipmentMapping.Add (sc' Equipment.MapEquipment (s));  						} else if (sc.BaseClasses [7].Name == "CBaseCSGrenade") {  							//"boom"-weapon.   							equipmentMapping.Add (sc' Equipment.MapEquipment (sc.DTName.Substring (3).ToLower ()));  						}   					} else if (sc.Name == "CC4") {  						//Bomb is neither "ratatata" nor "boom"' its "booooooom".  						equipmentMapping.Add (sc' EquipmentElement.Bomb);  					} else if (sc.Name == "CKnife" || (sc.BaseClasses.Count > 6 && sc.BaseClasses [6].Name == "CKnife")) {  						//tsching weapon  						equipmentMapping.Add (sc' EquipmentElement.Knife);  					} else if (sc.Name == "CWeaponNOVA" || sc.Name == "CWeaponSawedoff" || sc.Name == "CWeaponXM1014") {  						equipmentMapping.Add (sc' Equipment.MapEquipment (sc.Name.Substring (7).ToLower()));  					}  				}  			}
Magic Number,DemoInfo,DemoParser,C:\repos\EHVAG_demoinfo\DemoInfo\DemoParser.cs,MapEquipment,The following statement contains a magic number: for (int i = 0; i < SendTableParser.ServerClasses.Count; i++) {  				var sc = SendTableParser.ServerClasses[i];    				if (sc.BaseClasses.Count > 6 && sc.BaseClasses [6].Name == "CWeaponCSBase") {   					//It is a "weapon" (Gun' C4' ... (...is the cz still a "weapon" after the nerf? (fml' it was buffed again)))  					if (sc.BaseClasses.Count > 7) {  						if (sc.BaseClasses [7].Name == "CWeaponCSBaseGun") {  							//it is a ratatatata-weapon.  							var s = sc.DTName.Substring (9).ToLower ();  							equipmentMapping.Add (sc' Equipment.MapEquipment (s));  						} else if (sc.BaseClasses [7].Name == "CBaseCSGrenade") {  							//"boom"-weapon.   							equipmentMapping.Add (sc' Equipment.MapEquipment (sc.DTName.Substring (3).ToLower ()));  						}   					} else if (sc.Name == "CC4") {  						//Bomb is neither "ratatata" nor "boom"' its "booooooom".  						equipmentMapping.Add (sc' EquipmentElement.Bomb);  					} else if (sc.Name == "CKnife" || (sc.BaseClasses.Count > 6 && sc.BaseClasses [6].Name == "CKnife")) {  						//tsching weapon  						equipmentMapping.Add (sc' EquipmentElement.Knife);  					} else if (sc.Name == "CWeaponNOVA" || sc.Name == "CWeaponSawedoff" || sc.Name == "CWeaponXM1014") {  						equipmentMapping.Add (sc' Equipment.MapEquipment (sc.Name.Substring (7).ToLower()));  					}  				}  			}
Magic Number,DemoInfo,DemoParser,C:\repos\EHVAG_demoinfo\DemoInfo\DemoParser.cs,MapEquipment,The following statement contains a magic number: for (int i = 0; i < SendTableParser.ServerClasses.Count; i++) {  				var sc = SendTableParser.ServerClasses[i];    				if (sc.BaseClasses.Count > 6 && sc.BaseClasses [6].Name == "CWeaponCSBase") {   					//It is a "weapon" (Gun' C4' ... (...is the cz still a "weapon" after the nerf? (fml' it was buffed again)))  					if (sc.BaseClasses.Count > 7) {  						if (sc.BaseClasses [7].Name == "CWeaponCSBaseGun") {  							//it is a ratatatata-weapon.  							var s = sc.DTName.Substring (9).ToLower ();  							equipmentMapping.Add (sc' Equipment.MapEquipment (s));  						} else if (sc.BaseClasses [7].Name == "CBaseCSGrenade") {  							//"boom"-weapon.   							equipmentMapping.Add (sc' Equipment.MapEquipment (sc.DTName.Substring (3).ToLower ()));  						}   					} else if (sc.Name == "CC4") {  						//Bomb is neither "ratatata" nor "boom"' its "booooooom".  						equipmentMapping.Add (sc' EquipmentElement.Bomb);  					} else if (sc.Name == "CKnife" || (sc.BaseClasses.Count > 6 && sc.BaseClasses [6].Name == "CKnife")) {  						//tsching weapon  						equipmentMapping.Add (sc' EquipmentElement.Knife);  					} else if (sc.Name == "CWeaponNOVA" || sc.Name == "CWeaponSawedoff" || sc.Name == "CWeaponXM1014") {  						equipmentMapping.Add (sc' Equipment.MapEquipment (sc.Name.Substring (7).ToLower()));  					}  				}  			}
Magic Number,DemoInfo,DemoParser,C:\repos\EHVAG_demoinfo\DemoInfo\DemoParser.cs,MapEquipment,The following statement contains a magic number: for (int i = 0; i < SendTableParser.ServerClasses.Count; i++) {  				var sc = SendTableParser.ServerClasses[i];    				if (sc.BaseClasses.Count > 6 && sc.BaseClasses [6].Name == "CWeaponCSBase") {   					//It is a "weapon" (Gun' C4' ... (...is the cz still a "weapon" after the nerf? (fml' it was buffed again)))  					if (sc.BaseClasses.Count > 7) {  						if (sc.BaseClasses [7].Name == "CWeaponCSBaseGun") {  							//it is a ratatatata-weapon.  							var s = sc.DTName.Substring (9).ToLower ();  							equipmentMapping.Add (sc' Equipment.MapEquipment (s));  						} else if (sc.BaseClasses [7].Name == "CBaseCSGrenade") {  							//"boom"-weapon.   							equipmentMapping.Add (sc' Equipment.MapEquipment (sc.DTName.Substring (3).ToLower ()));  						}   					} else if (sc.Name == "CC4") {  						//Bomb is neither "ratatata" nor "boom"' its "booooooom".  						equipmentMapping.Add (sc' EquipmentElement.Bomb);  					} else if (sc.Name == "CKnife" || (sc.BaseClasses.Count > 6 && sc.BaseClasses [6].Name == "CKnife")) {  						//tsching weapon  						equipmentMapping.Add (sc' EquipmentElement.Knife);  					} else if (sc.Name == "CWeaponNOVA" || sc.Name == "CWeaponSawedoff" || sc.Name == "CWeaponXM1014") {  						equipmentMapping.Add (sc' Equipment.MapEquipment (sc.Name.Substring (7).ToLower()));  					}  				}  			}
Magic Number,DemoInfo,DemoParser,C:\repos\EHVAG_demoinfo\DemoInfo\DemoParser.cs,MapEquipment,The following statement contains a magic number: for (int i = 0; i < SendTableParser.ServerClasses.Count; i++) {  				var sc = SendTableParser.ServerClasses[i];    				if (sc.BaseClasses.Count > 6 && sc.BaseClasses [6].Name == "CWeaponCSBase") {   					//It is a "weapon" (Gun' C4' ... (...is the cz still a "weapon" after the nerf? (fml' it was buffed again)))  					if (sc.BaseClasses.Count > 7) {  						if (sc.BaseClasses [7].Name == "CWeaponCSBaseGun") {  							//it is a ratatatata-weapon.  							var s = sc.DTName.Substring (9).ToLower ();  							equipmentMapping.Add (sc' Equipment.MapEquipment (s));  						} else if (sc.BaseClasses [7].Name == "CBaseCSGrenade") {  							//"boom"-weapon.   							equipmentMapping.Add (sc' Equipment.MapEquipment (sc.DTName.Substring (3).ToLower ()));  						}   					} else if (sc.Name == "CC4") {  						//Bomb is neither "ratatata" nor "boom"' its "booooooom".  						equipmentMapping.Add (sc' EquipmentElement.Bomb);  					} else if (sc.Name == "CKnife" || (sc.BaseClasses.Count > 6 && sc.BaseClasses [6].Name == "CKnife")) {  						//tsching weapon  						equipmentMapping.Add (sc' EquipmentElement.Knife);  					} else if (sc.Name == "CWeaponNOVA" || sc.Name == "CWeaponSawedoff" || sc.Name == "CWeaponXM1014") {  						equipmentMapping.Add (sc' Equipment.MapEquipment (sc.Name.Substring (7).ToLower()));  					}  				}  			}
Magic Number,DemoInfo,Helper,C:\repos\EHVAG_demoinfo\DemoInfo\Helper.cs,ReadInt32SwapEndian,The following statement contains a magic number: return BitConverter.ToInt32(reader.ReadBytes(4).Reverse().ToArray()' 0);
Magic Number,DemoInfo,Helper,C:\repos\EHVAG_demoinfo\DemoInfo\Helper.cs,ReadInt64SwapEndian,The following statement contains a magic number: return BitConverter.ToInt64(reader.ReadBytes(8).Reverse().ToArray()' 0);
Magic Number,DemoInfo,Helper,C:\repos\EHVAG_demoinfo\DemoInfo\Helper.cs,ReadCString,The following statement contains a magic number: return encoding.GetString(reader.ReadBytes(length)).Split(new char[] { '\0' }' 2)[0];
Magic Number,DemoInfo,Helper,C:\repos\EHVAG_demoinfo\DemoInfo\Helper.cs,ReadVarInt32,The following statement contains a magic number: do {  				if (count > 5)  					throw new InvalidDataException("VarInt32 out of range");    				b = reader.ReadByte();    				result |= ( b & 0x7F ) << ( 7 * count );    				count++;  			} while (( b & 0x80 ) != 0);
Magic Number,DemoInfo,Helper,C:\repos\EHVAG_demoinfo\DemoInfo\Helper.cs,ReadVarInt32,The following statement contains a magic number: do {  				if (count > 5)  					throw new InvalidDataException("VarInt32 out of range");    				b = reader.ReadByte();    				result |= ( b & 0x7F ) << ( 7 * count );    				count++;  			} while (( b & 0x80 ) != 0);
Magic Number,DemoInfo,Helper,C:\repos\EHVAG_demoinfo\DemoInfo\Helper.cs,ReadNullTerminatedString,The following statement contains a magic number: return ReadNullTerminatedString(reader' encoding' 512);
Magic Number,DemoInfo,DemoHeader,C:\repos\EHVAG_demoinfo\DemoInfo\Structs.cs,ParseFrom,The following statement contains a magic number: return new DemoHeader() {                  Filestamp = reader.ReadCString(8)'                  Protocol = reader.ReadSignedInt(32)'  				NetworkProtocol = reader.ReadSignedInt(32)'                  ServerName = reader.ReadCString(MAX_OSPATH)'                    ClientName = reader.ReadCString(MAX_OSPATH)'                  MapName = reader.ReadCString(MAX_OSPATH)'                  GameDirectory = reader.ReadCString(MAX_OSPATH)'  				PlaybackTime = reader.ReadFloat()'    				PlaybackTicks = reader.ReadSignedInt(32)'  				PlaybackFrames = reader.ReadSignedInt(32)'  				SignonLength = reader.ReadSignedInt(32)'              };
Magic Number,DemoInfo,DemoHeader,C:\repos\EHVAG_demoinfo\DemoInfo\Structs.cs,ParseFrom,The following statement contains a magic number: return new DemoHeader() {                  Filestamp = reader.ReadCString(8)'                  Protocol = reader.ReadSignedInt(32)'  				NetworkProtocol = reader.ReadSignedInt(32)'                  ServerName = reader.ReadCString(MAX_OSPATH)'                    ClientName = reader.ReadCString(MAX_OSPATH)'                  MapName = reader.ReadCString(MAX_OSPATH)'                  GameDirectory = reader.ReadCString(MAX_OSPATH)'  				PlaybackTime = reader.ReadFloat()'    				PlaybackTicks = reader.ReadSignedInt(32)'  				PlaybackFrames = reader.ReadSignedInt(32)'  				SignonLength = reader.ReadSignedInt(32)'              };
Magic Number,DemoInfo,DemoHeader,C:\repos\EHVAG_demoinfo\DemoInfo\Structs.cs,ParseFrom,The following statement contains a magic number: return new DemoHeader() {                  Filestamp = reader.ReadCString(8)'                  Protocol = reader.ReadSignedInt(32)'  				NetworkProtocol = reader.ReadSignedInt(32)'                  ServerName = reader.ReadCString(MAX_OSPATH)'                    ClientName = reader.ReadCString(MAX_OSPATH)'                  MapName = reader.ReadCString(MAX_OSPATH)'                  GameDirectory = reader.ReadCString(MAX_OSPATH)'  				PlaybackTime = reader.ReadFloat()'    				PlaybackTicks = reader.ReadSignedInt(32)'  				PlaybackFrames = reader.ReadSignedInt(32)'  				SignonLength = reader.ReadSignedInt(32)'              };
Magic Number,DemoInfo,DemoHeader,C:\repos\EHVAG_demoinfo\DemoInfo\Structs.cs,ParseFrom,The following statement contains a magic number: return new DemoHeader() {                  Filestamp = reader.ReadCString(8)'                  Protocol = reader.ReadSignedInt(32)'  				NetworkProtocol = reader.ReadSignedInt(32)'                  ServerName = reader.ReadCString(MAX_OSPATH)'                    ClientName = reader.ReadCString(MAX_OSPATH)'                  MapName = reader.ReadCString(MAX_OSPATH)'                  GameDirectory = reader.ReadCString(MAX_OSPATH)'  				PlaybackTime = reader.ReadFloat()'    				PlaybackTicks = reader.ReadSignedInt(32)'  				PlaybackFrames = reader.ReadSignedInt(32)'  				SignonLength = reader.ReadSignedInt(32)'              };
Magic Number,DemoInfo,DemoHeader,C:\repos\EHVAG_demoinfo\DemoInfo\Structs.cs,ParseFrom,The following statement contains a magic number: return new DemoHeader() {                  Filestamp = reader.ReadCString(8)'                  Protocol = reader.ReadSignedInt(32)'  				NetworkProtocol = reader.ReadSignedInt(32)'                  ServerName = reader.ReadCString(MAX_OSPATH)'                    ClientName = reader.ReadCString(MAX_OSPATH)'                  MapName = reader.ReadCString(MAX_OSPATH)'                  GameDirectory = reader.ReadCString(MAX_OSPATH)'  				PlaybackTime = reader.ReadFloat()'    				PlaybackTicks = reader.ReadSignedInt(32)'  				PlaybackFrames = reader.ReadSignedInt(32)'  				SignonLength = reader.ReadSignedInt(32)'              };
Magic Number,DemoInfo,DemoHeader,C:\repos\EHVAG_demoinfo\DemoInfo\Structs.cs,ParseFrom,The following statement contains a magic number: return new DemoHeader() {                  Filestamp = reader.ReadCString(8)'                  Protocol = reader.ReadSignedInt(32)'  				NetworkProtocol = reader.ReadSignedInt(32)'                  ServerName = reader.ReadCString(MAX_OSPATH)'                    ClientName = reader.ReadCString(MAX_OSPATH)'                  MapName = reader.ReadCString(MAX_OSPATH)'                  GameDirectory = reader.ReadCString(MAX_OSPATH)'  				PlaybackTime = reader.ReadFloat()'    				PlaybackTicks = reader.ReadSignedInt(32)'  				PlaybackFrames = reader.ReadSignedInt(32)'  				SignonLength = reader.ReadSignedInt(32)'              };
Magic Number,DemoInfo,Split,C:\repos\EHVAG_demoinfo\DemoInfo\Structs.cs,Parse,The following statement contains a magic number: return new Split              {                  Flags = reader.ReadSignedInt(32)'                  viewOrigin = Vector.Parse(reader)'                  viewAngles = QAngle.Parse(reader)'                  localViewAngles = QAngle.Parse(reader)'                    viewOrigin2 = Vector.Parse(reader)'                  viewAngles2 = QAngle.Parse(reader)'                  localViewAngles2 = QAngle.Parse(reader)'              };
Magic Number,DemoInfo,CommandInfo,C:\repos\EHVAG_demoinfo\DemoInfo\Structs.cs,Parse,The following statement contains a magic number: return new CommandInfo               {                  u = new Split[2] { Split.Parse(reader)' Split.Parse(reader) }              };
Magic Number,DemoInfo,PlayerInfo,C:\repos\EHVAG_demoinfo\DemoInfo\Structs.cs,PlayerInfo,The following statement contains a magic number: Name = reader.ReadCString(128);
Magic Number,DemoInfo,PlayerInfo,C:\repos\EHVAG_demoinfo\DemoInfo\Structs.cs,PlayerInfo,The following statement contains a magic number: GUID = reader.ReadCString(33);
Magic Number,DemoInfo,PlayerInfo,C:\repos\EHVAG_demoinfo\DemoInfo\Structs.cs,PlayerInfo,The following statement contains a magic number: FriendsName = reader.ReadCString(128);
Magic Number,DemoInfo,BitStreamUtil,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitStreamUtil.cs,ReadUBitInt,The following statement contains a magic number: uint ret = bs.ReadInt(6);
Magic Number,DemoInfo,BitStreamUtil,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitStreamUtil.cs,ReadUBitInt,The following statement contains a magic number: switch (ret & (16 | 32))  			{  			case 16:  				ret = (ret & 15) | (bs.ReadInt(4) << 4);  				break;  			case 32:  				ret = (ret & 15) | (bs.ReadInt(8) << 4);  				break;  			case 48:  				ret = (ret & 15) | (bs.ReadInt(32 - 4) << 4);  				break;  			}
Magic Number,DemoInfo,BitStreamUtil,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitStreamUtil.cs,ReadUBitInt,The following statement contains a magic number: switch (ret & (16 | 32))  			{  			case 16:  				ret = (ret & 15) | (bs.ReadInt(4) << 4);  				break;  			case 32:  				ret = (ret & 15) | (bs.ReadInt(8) << 4);  				break;  			case 48:  				ret = (ret & 15) | (bs.ReadInt(32 - 4) << 4);  				break;  			}
Magic Number,DemoInfo,BitStreamUtil,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitStreamUtil.cs,ReadUBitInt,The following statement contains a magic number: switch (ret & (16 | 32))  			{  			case 16:  				ret = (ret & 15) | (bs.ReadInt(4) << 4);  				break;  			case 32:  				ret = (ret & 15) | (bs.ReadInt(8) << 4);  				break;  			case 48:  				ret = (ret & 15) | (bs.ReadInt(32 - 4) << 4);  				break;  			}
Magic Number,DemoInfo,BitStreamUtil,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitStreamUtil.cs,ReadUBitInt,The following statement contains a magic number: switch (ret & (16 | 32))  			{  			case 16:  				ret = (ret & 15) | (bs.ReadInt(4) << 4);  				break;  			case 32:  				ret = (ret & 15) | (bs.ReadInt(8) << 4);  				break;  			case 48:  				ret = (ret & 15) | (bs.ReadInt(32 - 4) << 4);  				break;  			}
Magic Number,DemoInfo,BitStreamUtil,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitStreamUtil.cs,ReadUBitInt,The following statement contains a magic number: switch (ret & (16 | 32))  			{  			case 16:  				ret = (ret & 15) | (bs.ReadInt(4) << 4);  				break;  			case 32:  				ret = (ret & 15) | (bs.ReadInt(8) << 4);  				break;  			case 48:  				ret = (ret & 15) | (bs.ReadInt(32 - 4) << 4);  				break;  			}
Magic Number,DemoInfo,BitStreamUtil,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitStreamUtil.cs,ReadUBitInt,The following statement contains a magic number: switch (ret & (16 | 32))  			{  			case 16:  				ret = (ret & 15) | (bs.ReadInt(4) << 4);  				break;  			case 32:  				ret = (ret & 15) | (bs.ReadInt(8) << 4);  				break;  			case 48:  				ret = (ret & 15) | (bs.ReadInt(32 - 4) << 4);  				break;  			}
Magic Number,DemoInfo,BitStreamUtil,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitStreamUtil.cs,ReadUBitInt,The following statement contains a magic number: switch (ret & (16 | 32))  			{  			case 16:  				ret = (ret & 15) | (bs.ReadInt(4) << 4);  				break;  			case 32:  				ret = (ret & 15) | (bs.ReadInt(8) << 4);  				break;  			case 48:  				ret = (ret & 15) | (bs.ReadInt(32 - 4) << 4);  				break;  			}
Magic Number,DemoInfo,BitStreamUtil,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitStreamUtil.cs,ReadUBitInt,The following statement contains a magic number: switch (ret & (16 | 32))  			{  			case 16:  				ret = (ret & 15) | (bs.ReadInt(4) << 4);  				break;  			case 32:  				ret = (ret & 15) | (bs.ReadInt(8) << 4);  				break;  			case 48:  				ret = (ret & 15) | (bs.ReadInt(32 - 4) << 4);  				break;  			}
Magic Number,DemoInfo,BitStreamUtil,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitStreamUtil.cs,ReadUBitInt,The following statement contains a magic number: switch (ret & (16 | 32))  			{  			case 16:  				ret = (ret & 15) | (bs.ReadInt(4) << 4);  				break;  			case 32:  				ret = (ret & 15) | (bs.ReadInt(8) << 4);  				break;  			case 48:  				ret = (ret & 15) | (bs.ReadInt(32 - 4) << 4);  				break;  			}
Magic Number,DemoInfo,BitStreamUtil,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitStreamUtil.cs,ReadUBitInt,The following statement contains a magic number: switch (ret & (16 | 32))  			{  			case 16:  				ret = (ret & 15) | (bs.ReadInt(4) << 4);  				break;  			case 32:  				ret = (ret & 15) | (bs.ReadInt(8) << 4);  				break;  			case 48:  				ret = (ret & 15) | (bs.ReadInt(32 - 4) << 4);  				break;  			}
Magic Number,DemoInfo,BitStreamUtil,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitStreamUtil.cs,ReadUBitInt,The following statement contains a magic number: switch (ret & (16 | 32))  			{  			case 16:  				ret = (ret & 15) | (bs.ReadInt(4) << 4);  				break;  			case 32:  				ret = (ret & 15) | (bs.ReadInt(8) << 4);  				break;  			case 48:  				ret = (ret & 15) | (bs.ReadInt(32 - 4) << 4);  				break;  			}
Magic Number,DemoInfo,BitStreamUtil,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitStreamUtil.cs,ReadUBitInt,The following statement contains a magic number: switch (ret & (16 | 32))  			{  			case 16:  				ret = (ret & 15) | (bs.ReadInt(4) << 4);  				break;  			case 32:  				ret = (ret & 15) | (bs.ReadInt(8) << 4);  				break;  			case 48:  				ret = (ret & 15) | (bs.ReadInt(32 - 4) << 4);  				break;  			}
Magic Number,DemoInfo,BitStreamUtil,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitStreamUtil.cs,ReadUBitInt,The following statement contains a magic number: switch (ret & (16 | 32))  			{  			case 16:  				ret = (ret & 15) | (bs.ReadInt(4) << 4);  				break;  			case 32:  				ret = (ret & 15) | (bs.ReadInt(8) << 4);  				break;  			case 48:  				ret = (ret & 15) | (bs.ReadInt(32 - 4) << 4);  				break;  			}
Magic Number,DemoInfo,BitStreamUtil,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitStreamUtil.cs,ReadUBitInt,The following statement contains a magic number: switch (ret & (16 | 32))  			{  			case 16:  				ret = (ret & 15) | (bs.ReadInt(4) << 4);  				break;  			case 32:  				ret = (ret & 15) | (bs.ReadInt(8) << 4);  				break;  			case 48:  				ret = (ret & 15) | (bs.ReadInt(32 - 4) << 4);  				break;  			}
Magic Number,DemoInfo,BitStreamUtil,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitStreamUtil.cs,ReadUBitInt,The following statement contains a magic number: switch (ret & (16 | 32))  			{  			case 16:  				ret = (ret & 15) | (bs.ReadInt(4) << 4);  				break;  			case 32:  				ret = (ret & 15) | (bs.ReadInt(8) << 4);  				break;  			case 48:  				ret = (ret & 15) | (bs.ReadInt(32 - 4) << 4);  				break;  			}
Magic Number,DemoInfo,BitStreamUtil,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitStreamUtil.cs,ReadString,The following statement contains a magic number: var result = new List<byte>(512);
Magic Number,DemoInfo,BitStreamUtil,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitStreamUtil.cs,ReadString,The following statement contains a magic number: for (int pos = 0; pos < limit; pos++) {  				var b = bs.ReadByte();  				if ((b == 0) || (b == 10))  					break;  				result.Add(b);  			}
Magic Number,DemoInfo,BitStreamUtil,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitStreamUtil.cs,ReadCString,The following statement contains a magic number: return Encoding.Default.GetString(reader.ReadBytes(length)).Split(new char[] { '\0' }' 2)[0];
Magic Number,DemoInfo,BitStreamUtil,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitStreamUtil.cs,ReadVarInt,The following statement contains a magic number: for (int count = 0; (tmpByte & 0x80) != 0; count++) {  				if (count > 5)  					throw new InvalidDataException("VarInt32 out of range");  				tmpByte = bs.ReadByte();  				result |= (tmpByte & 0x7F) << (7 * count);  			}
Magic Number,DemoInfo,BitStreamUtil,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitStreamUtil.cs,ReadVarInt,The following statement contains a magic number: for (int count = 0; (tmpByte & 0x80) != 0; count++) {  				if (count > 5)  					throw new InvalidDataException("VarInt32 out of range");  				tmpByte = bs.ReadByte();  				result |= (tmpByte & 0x7F) << (7 * count);  			}
Magic Number,DemoInfo,BitStreamUtil,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitStreamUtil.cs,ReadProtobufVarIntStub,The following statement contains a magic number: for (int count = 0; (b & 0x80) != 0; count++) {  				b = reader.ReadByte();    				if ((count < 4) || ((count == 4) && (((b & 0xF8) == 0) || ((b & 0xF8) == 0xF8))))  					result |= (b & ~0x80) << (7 * count);  				else {  					if (count >= 10)  						throw new OverflowException("Nope nope nope nope! 10 bytes max!");  					if ((count == 9) ? (b != 1) : ((b & 0x7F) != 0x7F))  						throw new NotSupportedException("more than 32 bits are not supported");  				}  			}
Magic Number,DemoInfo,BitStreamUtil,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitStreamUtil.cs,ReadProtobufVarIntStub,The following statement contains a magic number: for (int count = 0; (b & 0x80) != 0; count++) {  				b = reader.ReadByte();    				if ((count < 4) || ((count == 4) && (((b & 0xF8) == 0) || ((b & 0xF8) == 0xF8))))  					result |= (b & ~0x80) << (7 * count);  				else {  					if (count >= 10)  						throw new OverflowException("Nope nope nope nope! 10 bytes max!");  					if ((count == 9) ? (b != 1) : ((b & 0x7F) != 0x7F))  						throw new NotSupportedException("more than 32 bits are not supported");  				}  			}
Magic Number,DemoInfo,BitStreamUtil,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitStreamUtil.cs,ReadProtobufVarIntStub,The following statement contains a magic number: for (int count = 0; (b & 0x80) != 0; count++) {  				b = reader.ReadByte();    				if ((count < 4) || ((count == 4) && (((b & 0xF8) == 0) || ((b & 0xF8) == 0xF8))))  					result |= (b & ~0x80) << (7 * count);  				else {  					if (count >= 10)  						throw new OverflowException("Nope nope nope nope! 10 bytes max!");  					if ((count == 9) ? (b != 1) : ((b & 0x7F) != 0x7F))  						throw new NotSupportedException("more than 32 bits are not supported");  				}  			}
Magic Number,DemoInfo,BitStreamUtil,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitStreamUtil.cs,ReadProtobufVarIntStub,The following statement contains a magic number: for (int count = 0; (b & 0x80) != 0; count++) {  				b = reader.ReadByte();    				if ((count < 4) || ((count == 4) && (((b & 0xF8) == 0) || ((b & 0xF8) == 0xF8))))  					result |= (b & ~0x80) << (7 * count);  				else {  					if (count >= 10)  						throw new OverflowException("Nope nope nope nope! 10 bytes max!");  					if ((count == 9) ? (b != 1) : ((b & 0x7F) != 0x7F))  						throw new NotSupportedException("more than 32 bits are not supported");  				}  			}
Magic Number,DemoInfo,BitStreamUtil,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitStreamUtil.cs,ReadProtobufVarIntStub,The following statement contains a magic number: for (int count = 0; (b & 0x80) != 0; count++) {  				b = reader.ReadByte();    				if ((count < 4) || ((count == 4) && (((b & 0xF8) == 0) || ((b & 0xF8) == 0xF8))))  					result |= (b & ~0x80) << (7 * count);  				else {  					if (count >= 10)  						throw new OverflowException("Nope nope nope nope! 10 bytes max!");  					if ((count == 9) ? (b != 1) : ((b & 0x7F) != 0x7F))  						throw new NotSupportedException("more than 32 bits are not supported");  				}  			}
Magic Number,DemoInfo,NETTick,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\NETTick.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;  				if (wireType != 0)  					throw new InvalidDataException();    				var val = (uint)bitstream.ReadProtobufVarInt();    				switch (fieldnum) {  				case 1:  					Tick = val;  					break;  				case 4:  					HostComputationTime = val;  					break;  				case 5:  					HostComputationTimeStdDeviation = val;  					break;  				case 6:  					HostFramestartTimeStdDeviation = val;  					break;  				default:  					// silently drop  					break;  				}  			}
Magic Number,DemoInfo,NETTick,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\NETTick.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;  				if (wireType != 0)  					throw new InvalidDataException();    				var val = (uint)bitstream.ReadProtobufVarInt();    				switch (fieldnum) {  				case 1:  					Tick = val;  					break;  				case 4:  					HostComputationTime = val;  					break;  				case 5:  					HostComputationTimeStdDeviation = val;  					break;  				case 6:  					HostFramestartTimeStdDeviation = val;  					break;  				default:  					// silently drop  					break;  				}  			}
Magic Number,DemoInfo,NETTick,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\NETTick.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;  				if (wireType != 0)  					throw new InvalidDataException();    				var val = (uint)bitstream.ReadProtobufVarInt();    				switch (fieldnum) {  				case 1:  					Tick = val;  					break;  				case 4:  					HostComputationTime = val;  					break;  				case 5:  					HostComputationTimeStdDeviation = val;  					break;  				case 6:  					HostFramestartTimeStdDeviation = val;  					break;  				default:  					// silently drop  					break;  				}  			}
Magic Number,DemoInfo,NETTick,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\NETTick.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;  				if (wireType != 0)  					throw new InvalidDataException();    				var val = (uint)bitstream.ReadProtobufVarInt();    				switch (fieldnum) {  				case 1:  					Tick = val;  					break;  				case 4:  					HostComputationTime = val;  					break;  				case 5:  					HostComputationTimeStdDeviation = val;  					break;  				case 6:  					HostFramestartTimeStdDeviation = val;  					break;  				default:  					// silently drop  					break;  				}  			}
Magic Number,DemoInfo,NETTick,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\NETTick.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;  				if (wireType != 0)  					throw new InvalidDataException();    				var val = (uint)bitstream.ReadProtobufVarInt();    				switch (fieldnum) {  				case 1:  					Tick = val;  					break;  				case 4:  					HostComputationTime = val;  					break;  				case 5:  					HostComputationTimeStdDeviation = val;  					break;  				case 6:  					HostFramestartTimeStdDeviation = val;  					break;  				default:  					// silently drop  					break;  				}  			}
Magic Number,DemoInfo,PacketEntities,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\PacketEntities.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if ((fieldnum == 7) && (wireType == 2)) {  					// Entity data is special.  					// We'll simply hope that gaben is nice and sends  					// entity_data last' just like he should.    					var len = bitstream.ReadProtobufVarInt();  					bitstream.BeginChunk(len * 8);  					DemoInfo.DP.Handler.PacketEntitesHandler.Apply(this' bitstream' parser);  					bitstream.EndChunk();  					if (!bitstream.ChunkFinished)  						throw new NotImplementedException("Lord Gaben wasn't nice to us :/");  					break;  				}    				if (wireType != 0)  					throw new InvalidDataException();    				var val = bitstream.ReadProtobufVarInt();    				switch (fieldnum) {  				case 1:  					MaxEntries = val;  					break;  				case 2:  					UpdatedEntries = val;  					break;  				case 3:  					_IsDelta = val;  					break;  				case 4:  					_UpdateBaseline = val;  					break;  				case 5:  					Baseline = val;  					break;  				case 6:  					DeltaFrom = val;  					break;  				default:  					// silently drop  					break;  				}  			}
Magic Number,DemoInfo,PacketEntities,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\PacketEntities.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if ((fieldnum == 7) && (wireType == 2)) {  					// Entity data is special.  					// We'll simply hope that gaben is nice and sends  					// entity_data last' just like he should.    					var len = bitstream.ReadProtobufVarInt();  					bitstream.BeginChunk(len * 8);  					DemoInfo.DP.Handler.PacketEntitesHandler.Apply(this' bitstream' parser);  					bitstream.EndChunk();  					if (!bitstream.ChunkFinished)  						throw new NotImplementedException("Lord Gaben wasn't nice to us :/");  					break;  				}    				if (wireType != 0)  					throw new InvalidDataException();    				var val = bitstream.ReadProtobufVarInt();    				switch (fieldnum) {  				case 1:  					MaxEntries = val;  					break;  				case 2:  					UpdatedEntries = val;  					break;  				case 3:  					_IsDelta = val;  					break;  				case 4:  					_UpdateBaseline = val;  					break;  				case 5:  					Baseline = val;  					break;  				case 6:  					DeltaFrom = val;  					break;  				default:  					// silently drop  					break;  				}  			}
Magic Number,DemoInfo,PacketEntities,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\PacketEntities.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if ((fieldnum == 7) && (wireType == 2)) {  					// Entity data is special.  					// We'll simply hope that gaben is nice and sends  					// entity_data last' just like he should.    					var len = bitstream.ReadProtobufVarInt();  					bitstream.BeginChunk(len * 8);  					DemoInfo.DP.Handler.PacketEntitesHandler.Apply(this' bitstream' parser);  					bitstream.EndChunk();  					if (!bitstream.ChunkFinished)  						throw new NotImplementedException("Lord Gaben wasn't nice to us :/");  					break;  				}    				if (wireType != 0)  					throw new InvalidDataException();    				var val = bitstream.ReadProtobufVarInt();    				switch (fieldnum) {  				case 1:  					MaxEntries = val;  					break;  				case 2:  					UpdatedEntries = val;  					break;  				case 3:  					_IsDelta = val;  					break;  				case 4:  					_UpdateBaseline = val;  					break;  				case 5:  					Baseline = val;  					break;  				case 6:  					DeltaFrom = val;  					break;  				default:  					// silently drop  					break;  				}  			}
Magic Number,DemoInfo,PacketEntities,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\PacketEntities.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if ((fieldnum == 7) && (wireType == 2)) {  					// Entity data is special.  					// We'll simply hope that gaben is nice and sends  					// entity_data last' just like he should.    					var len = bitstream.ReadProtobufVarInt();  					bitstream.BeginChunk(len * 8);  					DemoInfo.DP.Handler.PacketEntitesHandler.Apply(this' bitstream' parser);  					bitstream.EndChunk();  					if (!bitstream.ChunkFinished)  						throw new NotImplementedException("Lord Gaben wasn't nice to us :/");  					break;  				}    				if (wireType != 0)  					throw new InvalidDataException();    				var val = bitstream.ReadProtobufVarInt();    				switch (fieldnum) {  				case 1:  					MaxEntries = val;  					break;  				case 2:  					UpdatedEntries = val;  					break;  				case 3:  					_IsDelta = val;  					break;  				case 4:  					_UpdateBaseline = val;  					break;  				case 5:  					Baseline = val;  					break;  				case 6:  					DeltaFrom = val;  					break;  				default:  					// silently drop  					break;  				}  			}
Magic Number,DemoInfo,PacketEntities,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\PacketEntities.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if ((fieldnum == 7) && (wireType == 2)) {  					// Entity data is special.  					// We'll simply hope that gaben is nice and sends  					// entity_data last' just like he should.    					var len = bitstream.ReadProtobufVarInt();  					bitstream.BeginChunk(len * 8);  					DemoInfo.DP.Handler.PacketEntitesHandler.Apply(this' bitstream' parser);  					bitstream.EndChunk();  					if (!bitstream.ChunkFinished)  						throw new NotImplementedException("Lord Gaben wasn't nice to us :/");  					break;  				}    				if (wireType != 0)  					throw new InvalidDataException();    				var val = bitstream.ReadProtobufVarInt();    				switch (fieldnum) {  				case 1:  					MaxEntries = val;  					break;  				case 2:  					UpdatedEntries = val;  					break;  				case 3:  					_IsDelta = val;  					break;  				case 4:  					_UpdateBaseline = val;  					break;  				case 5:  					Baseline = val;  					break;  				case 6:  					DeltaFrom = val;  					break;  				default:  					// silently drop  					break;  				}  			}
Magic Number,DemoInfo,PacketEntities,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\PacketEntities.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if ((fieldnum == 7) && (wireType == 2)) {  					// Entity data is special.  					// We'll simply hope that gaben is nice and sends  					// entity_data last' just like he should.    					var len = bitstream.ReadProtobufVarInt();  					bitstream.BeginChunk(len * 8);  					DemoInfo.DP.Handler.PacketEntitesHandler.Apply(this' bitstream' parser);  					bitstream.EndChunk();  					if (!bitstream.ChunkFinished)  						throw new NotImplementedException("Lord Gaben wasn't nice to us :/");  					break;  				}    				if (wireType != 0)  					throw new InvalidDataException();    				var val = bitstream.ReadProtobufVarInt();    				switch (fieldnum) {  				case 1:  					MaxEntries = val;  					break;  				case 2:  					UpdatedEntries = val;  					break;  				case 3:  					_IsDelta = val;  					break;  				case 4:  					_UpdateBaseline = val;  					break;  				case 5:  					Baseline = val;  					break;  				case 6:  					DeltaFrom = val;  					break;  				default:  					// silently drop  					break;  				}  			}
Magic Number,DemoInfo,PacketEntities,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\PacketEntities.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if ((fieldnum == 7) && (wireType == 2)) {  					// Entity data is special.  					// We'll simply hope that gaben is nice and sends  					// entity_data last' just like he should.    					var len = bitstream.ReadProtobufVarInt();  					bitstream.BeginChunk(len * 8);  					DemoInfo.DP.Handler.PacketEntitesHandler.Apply(this' bitstream' parser);  					bitstream.EndChunk();  					if (!bitstream.ChunkFinished)  						throw new NotImplementedException("Lord Gaben wasn't nice to us :/");  					break;  				}    				if (wireType != 0)  					throw new InvalidDataException();    				var val = bitstream.ReadProtobufVarInt();    				switch (fieldnum) {  				case 1:  					MaxEntries = val;  					break;  				case 2:  					UpdatedEntries = val;  					break;  				case 3:  					_IsDelta = val;  					break;  				case 4:  					_UpdateBaseline = val;  					break;  				case 5:  					Baseline = val;  					break;  				case 6:  					DeltaFrom = val;  					break;  				default:  					// silently drop  					break;  				}  			}
Magic Number,DemoInfo,PacketEntities,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\PacketEntities.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if ((fieldnum == 7) && (wireType == 2)) {  					// Entity data is special.  					// We'll simply hope that gaben is nice and sends  					// entity_data last' just like he should.    					var len = bitstream.ReadProtobufVarInt();  					bitstream.BeginChunk(len * 8);  					DemoInfo.DP.Handler.PacketEntitesHandler.Apply(this' bitstream' parser);  					bitstream.EndChunk();  					if (!bitstream.ChunkFinished)  						throw new NotImplementedException("Lord Gaben wasn't nice to us :/");  					break;  				}    				if (wireType != 0)  					throw new InvalidDataException();    				var val = bitstream.ReadProtobufVarInt();    				switch (fieldnum) {  				case 1:  					MaxEntries = val;  					break;  				case 2:  					UpdatedEntries = val;  					break;  				case 3:  					_IsDelta = val;  					break;  				case 4:  					_UpdateBaseline = val;  					break;  				case 5:  					Baseline = val;  					break;  				case 6:  					DeltaFrom = val;  					break;  				default:  					// silently drop  					break;  				}  			}
Magic Number,DemoInfo,PacketEntities,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\PacketEntities.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if ((fieldnum == 7) && (wireType == 2)) {  					// Entity data is special.  					// We'll simply hope that gaben is nice and sends  					// entity_data last' just like he should.    					var len = bitstream.ReadProtobufVarInt();  					bitstream.BeginChunk(len * 8);  					DemoInfo.DP.Handler.PacketEntitesHandler.Apply(this' bitstream' parser);  					bitstream.EndChunk();  					if (!bitstream.ChunkFinished)  						throw new NotImplementedException("Lord Gaben wasn't nice to us :/");  					break;  				}    				if (wireType != 0)  					throw new InvalidDataException();    				var val = bitstream.ReadProtobufVarInt();    				switch (fieldnum) {  				case 1:  					MaxEntries = val;  					break;  				case 2:  					UpdatedEntries = val;  					break;  				case 3:  					_IsDelta = val;  					break;  				case 4:  					_UpdateBaseline = val;  					break;  				case 5:  					Baseline = val;  					break;  				case 6:  					DeltaFrom = val;  					break;  				default:  					// silently drop  					break;  				}  			}
Magic Number,DemoInfo,PacketEntities,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\PacketEntities.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if ((fieldnum == 7) && (wireType == 2)) {  					// Entity data is special.  					// We'll simply hope that gaben is nice and sends  					// entity_data last' just like he should.    					var len = bitstream.ReadProtobufVarInt();  					bitstream.BeginChunk(len * 8);  					DemoInfo.DP.Handler.PacketEntitesHandler.Apply(this' bitstream' parser);  					bitstream.EndChunk();  					if (!bitstream.ChunkFinished)  						throw new NotImplementedException("Lord Gaben wasn't nice to us :/");  					break;  				}    				if (wireType != 0)  					throw new InvalidDataException();    				var val = bitstream.ReadProtobufVarInt();    				switch (fieldnum) {  				case 1:  					MaxEntries = val;  					break;  				case 2:  					UpdatedEntries = val;  					break;  				case 3:  					_IsDelta = val;  					break;  				case 4:  					_UpdateBaseline = val;  					break;  				case 5:  					Baseline = val;  					break;  				case 6:  					DeltaFrom = val;  					break;  				default:  					// silently drop  					break;  				}  			}
Magic Number,DemoInfo,GameEventList,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\GameEventList.cs,ReadDescriptors,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;  				if ((wireType != 2) || (fieldnum != 1))  					throw new InvalidDataException();    				var length = bitstream.ReadProtobufVarInt();  				bitstream.BeginChunk(length * 8);  				var descriptor = new Descriptor();  				descriptor.Parse(bitstream);  				yield return descriptor;  				bitstream.EndChunk();  			}
Magic Number,DemoInfo,GameEventList,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\GameEventList.cs,ReadDescriptors,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;  				if ((wireType != 2) || (fieldnum != 1))  					throw new InvalidDataException();    				var length = bitstream.ReadProtobufVarInt();  				bitstream.BeginChunk(length * 8);  				var descriptor = new Descriptor();  				descriptor.Parse(bitstream);  				yield return descriptor;  				bitstream.EndChunk();  			}
Magic Number,DemoInfo,GameEventList,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\GameEventList.cs,ReadDescriptors,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;  				if ((wireType != 2) || (fieldnum != 1))  					throw new InvalidDataException();    				var length = bitstream.ReadProtobufVarInt();  				bitstream.BeginChunk(length * 8);  				var descriptor = new Descriptor();  				descriptor.Parse(bitstream);  				yield return descriptor;  				bitstream.EndChunk();  			}
Magic Number,DemoInfo,GameEventList,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\GameEventList.cs,ReadDescriptors,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;  				if ((wireType != 2) || (fieldnum != 1))  					throw new InvalidDataException();    				var length = bitstream.ReadProtobufVarInt();  				bitstream.BeginChunk(length * 8);  				var descriptor = new Descriptor();  				descriptor.Parse(bitstream);  				yield return descriptor;  				bitstream.EndChunk();  			}
Magic Number,DemoInfo,Key,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\GameEventList.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  					var desc = bitstream.ReadProtobufVarInt();  					var wireType = desc & 7;  					var fieldnum = desc >> 3;  					if ((wireType == 0) && (fieldnum == 1)) {  						Type = bitstream.ReadProtobufVarInt();  					} else if ((wireType == 2) && (fieldnum == 2)) {  						Name = bitstream.ReadProtobufString();  					} else  						throw new InvalidDataException();  				}
Magic Number,DemoInfo,Key,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\GameEventList.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  					var desc = bitstream.ReadProtobufVarInt();  					var wireType = desc & 7;  					var fieldnum = desc >> 3;  					if ((wireType == 0) && (fieldnum == 1)) {  						Type = bitstream.ReadProtobufVarInt();  					} else if ((wireType == 2) && (fieldnum == 2)) {  						Name = bitstream.ReadProtobufString();  					} else  						throw new InvalidDataException();  				}
Magic Number,DemoInfo,Key,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\GameEventList.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  					var desc = bitstream.ReadProtobufVarInt();  					var wireType = desc & 7;  					var fieldnum = desc >> 3;  					if ((wireType == 0) && (fieldnum == 1)) {  						Type = bitstream.ReadProtobufVarInt();  					} else if ((wireType == 2) && (fieldnum == 2)) {  						Name = bitstream.ReadProtobufString();  					} else  						throw new InvalidDataException();  				}
Magic Number,DemoInfo,Key,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\GameEventList.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  					var desc = bitstream.ReadProtobufVarInt();  					var wireType = desc & 7;  					var fieldnum = desc >> 3;  					if ((wireType == 0) && (fieldnum == 1)) {  						Type = bitstream.ReadProtobufVarInt();  					} else if ((wireType == 2) && (fieldnum == 2)) {  						Name = bitstream.ReadProtobufString();  					} else  						throw new InvalidDataException();  				}
Magic Number,DemoInfo,Descriptor,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\GameEventList.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  					var desc = bitstream.ReadProtobufVarInt();  					var wireType = desc & 7;  					var fieldnum = desc >> 3;  					if ((wireType == 0) && (fieldnum == 1)) {  						EventId = bitstream.ReadProtobufVarInt();  					} else if ((wireType == 2) && (fieldnum == 2)) {  						Name = bitstream.ReadProtobufString();  					} else if ((wireType == 2) && (fieldnum == 3)) {  						var length = bitstream.ReadProtobufVarInt();  						bitstream.BeginChunk(length * 8);  						var key = new Key();  						key.Parse(bitstream);  						keys.Add(key);  						bitstream.EndChunk();  					} else  						throw new InvalidDataException();  				}
Magic Number,DemoInfo,Descriptor,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\GameEventList.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  					var desc = bitstream.ReadProtobufVarInt();  					var wireType = desc & 7;  					var fieldnum = desc >> 3;  					if ((wireType == 0) && (fieldnum == 1)) {  						EventId = bitstream.ReadProtobufVarInt();  					} else if ((wireType == 2) && (fieldnum == 2)) {  						Name = bitstream.ReadProtobufString();  					} else if ((wireType == 2) && (fieldnum == 3)) {  						var length = bitstream.ReadProtobufVarInt();  						bitstream.BeginChunk(length * 8);  						var key = new Key();  						key.Parse(bitstream);  						keys.Add(key);  						bitstream.EndChunk();  					} else  						throw new InvalidDataException();  				}
Magic Number,DemoInfo,Descriptor,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\GameEventList.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  					var desc = bitstream.ReadProtobufVarInt();  					var wireType = desc & 7;  					var fieldnum = desc >> 3;  					if ((wireType == 0) && (fieldnum == 1)) {  						EventId = bitstream.ReadProtobufVarInt();  					} else if ((wireType == 2) && (fieldnum == 2)) {  						Name = bitstream.ReadProtobufString();  					} else if ((wireType == 2) && (fieldnum == 3)) {  						var length = bitstream.ReadProtobufVarInt();  						bitstream.BeginChunk(length * 8);  						var key = new Key();  						key.Parse(bitstream);  						keys.Add(key);  						bitstream.EndChunk();  					} else  						throw new InvalidDataException();  				}
Magic Number,DemoInfo,Descriptor,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\GameEventList.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  					var desc = bitstream.ReadProtobufVarInt();  					var wireType = desc & 7;  					var fieldnum = desc >> 3;  					if ((wireType == 0) && (fieldnum == 1)) {  						EventId = bitstream.ReadProtobufVarInt();  					} else if ((wireType == 2) && (fieldnum == 2)) {  						Name = bitstream.ReadProtobufString();  					} else if ((wireType == 2) && (fieldnum == 3)) {  						var length = bitstream.ReadProtobufVarInt();  						bitstream.BeginChunk(length * 8);  						var key = new Key();  						key.Parse(bitstream);  						keys.Add(key);  						bitstream.EndChunk();  					} else  						throw new InvalidDataException();  				}
Magic Number,DemoInfo,Descriptor,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\GameEventList.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  					var desc = bitstream.ReadProtobufVarInt();  					var wireType = desc & 7;  					var fieldnum = desc >> 3;  					if ((wireType == 0) && (fieldnum == 1)) {  						EventId = bitstream.ReadProtobufVarInt();  					} else if ((wireType == 2) && (fieldnum == 2)) {  						Name = bitstream.ReadProtobufString();  					} else if ((wireType == 2) && (fieldnum == 3)) {  						var length = bitstream.ReadProtobufVarInt();  						bitstream.BeginChunk(length * 8);  						var key = new Key();  						key.Parse(bitstream);  						keys.Add(key);  						bitstream.EndChunk();  					} else  						throw new InvalidDataException();  				}
Magic Number,DemoInfo,Descriptor,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\GameEventList.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  					var desc = bitstream.ReadProtobufVarInt();  					var wireType = desc & 7;  					var fieldnum = desc >> 3;  					if ((wireType == 0) && (fieldnum == 1)) {  						EventId = bitstream.ReadProtobufVarInt();  					} else if ((wireType == 2) && (fieldnum == 2)) {  						Name = bitstream.ReadProtobufString();  					} else if ((wireType == 2) && (fieldnum == 3)) {  						var length = bitstream.ReadProtobufVarInt();  						bitstream.BeginChunk(length * 8);  						var key = new Key();  						key.Parse(bitstream);  						keys.Add(key);  						bitstream.EndChunk();  					} else  						throw new InvalidDataException();  				}
Magic Number,DemoInfo,Descriptor,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\GameEventList.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  					var desc = bitstream.ReadProtobufVarInt();  					var wireType = desc & 7;  					var fieldnum = desc >> 3;  					if ((wireType == 0) && (fieldnum == 1)) {  						EventId = bitstream.ReadProtobufVarInt();  					} else if ((wireType == 2) && (fieldnum == 2)) {  						Name = bitstream.ReadProtobufString();  					} else if ((wireType == 2) && (fieldnum == 3)) {  						var length = bitstream.ReadProtobufVarInt();  						bitstream.BeginChunk(length * 8);  						var key = new Key();  						key.Parse(bitstream);  						keys.Add(key);  						bitstream.EndChunk();  					} else  						throw new InvalidDataException();  				}
Magic Number,DemoInfo,GameEvent,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\GameEvent.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;  				if ((wireType == 2) && (fieldnum == 1)) {  					EventName = bitstream.ReadProtobufString();  				} else if ((wireType == 0) && (fieldnum == 2)) {  					EventId = bitstream.ReadProtobufVarInt();  				} else if ((wireType == 2) && (fieldnum == 3)) {  					bitstream.BeginChunk(bitstream.ReadProtobufVarInt() * 8);  					/*  					 * Hope and pray that gaben is once again nice to us and  					 * sends 'type' first' then the respective member' then NOTHING.  					 */  					desc = bitstream.ReadProtobufVarInt();  					wireType = desc & 7;  					fieldnum = desc >> 3;  					if ((wireType != 0) || (fieldnum != 1))  						throw new InvalidDataException("Lord Gaben wasn't nice to us :/");    					var typeMember = bitstream.ReadProtobufVarInt();  					desc = bitstream.ReadProtobufVarInt();  					wireType = desc & 7;  					fieldnum = desc >> 3;    					if (fieldnum != (typeMember + 1))  						throw new InvalidDataException("Lord Gaben wasn't nice to us :/ (srsly wtf!?)");    					switch (typeMember) {  					case 1: // string  						if (wireType != 2)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufString());  						break;  					case 2: // float  						if (wireType != 5)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadFloat());  						break;  					case 3: // long  					case 4: // short  					case 5: // byte  						if (wireType != 0)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufVarInt());  						break;  					case 6: // bool  						if (wireType != 0)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufVarInt() != 0);  						break;  					default:  						throw new InvalidDataException("Looks like they introduced a new type");  					}    					if (!bitstream.ChunkFinished)  						throw new InvalidDataException("Lord Gaben tricked us! D:");    					bitstream.EndChunk();  				} else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo,GameEvent,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\GameEvent.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;  				if ((wireType == 2) && (fieldnum == 1)) {  					EventName = bitstream.ReadProtobufString();  				} else if ((wireType == 0) && (fieldnum == 2)) {  					EventId = bitstream.ReadProtobufVarInt();  				} else if ((wireType == 2) && (fieldnum == 3)) {  					bitstream.BeginChunk(bitstream.ReadProtobufVarInt() * 8);  					/*  					 * Hope and pray that gaben is once again nice to us and  					 * sends 'type' first' then the respective member' then NOTHING.  					 */  					desc = bitstream.ReadProtobufVarInt();  					wireType = desc & 7;  					fieldnum = desc >> 3;  					if ((wireType != 0) || (fieldnum != 1))  						throw new InvalidDataException("Lord Gaben wasn't nice to us :/");    					var typeMember = bitstream.ReadProtobufVarInt();  					desc = bitstream.ReadProtobufVarInt();  					wireType = desc & 7;  					fieldnum = desc >> 3;    					if (fieldnum != (typeMember + 1))  						throw new InvalidDataException("Lord Gaben wasn't nice to us :/ (srsly wtf!?)");    					switch (typeMember) {  					case 1: // string  						if (wireType != 2)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufString());  						break;  					case 2: // float  						if (wireType != 5)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadFloat());  						break;  					case 3: // long  					case 4: // short  					case 5: // byte  						if (wireType != 0)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufVarInt());  						break;  					case 6: // bool  						if (wireType != 0)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufVarInt() != 0);  						break;  					default:  						throw new InvalidDataException("Looks like they introduced a new type");  					}    					if (!bitstream.ChunkFinished)  						throw new InvalidDataException("Lord Gaben tricked us! D:");    					bitstream.EndChunk();  				} else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo,GameEvent,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\GameEvent.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;  				if ((wireType == 2) && (fieldnum == 1)) {  					EventName = bitstream.ReadProtobufString();  				} else if ((wireType == 0) && (fieldnum == 2)) {  					EventId = bitstream.ReadProtobufVarInt();  				} else if ((wireType == 2) && (fieldnum == 3)) {  					bitstream.BeginChunk(bitstream.ReadProtobufVarInt() * 8);  					/*  					 * Hope and pray that gaben is once again nice to us and  					 * sends 'type' first' then the respective member' then NOTHING.  					 */  					desc = bitstream.ReadProtobufVarInt();  					wireType = desc & 7;  					fieldnum = desc >> 3;  					if ((wireType != 0) || (fieldnum != 1))  						throw new InvalidDataException("Lord Gaben wasn't nice to us :/");    					var typeMember = bitstream.ReadProtobufVarInt();  					desc = bitstream.ReadProtobufVarInt();  					wireType = desc & 7;  					fieldnum = desc >> 3;    					if (fieldnum != (typeMember + 1))  						throw new InvalidDataException("Lord Gaben wasn't nice to us :/ (srsly wtf!?)");    					switch (typeMember) {  					case 1: // string  						if (wireType != 2)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufString());  						break;  					case 2: // float  						if (wireType != 5)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadFloat());  						break;  					case 3: // long  					case 4: // short  					case 5: // byte  						if (wireType != 0)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufVarInt());  						break;  					case 6: // bool  						if (wireType != 0)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufVarInt() != 0);  						break;  					default:  						throw new InvalidDataException("Looks like they introduced a new type");  					}    					if (!bitstream.ChunkFinished)  						throw new InvalidDataException("Lord Gaben tricked us! D:");    					bitstream.EndChunk();  				} else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo,GameEvent,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\GameEvent.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;  				if ((wireType == 2) && (fieldnum == 1)) {  					EventName = bitstream.ReadProtobufString();  				} else if ((wireType == 0) && (fieldnum == 2)) {  					EventId = bitstream.ReadProtobufVarInt();  				} else if ((wireType == 2) && (fieldnum == 3)) {  					bitstream.BeginChunk(bitstream.ReadProtobufVarInt() * 8);  					/*  					 * Hope and pray that gaben is once again nice to us and  					 * sends 'type' first' then the respective member' then NOTHING.  					 */  					desc = bitstream.ReadProtobufVarInt();  					wireType = desc & 7;  					fieldnum = desc >> 3;  					if ((wireType != 0) || (fieldnum != 1))  						throw new InvalidDataException("Lord Gaben wasn't nice to us :/");    					var typeMember = bitstream.ReadProtobufVarInt();  					desc = bitstream.ReadProtobufVarInt();  					wireType = desc & 7;  					fieldnum = desc >> 3;    					if (fieldnum != (typeMember + 1))  						throw new InvalidDataException("Lord Gaben wasn't nice to us :/ (srsly wtf!?)");    					switch (typeMember) {  					case 1: // string  						if (wireType != 2)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufString());  						break;  					case 2: // float  						if (wireType != 5)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadFloat());  						break;  					case 3: // long  					case 4: // short  					case 5: // byte  						if (wireType != 0)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufVarInt());  						break;  					case 6: // bool  						if (wireType != 0)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufVarInt() != 0);  						break;  					default:  						throw new InvalidDataException("Looks like they introduced a new type");  					}    					if (!bitstream.ChunkFinished)  						throw new InvalidDataException("Lord Gaben tricked us! D:");    					bitstream.EndChunk();  				} else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo,GameEvent,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\GameEvent.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;  				if ((wireType == 2) && (fieldnum == 1)) {  					EventName = bitstream.ReadProtobufString();  				} else if ((wireType == 0) && (fieldnum == 2)) {  					EventId = bitstream.ReadProtobufVarInt();  				} else if ((wireType == 2) && (fieldnum == 3)) {  					bitstream.BeginChunk(bitstream.ReadProtobufVarInt() * 8);  					/*  					 * Hope and pray that gaben is once again nice to us and  					 * sends 'type' first' then the respective member' then NOTHING.  					 */  					desc = bitstream.ReadProtobufVarInt();  					wireType = desc & 7;  					fieldnum = desc >> 3;  					if ((wireType != 0) || (fieldnum != 1))  						throw new InvalidDataException("Lord Gaben wasn't nice to us :/");    					var typeMember = bitstream.ReadProtobufVarInt();  					desc = bitstream.ReadProtobufVarInt();  					wireType = desc & 7;  					fieldnum = desc >> 3;    					if (fieldnum != (typeMember + 1))  						throw new InvalidDataException("Lord Gaben wasn't nice to us :/ (srsly wtf!?)");    					switch (typeMember) {  					case 1: // string  						if (wireType != 2)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufString());  						break;  					case 2: // float  						if (wireType != 5)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadFloat());  						break;  					case 3: // long  					case 4: // short  					case 5: // byte  						if (wireType != 0)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufVarInt());  						break;  					case 6: // bool  						if (wireType != 0)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufVarInt() != 0);  						break;  					default:  						throw new InvalidDataException("Looks like they introduced a new type");  					}    					if (!bitstream.ChunkFinished)  						throw new InvalidDataException("Lord Gaben tricked us! D:");    					bitstream.EndChunk();  				} else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo,GameEvent,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\GameEvent.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;  				if ((wireType == 2) && (fieldnum == 1)) {  					EventName = bitstream.ReadProtobufString();  				} else if ((wireType == 0) && (fieldnum == 2)) {  					EventId = bitstream.ReadProtobufVarInt();  				} else if ((wireType == 2) && (fieldnum == 3)) {  					bitstream.BeginChunk(bitstream.ReadProtobufVarInt() * 8);  					/*  					 * Hope and pray that gaben is once again nice to us and  					 * sends 'type' first' then the respective member' then NOTHING.  					 */  					desc = bitstream.ReadProtobufVarInt();  					wireType = desc & 7;  					fieldnum = desc >> 3;  					if ((wireType != 0) || (fieldnum != 1))  						throw new InvalidDataException("Lord Gaben wasn't nice to us :/");    					var typeMember = bitstream.ReadProtobufVarInt();  					desc = bitstream.ReadProtobufVarInt();  					wireType = desc & 7;  					fieldnum = desc >> 3;    					if (fieldnum != (typeMember + 1))  						throw new InvalidDataException("Lord Gaben wasn't nice to us :/ (srsly wtf!?)");    					switch (typeMember) {  					case 1: // string  						if (wireType != 2)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufString());  						break;  					case 2: // float  						if (wireType != 5)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadFloat());  						break;  					case 3: // long  					case 4: // short  					case 5: // byte  						if (wireType != 0)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufVarInt());  						break;  					case 6: // bool  						if (wireType != 0)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufVarInt() != 0);  						break;  					default:  						throw new InvalidDataException("Looks like they introduced a new type");  					}    					if (!bitstream.ChunkFinished)  						throw new InvalidDataException("Lord Gaben tricked us! D:");    					bitstream.EndChunk();  				} else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo,GameEvent,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\GameEvent.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;  				if ((wireType == 2) && (fieldnum == 1)) {  					EventName = bitstream.ReadProtobufString();  				} else if ((wireType == 0) && (fieldnum == 2)) {  					EventId = bitstream.ReadProtobufVarInt();  				} else if ((wireType == 2) && (fieldnum == 3)) {  					bitstream.BeginChunk(bitstream.ReadProtobufVarInt() * 8);  					/*  					 * Hope and pray that gaben is once again nice to us and  					 * sends 'type' first' then the respective member' then NOTHING.  					 */  					desc = bitstream.ReadProtobufVarInt();  					wireType = desc & 7;  					fieldnum = desc >> 3;  					if ((wireType != 0) || (fieldnum != 1))  						throw new InvalidDataException("Lord Gaben wasn't nice to us :/");    					var typeMember = bitstream.ReadProtobufVarInt();  					desc = bitstream.ReadProtobufVarInt();  					wireType = desc & 7;  					fieldnum = desc >> 3;    					if (fieldnum != (typeMember + 1))  						throw new InvalidDataException("Lord Gaben wasn't nice to us :/ (srsly wtf!?)");    					switch (typeMember) {  					case 1: // string  						if (wireType != 2)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufString());  						break;  					case 2: // float  						if (wireType != 5)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadFloat());  						break;  					case 3: // long  					case 4: // short  					case 5: // byte  						if (wireType != 0)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufVarInt());  						break;  					case 6: // bool  						if (wireType != 0)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufVarInt() != 0);  						break;  					default:  						throw new InvalidDataException("Looks like they introduced a new type");  					}    					if (!bitstream.ChunkFinished)  						throw new InvalidDataException("Lord Gaben tricked us! D:");    					bitstream.EndChunk();  				} else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo,GameEvent,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\GameEvent.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;  				if ((wireType == 2) && (fieldnum == 1)) {  					EventName = bitstream.ReadProtobufString();  				} else if ((wireType == 0) && (fieldnum == 2)) {  					EventId = bitstream.ReadProtobufVarInt();  				} else if ((wireType == 2) && (fieldnum == 3)) {  					bitstream.BeginChunk(bitstream.ReadProtobufVarInt() * 8);  					/*  					 * Hope and pray that gaben is once again nice to us and  					 * sends 'type' first' then the respective member' then NOTHING.  					 */  					desc = bitstream.ReadProtobufVarInt();  					wireType = desc & 7;  					fieldnum = desc >> 3;  					if ((wireType != 0) || (fieldnum != 1))  						throw new InvalidDataException("Lord Gaben wasn't nice to us :/");    					var typeMember = bitstream.ReadProtobufVarInt();  					desc = bitstream.ReadProtobufVarInt();  					wireType = desc & 7;  					fieldnum = desc >> 3;    					if (fieldnum != (typeMember + 1))  						throw new InvalidDataException("Lord Gaben wasn't nice to us :/ (srsly wtf!?)");    					switch (typeMember) {  					case 1: // string  						if (wireType != 2)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufString());  						break;  					case 2: // float  						if (wireType != 5)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadFloat());  						break;  					case 3: // long  					case 4: // short  					case 5: // byte  						if (wireType != 0)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufVarInt());  						break;  					case 6: // bool  						if (wireType != 0)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufVarInt() != 0);  						break;  					default:  						throw new InvalidDataException("Looks like they introduced a new type");  					}    					if (!bitstream.ChunkFinished)  						throw new InvalidDataException("Lord Gaben tricked us! D:");    					bitstream.EndChunk();  				} else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo,GameEvent,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\GameEvent.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;  				if ((wireType == 2) && (fieldnum == 1)) {  					EventName = bitstream.ReadProtobufString();  				} else if ((wireType == 0) && (fieldnum == 2)) {  					EventId = bitstream.ReadProtobufVarInt();  				} else if ((wireType == 2) && (fieldnum == 3)) {  					bitstream.BeginChunk(bitstream.ReadProtobufVarInt() * 8);  					/*  					 * Hope and pray that gaben is once again nice to us and  					 * sends 'type' first' then the respective member' then NOTHING.  					 */  					desc = bitstream.ReadProtobufVarInt();  					wireType = desc & 7;  					fieldnum = desc >> 3;  					if ((wireType != 0) || (fieldnum != 1))  						throw new InvalidDataException("Lord Gaben wasn't nice to us :/");    					var typeMember = bitstream.ReadProtobufVarInt();  					desc = bitstream.ReadProtobufVarInt();  					wireType = desc & 7;  					fieldnum = desc >> 3;    					if (fieldnum != (typeMember + 1))  						throw new InvalidDataException("Lord Gaben wasn't nice to us :/ (srsly wtf!?)");    					switch (typeMember) {  					case 1: // string  						if (wireType != 2)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufString());  						break;  					case 2: // float  						if (wireType != 5)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadFloat());  						break;  					case 3: // long  					case 4: // short  					case 5: // byte  						if (wireType != 0)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufVarInt());  						break;  					case 6: // bool  						if (wireType != 0)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufVarInt() != 0);  						break;  					default:  						throw new InvalidDataException("Looks like they introduced a new type");  					}    					if (!bitstream.ChunkFinished)  						throw new InvalidDataException("Lord Gaben tricked us! D:");    					bitstream.EndChunk();  				} else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo,GameEvent,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\GameEvent.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;  				if ((wireType == 2) && (fieldnum == 1)) {  					EventName = bitstream.ReadProtobufString();  				} else if ((wireType == 0) && (fieldnum == 2)) {  					EventId = bitstream.ReadProtobufVarInt();  				} else if ((wireType == 2) && (fieldnum == 3)) {  					bitstream.BeginChunk(bitstream.ReadProtobufVarInt() * 8);  					/*  					 * Hope and pray that gaben is once again nice to us and  					 * sends 'type' first' then the respective member' then NOTHING.  					 */  					desc = bitstream.ReadProtobufVarInt();  					wireType = desc & 7;  					fieldnum = desc >> 3;  					if ((wireType != 0) || (fieldnum != 1))  						throw new InvalidDataException("Lord Gaben wasn't nice to us :/");    					var typeMember = bitstream.ReadProtobufVarInt();  					desc = bitstream.ReadProtobufVarInt();  					wireType = desc & 7;  					fieldnum = desc >> 3;    					if (fieldnum != (typeMember + 1))  						throw new InvalidDataException("Lord Gaben wasn't nice to us :/ (srsly wtf!?)");    					switch (typeMember) {  					case 1: // string  						if (wireType != 2)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufString());  						break;  					case 2: // float  						if (wireType != 5)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadFloat());  						break;  					case 3: // long  					case 4: // short  					case 5: // byte  						if (wireType != 0)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufVarInt());  						break;  					case 6: // bool  						if (wireType != 0)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufVarInt() != 0);  						break;  					default:  						throw new InvalidDataException("Looks like they introduced a new type");  					}    					if (!bitstream.ChunkFinished)  						throw new InvalidDataException("Lord Gaben tricked us! D:");    					bitstream.EndChunk();  				} else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo,GameEvent,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\GameEvent.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;  				if ((wireType == 2) && (fieldnum == 1)) {  					EventName = bitstream.ReadProtobufString();  				} else if ((wireType == 0) && (fieldnum == 2)) {  					EventId = bitstream.ReadProtobufVarInt();  				} else if ((wireType == 2) && (fieldnum == 3)) {  					bitstream.BeginChunk(bitstream.ReadProtobufVarInt() * 8);  					/*  					 * Hope and pray that gaben is once again nice to us and  					 * sends 'type' first' then the respective member' then NOTHING.  					 */  					desc = bitstream.ReadProtobufVarInt();  					wireType = desc & 7;  					fieldnum = desc >> 3;  					if ((wireType != 0) || (fieldnum != 1))  						throw new InvalidDataException("Lord Gaben wasn't nice to us :/");    					var typeMember = bitstream.ReadProtobufVarInt();  					desc = bitstream.ReadProtobufVarInt();  					wireType = desc & 7;  					fieldnum = desc >> 3;    					if (fieldnum != (typeMember + 1))  						throw new InvalidDataException("Lord Gaben wasn't nice to us :/ (srsly wtf!?)");    					switch (typeMember) {  					case 1: // string  						if (wireType != 2)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufString());  						break;  					case 2: // float  						if (wireType != 5)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadFloat());  						break;  					case 3: // long  					case 4: // short  					case 5: // byte  						if (wireType != 0)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufVarInt());  						break;  					case 6: // bool  						if (wireType != 0)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufVarInt() != 0);  						break;  					default:  						throw new InvalidDataException("Looks like they introduced a new type");  					}    					if (!bitstream.ChunkFinished)  						throw new InvalidDataException("Lord Gaben tricked us! D:");    					bitstream.EndChunk();  				} else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo,GameEvent,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\GameEvent.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;  				if ((wireType == 2) && (fieldnum == 1)) {  					EventName = bitstream.ReadProtobufString();  				} else if ((wireType == 0) && (fieldnum == 2)) {  					EventId = bitstream.ReadProtobufVarInt();  				} else if ((wireType == 2) && (fieldnum == 3)) {  					bitstream.BeginChunk(bitstream.ReadProtobufVarInt() * 8);  					/*  					 * Hope and pray that gaben is once again nice to us and  					 * sends 'type' first' then the respective member' then NOTHING.  					 */  					desc = bitstream.ReadProtobufVarInt();  					wireType = desc & 7;  					fieldnum = desc >> 3;  					if ((wireType != 0) || (fieldnum != 1))  						throw new InvalidDataException("Lord Gaben wasn't nice to us :/");    					var typeMember = bitstream.ReadProtobufVarInt();  					desc = bitstream.ReadProtobufVarInt();  					wireType = desc & 7;  					fieldnum = desc >> 3;    					if (fieldnum != (typeMember + 1))  						throw new InvalidDataException("Lord Gaben wasn't nice to us :/ (srsly wtf!?)");    					switch (typeMember) {  					case 1: // string  						if (wireType != 2)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufString());  						break;  					case 2: // float  						if (wireType != 5)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadFloat());  						break;  					case 3: // long  					case 4: // short  					case 5: // byte  						if (wireType != 0)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufVarInt());  						break;  					case 6: // bool  						if (wireType != 0)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufVarInt() != 0);  						break;  					default:  						throw new InvalidDataException("Looks like they introduced a new type");  					}    					if (!bitstream.ChunkFinished)  						throw new InvalidDataException("Lord Gaben tricked us! D:");    					bitstream.EndChunk();  				} else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo,GameEvent,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\GameEvent.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;  				if ((wireType == 2) && (fieldnum == 1)) {  					EventName = bitstream.ReadProtobufString();  				} else if ((wireType == 0) && (fieldnum == 2)) {  					EventId = bitstream.ReadProtobufVarInt();  				} else if ((wireType == 2) && (fieldnum == 3)) {  					bitstream.BeginChunk(bitstream.ReadProtobufVarInt() * 8);  					/*  					 * Hope and pray that gaben is once again nice to us and  					 * sends 'type' first' then the respective member' then NOTHING.  					 */  					desc = bitstream.ReadProtobufVarInt();  					wireType = desc & 7;  					fieldnum = desc >> 3;  					if ((wireType != 0) || (fieldnum != 1))  						throw new InvalidDataException("Lord Gaben wasn't nice to us :/");    					var typeMember = bitstream.ReadProtobufVarInt();  					desc = bitstream.ReadProtobufVarInt();  					wireType = desc & 7;  					fieldnum = desc >> 3;    					if (fieldnum != (typeMember + 1))  						throw new InvalidDataException("Lord Gaben wasn't nice to us :/ (srsly wtf!?)");    					switch (typeMember) {  					case 1: // string  						if (wireType != 2)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufString());  						break;  					case 2: // float  						if (wireType != 5)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadFloat());  						break;  					case 3: // long  					case 4: // short  					case 5: // byte  						if (wireType != 0)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufVarInt());  						break;  					case 6: // bool  						if (wireType != 0)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufVarInt() != 0);  						break;  					default:  						throw new InvalidDataException("Looks like they introduced a new type");  					}    					if (!bitstream.ChunkFinished)  						throw new InvalidDataException("Lord Gaben tricked us! D:");    					bitstream.EndChunk();  				} else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo,GameEvent,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\GameEvent.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;  				if ((wireType == 2) && (fieldnum == 1)) {  					EventName = bitstream.ReadProtobufString();  				} else if ((wireType == 0) && (fieldnum == 2)) {  					EventId = bitstream.ReadProtobufVarInt();  				} else if ((wireType == 2) && (fieldnum == 3)) {  					bitstream.BeginChunk(bitstream.ReadProtobufVarInt() * 8);  					/*  					 * Hope and pray that gaben is once again nice to us and  					 * sends 'type' first' then the respective member' then NOTHING.  					 */  					desc = bitstream.ReadProtobufVarInt();  					wireType = desc & 7;  					fieldnum = desc >> 3;  					if ((wireType != 0) || (fieldnum != 1))  						throw new InvalidDataException("Lord Gaben wasn't nice to us :/");    					var typeMember = bitstream.ReadProtobufVarInt();  					desc = bitstream.ReadProtobufVarInt();  					wireType = desc & 7;  					fieldnum = desc >> 3;    					if (fieldnum != (typeMember + 1))  						throw new InvalidDataException("Lord Gaben wasn't nice to us :/ (srsly wtf!?)");    					switch (typeMember) {  					case 1: // string  						if (wireType != 2)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufString());  						break;  					case 2: // float  						if (wireType != 5)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadFloat());  						break;  					case 3: // long  					case 4: // short  					case 5: // byte  						if (wireType != 0)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufVarInt());  						break;  					case 6: // bool  						if (wireType != 0)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufVarInt() != 0);  						break;  					default:  						throw new InvalidDataException("Looks like they introduced a new type");  					}    					if (!bitstream.ChunkFinished)  						throw new InvalidDataException("Lord Gaben tricked us! D:");    					bitstream.EndChunk();  				} else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo,GameEvent,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\GameEvent.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;  				if ((wireType == 2) && (fieldnum == 1)) {  					EventName = bitstream.ReadProtobufString();  				} else if ((wireType == 0) && (fieldnum == 2)) {  					EventId = bitstream.ReadProtobufVarInt();  				} else if ((wireType == 2) && (fieldnum == 3)) {  					bitstream.BeginChunk(bitstream.ReadProtobufVarInt() * 8);  					/*  					 * Hope and pray that gaben is once again nice to us and  					 * sends 'type' first' then the respective member' then NOTHING.  					 */  					desc = bitstream.ReadProtobufVarInt();  					wireType = desc & 7;  					fieldnum = desc >> 3;  					if ((wireType != 0) || (fieldnum != 1))  						throw new InvalidDataException("Lord Gaben wasn't nice to us :/");    					var typeMember = bitstream.ReadProtobufVarInt();  					desc = bitstream.ReadProtobufVarInt();  					wireType = desc & 7;  					fieldnum = desc >> 3;    					if (fieldnum != (typeMember + 1))  						throw new InvalidDataException("Lord Gaben wasn't nice to us :/ (srsly wtf!?)");    					switch (typeMember) {  					case 1: // string  						if (wireType != 2)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufString());  						break;  					case 2: // float  						if (wireType != 5)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadFloat());  						break;  					case 3: // long  					case 4: // short  					case 5: // byte  						if (wireType != 0)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufVarInt());  						break;  					case 6: // bool  						if (wireType != 0)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufVarInt() != 0);  						break;  					default:  						throw new InvalidDataException("Looks like they introduced a new type");  					}    					if (!bitstream.ChunkFinished)  						throw new InvalidDataException("Lord Gaben tricked us! D:");    					bitstream.EndChunk();  				} else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo,GameEvent,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\GameEvent.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;  				if ((wireType == 2) && (fieldnum == 1)) {  					EventName = bitstream.ReadProtobufString();  				} else if ((wireType == 0) && (fieldnum == 2)) {  					EventId = bitstream.ReadProtobufVarInt();  				} else if ((wireType == 2) && (fieldnum == 3)) {  					bitstream.BeginChunk(bitstream.ReadProtobufVarInt() * 8);  					/*  					 * Hope and pray that gaben is once again nice to us and  					 * sends 'type' first' then the respective member' then NOTHING.  					 */  					desc = bitstream.ReadProtobufVarInt();  					wireType = desc & 7;  					fieldnum = desc >> 3;  					if ((wireType != 0) || (fieldnum != 1))  						throw new InvalidDataException("Lord Gaben wasn't nice to us :/");    					var typeMember = bitstream.ReadProtobufVarInt();  					desc = bitstream.ReadProtobufVarInt();  					wireType = desc & 7;  					fieldnum = desc >> 3;    					if (fieldnum != (typeMember + 1))  						throw new InvalidDataException("Lord Gaben wasn't nice to us :/ (srsly wtf!?)");    					switch (typeMember) {  					case 1: // string  						if (wireType != 2)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufString());  						break;  					case 2: // float  						if (wireType != 5)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadFloat());  						break;  					case 3: // long  					case 4: // short  					case 5: // byte  						if (wireType != 0)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufVarInt());  						break;  					case 6: // bool  						if (wireType != 0)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufVarInt() != 0);  						break;  					default:  						throw new InvalidDataException("Looks like they introduced a new type");  					}    					if (!bitstream.ChunkFinished)  						throw new InvalidDataException("Lord Gaben tricked us! D:");    					bitstream.EndChunk();  				} else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo,GameEvent,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\GameEvent.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;  				if ((wireType == 2) && (fieldnum == 1)) {  					EventName = bitstream.ReadProtobufString();  				} else if ((wireType == 0) && (fieldnum == 2)) {  					EventId = bitstream.ReadProtobufVarInt();  				} else if ((wireType == 2) && (fieldnum == 3)) {  					bitstream.BeginChunk(bitstream.ReadProtobufVarInt() * 8);  					/*  					 * Hope and pray that gaben is once again nice to us and  					 * sends 'type' first' then the respective member' then NOTHING.  					 */  					desc = bitstream.ReadProtobufVarInt();  					wireType = desc & 7;  					fieldnum = desc >> 3;  					if ((wireType != 0) || (fieldnum != 1))  						throw new InvalidDataException("Lord Gaben wasn't nice to us :/");    					var typeMember = bitstream.ReadProtobufVarInt();  					desc = bitstream.ReadProtobufVarInt();  					wireType = desc & 7;  					fieldnum = desc >> 3;    					if (fieldnum != (typeMember + 1))  						throw new InvalidDataException("Lord Gaben wasn't nice to us :/ (srsly wtf!?)");    					switch (typeMember) {  					case 1: // string  						if (wireType != 2)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufString());  						break;  					case 2: // float  						if (wireType != 5)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadFloat());  						break;  					case 3: // long  					case 4: // short  					case 5: // byte  						if (wireType != 0)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufVarInt());  						break;  					case 6: // bool  						if (wireType != 0)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufVarInt() != 0);  						break;  					default:  						throw new InvalidDataException("Looks like they introduced a new type");  					}    					if (!bitstream.ChunkFinished)  						throw new InvalidDataException("Lord Gaben tricked us! D:");    					bitstream.EndChunk();  				} else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo,GameEvent,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\GameEvent.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;  				if ((wireType == 2) && (fieldnum == 1)) {  					EventName = bitstream.ReadProtobufString();  				} else if ((wireType == 0) && (fieldnum == 2)) {  					EventId = bitstream.ReadProtobufVarInt();  				} else if ((wireType == 2) && (fieldnum == 3)) {  					bitstream.BeginChunk(bitstream.ReadProtobufVarInt() * 8);  					/*  					 * Hope and pray that gaben is once again nice to us and  					 * sends 'type' first' then the respective member' then NOTHING.  					 */  					desc = bitstream.ReadProtobufVarInt();  					wireType = desc & 7;  					fieldnum = desc >> 3;  					if ((wireType != 0) || (fieldnum != 1))  						throw new InvalidDataException("Lord Gaben wasn't nice to us :/");    					var typeMember = bitstream.ReadProtobufVarInt();  					desc = bitstream.ReadProtobufVarInt();  					wireType = desc & 7;  					fieldnum = desc >> 3;    					if (fieldnum != (typeMember + 1))  						throw new InvalidDataException("Lord Gaben wasn't nice to us :/ (srsly wtf!?)");    					switch (typeMember) {  					case 1: // string  						if (wireType != 2)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufString());  						break;  					case 2: // float  						if (wireType != 5)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadFloat());  						break;  					case 3: // long  					case 4: // short  					case 5: // byte  						if (wireType != 0)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufVarInt());  						break;  					case 6: // bool  						if (wireType != 0)  							throw new InvalidDataException("proto definition differs");  						Keys.Add(bitstream.ReadProtobufVarInt() != 0);  						break;  					default:  						throw new InvalidDataException("Looks like they introduced a new type");  					}    					if (!bitstream.ChunkFinished)  						throw new InvalidDataException("Lord Gaben tricked us! D:");    					bitstream.EndChunk();  				} else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo,CreateStringTable,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\CreateStringTable.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 2) {  					if (fieldnum == 1) {  						Name = bitstream.ReadProtobufString();  						continue;  					} else if (fieldnum == 8) {  						// String data is special.  						// We'll simply hope that gaben is nice and sends  						// string_data last' just like he should.  						var len = bitstream.ReadProtobufVarInt();  						bitstream.BeginChunk(len * 8);  						DemoInfo.DP.Handler.CreateStringTableUserInfoHandler.Apply(this' bitstream' parser);  						bitstream.EndChunk();  						if (!bitstream.ChunkFinished)  							throw new NotImplementedException("Lord Gaben wasn't nice to us :/");  						break;  					} else  						throw new InvalidDataException("yes I know we should drop this but we" +  							"probably want to know that they added a new big field");  				}    				if (wireType != 0)  					throw new InvalidDataException();    				var val = bitstream.ReadProtobufVarInt();    				switch (fieldnum) {  				case 2:  					MaxEntries = val;  					break;  				case 3:  					NumEntries = val;  					break;  				case 4:  					_UserDataFixedSize = val;  					break;  				case 5:  					UserDataSize = val;  					break;  				case 6:  					UserDataSizeBits = val;  					break;  				case 7:  					Flags = val;  					break;  				default:  					// silently drop  					break;  				}  			}
Magic Number,DemoInfo,CreateStringTable,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\CreateStringTable.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 2) {  					if (fieldnum == 1) {  						Name = bitstream.ReadProtobufString();  						continue;  					} else if (fieldnum == 8) {  						// String data is special.  						// We'll simply hope that gaben is nice and sends  						// string_data last' just like he should.  						var len = bitstream.ReadProtobufVarInt();  						bitstream.BeginChunk(len * 8);  						DemoInfo.DP.Handler.CreateStringTableUserInfoHandler.Apply(this' bitstream' parser);  						bitstream.EndChunk();  						if (!bitstream.ChunkFinished)  							throw new NotImplementedException("Lord Gaben wasn't nice to us :/");  						break;  					} else  						throw new InvalidDataException("yes I know we should drop this but we" +  							"probably want to know that they added a new big field");  				}    				if (wireType != 0)  					throw new InvalidDataException();    				var val = bitstream.ReadProtobufVarInt();    				switch (fieldnum) {  				case 2:  					MaxEntries = val;  					break;  				case 3:  					NumEntries = val;  					break;  				case 4:  					_UserDataFixedSize = val;  					break;  				case 5:  					UserDataSize = val;  					break;  				case 6:  					UserDataSizeBits = val;  					break;  				case 7:  					Flags = val;  					break;  				default:  					// silently drop  					break;  				}  			}
Magic Number,DemoInfo,CreateStringTable,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\CreateStringTable.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 2) {  					if (fieldnum == 1) {  						Name = bitstream.ReadProtobufString();  						continue;  					} else if (fieldnum == 8) {  						// String data is special.  						// We'll simply hope that gaben is nice and sends  						// string_data last' just like he should.  						var len = bitstream.ReadProtobufVarInt();  						bitstream.BeginChunk(len * 8);  						DemoInfo.DP.Handler.CreateStringTableUserInfoHandler.Apply(this' bitstream' parser);  						bitstream.EndChunk();  						if (!bitstream.ChunkFinished)  							throw new NotImplementedException("Lord Gaben wasn't nice to us :/");  						break;  					} else  						throw new InvalidDataException("yes I know we should drop this but we" +  							"probably want to know that they added a new big field");  				}    				if (wireType != 0)  					throw new InvalidDataException();    				var val = bitstream.ReadProtobufVarInt();    				switch (fieldnum) {  				case 2:  					MaxEntries = val;  					break;  				case 3:  					NumEntries = val;  					break;  				case 4:  					_UserDataFixedSize = val;  					break;  				case 5:  					UserDataSize = val;  					break;  				case 6:  					UserDataSizeBits = val;  					break;  				case 7:  					Flags = val;  					break;  				default:  					// silently drop  					break;  				}  			}
Magic Number,DemoInfo,CreateStringTable,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\CreateStringTable.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 2) {  					if (fieldnum == 1) {  						Name = bitstream.ReadProtobufString();  						continue;  					} else if (fieldnum == 8) {  						// String data is special.  						// We'll simply hope that gaben is nice and sends  						// string_data last' just like he should.  						var len = bitstream.ReadProtobufVarInt();  						bitstream.BeginChunk(len * 8);  						DemoInfo.DP.Handler.CreateStringTableUserInfoHandler.Apply(this' bitstream' parser);  						bitstream.EndChunk();  						if (!bitstream.ChunkFinished)  							throw new NotImplementedException("Lord Gaben wasn't nice to us :/");  						break;  					} else  						throw new InvalidDataException("yes I know we should drop this but we" +  							"probably want to know that they added a new big field");  				}    				if (wireType != 0)  					throw new InvalidDataException();    				var val = bitstream.ReadProtobufVarInt();    				switch (fieldnum) {  				case 2:  					MaxEntries = val;  					break;  				case 3:  					NumEntries = val;  					break;  				case 4:  					_UserDataFixedSize = val;  					break;  				case 5:  					UserDataSize = val;  					break;  				case 6:  					UserDataSizeBits = val;  					break;  				case 7:  					Flags = val;  					break;  				default:  					// silently drop  					break;  				}  			}
Magic Number,DemoInfo,CreateStringTable,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\CreateStringTable.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 2) {  					if (fieldnum == 1) {  						Name = bitstream.ReadProtobufString();  						continue;  					} else if (fieldnum == 8) {  						// String data is special.  						// We'll simply hope that gaben is nice and sends  						// string_data last' just like he should.  						var len = bitstream.ReadProtobufVarInt();  						bitstream.BeginChunk(len * 8);  						DemoInfo.DP.Handler.CreateStringTableUserInfoHandler.Apply(this' bitstream' parser);  						bitstream.EndChunk();  						if (!bitstream.ChunkFinished)  							throw new NotImplementedException("Lord Gaben wasn't nice to us :/");  						break;  					} else  						throw new InvalidDataException("yes I know we should drop this but we" +  							"probably want to know that they added a new big field");  				}    				if (wireType != 0)  					throw new InvalidDataException();    				var val = bitstream.ReadProtobufVarInt();    				switch (fieldnum) {  				case 2:  					MaxEntries = val;  					break;  				case 3:  					NumEntries = val;  					break;  				case 4:  					_UserDataFixedSize = val;  					break;  				case 5:  					UserDataSize = val;  					break;  				case 6:  					UserDataSizeBits = val;  					break;  				case 7:  					Flags = val;  					break;  				default:  					// silently drop  					break;  				}  			}
Magic Number,DemoInfo,CreateStringTable,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\CreateStringTable.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 2) {  					if (fieldnum == 1) {  						Name = bitstream.ReadProtobufString();  						continue;  					} else if (fieldnum == 8) {  						// String data is special.  						// We'll simply hope that gaben is nice and sends  						// string_data last' just like he should.  						var len = bitstream.ReadProtobufVarInt();  						bitstream.BeginChunk(len * 8);  						DemoInfo.DP.Handler.CreateStringTableUserInfoHandler.Apply(this' bitstream' parser);  						bitstream.EndChunk();  						if (!bitstream.ChunkFinished)  							throw new NotImplementedException("Lord Gaben wasn't nice to us :/");  						break;  					} else  						throw new InvalidDataException("yes I know we should drop this but we" +  							"probably want to know that they added a new big field");  				}    				if (wireType != 0)  					throw new InvalidDataException();    				var val = bitstream.ReadProtobufVarInt();    				switch (fieldnum) {  				case 2:  					MaxEntries = val;  					break;  				case 3:  					NumEntries = val;  					break;  				case 4:  					_UserDataFixedSize = val;  					break;  				case 5:  					UserDataSize = val;  					break;  				case 6:  					UserDataSizeBits = val;  					break;  				case 7:  					Flags = val;  					break;  				default:  					// silently drop  					break;  				}  			}
Magic Number,DemoInfo,CreateStringTable,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\CreateStringTable.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 2) {  					if (fieldnum == 1) {  						Name = bitstream.ReadProtobufString();  						continue;  					} else if (fieldnum == 8) {  						// String data is special.  						// We'll simply hope that gaben is nice and sends  						// string_data last' just like he should.  						var len = bitstream.ReadProtobufVarInt();  						bitstream.BeginChunk(len * 8);  						DemoInfo.DP.Handler.CreateStringTableUserInfoHandler.Apply(this' bitstream' parser);  						bitstream.EndChunk();  						if (!bitstream.ChunkFinished)  							throw new NotImplementedException("Lord Gaben wasn't nice to us :/");  						break;  					} else  						throw new InvalidDataException("yes I know we should drop this but we" +  							"probably want to know that they added a new big field");  				}    				if (wireType != 0)  					throw new InvalidDataException();    				var val = bitstream.ReadProtobufVarInt();    				switch (fieldnum) {  				case 2:  					MaxEntries = val;  					break;  				case 3:  					NumEntries = val;  					break;  				case 4:  					_UserDataFixedSize = val;  					break;  				case 5:  					UserDataSize = val;  					break;  				case 6:  					UserDataSizeBits = val;  					break;  				case 7:  					Flags = val;  					break;  				default:  					// silently drop  					break;  				}  			}
Magic Number,DemoInfo,CreateStringTable,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\CreateStringTable.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 2) {  					if (fieldnum == 1) {  						Name = bitstream.ReadProtobufString();  						continue;  					} else if (fieldnum == 8) {  						// String data is special.  						// We'll simply hope that gaben is nice and sends  						// string_data last' just like he should.  						var len = bitstream.ReadProtobufVarInt();  						bitstream.BeginChunk(len * 8);  						DemoInfo.DP.Handler.CreateStringTableUserInfoHandler.Apply(this' bitstream' parser);  						bitstream.EndChunk();  						if (!bitstream.ChunkFinished)  							throw new NotImplementedException("Lord Gaben wasn't nice to us :/");  						break;  					} else  						throw new InvalidDataException("yes I know we should drop this but we" +  							"probably want to know that they added a new big field");  				}    				if (wireType != 0)  					throw new InvalidDataException();    				var val = bitstream.ReadProtobufVarInt();    				switch (fieldnum) {  				case 2:  					MaxEntries = val;  					break;  				case 3:  					NumEntries = val;  					break;  				case 4:  					_UserDataFixedSize = val;  					break;  				case 5:  					UserDataSize = val;  					break;  				case 6:  					UserDataSizeBits = val;  					break;  				case 7:  					Flags = val;  					break;  				default:  					// silently drop  					break;  				}  			}
Magic Number,DemoInfo,CreateStringTable,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\CreateStringTable.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 2) {  					if (fieldnum == 1) {  						Name = bitstream.ReadProtobufString();  						continue;  					} else if (fieldnum == 8) {  						// String data is special.  						// We'll simply hope that gaben is nice and sends  						// string_data last' just like he should.  						var len = bitstream.ReadProtobufVarInt();  						bitstream.BeginChunk(len * 8);  						DemoInfo.DP.Handler.CreateStringTableUserInfoHandler.Apply(this' bitstream' parser);  						bitstream.EndChunk();  						if (!bitstream.ChunkFinished)  							throw new NotImplementedException("Lord Gaben wasn't nice to us :/");  						break;  					} else  						throw new InvalidDataException("yes I know we should drop this but we" +  							"probably want to know that they added a new big field");  				}    				if (wireType != 0)  					throw new InvalidDataException();    				var val = bitstream.ReadProtobufVarInt();    				switch (fieldnum) {  				case 2:  					MaxEntries = val;  					break;  				case 3:  					NumEntries = val;  					break;  				case 4:  					_UserDataFixedSize = val;  					break;  				case 5:  					UserDataSize = val;  					break;  				case 6:  					UserDataSizeBits = val;  					break;  				case 7:  					Flags = val;  					break;  				default:  					// silently drop  					break;  				}  			}
Magic Number,DemoInfo,CreateStringTable,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\CreateStringTable.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 2) {  					if (fieldnum == 1) {  						Name = bitstream.ReadProtobufString();  						continue;  					} else if (fieldnum == 8) {  						// String data is special.  						// We'll simply hope that gaben is nice and sends  						// string_data last' just like he should.  						var len = bitstream.ReadProtobufVarInt();  						bitstream.BeginChunk(len * 8);  						DemoInfo.DP.Handler.CreateStringTableUserInfoHandler.Apply(this' bitstream' parser);  						bitstream.EndChunk();  						if (!bitstream.ChunkFinished)  							throw new NotImplementedException("Lord Gaben wasn't nice to us :/");  						break;  					} else  						throw new InvalidDataException("yes I know we should drop this but we" +  							"probably want to know that they added a new big field");  				}    				if (wireType != 0)  					throw new InvalidDataException();    				var val = bitstream.ReadProtobufVarInt();    				switch (fieldnum) {  				case 2:  					MaxEntries = val;  					break;  				case 3:  					NumEntries = val;  					break;  				case 4:  					_UserDataFixedSize = val;  					break;  				case 5:  					UserDataSize = val;  					break;  				case 6:  					UserDataSizeBits = val;  					break;  				case 7:  					Flags = val;  					break;  				default:  					// silently drop  					break;  				}  			}
Magic Number,DemoInfo,CreateStringTable,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\CreateStringTable.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 2) {  					if (fieldnum == 1) {  						Name = bitstream.ReadProtobufString();  						continue;  					} else if (fieldnum == 8) {  						// String data is special.  						// We'll simply hope that gaben is nice and sends  						// string_data last' just like he should.  						var len = bitstream.ReadProtobufVarInt();  						bitstream.BeginChunk(len * 8);  						DemoInfo.DP.Handler.CreateStringTableUserInfoHandler.Apply(this' bitstream' parser);  						bitstream.EndChunk();  						if (!bitstream.ChunkFinished)  							throw new NotImplementedException("Lord Gaben wasn't nice to us :/");  						break;  					} else  						throw new InvalidDataException("yes I know we should drop this but we" +  							"probably want to know that they added a new big field");  				}    				if (wireType != 0)  					throw new InvalidDataException();    				var val = bitstream.ReadProtobufVarInt();    				switch (fieldnum) {  				case 2:  					MaxEntries = val;  					break;  				case 3:  					NumEntries = val;  					break;  				case 4:  					_UserDataFixedSize = val;  					break;  				case 5:  					UserDataSize = val;  					break;  				case 6:  					UserDataSizeBits = val;  					break;  				case 7:  					Flags = val;  					break;  				default:  					// silently drop  					break;  				}  			}
Magic Number,DemoInfo,UpdateStringTable,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\UpdateStringTable.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if ((wireType == 2) && (fieldnum == 3)) {  					// String data is special.  					// We'll simply hope that gaben is nice and sends  					// string_data last' just like he should.  					var len = bitstream.ReadProtobufVarInt();  					bitstream.BeginChunk(len * 8);  					DemoInfo.DP.Handler.UpdateStringTableUserInfoHandler.Apply(this' bitstream' parser);  					bitstream.EndChunk();  					if (!bitstream.ChunkFinished)  						throw new NotImplementedException("Lord Gaben wasn't nice to us :/");  					break;  				}    				if (wireType != 0)  					throw new InvalidDataException();    				var val = bitstream.ReadProtobufVarInt();    				switch (fieldnum) {  				case 1:  					TableId = val;  					break;  				case 2:  					NumChangedEntries = val;  					break;  				default:  					// silently drop  					break;  				}  			}
Magic Number,DemoInfo,UpdateStringTable,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\UpdateStringTable.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if ((wireType == 2) && (fieldnum == 3)) {  					// String data is special.  					// We'll simply hope that gaben is nice and sends  					// string_data last' just like he should.  					var len = bitstream.ReadProtobufVarInt();  					bitstream.BeginChunk(len * 8);  					DemoInfo.DP.Handler.UpdateStringTableUserInfoHandler.Apply(this' bitstream' parser);  					bitstream.EndChunk();  					if (!bitstream.ChunkFinished)  						throw new NotImplementedException("Lord Gaben wasn't nice to us :/");  					break;  				}    				if (wireType != 0)  					throw new InvalidDataException();    				var val = bitstream.ReadProtobufVarInt();    				switch (fieldnum) {  				case 1:  					TableId = val;  					break;  				case 2:  					NumChangedEntries = val;  					break;  				default:  					// silently drop  					break;  				}  			}
Magic Number,DemoInfo,UpdateStringTable,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\UpdateStringTable.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if ((wireType == 2) && (fieldnum == 3)) {  					// String data is special.  					// We'll simply hope that gaben is nice and sends  					// string_data last' just like he should.  					var len = bitstream.ReadProtobufVarInt();  					bitstream.BeginChunk(len * 8);  					DemoInfo.DP.Handler.UpdateStringTableUserInfoHandler.Apply(this' bitstream' parser);  					bitstream.EndChunk();  					if (!bitstream.ChunkFinished)  						throw new NotImplementedException("Lord Gaben wasn't nice to us :/");  					break;  				}    				if (wireType != 0)  					throw new InvalidDataException();    				var val = bitstream.ReadProtobufVarInt();    				switch (fieldnum) {  				case 1:  					TableId = val;  					break;  				case 2:  					NumChangedEntries = val;  					break;  				default:  					// silently drop  					break;  				}  			}
Magic Number,DemoInfo,UpdateStringTable,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\UpdateStringTable.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if ((wireType == 2) && (fieldnum == 3)) {  					// String data is special.  					// We'll simply hope that gaben is nice and sends  					// string_data last' just like he should.  					var len = bitstream.ReadProtobufVarInt();  					bitstream.BeginChunk(len * 8);  					DemoInfo.DP.Handler.UpdateStringTableUserInfoHandler.Apply(this' bitstream' parser);  					bitstream.EndChunk();  					if (!bitstream.ChunkFinished)  						throw new NotImplementedException("Lord Gaben wasn't nice to us :/");  					break;  				}    				if (wireType != 0)  					throw new InvalidDataException();    				var val = bitstream.ReadProtobufVarInt();    				switch (fieldnum) {  				case 1:  					TableId = val;  					break;  				case 2:  					NumChangedEntries = val;  					break;  				default:  					// silently drop  					break;  				}  			}
Magic Number,DemoInfo,UpdateStringTable,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\UpdateStringTable.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if ((wireType == 2) && (fieldnum == 3)) {  					// String data is special.  					// We'll simply hope that gaben is nice and sends  					// string_data last' just like he should.  					var len = bitstream.ReadProtobufVarInt();  					bitstream.BeginChunk(len * 8);  					DemoInfo.DP.Handler.UpdateStringTableUserInfoHandler.Apply(this' bitstream' parser);  					bitstream.EndChunk();  					if (!bitstream.ChunkFinished)  						throw new NotImplementedException("Lord Gaben wasn't nice to us :/");  					break;  				}    				if (wireType != 0)  					throw new InvalidDataException();    				var val = bitstream.ReadProtobufVarInt();    				switch (fieldnum) {  				case 1:  					TableId = val;  					break;  				case 2:  					NumChangedEntries = val;  					break;  				default:  					// silently drop  					break;  				}  			}
Magic Number,DemoInfo,UpdateStringTable,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\UpdateStringTable.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if ((wireType == 2) && (fieldnum == 3)) {  					// String data is special.  					// We'll simply hope that gaben is nice and sends  					// string_data last' just like he should.  					var len = bitstream.ReadProtobufVarInt();  					bitstream.BeginChunk(len * 8);  					DemoInfo.DP.Handler.UpdateStringTableUserInfoHandler.Apply(this' bitstream' parser);  					bitstream.EndChunk();  					if (!bitstream.ChunkFinished)  						throw new NotImplementedException("Lord Gaben wasn't nice to us :/");  					break;  				}    				if (wireType != 0)  					throw new InvalidDataException();    				var val = bitstream.ReadProtobufVarInt();    				switch (fieldnum) {  				case 1:  					TableId = val;  					break;  				case 2:  					NumChangedEntries = val;  					break;  				default:  					// silently drop  					break;  				}  			}
Magic Number,DemoInfo,SendTable,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\SendTable.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 2) {  					if (fieldnum == 2) {  						NetTableName = bitstream.ReadProtobufString();  					} else if (fieldnum == 4) {  						// Props are special.  						// We'll simply hope that gaben is nice and sends  						// props last' just like he should.  						var len = bitstream.ReadProtobufVarInt();  						bitstream.BeginChunk(len * 8);  						var sendprop = new SendProp();  						sendprop.Parse(bitstream);  						sendprops.Add(sendprop);  						bitstream.EndChunk();  					} else  						throw new InvalidDataException("yes I know we should drop this" +  							"but we probably want to know that they added a new big field");  				} else if (wireType == 0) {  					var val = bitstream.ReadProtobufVarInt();    					switch (fieldnum) {  					case 1:  						_IsEnd = val;  						break;  					case 3:  						_NeedsDecoder = val;  						break;  					default:  						// silently drop  						break;  					}  				} else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo,SendTable,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\SendTable.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 2) {  					if (fieldnum == 2) {  						NetTableName = bitstream.ReadProtobufString();  					} else if (fieldnum == 4) {  						// Props are special.  						// We'll simply hope that gaben is nice and sends  						// props last' just like he should.  						var len = bitstream.ReadProtobufVarInt();  						bitstream.BeginChunk(len * 8);  						var sendprop = new SendProp();  						sendprop.Parse(bitstream);  						sendprops.Add(sendprop);  						bitstream.EndChunk();  					} else  						throw new InvalidDataException("yes I know we should drop this" +  							"but we probably want to know that they added a new big field");  				} else if (wireType == 0) {  					var val = bitstream.ReadProtobufVarInt();    					switch (fieldnum) {  					case 1:  						_IsEnd = val;  						break;  					case 3:  						_NeedsDecoder = val;  						break;  					default:  						// silently drop  						break;  					}  				} else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo,SendTable,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\SendTable.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 2) {  					if (fieldnum == 2) {  						NetTableName = bitstream.ReadProtobufString();  					} else if (fieldnum == 4) {  						// Props are special.  						// We'll simply hope that gaben is nice and sends  						// props last' just like he should.  						var len = bitstream.ReadProtobufVarInt();  						bitstream.BeginChunk(len * 8);  						var sendprop = new SendProp();  						sendprop.Parse(bitstream);  						sendprops.Add(sendprop);  						bitstream.EndChunk();  					} else  						throw new InvalidDataException("yes I know we should drop this" +  							"but we probably want to know that they added a new big field");  				} else if (wireType == 0) {  					var val = bitstream.ReadProtobufVarInt();    					switch (fieldnum) {  					case 1:  						_IsEnd = val;  						break;  					case 3:  						_NeedsDecoder = val;  						break;  					default:  						// silently drop  						break;  					}  				} else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo,SendTable,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\SendTable.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 2) {  					if (fieldnum == 2) {  						NetTableName = bitstream.ReadProtobufString();  					} else if (fieldnum == 4) {  						// Props are special.  						// We'll simply hope that gaben is nice and sends  						// props last' just like he should.  						var len = bitstream.ReadProtobufVarInt();  						bitstream.BeginChunk(len * 8);  						var sendprop = new SendProp();  						sendprop.Parse(bitstream);  						sendprops.Add(sendprop);  						bitstream.EndChunk();  					} else  						throw new InvalidDataException("yes I know we should drop this" +  							"but we probably want to know that they added a new big field");  				} else if (wireType == 0) {  					var val = bitstream.ReadProtobufVarInt();    					switch (fieldnum) {  					case 1:  						_IsEnd = val;  						break;  					case 3:  						_NeedsDecoder = val;  						break;  					default:  						// silently drop  						break;  					}  				} else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo,SendTable,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\SendTable.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 2) {  					if (fieldnum == 2) {  						NetTableName = bitstream.ReadProtobufString();  					} else if (fieldnum == 4) {  						// Props are special.  						// We'll simply hope that gaben is nice and sends  						// props last' just like he should.  						var len = bitstream.ReadProtobufVarInt();  						bitstream.BeginChunk(len * 8);  						var sendprop = new SendProp();  						sendprop.Parse(bitstream);  						sendprops.Add(sendprop);  						bitstream.EndChunk();  					} else  						throw new InvalidDataException("yes I know we should drop this" +  							"but we probably want to know that they added a new big field");  				} else if (wireType == 0) {  					var val = bitstream.ReadProtobufVarInt();    					switch (fieldnum) {  					case 1:  						_IsEnd = val;  						break;  					case 3:  						_NeedsDecoder = val;  						break;  					default:  						// silently drop  						break;  					}  				} else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo,SendTable,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\SendTable.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 2) {  					if (fieldnum == 2) {  						NetTableName = bitstream.ReadProtobufString();  					} else if (fieldnum == 4) {  						// Props are special.  						// We'll simply hope that gaben is nice and sends  						// props last' just like he should.  						var len = bitstream.ReadProtobufVarInt();  						bitstream.BeginChunk(len * 8);  						var sendprop = new SendProp();  						sendprop.Parse(bitstream);  						sendprops.Add(sendprop);  						bitstream.EndChunk();  					} else  						throw new InvalidDataException("yes I know we should drop this" +  							"but we probably want to know that they added a new big field");  				} else if (wireType == 0) {  					var val = bitstream.ReadProtobufVarInt();    					switch (fieldnum) {  					case 1:  						_IsEnd = val;  						break;  					case 3:  						_NeedsDecoder = val;  						break;  					default:  						// silently drop  						break;  					}  				} else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo,SendTable,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\SendTable.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 2) {  					if (fieldnum == 2) {  						NetTableName = bitstream.ReadProtobufString();  					} else if (fieldnum == 4) {  						// Props are special.  						// We'll simply hope that gaben is nice and sends  						// props last' just like he should.  						var len = bitstream.ReadProtobufVarInt();  						bitstream.BeginChunk(len * 8);  						var sendprop = new SendProp();  						sendprop.Parse(bitstream);  						sendprops.Add(sendprop);  						bitstream.EndChunk();  					} else  						throw new InvalidDataException("yes I know we should drop this" +  							"but we probably want to know that they added a new big field");  				} else if (wireType == 0) {  					var val = bitstream.ReadProtobufVarInt();    					switch (fieldnum) {  					case 1:  						_IsEnd = val;  						break;  					case 3:  						_NeedsDecoder = val;  						break;  					default:  						// silently drop  						break;  					}  				} else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo,SendProp,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\SendTable.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  					var desc = bitstream.ReadProtobufVarInt();  					var wireType = desc & 7;  					var fieldnum = desc >> 3;    					if (wireType == 2) {  						if (fieldnum == 2) {  							VarName = bitstream.ReadProtobufString();  						} else if (fieldnum == 5) {  							DtName = bitstream.ReadProtobufString();  						} else  							throw new InvalidDataException("yes I know we should drop this but we" +  								"probably want to know that they added a new big field");  					} else if (wireType == 0) {  						var val = bitstream.ReadProtobufVarInt();    						switch (fieldnum) {  						case 1:  							Type = val;  							break;  						case 3:  							Flags = val;  							break;  						case 4:  							Priority = val;  							break;  						case 6:  							NumElements = val;  							break;  						case 9:  							NumBits = val;  							break;  						default:  							// silently drop  							break;  						}  					} else if (wireType == 5) {  						var val = bitstream.ReadFloat();    						switch (fieldnum) {  						case 7:  							LowValue = val;  							break;  						case 8:  							HighValue = val;  							break;  						default:  							// silently drop  							break;  						}  					} else  						throw new InvalidDataException();  				}
Magic Number,DemoInfo,SendProp,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\SendTable.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  					var desc = bitstream.ReadProtobufVarInt();  					var wireType = desc & 7;  					var fieldnum = desc >> 3;    					if (wireType == 2) {  						if (fieldnum == 2) {  							VarName = bitstream.ReadProtobufString();  						} else if (fieldnum == 5) {  							DtName = bitstream.ReadProtobufString();  						} else  							throw new InvalidDataException("yes I know we should drop this but we" +  								"probably want to know that they added a new big field");  					} else if (wireType == 0) {  						var val = bitstream.ReadProtobufVarInt();    						switch (fieldnum) {  						case 1:  							Type = val;  							break;  						case 3:  							Flags = val;  							break;  						case 4:  							Priority = val;  							break;  						case 6:  							NumElements = val;  							break;  						case 9:  							NumBits = val;  							break;  						default:  							// silently drop  							break;  						}  					} else if (wireType == 5) {  						var val = bitstream.ReadFloat();    						switch (fieldnum) {  						case 7:  							LowValue = val;  							break;  						case 8:  							HighValue = val;  							break;  						default:  							// silently drop  							break;  						}  					} else  						throw new InvalidDataException();  				}
Magic Number,DemoInfo,SendProp,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\SendTable.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  					var desc = bitstream.ReadProtobufVarInt();  					var wireType = desc & 7;  					var fieldnum = desc >> 3;    					if (wireType == 2) {  						if (fieldnum == 2) {  							VarName = bitstream.ReadProtobufString();  						} else if (fieldnum == 5) {  							DtName = bitstream.ReadProtobufString();  						} else  							throw new InvalidDataException("yes I know we should drop this but we" +  								"probably want to know that they added a new big field");  					} else if (wireType == 0) {  						var val = bitstream.ReadProtobufVarInt();    						switch (fieldnum) {  						case 1:  							Type = val;  							break;  						case 3:  							Flags = val;  							break;  						case 4:  							Priority = val;  							break;  						case 6:  							NumElements = val;  							break;  						case 9:  							NumBits = val;  							break;  						default:  							// silently drop  							break;  						}  					} else if (wireType == 5) {  						var val = bitstream.ReadFloat();    						switch (fieldnum) {  						case 7:  							LowValue = val;  							break;  						case 8:  							HighValue = val;  							break;  						default:  							// silently drop  							break;  						}  					} else  						throw new InvalidDataException();  				}
Magic Number,DemoInfo,SendProp,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\SendTable.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  					var desc = bitstream.ReadProtobufVarInt();  					var wireType = desc & 7;  					var fieldnum = desc >> 3;    					if (wireType == 2) {  						if (fieldnum == 2) {  							VarName = bitstream.ReadProtobufString();  						} else if (fieldnum == 5) {  							DtName = bitstream.ReadProtobufString();  						} else  							throw new InvalidDataException("yes I know we should drop this but we" +  								"probably want to know that they added a new big field");  					} else if (wireType == 0) {  						var val = bitstream.ReadProtobufVarInt();    						switch (fieldnum) {  						case 1:  							Type = val;  							break;  						case 3:  							Flags = val;  							break;  						case 4:  							Priority = val;  							break;  						case 6:  							NumElements = val;  							break;  						case 9:  							NumBits = val;  							break;  						default:  							// silently drop  							break;  						}  					} else if (wireType == 5) {  						var val = bitstream.ReadFloat();    						switch (fieldnum) {  						case 7:  							LowValue = val;  							break;  						case 8:  							HighValue = val;  							break;  						default:  							// silently drop  							break;  						}  					} else  						throw new InvalidDataException();  				}
Magic Number,DemoInfo,SendProp,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\SendTable.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  					var desc = bitstream.ReadProtobufVarInt();  					var wireType = desc & 7;  					var fieldnum = desc >> 3;    					if (wireType == 2) {  						if (fieldnum == 2) {  							VarName = bitstream.ReadProtobufString();  						} else if (fieldnum == 5) {  							DtName = bitstream.ReadProtobufString();  						} else  							throw new InvalidDataException("yes I know we should drop this but we" +  								"probably want to know that they added a new big field");  					} else if (wireType == 0) {  						var val = bitstream.ReadProtobufVarInt();    						switch (fieldnum) {  						case 1:  							Type = val;  							break;  						case 3:  							Flags = val;  							break;  						case 4:  							Priority = val;  							break;  						case 6:  							NumElements = val;  							break;  						case 9:  							NumBits = val;  							break;  						default:  							// silently drop  							break;  						}  					} else if (wireType == 5) {  						var val = bitstream.ReadFloat();    						switch (fieldnum) {  						case 7:  							LowValue = val;  							break;  						case 8:  							HighValue = val;  							break;  						default:  							// silently drop  							break;  						}  					} else  						throw new InvalidDataException();  				}
Magic Number,DemoInfo,SendProp,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\SendTable.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  					var desc = bitstream.ReadProtobufVarInt();  					var wireType = desc & 7;  					var fieldnum = desc >> 3;    					if (wireType == 2) {  						if (fieldnum == 2) {  							VarName = bitstream.ReadProtobufString();  						} else if (fieldnum == 5) {  							DtName = bitstream.ReadProtobufString();  						} else  							throw new InvalidDataException("yes I know we should drop this but we" +  								"probably want to know that they added a new big field");  					} else if (wireType == 0) {  						var val = bitstream.ReadProtobufVarInt();    						switch (fieldnum) {  						case 1:  							Type = val;  							break;  						case 3:  							Flags = val;  							break;  						case 4:  							Priority = val;  							break;  						case 6:  							NumElements = val;  							break;  						case 9:  							NumBits = val;  							break;  						default:  							// silently drop  							break;  						}  					} else if (wireType == 5) {  						var val = bitstream.ReadFloat();    						switch (fieldnum) {  						case 7:  							LowValue = val;  							break;  						case 8:  							HighValue = val;  							break;  						default:  							// silently drop  							break;  						}  					} else  						throw new InvalidDataException();  				}
Magic Number,DemoInfo,SendProp,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\SendTable.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  					var desc = bitstream.ReadProtobufVarInt();  					var wireType = desc & 7;  					var fieldnum = desc >> 3;    					if (wireType == 2) {  						if (fieldnum == 2) {  							VarName = bitstream.ReadProtobufString();  						} else if (fieldnum == 5) {  							DtName = bitstream.ReadProtobufString();  						} else  							throw new InvalidDataException("yes I know we should drop this but we" +  								"probably want to know that they added a new big field");  					} else if (wireType == 0) {  						var val = bitstream.ReadProtobufVarInt();    						switch (fieldnum) {  						case 1:  							Type = val;  							break;  						case 3:  							Flags = val;  							break;  						case 4:  							Priority = val;  							break;  						case 6:  							NumElements = val;  							break;  						case 9:  							NumBits = val;  							break;  						default:  							// silently drop  							break;  						}  					} else if (wireType == 5) {  						var val = bitstream.ReadFloat();    						switch (fieldnum) {  						case 7:  							LowValue = val;  							break;  						case 8:  							HighValue = val;  							break;  						default:  							// silently drop  							break;  						}  					} else  						throw new InvalidDataException();  				}
Magic Number,DemoInfo,SendProp,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\SendTable.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  					var desc = bitstream.ReadProtobufVarInt();  					var wireType = desc & 7;  					var fieldnum = desc >> 3;    					if (wireType == 2) {  						if (fieldnum == 2) {  							VarName = bitstream.ReadProtobufString();  						} else if (fieldnum == 5) {  							DtName = bitstream.ReadProtobufString();  						} else  							throw new InvalidDataException("yes I know we should drop this but we" +  								"probably want to know that they added a new big field");  					} else if (wireType == 0) {  						var val = bitstream.ReadProtobufVarInt();    						switch (fieldnum) {  						case 1:  							Type = val;  							break;  						case 3:  							Flags = val;  							break;  						case 4:  							Priority = val;  							break;  						case 6:  							NumElements = val;  							break;  						case 9:  							NumBits = val;  							break;  						default:  							// silently drop  							break;  						}  					} else if (wireType == 5) {  						var val = bitstream.ReadFloat();    						switch (fieldnum) {  						case 7:  							LowValue = val;  							break;  						case 8:  							HighValue = val;  							break;  						default:  							// silently drop  							break;  						}  					} else  						throw new InvalidDataException();  				}
Magic Number,DemoInfo,SendProp,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\SendTable.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  					var desc = bitstream.ReadProtobufVarInt();  					var wireType = desc & 7;  					var fieldnum = desc >> 3;    					if (wireType == 2) {  						if (fieldnum == 2) {  							VarName = bitstream.ReadProtobufString();  						} else if (fieldnum == 5) {  							DtName = bitstream.ReadProtobufString();  						} else  							throw new InvalidDataException("yes I know we should drop this but we" +  								"probably want to know that they added a new big field");  					} else if (wireType == 0) {  						var val = bitstream.ReadProtobufVarInt();    						switch (fieldnum) {  						case 1:  							Type = val;  							break;  						case 3:  							Flags = val;  							break;  						case 4:  							Priority = val;  							break;  						case 6:  							NumElements = val;  							break;  						case 9:  							NumBits = val;  							break;  						default:  							// silently drop  							break;  						}  					} else if (wireType == 5) {  						var val = bitstream.ReadFloat();    						switch (fieldnum) {  						case 7:  							LowValue = val;  							break;  						case 8:  							HighValue = val;  							break;  						default:  							// silently drop  							break;  						}  					} else  						throw new InvalidDataException();  				}
Magic Number,DemoInfo,SendProp,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\SendTable.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  					var desc = bitstream.ReadProtobufVarInt();  					var wireType = desc & 7;  					var fieldnum = desc >> 3;    					if (wireType == 2) {  						if (fieldnum == 2) {  							VarName = bitstream.ReadProtobufString();  						} else if (fieldnum == 5) {  							DtName = bitstream.ReadProtobufString();  						} else  							throw new InvalidDataException("yes I know we should drop this but we" +  								"probably want to know that they added a new big field");  					} else if (wireType == 0) {  						var val = bitstream.ReadProtobufVarInt();    						switch (fieldnum) {  						case 1:  							Type = val;  							break;  						case 3:  							Flags = val;  							break;  						case 4:  							Priority = val;  							break;  						case 6:  							NumElements = val;  							break;  						case 9:  							NumBits = val;  							break;  						default:  							// silently drop  							break;  						}  					} else if (wireType == 5) {  						var val = bitstream.ReadFloat();    						switch (fieldnum) {  						case 7:  							LowValue = val;  							break;  						case 8:  							HighValue = val;  							break;  						default:  							// silently drop  							break;  						}  					} else  						throw new InvalidDataException();  				}
Magic Number,DemoInfo,SendProp,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\SendTable.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  					var desc = bitstream.ReadProtobufVarInt();  					var wireType = desc & 7;  					var fieldnum = desc >> 3;    					if (wireType == 2) {  						if (fieldnum == 2) {  							VarName = bitstream.ReadProtobufString();  						} else if (fieldnum == 5) {  							DtName = bitstream.ReadProtobufString();  						} else  							throw new InvalidDataException("yes I know we should drop this but we" +  								"probably want to know that they added a new big field");  					} else if (wireType == 0) {  						var val = bitstream.ReadProtobufVarInt();    						switch (fieldnum) {  						case 1:  							Type = val;  							break;  						case 3:  							Flags = val;  							break;  						case 4:  							Priority = val;  							break;  						case 6:  							NumElements = val;  							break;  						case 9:  							NumBits = val;  							break;  						default:  							// silently drop  							break;  						}  					} else if (wireType == 5) {  						var val = bitstream.ReadFloat();    						switch (fieldnum) {  						case 7:  							LowValue = val;  							break;  						case 8:  							HighValue = val;  							break;  						default:  							// silently drop  							break;  						}  					} else  						throw new InvalidDataException();  				}
Magic Number,DemoInfo,SendProp,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\SendTable.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished) {  					var desc = bitstream.ReadProtobufVarInt();  					var wireType = desc & 7;  					var fieldnum = desc >> 3;    					if (wireType == 2) {  						if (fieldnum == 2) {  							VarName = bitstream.ReadProtobufString();  						} else if (fieldnum == 5) {  							DtName = bitstream.ReadProtobufString();  						} else  							throw new InvalidDataException("yes I know we should drop this but we" +  								"probably want to know that they added a new big field");  					} else if (wireType == 0) {  						var val = bitstream.ReadProtobufVarInt();    						switch (fieldnum) {  						case 1:  							Type = val;  							break;  						case 3:  							Flags = val;  							break;  						case 4:  							Priority = val;  							break;  						case 6:  							NumElements = val;  							break;  						case 9:  							NumBits = val;  							break;  						default:  							// silently drop  							break;  						}  					} else if (wireType == 5) {  						var val = bitstream.ReadFloat();    						switch (fieldnum) {  						case 7:  							LowValue = val;  							break;  						case 8:  							HighValue = val;  							break;  						default:  							// silently drop  							break;  						}  					} else  						throw new InvalidDataException();  				}
Magic Number,DemoInfo.DP,DemoPacketParser,C:\repos\EHVAG_demoinfo\DemoInfo\DP\DemoPacketParser.cs,ParsePacket,The following statement contains a magic number: while (!bitstream.ChunkFinished)              {  				int cmd = bitstream.ReadProtobufVarInt(); //What type of packet is this?  				int length = bitstream.ReadProtobufVarInt(); //And how long is it?  				bitstream.BeginChunk(length * 8); //read length bytes  				if (cmd == (int)SVC_Messages.svc_PacketEntities) { //Parse packet entities  					new PacketEntities().Parse(bitstream' demo);   				} else if (cmd == (int)SVC_Messages.svc_GameEventList) { //and all this other stuff  					new GameEventList().Parse(bitstream' demo);  				} else if (cmd == (int)SVC_Messages.svc_GameEvent) {  					new GameEvent().Parse(bitstream' demo);  				} else if (cmd == (int)SVC_Messages.svc_CreateStringTable) {  					new CreateStringTable().Parse(bitstream' demo);  				} else if (cmd == (int)SVC_Messages.svc_UpdateStringTable) {  					new UpdateStringTable().Parse(bitstream' demo);  				} else if (cmd == (int)NET_Messages.net_Tick) { //and all this other stuff  						new NETTick().Parse(bitstream' demo);  				} else if (cmd == (int)SVC_Messages.svc_UserMessage) {  					new UserMessage().Parse(bitstream' demo);  				} else {  					//You can use this flag to see what information the other packets contain'   					//if you want. Then you can look into the objects. Has some advnatages' and some disdavantages (mostly speed)'   					//so we use our own lightning-fast parsing code.   					#if SLOW_PROTOBUF   					Type toParse = null;    					if (Enum.IsDefined(typeof(SVC_Messages)' cmd)) {  						SVC_Messages msg = (SVC_Messages)cmd;  						toParse = Assembly.GetExecutingAssembly().GetType("DemoInfo.Messages.CSVCMsg_" + msg.ToString().Substring(4));  					} else if (Enum.IsDefined(typeof(NET_Messages)' cmd)) {  						NET_Messages msg = (NET_Messages)cmd;  						toParse = Assembly.GetExecutingAssembly().GetType("DemoInfo.Messages.CNETMsg_" + msg.ToString().Substring(4));  					}    					var data = bitstream.ReadBytes(length);  					if (toParse == null)  						continue;    					ProtoBuf.IExtensible result;  					using (var memstream = new MemoryStream(data))  						result = memstream.ReadProtobufMessage(toParse);    					foreach (var parser in Parsers)  						if (parser.TryApplyMessage(result' demo) && (parser.Priority > 0))  							break;  					#endif  				}  				bitstream.EndChunk();              }
Magic Number,DemoInfo.DP,Entity,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Entity.cs,ReadFieldIndex,The following statement contains a magic number: if (bNewWay && reader.ReadBit()) {  				ret = (int)reader.ReadInt(3);  // read 3 bits  			} else {  				ret = (int)reader.ReadInt(7); // read 7 bits  				switch (ret & ( 32 | 64 )) {  				case 32:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(2) << 5 );  					break;  				case 64:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(4) << 5 );  					break;  				case 96:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(7) << 5 );  					break;  				}  			}
Magic Number,DemoInfo.DP,Entity,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Entity.cs,ReadFieldIndex,The following statement contains a magic number: if (bNewWay && reader.ReadBit()) {  				ret = (int)reader.ReadInt(3);  // read 3 bits  			} else {  				ret = (int)reader.ReadInt(7); // read 7 bits  				switch (ret & ( 32 | 64 )) {  				case 32:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(2) << 5 );  					break;  				case 64:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(4) << 5 );  					break;  				case 96:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(7) << 5 );  					break;  				}  			}
Magic Number,DemoInfo.DP,Entity,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Entity.cs,ReadFieldIndex,The following statement contains a magic number: if (bNewWay && reader.ReadBit()) {  				ret = (int)reader.ReadInt(3);  // read 3 bits  			} else {  				ret = (int)reader.ReadInt(7); // read 7 bits  				switch (ret & ( 32 | 64 )) {  				case 32:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(2) << 5 );  					break;  				case 64:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(4) << 5 );  					break;  				case 96:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(7) << 5 );  					break;  				}  			}
Magic Number,DemoInfo.DP,Entity,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Entity.cs,ReadFieldIndex,The following statement contains a magic number: if (bNewWay && reader.ReadBit()) {  				ret = (int)reader.ReadInt(3);  // read 3 bits  			} else {  				ret = (int)reader.ReadInt(7); // read 7 bits  				switch (ret & ( 32 | 64 )) {  				case 32:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(2) << 5 );  					break;  				case 64:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(4) << 5 );  					break;  				case 96:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(7) << 5 );  					break;  				}  			}
Magic Number,DemoInfo.DP,Entity,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Entity.cs,ReadFieldIndex,The following statement contains a magic number: if (bNewWay && reader.ReadBit()) {  				ret = (int)reader.ReadInt(3);  // read 3 bits  			} else {  				ret = (int)reader.ReadInt(7); // read 7 bits  				switch (ret & ( 32 | 64 )) {  				case 32:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(2) << 5 );  					break;  				case 64:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(4) << 5 );  					break;  				case 96:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(7) << 5 );  					break;  				}  			}
Magic Number,DemoInfo.DP,Entity,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Entity.cs,ReadFieldIndex,The following statement contains a magic number: if (bNewWay && reader.ReadBit()) {  				ret = (int)reader.ReadInt(3);  // read 3 bits  			} else {  				ret = (int)reader.ReadInt(7); // read 7 bits  				switch (ret & ( 32 | 64 )) {  				case 32:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(2) << 5 );  					break;  				case 64:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(4) << 5 );  					break;  				case 96:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(7) << 5 );  					break;  				}  			}
Magic Number,DemoInfo.DP,Entity,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Entity.cs,ReadFieldIndex,The following statement contains a magic number: if (bNewWay && reader.ReadBit()) {  				ret = (int)reader.ReadInt(3);  // read 3 bits  			} else {  				ret = (int)reader.ReadInt(7); // read 7 bits  				switch (ret & ( 32 | 64 )) {  				case 32:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(2) << 5 );  					break;  				case 64:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(4) << 5 );  					break;  				case 96:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(7) << 5 );  					break;  				}  			}
Magic Number,DemoInfo.DP,Entity,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Entity.cs,ReadFieldIndex,The following statement contains a magic number: if (bNewWay && reader.ReadBit()) {  				ret = (int)reader.ReadInt(3);  // read 3 bits  			} else {  				ret = (int)reader.ReadInt(7); // read 7 bits  				switch (ret & ( 32 | 64 )) {  				case 32:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(2) << 5 );  					break;  				case 64:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(4) << 5 );  					break;  				case 96:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(7) << 5 );  					break;  				}  			}
Magic Number,DemoInfo.DP,Entity,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Entity.cs,ReadFieldIndex,The following statement contains a magic number: if (bNewWay && reader.ReadBit()) {  				ret = (int)reader.ReadInt(3);  // read 3 bits  			} else {  				ret = (int)reader.ReadInt(7); // read 7 bits  				switch (ret & ( 32 | 64 )) {  				case 32:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(2) << 5 );  					break;  				case 64:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(4) << 5 );  					break;  				case 96:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(7) << 5 );  					break;  				}  			}
Magic Number,DemoInfo.DP,Entity,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Entity.cs,ReadFieldIndex,The following statement contains a magic number: if (bNewWay && reader.ReadBit()) {  				ret = (int)reader.ReadInt(3);  // read 3 bits  			} else {  				ret = (int)reader.ReadInt(7); // read 7 bits  				switch (ret & ( 32 | 64 )) {  				case 32:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(2) << 5 );  					break;  				case 64:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(4) << 5 );  					break;  				case 96:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(7) << 5 );  					break;  				}  			}
Magic Number,DemoInfo.DP,Entity,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Entity.cs,ReadFieldIndex,The following statement contains a magic number: if (bNewWay && reader.ReadBit()) {  				ret = (int)reader.ReadInt(3);  // read 3 bits  			} else {  				ret = (int)reader.ReadInt(7); // read 7 bits  				switch (ret & ( 32 | 64 )) {  				case 32:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(2) << 5 );  					break;  				case 64:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(4) << 5 );  					break;  				case 96:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(7) << 5 );  					break;  				}  			}
Magic Number,DemoInfo.DP,Entity,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Entity.cs,ReadFieldIndex,The following statement contains a magic number: if (bNewWay && reader.ReadBit()) {  				ret = (int)reader.ReadInt(3);  // read 3 bits  			} else {  				ret = (int)reader.ReadInt(7); // read 7 bits  				switch (ret & ( 32 | 64 )) {  				case 32:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(2) << 5 );  					break;  				case 64:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(4) << 5 );  					break;  				case 96:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(7) << 5 );  					break;  				}  			}
Magic Number,DemoInfo.DP,Entity,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Entity.cs,ReadFieldIndex,The following statement contains a magic number: if (bNewWay && reader.ReadBit()) {  				ret = (int)reader.ReadInt(3);  // read 3 bits  			} else {  				ret = (int)reader.ReadInt(7); // read 7 bits  				switch (ret & ( 32 | 64 )) {  				case 32:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(2) << 5 );  					break;  				case 64:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(4) << 5 );  					break;  				case 96:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(7) << 5 );  					break;  				}  			}
Magic Number,DemoInfo.DP,Entity,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Entity.cs,ReadFieldIndex,The following statement contains a magic number: if (bNewWay && reader.ReadBit()) {  				ret = (int)reader.ReadInt(3);  // read 3 bits  			} else {  				ret = (int)reader.ReadInt(7); // read 7 bits  				switch (ret & ( 32 | 64 )) {  				case 32:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(2) << 5 );  					break;  				case 64:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(4) << 5 );  					break;  				case 96:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(7) << 5 );  					break;  				}  			}
Magic Number,DemoInfo.DP,Entity,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Entity.cs,ReadFieldIndex,The following statement contains a magic number: if (bNewWay && reader.ReadBit()) {  				ret = (int)reader.ReadInt(3);  // read 3 bits  			} else {  				ret = (int)reader.ReadInt(7); // read 7 bits  				switch (ret & ( 32 | 64 )) {  				case 32:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(2) << 5 );  					break;  				case 64:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(4) << 5 );  					break;  				case 96:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(7) << 5 );  					break;  				}  			}
Magic Number,DemoInfo.DP,Entity,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Entity.cs,ReadFieldIndex,The following statement contains a magic number: if (bNewWay && reader.ReadBit()) {  				ret = (int)reader.ReadInt(3);  // read 3 bits  			} else {  				ret = (int)reader.ReadInt(7); // read 7 bits  				switch (ret & ( 32 | 64 )) {  				case 32:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(2) << 5 );  					break;  				case 64:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(4) << 5 );  					break;  				case 96:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(7) << 5 );  					break;  				}  			}
Magic Number,DemoInfo.DP.FastNetmessages,RankUpdate,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\RankUpdate.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished)  			{  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 0 && fieldnum == 1)  				{  					AccountId = bitstream.ReadProtobufVarInt();  				}  				else if(wireType == 0 && fieldnum == 2)  				{  					RankOld = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 0 && fieldnum == 3)  				{  					RankNew = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 0 && fieldnum == 4)  				{  					NumWins = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 5 && fieldnum == 5)  				{  					RankChange = bitstream.ReadFloat();  				}  			}
Magic Number,DemoInfo.DP.FastNetmessages,RankUpdate,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\RankUpdate.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished)  			{  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 0 && fieldnum == 1)  				{  					AccountId = bitstream.ReadProtobufVarInt();  				}  				else if(wireType == 0 && fieldnum == 2)  				{  					RankOld = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 0 && fieldnum == 3)  				{  					RankNew = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 0 && fieldnum == 4)  				{  					NumWins = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 5 && fieldnum == 5)  				{  					RankChange = bitstream.ReadFloat();  				}  			}
Magic Number,DemoInfo.DP.FastNetmessages,RankUpdate,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\RankUpdate.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished)  			{  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 0 && fieldnum == 1)  				{  					AccountId = bitstream.ReadProtobufVarInt();  				}  				else if(wireType == 0 && fieldnum == 2)  				{  					RankOld = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 0 && fieldnum == 3)  				{  					RankNew = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 0 && fieldnum == 4)  				{  					NumWins = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 5 && fieldnum == 5)  				{  					RankChange = bitstream.ReadFloat();  				}  			}
Magic Number,DemoInfo.DP.FastNetmessages,RankUpdate,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\RankUpdate.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished)  			{  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 0 && fieldnum == 1)  				{  					AccountId = bitstream.ReadProtobufVarInt();  				}  				else if(wireType == 0 && fieldnum == 2)  				{  					RankOld = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 0 && fieldnum == 3)  				{  					RankNew = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 0 && fieldnum == 4)  				{  					NumWins = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 5 && fieldnum == 5)  				{  					RankChange = bitstream.ReadFloat();  				}  			}
Magic Number,DemoInfo.DP.FastNetmessages,RankUpdate,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\RankUpdate.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished)  			{  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 0 && fieldnum == 1)  				{  					AccountId = bitstream.ReadProtobufVarInt();  				}  				else if(wireType == 0 && fieldnum == 2)  				{  					RankOld = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 0 && fieldnum == 3)  				{  					RankNew = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 0 && fieldnum == 4)  				{  					NumWins = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 5 && fieldnum == 5)  				{  					RankChange = bitstream.ReadFloat();  				}  			}
Magic Number,DemoInfo.DP.FastNetmessages,RankUpdate,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\RankUpdate.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished)  			{  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 0 && fieldnum == 1)  				{  					AccountId = bitstream.ReadProtobufVarInt();  				}  				else if(wireType == 0 && fieldnum == 2)  				{  					RankOld = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 0 && fieldnum == 3)  				{  					RankNew = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 0 && fieldnum == 4)  				{  					NumWins = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 5 && fieldnum == 5)  				{  					RankChange = bitstream.ReadFloat();  				}  			}
Magic Number,DemoInfo.DP.FastNetmessages,RankUpdate,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\RankUpdate.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished)  			{  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 0 && fieldnum == 1)  				{  					AccountId = bitstream.ReadProtobufVarInt();  				}  				else if(wireType == 0 && fieldnum == 2)  				{  					RankOld = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 0 && fieldnum == 3)  				{  					RankNew = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 0 && fieldnum == 4)  				{  					NumWins = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 5 && fieldnum == 5)  				{  					RankChange = bitstream.ReadFloat();  				}  			}
Magic Number,DemoInfo.DP.FastNetmessages,SayText,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\SayText.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished)  			{  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 0 && fieldnum == 1)  				{  					EntityIndex = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 2 && fieldnum == 2)  				{  					Text = bitstream.ReadProtobufString();  				}  				else if (wireType == 0 && fieldnum == 3)  				{  					_chat = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 0 && fieldnum == 4)  				{  					_textAllChat = bitstream.ReadProtobufVarInt();  				}  				else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo.DP.FastNetmessages,SayText,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\SayText.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished)  			{  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 0 && fieldnum == 1)  				{  					EntityIndex = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 2 && fieldnum == 2)  				{  					Text = bitstream.ReadProtobufString();  				}  				else if (wireType == 0 && fieldnum == 3)  				{  					_chat = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 0 && fieldnum == 4)  				{  					_textAllChat = bitstream.ReadProtobufVarInt();  				}  				else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo.DP.FastNetmessages,SayText,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\SayText.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished)  			{  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 0 && fieldnum == 1)  				{  					EntityIndex = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 2 && fieldnum == 2)  				{  					Text = bitstream.ReadProtobufString();  				}  				else if (wireType == 0 && fieldnum == 3)  				{  					_chat = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 0 && fieldnum == 4)  				{  					_textAllChat = bitstream.ReadProtobufVarInt();  				}  				else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo.DP.FastNetmessages,SayText,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\SayText.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished)  			{  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 0 && fieldnum == 1)  				{  					EntityIndex = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 2 && fieldnum == 2)  				{  					Text = bitstream.ReadProtobufString();  				}  				else if (wireType == 0 && fieldnum == 3)  				{  					_chat = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 0 && fieldnum == 4)  				{  					_textAllChat = bitstream.ReadProtobufVarInt();  				}  				else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo.DP.FastNetmessages,SayText,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\SayText.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished)  			{  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 0 && fieldnum == 1)  				{  					EntityIndex = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 2 && fieldnum == 2)  				{  					Text = bitstream.ReadProtobufString();  				}  				else if (wireType == 0 && fieldnum == 3)  				{  					_chat = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 0 && fieldnum == 4)  				{  					_textAllChat = bitstream.ReadProtobufVarInt();  				}  				else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo.DP.FastNetmessages,SayText,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\SayText.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished)  			{  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 0 && fieldnum == 1)  				{  					EntityIndex = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 2 && fieldnum == 2)  				{  					Text = bitstream.ReadProtobufString();  				}  				else if (wireType == 0 && fieldnum == 3)  				{  					_chat = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 0 && fieldnum == 4)  				{  					_textAllChat = bitstream.ReadProtobufVarInt();  				}  				else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo.DP.FastNetmessages,SayText2,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\SayText2.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished)  			{  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 0 && fieldnum == 1)  				{  					EntIdx = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 0 && fieldnum == 2)  				{  					_chat = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 2 && fieldnum == 3)  				{  					MsgName = bitstream.ReadProtobufString();  				}  				else if (wireType == 0 && fieldnum == 5)  				{  					_textAllChat = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 2 && fieldnum == 4)  				{  					Params.Add(bitstream.ReadProtobufString());  				}  				else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo.DP.FastNetmessages,SayText2,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\SayText2.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished)  			{  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 0 && fieldnum == 1)  				{  					EntIdx = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 0 && fieldnum == 2)  				{  					_chat = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 2 && fieldnum == 3)  				{  					MsgName = bitstream.ReadProtobufString();  				}  				else if (wireType == 0 && fieldnum == 5)  				{  					_textAllChat = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 2 && fieldnum == 4)  				{  					Params.Add(bitstream.ReadProtobufString());  				}  				else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo.DP.FastNetmessages,SayText2,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\SayText2.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished)  			{  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 0 && fieldnum == 1)  				{  					EntIdx = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 0 && fieldnum == 2)  				{  					_chat = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 2 && fieldnum == 3)  				{  					MsgName = bitstream.ReadProtobufString();  				}  				else if (wireType == 0 && fieldnum == 5)  				{  					_textAllChat = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 2 && fieldnum == 4)  				{  					Params.Add(bitstream.ReadProtobufString());  				}  				else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo.DP.FastNetmessages,SayText2,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\SayText2.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished)  			{  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 0 && fieldnum == 1)  				{  					EntIdx = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 0 && fieldnum == 2)  				{  					_chat = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 2 && fieldnum == 3)  				{  					MsgName = bitstream.ReadProtobufString();  				}  				else if (wireType == 0 && fieldnum == 5)  				{  					_textAllChat = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 2 && fieldnum == 4)  				{  					Params.Add(bitstream.ReadProtobufString());  				}  				else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo.DP.FastNetmessages,SayText2,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\SayText2.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished)  			{  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 0 && fieldnum == 1)  				{  					EntIdx = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 0 && fieldnum == 2)  				{  					_chat = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 2 && fieldnum == 3)  				{  					MsgName = bitstream.ReadProtobufString();  				}  				else if (wireType == 0 && fieldnum == 5)  				{  					_textAllChat = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 2 && fieldnum == 4)  				{  					Params.Add(bitstream.ReadProtobufString());  				}  				else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo.DP.FastNetmessages,SayText2,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\SayText2.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished)  			{  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 0 && fieldnum == 1)  				{  					EntIdx = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 0 && fieldnum == 2)  				{  					_chat = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 2 && fieldnum == 3)  				{  					MsgName = bitstream.ReadProtobufString();  				}  				else if (wireType == 0 && fieldnum == 5)  				{  					_textAllChat = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 2 && fieldnum == 4)  				{  					Params.Add(bitstream.ReadProtobufString());  				}  				else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo.DP.FastNetmessages,SayText2,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\SayText2.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished)  			{  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 0 && fieldnum == 1)  				{  					EntIdx = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 0 && fieldnum == 2)  				{  					_chat = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 2 && fieldnum == 3)  				{  					MsgName = bitstream.ReadProtobufString();  				}  				else if (wireType == 0 && fieldnum == 5)  				{  					_textAllChat = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 2 && fieldnum == 4)  				{  					Params.Add(bitstream.ReadProtobufString());  				}  				else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo.DP.FastNetmessages,SayText2,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\SayText2.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished)  			{  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 0 && fieldnum == 1)  				{  					EntIdx = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 0 && fieldnum == 2)  				{  					_chat = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 2 && fieldnum == 3)  				{  					MsgName = bitstream.ReadProtobufString();  				}  				else if (wireType == 0 && fieldnum == 5)  				{  					_textAllChat = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 2 && fieldnum == 4)  				{  					Params.Add(bitstream.ReadProtobufString());  				}  				else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo.DP.FastNetmessages,ServerRankUpdate,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\ServerRankUpdate.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished)  			{  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 2 && fieldnum == 1)  				{  					bitstream.BeginChunk(bitstream.ReadProtobufVarInt() * 8);  					new RankUpdate().Parse(bitstream' parser);  					bitstream.EndChunk();  				}  				else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo.DP.FastNetmessages,ServerRankUpdate,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\ServerRankUpdate.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished)  			{  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 2 && fieldnum == 1)  				{  					bitstream.BeginChunk(bitstream.ReadProtobufVarInt() * 8);  					new RankUpdate().Parse(bitstream' parser);  					bitstream.EndChunk();  				}  				else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo.DP.FastNetmessages,ServerRankUpdate,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\ServerRankUpdate.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished)  			{  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 2 && fieldnum == 1)  				{  					bitstream.BeginChunk(bitstream.ReadProtobufVarInt() * 8);  					new RankUpdate().Parse(bitstream' parser);  					bitstream.EndChunk();  				}  				else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo.DP.FastNetmessages,ServerRankUpdate,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\ServerRankUpdate.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished)  			{  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 2 && fieldnum == 1)  				{  					bitstream.BeginChunk(bitstream.ReadProtobufVarInt() * 8);  					new RankUpdate().Parse(bitstream' parser);  					bitstream.EndChunk();  				}  				else  					throw new InvalidDataException();  			}
Magic Number,DemoInfo.DP.FastNetmessages,UserMessage,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\UserMessage.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished)  			{  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 0 && fieldnum == 1)  				{  					MsgType = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 0 && fieldnum == 3)  				{  					PassThrough = bitstream.ReadProtobufVarInt();  				} else if (fieldnum == 2) {  					// msg data  					if (wireType == 2)  					{  						bitstream.BeginChunk(bitstream.ReadProtobufVarInt() * 8);  						switch (MsgType)  						{  							// This is where you can add others UserMessage parsing logic  							case (int)User_Messages.um_SayText:  								new SayText().Parse(bitstream' parser);  								break;  							case (int)User_Messages.um_SayText2:  								new SayText2().Parse(bitstream' parser);  								break;  							case (int)User_Messages.um_ServerRankUpdate:  								new ServerRankUpdate().Parse(bitstream' parser);  								break;  						}    						bitstream.EndChunk();  						if (!bitstream.ChunkFinished)  							throw new NotImplementedException("Lord Gaben wasn't nice to us :/");  					}  				}  			}
Magic Number,DemoInfo.DP.FastNetmessages,UserMessage,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\UserMessage.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished)  			{  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 0 && fieldnum == 1)  				{  					MsgType = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 0 && fieldnum == 3)  				{  					PassThrough = bitstream.ReadProtobufVarInt();  				} else if (fieldnum == 2) {  					// msg data  					if (wireType == 2)  					{  						bitstream.BeginChunk(bitstream.ReadProtobufVarInt() * 8);  						switch (MsgType)  						{  							// This is where you can add others UserMessage parsing logic  							case (int)User_Messages.um_SayText:  								new SayText().Parse(bitstream' parser);  								break;  							case (int)User_Messages.um_SayText2:  								new SayText2().Parse(bitstream' parser);  								break;  							case (int)User_Messages.um_ServerRankUpdate:  								new ServerRankUpdate().Parse(bitstream' parser);  								break;  						}    						bitstream.EndChunk();  						if (!bitstream.ChunkFinished)  							throw new NotImplementedException("Lord Gaben wasn't nice to us :/");  					}  				}  			}
Magic Number,DemoInfo.DP.FastNetmessages,UserMessage,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\UserMessage.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished)  			{  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 0 && fieldnum == 1)  				{  					MsgType = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 0 && fieldnum == 3)  				{  					PassThrough = bitstream.ReadProtobufVarInt();  				} else if (fieldnum == 2) {  					// msg data  					if (wireType == 2)  					{  						bitstream.BeginChunk(bitstream.ReadProtobufVarInt() * 8);  						switch (MsgType)  						{  							// This is where you can add others UserMessage parsing logic  							case (int)User_Messages.um_SayText:  								new SayText().Parse(bitstream' parser);  								break;  							case (int)User_Messages.um_SayText2:  								new SayText2().Parse(bitstream' parser);  								break;  							case (int)User_Messages.um_ServerRankUpdate:  								new ServerRankUpdate().Parse(bitstream' parser);  								break;  						}    						bitstream.EndChunk();  						if (!bitstream.ChunkFinished)  							throw new NotImplementedException("Lord Gaben wasn't nice to us :/");  					}  				}  			}
Magic Number,DemoInfo.DP.FastNetmessages,UserMessage,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\UserMessage.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished)  			{  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 0 && fieldnum == 1)  				{  					MsgType = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 0 && fieldnum == 3)  				{  					PassThrough = bitstream.ReadProtobufVarInt();  				} else if (fieldnum == 2) {  					// msg data  					if (wireType == 2)  					{  						bitstream.BeginChunk(bitstream.ReadProtobufVarInt() * 8);  						switch (MsgType)  						{  							// This is where you can add others UserMessage parsing logic  							case (int)User_Messages.um_SayText:  								new SayText().Parse(bitstream' parser);  								break;  							case (int)User_Messages.um_SayText2:  								new SayText2().Parse(bitstream' parser);  								break;  							case (int)User_Messages.um_ServerRankUpdate:  								new ServerRankUpdate().Parse(bitstream' parser);  								break;  						}    						bitstream.EndChunk();  						if (!bitstream.ChunkFinished)  							throw new NotImplementedException("Lord Gaben wasn't nice to us :/");  					}  				}  			}
Magic Number,DemoInfo.DP.FastNetmessages,UserMessage,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\UserMessage.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished)  			{  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 0 && fieldnum == 1)  				{  					MsgType = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 0 && fieldnum == 3)  				{  					PassThrough = bitstream.ReadProtobufVarInt();  				} else if (fieldnum == 2) {  					// msg data  					if (wireType == 2)  					{  						bitstream.BeginChunk(bitstream.ReadProtobufVarInt() * 8);  						switch (MsgType)  						{  							// This is where you can add others UserMessage parsing logic  							case (int)User_Messages.um_SayText:  								new SayText().Parse(bitstream' parser);  								break;  							case (int)User_Messages.um_SayText2:  								new SayText2().Parse(bitstream' parser);  								break;  							case (int)User_Messages.um_ServerRankUpdate:  								new ServerRankUpdate().Parse(bitstream' parser);  								break;  						}    						bitstream.EndChunk();  						if (!bitstream.ChunkFinished)  							throw new NotImplementedException("Lord Gaben wasn't nice to us :/");  					}  				}  			}
Magic Number,DemoInfo.DP.FastNetmessages,UserMessage,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\UserMessage.cs,Parse,The following statement contains a magic number: while (!bitstream.ChunkFinished)  			{  				var desc = bitstream.ReadProtobufVarInt();  				var wireType = desc & 7;  				var fieldnum = desc >> 3;    				if (wireType == 0 && fieldnum == 1)  				{  					MsgType = bitstream.ReadProtobufVarInt();  				}  				else if (wireType == 0 && fieldnum == 3)  				{  					PassThrough = bitstream.ReadProtobufVarInt();  				} else if (fieldnum == 2) {  					// msg data  					if (wireType == 2)  					{  						bitstream.BeginChunk(bitstream.ReadProtobufVarInt() * 8);  						switch (MsgType)  						{  							// This is where you can add others UserMessage parsing logic  							case (int)User_Messages.um_SayText:  								new SayText().Parse(bitstream' parser);  								break;  							case (int)User_Messages.um_SayText2:  								new SayText2().Parse(bitstream' parser);  								break;  							case (int)User_Messages.um_ServerRankUpdate:  								new ServerRankUpdate().Parse(bitstream' parser);  								break;  						}    						bitstream.EndChunk();  						if (!bitstream.ChunkFinished)  							throw new NotImplementedException("Lord Gaben wasn't nice to us :/");  					}  				}  			}
Magic Number,DemoInfo.DP.Handler,GameEventHandler,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Handler\GameEventHandler.cs,GetCommunityID,The following statement contains a magic number: long authServer = Convert.ToInt64(steamID.Substring(8' 1));
Magic Number,DemoInfo.DP.Handler,GameEventHandler,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Handler\GameEventHandler.cs,GetCommunityID,The following statement contains a magic number: long authID = Convert.ToInt64(steamID.Substring(10));
Magic Number,DemoInfo.DP.Handler,GameEventHandler,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Handler\GameEventHandler.cs,GetCommunityID,The following statement contains a magic number: return (76561197960265728 + (authID * 2) + authServer);
Magic Number,DemoInfo.DP.Handler,GameEventHandler,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Handler\GameEventHandler.cs,GetCommunityID,The following statement contains a magic number: return (76561197960265728 + (authID * 2) + authServer);
Magic Number,DemoInfo.DP.Handler,PacketEntitesHandler,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Handler\PacketEntitesHandler.cs,ReadEnterPVS,The following statement contains a magic number: reader.ReadInt(10);
Magic Number,DemoInfo.DP.Handler,PropDecoder,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Handler\PropDecoder.cs,DecodeString,The following statement contains a magic number: return Encoding.Default.GetString(reader.ReadBytes((int)reader.ReadInt(9)));
Magic Number,DemoInfo.DP.Handler,PropDecoder,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Handler\PropDecoder.cs,ReadBitCoord,The following statement contains a magic number: if (( intVal | fractVal ) != 0) {  				// Read the sign bit  				isNegative = reader.ReadBit();    				// If there's an integer' read it in  				if (intVal == 1) {  					// Adjust the integers from [0..MAX_COORD_VALUE-1] to [1..MAX_COORD_VALUE]  					intVal = (int)reader.ReadInt(14) + 1; //14 --> Coord int bits  				}    				//If there's a fraction' read it in  				if (fractVal == 1) {  					fractVal = (int)reader.ReadInt(COORD_FRACTIONAL_BITS);   				}    				value = intVal + ( (float)fractVal * COORD_RESOLUTION );    			}
Magic Number,DemoInfo.DP.Handler,PropDecoder,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Handler\PropDecoder.cs,ReadBitCoordMP,The following statement contains a magic number: if (isIntegral) {  				// Read the required integer and fraction flags  				intval = reader.ReadBit() ? 1 : 0;    				// If we got either parse them' otherwise it's a zero.  				if (intval == 1) {  					// Read the sign bit  					isNegative = reader.ReadBit();    					// If there's an integer' read it in  					// Adjust the integers from [0..MAX_COORD_VALUE-1] to [1..MAX_COORD_VALUE]  					if (inBounds) {  						value = (float)( reader.ReadInt(11) + 1 );  					} else {  						value = (float)( reader.ReadInt(14) + 1 );  					}  				}  			} else {  				// Read the required integer and fraction flags  				intval = reader.ReadBit() ? 1 : 0;    				// Read the sign bit  				isNegative = reader.ReadBit();    				// If we got either parse them' otherwise it's a zero.  				if (intval == 1) {    					// If there's an integer' read it in  					// Adjust the integers from [0..MAX_COORD_VALUE-1] to [1..MAX_COORD_VALUE]  					if (inBounds) {  						value = (float)( reader.ReadInt(11) + 1 );  					} else {  						value = (float)( reader.ReadInt(14) + 1 );  					}  				}    				// If there's a fraction' read it in  				fractval = (int)reader.ReadInt(isLowPrecision ? 3 : 5);    				// Calculate the correct floating point value  				value = intval + ( (float)fractval * ( isLowPrecision ? COORD_RESOLUTION_LOWPRECISION : COORD_RESOLUTION ) );  			}
Magic Number,DemoInfo.DP.Handler,PropDecoder,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Handler\PropDecoder.cs,ReadBitCoordMP,The following statement contains a magic number: if (isIntegral) {  				// Read the required integer and fraction flags  				intval = reader.ReadBit() ? 1 : 0;    				// If we got either parse them' otherwise it's a zero.  				if (intval == 1) {  					// Read the sign bit  					isNegative = reader.ReadBit();    					// If there's an integer' read it in  					// Adjust the integers from [0..MAX_COORD_VALUE-1] to [1..MAX_COORD_VALUE]  					if (inBounds) {  						value = (float)( reader.ReadInt(11) + 1 );  					} else {  						value = (float)( reader.ReadInt(14) + 1 );  					}  				}  			} else {  				// Read the required integer and fraction flags  				intval = reader.ReadBit() ? 1 : 0;    				// Read the sign bit  				isNegative = reader.ReadBit();    				// If we got either parse them' otherwise it's a zero.  				if (intval == 1) {    					// If there's an integer' read it in  					// Adjust the integers from [0..MAX_COORD_VALUE-1] to [1..MAX_COORD_VALUE]  					if (inBounds) {  						value = (float)( reader.ReadInt(11) + 1 );  					} else {  						value = (float)( reader.ReadInt(14) + 1 );  					}  				}    				// If there's a fraction' read it in  				fractval = (int)reader.ReadInt(isLowPrecision ? 3 : 5);    				// Calculate the correct floating point value  				value = intval + ( (float)fractval * ( isLowPrecision ? COORD_RESOLUTION_LOWPRECISION : COORD_RESOLUTION ) );  			}
Magic Number,DemoInfo.DP.Handler,PropDecoder,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Handler\PropDecoder.cs,ReadBitCoordMP,The following statement contains a magic number: if (isIntegral) {  				// Read the required integer and fraction flags  				intval = reader.ReadBit() ? 1 : 0;    				// If we got either parse them' otherwise it's a zero.  				if (intval == 1) {  					// Read the sign bit  					isNegative = reader.ReadBit();    					// If there's an integer' read it in  					// Adjust the integers from [0..MAX_COORD_VALUE-1] to [1..MAX_COORD_VALUE]  					if (inBounds) {  						value = (float)( reader.ReadInt(11) + 1 );  					} else {  						value = (float)( reader.ReadInt(14) + 1 );  					}  				}  			} else {  				// Read the required integer and fraction flags  				intval = reader.ReadBit() ? 1 : 0;    				// Read the sign bit  				isNegative = reader.ReadBit();    				// If we got either parse them' otherwise it's a zero.  				if (intval == 1) {    					// If there's an integer' read it in  					// Adjust the integers from [0..MAX_COORD_VALUE-1] to [1..MAX_COORD_VALUE]  					if (inBounds) {  						value = (float)( reader.ReadInt(11) + 1 );  					} else {  						value = (float)( reader.ReadInt(14) + 1 );  					}  				}    				// If there's a fraction' read it in  				fractval = (int)reader.ReadInt(isLowPrecision ? 3 : 5);    				// Calculate the correct floating point value  				value = intval + ( (float)fractval * ( isLowPrecision ? COORD_RESOLUTION_LOWPRECISION : COORD_RESOLUTION ) );  			}
Magic Number,DemoInfo.DP.Handler,PropDecoder,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Handler\PropDecoder.cs,ReadBitCoordMP,The following statement contains a magic number: if (isIntegral) {  				// Read the required integer and fraction flags  				intval = reader.ReadBit() ? 1 : 0;    				// If we got either parse them' otherwise it's a zero.  				if (intval == 1) {  					// Read the sign bit  					isNegative = reader.ReadBit();    					// If there's an integer' read it in  					// Adjust the integers from [0..MAX_COORD_VALUE-1] to [1..MAX_COORD_VALUE]  					if (inBounds) {  						value = (float)( reader.ReadInt(11) + 1 );  					} else {  						value = (float)( reader.ReadInt(14) + 1 );  					}  				}  			} else {  				// Read the required integer and fraction flags  				intval = reader.ReadBit() ? 1 : 0;    				// Read the sign bit  				isNegative = reader.ReadBit();    				// If we got either parse them' otherwise it's a zero.  				if (intval == 1) {    					// If there's an integer' read it in  					// Adjust the integers from [0..MAX_COORD_VALUE-1] to [1..MAX_COORD_VALUE]  					if (inBounds) {  						value = (float)( reader.ReadInt(11) + 1 );  					} else {  						value = (float)( reader.ReadInt(14) + 1 );  					}  				}    				// If there's a fraction' read it in  				fractval = (int)reader.ReadInt(isLowPrecision ? 3 : 5);    				// Calculate the correct floating point value  				value = intval + ( (float)fractval * ( isLowPrecision ? COORD_RESOLUTION_LOWPRECISION : COORD_RESOLUTION ) );  			}
Magic Number,DemoInfo.DP.Handler,PropDecoder,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Handler\PropDecoder.cs,ReadBitCoordMP,The following statement contains a magic number: if (isIntegral) {  				// Read the required integer and fraction flags  				intval = reader.ReadBit() ? 1 : 0;    				// If we got either parse them' otherwise it's a zero.  				if (intval == 1) {  					// Read the sign bit  					isNegative = reader.ReadBit();    					// If there's an integer' read it in  					// Adjust the integers from [0..MAX_COORD_VALUE-1] to [1..MAX_COORD_VALUE]  					if (inBounds) {  						value = (float)( reader.ReadInt(11) + 1 );  					} else {  						value = (float)( reader.ReadInt(14) + 1 );  					}  				}  			} else {  				// Read the required integer and fraction flags  				intval = reader.ReadBit() ? 1 : 0;    				// Read the sign bit  				isNegative = reader.ReadBit();    				// If we got either parse them' otherwise it's a zero.  				if (intval == 1) {    					// If there's an integer' read it in  					// Adjust the integers from [0..MAX_COORD_VALUE-1] to [1..MAX_COORD_VALUE]  					if (inBounds) {  						value = (float)( reader.ReadInt(11) + 1 );  					} else {  						value = (float)( reader.ReadInt(14) + 1 );  					}  				}    				// If there's a fraction' read it in  				fractval = (int)reader.ReadInt(isLowPrecision ? 3 : 5);    				// Calculate the correct floating point value  				value = intval + ( (float)fractval * ( isLowPrecision ? COORD_RESOLUTION_LOWPRECISION : COORD_RESOLUTION ) );  			}
Magic Number,DemoInfo.DP.Handler,PropDecoder,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Handler\PropDecoder.cs,ReadBitCoordMP,The following statement contains a magic number: if (isIntegral) {  				// Read the required integer and fraction flags  				intval = reader.ReadBit() ? 1 : 0;    				// If we got either parse them' otherwise it's a zero.  				if (intval == 1) {  					// Read the sign bit  					isNegative = reader.ReadBit();    					// If there's an integer' read it in  					// Adjust the integers from [0..MAX_COORD_VALUE-1] to [1..MAX_COORD_VALUE]  					if (inBounds) {  						value = (float)( reader.ReadInt(11) + 1 );  					} else {  						value = (float)( reader.ReadInt(14) + 1 );  					}  				}  			} else {  				// Read the required integer and fraction flags  				intval = reader.ReadBit() ? 1 : 0;    				// Read the sign bit  				isNegative = reader.ReadBit();    				// If we got either parse them' otherwise it's a zero.  				if (intval == 1) {    					// If there's an integer' read it in  					// Adjust the integers from [0..MAX_COORD_VALUE-1] to [1..MAX_COORD_VALUE]  					if (inBounds) {  						value = (float)( reader.ReadInt(11) + 1 );  					} else {  						value = (float)( reader.ReadInt(14) + 1 );  					}  				}    				// If there's a fraction' read it in  				fractval = (int)reader.ReadInt(isLowPrecision ? 3 : 5);    				// Calculate the correct floating point value  				value = intval + ( (float)fractval * ( isLowPrecision ? COORD_RESOLUTION_LOWPRECISION : COORD_RESOLUTION ) );  			}
Magic Number,DemoInfo.DP.Handler,CreateStringTableUserInfoHandler,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Handler\CreateStringTableUserInfoHandler.cs,Apply,The following statement contains a magic number: for (int i = 0; i < table.NumEntries; i++) {  				int entryIndex = lastEntry + 1;  				// d in the entity-index  				if (!reader.ReadBit()) {  					entryIndex = (int)reader.ReadInt(nEntryBits);  				}    				lastEntry = entryIndex;    				// Read the name of the string into entry.  				string entry = "";  				if (entryIndex < 0 || entryIndex >= table.MaxEntries) {  					throw new InvalidDataException("bogus string index");  				}    				if (reader.ReadBit()) {  					bool substringcheck = reader.ReadBit();    					if (substringcheck) {  						int index = (int)reader.ReadInt(5);  						int bytestocopy = (int)reader.ReadInt(5);    						entry = history[index].Substring(0' bytestocopy);    						entry += reader.ReadString(1024);  					} else {  						entry = reader.ReadString(1024);  					}  				}    				if (entry == null)  					entry = "";    				if (history.Count > 31)  					history.RemoveAt(0);    				history.Add(entry);    				// Read in the user data.  				byte[] userdata = new byte[0];  				if (reader.ReadBit()) {  					if (table.UserDataFixedSize) {  						userdata = reader.ReadBits(table.UserDataSizeBits);  					} else {  						int bytesToRead = (int)reader.ReadInt(14);    						userdata = reader.ReadBytes(bytesToRead);  					}  				}    				if (userdata.Length == 0)  					continue;    				if (table.Name == "userinfo") {  					// Now we'll parse the players out of it.  					BinaryReader playerReader = new BinaryReader(new MemoryStream(userdata));  					PlayerInfo info = PlayerInfo.ParseFrom(playerReader);    					parser.RawPlayers[entryIndex] = info;  				} else if (table.Name == "instancebaseline") {  					int classid = int.Parse(entry); //wtf volvo?    					parser.instanceBaseline[classid] = userdata;                  }                  else if (table.Name == "modelprecache") {                      parser.modelprecache[entryIndex] = entry;                  }  			}
Magic Number,DemoInfo.DP.Handler,CreateStringTableUserInfoHandler,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Handler\CreateStringTableUserInfoHandler.cs,Apply,The following statement contains a magic number: for (int i = 0; i < table.NumEntries; i++) {  				int entryIndex = lastEntry + 1;  				// d in the entity-index  				if (!reader.ReadBit()) {  					entryIndex = (int)reader.ReadInt(nEntryBits);  				}    				lastEntry = entryIndex;    				// Read the name of the string into entry.  				string entry = "";  				if (entryIndex < 0 || entryIndex >= table.MaxEntries) {  					throw new InvalidDataException("bogus string index");  				}    				if (reader.ReadBit()) {  					bool substringcheck = reader.ReadBit();    					if (substringcheck) {  						int index = (int)reader.ReadInt(5);  						int bytestocopy = (int)reader.ReadInt(5);    						entry = history[index].Substring(0' bytestocopy);    						entry += reader.ReadString(1024);  					} else {  						entry = reader.ReadString(1024);  					}  				}    				if (entry == null)  					entry = "";    				if (history.Count > 31)  					history.RemoveAt(0);    				history.Add(entry);    				// Read in the user data.  				byte[] userdata = new byte[0];  				if (reader.ReadBit()) {  					if (table.UserDataFixedSize) {  						userdata = reader.ReadBits(table.UserDataSizeBits);  					} else {  						int bytesToRead = (int)reader.ReadInt(14);    						userdata = reader.ReadBytes(bytesToRead);  					}  				}    				if (userdata.Length == 0)  					continue;    				if (table.Name == "userinfo") {  					// Now we'll parse the players out of it.  					BinaryReader playerReader = new BinaryReader(new MemoryStream(userdata));  					PlayerInfo info = PlayerInfo.ParseFrom(playerReader);    					parser.RawPlayers[entryIndex] = info;  				} else if (table.Name == "instancebaseline") {  					int classid = int.Parse(entry); //wtf volvo?    					parser.instanceBaseline[classid] = userdata;                  }                  else if (table.Name == "modelprecache") {                      parser.modelprecache[entryIndex] = entry;                  }  			}
Magic Number,DemoInfo.DP.Handler,CreateStringTableUserInfoHandler,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Handler\CreateStringTableUserInfoHandler.cs,Apply,The following statement contains a magic number: for (int i = 0; i < table.NumEntries; i++) {  				int entryIndex = lastEntry + 1;  				// d in the entity-index  				if (!reader.ReadBit()) {  					entryIndex = (int)reader.ReadInt(nEntryBits);  				}    				lastEntry = entryIndex;    				// Read the name of the string into entry.  				string entry = "";  				if (entryIndex < 0 || entryIndex >= table.MaxEntries) {  					throw new InvalidDataException("bogus string index");  				}    				if (reader.ReadBit()) {  					bool substringcheck = reader.ReadBit();    					if (substringcheck) {  						int index = (int)reader.ReadInt(5);  						int bytestocopy = (int)reader.ReadInt(5);    						entry = history[index].Substring(0' bytestocopy);    						entry += reader.ReadString(1024);  					} else {  						entry = reader.ReadString(1024);  					}  				}    				if (entry == null)  					entry = "";    				if (history.Count > 31)  					history.RemoveAt(0);    				history.Add(entry);    				// Read in the user data.  				byte[] userdata = new byte[0];  				if (reader.ReadBit()) {  					if (table.UserDataFixedSize) {  						userdata = reader.ReadBits(table.UserDataSizeBits);  					} else {  						int bytesToRead = (int)reader.ReadInt(14);    						userdata = reader.ReadBytes(bytesToRead);  					}  				}    				if (userdata.Length == 0)  					continue;    				if (table.Name == "userinfo") {  					// Now we'll parse the players out of it.  					BinaryReader playerReader = new BinaryReader(new MemoryStream(userdata));  					PlayerInfo info = PlayerInfo.ParseFrom(playerReader);    					parser.RawPlayers[entryIndex] = info;  				} else if (table.Name == "instancebaseline") {  					int classid = int.Parse(entry); //wtf volvo?    					parser.instanceBaseline[classid] = userdata;                  }                  else if (table.Name == "modelprecache") {                      parser.modelprecache[entryIndex] = entry;                  }  			}
Magic Number,DemoInfo.DP.Handler,CreateStringTableUserInfoHandler,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Handler\CreateStringTableUserInfoHandler.cs,Apply,The following statement contains a magic number: for (int i = 0; i < table.NumEntries; i++) {  				int entryIndex = lastEntry + 1;  				// d in the entity-index  				if (!reader.ReadBit()) {  					entryIndex = (int)reader.ReadInt(nEntryBits);  				}    				lastEntry = entryIndex;    				// Read the name of the string into entry.  				string entry = "";  				if (entryIndex < 0 || entryIndex >= table.MaxEntries) {  					throw new InvalidDataException("bogus string index");  				}    				if (reader.ReadBit()) {  					bool substringcheck = reader.ReadBit();    					if (substringcheck) {  						int index = (int)reader.ReadInt(5);  						int bytestocopy = (int)reader.ReadInt(5);    						entry = history[index].Substring(0' bytestocopy);    						entry += reader.ReadString(1024);  					} else {  						entry = reader.ReadString(1024);  					}  				}    				if (entry == null)  					entry = "";    				if (history.Count > 31)  					history.RemoveAt(0);    				history.Add(entry);    				// Read in the user data.  				byte[] userdata = new byte[0];  				if (reader.ReadBit()) {  					if (table.UserDataFixedSize) {  						userdata = reader.ReadBits(table.UserDataSizeBits);  					} else {  						int bytesToRead = (int)reader.ReadInt(14);    						userdata = reader.ReadBytes(bytesToRead);  					}  				}    				if (userdata.Length == 0)  					continue;    				if (table.Name == "userinfo") {  					// Now we'll parse the players out of it.  					BinaryReader playerReader = new BinaryReader(new MemoryStream(userdata));  					PlayerInfo info = PlayerInfo.ParseFrom(playerReader);    					parser.RawPlayers[entryIndex] = info;  				} else if (table.Name == "instancebaseline") {  					int classid = int.Parse(entry); //wtf volvo?    					parser.instanceBaseline[classid] = userdata;                  }                  else if (table.Name == "modelprecache") {                      parser.modelprecache[entryIndex] = entry;                  }  			}
Magic Number,DemoInfo.DP.Handler,CreateStringTableUserInfoHandler,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Handler\CreateStringTableUserInfoHandler.cs,Apply,The following statement contains a magic number: for (int i = 0; i < table.NumEntries; i++) {  				int entryIndex = lastEntry + 1;  				// d in the entity-index  				if (!reader.ReadBit()) {  					entryIndex = (int)reader.ReadInt(nEntryBits);  				}    				lastEntry = entryIndex;    				// Read the name of the string into entry.  				string entry = "";  				if (entryIndex < 0 || entryIndex >= table.MaxEntries) {  					throw new InvalidDataException("bogus string index");  				}    				if (reader.ReadBit()) {  					bool substringcheck = reader.ReadBit();    					if (substringcheck) {  						int index = (int)reader.ReadInt(5);  						int bytestocopy = (int)reader.ReadInt(5);    						entry = history[index].Substring(0' bytestocopy);    						entry += reader.ReadString(1024);  					} else {  						entry = reader.ReadString(1024);  					}  				}    				if (entry == null)  					entry = "";    				if (history.Count > 31)  					history.RemoveAt(0);    				history.Add(entry);    				// Read in the user data.  				byte[] userdata = new byte[0];  				if (reader.ReadBit()) {  					if (table.UserDataFixedSize) {  						userdata = reader.ReadBits(table.UserDataSizeBits);  					} else {  						int bytesToRead = (int)reader.ReadInt(14);    						userdata = reader.ReadBytes(bytesToRead);  					}  				}    				if (userdata.Length == 0)  					continue;    				if (table.Name == "userinfo") {  					// Now we'll parse the players out of it.  					BinaryReader playerReader = new BinaryReader(new MemoryStream(userdata));  					PlayerInfo info = PlayerInfo.ParseFrom(playerReader);    					parser.RawPlayers[entryIndex] = info;  				} else if (table.Name == "instancebaseline") {  					int classid = int.Parse(entry); //wtf volvo?    					parser.instanceBaseline[classid] = userdata;                  }                  else if (table.Name == "modelprecache") {                      parser.modelprecache[entryIndex] = entry;                  }  			}
Magic Number,DemoInfo.DP.Handler,CreateStringTableUserInfoHandler,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Handler\CreateStringTableUserInfoHandler.cs,Apply,The following statement contains a magic number: for (int i = 0; i < table.NumEntries; i++) {  				int entryIndex = lastEntry + 1;  				// d in the entity-index  				if (!reader.ReadBit()) {  					entryIndex = (int)reader.ReadInt(nEntryBits);  				}    				lastEntry = entryIndex;    				// Read the name of the string into entry.  				string entry = "";  				if (entryIndex < 0 || entryIndex >= table.MaxEntries) {  					throw new InvalidDataException("bogus string index");  				}    				if (reader.ReadBit()) {  					bool substringcheck = reader.ReadBit();    					if (substringcheck) {  						int index = (int)reader.ReadInt(5);  						int bytestocopy = (int)reader.ReadInt(5);    						entry = history[index].Substring(0' bytestocopy);    						entry += reader.ReadString(1024);  					} else {  						entry = reader.ReadString(1024);  					}  				}    				if (entry == null)  					entry = "";    				if (history.Count > 31)  					history.RemoveAt(0);    				history.Add(entry);    				// Read in the user data.  				byte[] userdata = new byte[0];  				if (reader.ReadBit()) {  					if (table.UserDataFixedSize) {  						userdata = reader.ReadBits(table.UserDataSizeBits);  					} else {  						int bytesToRead = (int)reader.ReadInt(14);    						userdata = reader.ReadBytes(bytesToRead);  					}  				}    				if (userdata.Length == 0)  					continue;    				if (table.Name == "userinfo") {  					// Now we'll parse the players out of it.  					BinaryReader playerReader = new BinaryReader(new MemoryStream(userdata));  					PlayerInfo info = PlayerInfo.ParseFrom(playerReader);    					parser.RawPlayers[entryIndex] = info;  				} else if (table.Name == "instancebaseline") {  					int classid = int.Parse(entry); //wtf volvo?    					parser.instanceBaseline[classid] = userdata;                  }                  else if (table.Name == "modelprecache") {                      parser.modelprecache[entryIndex] = entry;                  }  			}
Magic Number,DemoInfo.DT,DataTableParser,C:\repos\EHVAG_demoinfo\DemoInfo\DT\DataTableParser.cs,ParsePacket,The following statement contains a magic number: while (true)              {  				var type = (SVC_Messages)bitstream.ReadProtobufVarInt();  				if (type != SVC_Messages.svc_SendTable)  					throw new Exception("Expected SendTable' got " + type);    				var size = bitstream.ReadProtobufVarInt();  				bitstream.BeginChunk(size * 8);  				var sendTable = new SendTable(bitstream);  				bitstream.EndChunk();                    if (sendTable.IsEnd)                      break;    				DataTables.Add(sendTable);              }
Magic Number,DemoInfo.DT,DataTableParser,C:\repos\EHVAG_demoinfo\DemoInfo\DT\DataTableParser.cs,ParsePacket,The following statement contains a magic number: int serverClassCount = checked((int)bitstream.ReadInt(16));
Magic Number,DemoInfo.DT,DataTableParser,C:\repos\EHVAG_demoinfo\DemoInfo\DT\DataTableParser.cs,ParsePacket,The following statement contains a magic number: for (int i = 0; i < serverClassCount; i++)              {                  ServerClass entry = new ServerClass();  				entry.ClassID = checked((int)bitstream.ReadInt(16));                    if (entry.ClassID > serverClassCount)                      throw new Exception("Invalid class index");    				entry.Name = bitstream.ReadDataTableString();  				entry.DTName = bitstream.ReadDataTableString();                    entry.DataTableID = DataTables.FindIndex(a => a.Name == entry.DTName);                    ServerClasses.Add(entry);              }
Magic Number,DemoInfo.DT,DataTableParser,C:\repos\EHVAG_demoinfo\DemoInfo\DT\DataTableParser.cs,FlattenDataTable,The following statement contains a magic number: priorities.Add(64);
Magic Number,DemoInfo.DT,DataTableParser,C:\repos\EHVAG_demoinfo\DemoInfo\DT\DataTableParser.cs,FlattenDataTable,The following statement contains a magic number: for (int priorityIndex = 0; priorityIndex < priorities.Count; priorityIndex++)              {                  int priority = priorities[priorityIndex];                    while (true)                  {                      int currentProp = start;                        while (currentProp < flattenedProps.Count)                      {                          SendTableProperty prop = flattenedProps[currentProp].Prop;                            if (prop.Priority == priority || (priority == 64 && prop.Flags.HasFlagFast(SendPropertyFlags.ChangesOften)))                          {                              if (start != currentProp)                              {                                  FlattenedPropEntry temp = flattenedProps[start];                                  flattenedProps[start] = flattenedProps[currentProp];                                  flattenedProps[currentProp] = temp;                              }                                start++;                              break;                          }                          currentProp++;                      }                        if (currentProp == flattenedProps.Count)                          break;                  }              }
Magic Number,DemoInfo.ST,StringTableParser,C:\repos\EHVAG_demoinfo\DemoInfo\ST\StringTableParser.cs,ParseStringTable,The following statement contains a magic number: int numStrings = (int)reader.ReadInt(16);
Magic Number,DemoInfo.ST,StringTableParser,C:\repos\EHVAG_demoinfo\DemoInfo\ST\StringTableParser.cs,ParseStringTable,The following statement contains a magic number: for (int i = 0; i < numStrings; i++)              {                  string stringName = reader.ReadString();                    if (stringName.Length >= 100)                      throw new Exception("Roy said I should throw this.");                    if (reader.ReadBit())                  {                      int userDataSize = (int)reader.ReadInt(16);                        byte[] data = reader.ReadBytes(userDataSize);    					if (tableName == "userinfo") {  						PlayerInfo info = PlayerInfo.ParseFrom(new BinaryReader(new MemoryStream(data)));    						parser.RawPlayers[int.Parse(stringName)] = info;  					} else if (tableName == "instancebaseline") {  						int classid = int.Parse(stringName); //wtf volvo?    						parser.instanceBaseline[classid] = data;   					} else if (tableName == "modelprecache") {  						parser.modelprecache.Add (stringName);  					}                  }              }
Magic Number,DemoInfo.ST,StringTableParser,C:\repos\EHVAG_demoinfo\DemoInfo\ST\StringTableParser.cs,ParseStringTable,The following statement contains a magic number: for (int i = 0; i < numStrings; i++)              {                  string stringName = reader.ReadString();                    if (stringName.Length >= 100)                      throw new Exception("Roy said I should throw this.");                    if (reader.ReadBit())                  {                      int userDataSize = (int)reader.ReadInt(16);                        byte[] data = reader.ReadBytes(userDataSize);    					if (tableName == "userinfo") {  						PlayerInfo info = PlayerInfo.ParseFrom(new BinaryReader(new MemoryStream(data)));    						parser.RawPlayers[int.Parse(stringName)] = info;  					} else if (tableName == "instancebaseline") {  						int classid = int.Parse(stringName); //wtf volvo?    						parser.instanceBaseline[classid] = data;   					} else if (tableName == "modelprecache") {  						parser.modelprecache.Add (stringName);  					}                  }              }
Magic Number,DemoInfo.ST,StringTableParser,C:\repos\EHVAG_demoinfo\DemoInfo\ST\StringTableParser.cs,ParseStringTable,The following statement contains a magic number: if ( reader.ReadBit() )  	        {  		        int numstrings = (int)reader.ReadInt(16);  		        for ( int i = 0 ; i < numstrings; i++ )  		        {  			        reader.ReadString(); // stringname    			        if ( reader.ReadBit() )  			        {  				        int userDataSize = ( int )reader.ReadInt(16);    				        reader.ReadBytes( userDataSize );    			        }  			        else  			        {  			        }  		        }  	        }
Magic Number,DemoInfo.ST,StringTableParser,C:\repos\EHVAG_demoinfo\DemoInfo\ST\StringTableParser.cs,ParseStringTable,The following statement contains a magic number: if ( reader.ReadBit() )  	        {  		        int numstrings = (int)reader.ReadInt(16);  		        for ( int i = 0 ; i < numstrings; i++ )  		        {  			        reader.ReadString(); // stringname    			        if ( reader.ReadBit() )  			        {  				        int userDataSize = ( int )reader.ReadInt(16);    				        reader.ReadBytes( userDataSize );    			        }  			        else  			        {  			        }  		        }  	        }
Magic Number,DemoInfo.BitStreamImpl,BitArrayStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitArrayStream.cs,ReadByte,The following statement contains a magic number: return (byte)ReadInt(8);
Magic Number,DemoInfo.BitStreamImpl,BitArrayStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitArrayStream.cs,PeekBools,The following statement contains a magic number: for (int i = Position; i < Math.Min(Position + length' array.Count); i++) {  				if (array[i])  					buffer[idx++] = 49;  				else  					buffer[idx++] = 48;  			}
Magic Number,DemoInfo.BitStreamImpl,BitArrayStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitArrayStream.cs,PeekBools,The following statement contains a magic number: for (int i = Position; i < Math.Min(Position + length' array.Count); i++) {  				if (array[i])  					buffer[idx++] = 49;  				else  					buffer[idx++] = 48;  			}
Magic Number,DemoInfo.BitStreamImpl,BitArrayStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitArrayStream.cs,ReadSignedInt,The following statement contains a magic number: return ( ( (int)ReadInt(numBits) ) << ( 32 - numBits ) ) >> ( 32 - numBits );
Magic Number,DemoInfo.BitStreamImpl,BitArrayStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitArrayStream.cs,ReadSignedInt,The following statement contains a magic number: return ( ( (int)ReadInt(numBits) ) << ( 32 - numBits ) ) >> ( 32 - numBits );
Magic Number,DemoInfo.BitStreamImpl,BitArrayStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitArrayStream.cs,ReadFloat,The following statement contains a magic number: return BitConverter.ToSingle(ReadBytes(4)' 0);
Magic Number,DemoInfo.BitStreamImpl,BitArrayStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitArrayStream.cs,ReadBits,The following statement contains a magic number: byte[] result = new byte[(bits + 7) / 8];
Magic Number,DemoInfo.BitStreamImpl,BitArrayStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitArrayStream.cs,ReadBits,The following statement contains a magic number: byte[] result = new byte[(bits + 7) / 8];
Magic Number,DemoInfo.BitStreamImpl,BitArrayStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitArrayStream.cs,ReadBits,The following statement contains a magic number: for (int i = 0; i < (bits / 8); i++)  				result[i] = this.ReadByte();
Magic Number,DemoInfo.BitStreamImpl,BitArrayStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitArrayStream.cs,ReadBits,The following statement contains a magic number: if ((bits % 8) != 0)  				result[bits / 8] = ReadByte(bits % 8);
Magic Number,DemoInfo.BitStreamImpl,BitArrayStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitArrayStream.cs,ReadBits,The following statement contains a magic number: if ((bits % 8) != 0)  				result[bits / 8] = ReadByte(bits % 8);
Magic Number,DemoInfo.BitStreamImpl,BitArrayStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitArrayStream.cs,ReadBits,The following statement contains a magic number: if ((bits % 8) != 0)  				result[bits / 8] = ReadByte(bits % 8);
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,Initialize,The following statement contains a magic number: Offset = SLED * 8;
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,RefillBuffer,The following statement contains a magic number: for (int i = 0; i < SLED; i++)  				Buffer[i] = Buffer[(BitsInBuffer / 8) + i];
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,RefillBuffer,The following statement contains a magic number: int offset' thisTime = 1337;
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,RefillBuffer,The following statement contains a magic number: for (offset = 0; (offset < 4) && (thisTime != 0); offset += thisTime)  				thisTime = Underlying.Read(Buffer' SLED + offset' BUFSIZE - SLED - offset);
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,RefillBuffer,The following statement contains a magic number: BitsInBuffer = 8 * offset;
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,RefillBuffer,The following statement contains a magic number: if (thisTime == 0)  				// end of stream' so we can consume the sled now  				BitsInBuffer += SLED * 8;
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,PeekInt,The following statement contains a magic number: BitStreamUtil.AssertMaxBits(32' numBits);
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,PeekInt,The following statement contains a magic number: Debug.Assert(mayOverflow || ((Offset + numBits) <= (BitsInBuffer + (SLED * 8)))' "gg"' "This code just fell apart. We're all dead. Offset={0} numBits={1} BitsInBuffer={2}"' Offset' numBits' BitsInBuffer);
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,PeekInt,The following statement contains a magic number: return (uint)((BitConverter.ToUInt64(Buffer' (Offset / 8) & ~3) << ((8 * 8) - (Offset % (8 * 4)) - numBits)) >> ((8 * 8) - numBits));
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,PeekInt,The following statement contains a magic number: return (uint)((BitConverter.ToUInt64(Buffer' (Offset / 8) & ~3) << ((8 * 8) - (Offset % (8 * 4)) - numBits)) >> ((8 * 8) - numBits));
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,PeekInt,The following statement contains a magic number: return (uint)((BitConverter.ToUInt64(Buffer' (Offset / 8) & ~3) << ((8 * 8) - (Offset % (8 * 4)) - numBits)) >> ((8 * 8) - numBits));
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,PeekInt,The following statement contains a magic number: return (uint)((BitConverter.ToUInt64(Buffer' (Offset / 8) & ~3) << ((8 * 8) - (Offset % (8 * 4)) - numBits)) >> ((8 * 8) - numBits));
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,PeekInt,The following statement contains a magic number: return (uint)((BitConverter.ToUInt64(Buffer' (Offset / 8) & ~3) << ((8 * 8) - (Offset % (8 * 4)) - numBits)) >> ((8 * 8) - numBits));
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,PeekInt,The following statement contains a magic number: return (uint)((BitConverter.ToUInt64(Buffer' (Offset / 8) & ~3) << ((8 * 8) - (Offset % (8 * 4)) - numBits)) >> ((8 * 8) - numBits));
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,PeekInt,The following statement contains a magic number: return (uint)((BitConverter.ToUInt64(Buffer' (Offset / 8) & ~3) << ((8 * 8) - (Offset % (8 * 4)) - numBits)) >> ((8 * 8) - numBits));
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,PeekInt,The following statement contains a magic number: return (uint)((BitConverter.ToUInt64(Buffer' (Offset / 8) & ~3) << ((8 * 8) - (Offset % (8 * 4)) - numBits)) >> ((8 * 8) - numBits));
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,ReadSignedInt,The following statement contains a magic number: BitStreamUtil.AssertMaxBits(32' numBits);
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,ReadSignedInt,The following statement contains a magic number: var result = (int)(((long)(BitConverter.ToUInt64(Buffer' (Offset / 8) & ~3) << ((8 * 8) - (Offset % (8 * 4)) - numBits))) >> ((8 * 8) - numBits));
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,ReadSignedInt,The following statement contains a magic number: var result = (int)(((long)(BitConverter.ToUInt64(Buffer' (Offset / 8) & ~3) << ((8 * 8) - (Offset % (8 * 4)) - numBits))) >> ((8 * 8) - numBits));
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,ReadSignedInt,The following statement contains a magic number: var result = (int)(((long)(BitConverter.ToUInt64(Buffer' (Offset / 8) & ~3) << ((8 * 8) - (Offset % (8 * 4)) - numBits))) >> ((8 * 8) - numBits));
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,ReadSignedInt,The following statement contains a magic number: var result = (int)(((long)(BitConverter.ToUInt64(Buffer' (Offset / 8) & ~3) << ((8 * 8) - (Offset % (8 * 4)) - numBits))) >> ((8 * 8) - numBits));
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,ReadSignedInt,The following statement contains a magic number: var result = (int)(((long)(BitConverter.ToUInt64(Buffer' (Offset / 8) & ~3) << ((8 * 8) - (Offset % (8 * 4)) - numBits))) >> ((8 * 8) - numBits));
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,ReadSignedInt,The following statement contains a magic number: var result = (int)(((long)(BitConverter.ToUInt64(Buffer' (Offset / 8) & ~3) << ((8 * 8) - (Offset % (8 * 4)) - numBits))) >> ((8 * 8) - numBits));
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,ReadSignedInt,The following statement contains a magic number: var result = (int)(((long)(BitConverter.ToUInt64(Buffer' (Offset / 8) & ~3) << ((8 * 8) - (Offset % (8 * 4)) - numBits))) >> ((8 * 8) - numBits));
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,ReadSignedInt,The following statement contains a magic number: var result = (int)(((long)(BitConverter.ToUInt64(Buffer' (Offset / 8) & ~3) << ((8 * 8) - (Offset % (8 * 4)) - numBits))) >> ((8 * 8) - numBits));
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,ReadBit,The following statement contains a magic number: bool bit = (Buffer[Offset / 8] & (1 << (Offset & 7))) != 0;
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,ReadBit,The following statement contains a magic number: bool bit = (Buffer[Offset / 8] & (1 << (Offset & 7))) != 0;
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,ReadByte,The following statement contains a magic number: return ReadByte(8);
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,ReadByte,The following statement contains a magic number: BitStreamUtil.AssertMaxBits(8' bits);
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,ReadFloat,The following statement contains a magic number: return BitConverter.ToSingle(ReadBytes(4)' 0);
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,ReadBits,The following statement contains a magic number: byte[] result = new byte[(bits + 7) / 8];
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,ReadBits,The following statement contains a magic number: byte[] result = new byte[(bits + 7) / 8];
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,ReadBits,The following statement contains a magic number: for (int i = 0; i < (bits / 8); i++)  				result[i] = this.ReadByte();
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,ReadBits,The following statement contains a magic number: if ((bits % 8) != 0)  				result[bits / 8] = ReadByte(bits % 8);
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,ReadBits,The following statement contains a magic number: if ((bits % 8) != 0)  				result[bits / 8] = ReadByte(bits % 8);
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,ReadBits,The following statement contains a magic number: if ((bits % 8) != 0)  				result[bits / 8] = ReadByte(bits % 8);
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,ReadProtobufVarInt,The following statement contains a magic number: var availableBits = BitsInBuffer + (SLED * 8) - Offset;
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,ReadProtobufVarInt,The following statement contains a magic number: uint buf = PeekInt(32' true);
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,ReadProtobufVarInt,The following statement contains a magic number: BitStreamUtil.AssertMaxBits(availableBits' 1 * 8);
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,ReadProtobufVarInt,The following statement contains a magic number: if ((buf & MSB_1) != 0) {  				result |= (buf & MSK_2) >> 1;  				BitStreamUtil.AssertMaxBits(availableBits' 1 * 8);  				if ((buf & MSB_2) != 0) {  					result |= (buf & MSK_3) >> 2;  					BitStreamUtil.AssertMaxBits(availableBits' 2 * 8);  					if ((buf & MSB_3) != 0) {  						result |= (buf & MSK_4) >> 3;  						BitStreamUtil.AssertMaxBits(availableBits' 3 * 8);  						if ((buf & MSB_4) != 0)  							// dammit' it's too large (probably negative)  							// fall back to the slow implementation' that's rare  							return BitStreamUtil.ReadProtobufVarIntStub(this);  						else Advance(4 * 8);  					} else Advance(3 * 8);  				} else Advance(2 * 8);  			} else Advance(1 * 8);
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,ReadProtobufVarInt,The following statement contains a magic number: if ((buf & MSB_1) != 0) {  				result |= (buf & MSK_2) >> 1;  				BitStreamUtil.AssertMaxBits(availableBits' 1 * 8);  				if ((buf & MSB_2) != 0) {  					result |= (buf & MSK_3) >> 2;  					BitStreamUtil.AssertMaxBits(availableBits' 2 * 8);  					if ((buf & MSB_3) != 0) {  						result |= (buf & MSK_4) >> 3;  						BitStreamUtil.AssertMaxBits(availableBits' 3 * 8);  						if ((buf & MSB_4) != 0)  							// dammit' it's too large (probably negative)  							// fall back to the slow implementation' that's rare  							return BitStreamUtil.ReadProtobufVarIntStub(this);  						else Advance(4 * 8);  					} else Advance(3 * 8);  				} else Advance(2 * 8);  			} else Advance(1 * 8);
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,ReadProtobufVarInt,The following statement contains a magic number: if ((buf & MSB_1) != 0) {  				result |= (buf & MSK_2) >> 1;  				BitStreamUtil.AssertMaxBits(availableBits' 1 * 8);  				if ((buf & MSB_2) != 0) {  					result |= (buf & MSK_3) >> 2;  					BitStreamUtil.AssertMaxBits(availableBits' 2 * 8);  					if ((buf & MSB_3) != 0) {  						result |= (buf & MSK_4) >> 3;  						BitStreamUtil.AssertMaxBits(availableBits' 3 * 8);  						if ((buf & MSB_4) != 0)  							// dammit' it's too large (probably negative)  							// fall back to the slow implementation' that's rare  							return BitStreamUtil.ReadProtobufVarIntStub(this);  						else Advance(4 * 8);  					} else Advance(3 * 8);  				} else Advance(2 * 8);  			} else Advance(1 * 8);
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,ReadProtobufVarInt,The following statement contains a magic number: if ((buf & MSB_1) != 0) {  				result |= (buf & MSK_2) >> 1;  				BitStreamUtil.AssertMaxBits(availableBits' 1 * 8);  				if ((buf & MSB_2) != 0) {  					result |= (buf & MSK_3) >> 2;  					BitStreamUtil.AssertMaxBits(availableBits' 2 * 8);  					if ((buf & MSB_3) != 0) {  						result |= (buf & MSK_4) >> 3;  						BitStreamUtil.AssertMaxBits(availableBits' 3 * 8);  						if ((buf & MSB_4) != 0)  							// dammit' it's too large (probably negative)  							// fall back to the slow implementation' that's rare  							return BitStreamUtil.ReadProtobufVarIntStub(this);  						else Advance(4 * 8);  					} else Advance(3 * 8);  				} else Advance(2 * 8);  			} else Advance(1 * 8);
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,ReadProtobufVarInt,The following statement contains a magic number: if ((buf & MSB_1) != 0) {  				result |= (buf & MSK_2) >> 1;  				BitStreamUtil.AssertMaxBits(availableBits' 1 * 8);  				if ((buf & MSB_2) != 0) {  					result |= (buf & MSK_3) >> 2;  					BitStreamUtil.AssertMaxBits(availableBits' 2 * 8);  					if ((buf & MSB_3) != 0) {  						result |= (buf & MSK_4) >> 3;  						BitStreamUtil.AssertMaxBits(availableBits' 3 * 8);  						if ((buf & MSB_4) != 0)  							// dammit' it's too large (probably negative)  							// fall back to the slow implementation' that's rare  							return BitStreamUtil.ReadProtobufVarIntStub(this);  						else Advance(4 * 8);  					} else Advance(3 * 8);  				} else Advance(2 * 8);  			} else Advance(1 * 8);
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,ReadProtobufVarInt,The following statement contains a magic number: if ((buf & MSB_1) != 0) {  				result |= (buf & MSK_2) >> 1;  				BitStreamUtil.AssertMaxBits(availableBits' 1 * 8);  				if ((buf & MSB_2) != 0) {  					result |= (buf & MSK_3) >> 2;  					BitStreamUtil.AssertMaxBits(availableBits' 2 * 8);  					if ((buf & MSB_3) != 0) {  						result |= (buf & MSK_4) >> 3;  						BitStreamUtil.AssertMaxBits(availableBits' 3 * 8);  						if ((buf & MSB_4) != 0)  							// dammit' it's too large (probably negative)  							// fall back to the slow implementation' that's rare  							return BitStreamUtil.ReadProtobufVarIntStub(this);  						else Advance(4 * 8);  					} else Advance(3 * 8);  				} else Advance(2 * 8);  			} else Advance(1 * 8);
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,ReadProtobufVarInt,The following statement contains a magic number: if ((buf & MSB_1) != 0) {  				result |= (buf & MSK_2) >> 1;  				BitStreamUtil.AssertMaxBits(availableBits' 1 * 8);  				if ((buf & MSB_2) != 0) {  					result |= (buf & MSK_3) >> 2;  					BitStreamUtil.AssertMaxBits(availableBits' 2 * 8);  					if ((buf & MSB_3) != 0) {  						result |= (buf & MSK_4) >> 3;  						BitStreamUtil.AssertMaxBits(availableBits' 3 * 8);  						if ((buf & MSB_4) != 0)  							// dammit' it's too large (probably negative)  							// fall back to the slow implementation' that's rare  							return BitStreamUtil.ReadProtobufVarIntStub(this);  						else Advance(4 * 8);  					} else Advance(3 * 8);  				} else Advance(2 * 8);  			} else Advance(1 * 8);
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,ReadProtobufVarInt,The following statement contains a magic number: if ((buf & MSB_1) != 0) {  				result |= (buf & MSK_2) >> 1;  				BitStreamUtil.AssertMaxBits(availableBits' 1 * 8);  				if ((buf & MSB_2) != 0) {  					result |= (buf & MSK_3) >> 2;  					BitStreamUtil.AssertMaxBits(availableBits' 2 * 8);  					if ((buf & MSB_3) != 0) {  						result |= (buf & MSK_4) >> 3;  						BitStreamUtil.AssertMaxBits(availableBits' 3 * 8);  						if ((buf & MSB_4) != 0)  							// dammit' it's too large (probably negative)  							// fall back to the slow implementation' that's rare  							return BitStreamUtil.ReadProtobufVarIntStub(this);  						else Advance(4 * 8);  					} else Advance(3 * 8);  				} else Advance(2 * 8);  			} else Advance(1 * 8);
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,ReadProtobufVarInt,The following statement contains a magic number: if ((buf & MSB_1) != 0) {  				result |= (buf & MSK_2) >> 1;  				BitStreamUtil.AssertMaxBits(availableBits' 1 * 8);  				if ((buf & MSB_2) != 0) {  					result |= (buf & MSK_3) >> 2;  					BitStreamUtil.AssertMaxBits(availableBits' 2 * 8);  					if ((buf & MSB_3) != 0) {  						result |= (buf & MSK_4) >> 3;  						BitStreamUtil.AssertMaxBits(availableBits' 3 * 8);  						if ((buf & MSB_4) != 0)  							// dammit' it's too large (probably negative)  							// fall back to the slow implementation' that's rare  							return BitStreamUtil.ReadProtobufVarIntStub(this);  						else Advance(4 * 8);  					} else Advance(3 * 8);  				} else Advance(2 * 8);  			} else Advance(1 * 8);
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,ReadProtobufVarInt,The following statement contains a magic number: if ((buf & MSB_1) != 0) {  				result |= (buf & MSK_2) >> 1;  				BitStreamUtil.AssertMaxBits(availableBits' 1 * 8);  				if ((buf & MSB_2) != 0) {  					result |= (buf & MSK_3) >> 2;  					BitStreamUtil.AssertMaxBits(availableBits' 2 * 8);  					if ((buf & MSB_3) != 0) {  						result |= (buf & MSK_4) >> 3;  						BitStreamUtil.AssertMaxBits(availableBits' 3 * 8);  						if ((buf & MSB_4) != 0)  							// dammit' it's too large (probably negative)  							// fall back to the slow implementation' that's rare  							return BitStreamUtil.ReadProtobufVarIntStub(this);  						else Advance(4 * 8);  					} else Advance(3 * 8);  				} else Advance(2 * 8);  			} else Advance(1 * 8);
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,ReadProtobufVarInt,The following statement contains a magic number: if ((buf & MSB_1) != 0) {  				result |= (buf & MSK_2) >> 1;  				BitStreamUtil.AssertMaxBits(availableBits' 1 * 8);  				if ((buf & MSB_2) != 0) {  					result |= (buf & MSK_3) >> 2;  					BitStreamUtil.AssertMaxBits(availableBits' 2 * 8);  					if ((buf & MSB_3) != 0) {  						result |= (buf & MSK_4) >> 3;  						BitStreamUtil.AssertMaxBits(availableBits' 3 * 8);  						if ((buf & MSB_4) != 0)  							// dammit' it's too large (probably negative)  							// fall back to the slow implementation' that's rare  							return BitStreamUtil.ReadProtobufVarIntStub(this);  						else Advance(4 * 8);  					} else Advance(3 * 8);  				} else Advance(2 * 8);  			} else Advance(1 * 8);
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,ReadProtobufVarInt,The following statement contains a magic number: if ((buf & MSB_1) != 0) {  				result |= (buf & MSK_2) >> 1;  				BitStreamUtil.AssertMaxBits(availableBits' 1 * 8);  				if ((buf & MSB_2) != 0) {  					result |= (buf & MSK_3) >> 2;  					BitStreamUtil.AssertMaxBits(availableBits' 2 * 8);  					if ((buf & MSB_3) != 0) {  						result |= (buf & MSK_4) >> 3;  						BitStreamUtil.AssertMaxBits(availableBits' 3 * 8);  						if ((buf & MSB_4) != 0)  							// dammit' it's too large (probably negative)  							// fall back to the slow implementation' that's rare  							return BitStreamUtil.ReadProtobufVarIntStub(this);  						else Advance(4 * 8);  					} else Advance(3 * 8);  				} else Advance(2 * 8);  			} else Advance(1 * 8);
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,ReadProtobufVarInt,The following statement contains a magic number: if ((buf & MSB_1) != 0) {  				result |= (buf & MSK_2) >> 1;  				BitStreamUtil.AssertMaxBits(availableBits' 1 * 8);  				if ((buf & MSB_2) != 0) {  					result |= (buf & MSK_3) >> 2;  					BitStreamUtil.AssertMaxBits(availableBits' 2 * 8);  					if ((buf & MSB_3) != 0) {  						result |= (buf & MSK_4) >> 3;  						BitStreamUtil.AssertMaxBits(availableBits' 3 * 8);  						if ((buf & MSB_4) != 0)  							// dammit' it's too large (probably negative)  							// fall back to the slow implementation' that's rare  							return BitStreamUtil.ReadProtobufVarIntStub(this);  						else Advance(4 * 8);  					} else Advance(3 * 8);  				} else Advance(2 * 8);  			} else Advance(1 * 8);
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,ReadProtobufVarInt,The following statement contains a magic number: if ((buf & MSB_1) != 0) {  				result |= (buf & MSK_2) >> 1;  				BitStreamUtil.AssertMaxBits(availableBits' 1 * 8);  				if ((buf & MSB_2) != 0) {  					result |= (buf & MSK_3) >> 2;  					BitStreamUtil.AssertMaxBits(availableBits' 2 * 8);  					if ((buf & MSB_3) != 0) {  						result |= (buf & MSK_4) >> 3;  						BitStreamUtil.AssertMaxBits(availableBits' 3 * 8);  						if ((buf & MSB_4) != 0)  							// dammit' it's too large (probably negative)  							// fall back to the slow implementation' that's rare  							return BitStreamUtil.ReadProtobufVarIntStub(this);  						else Advance(4 * 8);  					} else Advance(3 * 8);  				} else Advance(2 * 8);  			} else Advance(1 * 8);
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,EndChunk,The following statement contains a magic number: if (delta < 0)  				throw new InvalidOperationException("Someone read beyond a chunk boundary");  			else if (delta > 0) {  				// so we need to skip stuff. fun.    				if (Underlying.CanSeek) {  					int bufferBits = BitsInBuffer - Offset;  					if ((bufferBits + (SLED * 8)) < delta) {  						int unbufferedSkipBits = delta - bufferBits;  						Underlying.Seek((unbufferedSkipBits >> 3) - SLED' SeekOrigin.Current);    						// Read at least 8 bytes' because we rely on that  						int offset' thisTime = 1337; // I'll cry if this ends up in the generated code  						for (offset = 0; (offset < 8) && (thisTime != 0); offset += thisTime)  							thisTime = Underlying.Read(Buffer' offset' BUFSIZE - offset);    						BitsInBuffer = 8 * (offset - SLED);    						if (thisTime == 0)  							// end of stream' so we can consume the sled now  							BitsInBuffer += SLED * 8;    						Offset = unbufferedSkipBits & 7;  						LazyGlobalPosition = target - Offset;  					} else  						// no need to efficiently skip' so just read and discard  						Advance(delta);  				} else  					// dammit' can't efficiently skip' so just read and discard  					Advance(delta);  			}
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,EndChunk,The following statement contains a magic number: if (delta < 0)  				throw new InvalidOperationException("Someone read beyond a chunk boundary");  			else if (delta > 0) {  				// so we need to skip stuff. fun.    				if (Underlying.CanSeek) {  					int bufferBits = BitsInBuffer - Offset;  					if ((bufferBits + (SLED * 8)) < delta) {  						int unbufferedSkipBits = delta - bufferBits;  						Underlying.Seek((unbufferedSkipBits >> 3) - SLED' SeekOrigin.Current);    						// Read at least 8 bytes' because we rely on that  						int offset' thisTime = 1337; // I'll cry if this ends up in the generated code  						for (offset = 0; (offset < 8) && (thisTime != 0); offset += thisTime)  							thisTime = Underlying.Read(Buffer' offset' BUFSIZE - offset);    						BitsInBuffer = 8 * (offset - SLED);    						if (thisTime == 0)  							// end of stream' so we can consume the sled now  							BitsInBuffer += SLED * 8;    						Offset = unbufferedSkipBits & 7;  						LazyGlobalPosition = target - Offset;  					} else  						// no need to efficiently skip' so just read and discard  						Advance(delta);  				} else  					// dammit' can't efficiently skip' so just read and discard  					Advance(delta);  			}
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,EndChunk,The following statement contains a magic number: if (delta < 0)  				throw new InvalidOperationException("Someone read beyond a chunk boundary");  			else if (delta > 0) {  				// so we need to skip stuff. fun.    				if (Underlying.CanSeek) {  					int bufferBits = BitsInBuffer - Offset;  					if ((bufferBits + (SLED * 8)) < delta) {  						int unbufferedSkipBits = delta - bufferBits;  						Underlying.Seek((unbufferedSkipBits >> 3) - SLED' SeekOrigin.Current);    						// Read at least 8 bytes' because we rely on that  						int offset' thisTime = 1337; // I'll cry if this ends up in the generated code  						for (offset = 0; (offset < 8) && (thisTime != 0); offset += thisTime)  							thisTime = Underlying.Read(Buffer' offset' BUFSIZE - offset);    						BitsInBuffer = 8 * (offset - SLED);    						if (thisTime == 0)  							// end of stream' so we can consume the sled now  							BitsInBuffer += SLED * 8;    						Offset = unbufferedSkipBits & 7;  						LazyGlobalPosition = target - Offset;  					} else  						// no need to efficiently skip' so just read and discard  						Advance(delta);  				} else  					// dammit' can't efficiently skip' so just read and discard  					Advance(delta);  			}
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,EndChunk,The following statement contains a magic number: if (delta < 0)  				throw new InvalidOperationException("Someone read beyond a chunk boundary");  			else if (delta > 0) {  				// so we need to skip stuff. fun.    				if (Underlying.CanSeek) {  					int bufferBits = BitsInBuffer - Offset;  					if ((bufferBits + (SLED * 8)) < delta) {  						int unbufferedSkipBits = delta - bufferBits;  						Underlying.Seek((unbufferedSkipBits >> 3) - SLED' SeekOrigin.Current);    						// Read at least 8 bytes' because we rely on that  						int offset' thisTime = 1337; // I'll cry if this ends up in the generated code  						for (offset = 0; (offset < 8) && (thisTime != 0); offset += thisTime)  							thisTime = Underlying.Read(Buffer' offset' BUFSIZE - offset);    						BitsInBuffer = 8 * (offset - SLED);    						if (thisTime == 0)  							// end of stream' so we can consume the sled now  							BitsInBuffer += SLED * 8;    						Offset = unbufferedSkipBits & 7;  						LazyGlobalPosition = target - Offset;  					} else  						// no need to efficiently skip' so just read and discard  						Advance(delta);  				} else  					// dammit' can't efficiently skip' so just read and discard  					Advance(delta);  			}
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,EndChunk,The following statement contains a magic number: if (delta < 0)  				throw new InvalidOperationException("Someone read beyond a chunk boundary");  			else if (delta > 0) {  				// so we need to skip stuff. fun.    				if (Underlying.CanSeek) {  					int bufferBits = BitsInBuffer - Offset;  					if ((bufferBits + (SLED * 8)) < delta) {  						int unbufferedSkipBits = delta - bufferBits;  						Underlying.Seek((unbufferedSkipBits >> 3) - SLED' SeekOrigin.Current);    						// Read at least 8 bytes' because we rely on that  						int offset' thisTime = 1337; // I'll cry if this ends up in the generated code  						for (offset = 0; (offset < 8) && (thisTime != 0); offset += thisTime)  							thisTime = Underlying.Read(Buffer' offset' BUFSIZE - offset);    						BitsInBuffer = 8 * (offset - SLED);    						if (thisTime == 0)  							// end of stream' so we can consume the sled now  							BitsInBuffer += SLED * 8;    						Offset = unbufferedSkipBits & 7;  						LazyGlobalPosition = target - Offset;  					} else  						// no need to efficiently skip' so just read and discard  						Advance(delta);  				} else  					// dammit' can't efficiently skip' so just read and discard  					Advance(delta);  			}
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,EndChunk,The following statement contains a magic number: if (delta < 0)  				throw new InvalidOperationException("Someone read beyond a chunk boundary");  			else if (delta > 0) {  				// so we need to skip stuff. fun.    				if (Underlying.CanSeek) {  					int bufferBits = BitsInBuffer - Offset;  					if ((bufferBits + (SLED * 8)) < delta) {  						int unbufferedSkipBits = delta - bufferBits;  						Underlying.Seek((unbufferedSkipBits >> 3) - SLED' SeekOrigin.Current);    						// Read at least 8 bytes' because we rely on that  						int offset' thisTime = 1337; // I'll cry if this ends up in the generated code  						for (offset = 0; (offset < 8) && (thisTime != 0); offset += thisTime)  							thisTime = Underlying.Read(Buffer' offset' BUFSIZE - offset);    						BitsInBuffer = 8 * (offset - SLED);    						if (thisTime == 0)  							// end of stream' so we can consume the sled now  							BitsInBuffer += SLED * 8;    						Offset = unbufferedSkipBits & 7;  						LazyGlobalPosition = target - Offset;  					} else  						// no need to efficiently skip' so just read and discard  						Advance(delta);  				} else  					// dammit' can't efficiently skip' so just read and discard  					Advance(delta);  			}
Magic Number,DemoInfo.BitStreamImpl,ManagedBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\ManagedBitStream.cs,EndChunk,The following statement contains a magic number: if (delta < 0)  				throw new InvalidOperationException("Someone read beyond a chunk boundary");  			else if (delta > 0) {  				// so we need to skip stuff. fun.    				if (Underlying.CanSeek) {  					int bufferBits = BitsInBuffer - Offset;  					if ((bufferBits + (SLED * 8)) < delta) {  						int unbufferedSkipBits = delta - bufferBits;  						Underlying.Seek((unbufferedSkipBits >> 3) - SLED' SeekOrigin.Current);    						// Read at least 8 bytes' because we rely on that  						int offset' thisTime = 1337; // I'll cry if this ends up in the generated code  						for (offset = 0; (offset < 8) && (thisTime != 0); offset += thisTime)  							thisTime = Underlying.Read(Buffer' offset' BUFSIZE - offset);    						BitsInBuffer = 8 * (offset - SLED);    						if (thisTime == 0)  							// end of stream' so we can consume the sled now  							BitsInBuffer += SLED * 8;    						Offset = unbufferedSkipBits & 7;  						LazyGlobalPosition = target - Offset;  					} else  						// no need to efficiently skip' so just read and discard  						Advance(delta);  				} else  					// dammit' can't efficiently skip' so just read and discard  					Advance(delta);  			}
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,Initialize,The following statement contains a magic number: Offset = SLED * 8;
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,RefillBuffer,The following statement contains a magic number: do {  				/*  				 * End of stream detection:  				 * These if clauses are kinda reversed' so this is how we're gonna do it:  				 * a) your average read:  				 *    None of them trigger. End of story.  				 * b) the first read into the last buffer:  				 *    the (thisTime == 0) down there fires  				 * c) the LAST read (end of stream follows):  				 *    the if (EndOfStream) fires' setting BitsInBuffer to 0 and zeroing out  				 *    the head of the buffer' so we read zeroes instead of random other stuff  				 * d) the (overflowing) read after the last read:  				 *    BitsInBuffer is 0 now' so we throw  				 *  				 * Just like chunking' this safety net has as little performance overhead as possible'  				 * at the cost of throwing later than it could (which can be too late in some  				 * scenarios; as in: you stop using the bitstream before it throws).  				 */  				if (EndOfStream) {  					if (BitsInBuffer == 0)  						throw new EndOfStreamException();    					/*  					 * Another late overrun detection:  					 * Offset SHOULD be < 0 after this.  					 * So Offset < BitsInBuffer.  					 * So we don't loop again.  					 * If it's not' we'll loop again which is exactly what we want  					 * as we overran the stream and wanna hit the throw above.  					 */  					Offset -= BitsInBuffer + 1;  					LazyGlobalPosition += BitsInBuffer + 1;  					*(uint*)PBuffer = 0; // safety  					BitsInBuffer = 0;  					continue;  				}    				// copy the sled  				*(uint*)PBuffer = *(uint*)(PBuffer + (BitsInBuffer >> 3));    				Offset -= BitsInBuffer;  				LazyGlobalPosition += BitsInBuffer;    				int offset' thisTime = 1337; // I'll cry if this ends up in the generated code  				for (offset = 0; (offset < 4) && (thisTime != 0); offset += thisTime)  					thisTime = Underlying.Read(Buffer' SLED + offset' BUFSIZE - SLED - offset);    				BitsInBuffer = 8 * offset;    				if (thisTime == 0) {  					// end of stream' so we can consume the sled now  					BitsInBuffer += SLED * 8;  					EndOfStream = true;  				}  			} while (Offset >= BitsInBuffer);
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,RefillBuffer,The following statement contains a magic number: do {  				/*  				 * End of stream detection:  				 * These if clauses are kinda reversed' so this is how we're gonna do it:  				 * a) your average read:  				 *    None of them trigger. End of story.  				 * b) the first read into the last buffer:  				 *    the (thisTime == 0) down there fires  				 * c) the LAST read (end of stream follows):  				 *    the if (EndOfStream) fires' setting BitsInBuffer to 0 and zeroing out  				 *    the head of the buffer' so we read zeroes instead of random other stuff  				 * d) the (overflowing) read after the last read:  				 *    BitsInBuffer is 0 now' so we throw  				 *  				 * Just like chunking' this safety net has as little performance overhead as possible'  				 * at the cost of throwing later than it could (which can be too late in some  				 * scenarios; as in: you stop using the bitstream before it throws).  				 */  				if (EndOfStream) {  					if (BitsInBuffer == 0)  						throw new EndOfStreamException();    					/*  					 * Another late overrun detection:  					 * Offset SHOULD be < 0 after this.  					 * So Offset < BitsInBuffer.  					 * So we don't loop again.  					 * If it's not' we'll loop again which is exactly what we want  					 * as we overran the stream and wanna hit the throw above.  					 */  					Offset -= BitsInBuffer + 1;  					LazyGlobalPosition += BitsInBuffer + 1;  					*(uint*)PBuffer = 0; // safety  					BitsInBuffer = 0;  					continue;  				}    				// copy the sled  				*(uint*)PBuffer = *(uint*)(PBuffer + (BitsInBuffer >> 3));    				Offset -= BitsInBuffer;  				LazyGlobalPosition += BitsInBuffer;    				int offset' thisTime = 1337; // I'll cry if this ends up in the generated code  				for (offset = 0; (offset < 4) && (thisTime != 0); offset += thisTime)  					thisTime = Underlying.Read(Buffer' SLED + offset' BUFSIZE - SLED - offset);    				BitsInBuffer = 8 * offset;    				if (thisTime == 0) {  					// end of stream' so we can consume the sled now  					BitsInBuffer += SLED * 8;  					EndOfStream = true;  				}  			} while (Offset >= BitsInBuffer);
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,RefillBuffer,The following statement contains a magic number: do {  				/*  				 * End of stream detection:  				 * These if clauses are kinda reversed' so this is how we're gonna do it:  				 * a) your average read:  				 *    None of them trigger. End of story.  				 * b) the first read into the last buffer:  				 *    the (thisTime == 0) down there fires  				 * c) the LAST read (end of stream follows):  				 *    the if (EndOfStream) fires' setting BitsInBuffer to 0 and zeroing out  				 *    the head of the buffer' so we read zeroes instead of random other stuff  				 * d) the (overflowing) read after the last read:  				 *    BitsInBuffer is 0 now' so we throw  				 *  				 * Just like chunking' this safety net has as little performance overhead as possible'  				 * at the cost of throwing later than it could (which can be too late in some  				 * scenarios; as in: you stop using the bitstream before it throws).  				 */  				if (EndOfStream) {  					if (BitsInBuffer == 0)  						throw new EndOfStreamException();    					/*  					 * Another late overrun detection:  					 * Offset SHOULD be < 0 after this.  					 * So Offset < BitsInBuffer.  					 * So we don't loop again.  					 * If it's not' we'll loop again which is exactly what we want  					 * as we overran the stream and wanna hit the throw above.  					 */  					Offset -= BitsInBuffer + 1;  					LazyGlobalPosition += BitsInBuffer + 1;  					*(uint*)PBuffer = 0; // safety  					BitsInBuffer = 0;  					continue;  				}    				// copy the sled  				*(uint*)PBuffer = *(uint*)(PBuffer + (BitsInBuffer >> 3));    				Offset -= BitsInBuffer;  				LazyGlobalPosition += BitsInBuffer;    				int offset' thisTime = 1337; // I'll cry if this ends up in the generated code  				for (offset = 0; (offset < 4) && (thisTime != 0); offset += thisTime)  					thisTime = Underlying.Read(Buffer' SLED + offset' BUFSIZE - SLED - offset);    				BitsInBuffer = 8 * offset;    				if (thisTime == 0) {  					// end of stream' so we can consume the sled now  					BitsInBuffer += SLED * 8;  					EndOfStream = true;  				}  			} while (Offset >= BitsInBuffer);
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,RefillBuffer,The following statement contains a magic number: do {  				/*  				 * End of stream detection:  				 * These if clauses are kinda reversed' so this is how we're gonna do it:  				 * a) your average read:  				 *    None of them trigger. End of story.  				 * b) the first read into the last buffer:  				 *    the (thisTime == 0) down there fires  				 * c) the LAST read (end of stream follows):  				 *    the if (EndOfStream) fires' setting BitsInBuffer to 0 and zeroing out  				 *    the head of the buffer' so we read zeroes instead of random other stuff  				 * d) the (overflowing) read after the last read:  				 *    BitsInBuffer is 0 now' so we throw  				 *  				 * Just like chunking' this safety net has as little performance overhead as possible'  				 * at the cost of throwing later than it could (which can be too late in some  				 * scenarios; as in: you stop using the bitstream before it throws).  				 */  				if (EndOfStream) {  					if (BitsInBuffer == 0)  						throw new EndOfStreamException();    					/*  					 * Another late overrun detection:  					 * Offset SHOULD be < 0 after this.  					 * So Offset < BitsInBuffer.  					 * So we don't loop again.  					 * If it's not' we'll loop again which is exactly what we want  					 * as we overran the stream and wanna hit the throw above.  					 */  					Offset -= BitsInBuffer + 1;  					LazyGlobalPosition += BitsInBuffer + 1;  					*(uint*)PBuffer = 0; // safety  					BitsInBuffer = 0;  					continue;  				}    				// copy the sled  				*(uint*)PBuffer = *(uint*)(PBuffer + (BitsInBuffer >> 3));    				Offset -= BitsInBuffer;  				LazyGlobalPosition += BitsInBuffer;    				int offset' thisTime = 1337; // I'll cry if this ends up in the generated code  				for (offset = 0; (offset < 4) && (thisTime != 0); offset += thisTime)  					thisTime = Underlying.Read(Buffer' SLED + offset' BUFSIZE - SLED - offset);    				BitsInBuffer = 8 * offset;    				if (thisTime == 0) {  					// end of stream' so we can consume the sled now  					BitsInBuffer += SLED * 8;  					EndOfStream = true;  				}  			} while (Offset >= BitsInBuffer);
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,RefillBuffer,The following statement contains a magic number: do {  				/*  				 * End of stream detection:  				 * These if clauses are kinda reversed' so this is how we're gonna do it:  				 * a) your average read:  				 *    None of them trigger. End of story.  				 * b) the first read into the last buffer:  				 *    the (thisTime == 0) down there fires  				 * c) the LAST read (end of stream follows):  				 *    the if (EndOfStream) fires' setting BitsInBuffer to 0 and zeroing out  				 *    the head of the buffer' so we read zeroes instead of random other stuff  				 * d) the (overflowing) read after the last read:  				 *    BitsInBuffer is 0 now' so we throw  				 *  				 * Just like chunking' this safety net has as little performance overhead as possible'  				 * at the cost of throwing later than it could (which can be too late in some  				 * scenarios; as in: you stop using the bitstream before it throws).  				 */  				if (EndOfStream) {  					if (BitsInBuffer == 0)  						throw new EndOfStreamException();    					/*  					 * Another late overrun detection:  					 * Offset SHOULD be < 0 after this.  					 * So Offset < BitsInBuffer.  					 * So we don't loop again.  					 * If it's not' we'll loop again which is exactly what we want  					 * as we overran the stream and wanna hit the throw above.  					 */  					Offset -= BitsInBuffer + 1;  					LazyGlobalPosition += BitsInBuffer + 1;  					*(uint*)PBuffer = 0; // safety  					BitsInBuffer = 0;  					continue;  				}    				// copy the sled  				*(uint*)PBuffer = *(uint*)(PBuffer + (BitsInBuffer >> 3));    				Offset -= BitsInBuffer;  				LazyGlobalPosition += BitsInBuffer;    				int offset' thisTime = 1337; // I'll cry if this ends up in the generated code  				for (offset = 0; (offset < 4) && (thisTime != 0); offset += thisTime)  					thisTime = Underlying.Read(Buffer' SLED + offset' BUFSIZE - SLED - offset);    				BitsInBuffer = 8 * offset;    				if (thisTime == 0) {  					// end of stream' so we can consume the sled now  					BitsInBuffer += SLED * 8;  					EndOfStream = true;  				}  			} while (Offset >= BitsInBuffer);
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,PeekInt,The following statement contains a magic number: BitStreamUtil.AssertMaxBits(32' numBits);
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,PeekInt,The following statement contains a magic number: Debug.Assert(mayOverflow || ((Offset + numBits) <= (BitsInBuffer + (SLED * 8)))' "gg"' "This code just fell apart. We're all dead. Offset={0} numBits={1} BitsInBuffer={2}"' Offset' numBits' BitsInBuffer);
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,PeekInt,The following statement contains a magic number: return (uint)(((*(ulong*)(PBuffer + ((Offset >> 3) & ~3))) << ((8 * 8) - ((Offset & ((8 * 4) - 1))) - numBits)) >> ((8 * 8) - numBits));
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,PeekInt,The following statement contains a magic number: return (uint)(((*(ulong*)(PBuffer + ((Offset >> 3) & ~3))) << ((8 * 8) - ((Offset & ((8 * 4) - 1))) - numBits)) >> ((8 * 8) - numBits));
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,PeekInt,The following statement contains a magic number: return (uint)(((*(ulong*)(PBuffer + ((Offset >> 3) & ~3))) << ((8 * 8) - ((Offset & ((8 * 4) - 1))) - numBits)) >> ((8 * 8) - numBits));
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,PeekInt,The following statement contains a magic number: return (uint)(((*(ulong*)(PBuffer + ((Offset >> 3) & ~3))) << ((8 * 8) - ((Offset & ((8 * 4) - 1))) - numBits)) >> ((8 * 8) - numBits));
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,PeekInt,The following statement contains a magic number: return (uint)(((*(ulong*)(PBuffer + ((Offset >> 3) & ~3))) << ((8 * 8) - ((Offset & ((8 * 4) - 1))) - numBits)) >> ((8 * 8) - numBits));
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,PeekInt,The following statement contains a magic number: return (uint)(((*(ulong*)(PBuffer + ((Offset >> 3) & ~3))) << ((8 * 8) - ((Offset & ((8 * 4) - 1))) - numBits)) >> ((8 * 8) - numBits));
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,PeekInt,The following statement contains a magic number: return (uint)(((*(ulong*)(PBuffer + ((Offset >> 3) & ~3))) << ((8 * 8) - ((Offset & ((8 * 4) - 1))) - numBits)) >> ((8 * 8) - numBits));
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,PeekInt,The following statement contains a magic number: return (uint)(((*(ulong*)(PBuffer + ((Offset >> 3) & ~3))) << ((8 * 8) - ((Offset & ((8 * 4) - 1))) - numBits)) >> ((8 * 8) - numBits));
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadBit,The following statement contains a magic number: bool bit = (PBuffer[Offset >> 3] & (1 << (Offset & 7))) != 0;
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadBit,The following statement contains a magic number: bool bit = (PBuffer[Offset >> 3] & (1 << (Offset & 7))) != 0;
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadByte,The following statement contains a magic number: var ret = (byte)PeekInt(8);
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadByte,The following statement contains a magic number: if (TryAdvance(8)) RefillBuffer();
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadByte,The following statement contains a magic number: BitStreamUtil.AssertMaxBits(8' bits);
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadBytes,The following statement contains a magic number: if (bytes < 3) {  				for (int i = 0; i < bytes; i++)  					ret[i] = ReadByte();  			} else if ((Offset & 7) == 0) {  				// zomg we have byte alignment  				int offset = 0;  				while (offset < bytes) {  					int remainingBytes = Math.Min((BitsInBuffer - Offset) >> 3' bytes - offset);  					System.Buffer.BlockCopy(Buffer' Offset >> 3' ret' offset' remainingBytes);  					offset += remainingBytes;  					if (TryAdvance(remainingBytes * 8)) RefillBuffer();  				}  			} else fixed (byte* retptr = ret) {  				int offset = 0;  				while (offset < bytes) {  					int remainingBytes = Math.Min(((BitsInBuffer - Offset) >> 3) + 1' bytes - offset);  					HyperspeedCopyRound(remainingBytes' retptr + offset);  					offset += remainingBytes;  				}  			}
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadBytes,The following statement contains a magic number: if (bytes < 3) {  				for (int i = 0; i < bytes; i++)  					ret[i] = ReadByte();  			} else if ((Offset & 7) == 0) {  				// zomg we have byte alignment  				int offset = 0;  				while (offset < bytes) {  					int remainingBytes = Math.Min((BitsInBuffer - Offset) >> 3' bytes - offset);  					System.Buffer.BlockCopy(Buffer' Offset >> 3' ret' offset' remainingBytes);  					offset += remainingBytes;  					if (TryAdvance(remainingBytes * 8)) RefillBuffer();  				}  			} else fixed (byte* retptr = ret) {  				int offset = 0;  				while (offset < bytes) {  					int remainingBytes = Math.Min(((BitsInBuffer - Offset) >> 3) + 1' bytes - offset);  					HyperspeedCopyRound(remainingBytes' retptr + offset);  					offset += remainingBytes;  				}  			}
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadBytes,The following statement contains a magic number: if (bytes < 3) {  				for (int i = 0; i < bytes; i++)  					ret[i] = ReadByte();  			} else if ((Offset & 7) == 0) {  				// zomg we have byte alignment  				int offset = 0;  				while (offset < bytes) {  					int remainingBytes = Math.Min((BitsInBuffer - Offset) >> 3' bytes - offset);  					System.Buffer.BlockCopy(Buffer' Offset >> 3' ret' offset' remainingBytes);  					offset += remainingBytes;  					if (TryAdvance(remainingBytes * 8)) RefillBuffer();  				}  			} else fixed (byte* retptr = ret) {  				int offset = 0;  				while (offset < bytes) {  					int remainingBytes = Math.Min(((BitsInBuffer - Offset) >> 3) + 1' bytes - offset);  					HyperspeedCopyRound(remainingBytes' retptr + offset);  					offset += remainingBytes;  				}  			}
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadBytes,The following statement contains a magic number: if (bytes < 3) {  				for (int i = 0; i < bytes; i++)  					ret[i] = ReadByte();  			} else if ((Offset & 7) == 0) {  				// zomg we have byte alignment  				int offset = 0;  				while (offset < bytes) {  					int remainingBytes = Math.Min((BitsInBuffer - Offset) >> 3' bytes - offset);  					System.Buffer.BlockCopy(Buffer' Offset >> 3' ret' offset' remainingBytes);  					offset += remainingBytes;  					if (TryAdvance(remainingBytes * 8)) RefillBuffer();  				}  			} else fixed (byte* retptr = ret) {  				int offset = 0;  				while (offset < bytes) {  					int remainingBytes = Math.Min(((BitsInBuffer - Offset) >> 3) + 1' bytes - offset);  					HyperspeedCopyRound(remainingBytes' retptr + offset);  					offset += remainingBytes;  				}  			}
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadBytes,The following statement contains a magic number: if (bytes < 3) {  				for (int i = 0; i < bytes; i++)  					ret[i] = ReadByte();  			} else if ((Offset & 7) == 0) {  				// zomg we have byte alignment  				int offset = 0;  				while (offset < bytes) {  					int remainingBytes = Math.Min((BitsInBuffer - Offset) >> 3' bytes - offset);  					System.Buffer.BlockCopy(Buffer' Offset >> 3' ret' offset' remainingBytes);  					offset += remainingBytes;  					if (TryAdvance(remainingBytes * 8)) RefillBuffer();  				}  			} else fixed (byte* retptr = ret) {  				int offset = 0;  				while (offset < bytes) {  					int remainingBytes = Math.Min(((BitsInBuffer - Offset) >> 3) + 1' bytes - offset);  					HyperspeedCopyRound(remainingBytes' retptr + offset);  					offset += remainingBytes;  				}  			}
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadBytes,The following statement contains a magic number: if (bytes < 3) {  				for (int i = 0; i < bytes; i++)  					ret[i] = ReadByte();  			} else if ((Offset & 7) == 0) {  				// zomg we have byte alignment  				int offset = 0;  				while (offset < bytes) {  					int remainingBytes = Math.Min((BitsInBuffer - Offset) >> 3' bytes - offset);  					System.Buffer.BlockCopy(Buffer' Offset >> 3' ret' offset' remainingBytes);  					offset += remainingBytes;  					if (TryAdvance(remainingBytes * 8)) RefillBuffer();  				}  			} else fixed (byte* retptr = ret) {  				int offset = 0;  				while (offset < bytes) {  					int remainingBytes = Math.Min(((BitsInBuffer - Offset) >> 3) + 1' bytes - offset);  					HyperspeedCopyRound(remainingBytes' retptr + offset);  					offset += remainingBytes;  				}  			}
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,HyperspeedCopyRound,The following statement contains a magic number: int misalign = 8 - (Offset & 7);
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,HyperspeedCopyRound,The following statement contains a magic number: int misalign = 8 - (Offset & 7);
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,HyperspeedCopyRound,The following statement contains a magic number: int realign = sizeof(ulong) * 8 - misalign;
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,HyperspeedCopyRound,The following statement contains a magic number: var inptr = (ulong*)(PBuffer + (Offset >> 3));
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,HyperspeedCopyRound,The following statement contains a magic number: Offset += (bytes - rest - 1) * 8;
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,HyperspeedCopyRound,The following statement contains a magic number: bout[0] = (byte)((ReadInt(8 - misalign) << misalign) | step);
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadSignedInt,The following statement contains a magic number: BitStreamUtil.AssertMaxBits(32' numBits);
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadSignedInt,The following statement contains a magic number: var result = (int)(((long)((*(ulong*)(PBuffer + ((Offset >> 3) & ~3))) << ((8 * 8) - (Offset & ((8 * 4) - 1)) - numBits))) >> ((8 * 8) - numBits));
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadSignedInt,The following statement contains a magic number: var result = (int)(((long)((*(ulong*)(PBuffer + ((Offset >> 3) & ~3))) << ((8 * 8) - (Offset & ((8 * 4) - 1)) - numBits))) >> ((8 * 8) - numBits));
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadSignedInt,The following statement contains a magic number: var result = (int)(((long)((*(ulong*)(PBuffer + ((Offset >> 3) & ~3))) << ((8 * 8) - (Offset & ((8 * 4) - 1)) - numBits))) >> ((8 * 8) - numBits));
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadSignedInt,The following statement contains a magic number: var result = (int)(((long)((*(ulong*)(PBuffer + ((Offset >> 3) & ~3))) << ((8 * 8) - (Offset & ((8 * 4) - 1)) - numBits))) >> ((8 * 8) - numBits));
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadSignedInt,The following statement contains a magic number: var result = (int)(((long)((*(ulong*)(PBuffer + ((Offset >> 3) & ~3))) << ((8 * 8) - (Offset & ((8 * 4) - 1)) - numBits))) >> ((8 * 8) - numBits));
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadSignedInt,The following statement contains a magic number: var result = (int)(((long)((*(ulong*)(PBuffer + ((Offset >> 3) & ~3))) << ((8 * 8) - (Offset & ((8 * 4) - 1)) - numBits))) >> ((8 * 8) - numBits));
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadSignedInt,The following statement contains a magic number: var result = (int)(((long)((*(ulong*)(PBuffer + ((Offset >> 3) & ~3))) << ((8 * 8) - (Offset & ((8 * 4) - 1)) - numBits))) >> ((8 * 8) - numBits));
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadSignedInt,The following statement contains a magic number: var result = (int)(((long)((*(ulong*)(PBuffer + ((Offset >> 3) & ~3))) << ((8 * 8) - (Offset & ((8 * 4) - 1)) - numBits))) >> ((8 * 8) - numBits));
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadFloat,The following statement contains a magic number: uint iResult = PeekInt(32);
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadFloat,The following statement contains a magic number: if (TryAdvance(32)) RefillBuffer();
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadBits,The following statement contains a magic number: byte[] result = new byte[(bits + 7) >> 3];
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadBits,The following statement contains a magic number: byte[] result = new byte[(bits + 7) >> 3];
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadBits,The following statement contains a magic number: ReadBytes(result' bits >> 3);
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadBits,The following statement contains a magic number: if ((bits & 7) != 0)  				result[bits >> 3] = ReadByte(bits & 7);
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadBits,The following statement contains a magic number: if ((bits & 7) != 0)  				result[bits >> 3] = ReadByte(bits & 7);
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadBits,The following statement contains a magic number: if ((bits & 7) != 0)  				result[bits >> 3] = ReadByte(bits & 7);
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadProtobufVarInt,The following statement contains a magic number: var availableBits = BitsInBuffer + (SLED * 8) - Offset;
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadProtobufVarInt,The following statement contains a magic number: uint buf = PeekInt(32' true);
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadProtobufVarInt,The following statement contains a magic number: BitStreamUtil.AssertMaxBits(availableBits' 1 * 8);
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadProtobufVarInt,The following statement contains a magic number: if ((buf & MSB_1) != 0) {  				result |= (buf & MSK_2) >> 1;  				BitStreamUtil.AssertMaxBits(availableBits' 1 * 8);  				if ((buf & MSB_2) != 0) {  					result |= (buf & MSK_3) >> 2;  					BitStreamUtil.AssertMaxBits(availableBits' 2 * 8);  					if ((buf & MSB_3) != 0) {  						result |= (buf & MSK_4) >> 3;  						BitStreamUtil.AssertMaxBits(availableBits' 3 * 8);  						if ((buf & MSB_4) != 0)  							// dammit' it's too large (probably negative)  							// fall back to the slow implementation' that's rare  							return BitStreamUtil.ReadProtobufVarIntStub(this);  						else if (TryAdvance(4 * 8)) RefillBuffer();  					} else if (TryAdvance(3 * 8)) RefillBuffer();  				} else if (TryAdvance(2 * 8)) RefillBuffer();  			} else if (TryAdvance(1 * 8)) RefillBuffer();
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadProtobufVarInt,The following statement contains a magic number: if ((buf & MSB_1) != 0) {  				result |= (buf & MSK_2) >> 1;  				BitStreamUtil.AssertMaxBits(availableBits' 1 * 8);  				if ((buf & MSB_2) != 0) {  					result |= (buf & MSK_3) >> 2;  					BitStreamUtil.AssertMaxBits(availableBits' 2 * 8);  					if ((buf & MSB_3) != 0) {  						result |= (buf & MSK_4) >> 3;  						BitStreamUtil.AssertMaxBits(availableBits' 3 * 8);  						if ((buf & MSB_4) != 0)  							// dammit' it's too large (probably negative)  							// fall back to the slow implementation' that's rare  							return BitStreamUtil.ReadProtobufVarIntStub(this);  						else if (TryAdvance(4 * 8)) RefillBuffer();  					} else if (TryAdvance(3 * 8)) RefillBuffer();  				} else if (TryAdvance(2 * 8)) RefillBuffer();  			} else if (TryAdvance(1 * 8)) RefillBuffer();
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadProtobufVarInt,The following statement contains a magic number: if ((buf & MSB_1) != 0) {  				result |= (buf & MSK_2) >> 1;  				BitStreamUtil.AssertMaxBits(availableBits' 1 * 8);  				if ((buf & MSB_2) != 0) {  					result |= (buf & MSK_3) >> 2;  					BitStreamUtil.AssertMaxBits(availableBits' 2 * 8);  					if ((buf & MSB_3) != 0) {  						result |= (buf & MSK_4) >> 3;  						BitStreamUtil.AssertMaxBits(availableBits' 3 * 8);  						if ((buf & MSB_4) != 0)  							// dammit' it's too large (probably negative)  							// fall back to the slow implementation' that's rare  							return BitStreamUtil.ReadProtobufVarIntStub(this);  						else if (TryAdvance(4 * 8)) RefillBuffer();  					} else if (TryAdvance(3 * 8)) RefillBuffer();  				} else if (TryAdvance(2 * 8)) RefillBuffer();  			} else if (TryAdvance(1 * 8)) RefillBuffer();
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadProtobufVarInt,The following statement contains a magic number: if ((buf & MSB_1) != 0) {  				result |= (buf & MSK_2) >> 1;  				BitStreamUtil.AssertMaxBits(availableBits' 1 * 8);  				if ((buf & MSB_2) != 0) {  					result |= (buf & MSK_3) >> 2;  					BitStreamUtil.AssertMaxBits(availableBits' 2 * 8);  					if ((buf & MSB_3) != 0) {  						result |= (buf & MSK_4) >> 3;  						BitStreamUtil.AssertMaxBits(availableBits' 3 * 8);  						if ((buf & MSB_4) != 0)  							// dammit' it's too large (probably negative)  							// fall back to the slow implementation' that's rare  							return BitStreamUtil.ReadProtobufVarIntStub(this);  						else if (TryAdvance(4 * 8)) RefillBuffer();  					} else if (TryAdvance(3 * 8)) RefillBuffer();  				} else if (TryAdvance(2 * 8)) RefillBuffer();  			} else if (TryAdvance(1 * 8)) RefillBuffer();
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadProtobufVarInt,The following statement contains a magic number: if ((buf & MSB_1) != 0) {  				result |= (buf & MSK_2) >> 1;  				BitStreamUtil.AssertMaxBits(availableBits' 1 * 8);  				if ((buf & MSB_2) != 0) {  					result |= (buf & MSK_3) >> 2;  					BitStreamUtil.AssertMaxBits(availableBits' 2 * 8);  					if ((buf & MSB_3) != 0) {  						result |= (buf & MSK_4) >> 3;  						BitStreamUtil.AssertMaxBits(availableBits' 3 * 8);  						if ((buf & MSB_4) != 0)  							// dammit' it's too large (probably negative)  							// fall back to the slow implementation' that's rare  							return BitStreamUtil.ReadProtobufVarIntStub(this);  						else if (TryAdvance(4 * 8)) RefillBuffer();  					} else if (TryAdvance(3 * 8)) RefillBuffer();  				} else if (TryAdvance(2 * 8)) RefillBuffer();  			} else if (TryAdvance(1 * 8)) RefillBuffer();
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadProtobufVarInt,The following statement contains a magic number: if ((buf & MSB_1) != 0) {  				result |= (buf & MSK_2) >> 1;  				BitStreamUtil.AssertMaxBits(availableBits' 1 * 8);  				if ((buf & MSB_2) != 0) {  					result |= (buf & MSK_3) >> 2;  					BitStreamUtil.AssertMaxBits(availableBits' 2 * 8);  					if ((buf & MSB_3) != 0) {  						result |= (buf & MSK_4) >> 3;  						BitStreamUtil.AssertMaxBits(availableBits' 3 * 8);  						if ((buf & MSB_4) != 0)  							// dammit' it's too large (probably negative)  							// fall back to the slow implementation' that's rare  							return BitStreamUtil.ReadProtobufVarIntStub(this);  						else if (TryAdvance(4 * 8)) RefillBuffer();  					} else if (TryAdvance(3 * 8)) RefillBuffer();  				} else if (TryAdvance(2 * 8)) RefillBuffer();  			} else if (TryAdvance(1 * 8)) RefillBuffer();
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadProtobufVarInt,The following statement contains a magic number: if ((buf & MSB_1) != 0) {  				result |= (buf & MSK_2) >> 1;  				BitStreamUtil.AssertMaxBits(availableBits' 1 * 8);  				if ((buf & MSB_2) != 0) {  					result |= (buf & MSK_3) >> 2;  					BitStreamUtil.AssertMaxBits(availableBits' 2 * 8);  					if ((buf & MSB_3) != 0) {  						result |= (buf & MSK_4) >> 3;  						BitStreamUtil.AssertMaxBits(availableBits' 3 * 8);  						if ((buf & MSB_4) != 0)  							// dammit' it's too large (probably negative)  							// fall back to the slow implementation' that's rare  							return BitStreamUtil.ReadProtobufVarIntStub(this);  						else if (TryAdvance(4 * 8)) RefillBuffer();  					} else if (TryAdvance(3 * 8)) RefillBuffer();  				} else if (TryAdvance(2 * 8)) RefillBuffer();  			} else if (TryAdvance(1 * 8)) RefillBuffer();
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadProtobufVarInt,The following statement contains a magic number: if ((buf & MSB_1) != 0) {  				result |= (buf & MSK_2) >> 1;  				BitStreamUtil.AssertMaxBits(availableBits' 1 * 8);  				if ((buf & MSB_2) != 0) {  					result |= (buf & MSK_3) >> 2;  					BitStreamUtil.AssertMaxBits(availableBits' 2 * 8);  					if ((buf & MSB_3) != 0) {  						result |= (buf & MSK_4) >> 3;  						BitStreamUtil.AssertMaxBits(availableBits' 3 * 8);  						if ((buf & MSB_4) != 0)  							// dammit' it's too large (probably negative)  							// fall back to the slow implementation' that's rare  							return BitStreamUtil.ReadProtobufVarIntStub(this);  						else if (TryAdvance(4 * 8)) RefillBuffer();  					} else if (TryAdvance(3 * 8)) RefillBuffer();  				} else if (TryAdvance(2 * 8)) RefillBuffer();  			} else if (TryAdvance(1 * 8)) RefillBuffer();
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadProtobufVarInt,The following statement contains a magic number: if ((buf & MSB_1) != 0) {  				result |= (buf & MSK_2) >> 1;  				BitStreamUtil.AssertMaxBits(availableBits' 1 * 8);  				if ((buf & MSB_2) != 0) {  					result |= (buf & MSK_3) >> 2;  					BitStreamUtil.AssertMaxBits(availableBits' 2 * 8);  					if ((buf & MSB_3) != 0) {  						result |= (buf & MSK_4) >> 3;  						BitStreamUtil.AssertMaxBits(availableBits' 3 * 8);  						if ((buf & MSB_4) != 0)  							// dammit' it's too large (probably negative)  							// fall back to the slow implementation' that's rare  							return BitStreamUtil.ReadProtobufVarIntStub(this);  						else if (TryAdvance(4 * 8)) RefillBuffer();  					} else if (TryAdvance(3 * 8)) RefillBuffer();  				} else if (TryAdvance(2 * 8)) RefillBuffer();  			} else if (TryAdvance(1 * 8)) RefillBuffer();
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadProtobufVarInt,The following statement contains a magic number: if ((buf & MSB_1) != 0) {  				result |= (buf & MSK_2) >> 1;  				BitStreamUtil.AssertMaxBits(availableBits' 1 * 8);  				if ((buf & MSB_2) != 0) {  					result |= (buf & MSK_3) >> 2;  					BitStreamUtil.AssertMaxBits(availableBits' 2 * 8);  					if ((buf & MSB_3) != 0) {  						result |= (buf & MSK_4) >> 3;  						BitStreamUtil.AssertMaxBits(availableBits' 3 * 8);  						if ((buf & MSB_4) != 0)  							// dammit' it's too large (probably negative)  							// fall back to the slow implementation' that's rare  							return BitStreamUtil.ReadProtobufVarIntStub(this);  						else if (TryAdvance(4 * 8)) RefillBuffer();  					} else if (TryAdvance(3 * 8)) RefillBuffer();  				} else if (TryAdvance(2 * 8)) RefillBuffer();  			} else if (TryAdvance(1 * 8)) RefillBuffer();
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadProtobufVarInt,The following statement contains a magic number: if ((buf & MSB_1) != 0) {  				result |= (buf & MSK_2) >> 1;  				BitStreamUtil.AssertMaxBits(availableBits' 1 * 8);  				if ((buf & MSB_2) != 0) {  					result |= (buf & MSK_3) >> 2;  					BitStreamUtil.AssertMaxBits(availableBits' 2 * 8);  					if ((buf & MSB_3) != 0) {  						result |= (buf & MSK_4) >> 3;  						BitStreamUtil.AssertMaxBits(availableBits' 3 * 8);  						if ((buf & MSB_4) != 0)  							// dammit' it's too large (probably negative)  							// fall back to the slow implementation' that's rare  							return BitStreamUtil.ReadProtobufVarIntStub(this);  						else if (TryAdvance(4 * 8)) RefillBuffer();  					} else if (TryAdvance(3 * 8)) RefillBuffer();  				} else if (TryAdvance(2 * 8)) RefillBuffer();  			} else if (TryAdvance(1 * 8)) RefillBuffer();
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadProtobufVarInt,The following statement contains a magic number: if ((buf & MSB_1) != 0) {  				result |= (buf & MSK_2) >> 1;  				BitStreamUtil.AssertMaxBits(availableBits' 1 * 8);  				if ((buf & MSB_2) != 0) {  					result |= (buf & MSK_3) >> 2;  					BitStreamUtil.AssertMaxBits(availableBits' 2 * 8);  					if ((buf & MSB_3) != 0) {  						result |= (buf & MSK_4) >> 3;  						BitStreamUtil.AssertMaxBits(availableBits' 3 * 8);  						if ((buf & MSB_4) != 0)  							// dammit' it's too large (probably negative)  							// fall back to the slow implementation' that's rare  							return BitStreamUtil.ReadProtobufVarIntStub(this);  						else if (TryAdvance(4 * 8)) RefillBuffer();  					} else if (TryAdvance(3 * 8)) RefillBuffer();  				} else if (TryAdvance(2 * 8)) RefillBuffer();  			} else if (TryAdvance(1 * 8)) RefillBuffer();
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadProtobufVarInt,The following statement contains a magic number: if ((buf & MSB_1) != 0) {  				result |= (buf & MSK_2) >> 1;  				BitStreamUtil.AssertMaxBits(availableBits' 1 * 8);  				if ((buf & MSB_2) != 0) {  					result |= (buf & MSK_3) >> 2;  					BitStreamUtil.AssertMaxBits(availableBits' 2 * 8);  					if ((buf & MSB_3) != 0) {  						result |= (buf & MSK_4) >> 3;  						BitStreamUtil.AssertMaxBits(availableBits' 3 * 8);  						if ((buf & MSB_4) != 0)  							// dammit' it's too large (probably negative)  							// fall back to the slow implementation' that's rare  							return BitStreamUtil.ReadProtobufVarIntStub(this);  						else if (TryAdvance(4 * 8)) RefillBuffer();  					} else if (TryAdvance(3 * 8)) RefillBuffer();  				} else if (TryAdvance(2 * 8)) RefillBuffer();  			} else if (TryAdvance(1 * 8)) RefillBuffer();
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,ReadProtobufVarInt,The following statement contains a magic number: if ((buf & MSB_1) != 0) {  				result |= (buf & MSK_2) >> 1;  				BitStreamUtil.AssertMaxBits(availableBits' 1 * 8);  				if ((buf & MSB_2) != 0) {  					result |= (buf & MSK_3) >> 2;  					BitStreamUtil.AssertMaxBits(availableBits' 2 * 8);  					if ((buf & MSB_3) != 0) {  						result |= (buf & MSK_4) >> 3;  						BitStreamUtil.AssertMaxBits(availableBits' 3 * 8);  						if ((buf & MSB_4) != 0)  							// dammit' it's too large (probably negative)  							// fall back to the slow implementation' that's rare  							return BitStreamUtil.ReadProtobufVarIntStub(this);  						else if (TryAdvance(4 * 8)) RefillBuffer();  					} else if (TryAdvance(3 * 8)) RefillBuffer();  				} else if (TryAdvance(2 * 8)) RefillBuffer();  			} else if (TryAdvance(1 * 8)) RefillBuffer();
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,EndChunk,The following statement contains a magic number: if (delta < 0)  				throw new InvalidOperationException("Someone read beyond a chunk boundary");  			else if (delta > 0) {  				// so we need to skip stuff. fun.    				if (Underlying.CanSeek) {  					int bufferBits = BitsInBuffer - Offset;  					if ((bufferBits + (SLED * 8)) < delta) {  						if (EndOfStream)  							throw new EndOfStreamException();    						int unbufferedSkipBits = delta - bufferBits;  						Underlying.Seek((unbufferedSkipBits >> 3) - SLED' SeekOrigin.Current);    						// Read at least 8 bytes' because we rely on that  						int offset' thisTime = 1337; // I'll cry if this ends up in the generated code  						for (offset = 0; (offset < 8) && (thisTime != 0); offset += thisTime)  							thisTime = Underlying.Read(Buffer' offset' BUFSIZE - offset);    						BitsInBuffer = 8 * (offset - SLED);    						if (thisTime == 0) {  							// end of stream' so we can consume the sled now  							BitsInBuffer += SLED * 8;  							EndOfStream = true;  						}    						Offset = unbufferedSkipBits & 7;  						LazyGlobalPosition = target - Offset;  					} else  						// no need to efficiently skip' so just read and discard  						if (TryAdvance(delta)) RefillBuffer();  				} else  					// dammit' can't efficiently skip' so just read and discard  					if (TryAdvance(delta)) RefillBuffer();  			}
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,EndChunk,The following statement contains a magic number: if (delta < 0)  				throw new InvalidOperationException("Someone read beyond a chunk boundary");  			else if (delta > 0) {  				// so we need to skip stuff. fun.    				if (Underlying.CanSeek) {  					int bufferBits = BitsInBuffer - Offset;  					if ((bufferBits + (SLED * 8)) < delta) {  						if (EndOfStream)  							throw new EndOfStreamException();    						int unbufferedSkipBits = delta - bufferBits;  						Underlying.Seek((unbufferedSkipBits >> 3) - SLED' SeekOrigin.Current);    						// Read at least 8 bytes' because we rely on that  						int offset' thisTime = 1337; // I'll cry if this ends up in the generated code  						for (offset = 0; (offset < 8) && (thisTime != 0); offset += thisTime)  							thisTime = Underlying.Read(Buffer' offset' BUFSIZE - offset);    						BitsInBuffer = 8 * (offset - SLED);    						if (thisTime == 0) {  							// end of stream' so we can consume the sled now  							BitsInBuffer += SLED * 8;  							EndOfStream = true;  						}    						Offset = unbufferedSkipBits & 7;  						LazyGlobalPosition = target - Offset;  					} else  						// no need to efficiently skip' so just read and discard  						if (TryAdvance(delta)) RefillBuffer();  				} else  					// dammit' can't efficiently skip' so just read and discard  					if (TryAdvance(delta)) RefillBuffer();  			}
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,EndChunk,The following statement contains a magic number: if (delta < 0)  				throw new InvalidOperationException("Someone read beyond a chunk boundary");  			else if (delta > 0) {  				// so we need to skip stuff. fun.    				if (Underlying.CanSeek) {  					int bufferBits = BitsInBuffer - Offset;  					if ((bufferBits + (SLED * 8)) < delta) {  						if (EndOfStream)  							throw new EndOfStreamException();    						int unbufferedSkipBits = delta - bufferBits;  						Underlying.Seek((unbufferedSkipBits >> 3) - SLED' SeekOrigin.Current);    						// Read at least 8 bytes' because we rely on that  						int offset' thisTime = 1337; // I'll cry if this ends up in the generated code  						for (offset = 0; (offset < 8) && (thisTime != 0); offset += thisTime)  							thisTime = Underlying.Read(Buffer' offset' BUFSIZE - offset);    						BitsInBuffer = 8 * (offset - SLED);    						if (thisTime == 0) {  							// end of stream' so we can consume the sled now  							BitsInBuffer += SLED * 8;  							EndOfStream = true;  						}    						Offset = unbufferedSkipBits & 7;  						LazyGlobalPosition = target - Offset;  					} else  						// no need to efficiently skip' so just read and discard  						if (TryAdvance(delta)) RefillBuffer();  				} else  					// dammit' can't efficiently skip' so just read and discard  					if (TryAdvance(delta)) RefillBuffer();  			}
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,EndChunk,The following statement contains a magic number: if (delta < 0)  				throw new InvalidOperationException("Someone read beyond a chunk boundary");  			else if (delta > 0) {  				// so we need to skip stuff. fun.    				if (Underlying.CanSeek) {  					int bufferBits = BitsInBuffer - Offset;  					if ((bufferBits + (SLED * 8)) < delta) {  						if (EndOfStream)  							throw new EndOfStreamException();    						int unbufferedSkipBits = delta - bufferBits;  						Underlying.Seek((unbufferedSkipBits >> 3) - SLED' SeekOrigin.Current);    						// Read at least 8 bytes' because we rely on that  						int offset' thisTime = 1337; // I'll cry if this ends up in the generated code  						for (offset = 0; (offset < 8) && (thisTime != 0); offset += thisTime)  							thisTime = Underlying.Read(Buffer' offset' BUFSIZE - offset);    						BitsInBuffer = 8 * (offset - SLED);    						if (thisTime == 0) {  							// end of stream' so we can consume the sled now  							BitsInBuffer += SLED * 8;  							EndOfStream = true;  						}    						Offset = unbufferedSkipBits & 7;  						LazyGlobalPosition = target - Offset;  					} else  						// no need to efficiently skip' so just read and discard  						if (TryAdvance(delta)) RefillBuffer();  				} else  					// dammit' can't efficiently skip' so just read and discard  					if (TryAdvance(delta)) RefillBuffer();  			}
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,EndChunk,The following statement contains a magic number: if (delta < 0)  				throw new InvalidOperationException("Someone read beyond a chunk boundary");  			else if (delta > 0) {  				// so we need to skip stuff. fun.    				if (Underlying.CanSeek) {  					int bufferBits = BitsInBuffer - Offset;  					if ((bufferBits + (SLED * 8)) < delta) {  						if (EndOfStream)  							throw new EndOfStreamException();    						int unbufferedSkipBits = delta - bufferBits;  						Underlying.Seek((unbufferedSkipBits >> 3) - SLED' SeekOrigin.Current);    						// Read at least 8 bytes' because we rely on that  						int offset' thisTime = 1337; // I'll cry if this ends up in the generated code  						for (offset = 0; (offset < 8) && (thisTime != 0); offset += thisTime)  							thisTime = Underlying.Read(Buffer' offset' BUFSIZE - offset);    						BitsInBuffer = 8 * (offset - SLED);    						if (thisTime == 0) {  							// end of stream' so we can consume the sled now  							BitsInBuffer += SLED * 8;  							EndOfStream = true;  						}    						Offset = unbufferedSkipBits & 7;  						LazyGlobalPosition = target - Offset;  					} else  						// no need to efficiently skip' so just read and discard  						if (TryAdvance(delta)) RefillBuffer();  				} else  					// dammit' can't efficiently skip' so just read and discard  					if (TryAdvance(delta)) RefillBuffer();  			}
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,EndChunk,The following statement contains a magic number: if (delta < 0)  				throw new InvalidOperationException("Someone read beyond a chunk boundary");  			else if (delta > 0) {  				// so we need to skip stuff. fun.    				if (Underlying.CanSeek) {  					int bufferBits = BitsInBuffer - Offset;  					if ((bufferBits + (SLED * 8)) < delta) {  						if (EndOfStream)  							throw new EndOfStreamException();    						int unbufferedSkipBits = delta - bufferBits;  						Underlying.Seek((unbufferedSkipBits >> 3) - SLED' SeekOrigin.Current);    						// Read at least 8 bytes' because we rely on that  						int offset' thisTime = 1337; // I'll cry if this ends up in the generated code  						for (offset = 0; (offset < 8) && (thisTime != 0); offset += thisTime)  							thisTime = Underlying.Read(Buffer' offset' BUFSIZE - offset);    						BitsInBuffer = 8 * (offset - SLED);    						if (thisTime == 0) {  							// end of stream' so we can consume the sled now  							BitsInBuffer += SLED * 8;  							EndOfStream = true;  						}    						Offset = unbufferedSkipBits & 7;  						LazyGlobalPosition = target - Offset;  					} else  						// no need to efficiently skip' so just read and discard  						if (TryAdvance(delta)) RefillBuffer();  				} else  					// dammit' can't efficiently skip' so just read and discard  					if (TryAdvance(delta)) RefillBuffer();  			}
Magic Number,DemoInfo.BitStreamImpl,UnsafeBitStream,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\UnsafeBitStream.cs,EndChunk,The following statement contains a magic number: if (delta < 0)  				throw new InvalidOperationException("Someone read beyond a chunk boundary");  			else if (delta > 0) {  				// so we need to skip stuff. fun.    				if (Underlying.CanSeek) {  					int bufferBits = BitsInBuffer - Offset;  					if ((bufferBits + (SLED * 8)) < delta) {  						if (EndOfStream)  							throw new EndOfStreamException();    						int unbufferedSkipBits = delta - bufferBits;  						Underlying.Seek((unbufferedSkipBits >> 3) - SLED' SeekOrigin.Current);    						// Read at least 8 bytes' because we rely on that  						int offset' thisTime = 1337; // I'll cry if this ends up in the generated code  						for (offset = 0; (offset < 8) && (thisTime != 0); offset += thisTime)  							thisTime = Underlying.Read(Buffer' offset' BUFSIZE - offset);    						BitsInBuffer = 8 * (offset - SLED);    						if (thisTime == 0) {  							// end of stream' so we can consume the sled now  							BitsInBuffer += SLED * 8;  							EndOfStream = true;  						}    						Offset = unbufferedSkipBits & 7;  						LazyGlobalPosition = target - Offset;  					} else  						// no need to efficiently skip' so just read and discard  						if (TryAdvance(delta)) RefillBuffer();  				} else  					// dammit' can't efficiently skip' so just read and discard  					if (TryAdvance(delta)) RefillBuffer();  			}
Missing Default,DemoInfo,BitStreamUtil,C:\repos\EHVAG_demoinfo\DemoInfo\BitStream\BitStreamUtil.cs,ReadUBitInt,The following switch statement is missing a default case: switch (ret & (16 | 32))  			{  			case 16:  				ret = (ret & 15) | (bs.ReadInt(4) << 4);  				break;  			case 32:  				ret = (ret & 15) | (bs.ReadInt(8) << 4);  				break;  			case 48:  				ret = (ret & 15) | (bs.ReadInt(32 - 4) << 4);  				break;  			}
Missing Default,DemoInfo.DP,Entity,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Entity.cs,ReadFieldIndex,The following switch statement is missing a default case: switch (ret & ( 32 | 64 )) {  				case 32:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(2) << 5 );  					break;  				case 64:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(4) << 5 );  					break;  				case 96:  					ret = ( ret & ~96 ) | ( (int)reader.ReadInt(7) << 5 );  					break;  				}
Missing Default,DemoInfo.DP.FastNetmessages,UserMessage,C:\repos\EHVAG_demoinfo\DemoInfo\DP\FastNetmessages\UserMessage.cs,Parse,The following switch statement is missing a default case: switch (MsgType)  						{  							// This is where you can add others UserMessage parsing logic  							case (int)User_Messages.um_SayText:  								new SayText().Parse(bitstream' parser);  								break;  							case (int)User_Messages.um_SayText2:  								new SayText2().Parse(bitstream' parser);  								break;  							case (int)User_Messages.um_ServerRankUpdate:  								new ServerRankUpdate().Parse(bitstream' parser);  								break;  						}
Missing Default,DemoInfo.DP.Handler,GameEventHandler,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Handler\GameEventHandler.cs,Apply,The following switch statement is missing a default case: switch (eventDescriptor.Name) {  			case "weapon_fire":    				data = MapData (eventDescriptor' rawEvent);    				WeaponFiredEventArgs fire = new WeaponFiredEventArgs ();  				fire.Shooter = parser.Players.ContainsKey ((int)data ["userid"]) ? parser.Players [(int)data ["userid"]] : null;  				fire.Weapon = new Equipment ((string)data ["weapon"]);    				if (fire.Shooter != null && fire.Shooter.ActiveWeapon != null && fire.Weapon.Class != EquipmentClass.Grenade) {  					fire.Weapon = fire.Shooter.ActiveWeapon;  				}    				parser.RaiseWeaponFired(fire);  				break;  			case "player_death":  				data = MapData(eventDescriptor' rawEvent);    				PlayerKilledEventArgs kill = new PlayerKilledEventArgs();                    kill.Victim = parser.Players.ContainsKey((int)data["userid"]) ? parser.Players[(int)data["userid"]] : null;  				kill.Killer = parser.Players.ContainsKey((int)data["attacker"]) ? parser.Players[(int)data["attacker"]] : null;  				kill.Assister = parser.Players.ContainsKey((int)data["assister"]) ? parser.Players[(int)data["assister"]] : null;  				kill.Headshot = (bool)data["headshot"];  				kill.Weapon = new Equipment((string)data["weapon"]' (string)data["weapon_itemid"]);    				if (kill.Killer != null && kill.Weapon.Class != EquipmentClass.Grenade  						&& kill.Weapon.Weapon != EquipmentElement.Revolver  						&& kill.Killer.Weapons.Any() && kill.Weapon.Weapon != EquipmentElement.World) {  					#if DEBUG  					if(kill.Weapon.Weapon != kill.Killer.ActiveWeapon.Weapon)  						throw new InvalidDataException();  					#endif  					kill.Weapon = kill.Killer.ActiveWeapon;  				}      				kill.PenetratedObjects = (int)data["penetrated"];    				parser.RaisePlayerKilled(kill);  				break;  			case "player_hurt":  				data = MapData (eventDescriptor' rawEvent);    				PlayerHurtEventArgs hurt = new PlayerHurtEventArgs ();  				hurt.Player = parser.Players.ContainsKey ((int)data ["userid"]) ? parser.Players [(int)data ["userid"]] : null;  				hurt.Attacker = parser.Players.ContainsKey ((int)data ["attacker"]) ? parser.Players [(int)data ["attacker"]] : null;  				hurt.Health = (int)data ["health"];  				hurt.Armor = (int)data ["armor"];  				hurt.HealthDamage = (int)data ["dmg_health"];  				hurt.ArmorDamage = (int)data ["dmg_armor"];  				hurt.Hitgroup = (Hitgroup)((int)data ["hitgroup"]);    				hurt.Weapon = new Equipment ((string)data ["weapon"]' "");    				if (hurt.Attacker != null && hurt.Weapon.Class != EquipmentClass.Grenade && hurt.Attacker.Weapons.Any ()) {  					hurt.Weapon = hurt.Attacker.ActiveWeapon;  				}    				parser.RaisePlayerHurt (hurt);  				break;    				#region Nades  			case "player_blind":  				data = MapData(eventDescriptor' rawEvent);    				if (parser.Players.ContainsKey((int)data["userid"])) {  					var blindPlayer = parser.Players.ContainsKey((int)data["userid"]) ? parser.Players[(int)data["userid"]] : null;    					if (blindPlayer != null && blindPlayer.Team != Team.Spectate)  					{  						BlindEventArgs blind = new BlindEventArgs();  						blind.Player = blindPlayer;  						if (data.ContainsKey("attacker") && parser.Players.ContainsKey((int)data["attacker"])) {  							blind.Attacker = parser.Players[(int)data["attacker"]];  						} else {  							blind.Attacker = null;  						}    						if (data.ContainsKey("blind_duration"))  							blind.FlashDuration = (float?)data["blind_duration"];  						else  							blind.FlashDuration = null;    						parser.RaiseBlind(blind);  					}    					//previous blind implementation  					blindPlayers.Add(parser.Players[(int)data["userid"]]);  				}    				break;  			case "flashbang_detonate":  				var args = FillNadeEvent<FlashEventArgs>(MapData(eventDescriptor' rawEvent)' parser);  				args.FlashedPlayers = blindPlayers.ToArray(); //prev blind implementation  				parser.RaiseFlashExploded(args);  				blindPlayers.Clear(); //prev blind implementation  				break;  			case "hegrenade_detonate":  				parser.RaiseGrenadeExploded(FillNadeEvent<GrenadeEventArgs>(MapData(eventDescriptor' rawEvent)' parser));  				break;  			case "decoy_started":  				parser.RaiseDecoyStart(FillNadeEvent<DecoyEventArgs>(MapData(eventDescriptor' rawEvent)' parser));  				break;  			case "decoy_detonate":  				parser.RaiseDecoyEnd(FillNadeEvent<DecoyEventArgs>(MapData(eventDescriptor' rawEvent)' parser));  				break;  			case "smokegrenade_detonate":  				parser.RaiseSmokeStart(FillNadeEvent<SmokeEventArgs>(MapData(eventDescriptor' rawEvent)' parser));  				break;  			case "smokegrenade_expired":  				parser.RaiseSmokeEnd(FillNadeEvent<SmokeEventArgs>(MapData(eventDescriptor' rawEvent)' parser));  				break;  			case "inferno_startburn":  				parser.RaiseFireStart(FillNadeEvent<FireEventArgs>(MapData(eventDescriptor' rawEvent)' parser));  				break;  			case "inferno_expire":  				parser.RaiseFireEnd(FillNadeEvent<FireEventArgs>(MapData(eventDescriptor' rawEvent)' parser));  				break;  				#endregion  			  			case "player_connect":  				data = MapData (eventDescriptor' rawEvent);    				PlayerInfo player = new PlayerInfo ();  				player.UserID = (int)data ["userid"];  				player.Name = (string)data ["name"];  				player.GUID = (string)data ["networkid"];  				player.XUID = player.GUID == "BOT" ? 0 : GetCommunityID (player.GUID);      				//player.IsFakePlayer = (bool)data["bot"];    				int index = (int)data["index"];    				parser.RawPlayers[index] = player;      				break;  			case "player_disconnect":  				data = MapData(eventDescriptor' rawEvent);    				PlayerDisconnectEventArgs disconnect = new PlayerDisconnectEventArgs();  				disconnect.Player = parser.Players.ContainsKey((int)data["userid"]) ? parser.Players[(int)data["userid"]] : null;  				parser.RaisePlayerDisconnect(disconnect);    				int toDelete = (int)data["userid"];  				for (int i = 0; i < parser.RawPlayers.Length; i++) {    					if (parser.RawPlayers[i] != null && parser.RawPlayers[i].UserID == toDelete) {  						parser.RawPlayers[i] = null;  						break;  					}  				}    				if (parser.Players.ContainsKey(toDelete))  				{  					parser.Players.Remove(toDelete);  				}    				break;    			case "player_team":  				data = MapData(eventDescriptor' rawEvent);  				PlayerTeamEventArgs playerTeamEvent = new PlayerTeamEventArgs();    				Team t = Team.Spectate;    				int team = (int)data["team"];    				if (team == parser.tID)  					t = Team.Terrorist;  				else if (team == parser.ctID)  					t = Team.CounterTerrorist;  				playerTeamEvent.NewTeam = t;    				t = Team.Spectate;  				team = (int)data["oldteam"];  				if (team == parser.tID)  					t = Team.Terrorist;  				else if (team == parser.ctID)  					t = Team.CounterTerrorist;  				playerTeamEvent.OldTeam = t;    				playerTeamEvent.Swapped = parser.Players.ContainsKey((int)data["userid"]) ? parser.Players[(int)data["userid"]] : null;  				playerTeamEvent.IsBot = (bool)data["isbot"];  				playerTeamEvent.Silent = (bool)data["silent"];    				parser.RaisePlayerTeam(playerTeamEvent);  				break;  			case "bomb_beginplant": //When the bomb is starting to get planted  			case "bomb_abortplant": //When the bomb planter stops planting the bomb  			case "bomb_planted": //When the bomb has been planted  			case "bomb_defused": //When the bomb has been defused  			case "bomb_exploded": //When the bomb has exploded  				data = MapData(eventDescriptor' rawEvent);    				var bombEventArgs = new BombEventArgs();                  bombEventArgs.Player = parser.Players.ContainsKey((int)data["userid"]) ? parser.Players[(int)data["userid"]] : null;    				int site = (int)data["site"];    				if (site == parser.bombsiteAIndex) {  					bombEventArgs.Site = 'A';  				} else if (site == parser.bombsiteBIndex) {  					bombEventArgs.Site = 'B';  				} else {  					var relevantTrigger = parser.triggers.Single(a => a.Index == site);  					if (relevantTrigger.Contains(parser.bombsiteACenter)) {  						//planted at A.  						bombEventArgs.Site = 'A';  						parser.bombsiteAIndex = site;  					} else {  						//planted at B.  						bombEventArgs.Site = 'B';  						parser.bombsiteBIndex = site;  					}   				}          				switch (eventDescriptor.Name) {  				case "bomb_beginplant":  					parser.RaiseBombBeginPlant(bombEventArgs);  					break;  				case "bomb_abortplant":  					parser.RaiseBombAbortPlant(bombEventArgs);  					break;  				case "bomb_planted":  					parser.RaiseBombPlanted(bombEventArgs);  					break;  				case "bomb_defused":  					parser.RaiseBombDefused(bombEventArgs);  					break;  				case "bomb_exploded":  					parser.RaiseBombExploded(bombEventArgs);  					break;  				}    				break;  			case "bomb_begindefuse":  				data = MapData(eventDescriptor' rawEvent);  				var e = new BombDefuseEventArgs();                  e.Player = parser.Players.ContainsKey((int)data["userid"]) ? parser.Players[(int)data["userid"]] : null;  				e.HasKit = (bool)data["haskit"];  				parser.RaiseBombBeginDefuse(e);  				break;  			case "bomb_abortdefuse":  				data = MapData(eventDescriptor' rawEvent);  				var e2 = new BombDefuseEventArgs();                  e2.Player = parser.Players.ContainsKey((int)data["userid"]) ? parser.Players[(int)data["userid"]] : null;  				e2.HasKit = e2.Player.HasDefuseKit;  				parser.RaiseBombAbortDefuse(e2);  				break;  			}
Missing Default,DemoInfo.DP.Handler,GameEventHandler,C:\repos\EHVAG_demoinfo\DemoInfo\DP\Handler\GameEventHandler.cs,Apply,The following switch statement is missing a default case: switch (eventDescriptor.Name) {  				case "bomb_beginplant":  					parser.RaiseBombBeginPlant(bombEventArgs);  					break;  				case "bomb_abortplant":  					parser.RaiseBombAbortPlant(bombEventArgs);  					break;  				case "bomb_planted":  					parser.RaiseBombPlanted(bombEventArgs);  					break;  				case "bomb_defused":  					parser.RaiseBombDefused(bombEventArgs);  					break;  				case "bomb_exploded":  					parser.RaiseBombExploded(bombEventArgs);  					break;  				}
