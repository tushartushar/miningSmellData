Implementation smell,Namespace,Class,File,Method,Description
Long Method,Portfish,Benchmark,C:\repos\bpfliegel_Portfish\src\Benchmark.cs,benchmark,The method has 103 lines of code.
Long Method,Portfish,Book,C:\repos\bpfliegel_Portfish\src\Book.cs,probe,The method has 141 lines of code.
Long Method,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRPKR,The method has 101 lines of code.
Long Method,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,do_evaluate,The method has 122 lines of code.
Long Method,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The method has 240 lines of code.
Long Method,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_king,The method has 196 lines of code.
Long Method,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_unstoppable_pawns,The method has 136 lines of code.
Long Method,Portfish,MaterialTable,C:\repos\bpfliegel_Portfish\src\Material.cs,probe,The method has 136 lines of code.
Long Method,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,from_fen,The method has 122 lines of code.
Long Method,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,do_move,The method has 190 lines of code.
Long Method,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,pos_is_ok,The method has 114 lines of code.
Long Method,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,id_loop,The method has 172 lines of code.
Long Method,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The method has 664 lines of code.
Long Method,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,qsearch,The method has 201 lines of code.
Long Method,Portfish,Thread,C:\repos\bpfliegel_Portfish\src\Thread.cs,idle_loop,The method has 129 lines of code.
Long Method,Portfish,Uci,C:\repos\bpfliegel_Portfish\src\Uci.cs,uci_loop,The method has 120 lines of code.
Long Method,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,init,The method has 121 lines of code.
Complex Method,Portfish,KPKPosition,C:\repos\bpfliegel_Portfish\src\Bitbase.cs,init,Cyclomatic complexity of the method is 8
Complex Method,Portfish,KPKPosition,C:\repos\bpfliegel_Portfish\src\Bitbase.cs,classify_leaf,Cyclomatic complexity of the method is 9
Complex Method,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRPKR,Cyclomatic complexity of the method is 13
Complex Method,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,Cyclomatic complexity of the method is 27
Complex Method,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_king,Cyclomatic complexity of the method is 12
Complex Method,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_unstoppable_pawns,Cyclomatic complexity of the method is 19
Complex Method,Portfish,MaterialTable,C:\repos\bpfliegel_Portfish\src\Material.cs,probe,Cyclomatic complexity of the method is 17
Complex Method,Portfish,Movegen,C:\repos\bpfliegel_Portfish\src\Movegen.cs,generate_pawn_moves,Cyclomatic complexity of the method is 16
Complex Method,Portfish,BrokerManager,C:\repos\bpfliegel_Portfish\src\ObjectBroker.cs,Warmup,Cyclomatic complexity of the method is 21
Complex Method,Portfish,PawnTable,C:\repos\bpfliegel_Portfish\src\PawnInfo.cs,evaluate_pawns,Cyclomatic complexity of the method is 13
Complex Method,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,from_fen,Cyclomatic complexity of the method is 12
Complex Method,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,to_fen,Cyclomatic complexity of the method is 11
Complex Method,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,is_pseudo_legal,Cyclomatic complexity of the method is 13
Complex Method,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,move_gives_check,Cyclomatic complexity of the method is 8
Complex Method,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,do_move,Cyclomatic complexity of the method is 13
Complex Method,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,init,Cyclomatic complexity of the method is 10
Complex Method,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,flip,Cyclomatic complexity of the method is 8
Complex Method,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,pos_is_ok,Cyclomatic complexity of the method is 40
Complex Method,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,init,Cyclomatic complexity of the method is 8
Complex Method,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,id_loop,Cyclomatic complexity of the method is 16
Complex Method,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,Cyclomatic complexity of the method is 71
Complex Method,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,qsearch,Cyclomatic complexity of the method is 18
Complex Method,Portfish,Thread,C:\repos\bpfliegel_Portfish\src\Thread.cs,idle_loop,Cyclomatic complexity of the method is 10
Complex Method,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,init,Cyclomatic complexity of the method is 25
Long Parameter List,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The method has 5 parameters. Parameters: Us' Trace' pos' ei' mobility
Long Parameter List,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_king,The method has 6 parameters. Parameters: Us' Trace' pos' ei' marginsWHITE' marginsBLACK
Long Parameter List,Portfish,Movegen,C:\repos\bpfliegel_Portfish\src\Movegen.cs,generate_castle,The method has 6 parameters. Parameters: Side' OnlyChecks' pos' ms' mpos' us
Long Parameter List,Portfish,Movegen,C:\repos\bpfliegel_Portfish\src\Movegen.cs,generate_promotions,The method has 7 parameters. Parameters: Type' Delta' ms' mpos' pawnsOn7' target' ksq
Long Parameter List,Portfish,Movegen,C:\repos\bpfliegel_Portfish\src\Movegen.cs,generate_pawn_moves,The method has 7 parameters. Parameters: Us' Type' pos' ms' mpos' target' ksq
Long Parameter List,Portfish,Movegen,C:\repos\bpfliegel_Portfish\src\Movegen.cs,generate_direct_checks,The method has 6 parameters. Parameters: Pt' pos' ms' mpos' us' ci
Long Parameter List,Portfish,Movegen,C:\repos\bpfliegel_Portfish\src\Movegen.cs,generate_king_moves,The method has 5 parameters. Parameters: pos' ms' mpos' us' target
Long Parameter List,Portfish,Movegen,C:\repos\bpfliegel_Portfish\src\Movegen.cs,generate_moves,The method has 5 parameters. Parameters: pos' ms' mpos' us' target
Long Parameter List,Portfish,MovePicker,C:\repos\bpfliegel_Portfish\src\MovePicker.cs,MovePickerC,The method has 7 parameters. Parameters: p' ttm' d' h' ss' beta' mpExt
Long Parameter List,Portfish,MovePicker,C:\repos\bpfliegel_Portfish\src\MovePicker.cs,MovePickerC,The method has 5 parameters. Parameters: p' ttm' d' h' sq
Long Parameter List,Portfish,PawnTable,C:\repos\bpfliegel_Portfish\src\PawnInfo.cs,evaluate_pawns,The method has 5 parameters. Parameters: Us' pos' ourPawns' theirPawns' e
Long Parameter List,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The method has 7 parameters. Parameters: NT' pos' ss' ssPos' alpha' beta' depth
Long Parameter List,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,qsearch,The method has 7 parameters. Parameters: NT' pos' ss' ssPos' alpha' beta' depth
Long Parameter List,Portfish,Threads,C:\repos\bpfliegel_Portfish\src\Thread.cs,split,The method has 13 parameters. Parameters: Fake' pos' ss' ssPos' alpha' beta' bestValue' bestMove' depth' threatMove' moveCount' mp' nodeType
Long Parameter List,Portfish,TimeMgr,C:\repos\bpfliegel_Portfish\src\Timeman.cs,remaining,The method has 5 parameters. Parameters: T' myTime' movesToGo' currentPly' slowMover
Long Parameter List,Portfish,TTEntry,C:\repos\bpfliegel_Portfish\src\TT.cs,save,The method has 8 parameters. Parameters: k' v' t' d' m' g' statV' statM
Long Parameter List,Portfish,TT,C:\repos\bpfliegel_Portfish\src\TT.cs,store,The method has 7 parameters. Parameters: posKey' v' t' d' m' statV' kingD
Long Parameter List,Portfish,UCIOption,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,UCIOption,The method has 5 parameters. Parameters: index' v' minv' maxv' fn
Long Parameter List,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,init_magics,The method has 7 parameters. Parameters: Pt' attacks' magics' masks' shifts' deltas' index
Long Identifier,Portfish,MaterialTable,C:\repos\bpfliegel_Portfish\src\Material.cs,,The length of the parameter QuadraticCoefficientsSameColor is 30.
Long Identifier,Portfish,MaterialTable,C:\repos\bpfliegel_Portfish\src\Material.cs,,The length of the parameter QuadraticCoefficientsOppositeColor is 34.
Long Statement,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KQKRPs,The length of the statement  "                && ((pos.pieces_PTC(PieceTypeC.ROOK' weakerSide) & Utils.rank_bb_R(Utils.relative_rank_CR(weakerSide' RankC.RANK_3))) != 0) " is 123.
Long Statement,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KQKRPs,The length of the statement  "                && ((pos.pieces_PTC(PieceTypeC.PAWN' weakerSide) & Utils.rank_bb_R(Utils.relative_rank_CR(weakerSide' RankC.RANK_2))) != 0) " is 123.
Long Statement,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRPKR,The length of the statement  "                && (Utils.square_distance(wksq' wpsq + SquareC.DELTA_N) < Utils.square_distance(bksq' wpsq + SquareC.DELTA_N) - 2 + tempo) " is 122.
Long Statement,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KPKP,The length of the statement  "            return (KPKPosition.probe_kpk_bitbase(wksq' wpsq' bksq' stm) != 0) ? ScaleFactorC.SCALE_FACTOR_NONE : ScaleFactorC.SCALE_FACTOR_DRAW; " is 133.
Long Statement,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,init,The length of the statement  "            Weights[EvalWeightC.Mobility] = weight_option("Mobility (Middle Game)"' "Mobility (Endgame)"' WeightsInternal[EvalWeightC.Mobility]); " is 133.
Long Statement,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,init,The length of the statement  "            Weights[EvalWeightC.PassedPawns] = weight_option("Passed Pawns (Middle Game)"' "Passed Pawns (Endgame)"' WeightsInternal[EvalWeightC.PassedPawns]); " is 147.
Long Statement,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,init,The length of the statement  "            Weights[EvalWeightC.KingDangerThem] = weight_option("Aggressiveness"' "Aggressiveness"' WeightsInternal[EvalWeightC.KingDangerThem]); " is 133.
Long Statement,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,init,The length of the statement  "                Weights[EvalWeightC.KingDangerUs] = Weights[EvalWeightC.KingDangerThem] = (Weights[EvalWeightC.KingDangerUs] + Weights[EvalWeightC.KingDangerThem]) / 2; " is 152.
Long Statement,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,do_evaluate,The length of the statement  "                ((((int)(((((mobilityWhite - mobilityBlack) + 32768) & ~0xffff) / 0x10000)) * (((Weights[EvalWeightC.Mobility] + 32768) & ~0xffff) / 0x10000)) / 0x100) << 16) + " is 160.
Long Statement,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,do_evaluate,The length of the statement  "                (((int)(((Int16)((mobilityWhite - mobilityBlack) & 0xffff))) * ((Int16)(Weights[EvalWeightC.Mobility] & 0xffff))) / 0x100) " is 122.
Long Statement,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,do_evaluate,The length of the statement  "            score += evaluate_king(ColorC.WHITE' Trace' pos' ei' ref marginsWHITE' ref marginsBLACK) - evaluate_king(ColorC.BLACK' Trace' pos' ei' ref marginsWHITE' ref marginsBLACK); " is 171.
Long Statement,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,do_evaluate,The length of the statement  "                score += (((((int)((((((s * ei.mi.spaceWeight) << 16) + 32768) & ~0xffff) / 0x10000)) * (((Weights[EvalWeightC.Space] + 32768) & ~0xffff) / 0x10000)) / 0x100) << 16)  " is 165.
Long Statement,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,do_evaluate,The length of the statement  "                    + (((int)(((Int16)(((s * ei.mi.spaceWeight) << 16) & 0xffff))) * ((Int16)(Weights[EvalWeightC.Space] & 0xffff))) / 0x100)); " is 123.
Long Statement,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,do_evaluate,The length of the statement  "            ScaleFactor sf = ((Int16)(score & 0xffff)) > ValueC.VALUE_DRAW ? ei.mi.scale_factor_WHITE(pos) : ei.mi.scale_factor_BLACK(pos); " is 127.
Long Statement,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,do_evaluate,The length of the statement  "                    (((((pos.pieceList[ColorC.WHITE][PieceTypeC.BISHOP][0] ^ pos.pieceList[ColorC.BLACK][PieceTypeC.BISHOP][0]) >> 3) ^ (pos.pieceList[ColorC.WHITE][PieceTypeC.BISHOP][0] ^ pos.pieceList[ColorC.BLACK][PieceTypeC.BISHOP][0])) & 1) != 0) " is 231.
Long Statement,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,do_evaluate,The length of the statement  "            int result = ((((score + 32768) & ~0xffff) / 0x10000) * (int)(ei.mi.gamePhase) + ev * (int)(128 - ei.mi.gamePhase)) / 128; " is 122.
Long Statement,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,do_evaluate,The length of the statement  "                trace_add(TracedTypeC.MOBILITY' Utils.apply_weight(mobilityWhite' Weights[EvalWeightC.Mobility])' Utils.apply_weight(mobilityBlack' Weights[EvalWeightC.Mobility])); " is 164.
Long Statement,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,do_evaluate,The length of the statement  "                trace_add(TracedTypeC.PASSED' evaluate_passed_pawns(ColorC.WHITE' pos' ei)' evaluate_passed_pawns(ColorC.BLACK' pos' ei)); " is 122.
Long Statement,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,do_evaluate,The length of the statement  "                trace_add(TracedTypeC.SPACE' Utils.apply_weight(w' Weights[EvalWeightC.Space])' Utils.apply_weight(b' Weights[EvalWeightC.Space])); " is 131.
Long Statement,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,init_eval_info,The length of the statement  "                && (Us == 0 ? pos.st.npMaterialWHITE : pos.st.npMaterialBLACK) >= Constants.QueenValueMidgame + Constants.RookValueMidgame) " is 123.
Long Statement,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The length of the statement  "                        b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])]; " is 212.
Long Statement,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The length of the statement  "                    mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea)); " is 127.
Long Statement,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The length of the statement  "                            score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7]; " is 125.
Long Statement,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The length of the statement  "                                (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0) " is 165.
Long Statement,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The length of the statement  "                        bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0; " is 126.
Long Statement,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The length of the statement  "                                    if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0) " is 154.
Long Statement,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The length of the statement  "                                        score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16); " is 160.
Long Statement,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The length of the statement  "                                    if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0) " is 140.
Long Statement,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The length of the statement  "                                        score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16); " is 160.
Long Statement,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_king,The length of the statement  "                b1 = (Utils.RAttacks[ksq][(((pos.occupied_squares & Utils.RMasks[ksq]) * Utils.RMagics[ksq]) >> Utils.RShifts[ksq])]) & safe; " is 125.
Long Statement,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_king,The length of the statement  "                b2 = (Utils.BAttacks[ksq][(((pos.occupied_squares & Utils.BMasks[ksq]) * Utils.BMagics[ksq]) >> Utils.BShifts[ksq])]) & safe; " is 125.
Long Statement,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_passed_pawns,The length of the statement  "                        ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)] * rr); " is 145.
Long Statement,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_passed_pawns,The length of the statement  "                            ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them])) != 0) " is 124.
Long Statement,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_passed_pawns,The length of the statement  "                            ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) & pos.attacks_from_ROOK(s)) != 0) " is 151.
Long Statement,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_unstoppable_pawns,The length of the statement  "                    oppMovesToGo = Utils.square_distance(pos.king_square(Utils.flip_C(c))' queeningSquare) - ((c != pos.sideToMove) ? 1 : 0); " is 121.
Long Statement,Portfish,MaterialTable,C:\repos\bpfliegel_Portfish\src\Material.cs,probe,The length of the statement  "            if ((pos.pieces_PT(PieceTypeC.PAWN) == 0) && (pos.pieces_PT(PieceTypeC.ROOK) == 0) && (pos.pieces_PT(PieceTypeC.QUEEN) == 0)) " is 125.
Long Statement,Portfish,MaterialTable,C:\repos\bpfliegel_Portfish\src\Material.cs,probe,The length of the statement  "                (npm_w == npm_b || npm_w < Constants.RookValueMidgame ? 0 : NoPawnsSF[Math.Min(pos.piece_count(ColorC.WHITE' PieceTypeC.BISHOP)' 2)]); " is 134.
Long Statement,Portfish,MaterialTable,C:\repos\bpfliegel_Portfish\src\Material.cs,probe,The length of the statement  "                (npm_w == npm_b || npm_b < Constants.RookValueMidgame ? 0 : NoPawnsSF[Math.Min(pos.piece_count(ColorC.BLACK' PieceTypeC.BISHOP)' 2)]); " is 134.
Long Statement,Portfish,MaterialTable,C:\repos\bpfliegel_Portfish\src\Material.cs,probe,The length of the statement  "            if (npm_w + npm_b >= 2 * Constants.QueenValueMidgame + 4 * Constants.RookValueMidgame + 2 * Constants.KnightValueMidgame) " is 121.
Long Statement,Portfish,MaterialTable,C:\repos\bpfliegel_Portfish\src\Material.cs,probe,The length of the statement  "                int minorPieceCount = pos.piece_count(ColorC.WHITE' PieceTypeC.KNIGHT) + pos.piece_count(ColorC.WHITE' PieceTypeC.BISHOP) " is 121.
Long Statement,Portfish,Movegen,C:\repos\bpfliegel_Portfish\src\Movegen.cs,generate_moves,The length of the statement  "                        if (pieceType == PieceTypeC.BISHOP) { b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] & target; } " is 156.
Long Statement,Portfish,Movegen,C:\repos\bpfliegel_Portfish\src\Movegen.cs,generate_moves,The length of the statement  "                        else if (pieceType == PieceTypeC.ROOK) { b = Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])] & target; } " is 159.
Long Statement,Portfish,Movegen,C:\repos\bpfliegel_Portfish\src\Movegen.cs,generate_moves,The length of the statement  "                        else if (pieceType == PieceTypeC.QUEEN) { b = (Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])]) & target; } " is 267.
Long Statement,Portfish,Movegen,C:\repos\bpfliegel_Portfish\src\Movegen.cs,generate_moves,The length of the statement  "                        else if (pieceType == PieceTypeC.QUEEN) { b = (Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares)) & target; } " is 157.
Long Statement,Portfish,Movegen,C:\repos\bpfliegel_Portfish\src\Movegen.cs,generate_evasion,The length of the statement  "                        if ((Utils.between_bb(ksq' checksq) != 0) || ((Utils.bit_is_set(Utils.PseudoAttacks[PieceTypeC.BISHOP][checksq]' ksq)) == 0)) " is 125.
Long Statement,Portfish,MovePicker,C:\repos\bpfliegel_Portfish\src\MovePicker.cs,score_evasions,The length of the statement  "                if ((seeScore = ((Position.PieceValueMidgame[pos.board[m & 0x3F]] >= Position.PieceValueMidgame[pos.board[((m >> 6) & 0x3F)]]) ? 1 : pos.see(m' false))) < 0) " is 157.
Long Statement,Portfish,MovePicker,C:\repos\bpfliegel_Portfish\src\MovePicker.cs,score_evasions,The length of the statement  "                else if (((pos.board[m & 0x3F] != PieceC.NO_PIECE) && !((m & (3 << 14)) == (3 << 14))) || ((m & (3 << 14)) == (2 << 14))) " is 121.
Long Statement,Portfish,MovePicker,C:\repos\bpfliegel_Portfish\src\MovePicker.cs,score_evasions,The length of the statement  "                    ms[idx].score = Position.PieceValueMidgame[pos.board[(m & 0x3F)]] - (pos.board[((m >> 6) & 0x3F)] & 7) + History.MaxValue; " is 122.
Long Statement,Portfish,BrokerManager,C:\repos\bpfliegel_Portfish\src\ObjectBroker.cs,Warmup,The length of the statement  "            brokerSize = 40; for (i = 0; i < brokerSize; i++) { CheckInfoBroker.GetObject(); } for (i = 0; i < brokerSize; i++) { CheckInfoBroker.Free(); } " is 143.
Long Statement,Portfish,BrokerManager,C:\repos\bpfliegel_Portfish\src\ObjectBroker.cs,Warmup,The length of the statement  "            brokerSize = 4; for (i = 0; i < brokerSize; i++) { EvalInfoBroker.GetObject(); } for (i = 0; i < brokerSize; i++) { EvalInfoBroker.Free(); } " is 140.
Long Statement,Portfish,BrokerManager,C:\repos\bpfliegel_Portfish\src\ObjectBroker.cs,Warmup,The length of the statement  "            brokerSize = 4; for (i = 0; i < brokerSize; i++) { SwapListBroker.GetObject(); } for (i = 0; i < brokerSize; i++) { SwapListBroker.Free(); } " is 140.
Long Statement,Portfish,BrokerManager,C:\repos\bpfliegel_Portfish\src\ObjectBroker.cs,Warmup,The length of the statement  "            brokerSize = 36; for (i = 0; i < brokerSize; i++) { MovesSearchedBroker.GetObject(); } for (i = 0; i < brokerSize; i++) { MovesSearchedBroker.Free(); } " is 151.
Long Statement,Portfish,BrokerManager,C:\repos\bpfliegel_Portfish\src\ObjectBroker.cs,Warmup,The length of the statement  "            brokerSize = 8; for (i = 0; i < brokerSize; i++) { PositionBroker.GetObject(); } for (i = 0; i < brokerSize; i++) { PositionBroker.Free(); } " is 140.
Long Statement,Portfish,BrokerManager,C:\repos\bpfliegel_Portfish\src\ObjectBroker.cs,Warmup,The length of the statement  "            brokerSize = 4; for (i = 0; i < brokerSize; i++) { StateInfoArrayBroker.GetObject(); } for (i = 0; i < brokerSize; i++) { StateInfoArrayBroker.Free(); } " is 152.
Long Statement,Portfish,BrokerManager,C:\repos\bpfliegel_Portfish\src\ObjectBroker.cs,Warmup,The length of the statement  "            brokerSize = 4; for (i = 0; i < brokerSize; i++) { MListBroker.GetObject(); } for (i = 0; i < brokerSize; i++) { MListBroker.Free(); } " is 134.
Long Statement,Portfish,BrokerManager,C:\repos\bpfliegel_Portfish\src\ObjectBroker.cs,Warmup,The length of the statement  "            brokerSize = 36; for (i = 0; i < brokerSize; i++) { StateInfoBroker.GetObject(); } for (i = 0; i < brokerSize; i++) { StateInfoBroker.Free(); } " is 143.
Long Statement,Portfish,BrokerManager,C:\repos\bpfliegel_Portfish\src\ObjectBroker.cs,Warmup,The length of the statement  "            brokerSize = 8; LoopStack[] arrLoopStack = new LoopStack[brokerSize]; for (i = 0; i < brokerSize; i++) { arrLoopStack[i] = LoopStackBroker.GetObject(); } for (i = brokerSize - 1; i >= 0; i--) { LoopStackBroker.Free(arrLoopStack[i]); } " is 234.
Long Statement,Portfish,BrokerManager,C:\repos\bpfliegel_Portfish\src\ObjectBroker.cs,Warmup,The length of the statement  "            brokerSize = 40; MovePicker[] arrMovePicker = new MovePicker[brokerSize]; for (i = 0; i < brokerSize; i++) { arrMovePicker[i] = MovePickerBroker.GetObject(); } for (i = brokerSize - 1; i >= 0; i--) { MovePickerBroker.Free(arrMovePicker[i]); } " is 242.
Long Statement,Portfish,CheckInfoBroker,C:\repos\bpfliegel_Portfish\src\ObjectBroker.cs,Report,The length of the statement  "            return string.Format("CheckInfoBroker: {0}{1}\r\n"' entryCount' entryCount>0 ? string.Format(" ({0})"' sb.ToString().Substring(1)) : string.Empty); " is 147.
Long Statement,Portfish,EvalInfoBroker,C:\repos\bpfliegel_Portfish\src\ObjectBroker.cs,Report,The length of the statement  "            return string.Format("EvalInfoBroker: {0}{1}\r\n"' entryCount' entryCount > 0 ? string.Format(" ({0})"' sb.ToString().Substring(1)) : string.Empty); " is 148.
Long Statement,Portfish,SwapListBroker,C:\repos\bpfliegel_Portfish\src\ObjectBroker.cs,Report,The length of the statement  "            return string.Format("SwapListBroker: {0}{1}\r\n"' entryCount' entryCount > 0 ? string.Format(" ({0})"' sb.ToString().Substring(1)) : string.Empty); " is 148.
Long Statement,Portfish,MovesSearchedBroker,C:\repos\bpfliegel_Portfish\src\ObjectBroker.cs,Report,The length of the statement  "            return string.Format("MovesSearchedBroker: {0}{1}\r\n"' entryCount' entryCount > 0 ? string.Format(" ({0})"' sb.ToString().Substring(1)) : string.Empty); " is 153.
Long Statement,Portfish,StateInfoArrayBroker,C:\repos\bpfliegel_Portfish\src\ObjectBroker.cs,Report,The length of the statement  "            return string.Format("StateInfoArrayBroker: {0}{1}\r\n"' entryCount' entryCount > 0 ? string.Format(" ({0})"' sb.ToString().Substring(1)) : string.Empty); " is 154.
Long Statement,Portfish,PositionBroker,C:\repos\bpfliegel_Portfish\src\ObjectBroker.cs,Report,The length of the statement  "            return string.Format("PositionBroker: {0}{1}\r\n"' entryCount' entryCount > 0 ? string.Format(" ({0})"' sb.ToString().Substring(1)) : string.Empty); " is 148.
Long Statement,Portfish,MListBroker,C:\repos\bpfliegel_Portfish\src\ObjectBroker.cs,Report,The length of the statement  "            return string.Format("MListBroker: {0}{1}\r\n"' entryCount' entryCount > 0 ? string.Format(" ({0})"' sb.ToString().Substring(1)) : string.Empty); " is 145.
Long Statement,Portfish,StateInfoBroker,C:\repos\bpfliegel_Portfish\src\ObjectBroker.cs,Report,The length of the statement  "            return string.Format("StateInfoBroker: {0}{1}\r\n"' entryCount' entryCount > 0 ? string.Format(" ({0})"' sb.ToString().Substring(1)) : string.Empty); " is 149.
Long Statement,Portfish,MovePickerBroker,C:\repos\bpfliegel_Portfish\src\ObjectBroker.cs,Report,The length of the statement  "            return string.Format("MovePickerBroker: {0}{1}\r\n"' entryCount' entryCount > 0 ? string.Format(" ({0})"' sb.ToString().Substring(1)) : string.Empty); " is 150.
Long Statement,Portfish,LoopStackBroker,C:\repos\bpfliegel_Portfish\src\ObjectBroker.cs,Report,The length of the statement  "            return string.Format("LoopStackBroker: {0}{1}\r\n"' entryCount' entryCount > 0 ? string.Format(" ({0})"' sb.ToString().Substring(1)) : string.Empty); " is 149.
Long Statement,Portfish,CheckInfo,C:\repos\bpfliegel_Portfish\src\Position.cs,CreateCheckInfo,The length of the statement  "            checkSq[PieceTypeC.BISHOP] = Utils.BAttacks[ksq][(((pos.occupied_squares & Utils.BMasks[ksq]) * Utils.BMagics[ksq]) >> Utils.BShifts[ksq])]; " is 140.
Long Statement,Portfish,CheckInfo,C:\repos\bpfliegel_Portfish\src\Position.cs,CreateCheckInfo,The length of the statement  "            checkSq[PieceTypeC.ROOK] = Utils.RAttacks[ksq][(((pos.occupied_squares & Utils.RMasks[ksq]) * Utils.RMagics[ksq]) >> Utils.RShifts[ksq])]; " is 138.
Long Statement,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,attacks_from_PTS,The length of the statement  "            if (pieceType == PieceTypeC.QUEEN) return Utils.bishop_attacks_bb(s' occupied_squares) | Utils.rook_attacks_bb(s' occupied_squares); " is 132.
Long Statement,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,attacks_from_BISHOP,The length of the statement  "            return Utils.BAttacks[s][(lo * (UInt32)(Utils.BMagics[s]) ^ hi * (UInt32)(Utils.BMagics[s] >> 32)) >> Utils.BShifts[s]]; " is 120.
Long Statement,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,attacks_from_ROOK,The length of the statement  "            return Utils.RAttacks[s][(lo * (UInt32)(Utils.RMagics[s]) ^ hi * (UInt32)(Utils.RMagics[s] >> 32)) >> Utils.RShifts[s]]; " is 120.
Long Statement,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,attacks_from_QUEEN,The length of the statement  "            return Utils.BAttacks[s][(((occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])]; " is 207.
Long Statement,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,attacks_from_QUEEN,The length of the statement  "            return Utils.BAttacks[s][(lob * (UInt32)(Utils.BMagics[s]) ^ hib * (UInt32)(Utils.BMagics[s] >> 32)) >> Utils.BShifts[s]] | Utils.RAttacks[s][(lor * (UInt32)(Utils.RMagics[s]) ^ hir * (UInt32)(Utils.RMagics[s] >> 32)) >> Utils.RShifts[s]]; " is 239.
Long Statement,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,attackers_to,The length of the statement  "            return ((Utils.StepAttacksBB[((ColorC.BLACK << 3) | PieceTypeC.PAWN)][s]) & (byTypeBB[PieceTypeC.PAWN] & byColorBB[ColorC.WHITE])) " is 130.
Long Statement,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,attackers_to,The length of the statement  "                  | ((Utils.StepAttacksBB[((ColorC.WHITE << 3) | PieceTypeC.PAWN)][s]) & (byTypeBB[PieceTypeC.PAWN] & byColorBB[ColorC.BLACK])) " is 125.
Long Statement,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,attackers_to,The length of the statement  "                  | ((Utils.RAttacks[s][(((occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])]) & (byTypeBB[PieceTypeC.ROOK] | byTypeBB[PieceTypeC.QUEEN])) " is 163.
Long Statement,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,attackers_to,The length of the statement  "                  | ((Utils.BAttacks[s][(((occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])]) & (byTypeBB[PieceTypeC.BISHOP] | byTypeBB[PieceTypeC.QUEEN])) " is 165.
Long Statement,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,attackers_to,The length of the statement  "            return ((Utils.StepAttacksBB[((ColorC.BLACK << 3) | PieceTypeC.PAWN)][s]) & (byTypeBB[PieceTypeC.PAWN] & byColorBB[ColorC.WHITE])) " is 130.
Long Statement,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,attackers_to,The length of the statement  "                  | ((Utils.StepAttacksBB[((ColorC.WHITE << 3) | PieceTypeC.PAWN)][s]) & (byTypeBB[PieceTypeC.PAWN] & byColorBB[ColorC.BLACK])) " is 125.
Long Statement,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,attackers_to,The length of the statement  "            return ((Utils.StepAttacksBB[((ColorC.BLACK << 3) | PieceTypeC.PAWN)][s]) & (byTypeBB[PieceTypeC.PAWN] & byColorBB[ColorC.WHITE])) " is 130.
Long Statement,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,attackers_to,The length of the statement  "                  | ((Utils.StepAttacksBB[((ColorC.WHITE << 3) | PieceTypeC.PAWN)][s]) & (byTypeBB[PieceTypeC.PAWN] & byColorBB[ColorC.BLACK])) " is 125.
Long Statement,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,attackers_to,The length of the statement  "                  | ((Utils.RAttacks[s][(((occ & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])]) & (byTypeBB[PieceTypeC.ROOK] | byTypeBB[PieceTypeC.QUEEN])) " is 150.
Long Statement,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,attackers_to,The length of the statement  "                  | ((Utils.BAttacks[s][(((occ & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])]) & (byTypeBB[PieceTypeC.BISHOP] | byTypeBB[PieceTypeC.QUEEN])) " is 152.
Long Statement,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,attackers_to,The length of the statement  "            return ((Utils.StepAttacksBB[((ColorC.BLACK << 3) | PieceTypeC.PAWN)][s]) & (byTypeBB[PieceTypeC.PAWN] & byColorBB[ColorC.WHITE])) " is 130.
Long Statement,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,attackers_to,The length of the statement  "                  | ((Utils.StepAttacksBB[((ColorC.WHITE << 3) | PieceTypeC.PAWN)][s]) & (byTypeBB[PieceTypeC.PAWN] & byColorBB[ColorC.BLACK])) " is 125.
Long Statement,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,discovered_check_candidates,The length of the statement  "            Bitboard pinners = byColorBB[sideToMove] & (((byTypeBB[PieceTypeC.ROOK] | byTypeBB[PieceTypeC.QUEEN]) & Utils.PseudoAttacks_ROOK[ksq]) " is 134.
Long Statement,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,discovered_check_candidates,The length of the statement  "                b = (Utils.BetweenBB[ksq][(Utils.BSFTable[((bb & (0xffffffffffffffff - bb + 1)) * 0x218A392CD3D5DBFUL) >> 58])]) & occupied_squares; " is 132.
Long Statement,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,pinned_pieces,The length of the statement  "            Bitboard pinners = byColorBB[sideToMove ^ 1] & (((byTypeBB[PieceTypeC.ROOK] | byTypeBB[PieceTypeC.QUEEN]) & Utils.PseudoAttacks_ROOK[ksq]) " is 138.
Long Statement,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,pinned_pieces,The length of the statement  "                b = (Utils.BetweenBB[ksq][(Utils.BSFTable[((bb & (0xffffffffffffffff - bb + 1)) * 0x218A392CD3D5DBFUL) >> 58])]) & occupied_squares; " is 132.
Long Statement,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,to_fen,The length of the statement  "                fen.Append(chess960 ? (Utils.toupper(Utils.file_to_char(Utils.file_of(castle_rook_square(ColorC.WHITE' CastlingSideC.KING_SIDE))))) : 'K'); " is 139.
Long Statement,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,to_fen,The length of the statement  "                fen.Append(chess960 ? (Utils.toupper(Utils.file_to_char(Utils.file_of(castle_rook_square(ColorC.WHITE' CastlingSideC.QUEEN_SIDE))))) : 'Q'); " is 140.
Long Statement,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,to_fen,The length of the statement  "                fen.Append(chess960 ? Utils.file_to_char(Utils.file_of(castle_rook_square(ColorC.BLACK' CastlingSideC.KING_SIDE))) : 'k'); " is 122.
Long Statement,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,to_fen,The length of the statement  "                fen.Append(chess960 ? Utils.file_to_char(Utils.file_of(castle_rook_square(ColorC.BLACK' CastlingSideC.QUEEN_SIDE))) : 'q'); " is 123.
Long Statement,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,pl_move_is_legal,The length of the statement  "                return ((Utils.rook_attacks_bb(ksq' b) & ((byTypeBB[PieceTypeC.ROOK] | byTypeBB[PieceTypeC.QUEEN]) & byColorBB[them])) == 0) " is 124.
Long Statement,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,pl_move_is_legal,The length of the statement  "                      && ((Utils.bishop_attacks_bb(ksq' b) & ((byTypeBB[PieceTypeC.BISHOP] | byTypeBB[PieceTypeC.QUEEN]) & byColorBB[them])) == 0); " is 125.
Long Statement,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,move_gives_check,The length of the statement  "                    || (((Utils.BetweenBB[from][to] | Utils.BetweenBB[from][pieceList[sideToMove ^ 1][PieceTypeC.KING][0]] | Utils.BetweenBB[to][pieceList[sideToMove ^ 1][PieceTypeC.KING][0]]) & (Utils.SquareBB[from] | Utils.SquareBB[to] | Utils.SquareBB[pieceList[sideToMove ^ 1][PieceTypeC.KING][0]])) == 0)) " is 290.
Long Statement,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,move_gives_check,The length of the statement  "                return ((Utils.rook_attacks_bb(ksq' b) & ((byTypeBB[PieceTypeC.ROOK] | byTypeBB[PieceTypeC.QUEEN]) & byColorBB[us])) != 0) " is 122.
Long Statement,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,move_gives_check,The length of the statement  "                      || ((Utils.bishop_attacks_bb(ksq' b) & ((byTypeBB[PieceTypeC.BISHOP] | byTypeBB[PieceTypeC.QUEEN]) & byColorBB[us])) != 0); " is 123.
Long Statement,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,move_gives_check,The length of the statement  "                Bitboard b = (occupied_squares ^ Utils.SquareBB[kfrom] ^ Utils.SquareBB[rfrom]) | Utils.SquareBB[rto] | Utils.SquareBB[kto]; " is 124.
Long Statement,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,do_move,The length of the statement  "                    if (them == 0) { st.npMaterialWHITE -= PieceValueMidgame[capture]; } else { st.npMaterialBLACK -= PieceValueMidgame[capture]; } " is 127.
Long Statement,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,do_move,The length of the statement  "                    && ((((Utils.StepAttacksBB[((us << 3) | PieceTypeC.PAWN)][from + (us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)]) & (byTypeBB[PieceTypeC.PAWN] & byColorBB[them]))) != 0)) " is 180.
Long Statement,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,do_move,The length of the statement  "                            st.checkersBB |= attacks_from_ROOK(pieceList[them][PieceTypeC.KING][0]) & ((byTypeBB[PieceTypeC.ROOK] | byTypeBB[PieceTypeC.QUEEN]) & byColorBB[us]); " is 149.
Long Statement,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,do_move,The length of the statement  "                            st.checkersBB |= attacks_from_BISHOP(pieceList[them][PieceTypeC.KING][0]) & ((byTypeBB[PieceTypeC.BISHOP] | byTypeBB[PieceTypeC.QUEEN]) & byColorBB[us]); " is 153.
Long Statement,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,see,The length of the statement  "                attackers |= ((Utils.RAttacks[to][(((occ & Utils.RMasks[to]) * Utils.RMagics[to]) >> Utils.RShifts[to])]) & (byTypeBB[PieceTypeC.ROOK] | byTypeBB[PieceTypeC.QUEEN])) " is 165.
Long Statement,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,see,The length of the statement  "                            | ((Utils.BAttacks[to][(((occ & Utils.BMasks[to]) * Utils.BMagics[to]) >> Utils.BShifts[to])]) & (byTypeBB[PieceTypeC.BISHOP] | byTypeBB[PieceTypeC.QUEEN])); " is 157.
Long Statement,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,is_dangerous,The length of the statement  "                && (pos.st.npMaterialWHITE + pos.st.npMaterialBLACK - Position.PieceValueMidgame[pos.board[m & 0x3F]] == ValueC.VALUE_ZERO)" is 123.
Long Statement,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The length of the statement  "            bool PvNode = (NT == NodeTypeC.PV || NT == NodeTypeC.Root || NT == NodeTypeC.SplitPointPV || NT == NodeTypeC.SplitPointRoot);" is 125.
Long Statement,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The length of the statement  "                TT.store(posKey' ValueC.VALUE_NONE' Bound.BOUND_NONE' DepthC.DEPTH_NONE' MoveC.MOVE_NONE' ss[ssPos].eval' ss[ssPos].evalMargin);" is 128.
Long Statement,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The length of the statement  "                nullValue = depth - R * DepthC.ONE_PLY < DepthC.ONE_PLY ? -qsearch(NodeTypeC.NonPV' pos' ss' ssPos + 1' -beta' -alpha' DepthC.DEPTH_ZERO)" is 137.
Long Statement,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The length of the statement  "            mp.MovePickerC(pos' ttMove' depth' H' ss[ssPos]' PvNode ? -ValueC.VALUE_INFINITE : beta' SpNode ? ss[ssPos].sp.mp : null);" is 122.
Long Statement,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The length of the statement  "                    value = newDepth < DepthC.ONE_PLY ? -qsearch(NodeTypeC.NonPV' pos' ss' ssPos + 1' -(alpha + 1)' -alpha' DepthC.DEPTH_ZERO)" is 122.
Long Statement,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The length of the statement  "                    bestValue = Threads.split(Constants.FakeSplit' pos' ss' ssPos' alpha' beta' bestValue' ref bestMove' depth' threatMove' moveCount' mp' NT);" is 139.
Long Statement,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,qsearch,The length of the statement  "                        TT.store(pos.key()' value_to_tt(bestValue' ss[ssPos].ply)' Bound.BOUND_LOWER' DepthC.DEPTH_NONE' MoveC.MOVE_NONE' ss[ssPos].eval' evalMargin);" is 142.
Long Statement,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,qsearch,The length of the statement  "                                 && !(((pos.board[move & 0x3F] != PieceC.NO_PIECE) && !((move & (3 << 14)) == (3 << 14))) || ((move & (3 << 14)) == (2 << 14)))" is 126.
Long Statement,Portfish,Threads,C:\repos\bpfliegel_Portfish\src\Thread.cs,init,The length of the statement  "            Windows.Foundation.IAsyncAction action = Windows.System.Threading.ThreadPool.RunAsync(delegate { launch_threads(initEvents); }' WorkItemPriority.Normal); " is 153.
Long Statement,Portfish,TimeMgr,C:\repos\bpfliegel_Portfish\src\Timeman.cs,remaining,The length of the statement  "            float ratio2 = (thisMoveImportance + TStealRatio * otherMovesImportance) / (float)(thisMoveImportance + otherMovesImportance); " is 126.
Long Statement,Portfish,TT,C:\repos\bpfliegel_Portfish\src\TT.cs,store,The length of the statement  "                //if ((entries[replacePos].generation8 == generation ? 2 : 0) + (tte.generation8 == generation || tte.bound == 3/*Bound.BOUND_EXACT*/ ? -2 : 0) + (tte.depth16 < entries[replacePos].depth16 ? 1 : 0) > 0) " is 202.
Long Statement,Portfish,TT,C:\repos\bpfliegel_Portfish\src\TT.cs,store,The length of the statement  "                    if ((!(tte.generation8 == generation || tte.bound == 3/*Bound.BOUND_EXACT*/)) && (tte.depth16 < entries[replacePos].depth16)) " is 125.
Long Statement,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,init_magics,The length of the statement  "                edges = ((Constants.Rank1BB | Constants.Rank8BB) & ~Utils.rank_bb_S(s)) | ((Constants.FileABB | Constants.FileHBB) & ~Utils.file_bb_S(s)); " is 138.
Long Statement,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,engine_info,The length of the statement  "            string versionInfo = buildDateTime.Year.ToString() + buildDateTime.Month.ToString().PadLeft(2' '0') + buildDateTime.Day.ToString().PadLeft(2' '0'); " is 147.
Long Statement,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,apply_weight,The length of the statement  "            return (((((int)((((v + 32768) & ~0xffff) / 0x10000)) * (((w + 32768) & ~0xffff) / 0x10000)) / 0x100) << 16) + (((int)(((Int16)(v & 0xffff))) * ((Int16)(w & 0xffff))) / 0x100)); " is 177.
Complex Conditional,Portfish,KPKPosition,C:\repos\bpfliegel_Portfish\src\Bitbase.cs,classify_leaf,The conditional expression  "wksq == psq || wksq == bksq || bksq == psq                  || (Utils.bit_is_set(k_attacks(ColorC.WHITE)'bksq)!=0)                  || (stm == ColorC.WHITE && (Utils.bit_is_set(p_attacks()'bksq)!=0))"  is complex.
Complex Conditional,Portfish,KPKPosition,C:\repos\bpfliegel_Portfish\src\Bitbase.cs,classify_leaf,The conditional expression  "Utils.rank_of(psq) == RankC.RANK_7                  && stm == ColorC.WHITE                  && wksq != psq + SquareC.DELTA_N                  && (Utils.square_distance(bksq' psq + SquareC.DELTA_N) > 1                      || (Utils.bit_is_set(k_attacks(ColorC.WHITE)'(psq + SquareC.DELTA_N))!=0) )"  is complex.
Complex Conditional,Portfish,KPKPosition,C:\repos\bpfliegel_Portfish\src\Bitbase.cs,classify_leaf,The conditional expression  "stm == ColorC.WHITE                  && wksq == psq + SquareC.DELTA_N                  && bksq == wksq + SquareC.DELTA_N + SquareC.DELTA_N                  && Utils.rank_of(psq) < RankC.RANK_5"  is complex.
Complex Conditional,Portfish,KPKPosition,C:\repos\bpfliegel_Portfish\src\Bitbase.cs,classify_leaf,The conditional expression  "Utils.file_of(wksq) == FileC.FILE_A                  && Utils.file_of(psq) == FileC.FILE_A                  && Utils.rank_of(wksq) > Utils.rank_of(psq)                  && bksq == wksq + 2"  is complex.
Complex Conditional,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRKP,The conditional expression  "Utils.rank_of(bksq) <= RankC.RANK_3                       && Utils.square_distance(bksq' bpsq) == 1                       && Utils.rank_of(wksq) >= RankC.RANK_4                       && Utils.square_distance(wksq' bpsq) - tempo > 2"  is complex.
Complex Conditional,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KQKRPs,The conditional expression  "Utils.relative_rank_CS(weakerSide' kingSq) <= RankC.RANK_2                  && Utils.relative_rank_CS(weakerSide' pos.king_square(strongerSide)) >= RankC.RANK_4                  && ((pos.pieces_PTC(PieceTypeC.ROOK' weakerSide) & Utils.rank_bb_R(Utils.relative_rank_CR(weakerSide' RankC.RANK_3))) != 0)                  && ((pos.pieces_PTC(PieceTypeC.PAWN' weakerSide) & Utils.rank_bb_R(Utils.relative_rank_CR(weakerSide' RankC.RANK_2))) != 0)                  && ((Position.attacks_from_KING(kingSq) & pos.pieces_PTC(PieceTypeC.PAWN' weakerSide)) != 0)"  is complex.
Complex Conditional,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRPKR,The conditional expression  "r <= RankC.RANK_5                  && Utils.square_distance(bksq' queeningSq) <= 1                  && wksq <= SquareC.SQ_H5                  && (Utils.rank_of(brsq) == RankC.RANK_6 || (r <= RankC.RANK_3 && Utils.rank_of(wrsq) != RankC.RANK_6))"  is complex.
Complex Conditional,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRPKR,The conditional expression  "r == RankC.RANK_6                  && Utils.square_distance(bksq' queeningSq) <= 1                  && Utils.rank_of(wksq) + tempo <= RankC.RANK_6                  && (Utils.rank_of(brsq) == RankC.RANK_1 || ((tempo == 0) && Math.Abs(Utils.file_of(brsq) - f) >= 3))"  is complex.
Complex Conditional,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRPKR,The conditional expression  "r >= RankC.RANK_6                  && bksq == queeningSq                  && Utils.rank_of(brsq) == RankC.RANK_1                  && ((tempo == 0) || Utils.square_distance(wksq' wpsq) >= 2)"  is complex.
Complex Conditional,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRPKR,The conditional expression  "wpsq == SquareC.SQ_A7                  && wrsq == SquareC.SQ_A8                  && (bksq == SquareC.SQ_H7 || bksq == SquareC.SQ_G7)                  && Utils.file_of(brsq) == FileC.FILE_A                  && (Utils.rank_of(brsq) <= RankC.RANK_3 || Utils.file_of(wksq) >= FileC.FILE_D || Utils.rank_of(wksq) <= RankC.RANK_5)"  is complex.
Complex Conditional,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRPKR,The conditional expression  "r <= RankC.RANK_5                  && bksq == wpsq + SquareC.DELTA_N                  && Utils.square_distance(wksq' wpsq) - tempo >= 2                  && Utils.square_distance(wksq' brsq) - tempo >= 2"  is complex.
Complex Conditional,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRPKR,The conditional expression  "r == RankC.RANK_7                  && f != FileC.FILE_A                  && Utils.file_of(wrsq) == f                  && wrsq != queeningSq                  && (Utils.square_distance(wksq' queeningSq) < Utils.square_distance(bksq' queeningSq) - 2 + tempo)                  && (Utils.square_distance(wksq' queeningSq) < Utils.square_distance(bksq' wrsq) + tempo)"  is complex.
Complex Conditional,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRPKR,The conditional expression  "f != FileC.FILE_A                  && Utils.file_of(wrsq) == f                  && wrsq < wpsq                  && (Utils.square_distance(wksq' queeningSq) < Utils.square_distance(bksq' queeningSq) - 2 + tempo)                  && (Utils.square_distance(wksq' wpsq + SquareC.DELTA_N) < Utils.square_distance(bksq' wpsq + SquareC.DELTA_N) - 2 + tempo)                  && (Utils.square_distance(bksq' wrsq) + tempo >= 3                      || (Utils.square_distance(wksq' queeningSq) < Utils.square_distance(bksq' wrsq) + tempo                          && (Utils.square_distance(wksq' wpsq + SquareC.DELTA_N) < Utils.square_distance(bksq' wrsq) + tempo)))"  is complex.
Complex Conditional,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KBPKB,The conditional expression  "Utils.file_of(weakerKingSq) == Utils.file_of(pawnSq)                  && Utils.relative_rank_CS(strongerSide' pawnSq) < Utils.relative_rank_CS(strongerSide' weakerKingSq)                  && (Utils.opposite_colors(weakerKingSq' strongerBishopSq)                      || Utils.relative_rank_CS(strongerSide' weakerKingSq) <= RankC.RANK_6)"  is complex.
Complex Conditional,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KBPPKB,The conditional expression  "ksq == blockSq1                          && Utils.opposite_colors(ksq' wbsq)                          && (bbsq == blockSq2                              || (((pos.attacks_from_BISHOP(blockSq2) & pos.pieces_PTC(PieceTypeC.BISHOP' weakerSide))) != 0)                              || Math.Abs(r1 - r2) >= 2)"  is complex.
Complex Conditional,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KBPPKB,The conditional expression  "ksq == blockSq2                               && Utils.opposite_colors(ksq' wbsq)                               && (bbsq == blockSq1                                   || (((pos.attacks_from_BISHOP(blockSq1) & pos.pieces_PTC(PieceTypeC.BISHOP' weakerSide)))) != 0)"  is complex.
Complex Conditional,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KBPKN,The conditional expression  "Utils.file_of(weakerKingSq) == Utils.file_of(pawnSq)                  && Utils.relative_rank_CS(strongerSide' pawnSq) < Utils.relative_rank_CS(strongerSide' weakerKingSq)                  && (Utils.opposite_colors(weakerKingSq' strongerBishopSq)                      || Utils.relative_rank_CS(strongerSide' weakerKingSq) <= RankC.RANK_6)"  is complex.
Complex Conditional,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,do_evaluate,The conditional expression  "ei.mi.gamePhase < PhaseC.PHASE_MIDGAME                  &&                   (                      pos.pieceCount[ColorC.WHITE][PieceTypeC.BISHOP] == 1                      &&                       pos.pieceCount[ColorC.BLACK][PieceTypeC.BISHOP] == 1                      &&                       (((((pos.pieceList[ColorC.WHITE][PieceTypeC.BISHOP][0] ^ pos.pieceList[ColorC.BLACK][PieceTypeC.BISHOP][0]) >> 3) ^ (pos.pieceList[ColorC.WHITE][PieceTypeC.BISHOP][0] ^ pos.pieceList[ColorC.BLACK][PieceTypeC.BISHOP][0])) & 1) != 0)                  )                  && sf == ScaleFactorC.SCALE_FACTOR_NORMAL"  is complex.
Complex Conditional,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The conditional expression  "(Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)"  is complex.
Complex Conditional,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The conditional expression  "(Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8"  is complex.
Complex Conditional,Portfish,Movegen,C:\repos\bpfliegel_Portfish\src\Movegen.cs,generate_direct_checks,The conditional expression  "(Pt == PieceTypeC.BISHOP || Pt == PieceTypeC.ROOK || Pt == PieceTypeC.QUEEN)                          && ((Utils.PseudoAttacks[Pt][from] & target) == 0)"  is complex.
Complex Conditional,Portfish,MovePicker,C:\repos\bpfliegel_Portfish\src\MovePicker.cs,next_move,The conditional expression  "move != MoveC.MOVE_NONE                              && pos.is_pseudo_legal(move)                              && move != ttMove                              && !pos.is_capture(move)"  is complex.
Complex Conditional,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,from_fen,The conditional expression  "((col >= 'a' && col <= 'h'))                          && ((row == '3' || row == '6'))"  is complex.
Complex Conditional,Portfish,RootMove,C:\repos\bpfliegel_Portfish\src\Search.cs,extract_pv_from_tt,The conditional expression  "TT.probe(pos.key()' ref ttePos' out tte)                && (m = tte.move()) != MoveC.MOVE_NONE // Local copy' TT entry could change                && pos.is_pseudo_legal(m)                && pos.pl_move_is_legal(m' pos.pinned_pieces())                && ply < Constants.MAX_PLY                && (!pos.is_draw(false) || ply < 2)"  is complex.
Complex Conditional,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,is_dangerous,The conditional expression  "captureOrPromotion                 && (pos.board[m & 0x3F] & 7) != PieceTypeC.PAWN                 && ((m & (3 << 14)) == 0)                 && (pos.st.npMaterialWHITE + pos.st.npMaterialBLACK - Position.PieceValueMidgame[pos.board[m & 0x3F]] == ValueC.VALUE_ZERO)"  is complex.
Complex Conditional,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,id_loop,The conditional expression  "!SignalsStop && ++depth <= Constants.MAX_PLY && ((Limits.depth == 0) || depth <= Limits.depth)"  is complex.
Complex Conditional,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,id_loop,The conditional expression  "depth >= 12                         && !stop                         && ((bestMoveNeverChanged && (pos.captured_piece_type() != 0))                             || SearchTime.ElapsedMilliseconds > (TimeMgr.available_time() * 40) / 100)"  is complex.
Complex Conditional,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The conditional expression  "(SignalsStop                  || pos.is_draw(false)                  || ss[ssPos].ply > Constants.MAX_PLY) && !RootNode"  is complex.
Complex Conditional,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The conditional expression  "!RootNode && tteHasValue && (PvNode ? tte.depth() >= depth && tte.type() == Bound.BOUND_EXACT                                             : can_return_tt(tte' depth' ttValue' beta))"  is complex.
Complex Conditional,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The conditional expression  "ttValue >= beta                     && (ttMove != 0)                     && !pos.is_capture_or_promotion(ttMove)                     && ttMove != ss[ssPos].killers0"  is complex.
Complex Conditional,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The conditional expression  "(move = ss[ssPos - 1].currentMove) != MoveC.MOVE_NULL                 && ss[ssPos - 1].eval != ValueC.VALUE_NONE                 && ss[ssPos].eval != ValueC.VALUE_NONE                 && (pos.captured_piece_type() == 0)                 && !Utils.is_special(move)"  is complex.
Complex Conditional,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The conditional expression  "!PvNode && !inCheck                 && depth < RazorDepth                 && refinedValue + razor_margin(depth) < beta                 && ttMove == MoveC.MOVE_NONE                 && Math.Abs(beta) < ValueC.VALUE_MATE_IN_MAX_PLY                 && !pos.pawn_on_7th(pos.sideToMove)"  is complex.
Complex Conditional,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The conditional expression  "!PvNode && !inCheck                 && (ss[ssPos].skipNullMove == 0)                 && depth < RazorDepth                 && Math.Abs(beta) < ValueC.VALUE_MATE_IN_MAX_PLY                 && refinedValue - futility_margin(depth' 0) >= beta                 && (pos.non_pawn_material(pos.sideToMove) != 0)"  is complex.
Complex Conditional,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The conditional expression  "!PvNode && !inCheck                 && (ss[ssPos].skipNullMove == 0)                 && depth > DepthC.ONE_PLY                 && refinedValue >= beta                 && Math.Abs(beta) < ValueC.VALUE_MATE_IN_MAX_PLY                 && (pos.non_pawn_material(pos.sideToMove) != 0)"  is complex.
Complex Conditional,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The conditional expression  "depth < ThreatDepth                         && (ss[ssPos - 1].reduction != 0)                         && threatMove != MoveC.MOVE_NONE                         && connected_moves(pos' ss[ssPos - 1].currentMove' threatMove)"  is complex.
Complex Conditional,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The conditional expression  "!PvNode && !inCheck                 && excludedMove == MoveC.MOVE_NONE                 && depth >= RazorDepth + DepthC.ONE_PLY                 && (ss[ssPos].skipNullMove == 0)                 && Math.Abs(beta) < ValueC.VALUE_MATE_IN_MAX_PLY"  is complex.
Complex Conditional,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The conditional expression  "ttMove == MoveC.MOVE_NONE                 && depth >= IIDDepth[PvNode ? 1 : 0]                 && (PvNode || (!inCheck && ss[ssPos].eval + IIDMargin >= beta))"  is complex.
Complex Conditional,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The conditional expression  "bestValue < beta                    && (move = mp.next_move()) != MoveC.MOVE_NONE                     && !thisThread.cutoff_occurred()                     && !SignalsStop"  is complex.
Complex Conditional,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The conditional expression  "singularExtensionNode                     && (ext == 0)                     && move == ttMove                     && pos.pl_move_is_legal(move' ci.pinned)"  is complex.
Complex Conditional,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The conditional expression  "!PvNode && !inCheck                     && !captureOrPromotion                     && !dangerous                     && move != ttMove                     && (bestValue > ValueC.VALUE_MATED_IN_MAX_PLY || bestValue == -ValueC.VALUE_INFINITE)                     && !Utils.is_castle(move)"  is complex.
Complex Conditional,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The conditional expression  "!isPvMove                     && !captureOrPromotion                     && !dangerous                     && ss[ssPos].killers0 != move                     && ss[ssPos].killers1 != move                     && depth > 3 * DepthC.ONE_PLY                     && !Utils.is_castle(move)"  is complex.
Complex Conditional,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The conditional expression  "PvNode && (isPvMove || (value > alpha && (RootNode || value < beta)))"  is complex.
Complex Conditional,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The conditional expression  "!SpNode                   && depth >= Threads.min_split_depth()                   && bestValue < beta                   && Threads.available_slave_exists(thisThread)                   && !SignalsStop                   && !thisThread.cutoff_occurred()"  is complex.
Complex Conditional,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,qsearch,The conditional expression  "!PvNode                     && !inCheck                     && !givesCheck                     && move != ttMove                     && enoughMaterial                     && ((move & (3 << 14)) != (1 << 14))                     && !pos.is_passed_pawn_push(move)"  is complex.
Complex Conditional,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,qsearch,The conditional expression  "!PvNode                     && move != ttMove                     && (!inCheck || evasionPrunable)                     && (move & (3 << 14)) != (1 << 14)                     && pos.see(move' true) < 0"  is complex.
Complex Conditional,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,qsearch,The conditional expression  "!PvNode                     && !inCheck                     && givesCheck                     && move != ttMove                     && !(((move & (3 << 14)) != 0) ? ((move & (3 << 14)) != (3 << 14)) : (pos.board[move & 0x3F] != PieceC.NO_PIECE))                     && ss[ssPos].eval + Constants.PawnValueMidgame / 4 < beta                     && !check_is_dangerous(pos' move' futilityBase' beta)"  is complex.
Complex Conditional,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,connected_threat,The conditional expression  "pos.is_capture(threat)                 && (Position.PieceValueMidgame[pos.piece_on(tfrom)] >= Position.PieceValueMidgame[pos.piece_on(tto)]                     || Utils.type_of(pos.piece_on(tfrom)) == PieceTypeC.KING)                 && pos.move_attacks_square(m' tto)"  is complex.
Complex Conditional,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,refine_eval,The conditional expression  "(((tte.type() & Bound.BOUND_LOWER) != 0) && v >= defaultEval)                 || (((tte.type() & Bound.BOUND_UPPER) != 0) && v < defaultEval)"  is complex.
Complex Conditional,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,check_time,The conditional expression  "(Limits.use_time_management() && noMoreTime)                 || ((Limits.movetime != 0) && e >= Limits.movetime)"  is complex.
Complex Conditional,Portfish,Thread,C:\repos\bpfliegel_Portfish\src\Thread.cs,idle_loop,The conditional expression  "do_sleep                         || do_exit                         || (!is_searching && use_sleeping_threads)"  is complex.
Magic Number,Portfish,Benchmark,C:\repos\bpfliegel_Portfish\src\Benchmark.cs,benchmark,The following statement contains a magic number: if (limitType == "time")                  limits.movetime = 1000 * int.Parse(limit); // maxTime is in ms                else if (limitType == "nodes")                  limits.nodes = int.Parse(limit);                else                  limits.depth = int.Parse(limit);
Magic Number,Portfish,Benchmark,C:\repos\bpfliegel_Portfish\src\Benchmark.cs,benchmark,The following statement contains a magic number: for (int i = 0; i < fens.Count; i++)              {                  time.Reset(); time.Start();                  Position pos = new Position(fens[i]' bool.Parse(OptionMap.Instance["UCI_Chess960"].v)' Threads.main_thread());                    Plug.Write("\nPosition: ");                  Plug.Write((i + 1).ToString());                  Plug.Write("/");                  Plug.Write(fens.Count.ToString());                  Plug.Write(Constants.endl);                    if (limitType == "perft")                  {                      Int64 cnt = Search.perft(pos' limits.depth * DepthC.ONE_PLY);                      Plug.Write("\nPerft ");                      Plug.Write(limits.depth.ToString());                      Plug.Write(" leaf nodes: ");                      Plug.Write(cnt.ToString());                      Plug.Write(Constants.endl);                      nodes = cnt;                  }                  else                  {                      Threads.start_searching(pos' limits' new List<Move>());                      Threads.wait_for_search_finished();                      nodes = Search.RootPosition.nodes;                      res[i] = nodes;                  }                    e = time.ElapsedMilliseconds;                    nodesAll += nodes;                  eAll += e;                    Plug.Write("\n===========================");                  Plug.Write("\nTotal time (ms) : ");                  Plug.Write(e.ToString());                  Plug.Write("\nNodes searched  : ");                  Plug.Write(nodes.ToString());                  Plug.Write("\nNodes/second    : ");                  Plug.Write(((int)(nodes / (e / 1000.0))).ToString());                  Plug.Write(Constants.endl);                }
Magic Number,Portfish,Benchmark,C:\repos\bpfliegel_Portfish\src\Benchmark.cs,benchmark,The following statement contains a magic number: Plug.Write(((int)(nodesAll / (eAll / 1000.0))).ToString());
Magic Number,Portfish,KPKPosition,C:\repos\bpfliegel_Portfish\src\Bitbase.cs,probe_kpk_bitbase,The following statement contains a magic number: int idx = stm + (bksq << 1) + (wksq << 7) + ((wpsq & 7) << 13) + (((wpsq >> 3) - 1) << 15);
Magic Number,Portfish,KPKPosition,C:\repos\bpfliegel_Portfish\src\Bitbase.cs,probe_kpk_bitbase,The following statement contains a magic number: int idx = stm + (bksq << 1) + (wksq << 7) + ((wpsq & 7) << 13) + (((wpsq >> 3) - 1) << 15);
Magic Number,Portfish,KPKPosition,C:\repos\bpfliegel_Portfish\src\Bitbase.cs,probe_kpk_bitbase,The following statement contains a magic number: int idx = stm + (bksq << 1) + (wksq << 7) + ((wpsq & 7) << 13) + (((wpsq >> 3) - 1) << 15);
Magic Number,Portfish,KPKPosition,C:\repos\bpfliegel_Portfish\src\Bitbase.cs,probe_kpk_bitbase,The following statement contains a magic number: int idx = stm + (bksq << 1) + (wksq << 7) + ((wpsq & 7) << 13) + (((wpsq >> 3) - 1) << 15);
Magic Number,Portfish,KPKPosition,C:\repos\bpfliegel_Portfish\src\Bitbase.cs,probe_kpk_bitbase,The following statement contains a magic number: int idx = stm + (bksq << 1) + (wksq << 7) + ((wpsq & 7) << 13) + (((wpsq >> 3) - 1) << 15);
Magic Number,Portfish,KPKPosition,C:\repos\bpfliegel_Portfish\src\Bitbase.cs,probe_kpk_bitbase,The following statement contains a magic number: return KPKBitbase[idx / 32] & (Constants.UInt32One << (idx & 31));
Magic Number,Portfish,KPKPosition,C:\repos\bpfliegel_Portfish\src\Bitbase.cs,probe_kpk_bitbase,The following statement contains a magic number: return KPKBitbase[idx / 32] & (Constants.UInt32One << (idx & 31));
Magic Number,Portfish,KPKPosition,C:\repos\bpfliegel_Portfish\src\Bitbase.cs,init,The following statement contains a magic number: for (idx = 0; idx < IndexMax / 32; idx++)                  for (bit = 0; bit < 32; bit++)                      if (db[32 * idx + bit] == ResultC.WIN)                          KPKBitbase[idx] |= (one << bit);
Magic Number,Portfish,KPKPosition,C:\repos\bpfliegel_Portfish\src\Bitbase.cs,init,The following statement contains a magic number: for (idx = 0; idx < IndexMax / 32; idx++)                  for (bit = 0; bit < 32; bit++)                      if (db[32 * idx + bit] == ResultC.WIN)                          KPKBitbase[idx] |= (one << bit);
Magic Number,Portfish,KPKPosition,C:\repos\bpfliegel_Portfish\src\Bitbase.cs,init,The following statement contains a magic number: for (idx = 0; idx < IndexMax / 32; idx++)                  for (bit = 0; bit < 32; bit++)                      if (db[32 * idx + bit] == ResultC.WIN)                          KPKBitbase[idx] |= (one << bit);
Magic Number,Portfish,KPKPosition,C:\repos\bpfliegel_Portfish\src\Bitbase.cs,index,The following statement contains a magic number: return c + (b << 1) + (w << 7) + (Utils.file_of(p) << 13) + ((Utils.rank_of(p) - 1) << 15);
Magic Number,Portfish,KPKPosition,C:\repos\bpfliegel_Portfish\src\Bitbase.cs,index,The following statement contains a magic number: return c + (b << 1) + (w << 7) + (Utils.file_of(p) << 13) + ((Utils.rank_of(p) - 1) << 15);
Magic Number,Portfish,KPKPosition,C:\repos\bpfliegel_Portfish\src\Bitbase.cs,index,The following statement contains a magic number: return c + (b << 1) + (w << 7) + (Utils.file_of(p) << 13) + ((Utils.rank_of(p) - 1) << 15);
Magic Number,Portfish,KPKPosition,C:\repos\bpfliegel_Portfish\src\Bitbase.cs,decode_index,The following statement contains a magic number: bksq = ((idx >> 1) & 63);
Magic Number,Portfish,KPKPosition,C:\repos\bpfliegel_Portfish\src\Bitbase.cs,decode_index,The following statement contains a magic number: wksq = ((idx >> 7) & 63);
Magic Number,Portfish,KPKPosition,C:\repos\bpfliegel_Portfish\src\Bitbase.cs,decode_index,The following statement contains a magic number: wksq = ((idx >> 7) & 63);
Magic Number,Portfish,KPKPosition,C:\repos\bpfliegel_Portfish\src\Bitbase.cs,decode_index,The following statement contains a magic number: psq = Utils.make_square(((idx >> 13) & 3)' ((idx >> 15) + 1));
Magic Number,Portfish,KPKPosition,C:\repos\bpfliegel_Portfish\src\Bitbase.cs,decode_index,The following statement contains a magic number: psq = Utils.make_square(((idx >> 13) & 3)' ((idx >> 15) + 1));
Magic Number,Portfish,KPKPosition,C:\repos\bpfliegel_Portfish\src\Bitbase.cs,decode_index,The following statement contains a magic number: psq = Utils.make_square(((idx >> 13) & 3)' ((idx >> 15) + 1));
Magic Number,Portfish,KPKPosition,C:\repos\bpfliegel_Portfish\src\Bitbase.cs,classify_leaf,The following statement contains a magic number: if (Utils.file_of(wksq) == FileC.FILE_A                  && Utils.file_of(psq) == FileC.FILE_A                  && Utils.rank_of(wksq) > Utils.rank_of(psq)                  && bksq == wksq + 2)                  return ResultC.DRAW;
Magic Number,Portfish,Bitcount,C:\repos\bpfliegel_Portfish\src\Bitcount.cs,popcount_1s_Full,The following statement contains a magic number: b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);
Magic Number,Portfish,Bitcount,C:\repos\bpfliegel_Portfish\src\Bitcount.cs,popcount_1s_Full,The following statement contains a magic number: b = ((b >> 4) + b) & 0x0F0F0F0F0F0F0F0FUL;
Magic Number,Portfish,Bitcount,C:\repos\bpfliegel_Portfish\src\Bitcount.cs,popcount_1s_Full,The following statement contains a magic number: return (int)((b * 0x0101010101010101UL) >> 56);
Magic Number,Portfish,Bitcount,C:\repos\bpfliegel_Portfish\src\Bitcount.cs,popcount_1s_Max15,The following statement contains a magic number: b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);
Magic Number,Portfish,Bitcount,C:\repos\bpfliegel_Portfish\src\Bitcount.cs,popcount_1s_Max15,The following statement contains a magic number: return (int)((b * 0x1111111111111111UL) >> 60);
Magic Number,Portfish,Book,C:\repos\bpfliegel_Portfish\src\Book.cs,probe,The following statement contains a magic number: if (move != 0)              {                  // A PolyGlot book move is encoded as follows:                  //                  // bit  0- 5: destination square (from 0 to 63)                  // bit  6-11: origin square (from 0 to 63)                  // bit 12-14: promotion piece (from KNIGHT == 1 to QUEEN == 4)                  //                  // Castling moves follow "king captures rook" representation. So in case book                  // move is a promotion we have to convert to our representation' in all the                  // other cases we can directly compare with a Move after having masked out                  // the special Move's flags (bit 14-15) that are not supported by PolyGlot.                  int pt = (move >> 12) & 7;                  if (pt != 0)                  {                      move = Utils.make_promotion(Utils.from_sq(move)' Utils.to_sq(move)' (pt + 1));                  }                    // Add 'special move' flags and verify it is legal                  MList mlist = MListBroker.GetObject(); mlist.pos = 0;                  Movegen.generate_legal(pos' mlist.moves' ref mlist.pos);                  for (int i = 0; i < mlist.pos; i++)                  {                      if (move == (mlist.moves[i].move & 0x3FFF))                      {                          Move retval = mlist.moves[i].move;                          MListBroker.Free();                          return retval;                      }                  }                  MListBroker.Free();              }
Magic Number,Portfish,Book,C:\repos\bpfliegel_Portfish\src\Book.cs,probe,The following statement contains a magic number: if (move != 0)              {                  // A PolyGlot book move is encoded as follows:                  //                  // bit  0- 5: destination square (from 0 to 63)                  // bit  6-11: origin square (from 0 to 63)                  // bit 12-14: promotion piece (from KNIGHT == 1 to QUEEN == 4)                  //                  // Castling moves follow "king captures rook" representation. So in case book                  // move is a promotion we have to convert to our representation' in all the                  // other cases we can directly compare with a Move after having masked out                  // the special Move's flags (bit 14-15) that are not supported by PolyGlot.                  int pt = (move >> 12) & 7;                  if (pt != 0)                  {                      move = Utils.make_promotion(Utils.from_sq(move)' Utils.to_sq(move)' (pt + 1));                  }                    // Add 'special move' flags and verify it is legal                  MList mlist = MListBroker.GetObject(); mlist.pos = 0;                  Movegen.generate_legal(pos' mlist.moves' ref mlist.pos);                  for (int i = 0; i < mlist.pos; i++)                  {                      if (move == (mlist.moves[i].move & 0x3FFF))                      {                          Move retval = mlist.moves[i].move;                          MListBroker.Free();                          return retval;                      }                  }                  MListBroker.Free();              }
Magic Number,Portfish,Book,C:\repos\bpfliegel_Portfish\src\Book.cs,Read,The following statement contains a magic number: e.key =                  (((UInt64)t[0]) << 56) |                  (((UInt64)t[1]) << 48) |                  (((UInt64)t[2]) << 40) |                  (((UInt64)t[3]) << 32) |                  (((UInt64)t[4]) << 24) |                  (((UInt64)t[5]) << 16) |                  (((UInt64)t[6]) << 8) |                  (((UInt64)t[7]) << 0);
Magic Number,Portfish,Book,C:\repos\bpfliegel_Portfish\src\Book.cs,Read,The following statement contains a magic number: e.key =                  (((UInt64)t[0]) << 56) |                  (((UInt64)t[1]) << 48) |                  (((UInt64)t[2]) << 40) |                  (((UInt64)t[3]) << 32) |                  (((UInt64)t[4]) << 24) |                  (((UInt64)t[5]) << 16) |                  (((UInt64)t[6]) << 8) |                  (((UInt64)t[7]) << 0);
Magic Number,Portfish,Book,C:\repos\bpfliegel_Portfish\src\Book.cs,Read,The following statement contains a magic number: e.key =                  (((UInt64)t[0]) << 56) |                  (((UInt64)t[1]) << 48) |                  (((UInt64)t[2]) << 40) |                  (((UInt64)t[3]) << 32) |                  (((UInt64)t[4]) << 24) |                  (((UInt64)t[5]) << 16) |                  (((UInt64)t[6]) << 8) |                  (((UInt64)t[7]) << 0);
Magic Number,Portfish,Book,C:\repos\bpfliegel_Portfish\src\Book.cs,Read,The following statement contains a magic number: e.key =                  (((UInt64)t[0]) << 56) |                  (((UInt64)t[1]) << 48) |                  (((UInt64)t[2]) << 40) |                  (((UInt64)t[3]) << 32) |                  (((UInt64)t[4]) << 24) |                  (((UInt64)t[5]) << 16) |                  (((UInt64)t[6]) << 8) |                  (((UInt64)t[7]) << 0);
Magic Number,Portfish,Book,C:\repos\bpfliegel_Portfish\src\Book.cs,Read,The following statement contains a magic number: e.key =                  (((UInt64)t[0]) << 56) |                  (((UInt64)t[1]) << 48) |                  (((UInt64)t[2]) << 40) |                  (((UInt64)t[3]) << 32) |                  (((UInt64)t[4]) << 24) |                  (((UInt64)t[5]) << 16) |                  (((UInt64)t[6]) << 8) |                  (((UInt64)t[7]) << 0);
Magic Number,Portfish,Book,C:\repos\bpfliegel_Portfish\src\Book.cs,Read,The following statement contains a magic number: e.key =                  (((UInt64)t[0]) << 56) |                  (((UInt64)t[1]) << 48) |                  (((UInt64)t[2]) << 40) |                  (((UInt64)t[3]) << 32) |                  (((UInt64)t[4]) << 24) |                  (((UInt64)t[5]) << 16) |                  (((UInt64)t[6]) << 8) |                  (((UInt64)t[7]) << 0);
Magic Number,Portfish,Book,C:\repos\bpfliegel_Portfish\src\Book.cs,Read,The following statement contains a magic number: e.key =                  (((UInt64)t[0]) << 56) |                  (((UInt64)t[1]) << 48) |                  (((UInt64)t[2]) << 40) |                  (((UInt64)t[3]) << 32) |                  (((UInt64)t[4]) << 24) |                  (((UInt64)t[5]) << 16) |                  (((UInt64)t[6]) << 8) |                  (((UInt64)t[7]) << 0);
Magic Number,Portfish,Book,C:\repos\bpfliegel_Portfish\src\Book.cs,Read,The following statement contains a magic number: e.key =                  (((UInt64)t[0]) << 56) |                  (((UInt64)t[1]) << 48) |                  (((UInt64)t[2]) << 40) |                  (((UInt64)t[3]) << 32) |                  (((UInt64)t[4]) << 24) |                  (((UInt64)t[5]) << 16) |                  (((UInt64)t[6]) << 8) |                  (((UInt64)t[7]) << 0);
Magic Number,Portfish,Book,C:\repos\bpfliegel_Portfish\src\Book.cs,Read,The following statement contains a magic number: e.key =                  (((UInt64)t[0]) << 56) |                  (((UInt64)t[1]) << 48) |                  (((UInt64)t[2]) << 40) |                  (((UInt64)t[3]) << 32) |                  (((UInt64)t[4]) << 24) |                  (((UInt64)t[5]) << 16) |                  (((UInt64)t[6]) << 8) |                  (((UInt64)t[7]) << 0);
Magic Number,Portfish,Book,C:\repos\bpfliegel_Portfish\src\Book.cs,Read,The following statement contains a magic number: e.key =                  (((UInt64)t[0]) << 56) |                  (((UInt64)t[1]) << 48) |                  (((UInt64)t[2]) << 40) |                  (((UInt64)t[3]) << 32) |                  (((UInt64)t[4]) << 24) |                  (((UInt64)t[5]) << 16) |                  (((UInt64)t[6]) << 8) |                  (((UInt64)t[7]) << 0);
Magic Number,Portfish,Book,C:\repos\bpfliegel_Portfish\src\Book.cs,Read,The following statement contains a magic number: e.key =                  (((UInt64)t[0]) << 56) |                  (((UInt64)t[1]) << 48) |                  (((UInt64)t[2]) << 40) |                  (((UInt64)t[3]) << 32) |                  (((UInt64)t[4]) << 24) |                  (((UInt64)t[5]) << 16) |                  (((UInt64)t[6]) << 8) |                  (((UInt64)t[7]) << 0);
Magic Number,Portfish,Book,C:\repos\bpfliegel_Portfish\src\Book.cs,Read,The following statement contains a magic number: e.key =                  (((UInt64)t[0]) << 56) |                  (((UInt64)t[1]) << 48) |                  (((UInt64)t[2]) << 40) |                  (((UInt64)t[3]) << 32) |                  (((UInt64)t[4]) << 24) |                  (((UInt64)t[5]) << 16) |                  (((UInt64)t[6]) << 8) |                  (((UInt64)t[7]) << 0);
Magic Number,Portfish,Book,C:\repos\bpfliegel_Portfish\src\Book.cs,Read,The following statement contains a magic number: e.key =                  (((UInt64)t[0]) << 56) |                  (((UInt64)t[1]) << 48) |                  (((UInt64)t[2]) << 40) |                  (((UInt64)t[3]) << 32) |                  (((UInt64)t[4]) << 24) |                  (((UInt64)t[5]) << 16) |                  (((UInt64)t[6]) << 8) |                  (((UInt64)t[7]) << 0);
Magic Number,Portfish,Book,C:\repos\bpfliegel_Portfish\src\Book.cs,Read,The following statement contains a magic number: e.move = (UInt16)(                  (((UInt64)t[8]) << 8) |                  (((UInt64)t[9]) << 0));
Magic Number,Portfish,Book,C:\repos\bpfliegel_Portfish\src\Book.cs,Read,The following statement contains a magic number: e.move = (UInt16)(                  (((UInt64)t[8]) << 8) |                  (((UInt64)t[9]) << 0));
Magic Number,Portfish,Book,C:\repos\bpfliegel_Portfish\src\Book.cs,Read,The following statement contains a magic number: e.move = (UInt16)(                  (((UInt64)t[8]) << 8) |                  (((UInt64)t[9]) << 0));
Magic Number,Portfish,Book,C:\repos\bpfliegel_Portfish\src\Book.cs,Read,The following statement contains a magic number: e.count = (UInt16)(                  (((UInt64)t[10]) << 8) |                  (((UInt64)t[11]) << 0));
Magic Number,Portfish,Book,C:\repos\bpfliegel_Portfish\src\Book.cs,Read,The following statement contains a magic number: e.count = (UInt16)(                  (((UInt64)t[10]) << 8) |                  (((UInt64)t[11]) << 0));
Magic Number,Portfish,Book,C:\repos\bpfliegel_Portfish\src\Book.cs,Read,The following statement contains a magic number: e.count = (UInt16)(                  (((UInt64)t[10]) << 8) |                  (((UInt64)t[11]) << 0));
Magic Number,Portfish,Book,C:\repos\bpfliegel_Portfish\src\Book.cs,Read,The following statement contains a magic number: e.learn = (UInt32)(                  (((UInt64)t[12]) << 24) |                  (((UInt64)t[13]) << 16) |                  (((UInt64)t[14]) << 8) |                  (((UInt64)t[15]) << 0));
Magic Number,Portfish,Book,C:\repos\bpfliegel_Portfish\src\Book.cs,Read,The following statement contains a magic number: e.learn = (UInt32)(                  (((UInt64)t[12]) << 24) |                  (((UInt64)t[13]) << 16) |                  (((UInt64)t[14]) << 8) |                  (((UInt64)t[15]) << 0));
Magic Number,Portfish,Book,C:\repos\bpfliegel_Portfish\src\Book.cs,Read,The following statement contains a magic number: e.learn = (UInt32)(                  (((UInt64)t[12]) << 24) |                  (((UInt64)t[13]) << 16) |                  (((UInt64)t[14]) << 8) |                  (((UInt64)t[15]) << 0));
Magic Number,Portfish,Book,C:\repos\bpfliegel_Portfish\src\Book.cs,Read,The following statement contains a magic number: e.learn = (UInt32)(                  (((UInt64)t[12]) << 24) |                  (((UInt64)t[13]) << 16) |                  (((UInt64)t[14]) << 8) |                  (((UInt64)t[15]) << 0));
Magic Number,Portfish,Book,C:\repos\bpfliegel_Portfish\src\Book.cs,Read,The following statement contains a magic number: e.learn = (UInt32)(                  (((UInt64)t[12]) << 24) |                  (((UInt64)t[13]) << 16) |                  (((UInt64)t[14]) << 8) |                  (((UInt64)t[15]) << 0));
Magic Number,Portfish,Book,C:\repos\bpfliegel_Portfish\src\Book.cs,Read,The following statement contains a magic number: e.learn = (UInt32)(                  (((UInt64)t[12]) << 24) |                  (((UInt64)t[13]) << 16) |                  (((UInt64)t[14]) << 8) |                  (((UInt64)t[15]) << 0));
Magic Number,Portfish,Book,C:\repos\bpfliegel_Portfish\src\Book.cs,Read,The following statement contains a magic number: e.learn = (UInt32)(                  (((UInt64)t[12]) << 24) |                  (((UInt64)t[13]) << 16) |                  (((UInt64)t[14]) << 8) |                  (((UInt64)t[15]) << 0));
Magic Number,Portfish,Book,C:\repos\bpfliegel_Portfish\src\Book.cs,book_key,The following statement contains a magic number: while (b != 0)              {                  // Piece offset is at 64 * polyPiece where polyPiece is defined as:                  // BP = 0' WP = 1' BN = 2' WN = 3' ... BK = 10' WK = 11                  Square s = Utils.pop_1st_bit(ref b);                  Piece p = pos.piece_on(s);                  int polyPiece = 2 * (Utils.type_of(p) - 1) + (Utils.color_of(p) == ColorC.WHITE ? 1 : 0);                  key ^= PolyGlotRandoms[ZobPieceOffset + (64 * polyPiece + s)];              }
Magic Number,Portfish,Book,C:\repos\bpfliegel_Portfish\src\Book.cs,book_key,The following statement contains a magic number: while (b != 0)              {                  // Piece offset is at 64 * polyPiece where polyPiece is defined as:                  // BP = 0' WP = 1' BN = 2' WN = 3' ... BK = 10' WK = 11                  Square s = Utils.pop_1st_bit(ref b);                  Piece p = pos.piece_on(s);                  int polyPiece = 2 * (Utils.type_of(p) - 1) + (Utils.color_of(p) == ColorC.WHITE ? 1 : 0);                  key ^= PolyGlotRandoms[ZobPieceOffset + (64 * polyPiece + s)];              }
Magic Number,Portfish,Book,C:\repos\bpfliegel_Portfish\src\Book.cs,binary_search,The following statement contains a magic number: while (low < high)              {                  mid = (low + high) / 2;                    Debug.Assert(mid >= low && mid < high);                    br.BaseStream.Seek((long)(mid * SIZE_OF_BOOKENTRY)' SeekOrigin.Begin);                  Read(ref e' br);                    if (key <= e.key)                      high = mid;                  else                      low = mid + 1;              }
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,key,The following statement contains a magic number: Debug.Assert(code.Length > 0 && code.Length < 8);
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,key,The following statement contains a magic number: string fen = sides[0] + (char)('0' + (int)(8 - code.Length))                          + sides[1] + "/8/8/8/8/8/8/8 w - - 0 10";
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRKP,The following statement contains a magic number: if (wksq < bpsq && Utils.file_of(wksq) == Utils.file_of(bpsq))                  result = Constants.RookValueEndgame - (Utils.square_distance(wksq' bpsq));                // If the weaker side's king is too far from the pawn and the rook'              // it's a win              else if (Utils.square_distance(bksq' bpsq) - (tempo ^ 1) >= 3                       && Utils.square_distance(bksq' wrsq) >= 3)                  result = Constants.RookValueEndgame - (Utils.square_distance(wksq' bpsq));                // If the pawn is far advanced and supported by the defending king'              // the position is drawish              else if (Utils.rank_of(bksq) <= RankC.RANK_3                       && Utils.square_distance(bksq' bpsq) == 1                       && Utils.rank_of(wksq) >= RankC.RANK_4                       && Utils.square_distance(wksq' bpsq) - tempo > 2)                  result = (80 - Utils.square_distance(wksq' bpsq) * 8);                else                  result = (200)                          - (Utils.square_distance(wksq' bpsq + SquareC.DELTA_S) * 8)                          + (Utils.square_distance(bksq' bpsq + SquareC.DELTA_S) * 8)                          + (Utils.square_distance(bpsq' queeningSq) * 8);
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRKP,The following statement contains a magic number: if (wksq < bpsq && Utils.file_of(wksq) == Utils.file_of(bpsq))                  result = Constants.RookValueEndgame - (Utils.square_distance(wksq' bpsq));                // If the weaker side's king is too far from the pawn and the rook'              // it's a win              else if (Utils.square_distance(bksq' bpsq) - (tempo ^ 1) >= 3                       && Utils.square_distance(bksq' wrsq) >= 3)                  result = Constants.RookValueEndgame - (Utils.square_distance(wksq' bpsq));                // If the pawn is far advanced and supported by the defending king'              // the position is drawish              else if (Utils.rank_of(bksq) <= RankC.RANK_3                       && Utils.square_distance(bksq' bpsq) == 1                       && Utils.rank_of(wksq) >= RankC.RANK_4                       && Utils.square_distance(wksq' bpsq) - tempo > 2)                  result = (80 - Utils.square_distance(wksq' bpsq) * 8);                else                  result = (200)                          - (Utils.square_distance(wksq' bpsq + SquareC.DELTA_S) * 8)                          + (Utils.square_distance(bksq' bpsq + SquareC.DELTA_S) * 8)                          + (Utils.square_distance(bpsq' queeningSq) * 8);
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRKP,The following statement contains a magic number: if (wksq < bpsq && Utils.file_of(wksq) == Utils.file_of(bpsq))                  result = Constants.RookValueEndgame - (Utils.square_distance(wksq' bpsq));                // If the weaker side's king is too far from the pawn and the rook'              // it's a win              else if (Utils.square_distance(bksq' bpsq) - (tempo ^ 1) >= 3                       && Utils.square_distance(bksq' wrsq) >= 3)                  result = Constants.RookValueEndgame - (Utils.square_distance(wksq' bpsq));                // If the pawn is far advanced and supported by the defending king'              // the position is drawish              else if (Utils.rank_of(bksq) <= RankC.RANK_3                       && Utils.square_distance(bksq' bpsq) == 1                       && Utils.rank_of(wksq) >= RankC.RANK_4                       && Utils.square_distance(wksq' bpsq) - tempo > 2)                  result = (80 - Utils.square_distance(wksq' bpsq) * 8);                else                  result = (200)                          - (Utils.square_distance(wksq' bpsq + SquareC.DELTA_S) * 8)                          + (Utils.square_distance(bksq' bpsq + SquareC.DELTA_S) * 8)                          + (Utils.square_distance(bpsq' queeningSq) * 8);
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRKP,The following statement contains a magic number: if (wksq < bpsq && Utils.file_of(wksq) == Utils.file_of(bpsq))                  result = Constants.RookValueEndgame - (Utils.square_distance(wksq' bpsq));                // If the weaker side's king is too far from the pawn and the rook'              // it's a win              else if (Utils.square_distance(bksq' bpsq) - (tempo ^ 1) >= 3                       && Utils.square_distance(bksq' wrsq) >= 3)                  result = Constants.RookValueEndgame - (Utils.square_distance(wksq' bpsq));                // If the pawn is far advanced and supported by the defending king'              // the position is drawish              else if (Utils.rank_of(bksq) <= RankC.RANK_3                       && Utils.square_distance(bksq' bpsq) == 1                       && Utils.rank_of(wksq) >= RankC.RANK_4                       && Utils.square_distance(wksq' bpsq) - tempo > 2)                  result = (80 - Utils.square_distance(wksq' bpsq) * 8);                else                  result = (200)                          - (Utils.square_distance(wksq' bpsq + SquareC.DELTA_S) * 8)                          + (Utils.square_distance(bksq' bpsq + SquareC.DELTA_S) * 8)                          + (Utils.square_distance(bpsq' queeningSq) * 8);
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRKP,The following statement contains a magic number: if (wksq < bpsq && Utils.file_of(wksq) == Utils.file_of(bpsq))                  result = Constants.RookValueEndgame - (Utils.square_distance(wksq' bpsq));                // If the weaker side's king is too far from the pawn and the rook'              // it's a win              else if (Utils.square_distance(bksq' bpsq) - (tempo ^ 1) >= 3                       && Utils.square_distance(bksq' wrsq) >= 3)                  result = Constants.RookValueEndgame - (Utils.square_distance(wksq' bpsq));                // If the pawn is far advanced and supported by the defending king'              // the position is drawish              else if (Utils.rank_of(bksq) <= RankC.RANK_3                       && Utils.square_distance(bksq' bpsq) == 1                       && Utils.rank_of(wksq) >= RankC.RANK_4                       && Utils.square_distance(wksq' bpsq) - tempo > 2)                  result = (80 - Utils.square_distance(wksq' bpsq) * 8);                else                  result = (200)                          - (Utils.square_distance(wksq' bpsq + SquareC.DELTA_S) * 8)                          + (Utils.square_distance(bksq' bpsq + SquareC.DELTA_S) * 8)                          + (Utils.square_distance(bpsq' queeningSq) * 8);
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRKP,The following statement contains a magic number: if (wksq < bpsq && Utils.file_of(wksq) == Utils.file_of(bpsq))                  result = Constants.RookValueEndgame - (Utils.square_distance(wksq' bpsq));                // If the weaker side's king is too far from the pawn and the rook'              // it's a win              else if (Utils.square_distance(bksq' bpsq) - (tempo ^ 1) >= 3                       && Utils.square_distance(bksq' wrsq) >= 3)                  result = Constants.RookValueEndgame - (Utils.square_distance(wksq' bpsq));                // If the pawn is far advanced and supported by the defending king'              // the position is drawish              else if (Utils.rank_of(bksq) <= RankC.RANK_3                       && Utils.square_distance(bksq' bpsq) == 1                       && Utils.rank_of(wksq) >= RankC.RANK_4                       && Utils.square_distance(wksq' bpsq) - tempo > 2)                  result = (80 - Utils.square_distance(wksq' bpsq) * 8);                else                  result = (200)                          - (Utils.square_distance(wksq' bpsq + SquareC.DELTA_S) * 8)                          + (Utils.square_distance(bksq' bpsq + SquareC.DELTA_S) * 8)                          + (Utils.square_distance(bpsq' queeningSq) * 8);
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRKP,The following statement contains a magic number: if (wksq < bpsq && Utils.file_of(wksq) == Utils.file_of(bpsq))                  result = Constants.RookValueEndgame - (Utils.square_distance(wksq' bpsq));                // If the weaker side's king is too far from the pawn and the rook'              // it's a win              else if (Utils.square_distance(bksq' bpsq) - (tempo ^ 1) >= 3                       && Utils.square_distance(bksq' wrsq) >= 3)                  result = Constants.RookValueEndgame - (Utils.square_distance(wksq' bpsq));                // If the pawn is far advanced and supported by the defending king'              // the position is drawish              else if (Utils.rank_of(bksq) <= RankC.RANK_3                       && Utils.square_distance(bksq' bpsq) == 1                       && Utils.rank_of(wksq) >= RankC.RANK_4                       && Utils.square_distance(wksq' bpsq) - tempo > 2)                  result = (80 - Utils.square_distance(wksq' bpsq) * 8);                else                  result = (200)                          - (Utils.square_distance(wksq' bpsq + SquareC.DELTA_S) * 8)                          + (Utils.square_distance(bksq' bpsq + SquareC.DELTA_S) * 8)                          + (Utils.square_distance(bpsq' queeningSq) * 8);
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRKP,The following statement contains a magic number: if (wksq < bpsq && Utils.file_of(wksq) == Utils.file_of(bpsq))                  result = Constants.RookValueEndgame - (Utils.square_distance(wksq' bpsq));                // If the weaker side's king is too far from the pawn and the rook'              // it's a win              else if (Utils.square_distance(bksq' bpsq) - (tempo ^ 1) >= 3                       && Utils.square_distance(bksq' wrsq) >= 3)                  result = Constants.RookValueEndgame - (Utils.square_distance(wksq' bpsq));                // If the pawn is far advanced and supported by the defending king'              // the position is drawish              else if (Utils.rank_of(bksq) <= RankC.RANK_3                       && Utils.square_distance(bksq' bpsq) == 1                       && Utils.rank_of(wksq) >= RankC.RANK_4                       && Utils.square_distance(wksq' bpsq) - tempo > 2)                  result = (80 - Utils.square_distance(wksq' bpsq) * 8);                else                  result = (200)                          - (Utils.square_distance(wksq' bpsq + SquareC.DELTA_S) * 8)                          + (Utils.square_distance(bksq' bpsq + SquareC.DELTA_S) * 8)                          + (Utils.square_distance(bpsq' queeningSq) * 8);
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRKP,The following statement contains a magic number: if (wksq < bpsq && Utils.file_of(wksq) == Utils.file_of(bpsq))                  result = Constants.RookValueEndgame - (Utils.square_distance(wksq' bpsq));                // If the weaker side's king is too far from the pawn and the rook'              // it's a win              else if (Utils.square_distance(bksq' bpsq) - (tempo ^ 1) >= 3                       && Utils.square_distance(bksq' wrsq) >= 3)                  result = Constants.RookValueEndgame - (Utils.square_distance(wksq' bpsq));                // If the pawn is far advanced and supported by the defending king'              // the position is drawish              else if (Utils.rank_of(bksq) <= RankC.RANK_3                       && Utils.square_distance(bksq' bpsq) == 1                       && Utils.rank_of(wksq) >= RankC.RANK_4                       && Utils.square_distance(wksq' bpsq) - tempo > 2)                  result = (80 - Utils.square_distance(wksq' bpsq) * 8);                else                  result = (200)                          - (Utils.square_distance(wksq' bpsq + SquareC.DELTA_S) * 8)                          + (Utils.square_distance(bksq' bpsq + SquareC.DELTA_S) * 8)                          + (Utils.square_distance(bpsq' queeningSq) * 8);
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KBBKN,The following statement contains a magic number: Debug.Assert(pos.piece_count(strongerSide' PieceTypeC.BISHOP) == 2);
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KBBKN,The following statement contains a magic number: Debug.Assert(pos.non_pawn_material(strongerSide) == 2 * Constants.BishopValueMidgame);
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KBBKN,The following statement contains a magic number: result += (Utils.square_distance(bksq' nsq) * 32);
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KBBKN,The following statement contains a magic number: result += ((8 - Bitcount.popcount_1s_Max15(Position.attacks_from_KNIGHT(nsq))) * 8);
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KBBKN,The following statement contains a magic number: result += ((8 - Bitcount.popcount_1s_Max15(Position.attacks_from_KNIGHT(nsq))) * 8);
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KBPsK,The following statement contains a magic number: if ((pawnFile == FileC.FILE_A || pawnFile == FileC.FILE_H)                  && (((pawns & ~Utils.file_bb_F(pawnFile))) == 0))              {                  Square bishopSq = pos.pieceList[strongerSide][PieceTypeC.BISHOP][0];                  Square queeningSq = Utils.relative_square(strongerSide' Utils.make_square(pawnFile' RankC.RANK_8));                  Square kingSq = pos.king_square(weakerSide);                    if (Utils.opposite_colors(queeningSq' bishopSq)                      && Math.Abs(Utils.file_of(kingSq) - pawnFile) <= 1)                  {                      // The bishop has the wrong color' and the defending king is on the                      // file of the pawn(s) or the adjacent file. Find the rank of the                      // frontmost pawn.                      Rank rank;                      if (strongerSide == ColorC.WHITE)                      {                          for (rank = RankC.RANK_7; (((Utils.rank_bb_R(rank) & pawns)) == 0); rank--) { }                          Debug.Assert(rank >= RankC.RANK_2 && rank <= RankC.RANK_7);                      }                      else                      {                          for (rank = RankC.RANK_2; (((Utils.rank_bb_R(rank) & pawns)) == 0); rank++) { }                          rank = (rank ^ 7);  // HACK to get the relative rank                          Debug.Assert(rank >= RankC.RANK_2 && rank <= RankC.RANK_7);                      }                      // If the defending king has distance 1 to the promotion square or                      // is placed somewhere in front of the pawn' it's a draw.                      if (Utils.square_distance(kingSq' queeningSq) <= 1                          || Utils.relative_rank_CS(strongerSide' kingSq) >= rank)                          return ScaleFactorC.SCALE_FACTOR_DRAW;                  }              }
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRPKR,The following statement contains a magic number: if (r == RankC.RANK_6                  && Utils.square_distance(bksq' queeningSq) <= 1                  && Utils.rank_of(wksq) + tempo <= RankC.RANK_6                  && (Utils.rank_of(brsq) == RankC.RANK_1 || ((tempo == 0) && Math.Abs(Utils.file_of(brsq) - f) >= 3)))                  return ScaleFactorC.SCALE_FACTOR_DRAW;
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRPKR,The following statement contains a magic number: if (r >= RankC.RANK_6                  && bksq == queeningSq                  && Utils.rank_of(brsq) == RankC.RANK_1                  && ((tempo == 0) || Utils.square_distance(wksq' wpsq) >= 2))                  return ScaleFactorC.SCALE_FACTOR_DRAW;
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRPKR,The following statement contains a magic number: if (r <= RankC.RANK_5                  && bksq == wpsq + SquareC.DELTA_N                  && Utils.square_distance(wksq' wpsq) - tempo >= 2                  && Utils.square_distance(wksq' brsq) - tempo >= 2)                  return ScaleFactorC.SCALE_FACTOR_DRAW;
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRPKR,The following statement contains a magic number: if (r <= RankC.RANK_5                  && bksq == wpsq + SquareC.DELTA_N                  && Utils.square_distance(wksq' wpsq) - tempo >= 2                  && Utils.square_distance(wksq' brsq) - tempo >= 2)                  return ScaleFactorC.SCALE_FACTOR_DRAW;
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRPKR,The following statement contains a magic number: if (r == RankC.RANK_7                  && f != FileC.FILE_A                  && Utils.file_of(wrsq) == f                  && wrsq != queeningSq                  && (Utils.square_distance(wksq' queeningSq) < Utils.square_distance(bksq' queeningSq) - 2 + tempo)                  && (Utils.square_distance(wksq' queeningSq) < Utils.square_distance(bksq' wrsq) + tempo))                  return (ScaleFactorC.SCALE_FACTOR_MAX - 2 * Utils.square_distance(wksq' queeningSq));
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRPKR,The following statement contains a magic number: if (r == RankC.RANK_7                  && f != FileC.FILE_A                  && Utils.file_of(wrsq) == f                  && wrsq != queeningSq                  && (Utils.square_distance(wksq' queeningSq) < Utils.square_distance(bksq' queeningSq) - 2 + tempo)                  && (Utils.square_distance(wksq' queeningSq) < Utils.square_distance(bksq' wrsq) + tempo))                  return (ScaleFactorC.SCALE_FACTOR_MAX - 2 * Utils.square_distance(wksq' queeningSq));
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRPKR,The following statement contains a magic number: if (f != FileC.FILE_A                  && Utils.file_of(wrsq) == f                  && wrsq < wpsq                  && (Utils.square_distance(wksq' queeningSq) < Utils.square_distance(bksq' queeningSq) - 2 + tempo)                  && (Utils.square_distance(wksq' wpsq + SquareC.DELTA_N) < Utils.square_distance(bksq' wpsq + SquareC.DELTA_N) - 2 + tempo)                  && (Utils.square_distance(bksq' wrsq) + tempo >= 3                      || (Utils.square_distance(wksq' queeningSq) < Utils.square_distance(bksq' wrsq) + tempo                          && (Utils.square_distance(wksq' wpsq + SquareC.DELTA_N) < Utils.square_distance(bksq' wrsq) + tempo))))                  return (ScaleFactorC.SCALE_FACTOR_MAX                                     - 8 * Utils.square_distance(wpsq' queeningSq)                                     - 2 * Utils.square_distance(wksq' queeningSq));
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRPKR,The following statement contains a magic number: if (f != FileC.FILE_A                  && Utils.file_of(wrsq) == f                  && wrsq < wpsq                  && (Utils.square_distance(wksq' queeningSq) < Utils.square_distance(bksq' queeningSq) - 2 + tempo)                  && (Utils.square_distance(wksq' wpsq + SquareC.DELTA_N) < Utils.square_distance(bksq' wpsq + SquareC.DELTA_N) - 2 + tempo)                  && (Utils.square_distance(bksq' wrsq) + tempo >= 3                      || (Utils.square_distance(wksq' queeningSq) < Utils.square_distance(bksq' wrsq) + tempo                          && (Utils.square_distance(wksq' wpsq + SquareC.DELTA_N) < Utils.square_distance(bksq' wrsq) + tempo))))                  return (ScaleFactorC.SCALE_FACTOR_MAX                                     - 8 * Utils.square_distance(wpsq' queeningSq)                                     - 2 * Utils.square_distance(wksq' queeningSq));
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRPKR,The following statement contains a magic number: if (f != FileC.FILE_A                  && Utils.file_of(wrsq) == f                  && wrsq < wpsq                  && (Utils.square_distance(wksq' queeningSq) < Utils.square_distance(bksq' queeningSq) - 2 + tempo)                  && (Utils.square_distance(wksq' wpsq + SquareC.DELTA_N) < Utils.square_distance(bksq' wpsq + SquareC.DELTA_N) - 2 + tempo)                  && (Utils.square_distance(bksq' wrsq) + tempo >= 3                      || (Utils.square_distance(wksq' queeningSq) < Utils.square_distance(bksq' wrsq) + tempo                          && (Utils.square_distance(wksq' wpsq + SquareC.DELTA_N) < Utils.square_distance(bksq' wrsq) + tempo))))                  return (ScaleFactorC.SCALE_FACTOR_MAX                                     - 8 * Utils.square_distance(wpsq' queeningSq)                                     - 2 * Utils.square_distance(wksq' queeningSq));
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRPKR,The following statement contains a magic number: if (f != FileC.FILE_A                  && Utils.file_of(wrsq) == f                  && wrsq < wpsq                  && (Utils.square_distance(wksq' queeningSq) < Utils.square_distance(bksq' queeningSq) - 2 + tempo)                  && (Utils.square_distance(wksq' wpsq + SquareC.DELTA_N) < Utils.square_distance(bksq' wpsq + SquareC.DELTA_N) - 2 + tempo)                  && (Utils.square_distance(bksq' wrsq) + tempo >= 3                      || (Utils.square_distance(wksq' queeningSq) < Utils.square_distance(bksq' wrsq) + tempo                          && (Utils.square_distance(wksq' wpsq + SquareC.DELTA_N) < Utils.square_distance(bksq' wrsq) + tempo))))                  return (ScaleFactorC.SCALE_FACTOR_MAX                                     - 8 * Utils.square_distance(wpsq' queeningSq)                                     - 2 * Utils.square_distance(wksq' queeningSq));
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRPKR,The following statement contains a magic number: if (f != FileC.FILE_A                  && Utils.file_of(wrsq) == f                  && wrsq < wpsq                  && (Utils.square_distance(wksq' queeningSq) < Utils.square_distance(bksq' queeningSq) - 2 + tempo)                  && (Utils.square_distance(wksq' wpsq + SquareC.DELTA_N) < Utils.square_distance(bksq' wpsq + SquareC.DELTA_N) - 2 + tempo)                  && (Utils.square_distance(bksq' wrsq) + tempo >= 3                      || (Utils.square_distance(wksq' queeningSq) < Utils.square_distance(bksq' wrsq) + tempo                          && (Utils.square_distance(wksq' wpsq + SquareC.DELTA_N) < Utils.square_distance(bksq' wrsq) + tempo))))                  return (ScaleFactorC.SCALE_FACTOR_MAX                                     - 8 * Utils.square_distance(wpsq' queeningSq)                                     - 2 * Utils.square_distance(wksq' queeningSq));
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRPKR,The following statement contains a magic number: if (r <= RankC.RANK_4 && bksq > wpsq)              {                  if (Utils.file_of(bksq) == Utils.file_of(wpsq))                      return (10);                  if (Math.Abs(Utils.file_of(bksq) - Utils.file_of(wpsq)) == 1                      && Utils.square_distance(wksq' bksq) > 2)                      return (24 - 2 * Utils.square_distance(wksq' bksq));              }
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRPKR,The following statement contains a magic number: if (r <= RankC.RANK_4 && bksq > wpsq)              {                  if (Utils.file_of(bksq) == Utils.file_of(wpsq))                      return (10);                  if (Math.Abs(Utils.file_of(bksq) - Utils.file_of(wpsq)) == 1                      && Utils.square_distance(wksq' bksq) > 2)                      return (24 - 2 * Utils.square_distance(wksq' bksq));              }
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRPKR,The following statement contains a magic number: if (r <= RankC.RANK_4 && bksq > wpsq)              {                  if (Utils.file_of(bksq) == Utils.file_of(wpsq))                      return (10);                  if (Math.Abs(Utils.file_of(bksq) - Utils.file_of(wpsq)) == 1                      && Utils.square_distance(wksq' bksq) > 2)                      return (24 - 2 * Utils.square_distance(wksq' bksq));              }
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRPKR,The following statement contains a magic number: if (r <= RankC.RANK_4 && bksq > wpsq)              {                  if (Utils.file_of(bksq) == Utils.file_of(wpsq))                      return (10);                  if (Math.Abs(Utils.file_of(bksq) - Utils.file_of(wpsq)) == 1                      && Utils.square_distance(wksq' bksq) > 2)                      return (24 - 2 * Utils.square_distance(wksq' bksq));              }
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRPPKRP,The following statement contains a magic number: Debug.Assert(pos.piece_count(strongerSide' PieceTypeC.PAWN) == 2);
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRPPKRP,The following statement contains a magic number: if (Utils.file_distance(bksq' wpsq1) <= 1                  && Utils.file_distance(bksq' wpsq2) <= 1                  && Utils.relative_rank_CS(strongerSide' bksq) > r)              {                  switch (r)                  {                      case RankC.RANK_2: return (10);                      case RankC.RANK_3: return (10);                      case RankC.RANK_4: return (15);                      case RankC.RANK_5: return (20);                      case RankC.RANK_6: return (40);                      default: Debug.Assert(false); break;                  }              }
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRPPKRP,The following statement contains a magic number: if (Utils.file_distance(bksq' wpsq1) <= 1                  && Utils.file_distance(bksq' wpsq2) <= 1                  && Utils.relative_rank_CS(strongerSide' bksq) > r)              {                  switch (r)                  {                      case RankC.RANK_2: return (10);                      case RankC.RANK_3: return (10);                      case RankC.RANK_4: return (15);                      case RankC.RANK_5: return (20);                      case RankC.RANK_6: return (40);                      default: Debug.Assert(false); break;                  }              }
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRPPKRP,The following statement contains a magic number: if (Utils.file_distance(bksq' wpsq1) <= 1                  && Utils.file_distance(bksq' wpsq2) <= 1                  && Utils.relative_rank_CS(strongerSide' bksq) > r)              {                  switch (r)                  {                      case RankC.RANK_2: return (10);                      case RankC.RANK_3: return (10);                      case RankC.RANK_4: return (15);                      case RankC.RANK_5: return (20);                      case RankC.RANK_6: return (40);                      default: Debug.Assert(false); break;                  }              }
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRPPKRP,The following statement contains a magic number: if (Utils.file_distance(bksq' wpsq1) <= 1                  && Utils.file_distance(bksq' wpsq2) <= 1                  && Utils.relative_rank_CS(strongerSide' bksq) > r)              {                  switch (r)                  {                      case RankC.RANK_2: return (10);                      case RankC.RANK_3: return (10);                      case RankC.RANK_4: return (15);                      case RankC.RANK_5: return (20);                      case RankC.RANK_6: return (40);                      default: Debug.Assert(false); break;                  }              }
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KRPPKRP,The following statement contains a magic number: if (Utils.file_distance(bksq' wpsq1) <= 1                  && Utils.file_distance(bksq' wpsq2) <= 1                  && Utils.relative_rank_CS(strongerSide' bksq) > r)              {                  switch (r)                  {                      case RankC.RANK_2: return (10);                      case RankC.RANK_3: return (10);                      case RankC.RANK_4: return (15);                      case RankC.RANK_5: return (20);                      case RankC.RANK_6: return (40);                      default: Debug.Assert(false); break;                  }              }
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KPsK,The following statement contains a magic number: Debug.Assert(pos.piece_count(strongerSide' PieceTypeC.PAWN) >= 2);
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KBPKB,The following statement contains a magic number: if (Utils.opposite_colors(strongerBishopSq' weakerBishopSq))              {                  // We assume that the position is drawn in the following three situations:                  //                  //   a. The pawn is on rank 5 or further back.                  //   b. The defending king is somewhere in the pawn's path.                  //   c. The defending bishop attacks some square along the pawn's path'                  //      and is at least three squares away from the pawn.                  //                  // These rules are probably not perfect' but in practice they work                  // reasonably well.                    if (Utils.relative_rank_CS(strongerSide' pawnSq) <= RankC.RANK_5)                      return ScaleFactorC.SCALE_FACTOR_DRAW;                  else                  {                      Bitboard path = Utils.forward_bb(strongerSide' pawnSq);                        if ((path & pos.pieces_PTC(PieceTypeC.KING' weakerSide)) != 0)                          return ScaleFactorC.SCALE_FACTOR_DRAW;                        if (((pos.attacks_from_BISHOP(weakerBishopSq) & path) != 0)                          && Utils.square_distance(weakerBishopSq' pawnSq) >= 3)                          return ScaleFactorC.SCALE_FACTOR_DRAW;                  }              }
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KBPPKB,The following statement contains a magic number: Debug.Assert(pos.piece_count(strongerSide' PieceTypeC.PAWN) == 2);
Magic Number,Portfish,Endgame,C:\repos\bpfliegel_Portfish\src\Endgame.cs,Endgame_KBPPKB,The following statement contains a magic number: switch (Utils.file_distance(psq1' psq2))              {                  case 0:                      // Both pawns are on the same file. Easy draw if defender firmly controls                      // some square in the frontmost pawn's path.                      if (Utils.file_of(ksq) == Utils.file_of(blockSq1)                    && Utils.relative_rank_CS(strongerSide' ksq) >= Utils.relative_rank_CS(strongerSide' blockSq1)                    && Utils.opposite_colors(ksq' wbsq))                          return ScaleFactorC.SCALE_FACTOR_DRAW;                      else                          return ScaleFactorC.SCALE_FACTOR_NONE;                    case 1:                      // Pawns on adjacent files. Draw if defender firmly controls the square                      // in front of the frontmost pawn's path' and the square diagonally behind                      // this square on the file of the other pawn.                      if (ksq == blockSq1                          && Utils.opposite_colors(ksq' wbsq)                          && (bbsq == blockSq2                              || (((pos.attacks_from_BISHOP(blockSq2) & pos.pieces_PTC(PieceTypeC.BISHOP' weakerSide))) != 0)                              || Math.Abs(r1 - r2) >= 2))                          return ScaleFactorC.SCALE_FACTOR_DRAW;                        else if (ksq == blockSq2                               && Utils.opposite_colors(ksq' wbsq)                               && (bbsq == blockSq1                                   || (((pos.attacks_from_BISHOP(blockSq1) & pos.pieces_PTC(PieceTypeC.BISHOP' weakerSide)))) != 0))                          return ScaleFactorC.SCALE_FACTOR_DRAW;                      else                          return ScaleFactorC.SCALE_FACTOR_NONE;                    default:                      // The pawns are not on the same file or adjacent files. No scaling.                      return ScaleFactorC.SCALE_FACTOR_NONE;              }
Magic Number,Portfish,EvalInfo,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,EvalInfo,The following statement contains a magic number: for (int i = 0; i < 2; i++)              {                  attackedBy[i] = new Bitboard[8];              }
Magic Number,Portfish,EvalInfo,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,EvalInfo,The following statement contains a magic number: for (int i = 0; i < 2; i++)              {                  attackedBy[i] = new Bitboard[8];              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,init,The following statement contains a magic number: TracedScores[0] = new Score[16];
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,init,The following statement contains a magic number: TracedScores[1] = new Score[16];
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,init,The following statement contains a magic number: KingDangerTable[0] = new Score[128];
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,init,The following statement contains a magic number: KingDangerTable[1] = new Score[128];
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,init,The following statement contains a magic number: if (bool.Parse(OptionMap.Instance["UCI_AnalyseMode"].v))              {                  Weights[EvalWeightC.KingDangerUs] = Weights[EvalWeightC.KingDangerThem] = (Weights[EvalWeightC.KingDangerUs] + Weights[EvalWeightC.KingDangerThem]) / 2;              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,init,The following statement contains a magic number: for (int t = 0' i = 1; i < 100; i++)              {                  t = Math.Min(Peak' Math.Min((int)(0.4 * i * i)' t + MaxSlope));                    KingDangerTable[1][i] = Utils.apply_weight(Utils.make_score(t' 0)' Weights[EvalWeightC.KingDangerUs]);                  KingDangerTable[0][i] = Utils.apply_weight(Utils.make_score(t' 0)' Weights[EvalWeightC.KingDangerThem]);              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,init,The following statement contains a magic number: for (int t = 0' i = 1; i < 100; i++)              {                  t = Math.Min(Peak' Math.Min((int)(0.4 * i * i)' t + MaxSlope));                    KingDangerTable[1][i] = Utils.apply_weight(Utils.make_score(t' 0)' Weights[EvalWeightC.KingDangerUs]);                  KingDangerTable[0][i] = Utils.apply_weight(Utils.make_score(t' 0)' Weights[EvalWeightC.KingDangerThem]);              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,trace,The following statement contains a magic number: Array.Clear(TracedScores[0]' 0' 16);
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,trace,The following statement contains a magic number: Array.Clear(TracedScores[1]' 0' 16);
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,trace,The following statement contains a magic number: TraceStream.Append("Eval term ".PadLeft(21' ' '));
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,do_evaluate,The following statement contains a magic number: score += ((ei.mi.value << 16) + ei.mi.value);
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,do_evaluate,The following statement contains a magic number: score += (                  ((((int)(((((mobilityWhite - mobilityBlack) + 32768) & ~0xffff) / 0x10000)) * (((Weights[EvalWeightC.Mobility] + 32768) & ~0xffff) / 0x10000)) / 0x100) << 16) +                  (((int)(((Int16)((mobilityWhite - mobilityBlack) & 0xffff))) * ((Int16)(Weights[EvalWeightC.Mobility] & 0xffff))) / 0x100)              );
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,do_evaluate,The following statement contains a magic number: score += (                  ((((int)(((((mobilityWhite - mobilityBlack) + 32768) & ~0xffff) / 0x10000)) * (((Weights[EvalWeightC.Mobility] + 32768) & ~0xffff) / 0x10000)) / 0x100) << 16) +                  (((int)(((Int16)((mobilityWhite - mobilityBlack) & 0xffff))) * ((Int16)(Weights[EvalWeightC.Mobility] & 0xffff))) / 0x100)              );
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,do_evaluate,The following statement contains a magic number: score += (                  ((((int)(((((mobilityWhite - mobilityBlack) + 32768) & ~0xffff) / 0x10000)) * (((Weights[EvalWeightC.Mobility] + 32768) & ~0xffff) / 0x10000)) / 0x100) << 16) +                  (((int)(((Int16)((mobilityWhite - mobilityBlack) & 0xffff))) * ((Int16)(Weights[EvalWeightC.Mobility] & 0xffff))) / 0x100)              );
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,do_evaluate,The following statement contains a magic number: if (ei.mi.spaceWeight != 0)              {                  int s = evaluate_space(ColorC.WHITE' pos' ei) - evaluate_space(ColorC.BLACK' pos' ei);                  score += (((((int)((((((s * ei.mi.spaceWeight) << 16) + 32768) & ~0xffff) / 0x10000)) * (((Weights[EvalWeightC.Space] + 32768) & ~0xffff) / 0x10000)) / 0x100) << 16)                       + (((int)(((Int16)(((s * ei.mi.spaceWeight) << 16) & 0xffff))) * ((Int16)(Weights[EvalWeightC.Space] & 0xffff))) / 0x100));              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,do_evaluate,The following statement contains a magic number: if (ei.mi.spaceWeight != 0)              {                  int s = evaluate_space(ColorC.WHITE' pos' ei) - evaluate_space(ColorC.BLACK' pos' ei);                  score += (((((int)((((((s * ei.mi.spaceWeight) << 16) + 32768) & ~0xffff) / 0x10000)) * (((Weights[EvalWeightC.Space] + 32768) & ~0xffff) / 0x10000)) / 0x100) << 16)                       + (((int)(((Int16)(((s * ei.mi.spaceWeight) << 16) & 0xffff))) * ((Int16)(Weights[EvalWeightC.Space] & 0xffff))) / 0x100));              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,do_evaluate,The following statement contains a magic number: if (ei.mi.spaceWeight != 0)              {                  int s = evaluate_space(ColorC.WHITE' pos' ei) - evaluate_space(ColorC.BLACK' pos' ei);                  score += (((((int)((((((s * ei.mi.spaceWeight) << 16) + 32768) & ~0xffff) / 0x10000)) * (((Weights[EvalWeightC.Space] + 32768) & ~0xffff) / 0x10000)) / 0x100) << 16)                       + (((int)(((Int16)(((s * ei.mi.spaceWeight) << 16) & 0xffff))) * ((Int16)(Weights[EvalWeightC.Space] & 0xffff))) / 0x100));              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,do_evaluate,The following statement contains a magic number: if (ei.mi.spaceWeight != 0)              {                  int s = evaluate_space(ColorC.WHITE' pos' ei) - evaluate_space(ColorC.BLACK' pos' ei);                  score += (((((int)((((((s * ei.mi.spaceWeight) << 16) + 32768) & ~0xffff) / 0x10000)) * (((Weights[EvalWeightC.Space] + 32768) & ~0xffff) / 0x10000)) / 0x100) << 16)                       + (((int)(((Int16)(((s * ei.mi.spaceWeight) << 16) & 0xffff))) * ((Int16)(Weights[EvalWeightC.Space] & 0xffff))) / 0x100));              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,do_evaluate,The following statement contains a magic number: if (ei.mi.spaceWeight != 0)              {                  int s = evaluate_space(ColorC.WHITE' pos' ei) - evaluate_space(ColorC.BLACK' pos' ei);                  score += (((((int)((((((s * ei.mi.spaceWeight) << 16) + 32768) & ~0xffff) / 0x10000)) * (((Weights[EvalWeightC.Space] + 32768) & ~0xffff) / 0x10000)) / 0x100) << 16)                       + (((int)(((Int16)(((s * ei.mi.spaceWeight) << 16) & 0xffff))) * ((Int16)(Weights[EvalWeightC.Space] & 0xffff))) / 0x100));              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,do_evaluate,The following statement contains a magic number: if (ei.mi.gamePhase < PhaseC.PHASE_MIDGAME                  &&                   (                      pos.pieceCount[ColorC.WHITE][PieceTypeC.BISHOP] == 1                      &&                       pos.pieceCount[ColorC.BLACK][PieceTypeC.BISHOP] == 1                      &&                       (((((pos.pieceList[ColorC.WHITE][PieceTypeC.BISHOP][0] ^ pos.pieceList[ColorC.BLACK][PieceTypeC.BISHOP][0]) >> 3) ^ (pos.pieceList[ColorC.WHITE][PieceTypeC.BISHOP][0] ^ pos.pieceList[ColorC.BLACK][PieceTypeC.BISHOP][0])) & 1) != 0)                  )                  && sf == ScaleFactorC.SCALE_FACTOR_NORMAL)              {                  // Only the two bishops ?                  if (pos.st.npMaterialWHITE == Constants.BishopValueMidgame && pos.st.npMaterialBLACK == Constants.BishopValueMidgame)                  {                      // Check for KBP vs KB with only a single pawn that is almost                      // certainly a draw or at least two pawns.                      sf = (pos.pieceCount[ColorC.WHITE][PieceTypeC.PAWN] + pos.pieceCount[ColorC.BLACK][PieceTypeC.PAWN] == 1) ? (8) : (32);                  }                  else                      // Endgame with opposite-colored bishops' but also other pieces. Still                      // a bit drawish' but not as drawish as with only the two bishops.                      sf = (50);              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,do_evaluate,The following statement contains a magic number: if (ei.mi.gamePhase < PhaseC.PHASE_MIDGAME                  &&                   (                      pos.pieceCount[ColorC.WHITE][PieceTypeC.BISHOP] == 1                      &&                       pos.pieceCount[ColorC.BLACK][PieceTypeC.BISHOP] == 1                      &&                       (((((pos.pieceList[ColorC.WHITE][PieceTypeC.BISHOP][0] ^ pos.pieceList[ColorC.BLACK][PieceTypeC.BISHOP][0]) >> 3) ^ (pos.pieceList[ColorC.WHITE][PieceTypeC.BISHOP][0] ^ pos.pieceList[ColorC.BLACK][PieceTypeC.BISHOP][0])) & 1) != 0)                  )                  && sf == ScaleFactorC.SCALE_FACTOR_NORMAL)              {                  // Only the two bishops ?                  if (pos.st.npMaterialWHITE == Constants.BishopValueMidgame && pos.st.npMaterialBLACK == Constants.BishopValueMidgame)                  {                      // Check for KBP vs KB with only a single pawn that is almost                      // certainly a draw or at least two pawns.                      sf = (pos.pieceCount[ColorC.WHITE][PieceTypeC.PAWN] + pos.pieceCount[ColorC.BLACK][PieceTypeC.PAWN] == 1) ? (8) : (32);                  }                  else                      // Endgame with opposite-colored bishops' but also other pieces. Still                      // a bit drawish' but not as drawish as with only the two bishops.                      sf = (50);              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,do_evaluate,The following statement contains a magic number: if (ei.mi.gamePhase < PhaseC.PHASE_MIDGAME                  &&                   (                      pos.pieceCount[ColorC.WHITE][PieceTypeC.BISHOP] == 1                      &&                       pos.pieceCount[ColorC.BLACK][PieceTypeC.BISHOP] == 1                      &&                       (((((pos.pieceList[ColorC.WHITE][PieceTypeC.BISHOP][0] ^ pos.pieceList[ColorC.BLACK][PieceTypeC.BISHOP][0]) >> 3) ^ (pos.pieceList[ColorC.WHITE][PieceTypeC.BISHOP][0] ^ pos.pieceList[ColorC.BLACK][PieceTypeC.BISHOP][0])) & 1) != 0)                  )                  && sf == ScaleFactorC.SCALE_FACTOR_NORMAL)              {                  // Only the two bishops ?                  if (pos.st.npMaterialWHITE == Constants.BishopValueMidgame && pos.st.npMaterialBLACK == Constants.BishopValueMidgame)                  {                      // Check for KBP vs KB with only a single pawn that is almost                      // certainly a draw or at least two pawns.                      sf = (pos.pieceCount[ColorC.WHITE][PieceTypeC.PAWN] + pos.pieceCount[ColorC.BLACK][PieceTypeC.PAWN] == 1) ? (8) : (32);                  }                  else                      // Endgame with opposite-colored bishops' but also other pieces. Still                      // a bit drawish' but not as drawish as with only the two bishops.                      sf = (50);              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,do_evaluate,The following statement contains a magic number: if (ei.mi.gamePhase < PhaseC.PHASE_MIDGAME                  &&                   (                      pos.pieceCount[ColorC.WHITE][PieceTypeC.BISHOP] == 1                      &&                       pos.pieceCount[ColorC.BLACK][PieceTypeC.BISHOP] == 1                      &&                       (((((pos.pieceList[ColorC.WHITE][PieceTypeC.BISHOP][0] ^ pos.pieceList[ColorC.BLACK][PieceTypeC.BISHOP][0]) >> 3) ^ (pos.pieceList[ColorC.WHITE][PieceTypeC.BISHOP][0] ^ pos.pieceList[ColorC.BLACK][PieceTypeC.BISHOP][0])) & 1) != 0)                  )                  && sf == ScaleFactorC.SCALE_FACTOR_NORMAL)              {                  // Only the two bishops ?                  if (pos.st.npMaterialWHITE == Constants.BishopValueMidgame && pos.st.npMaterialBLACK == Constants.BishopValueMidgame)                  {                      // Check for KBP vs KB with only a single pawn that is almost                      // certainly a draw or at least two pawns.                      sf = (pos.pieceCount[ColorC.WHITE][PieceTypeC.PAWN] + pos.pieceCount[ColorC.BLACK][PieceTypeC.PAWN] == 1) ? (8) : (32);                  }                  else                      // Endgame with opposite-colored bishops' but also other pieces. Still                      // a bit drawish' but not as drawish as with only the two bishops.                      sf = (50);              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,do_evaluate,The following statement contains a magic number: int result = ((((score + 32768) & ~0xffff) / 0x10000) * (int)(ei.mi.gamePhase) + ev * (int)(128 - ei.mi.gamePhase)) / 128;
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,do_evaluate,The following statement contains a magic number: int result = ((((score + 32768) & ~0xffff) / 0x10000) * (int)(ei.mi.gamePhase) + ev * (int)(128 - ei.mi.gamePhase)) / 128;
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,do_evaluate,The following statement contains a magic number: int result = ((((score + 32768) & ~0xffff) / 0x10000) * (int)(ei.mi.gamePhase) + ev * (int)(128 - ei.mi.gamePhase)) / 128;
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,do_evaluate,The following statement contains a magic number: Value v = ((result + GrainSize / 2) & ~(GrainSize - 1));
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,do_evaluate,The following statement contains a magic number: if (Trace)              {                  trace_add(TracedTypeC.PST' pos.psq_score());                  trace_add(TracedTypeC.IMBALANCE' ei.mi.material_value());                  trace_add(PieceTypeC.PAWN' ei.pi.pawns_value());                  trace_add(TracedTypeC.MOBILITY' Utils.apply_weight(mobilityWhite' Weights[EvalWeightC.Mobility])' Utils.apply_weight(mobilityBlack' Weights[EvalWeightC.Mobility]));                  trace_add(TracedTypeC.THREAT' evaluate_threats(ColorC.WHITE' pos' ei)' evaluate_threats(ColorC.BLACK' pos' ei));                  trace_add(TracedTypeC.PASSED' evaluate_passed_pawns(ColorC.WHITE' pos' ei)' evaluate_passed_pawns(ColorC.BLACK' pos' ei));                  trace_add(TracedTypeC.UNSTOPPABLE' evaluate_unstoppable_pawns(pos' ei));                  Score w = Utils.make_score(ei.mi.space_weight() * evaluate_space(ColorC.WHITE' pos' ei)' 0);                  Score b = Utils.make_score(ei.mi.space_weight() * evaluate_space(ColorC.BLACK' pos' ei)' 0);                  trace_add(TracedTypeC.SPACE' Utils.apply_weight(w' Weights[EvalWeightC.Space])' Utils.apply_weight(b' Weights[EvalWeightC.Space]));                  trace_add(TracedTypeC.TOTAL' score);                    TraceStream.Append("\nUncertainty margin: White: ");                  TraceStream.Append(FormatDouble(to_cp(marginsWHITE)' null' true));                  TraceStream.Append("' Black: ");                  TraceStream.Append(FormatDouble(to_cp(marginsBLACK)' null' true));                  TraceStream.Append("\nScaling: ");                  TraceStream.Append(FormatDouble((100.0 * ei.mi.game_phase() / 128.0)' 6' false));                  TraceStream.Append("% MG' ");                  TraceStream.Append(FormatDouble((100.0 * (1.0 - ei.mi.game_phase() / 128.0))' 6' false));                  TraceStream.Append("% * ");                  TraceStream.Append(FormatDouble(((100.0 * sf) / ScaleFactorC.SCALE_FACTOR_NORMAL)' 6' false));                  TraceStream.Append("% EG.\n");                  TraceStream.Append("Total evaluation: ");                  TraceStream.Append(FormatDouble(to_cp(v)' null' false));              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,do_evaluate,The following statement contains a magic number: if (Trace)              {                  trace_add(TracedTypeC.PST' pos.psq_score());                  trace_add(TracedTypeC.IMBALANCE' ei.mi.material_value());                  trace_add(PieceTypeC.PAWN' ei.pi.pawns_value());                  trace_add(TracedTypeC.MOBILITY' Utils.apply_weight(mobilityWhite' Weights[EvalWeightC.Mobility])' Utils.apply_weight(mobilityBlack' Weights[EvalWeightC.Mobility]));                  trace_add(TracedTypeC.THREAT' evaluate_threats(ColorC.WHITE' pos' ei)' evaluate_threats(ColorC.BLACK' pos' ei));                  trace_add(TracedTypeC.PASSED' evaluate_passed_pawns(ColorC.WHITE' pos' ei)' evaluate_passed_pawns(ColorC.BLACK' pos' ei));                  trace_add(TracedTypeC.UNSTOPPABLE' evaluate_unstoppable_pawns(pos' ei));                  Score w = Utils.make_score(ei.mi.space_weight() * evaluate_space(ColorC.WHITE' pos' ei)' 0);                  Score b = Utils.make_score(ei.mi.space_weight() * evaluate_space(ColorC.BLACK' pos' ei)' 0);                  trace_add(TracedTypeC.SPACE' Utils.apply_weight(w' Weights[EvalWeightC.Space])' Utils.apply_weight(b' Weights[EvalWeightC.Space]));                  trace_add(TracedTypeC.TOTAL' score);                    TraceStream.Append("\nUncertainty margin: White: ");                  TraceStream.Append(FormatDouble(to_cp(marginsWHITE)' null' true));                  TraceStream.Append("' Black: ");                  TraceStream.Append(FormatDouble(to_cp(marginsBLACK)' null' true));                  TraceStream.Append("\nScaling: ");                  TraceStream.Append(FormatDouble((100.0 * ei.mi.game_phase() / 128.0)' 6' false));                  TraceStream.Append("% MG' ");                  TraceStream.Append(FormatDouble((100.0 * (1.0 - ei.mi.game_phase() / 128.0))' 6' false));                  TraceStream.Append("% * ");                  TraceStream.Append(FormatDouble(((100.0 * sf) / ScaleFactorC.SCALE_FACTOR_NORMAL)' 6' false));                  TraceStream.Append("% EG.\n");                  TraceStream.Append("Total evaluation: ");                  TraceStream.Append(FormatDouble(to_cp(v)' null' false));              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,do_evaluate,The following statement contains a magic number: if (Trace)              {                  trace_add(TracedTypeC.PST' pos.psq_score());                  trace_add(TracedTypeC.IMBALANCE' ei.mi.material_value());                  trace_add(PieceTypeC.PAWN' ei.pi.pawns_value());                  trace_add(TracedTypeC.MOBILITY' Utils.apply_weight(mobilityWhite' Weights[EvalWeightC.Mobility])' Utils.apply_weight(mobilityBlack' Weights[EvalWeightC.Mobility]));                  trace_add(TracedTypeC.THREAT' evaluate_threats(ColorC.WHITE' pos' ei)' evaluate_threats(ColorC.BLACK' pos' ei));                  trace_add(TracedTypeC.PASSED' evaluate_passed_pawns(ColorC.WHITE' pos' ei)' evaluate_passed_pawns(ColorC.BLACK' pos' ei));                  trace_add(TracedTypeC.UNSTOPPABLE' evaluate_unstoppable_pawns(pos' ei));                  Score w = Utils.make_score(ei.mi.space_weight() * evaluate_space(ColorC.WHITE' pos' ei)' 0);                  Score b = Utils.make_score(ei.mi.space_weight() * evaluate_space(ColorC.BLACK' pos' ei)' 0);                  trace_add(TracedTypeC.SPACE' Utils.apply_weight(w' Weights[EvalWeightC.Space])' Utils.apply_weight(b' Weights[EvalWeightC.Space]));                  trace_add(TracedTypeC.TOTAL' score);                    TraceStream.Append("\nUncertainty margin: White: ");                  TraceStream.Append(FormatDouble(to_cp(marginsWHITE)' null' true));                  TraceStream.Append("' Black: ");                  TraceStream.Append(FormatDouble(to_cp(marginsBLACK)' null' true));                  TraceStream.Append("\nScaling: ");                  TraceStream.Append(FormatDouble((100.0 * ei.mi.game_phase() / 128.0)' 6' false));                  TraceStream.Append("% MG' ");                  TraceStream.Append(FormatDouble((100.0 * (1.0 - ei.mi.game_phase() / 128.0))' 6' false));                  TraceStream.Append("% * ");                  TraceStream.Append(FormatDouble(((100.0 * sf) / ScaleFactorC.SCALE_FACTOR_NORMAL)' 6' false));                  TraceStream.Append("% EG.\n");                  TraceStream.Append("Total evaluation: ");                  TraceStream.Append(FormatDouble(to_cp(v)' null' false));              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,do_evaluate,The following statement contains a magic number: if (Trace)              {                  trace_add(TracedTypeC.PST' pos.psq_score());                  trace_add(TracedTypeC.IMBALANCE' ei.mi.material_value());                  trace_add(PieceTypeC.PAWN' ei.pi.pawns_value());                  trace_add(TracedTypeC.MOBILITY' Utils.apply_weight(mobilityWhite' Weights[EvalWeightC.Mobility])' Utils.apply_weight(mobilityBlack' Weights[EvalWeightC.Mobility]));                  trace_add(TracedTypeC.THREAT' evaluate_threats(ColorC.WHITE' pos' ei)' evaluate_threats(ColorC.BLACK' pos' ei));                  trace_add(TracedTypeC.PASSED' evaluate_passed_pawns(ColorC.WHITE' pos' ei)' evaluate_passed_pawns(ColorC.BLACK' pos' ei));                  trace_add(TracedTypeC.UNSTOPPABLE' evaluate_unstoppable_pawns(pos' ei));                  Score w = Utils.make_score(ei.mi.space_weight() * evaluate_space(ColorC.WHITE' pos' ei)' 0);                  Score b = Utils.make_score(ei.mi.space_weight() * evaluate_space(ColorC.BLACK' pos' ei)' 0);                  trace_add(TracedTypeC.SPACE' Utils.apply_weight(w' Weights[EvalWeightC.Space])' Utils.apply_weight(b' Weights[EvalWeightC.Space]));                  trace_add(TracedTypeC.TOTAL' score);                    TraceStream.Append("\nUncertainty margin: White: ");                  TraceStream.Append(FormatDouble(to_cp(marginsWHITE)' null' true));                  TraceStream.Append("' Black: ");                  TraceStream.Append(FormatDouble(to_cp(marginsBLACK)' null' true));                  TraceStream.Append("\nScaling: ");                  TraceStream.Append(FormatDouble((100.0 * ei.mi.game_phase() / 128.0)' 6' false));                  TraceStream.Append("% MG' ");                  TraceStream.Append(FormatDouble((100.0 * (1.0 - ei.mi.game_phase() / 128.0))' 6' false));                  TraceStream.Append("% * ");                  TraceStream.Append(FormatDouble(((100.0 * sf) / ScaleFactorC.SCALE_FACTOR_NORMAL)' 6' false));                  TraceStream.Append("% EG.\n");                  TraceStream.Append("Total evaluation: ");                  TraceStream.Append(FormatDouble(to_cp(v)' null' false));              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,do_evaluate,The following statement contains a magic number: if (Trace)              {                  trace_add(TracedTypeC.PST' pos.psq_score());                  trace_add(TracedTypeC.IMBALANCE' ei.mi.material_value());                  trace_add(PieceTypeC.PAWN' ei.pi.pawns_value());                  trace_add(TracedTypeC.MOBILITY' Utils.apply_weight(mobilityWhite' Weights[EvalWeightC.Mobility])' Utils.apply_weight(mobilityBlack' Weights[EvalWeightC.Mobility]));                  trace_add(TracedTypeC.THREAT' evaluate_threats(ColorC.WHITE' pos' ei)' evaluate_threats(ColorC.BLACK' pos' ei));                  trace_add(TracedTypeC.PASSED' evaluate_passed_pawns(ColorC.WHITE' pos' ei)' evaluate_passed_pawns(ColorC.BLACK' pos' ei));                  trace_add(TracedTypeC.UNSTOPPABLE' evaluate_unstoppable_pawns(pos' ei));                  Score w = Utils.make_score(ei.mi.space_weight() * evaluate_space(ColorC.WHITE' pos' ei)' 0);                  Score b = Utils.make_score(ei.mi.space_weight() * evaluate_space(ColorC.BLACK' pos' ei)' 0);                  trace_add(TracedTypeC.SPACE' Utils.apply_weight(w' Weights[EvalWeightC.Space])' Utils.apply_weight(b' Weights[EvalWeightC.Space]));                  trace_add(TracedTypeC.TOTAL' score);                    TraceStream.Append("\nUncertainty margin: White: ");                  TraceStream.Append(FormatDouble(to_cp(marginsWHITE)' null' true));                  TraceStream.Append("' Black: ");                  TraceStream.Append(FormatDouble(to_cp(marginsBLACK)' null' true));                  TraceStream.Append("\nScaling: ");                  TraceStream.Append(FormatDouble((100.0 * ei.mi.game_phase() / 128.0)' 6' false));                  TraceStream.Append("% MG' ");                  TraceStream.Append(FormatDouble((100.0 * (1.0 - ei.mi.game_phase() / 128.0))' 6' false));                  TraceStream.Append("% * ");                  TraceStream.Append(FormatDouble(((100.0 * sf) / ScaleFactorC.SCALE_FACTOR_NORMAL)' 6' false));                  TraceStream.Append("% EG.\n");                  TraceStream.Append("Total evaluation: ");                  TraceStream.Append(FormatDouble(to_cp(v)' null' false));              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,do_evaluate,The following statement contains a magic number: if (Trace)              {                  trace_add(TracedTypeC.PST' pos.psq_score());                  trace_add(TracedTypeC.IMBALANCE' ei.mi.material_value());                  trace_add(PieceTypeC.PAWN' ei.pi.pawns_value());                  trace_add(TracedTypeC.MOBILITY' Utils.apply_weight(mobilityWhite' Weights[EvalWeightC.Mobility])' Utils.apply_weight(mobilityBlack' Weights[EvalWeightC.Mobility]));                  trace_add(TracedTypeC.THREAT' evaluate_threats(ColorC.WHITE' pos' ei)' evaluate_threats(ColorC.BLACK' pos' ei));                  trace_add(TracedTypeC.PASSED' evaluate_passed_pawns(ColorC.WHITE' pos' ei)' evaluate_passed_pawns(ColorC.BLACK' pos' ei));                  trace_add(TracedTypeC.UNSTOPPABLE' evaluate_unstoppable_pawns(pos' ei));                  Score w = Utils.make_score(ei.mi.space_weight() * evaluate_space(ColorC.WHITE' pos' ei)' 0);                  Score b = Utils.make_score(ei.mi.space_weight() * evaluate_space(ColorC.BLACK' pos' ei)' 0);                  trace_add(TracedTypeC.SPACE' Utils.apply_weight(w' Weights[EvalWeightC.Space])' Utils.apply_weight(b' Weights[EvalWeightC.Space]));                  trace_add(TracedTypeC.TOTAL' score);                    TraceStream.Append("\nUncertainty margin: White: ");                  TraceStream.Append(FormatDouble(to_cp(marginsWHITE)' null' true));                  TraceStream.Append("' Black: ");                  TraceStream.Append(FormatDouble(to_cp(marginsBLACK)' null' true));                  TraceStream.Append("\nScaling: ");                  TraceStream.Append(FormatDouble((100.0 * ei.mi.game_phase() / 128.0)' 6' false));                  TraceStream.Append("% MG' ");                  TraceStream.Append(FormatDouble((100.0 * (1.0 - ei.mi.game_phase() / 128.0))' 6' false));                  TraceStream.Append("% * ");                  TraceStream.Append(FormatDouble(((100.0 * sf) / ScaleFactorC.SCALE_FACTOR_NORMAL)' 6' false));                  TraceStream.Append("% EG.\n");                  TraceStream.Append("Total evaluation: ");                  TraceStream.Append(FormatDouble(to_cp(v)' null' false));              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,do_evaluate,The following statement contains a magic number: if (Trace)              {                  trace_add(TracedTypeC.PST' pos.psq_score());                  trace_add(TracedTypeC.IMBALANCE' ei.mi.material_value());                  trace_add(PieceTypeC.PAWN' ei.pi.pawns_value());                  trace_add(TracedTypeC.MOBILITY' Utils.apply_weight(mobilityWhite' Weights[EvalWeightC.Mobility])' Utils.apply_weight(mobilityBlack' Weights[EvalWeightC.Mobility]));                  trace_add(TracedTypeC.THREAT' evaluate_threats(ColorC.WHITE' pos' ei)' evaluate_threats(ColorC.BLACK' pos' ei));                  trace_add(TracedTypeC.PASSED' evaluate_passed_pawns(ColorC.WHITE' pos' ei)' evaluate_passed_pawns(ColorC.BLACK' pos' ei));                  trace_add(TracedTypeC.UNSTOPPABLE' evaluate_unstoppable_pawns(pos' ei));                  Score w = Utils.make_score(ei.mi.space_weight() * evaluate_space(ColorC.WHITE' pos' ei)' 0);                  Score b = Utils.make_score(ei.mi.space_weight() * evaluate_space(ColorC.BLACK' pos' ei)' 0);                  trace_add(TracedTypeC.SPACE' Utils.apply_weight(w' Weights[EvalWeightC.Space])' Utils.apply_weight(b' Weights[EvalWeightC.Space]));                  trace_add(TracedTypeC.TOTAL' score);                    TraceStream.Append("\nUncertainty margin: White: ");                  TraceStream.Append(FormatDouble(to_cp(marginsWHITE)' null' true));                  TraceStream.Append("' Black: ");                  TraceStream.Append(FormatDouble(to_cp(marginsBLACK)' null' true));                  TraceStream.Append("\nScaling: ");                  TraceStream.Append(FormatDouble((100.0 * ei.mi.game_phase() / 128.0)' 6' false));                  TraceStream.Append("% MG' ");                  TraceStream.Append(FormatDouble((100.0 * (1.0 - ei.mi.game_phase() / 128.0))' 6' false));                  TraceStream.Append("% * ");                  TraceStream.Append(FormatDouble(((100.0 * sf) / ScaleFactorC.SCALE_FACTOR_NORMAL)' 6' false));                  TraceStream.Append("% EG.\n");                  TraceStream.Append("Total evaluation: ");                  TraceStream.Append(FormatDouble(to_cp(v)' null' false));              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,do_evaluate,The following statement contains a magic number: if (Trace)              {                  trace_add(TracedTypeC.PST' pos.psq_score());                  trace_add(TracedTypeC.IMBALANCE' ei.mi.material_value());                  trace_add(PieceTypeC.PAWN' ei.pi.pawns_value());                  trace_add(TracedTypeC.MOBILITY' Utils.apply_weight(mobilityWhite' Weights[EvalWeightC.Mobility])' Utils.apply_weight(mobilityBlack' Weights[EvalWeightC.Mobility]));                  trace_add(TracedTypeC.THREAT' evaluate_threats(ColorC.WHITE' pos' ei)' evaluate_threats(ColorC.BLACK' pos' ei));                  trace_add(TracedTypeC.PASSED' evaluate_passed_pawns(ColorC.WHITE' pos' ei)' evaluate_passed_pawns(ColorC.BLACK' pos' ei));                  trace_add(TracedTypeC.UNSTOPPABLE' evaluate_unstoppable_pawns(pos' ei));                  Score w = Utils.make_score(ei.mi.space_weight() * evaluate_space(ColorC.WHITE' pos' ei)' 0);                  Score b = Utils.make_score(ei.mi.space_weight() * evaluate_space(ColorC.BLACK' pos' ei)' 0);                  trace_add(TracedTypeC.SPACE' Utils.apply_weight(w' Weights[EvalWeightC.Space])' Utils.apply_weight(b' Weights[EvalWeightC.Space]));                  trace_add(TracedTypeC.TOTAL' score);                    TraceStream.Append("\nUncertainty margin: White: ");                  TraceStream.Append(FormatDouble(to_cp(marginsWHITE)' null' true));                  TraceStream.Append("' Black: ");                  TraceStream.Append(FormatDouble(to_cp(marginsBLACK)' null' true));                  TraceStream.Append("\nScaling: ");                  TraceStream.Append(FormatDouble((100.0 * ei.mi.game_phase() / 128.0)' 6' false));                  TraceStream.Append("% MG' ");                  TraceStream.Append(FormatDouble((100.0 * (1.0 - ei.mi.game_phase() / 128.0))' 6' false));                  TraceStream.Append("% * ");                  TraceStream.Append(FormatDouble(((100.0 * sf) / ScaleFactorC.SCALE_FACTOR_NORMAL)' 6' false));                  TraceStream.Append("% EG.\n");                  TraceStream.Append("Total evaluation: ");                  TraceStream.Append(FormatDouble(to_cp(v)' null' false));              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,init_eval_info,The following statement contains a magic number: if ((pos.pieceCount[Us][PieceTypeC.QUEEN] != 0)                  && (Us == 0 ? pos.st.npMaterialWHITE : pos.st.npMaterialBLACK) >= Constants.QueenValueMidgame + Constants.RookValueMidgame)              {                  ei.kingRing[Them] = (b | (Us == ColorC.WHITE ? b >> 8 : b << 8));                  b &= ei.attackedBy[Us][PieceTypeC.PAWN];                  ei.kingAttackersCount[Us] = (b != 0) ? Bitcount.popcount_1s_Max15(b) / 2 : 0;                  ei.kingAdjacentZoneAttacksCount[Us] = ei.kingAttackersWeight[Us] = 0;              }              else              {                  ei.kingRing[Them] = 0; ei.kingAttackersCount[Us] = 0;              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,init_eval_info,The following statement contains a magic number: if ((pos.pieceCount[Us][PieceTypeC.QUEEN] != 0)                  && (Us == 0 ? pos.st.npMaterialWHITE : pos.st.npMaterialBLACK) >= Constants.QueenValueMidgame + Constants.RookValueMidgame)              {                  ei.kingRing[Them] = (b | (Us == ColorC.WHITE ? b >> 8 : b << 8));                  b &= ei.attackedBy[Us][PieceTypeC.PAWN];                  ei.kingAttackersCount[Us] = (b != 0) ? Bitcount.popcount_1s_Max15(b) / 2 : 0;                  ei.kingAdjacentZoneAttacksCount[Us] = ei.kingAttackersWeight[Us] = 0;              }              else              {                  ei.kingRing[Them] = 0; ei.kingAttackersCount[Us] = 0;              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,init_eval_info,The following statement contains a magic number: if ((pos.pieceCount[Us][PieceTypeC.QUEEN] != 0)                  && (Us == 0 ? pos.st.npMaterialWHITE : pos.st.npMaterialBLACK) >= Constants.QueenValueMidgame + Constants.RookValueMidgame)              {                  ei.kingRing[Them] = (b | (Us == ColorC.WHITE ? b >> 8 : b << 8));                  b &= ei.attackedBy[Us][PieceTypeC.PAWN];                  ei.kingAttackersCount[Us] = (b != 0) ? Bitcount.popcount_1s_Max15(b) / 2 : 0;                  ei.kingAdjacentZoneAttacksCount[Us] = ei.kingAttackersWeight[Us] = 0;              }              else              {                  ei.kingRing[Them] = 0; ei.kingAttackersCount[Us] = 0;              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_threats,The following statement contains a magic number: if (undefendedMinors != 0)                  score += ((undefendedMinors & (undefendedMinors - 1)) != 0) ? UndefendedMinorPenalty * 2 : UndefendedMinorPenalty;
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_pieces_of_color,The following statement contains a magic number: for (PieceType Piece = PieceTypeC.KNIGHT; Piece < PieceTypeC.KING; Piece++)              {                  score = ScoreC.SCORE_ZERO;                  ei.attackedBy[Us][Piece] = 0;                  Square[] pl = pos.pieceList[Us][Piece];                  plPos = 0;                  while ((s = pl[plPos++]) != SquareC.SQ_NONE)                  {                      // Find attacked squares' including x-ray attacks for bishops and rooks                      if (Piece == PieceTypeC.KNIGHT)                      {                          b = Utils.StepAttacksBB_KNIGHT[s];                      }                      else if (Piece == PieceTypeC.QUEEN)                      {  #if X64                          b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares);  #endif                      }                      else if (Piece == PieceTypeC.BISHOP)                      {  #if X64                          b = Utils.BAttacks[s][(((                                (pos.occupied_squares ^ (pos.byTypeBB[PieceTypeC.QUEEN] & pos.byColorBB[Us]))                              & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])];  #else                          b = Utils.bishop_attacks_bb(s' pos.occupied_squares ^ pos.pieces_PTC(PieceTypeC.QUEEN' Us));  #endif                      }                      else if (Piece == PieceTypeC.ROOK)                      {  #if X64                          b = Utils.RAttacks[s][(((                                (pos.occupied_squares ^ ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Us]))                              & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])];  #else                          b = Utils.rook_attacks_bb(s' pos.occupied_squares ^ pos.pieces(PieceTypeC.ROOK' PieceTypeC.QUEEN' Us));  #endif                      }                        // Update attack info                      ei.attackedBy[Us][Piece] |= b;                        // King attacks                      if ((b & kingRingThem) != 0)                      {                          ei.kingAttackersCount[Us]++;                          ei.kingAttackersWeight[Us] += KingAttackWeights[Piece];                          Bitboard bb = (b & attackedByThemKing);//ei.attackedBy[Them][PieceTypeC.KING]);                          if (bb != 0)                          {  #if X64                              bb -= (bb >> 1) & 0x5555555555555555UL;                              bb = ((bb >> 2) & 0x3333333333333333UL) + (bb & 0x3333333333333333UL);                              ei.kingAdjacentZoneAttacksCount[Us] += (int)((bb * 0x1111111111111111UL) >> 60);  #else                              ei.kingAdjacentZoneAttacksCount[Us] += Bitcount.popcount_1s_Max15(bb);  #endif                          }                      }                        // Mobility  #if X64                      Bitboard bmob = b & mobilityArea;                      if (Piece != PieceTypeC.QUEEN)                      {                          bmob -= (bmob >> 1) & 0x5555555555555555UL;                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          mob = (int)((bmob * 0x1111111111111111UL) >> 60);                      }                      else                      {                          bmob -= ((bmob >> 1) & 0x5555555555555555UL);                          bmob = ((bmob >> 2) & 0x3333333333333333UL) + (bmob & 0x3333333333333333UL);                          bmob = ((bmob >> 4) + bmob) & 0x0F0F0F0F0F0F0F0FUL;                          mob = (int)((bmob * 0x0101010101010101UL) >> 56);                      }  #else                      mob = (Piece != PieceTypeC.QUEEN ? Bitcount.popcount_1s_Max15(b & mobilityArea) : Bitcount.popcount_1s_Full(b & mobilityArea));  #endif                      mobility += MobilityBonus[Piece][mob];                        // Add a bonus if a slider is pinning an enemy piece                      if (                          (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((Utils.PseudoAttacks[Piece][pos.pieceList[Them][PieceTypeC.KING][0]] & Utils.SquareBB[s]) != 0)                          )                      {                          b = Utils.BetweenBB[s][pos.pieceList[Them][PieceTypeC.KING][0]] & pos.occupied_squares;                            Debug.Assert(b != 0);                            if (((b & (b - 1)) == 0) && ((b & pos.byColorBB[Them]) != 0))                          {  #if X64                              score += ThreatBonus[Piece][pos.board[Utils.BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58]] & 7];  #else                              score += ThreatBonus[Piece][pos.board[Utils.first_1(b)] & 7];  #endif                          }                      }                        // Decrease score if we are attacked by an enemy pawn. Remaining part                      // of threat evaluation must be done later when we have full attack info.                      if ((attackedByThemPawn & Utils.SquareBB[s]) != 0)                      {                          score -= ThreatenedByPawnPenalty[Piece];                      }                        // Bishop and knight outposts squares                      if (                           (Piece == PieceTypeC.BISHOP || Piece == PieceTypeC.KNIGHT)                           &&                           (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Them]) & Utils.AttackSpanMask[Us][s]) == 0)                           )                      {                          #region Evaluate outposts inlined                            // evaluate_outposts() evaluates bishop and knight outposts squares                            // Initial bonus based on square                          Value bonus = OutpostBonus[Piece == PieceTypeC.BISHOP ? 1 : 0][s ^ (Us * 56)];                            // Increase bonus if supported by pawn' especially if the opponent has                          // no minor piece which can exchange the outpost piece.                          if ((bonus != 0) && ((ei.attackedBy[Us][PieceTypeC.PAWN] & Utils.SquareBB[s]) != 0))                          {                              if (                                  ((pos.byTypeBB[PieceTypeC.KNIGHT] & pos.byColorBB[Them]) == 0)                                  &&                                  (((((0xAA55AA55AA55AA55UL & Utils.SquareBB[s]) != 0) ? 0xAA55AA55AA55AA55UL : ~0xAA55AA55AA55AA55UL) & (pos.byTypeBB[PieceTypeC.BISHOP] & pos.byColorBB[Them])) == 0)                                  )                              {                                  bonus += bonus + bonus / 2;                              }                              else                              {                                  bonus += bonus / 2;                              }                          }                          score += ((bonus << 16) + bonus); // Utils.make_score(bonus' bonus);                            #endregion                      }                        // Queen or rook on 7th rank                      if (                          (Piece == PieceTypeC.ROOK || Piece == PieceTypeC.QUEEN)                          &&                          ((s >> 3) ^ (Us * 7)) == RankC.RANK_7                          &&                          (((pos.pieceList[Them][PieceTypeC.KING][0]) >> 3) ^ (Us * 7)) == RankC.RANK_8                      )                      {                          score += (Piece == PieceTypeC.ROOK ? RookOn7thBonus : QueenOn7thBonus);                      }                          // Special extra evaluation for bishops                      if (pos.chess960 && (Piece == PieceTypeC.BISHOP))                      {                          // An important Chess960 pattern: A cornered bishop blocked by                          // a friendly pawn diagonally in front of it is a very serious                          // problem' especially when that pawn is also blocked.                          if (s == Utils.relative_square(Us' SquareC.SQ_A1) || s == Utils.relative_square(Us' SquareC.SQ_H1))                          {                              Square d = Utils.pawn_push(Us) + (Utils.file_of(s) == FileC.FILE_A ? SquareC.DELTA_E : SquareC.DELTA_W);                              if (pos.piece_on(s + d) == Utils.make_piece(Us' PieceTypeC.PAWN))                              {                                  if (!pos.is_empty(s + d + Utils.pawn_push(Us)))                                      score -= 2 * TrappedBishopA1H1Penalty;                                  else if (pos.piece_on(s + 2 * d) == Utils.make_piece(Us' PieceTypeC.PAWN))                                      score -= TrappedBishopA1H1Penalty;                                  else                                      score -= TrappedBishopA1H1Penalty / 2;                              }                          }                      }                        // Special extra evaluation for rooks                      if (Piece == PieceTypeC.ROOK)                      {                          // Open and half-open files                          f = (s & 7);                            bool halfOpenUs = ((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0;                            if (halfOpenUs)                          {                              if (((Them == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & (1 << f)) : (ei.pi.halfOpenFilesBLACK & (1 << f))) != 0)                                  score += RookOpenFileBonus;                              else                                  score += RookHalfOpenFileBonus;                          }                            // Penalize rooks which are trapped inside a king. Penalize more if                          // king has lost right to castle.                          if (mob > 6 || halfOpenUs)                              continue;                            ksq = pos.pieceList[Us][PieceTypeC.KING][0];                            if (((ksq >> 3) ^ (Us * 7)) == RankC.RANK_1 || (ksq >> 3) == (s >> 3))                          {                              if ((ksq & 7) >= FileC.FILE_E)                              {                                  if (f > (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ~((1 << ((ksq & 7) + 1)) - 1)) : (ei.pi.halfOpenFilesBLACK & ~((1 << ((ksq & 7) + 1)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                              else                              {                                  if (f < (ksq & 7))                                  {                                      // Is there a half-open file between the king and the edge of the board?                                      if (((Us == ColorC.WHITE) ? (ei.pi.halfOpenFilesWHITE & ((1 << (ksq & 7)) - 1)) : (ei.pi.halfOpenFilesBLACK & ((1 << (ksq & 7)) - 1))) == 0)                                      {                                          score -= ((((pos.st.castleRights & (CastleRightC.WHITE_ANY << (Us << 1))) != 0) ? (TrappedRookPenalty - mob * 16) / 2 : (TrappedRookPenalty - mob * 16)) << 16);                                      }                                  }                              }                          }                      }                  }                    scores += score;                    if (Trace)                  {                      TracedScores[Us][Piece] = score;                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_king,The following statement contains a magic number: if (ei.kingAttackersCount[Them] >= 2                  && (ei.kingAdjacentZoneAttacksCount[Them] != 0))              {                  // Find the attacked squares around the king which has no defenders                  // apart from the king itself                  undefended = ei.attackedBy[Them][0] & ei.attackedBy[Us][PieceTypeC.KING];                  undefended &= ~(ei.attackedBy[Us][PieceTypeC.PAWN] | ei.attackedBy[Us][PieceTypeC.KNIGHT]                                  | ei.attackedBy[Us][PieceTypeC.BISHOP] | ei.attackedBy[Us][PieceTypeC.ROOK]                                  | ei.attackedBy[Us][PieceTypeC.QUEEN]);    #if X64                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  b = undefended - ((undefended >> 1) & 0x5555555555555555UL);                  b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + ((int)((b * 0x1111111111111111UL) >> 60)))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += QueenContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += RookContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = (Utils.RAttacks[ksq][(((pos.occupied_squares & Utils.RMasks[ksq]) * Utils.RMagics[ksq]) >> Utils.RShifts[ksq])]) & safe;                  b2 = (Utils.BAttacks[ksq][(((pos.occupied_squares & Utils.BMasks[ksq]) * Utils.BMagics[ksq]) >> Utils.BShifts[ksq])]) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += QueenCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += RookCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += BishopCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += KnightCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }  #else                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + Bitcount.popcount_1s_Max15(undefended))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          attackUnits += QueenContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          attackUnits += RookContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = pos.attacks_from_ROOK(ksq) & safe;                  b2 = pos.attacks_from_BISHOP(ksq) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      attackUnits += QueenCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      attackUnits += RookCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      attackUnits += BishopCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      attackUnits += KnightCheckBonus * Bitcount.popcount_1s_Max15(b);                  }  #endif                    // To index KingDangerTable[] attackUnits must be in [0' 99] range                  attackUnits = Math.Min(99' Math.Max(0' attackUnits));                    // Finally' extract the king danger score from the KingDangerTable[]                  // array and subtract the score from evaluation. Set also margins[]                  // value that will be used for pruning because this value can sometimes                  // be very big' and so capturing a single attacking piece can therefore                  // result in a score change far bigger than the value of the captured piece.                  kingScore = KingDangerTable[Us == RootColor ? 1 : 0][attackUnits];                  score -= kingScore;                  if (Us == ColorC.WHITE)                  {                      marginsWHITE += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }                  else                  {                      marginsBLACK += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_king,The following statement contains a magic number: if (ei.kingAttackersCount[Them] >= 2                  && (ei.kingAdjacentZoneAttacksCount[Them] != 0))              {                  // Find the attacked squares around the king which has no defenders                  // apart from the king itself                  undefended = ei.attackedBy[Them][0] & ei.attackedBy[Us][PieceTypeC.KING];                  undefended &= ~(ei.attackedBy[Us][PieceTypeC.PAWN] | ei.attackedBy[Us][PieceTypeC.KNIGHT]                                  | ei.attackedBy[Us][PieceTypeC.BISHOP] | ei.attackedBy[Us][PieceTypeC.ROOK]                                  | ei.attackedBy[Us][PieceTypeC.QUEEN]);    #if X64                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  b = undefended - ((undefended >> 1) & 0x5555555555555555UL);                  b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + ((int)((b * 0x1111111111111111UL) >> 60)))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += QueenContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += RookContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = (Utils.RAttacks[ksq][(((pos.occupied_squares & Utils.RMasks[ksq]) * Utils.RMagics[ksq]) >> Utils.RShifts[ksq])]) & safe;                  b2 = (Utils.BAttacks[ksq][(((pos.occupied_squares & Utils.BMasks[ksq]) * Utils.BMagics[ksq]) >> Utils.BShifts[ksq])]) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += QueenCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += RookCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += BishopCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += KnightCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }  #else                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + Bitcount.popcount_1s_Max15(undefended))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          attackUnits += QueenContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          attackUnits += RookContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = pos.attacks_from_ROOK(ksq) & safe;                  b2 = pos.attacks_from_BISHOP(ksq) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      attackUnits += QueenCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      attackUnits += RookCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      attackUnits += BishopCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      attackUnits += KnightCheckBonus * Bitcount.popcount_1s_Max15(b);                  }  #endif                    // To index KingDangerTable[] attackUnits must be in [0' 99] range                  attackUnits = Math.Min(99' Math.Max(0' attackUnits));                    // Finally' extract the king danger score from the KingDangerTable[]                  // array and subtract the score from evaluation. Set also margins[]                  // value that will be used for pruning because this value can sometimes                  // be very big' and so capturing a single attacking piece can therefore                  // result in a score change far bigger than the value of the captured piece.                  kingScore = KingDangerTable[Us == RootColor ? 1 : 0][attackUnits];                  score -= kingScore;                  if (Us == ColorC.WHITE)                  {                      marginsWHITE += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }                  else                  {                      marginsBLACK += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_king,The following statement contains a magic number: if (ei.kingAttackersCount[Them] >= 2                  && (ei.kingAdjacentZoneAttacksCount[Them] != 0))              {                  // Find the attacked squares around the king which has no defenders                  // apart from the king itself                  undefended = ei.attackedBy[Them][0] & ei.attackedBy[Us][PieceTypeC.KING];                  undefended &= ~(ei.attackedBy[Us][PieceTypeC.PAWN] | ei.attackedBy[Us][PieceTypeC.KNIGHT]                                  | ei.attackedBy[Us][PieceTypeC.BISHOP] | ei.attackedBy[Us][PieceTypeC.ROOK]                                  | ei.attackedBy[Us][PieceTypeC.QUEEN]);    #if X64                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  b = undefended - ((undefended >> 1) & 0x5555555555555555UL);                  b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + ((int)((b * 0x1111111111111111UL) >> 60)))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += QueenContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += RookContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = (Utils.RAttacks[ksq][(((pos.occupied_squares & Utils.RMasks[ksq]) * Utils.RMagics[ksq]) >> Utils.RShifts[ksq])]) & safe;                  b2 = (Utils.BAttacks[ksq][(((pos.occupied_squares & Utils.BMasks[ksq]) * Utils.BMagics[ksq]) >> Utils.BShifts[ksq])]) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += QueenCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += RookCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += BishopCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += KnightCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }  #else                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + Bitcount.popcount_1s_Max15(undefended))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          attackUnits += QueenContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          attackUnits += RookContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = pos.attacks_from_ROOK(ksq) & safe;                  b2 = pos.attacks_from_BISHOP(ksq) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      attackUnits += QueenCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      attackUnits += RookCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      attackUnits += BishopCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      attackUnits += KnightCheckBonus * Bitcount.popcount_1s_Max15(b);                  }  #endif                    // To index KingDangerTable[] attackUnits must be in [0' 99] range                  attackUnits = Math.Min(99' Math.Max(0' attackUnits));                    // Finally' extract the king danger score from the KingDangerTable[]                  // array and subtract the score from evaluation. Set also margins[]                  // value that will be used for pruning because this value can sometimes                  // be very big' and so capturing a single attacking piece can therefore                  // result in a score change far bigger than the value of the captured piece.                  kingScore = KingDangerTable[Us == RootColor ? 1 : 0][attackUnits];                  score -= kingScore;                  if (Us == ColorC.WHITE)                  {                      marginsWHITE += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }                  else                  {                      marginsBLACK += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_king,The following statement contains a magic number: if (ei.kingAttackersCount[Them] >= 2                  && (ei.kingAdjacentZoneAttacksCount[Them] != 0))              {                  // Find the attacked squares around the king which has no defenders                  // apart from the king itself                  undefended = ei.attackedBy[Them][0] & ei.attackedBy[Us][PieceTypeC.KING];                  undefended &= ~(ei.attackedBy[Us][PieceTypeC.PAWN] | ei.attackedBy[Us][PieceTypeC.KNIGHT]                                  | ei.attackedBy[Us][PieceTypeC.BISHOP] | ei.attackedBy[Us][PieceTypeC.ROOK]                                  | ei.attackedBy[Us][PieceTypeC.QUEEN]);    #if X64                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  b = undefended - ((undefended >> 1) & 0x5555555555555555UL);                  b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + ((int)((b * 0x1111111111111111UL) >> 60)))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += QueenContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += RookContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = (Utils.RAttacks[ksq][(((pos.occupied_squares & Utils.RMasks[ksq]) * Utils.RMagics[ksq]) >> Utils.RShifts[ksq])]) & safe;                  b2 = (Utils.BAttacks[ksq][(((pos.occupied_squares & Utils.BMasks[ksq]) * Utils.BMagics[ksq]) >> Utils.BShifts[ksq])]) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += QueenCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += RookCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += BishopCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += KnightCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }  #else                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + Bitcount.popcount_1s_Max15(undefended))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          attackUnits += QueenContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          attackUnits += RookContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = pos.attacks_from_ROOK(ksq) & safe;                  b2 = pos.attacks_from_BISHOP(ksq) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      attackUnits += QueenCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      attackUnits += RookCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      attackUnits += BishopCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      attackUnits += KnightCheckBonus * Bitcount.popcount_1s_Max15(b);                  }  #endif                    // To index KingDangerTable[] attackUnits must be in [0' 99] range                  attackUnits = Math.Min(99' Math.Max(0' attackUnits));                    // Finally' extract the king danger score from the KingDangerTable[]                  // array and subtract the score from evaluation. Set also margins[]                  // value that will be used for pruning because this value can sometimes                  // be very big' and so capturing a single attacking piece can therefore                  // result in a score change far bigger than the value of the captured piece.                  kingScore = KingDangerTable[Us == RootColor ? 1 : 0][attackUnits];                  score -= kingScore;                  if (Us == ColorC.WHITE)                  {                      marginsWHITE += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }                  else                  {                      marginsBLACK += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_king,The following statement contains a magic number: if (ei.kingAttackersCount[Them] >= 2                  && (ei.kingAdjacentZoneAttacksCount[Them] != 0))              {                  // Find the attacked squares around the king which has no defenders                  // apart from the king itself                  undefended = ei.attackedBy[Them][0] & ei.attackedBy[Us][PieceTypeC.KING];                  undefended &= ~(ei.attackedBy[Us][PieceTypeC.PAWN] | ei.attackedBy[Us][PieceTypeC.KNIGHT]                                  | ei.attackedBy[Us][PieceTypeC.BISHOP] | ei.attackedBy[Us][PieceTypeC.ROOK]                                  | ei.attackedBy[Us][PieceTypeC.QUEEN]);    #if X64                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  b = undefended - ((undefended >> 1) & 0x5555555555555555UL);                  b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + ((int)((b * 0x1111111111111111UL) >> 60)))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += QueenContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += RookContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = (Utils.RAttacks[ksq][(((pos.occupied_squares & Utils.RMasks[ksq]) * Utils.RMagics[ksq]) >> Utils.RShifts[ksq])]) & safe;                  b2 = (Utils.BAttacks[ksq][(((pos.occupied_squares & Utils.BMasks[ksq]) * Utils.BMagics[ksq]) >> Utils.BShifts[ksq])]) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += QueenCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += RookCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += BishopCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += KnightCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }  #else                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + Bitcount.popcount_1s_Max15(undefended))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          attackUnits += QueenContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          attackUnits += RookContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = pos.attacks_from_ROOK(ksq) & safe;                  b2 = pos.attacks_from_BISHOP(ksq) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      attackUnits += QueenCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      attackUnits += RookCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      attackUnits += BishopCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      attackUnits += KnightCheckBonus * Bitcount.popcount_1s_Max15(b);                  }  #endif                    // To index KingDangerTable[] attackUnits must be in [0' 99] range                  attackUnits = Math.Min(99' Math.Max(0' attackUnits));                    // Finally' extract the king danger score from the KingDangerTable[]                  // array and subtract the score from evaluation. Set also margins[]                  // value that will be used for pruning because this value can sometimes                  // be very big' and so capturing a single attacking piece can therefore                  // result in a score change far bigger than the value of the captured piece.                  kingScore = KingDangerTable[Us == RootColor ? 1 : 0][attackUnits];                  score -= kingScore;                  if (Us == ColorC.WHITE)                  {                      marginsWHITE += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }                  else                  {                      marginsBLACK += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_king,The following statement contains a magic number: if (ei.kingAttackersCount[Them] >= 2                  && (ei.kingAdjacentZoneAttacksCount[Them] != 0))              {                  // Find the attacked squares around the king which has no defenders                  // apart from the king itself                  undefended = ei.attackedBy[Them][0] & ei.attackedBy[Us][PieceTypeC.KING];                  undefended &= ~(ei.attackedBy[Us][PieceTypeC.PAWN] | ei.attackedBy[Us][PieceTypeC.KNIGHT]                                  | ei.attackedBy[Us][PieceTypeC.BISHOP] | ei.attackedBy[Us][PieceTypeC.ROOK]                                  | ei.attackedBy[Us][PieceTypeC.QUEEN]);    #if X64                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  b = undefended - ((undefended >> 1) & 0x5555555555555555UL);                  b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + ((int)((b * 0x1111111111111111UL) >> 60)))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += QueenContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += RookContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = (Utils.RAttacks[ksq][(((pos.occupied_squares & Utils.RMasks[ksq]) * Utils.RMagics[ksq]) >> Utils.RShifts[ksq])]) & safe;                  b2 = (Utils.BAttacks[ksq][(((pos.occupied_squares & Utils.BMasks[ksq]) * Utils.BMagics[ksq]) >> Utils.BShifts[ksq])]) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += QueenCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += RookCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += BishopCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += KnightCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }  #else                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + Bitcount.popcount_1s_Max15(undefended))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          attackUnits += QueenContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          attackUnits += RookContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = pos.attacks_from_ROOK(ksq) & safe;                  b2 = pos.attacks_from_BISHOP(ksq) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      attackUnits += QueenCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      attackUnits += RookCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      attackUnits += BishopCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      attackUnits += KnightCheckBonus * Bitcount.popcount_1s_Max15(b);                  }  #endif                    // To index KingDangerTable[] attackUnits must be in [0' 99] range                  attackUnits = Math.Min(99' Math.Max(0' attackUnits));                    // Finally' extract the king danger score from the KingDangerTable[]                  // array and subtract the score from evaluation. Set also margins[]                  // value that will be used for pruning because this value can sometimes                  // be very big' and so capturing a single attacking piece can therefore                  // result in a score change far bigger than the value of the captured piece.                  kingScore = KingDangerTable[Us == RootColor ? 1 : 0][attackUnits];                  score -= kingScore;                  if (Us == ColorC.WHITE)                  {                      marginsWHITE += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }                  else                  {                      marginsBLACK += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_king,The following statement contains a magic number: if (ei.kingAttackersCount[Them] >= 2                  && (ei.kingAdjacentZoneAttacksCount[Them] != 0))              {                  // Find the attacked squares around the king which has no defenders                  // apart from the king itself                  undefended = ei.attackedBy[Them][0] & ei.attackedBy[Us][PieceTypeC.KING];                  undefended &= ~(ei.attackedBy[Us][PieceTypeC.PAWN] | ei.attackedBy[Us][PieceTypeC.KNIGHT]                                  | ei.attackedBy[Us][PieceTypeC.BISHOP] | ei.attackedBy[Us][PieceTypeC.ROOK]                                  | ei.attackedBy[Us][PieceTypeC.QUEEN]);    #if X64                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  b = undefended - ((undefended >> 1) & 0x5555555555555555UL);                  b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + ((int)((b * 0x1111111111111111UL) >> 60)))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += QueenContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += RookContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = (Utils.RAttacks[ksq][(((pos.occupied_squares & Utils.RMasks[ksq]) * Utils.RMagics[ksq]) >> Utils.RShifts[ksq])]) & safe;                  b2 = (Utils.BAttacks[ksq][(((pos.occupied_squares & Utils.BMasks[ksq]) * Utils.BMagics[ksq]) >> Utils.BShifts[ksq])]) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += QueenCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += RookCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += BishopCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += KnightCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }  #else                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + Bitcount.popcount_1s_Max15(undefended))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          attackUnits += QueenContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          attackUnits += RookContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = pos.attacks_from_ROOK(ksq) & safe;                  b2 = pos.attacks_from_BISHOP(ksq) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      attackUnits += QueenCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      attackUnits += RookCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      attackUnits += BishopCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      attackUnits += KnightCheckBonus * Bitcount.popcount_1s_Max15(b);                  }  #endif                    // To index KingDangerTable[] attackUnits must be in [0' 99] range                  attackUnits = Math.Min(99' Math.Max(0' attackUnits));                    // Finally' extract the king danger score from the KingDangerTable[]                  // array and subtract the score from evaluation. Set also margins[]                  // value that will be used for pruning because this value can sometimes                  // be very big' and so capturing a single attacking piece can therefore                  // result in a score change far bigger than the value of the captured piece.                  kingScore = KingDangerTable[Us == RootColor ? 1 : 0][attackUnits];                  score -= kingScore;                  if (Us == ColorC.WHITE)                  {                      marginsWHITE += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }                  else                  {                      marginsBLACK += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_king,The following statement contains a magic number: if (ei.kingAttackersCount[Them] >= 2                  && (ei.kingAdjacentZoneAttacksCount[Them] != 0))              {                  // Find the attacked squares around the king which has no defenders                  // apart from the king itself                  undefended = ei.attackedBy[Them][0] & ei.attackedBy[Us][PieceTypeC.KING];                  undefended &= ~(ei.attackedBy[Us][PieceTypeC.PAWN] | ei.attackedBy[Us][PieceTypeC.KNIGHT]                                  | ei.attackedBy[Us][PieceTypeC.BISHOP] | ei.attackedBy[Us][PieceTypeC.ROOK]                                  | ei.attackedBy[Us][PieceTypeC.QUEEN]);    #if X64                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  b = undefended - ((undefended >> 1) & 0x5555555555555555UL);                  b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + ((int)((b * 0x1111111111111111UL) >> 60)))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += QueenContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += RookContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = (Utils.RAttacks[ksq][(((pos.occupied_squares & Utils.RMasks[ksq]) * Utils.RMagics[ksq]) >> Utils.RShifts[ksq])]) & safe;                  b2 = (Utils.BAttacks[ksq][(((pos.occupied_squares & Utils.BMasks[ksq]) * Utils.BMagics[ksq]) >> Utils.BShifts[ksq])]) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += QueenCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += RookCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += BishopCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += KnightCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }  #else                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + Bitcount.popcount_1s_Max15(undefended))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          attackUnits += QueenContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          attackUnits += RookContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = pos.attacks_from_ROOK(ksq) & safe;                  b2 = pos.attacks_from_BISHOP(ksq) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      attackUnits += QueenCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      attackUnits += RookCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      attackUnits += BishopCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      attackUnits += KnightCheckBonus * Bitcount.popcount_1s_Max15(b);                  }  #endif                    // To index KingDangerTable[] attackUnits must be in [0' 99] range                  attackUnits = Math.Min(99' Math.Max(0' attackUnits));                    // Finally' extract the king danger score from the KingDangerTable[]                  // array and subtract the score from evaluation. Set also margins[]                  // value that will be used for pruning because this value can sometimes                  // be very big' and so capturing a single attacking piece can therefore                  // result in a score change far bigger than the value of the captured piece.                  kingScore = KingDangerTable[Us == RootColor ? 1 : 0][attackUnits];                  score -= kingScore;                  if (Us == ColorC.WHITE)                  {                      marginsWHITE += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }                  else                  {                      marginsBLACK += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_king,The following statement contains a magic number: if (ei.kingAttackersCount[Them] >= 2                  && (ei.kingAdjacentZoneAttacksCount[Them] != 0))              {                  // Find the attacked squares around the king which has no defenders                  // apart from the king itself                  undefended = ei.attackedBy[Them][0] & ei.attackedBy[Us][PieceTypeC.KING];                  undefended &= ~(ei.attackedBy[Us][PieceTypeC.PAWN] | ei.attackedBy[Us][PieceTypeC.KNIGHT]                                  | ei.attackedBy[Us][PieceTypeC.BISHOP] | ei.attackedBy[Us][PieceTypeC.ROOK]                                  | ei.attackedBy[Us][PieceTypeC.QUEEN]);    #if X64                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  b = undefended - ((undefended >> 1) & 0x5555555555555555UL);                  b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + ((int)((b * 0x1111111111111111UL) >> 60)))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += QueenContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += RookContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = (Utils.RAttacks[ksq][(((pos.occupied_squares & Utils.RMasks[ksq]) * Utils.RMagics[ksq]) >> Utils.RShifts[ksq])]) & safe;                  b2 = (Utils.BAttacks[ksq][(((pos.occupied_squares & Utils.BMasks[ksq]) * Utils.BMagics[ksq]) >> Utils.BShifts[ksq])]) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += QueenCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += RookCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += BishopCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += KnightCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }  #else                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + Bitcount.popcount_1s_Max15(undefended))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          attackUnits += QueenContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          attackUnits += RookContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = pos.attacks_from_ROOK(ksq) & safe;                  b2 = pos.attacks_from_BISHOP(ksq) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      attackUnits += QueenCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      attackUnits += RookCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      attackUnits += BishopCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      attackUnits += KnightCheckBonus * Bitcount.popcount_1s_Max15(b);                  }  #endif                    // To index KingDangerTable[] attackUnits must be in [0' 99] range                  attackUnits = Math.Min(99' Math.Max(0' attackUnits));                    // Finally' extract the king danger score from the KingDangerTable[]                  // array and subtract the score from evaluation. Set also margins[]                  // value that will be used for pruning because this value can sometimes                  // be very big' and so capturing a single attacking piece can therefore                  // result in a score change far bigger than the value of the captured piece.                  kingScore = KingDangerTable[Us == RootColor ? 1 : 0][attackUnits];                  score -= kingScore;                  if (Us == ColorC.WHITE)                  {                      marginsWHITE += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }                  else                  {                      marginsBLACK += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_king,The following statement contains a magic number: if (ei.kingAttackersCount[Them] >= 2                  && (ei.kingAdjacentZoneAttacksCount[Them] != 0))              {                  // Find the attacked squares around the king which has no defenders                  // apart from the king itself                  undefended = ei.attackedBy[Them][0] & ei.attackedBy[Us][PieceTypeC.KING];                  undefended &= ~(ei.attackedBy[Us][PieceTypeC.PAWN] | ei.attackedBy[Us][PieceTypeC.KNIGHT]                                  | ei.attackedBy[Us][PieceTypeC.BISHOP] | ei.attackedBy[Us][PieceTypeC.ROOK]                                  | ei.attackedBy[Us][PieceTypeC.QUEEN]);    #if X64                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  b = undefended - ((undefended >> 1) & 0x5555555555555555UL);                  b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + ((int)((b * 0x1111111111111111UL) >> 60)))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += QueenContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += RookContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = (Utils.RAttacks[ksq][(((pos.occupied_squares & Utils.RMasks[ksq]) * Utils.RMagics[ksq]) >> Utils.RShifts[ksq])]) & safe;                  b2 = (Utils.BAttacks[ksq][(((pos.occupied_squares & Utils.BMasks[ksq]) * Utils.BMagics[ksq]) >> Utils.BShifts[ksq])]) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += QueenCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += RookCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += BishopCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += KnightCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }  #else                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + Bitcount.popcount_1s_Max15(undefended))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          attackUnits += QueenContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          attackUnits += RookContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = pos.attacks_from_ROOK(ksq) & safe;                  b2 = pos.attacks_from_BISHOP(ksq) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      attackUnits += QueenCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      attackUnits += RookCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      attackUnits += BishopCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      attackUnits += KnightCheckBonus * Bitcount.popcount_1s_Max15(b);                  }  #endif                    // To index KingDangerTable[] attackUnits must be in [0' 99] range                  attackUnits = Math.Min(99' Math.Max(0' attackUnits));                    // Finally' extract the king danger score from the KingDangerTable[]                  // array and subtract the score from evaluation. Set also margins[]                  // value that will be used for pruning because this value can sometimes                  // be very big' and so capturing a single attacking piece can therefore                  // result in a score change far bigger than the value of the captured piece.                  kingScore = KingDangerTable[Us == RootColor ? 1 : 0][attackUnits];                  score -= kingScore;                  if (Us == ColorC.WHITE)                  {                      marginsWHITE += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }                  else                  {                      marginsBLACK += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_king,The following statement contains a magic number: if (ei.kingAttackersCount[Them] >= 2                  && (ei.kingAdjacentZoneAttacksCount[Them] != 0))              {                  // Find the attacked squares around the king which has no defenders                  // apart from the king itself                  undefended = ei.attackedBy[Them][0] & ei.attackedBy[Us][PieceTypeC.KING];                  undefended &= ~(ei.attackedBy[Us][PieceTypeC.PAWN] | ei.attackedBy[Us][PieceTypeC.KNIGHT]                                  | ei.attackedBy[Us][PieceTypeC.BISHOP] | ei.attackedBy[Us][PieceTypeC.ROOK]                                  | ei.attackedBy[Us][PieceTypeC.QUEEN]);    #if X64                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  b = undefended - ((undefended >> 1) & 0x5555555555555555UL);                  b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + ((int)((b * 0x1111111111111111UL) >> 60)))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += QueenContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += RookContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = (Utils.RAttacks[ksq][(((pos.occupied_squares & Utils.RMasks[ksq]) * Utils.RMagics[ksq]) >> Utils.RShifts[ksq])]) & safe;                  b2 = (Utils.BAttacks[ksq][(((pos.occupied_squares & Utils.BMasks[ksq]) * Utils.BMagics[ksq]) >> Utils.BShifts[ksq])]) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += QueenCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += RookCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += BishopCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += KnightCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }  #else                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + Bitcount.popcount_1s_Max15(undefended))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          attackUnits += QueenContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          attackUnits += RookContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = pos.attacks_from_ROOK(ksq) & safe;                  b2 = pos.attacks_from_BISHOP(ksq) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      attackUnits += QueenCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      attackUnits += RookCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      attackUnits += BishopCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      attackUnits += KnightCheckBonus * Bitcount.popcount_1s_Max15(b);                  }  #endif                    // To index KingDangerTable[] attackUnits must be in [0' 99] range                  attackUnits = Math.Min(99' Math.Max(0' attackUnits));                    // Finally' extract the king danger score from the KingDangerTable[]                  // array and subtract the score from evaluation. Set also margins[]                  // value that will be used for pruning because this value can sometimes                  // be very big' and so capturing a single attacking piece can therefore                  // result in a score change far bigger than the value of the captured piece.                  kingScore = KingDangerTable[Us == RootColor ? 1 : 0][attackUnits];                  score -= kingScore;                  if (Us == ColorC.WHITE)                  {                      marginsWHITE += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }                  else                  {                      marginsBLACK += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_king,The following statement contains a magic number: if (ei.kingAttackersCount[Them] >= 2                  && (ei.kingAdjacentZoneAttacksCount[Them] != 0))              {                  // Find the attacked squares around the king which has no defenders                  // apart from the king itself                  undefended = ei.attackedBy[Them][0] & ei.attackedBy[Us][PieceTypeC.KING];                  undefended &= ~(ei.attackedBy[Us][PieceTypeC.PAWN] | ei.attackedBy[Us][PieceTypeC.KNIGHT]                                  | ei.attackedBy[Us][PieceTypeC.BISHOP] | ei.attackedBy[Us][PieceTypeC.ROOK]                                  | ei.attackedBy[Us][PieceTypeC.QUEEN]);    #if X64                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  b = undefended - ((undefended >> 1) & 0x5555555555555555UL);                  b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + ((int)((b * 0x1111111111111111UL) >> 60)))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += QueenContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += RookContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = (Utils.RAttacks[ksq][(((pos.occupied_squares & Utils.RMasks[ksq]) * Utils.RMagics[ksq]) >> Utils.RShifts[ksq])]) & safe;                  b2 = (Utils.BAttacks[ksq][(((pos.occupied_squares & Utils.BMasks[ksq]) * Utils.BMagics[ksq]) >> Utils.BShifts[ksq])]) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += QueenCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += RookCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += BishopCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += KnightCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }  #else                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + Bitcount.popcount_1s_Max15(undefended))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          attackUnits += QueenContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          attackUnits += RookContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = pos.attacks_from_ROOK(ksq) & safe;                  b2 = pos.attacks_from_BISHOP(ksq) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      attackUnits += QueenCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      attackUnits += RookCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      attackUnits += BishopCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      attackUnits += KnightCheckBonus * Bitcount.popcount_1s_Max15(b);                  }  #endif                    // To index KingDangerTable[] attackUnits must be in [0' 99] range                  attackUnits = Math.Min(99' Math.Max(0' attackUnits));                    // Finally' extract the king danger score from the KingDangerTable[]                  // array and subtract the score from evaluation. Set also margins[]                  // value that will be used for pruning because this value can sometimes                  // be very big' and so capturing a single attacking piece can therefore                  // result in a score change far bigger than the value of the captured piece.                  kingScore = KingDangerTable[Us == RootColor ? 1 : 0][attackUnits];                  score -= kingScore;                  if (Us == ColorC.WHITE)                  {                      marginsWHITE += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }                  else                  {                      marginsBLACK += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_king,The following statement contains a magic number: if (ei.kingAttackersCount[Them] >= 2                  && (ei.kingAdjacentZoneAttacksCount[Them] != 0))              {                  // Find the attacked squares around the king which has no defenders                  // apart from the king itself                  undefended = ei.attackedBy[Them][0] & ei.attackedBy[Us][PieceTypeC.KING];                  undefended &= ~(ei.attackedBy[Us][PieceTypeC.PAWN] | ei.attackedBy[Us][PieceTypeC.KNIGHT]                                  | ei.attackedBy[Us][PieceTypeC.BISHOP] | ei.attackedBy[Us][PieceTypeC.ROOK]                                  | ei.attackedBy[Us][PieceTypeC.QUEEN]);    #if X64                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  b = undefended - ((undefended >> 1) & 0x5555555555555555UL);                  b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + ((int)((b * 0x1111111111111111UL) >> 60)))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += QueenContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += RookContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = (Utils.RAttacks[ksq][(((pos.occupied_squares & Utils.RMasks[ksq]) * Utils.RMagics[ksq]) >> Utils.RShifts[ksq])]) & safe;                  b2 = (Utils.BAttacks[ksq][(((pos.occupied_squares & Utils.BMasks[ksq]) * Utils.BMagics[ksq]) >> Utils.BShifts[ksq])]) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += QueenCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += RookCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += BishopCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += KnightCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }  #else                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + Bitcount.popcount_1s_Max15(undefended))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          attackUnits += QueenContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          attackUnits += RookContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = pos.attacks_from_ROOK(ksq) & safe;                  b2 = pos.attacks_from_BISHOP(ksq) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      attackUnits += QueenCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      attackUnits += RookCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      attackUnits += BishopCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      attackUnits += KnightCheckBonus * Bitcount.popcount_1s_Max15(b);                  }  #endif                    // To index KingDangerTable[] attackUnits must be in [0' 99] range                  attackUnits = Math.Min(99' Math.Max(0' attackUnits));                    // Finally' extract the king danger score from the KingDangerTable[]                  // array and subtract the score from evaluation. Set also margins[]                  // value that will be used for pruning because this value can sometimes                  // be very big' and so capturing a single attacking piece can therefore                  // result in a score change far bigger than the value of the captured piece.                  kingScore = KingDangerTable[Us == RootColor ? 1 : 0][attackUnits];                  score -= kingScore;                  if (Us == ColorC.WHITE)                  {                      marginsWHITE += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }                  else                  {                      marginsBLACK += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_king,The following statement contains a magic number: if (ei.kingAttackersCount[Them] >= 2                  && (ei.kingAdjacentZoneAttacksCount[Them] != 0))              {                  // Find the attacked squares around the king which has no defenders                  // apart from the king itself                  undefended = ei.attackedBy[Them][0] & ei.attackedBy[Us][PieceTypeC.KING];                  undefended &= ~(ei.attackedBy[Us][PieceTypeC.PAWN] | ei.attackedBy[Us][PieceTypeC.KNIGHT]                                  | ei.attackedBy[Us][PieceTypeC.BISHOP] | ei.attackedBy[Us][PieceTypeC.ROOK]                                  | ei.attackedBy[Us][PieceTypeC.QUEEN]);    #if X64                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  b = undefended - ((undefended >> 1) & 0x5555555555555555UL);                  b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + ((int)((b * 0x1111111111111111UL) >> 60)))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += QueenContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += RookContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = (Utils.RAttacks[ksq][(((pos.occupied_squares & Utils.RMasks[ksq]) * Utils.RMagics[ksq]) >> Utils.RShifts[ksq])]) & safe;                  b2 = (Utils.BAttacks[ksq][(((pos.occupied_squares & Utils.BMasks[ksq]) * Utils.BMagics[ksq]) >> Utils.BShifts[ksq])]) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += QueenCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += RookCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += BishopCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += KnightCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }  #else                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + Bitcount.popcount_1s_Max15(undefended))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          attackUnits += QueenContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          attackUnits += RookContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = pos.attacks_from_ROOK(ksq) & safe;                  b2 = pos.attacks_from_BISHOP(ksq) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      attackUnits += QueenCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      attackUnits += RookCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      attackUnits += BishopCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      attackUnits += KnightCheckBonus * Bitcount.popcount_1s_Max15(b);                  }  #endif                    // To index KingDangerTable[] attackUnits must be in [0' 99] range                  attackUnits = Math.Min(99' Math.Max(0' attackUnits));                    // Finally' extract the king danger score from the KingDangerTable[]                  // array and subtract the score from evaluation. Set also margins[]                  // value that will be used for pruning because this value can sometimes                  // be very big' and so capturing a single attacking piece can therefore                  // result in a score change far bigger than the value of the captured piece.                  kingScore = KingDangerTable[Us == RootColor ? 1 : 0][attackUnits];                  score -= kingScore;                  if (Us == ColorC.WHITE)                  {                      marginsWHITE += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }                  else                  {                      marginsBLACK += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_king,The following statement contains a magic number: if (ei.kingAttackersCount[Them] >= 2                  && (ei.kingAdjacentZoneAttacksCount[Them] != 0))              {                  // Find the attacked squares around the king which has no defenders                  // apart from the king itself                  undefended = ei.attackedBy[Them][0] & ei.attackedBy[Us][PieceTypeC.KING];                  undefended &= ~(ei.attackedBy[Us][PieceTypeC.PAWN] | ei.attackedBy[Us][PieceTypeC.KNIGHT]                                  | ei.attackedBy[Us][PieceTypeC.BISHOP] | ei.attackedBy[Us][PieceTypeC.ROOK]                                  | ei.attackedBy[Us][PieceTypeC.QUEEN]);    #if X64                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  b = undefended - ((undefended >> 1) & 0x5555555555555555UL);                  b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + ((int)((b * 0x1111111111111111UL) >> 60)))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += QueenContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += RookContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = (Utils.RAttacks[ksq][(((pos.occupied_squares & Utils.RMasks[ksq]) * Utils.RMagics[ksq]) >> Utils.RShifts[ksq])]) & safe;                  b2 = (Utils.BAttacks[ksq][(((pos.occupied_squares & Utils.BMasks[ksq]) * Utils.BMagics[ksq]) >> Utils.BShifts[ksq])]) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += QueenCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += RookCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += BishopCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += KnightCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }  #else                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + Bitcount.popcount_1s_Max15(undefended))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          attackUnits += QueenContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          attackUnits += RookContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = pos.attacks_from_ROOK(ksq) & safe;                  b2 = pos.attacks_from_BISHOP(ksq) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      attackUnits += QueenCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      attackUnits += RookCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      attackUnits += BishopCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      attackUnits += KnightCheckBonus * Bitcount.popcount_1s_Max15(b);                  }  #endif                    // To index KingDangerTable[] attackUnits must be in [0' 99] range                  attackUnits = Math.Min(99' Math.Max(0' attackUnits));                    // Finally' extract the king danger score from the KingDangerTable[]                  // array and subtract the score from evaluation. Set also margins[]                  // value that will be used for pruning because this value can sometimes                  // be very big' and so capturing a single attacking piece can therefore                  // result in a score change far bigger than the value of the captured piece.                  kingScore = KingDangerTable[Us == RootColor ? 1 : 0][attackUnits];                  score -= kingScore;                  if (Us == ColorC.WHITE)                  {                      marginsWHITE += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }                  else                  {                      marginsBLACK += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_king,The following statement contains a magic number: if (ei.kingAttackersCount[Them] >= 2                  && (ei.kingAdjacentZoneAttacksCount[Them] != 0))              {                  // Find the attacked squares around the king which has no defenders                  // apart from the king itself                  undefended = ei.attackedBy[Them][0] & ei.attackedBy[Us][PieceTypeC.KING];                  undefended &= ~(ei.attackedBy[Us][PieceTypeC.PAWN] | ei.attackedBy[Us][PieceTypeC.KNIGHT]                                  | ei.attackedBy[Us][PieceTypeC.BISHOP] | ei.attackedBy[Us][PieceTypeC.ROOK]                                  | ei.attackedBy[Us][PieceTypeC.QUEEN]);    #if X64                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  b = undefended - ((undefended >> 1) & 0x5555555555555555UL);                  b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + ((int)((b * 0x1111111111111111UL) >> 60)))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += QueenContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += RookContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = (Utils.RAttacks[ksq][(((pos.occupied_squares & Utils.RMasks[ksq]) * Utils.RMagics[ksq]) >> Utils.RShifts[ksq])]) & safe;                  b2 = (Utils.BAttacks[ksq][(((pos.occupied_squares & Utils.BMasks[ksq]) * Utils.BMagics[ksq]) >> Utils.BShifts[ksq])]) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += QueenCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += RookCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += BishopCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += KnightCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }  #else                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + Bitcount.popcount_1s_Max15(undefended))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          attackUnits += QueenContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          attackUnits += RookContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = pos.attacks_from_ROOK(ksq) & safe;                  b2 = pos.attacks_from_BISHOP(ksq) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      attackUnits += QueenCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      attackUnits += RookCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      attackUnits += BishopCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      attackUnits += KnightCheckBonus * Bitcount.popcount_1s_Max15(b);                  }  #endif                    // To index KingDangerTable[] attackUnits must be in [0' 99] range                  attackUnits = Math.Min(99' Math.Max(0' attackUnits));                    // Finally' extract the king danger score from the KingDangerTable[]                  // array and subtract the score from evaluation. Set also margins[]                  // value that will be used for pruning because this value can sometimes                  // be very big' and so capturing a single attacking piece can therefore                  // result in a score change far bigger than the value of the captured piece.                  kingScore = KingDangerTable[Us == RootColor ? 1 : 0][attackUnits];                  score -= kingScore;                  if (Us == ColorC.WHITE)                  {                      marginsWHITE += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }                  else                  {                      marginsBLACK += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_king,The following statement contains a magic number: if (ei.kingAttackersCount[Them] >= 2                  && (ei.kingAdjacentZoneAttacksCount[Them] != 0))              {                  // Find the attacked squares around the king which has no defenders                  // apart from the king itself                  undefended = ei.attackedBy[Them][0] & ei.attackedBy[Us][PieceTypeC.KING];                  undefended &= ~(ei.attackedBy[Us][PieceTypeC.PAWN] | ei.attackedBy[Us][PieceTypeC.KNIGHT]                                  | ei.attackedBy[Us][PieceTypeC.BISHOP] | ei.attackedBy[Us][PieceTypeC.ROOK]                                  | ei.attackedBy[Us][PieceTypeC.QUEEN]);    #if X64                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  b = undefended - ((undefended >> 1) & 0x5555555555555555UL);                  b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + ((int)((b * 0x1111111111111111UL) >> 60)))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += QueenContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += RookContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = (Utils.RAttacks[ksq][(((pos.occupied_squares & Utils.RMasks[ksq]) * Utils.RMagics[ksq]) >> Utils.RShifts[ksq])]) & safe;                  b2 = (Utils.BAttacks[ksq][(((pos.occupied_squares & Utils.BMasks[ksq]) * Utils.BMagics[ksq]) >> Utils.BShifts[ksq])]) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += QueenCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += RookCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += BishopCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += KnightCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }  #else                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + Bitcount.popcount_1s_Max15(undefended))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          attackUnits += QueenContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          attackUnits += RookContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = pos.attacks_from_ROOK(ksq) & safe;                  b2 = pos.attacks_from_BISHOP(ksq) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      attackUnits += QueenCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      attackUnits += RookCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      attackUnits += BishopCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      attackUnits += KnightCheckBonus * Bitcount.popcount_1s_Max15(b);                  }  #endif                    // To index KingDangerTable[] attackUnits must be in [0' 99] range                  attackUnits = Math.Min(99' Math.Max(0' attackUnits));                    // Finally' extract the king danger score from the KingDangerTable[]                  // array and subtract the score from evaluation. Set also margins[]                  // value that will be used for pruning because this value can sometimes                  // be very big' and so capturing a single attacking piece can therefore                  // result in a score change far bigger than the value of the captured piece.                  kingScore = KingDangerTable[Us == RootColor ? 1 : 0][attackUnits];                  score -= kingScore;                  if (Us == ColorC.WHITE)                  {                      marginsWHITE += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }                  else                  {                      marginsBLACK += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_king,The following statement contains a magic number: if (ei.kingAttackersCount[Them] >= 2                  && (ei.kingAdjacentZoneAttacksCount[Them] != 0))              {                  // Find the attacked squares around the king which has no defenders                  // apart from the king itself                  undefended = ei.attackedBy[Them][0] & ei.attackedBy[Us][PieceTypeC.KING];                  undefended &= ~(ei.attackedBy[Us][PieceTypeC.PAWN] | ei.attackedBy[Us][PieceTypeC.KNIGHT]                                  | ei.attackedBy[Us][PieceTypeC.BISHOP] | ei.attackedBy[Us][PieceTypeC.ROOK]                                  | ei.attackedBy[Us][PieceTypeC.QUEEN]);    #if X64                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  b = undefended - ((undefended >> 1) & 0x5555555555555555UL);                  b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + ((int)((b * 0x1111111111111111UL) >> 60)))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += QueenContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += RookContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = (Utils.RAttacks[ksq][(((pos.occupied_squares & Utils.RMasks[ksq]) * Utils.RMagics[ksq]) >> Utils.RShifts[ksq])]) & safe;                  b2 = (Utils.BAttacks[ksq][(((pos.occupied_squares & Utils.BMasks[ksq]) * Utils.BMagics[ksq]) >> Utils.BShifts[ksq])]) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += QueenCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += RookCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += BishopCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += KnightCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }  #else                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + Bitcount.popcount_1s_Max15(undefended))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          attackUnits += QueenContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          attackUnits += RookContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = pos.attacks_from_ROOK(ksq) & safe;                  b2 = pos.attacks_from_BISHOP(ksq) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      attackUnits += QueenCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      attackUnits += RookCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      attackUnits += BishopCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      attackUnits += KnightCheckBonus * Bitcount.popcount_1s_Max15(b);                  }  #endif                    // To index KingDangerTable[] attackUnits must be in [0' 99] range                  attackUnits = Math.Min(99' Math.Max(0' attackUnits));                    // Finally' extract the king danger score from the KingDangerTable[]                  // array and subtract the score from evaluation. Set also margins[]                  // value that will be used for pruning because this value can sometimes                  // be very big' and so capturing a single attacking piece can therefore                  // result in a score change far bigger than the value of the captured piece.                  kingScore = KingDangerTable[Us == RootColor ? 1 : 0][attackUnits];                  score -= kingScore;                  if (Us == ColorC.WHITE)                  {                      marginsWHITE += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }                  else                  {                      marginsBLACK += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_king,The following statement contains a magic number: if (ei.kingAttackersCount[Them] >= 2                  && (ei.kingAdjacentZoneAttacksCount[Them] != 0))              {                  // Find the attacked squares around the king which has no defenders                  // apart from the king itself                  undefended = ei.attackedBy[Them][0] & ei.attackedBy[Us][PieceTypeC.KING];                  undefended &= ~(ei.attackedBy[Us][PieceTypeC.PAWN] | ei.attackedBy[Us][PieceTypeC.KNIGHT]                                  | ei.attackedBy[Us][PieceTypeC.BISHOP] | ei.attackedBy[Us][PieceTypeC.ROOK]                                  | ei.attackedBy[Us][PieceTypeC.QUEEN]);    #if X64                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  b = undefended - ((undefended >> 1) & 0x5555555555555555UL);                  b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + ((int)((b * 0x1111111111111111UL) >> 60)))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += QueenContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += RookContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = (Utils.RAttacks[ksq][(((pos.occupied_squares & Utils.RMasks[ksq]) * Utils.RMagics[ksq]) >> Utils.RShifts[ksq])]) & safe;                  b2 = (Utils.BAttacks[ksq][(((pos.occupied_squares & Utils.BMasks[ksq]) * Utils.BMagics[ksq]) >> Utils.BShifts[ksq])]) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += QueenCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += RookCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += BishopCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += KnightCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }  #else                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + Bitcount.popcount_1s_Max15(undefended))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          attackUnits += QueenContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          attackUnits += RookContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = pos.attacks_from_ROOK(ksq) & safe;                  b2 = pos.attacks_from_BISHOP(ksq) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      attackUnits += QueenCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      attackUnits += RookCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      attackUnits += BishopCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      attackUnits += KnightCheckBonus * Bitcount.popcount_1s_Max15(b);                  }  #endif                    // To index KingDangerTable[] attackUnits must be in [0' 99] range                  attackUnits = Math.Min(99' Math.Max(0' attackUnits));                    // Finally' extract the king danger score from the KingDangerTable[]                  // array and subtract the score from evaluation. Set also margins[]                  // value that will be used for pruning because this value can sometimes                  // be very big' and so capturing a single attacking piece can therefore                  // result in a score change far bigger than the value of the captured piece.                  kingScore = KingDangerTable[Us == RootColor ? 1 : 0][attackUnits];                  score -= kingScore;                  if (Us == ColorC.WHITE)                  {                      marginsWHITE += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }                  else                  {                      marginsBLACK += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_king,The following statement contains a magic number: if (ei.kingAttackersCount[Them] >= 2                  && (ei.kingAdjacentZoneAttacksCount[Them] != 0))              {                  // Find the attacked squares around the king which has no defenders                  // apart from the king itself                  undefended = ei.attackedBy[Them][0] & ei.attackedBy[Us][PieceTypeC.KING];                  undefended &= ~(ei.attackedBy[Us][PieceTypeC.PAWN] | ei.attackedBy[Us][PieceTypeC.KNIGHT]                                  | ei.attackedBy[Us][PieceTypeC.BISHOP] | ei.attackedBy[Us][PieceTypeC.ROOK]                                  | ei.attackedBy[Us][PieceTypeC.QUEEN]);    #if X64                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  b = undefended - ((undefended >> 1) & 0x5555555555555555UL);                  b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + ((int)((b * 0x1111111111111111UL) >> 60)))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += QueenContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += RookContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = (Utils.RAttacks[ksq][(((pos.occupied_squares & Utils.RMasks[ksq]) * Utils.RMagics[ksq]) >> Utils.RShifts[ksq])]) & safe;                  b2 = (Utils.BAttacks[ksq][(((pos.occupied_squares & Utils.BMasks[ksq]) * Utils.BMagics[ksq]) >> Utils.BShifts[ksq])]) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += QueenCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += RookCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += BishopCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += KnightCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }  #else                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + Bitcount.popcount_1s_Max15(undefended))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          attackUnits += QueenContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          attackUnits += RookContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = pos.attacks_from_ROOK(ksq) & safe;                  b2 = pos.attacks_from_BISHOP(ksq) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      attackUnits += QueenCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      attackUnits += RookCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      attackUnits += BishopCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      attackUnits += KnightCheckBonus * Bitcount.popcount_1s_Max15(b);                  }  #endif                    // To index KingDangerTable[] attackUnits must be in [0' 99] range                  attackUnits = Math.Min(99' Math.Max(0' attackUnits));                    // Finally' extract the king danger score from the KingDangerTable[]                  // array and subtract the score from evaluation. Set also margins[]                  // value that will be used for pruning because this value can sometimes                  // be very big' and so capturing a single attacking piece can therefore                  // result in a score change far bigger than the value of the captured piece.                  kingScore = KingDangerTable[Us == RootColor ? 1 : 0][attackUnits];                  score -= kingScore;                  if (Us == ColorC.WHITE)                  {                      marginsWHITE += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }                  else                  {                      marginsBLACK += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_king,The following statement contains a magic number: if (ei.kingAttackersCount[Them] >= 2                  && (ei.kingAdjacentZoneAttacksCount[Them] != 0))              {                  // Find the attacked squares around the king which has no defenders                  // apart from the king itself                  undefended = ei.attackedBy[Them][0] & ei.attackedBy[Us][PieceTypeC.KING];                  undefended &= ~(ei.attackedBy[Us][PieceTypeC.PAWN] | ei.attackedBy[Us][PieceTypeC.KNIGHT]                                  | ei.attackedBy[Us][PieceTypeC.BISHOP] | ei.attackedBy[Us][PieceTypeC.ROOK]                                  | ei.attackedBy[Us][PieceTypeC.QUEEN]);    #if X64                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  b = undefended - ((undefended >> 1) & 0x5555555555555555UL);                  b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + ((int)((b * 0x1111111111111111UL) >> 60)))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += QueenContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += RookContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = (Utils.RAttacks[ksq][(((pos.occupied_squares & Utils.RMasks[ksq]) * Utils.RMagics[ksq]) >> Utils.RShifts[ksq])]) & safe;                  b2 = (Utils.BAttacks[ksq][(((pos.occupied_squares & Utils.BMasks[ksq]) * Utils.BMagics[ksq]) >> Utils.BShifts[ksq])]) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += QueenCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += RookCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += BishopCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += KnightCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }  #else                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + Bitcount.popcount_1s_Max15(undefended))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          attackUnits += QueenContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          attackUnits += RookContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = pos.attacks_from_ROOK(ksq) & safe;                  b2 = pos.attacks_from_BISHOP(ksq) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      attackUnits += QueenCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      attackUnits += RookCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      attackUnits += BishopCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      attackUnits += KnightCheckBonus * Bitcount.popcount_1s_Max15(b);                  }  #endif                    // To index KingDangerTable[] attackUnits must be in [0' 99] range                  attackUnits = Math.Min(99' Math.Max(0' attackUnits));                    // Finally' extract the king danger score from the KingDangerTable[]                  // array and subtract the score from evaluation. Set also margins[]                  // value that will be used for pruning because this value can sometimes                  // be very big' and so capturing a single attacking piece can therefore                  // result in a score change far bigger than the value of the captured piece.                  kingScore = KingDangerTable[Us == RootColor ? 1 : 0][attackUnits];                  score -= kingScore;                  if (Us == ColorC.WHITE)                  {                      marginsWHITE += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }                  else                  {                      marginsBLACK += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_king,The following statement contains a magic number: if (ei.kingAttackersCount[Them] >= 2                  && (ei.kingAdjacentZoneAttacksCount[Them] != 0))              {                  // Find the attacked squares around the king which has no defenders                  // apart from the king itself                  undefended = ei.attackedBy[Them][0] & ei.attackedBy[Us][PieceTypeC.KING];                  undefended &= ~(ei.attackedBy[Us][PieceTypeC.PAWN] | ei.attackedBy[Us][PieceTypeC.KNIGHT]                                  | ei.attackedBy[Us][PieceTypeC.BISHOP] | ei.attackedBy[Us][PieceTypeC.ROOK]                                  | ei.attackedBy[Us][PieceTypeC.QUEEN]);    #if X64                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  b = undefended - ((undefended >> 1) & 0x5555555555555555UL);                  b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + ((int)((b * 0x1111111111111111UL) >> 60)))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += QueenContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += RookContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = (Utils.RAttacks[ksq][(((pos.occupied_squares & Utils.RMasks[ksq]) * Utils.RMagics[ksq]) >> Utils.RShifts[ksq])]) & safe;                  b2 = (Utils.BAttacks[ksq][(((pos.occupied_squares & Utils.BMasks[ksq]) * Utils.BMagics[ksq]) >> Utils.BShifts[ksq])]) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += QueenCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += RookCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += BishopCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += KnightCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }  #else                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + Bitcount.popcount_1s_Max15(undefended))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          attackUnits += QueenContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          attackUnits += RookContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = pos.attacks_from_ROOK(ksq) & safe;                  b2 = pos.attacks_from_BISHOP(ksq) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      attackUnits += QueenCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      attackUnits += RookCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      attackUnits += BishopCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      attackUnits += KnightCheckBonus * Bitcount.popcount_1s_Max15(b);                  }  #endif                    // To index KingDangerTable[] attackUnits must be in [0' 99] range                  attackUnits = Math.Min(99' Math.Max(0' attackUnits));                    // Finally' extract the king danger score from the KingDangerTable[]                  // array and subtract the score from evaluation. Set also margins[]                  // value that will be used for pruning because this value can sometimes                  // be very big' and so capturing a single attacking piece can therefore                  // result in a score change far bigger than the value of the captured piece.                  kingScore = KingDangerTable[Us == RootColor ? 1 : 0][attackUnits];                  score -= kingScore;                  if (Us == ColorC.WHITE)                  {                      marginsWHITE += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }                  else                  {                      marginsBLACK += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_king,The following statement contains a magic number: if (ei.kingAttackersCount[Them] >= 2                  && (ei.kingAdjacentZoneAttacksCount[Them] != 0))              {                  // Find the attacked squares around the king which has no defenders                  // apart from the king itself                  undefended = ei.attackedBy[Them][0] & ei.attackedBy[Us][PieceTypeC.KING];                  undefended &= ~(ei.attackedBy[Us][PieceTypeC.PAWN] | ei.attackedBy[Us][PieceTypeC.KNIGHT]                                  | ei.attackedBy[Us][PieceTypeC.BISHOP] | ei.attackedBy[Us][PieceTypeC.ROOK]                                  | ei.attackedBy[Us][PieceTypeC.QUEEN]);    #if X64                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  b = undefended - ((undefended >> 1) & 0x5555555555555555UL);                  b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + ((int)((b * 0x1111111111111111UL) >> 60)))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += QueenContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += RookContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = (Utils.RAttacks[ksq][(((pos.occupied_squares & Utils.RMasks[ksq]) * Utils.RMagics[ksq]) >> Utils.RShifts[ksq])]) & safe;                  b2 = (Utils.BAttacks[ksq][(((pos.occupied_squares & Utils.BMasks[ksq]) * Utils.BMagics[ksq]) >> Utils.BShifts[ksq])]) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += QueenCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += RookCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += BishopCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += KnightCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }  #else                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + Bitcount.popcount_1s_Max15(undefended))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          attackUnits += QueenContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          attackUnits += RookContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = pos.attacks_from_ROOK(ksq) & safe;                  b2 = pos.attacks_from_BISHOP(ksq) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      attackUnits += QueenCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      attackUnits += RookCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      attackUnits += BishopCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      attackUnits += KnightCheckBonus * Bitcount.popcount_1s_Max15(b);                  }  #endif                    // To index KingDangerTable[] attackUnits must be in [0' 99] range                  attackUnits = Math.Min(99' Math.Max(0' attackUnits));                    // Finally' extract the king danger score from the KingDangerTable[]                  // array and subtract the score from evaluation. Set also margins[]                  // value that will be used for pruning because this value can sometimes                  // be very big' and so capturing a single attacking piece can therefore                  // result in a score change far bigger than the value of the captured piece.                  kingScore = KingDangerTable[Us == RootColor ? 1 : 0][attackUnits];                  score -= kingScore;                  if (Us == ColorC.WHITE)                  {                      marginsWHITE += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }                  else                  {                      marginsBLACK += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_king,The following statement contains a magic number: if (ei.kingAttackersCount[Them] >= 2                  && (ei.kingAdjacentZoneAttacksCount[Them] != 0))              {                  // Find the attacked squares around the king which has no defenders                  // apart from the king itself                  undefended = ei.attackedBy[Them][0] & ei.attackedBy[Us][PieceTypeC.KING];                  undefended &= ~(ei.attackedBy[Us][PieceTypeC.PAWN] | ei.attackedBy[Us][PieceTypeC.KNIGHT]                                  | ei.attackedBy[Us][PieceTypeC.BISHOP] | ei.attackedBy[Us][PieceTypeC.ROOK]                                  | ei.attackedBy[Us][PieceTypeC.QUEEN]);    #if X64                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  b = undefended - ((undefended >> 1) & 0x5555555555555555UL);                  b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + ((int)((b * 0x1111111111111111UL) >> 60)))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += QueenContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += RookContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = (Utils.RAttacks[ksq][(((pos.occupied_squares & Utils.RMasks[ksq]) * Utils.RMagics[ksq]) >> Utils.RShifts[ksq])]) & safe;                  b2 = (Utils.BAttacks[ksq][(((pos.occupied_squares & Utils.BMasks[ksq]) * Utils.BMagics[ksq]) >> Utils.BShifts[ksq])]) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += QueenCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += RookCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += BishopCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += KnightCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }  #else                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + Bitcount.popcount_1s_Max15(undefended))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          attackUnits += QueenContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          attackUnits += RookContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = pos.attacks_from_ROOK(ksq) & safe;                  b2 = pos.attacks_from_BISHOP(ksq) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      attackUnits += QueenCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      attackUnits += RookCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      attackUnits += BishopCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      attackUnits += KnightCheckBonus * Bitcount.popcount_1s_Max15(b);                  }  #endif                    // To index KingDangerTable[] attackUnits must be in [0' 99] range                  attackUnits = Math.Min(99' Math.Max(0' attackUnits));                    // Finally' extract the king danger score from the KingDangerTable[]                  // array and subtract the score from evaluation. Set also margins[]                  // value that will be used for pruning because this value can sometimes                  // be very big' and so capturing a single attacking piece can therefore                  // result in a score change far bigger than the value of the captured piece.                  kingScore = KingDangerTable[Us == RootColor ? 1 : 0][attackUnits];                  score -= kingScore;                  if (Us == ColorC.WHITE)                  {                      marginsWHITE += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }                  else                  {                      marginsBLACK += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_king,The following statement contains a magic number: if (ei.kingAttackersCount[Them] >= 2                  && (ei.kingAdjacentZoneAttacksCount[Them] != 0))              {                  // Find the attacked squares around the king which has no defenders                  // apart from the king itself                  undefended = ei.attackedBy[Them][0] & ei.attackedBy[Us][PieceTypeC.KING];                  undefended &= ~(ei.attackedBy[Us][PieceTypeC.PAWN] | ei.attackedBy[Us][PieceTypeC.KNIGHT]                                  | ei.attackedBy[Us][PieceTypeC.BISHOP] | ei.attackedBy[Us][PieceTypeC.ROOK]                                  | ei.attackedBy[Us][PieceTypeC.QUEEN]);    #if X64                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  b = undefended - ((undefended >> 1) & 0x5555555555555555UL);                  b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + ((int)((b * 0x1111111111111111UL) >> 60)))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += QueenContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += RookContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = (Utils.RAttacks[ksq][(((pos.occupied_squares & Utils.RMasks[ksq]) * Utils.RMagics[ksq]) >> Utils.RShifts[ksq])]) & safe;                  b2 = (Utils.BAttacks[ksq][(((pos.occupied_squares & Utils.BMasks[ksq]) * Utils.BMagics[ksq]) >> Utils.BShifts[ksq])]) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += QueenCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += RookCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += BishopCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += KnightCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }  #else                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + Bitcount.popcount_1s_Max15(undefended))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          attackUnits += QueenContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          attackUnits += RookContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = pos.attacks_from_ROOK(ksq) & safe;                  b2 = pos.attacks_from_BISHOP(ksq) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      attackUnits += QueenCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      attackUnits += RookCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      attackUnits += BishopCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      attackUnits += KnightCheckBonus * Bitcount.popcount_1s_Max15(b);                  }  #endif                    // To index KingDangerTable[] attackUnits must be in [0' 99] range                  attackUnits = Math.Min(99' Math.Max(0' attackUnits));                    // Finally' extract the king danger score from the KingDangerTable[]                  // array and subtract the score from evaluation. Set also margins[]                  // value that will be used for pruning because this value can sometimes                  // be very big' and so capturing a single attacking piece can therefore                  // result in a score change far bigger than the value of the captured piece.                  kingScore = KingDangerTable[Us == RootColor ? 1 : 0][attackUnits];                  score -= kingScore;                  if (Us == ColorC.WHITE)                  {                      marginsWHITE += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }                  else                  {                      marginsBLACK += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_king,The following statement contains a magic number: if (ei.kingAttackersCount[Them] >= 2                  && (ei.kingAdjacentZoneAttacksCount[Them] != 0))              {                  // Find the attacked squares around the king which has no defenders                  // apart from the king itself                  undefended = ei.attackedBy[Them][0] & ei.attackedBy[Us][PieceTypeC.KING];                  undefended &= ~(ei.attackedBy[Us][PieceTypeC.PAWN] | ei.attackedBy[Us][PieceTypeC.KNIGHT]                                  | ei.attackedBy[Us][PieceTypeC.BISHOP] | ei.attackedBy[Us][PieceTypeC.ROOK]                                  | ei.attackedBy[Us][PieceTypeC.QUEEN]);    #if X64                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  b = undefended - ((undefended >> 1) & 0x5555555555555555UL);                  b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + ((int)((b * 0x1111111111111111UL) >> 60)))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += QueenContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          b -= (b >> 1) & 0x5555555555555555UL;                          b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                          attackUnits += RookContactCheckBonus                                        * ((int)((b * 0x1111111111111111UL) >> 60))                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = (Utils.RAttacks[ksq][(((pos.occupied_squares & Utils.RMasks[ksq]) * Utils.RMagics[ksq]) >> Utils.RShifts[ksq])]) & safe;                  b2 = (Utils.BAttacks[ksq][(((pos.occupied_squares & Utils.BMasks[ksq]) * Utils.BMagics[ksq]) >> Utils.BShifts[ksq])]) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += QueenCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += RookCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += BishopCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      b -= (b >> 1) & 0x5555555555555555UL;                      b = ((b >> 2) & 0x3333333333333333UL) + (b & 0x3333333333333333UL);                      attackUnits += KnightCheckBonus * ((int)((b * 0x1111111111111111UL) >> 60));                  }  #else                  // Initialize the 'attackUnits' variable' which is used later on as an                  // index to the KingDangerTable[] array. The initial value is based on                  // the number and types of the enemy's attacking pieces' the number of                  // attacked and undefended squares around our king' the square of the                  // king' and the quality of the pawn shelter.                  attackUnits = Math.Min(25' (ei.kingAttackersCount[Them] * ei.kingAttackersWeight[Them]) / 2)                               + 3 * (ei.kingAdjacentZoneAttacksCount[Them] + Bitcount.popcount_1s_Max15(undefended))                               + InitKingDanger[(ksq ^ (Us * 56))]                               - ((((score) + 32768) & ~0xffff) / 0x10000) / 32;                    // Analyse enemy's safe queen contact checks. First find undefended                  // squares around the king attacked by enemy queen...                  b = undefended & ei.attackedBy[Them][PieceTypeC.QUEEN] & ~(pos.byColorBB[Them]);                  if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.ROOK]);                      if (b != 0)                      {                          attackUnits += QueenContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe rook contact checks. First find undefended                  // squares around the king attacked by enemy rooks...                  b = undefended & ei.attackedBy[Them][PieceTypeC.ROOK] & ~pos.byColorBB[Them];                    // Consider only squares where the enemy rook gives check                  b &= Utils.PseudoAttacks_ROOK[ksq];                    if (b != 0)                  {                      // ...then remove squares not supported by another enemy piece                      b &= (ei.attackedBy[Them][PieceTypeC.PAWN] | ei.attackedBy[Them][PieceTypeC.KNIGHT]                            | ei.attackedBy[Them][PieceTypeC.BISHOP] | ei.attackedBy[Them][PieceTypeC.QUEEN]);                      if (b != 0)                      {                          attackUnits += RookContactCheckBonus                                        * Bitcount.popcount_1s_Max15(b)                                        * (Them == pos.sideToMove ? 2 : 1);                      }                  }                    // Analyse enemy's safe distance checks for sliders and knights                  safe = ~(pos.byColorBB[Them] | ei.attackedBy[Us][0]);                    b1 = pos.attacks_from_ROOK(ksq) & safe;                  b2 = pos.attacks_from_BISHOP(ksq) & safe;                    // Enemy queen safe checks                  b = (b1 | b2) & ei.attackedBy[Them][PieceTypeC.QUEEN];                  if (b != 0)                  {                      attackUnits += QueenCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy rooks safe checks                  b = b1 & ei.attackedBy[Them][PieceTypeC.ROOK];                  if (b != 0)                  {                      attackUnits += RookCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy bishops safe checks                  b = b2 & ei.attackedBy[Them][PieceTypeC.BISHOP];                  if (b != 0)                  {                      attackUnits += BishopCheckBonus * Bitcount.popcount_1s_Max15(b);                  }                    // Enemy knights safe checks                  b = Utils.StepAttacksBB_KNIGHT[ksq] & ei.attackedBy[Them][PieceTypeC.KNIGHT] & safe;                  if (b != 0)                  {                      attackUnits += KnightCheckBonus * Bitcount.popcount_1s_Max15(b);                  }  #endif                    // To index KingDangerTable[] attackUnits must be in [0' 99] range                  attackUnits = Math.Min(99' Math.Max(0' attackUnits));                    // Finally' extract the king danger score from the KingDangerTable[]                  // array and subtract the score from evaluation. Set also margins[]                  // value that will be used for pruning because this value can sometimes                  // be very big' and so capturing a single attacking piece can therefore                  // result in a score change far bigger than the value of the captured piece.                  kingScore = KingDangerTable[Us == RootColor ? 1 : 0][attackUnits];                  score -= kingScore;                  if (Us == ColorC.WHITE)                  {                      marginsWHITE += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }                  else                  {                      marginsBLACK += (((kingScore + 32768) & ~0xffff) / 0x10000);                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_passed_pawns,The following statement contains a magic number: do              {  #if X64                  Bitboard bb = b;                  b &= (b - 1);                  Square s = (Utils.BSFTable[((bb & (0xffffffffffffffff - bb + 1)) * 0x218A392CD3D5DBFUL) >> 58]);  #else                  Square s = Utils.pop_1st_bit(ref b);  #endif                  Debug.Assert(pos.pawn_is_passed(Us' s));                    int r = ((s >> 3) ^ (Us * 7)) - RankC.RANK_2;                  int rr = r * (r - 1);                    // Base bonus based on rank                  Value mbonus = (20 * rr);                  Value ebonus = (10 * (rr + r + 1));                    if (rr != 0)                  {                      Square blockSq = s + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                        // Adjust bonus based on kings proximity                      ebonus += (Utils.SquareDistance[pos.pieceList[Them][PieceTypeC.KING][0]][blockSq] * 5 * rr);                      ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq] * 2 * rr);                        // If blockSq is not the queening square then consider also a second push                      if ((blockSq >> 3) != (Us == ColorC.WHITE ? RankC.RANK_8 : RankC.RANK_1))                      {                          ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)] * rr);                      }                        // If the pawn is free to advance' increase bonus                      if (pos.board[blockSq] == PieceC.NO_PIECE)                      {                          squaresToQueen = Utils.ForwardBB[Us][s];                          defendedSquares = squaresToQueen & ei.attackedBy[Us][0];                            // If there is an enemy rook or queen attacking the pawn from behind'                          // add all X-ray attacks by the rook or queen. Otherwise consider only                          // the squares in the pawn's path attacked or occupied by the enemy.                          if (                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them])) != 0)                              &&                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) & pos.attacks_from_ROOK(s)) != 0)                              )                          {                              unsafeSquares = squaresToQueen;                          }                          else                          {                              unsafeSquares = squaresToQueen & (ei.attackedBy[Them][0] | pos.byColorBB[Them]);                          }                            // If there aren't enemy attacks or pieces along the path to queen give                          // huge bonus. Even bigger if we protect the pawn's path.                          if (unsafeSquares == 0)                              ebonus += (rr * (squaresToQueen == defendedSquares ? 17 : 15));                          else                              // OK' there are enemy attacks or pieces (but not pawns). Are those                              // squares which are attacked by the enemy also attacked by us ?                              // If yes' big bonus (but smaller than when there are no enemy attacks)'                              // if no' somewhat smaller bonus.                              ebonus += (rr * ((unsafeSquares & defendedSquares) == unsafeSquares ? 13 : 8));                      }                  } // rr != 0                    // Increase the bonus if the passed pawn is supported by a friendly pawn                  // on the same rank and a bit smaller if it's on the previous rank.                  supportingPawns = (pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Us]) & Utils.AdjacentFilesBB[s & 7];                  if ((supportingPawns & Utils.RankBB[s >> 3]) != 0)                      ebonus += (r * 20);                  else if ((supportingPawns & Utils.RankBB[(s - (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)) >> 3]) != 0)                      ebonus += (r * 12);                    // Rook pawns are a special case: They are sometimes worse' and                  // sometimes better than other passed pawns. It is difficult to find                  // good rules for determining whether they are good or bad. For now'                  // we try the following: Increase the value for rook pawns if the                  // other side has no pieces apart from a knight' and decrease the                  // value if the other side has a rook or queen.                  if ((s & 7) == FileC.FILE_A || (s & 7) == FileC.FILE_H)                  {                      if ((Them == 0 ? pos.st.npMaterialWHITE : pos.st.npMaterialBLACK) <= Constants.KnightValueMidgame)                          ebonus += ebonus / 4;                      else if (((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) != 0)                          ebonus -= ebonus / 4;                  }                  score += ((mbonus << 16) + ebonus);                } while (b != 0);
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_passed_pawns,The following statement contains a magic number: do              {  #if X64                  Bitboard bb = b;                  b &= (b - 1);                  Square s = (Utils.BSFTable[((bb & (0xffffffffffffffff - bb + 1)) * 0x218A392CD3D5DBFUL) >> 58]);  #else                  Square s = Utils.pop_1st_bit(ref b);  #endif                  Debug.Assert(pos.pawn_is_passed(Us' s));                    int r = ((s >> 3) ^ (Us * 7)) - RankC.RANK_2;                  int rr = r * (r - 1);                    // Base bonus based on rank                  Value mbonus = (20 * rr);                  Value ebonus = (10 * (rr + r + 1));                    if (rr != 0)                  {                      Square blockSq = s + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                        // Adjust bonus based on kings proximity                      ebonus += (Utils.SquareDistance[pos.pieceList[Them][PieceTypeC.KING][0]][blockSq] * 5 * rr);                      ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq] * 2 * rr);                        // If blockSq is not the queening square then consider also a second push                      if ((blockSq >> 3) != (Us == ColorC.WHITE ? RankC.RANK_8 : RankC.RANK_1))                      {                          ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)] * rr);                      }                        // If the pawn is free to advance' increase bonus                      if (pos.board[blockSq] == PieceC.NO_PIECE)                      {                          squaresToQueen = Utils.ForwardBB[Us][s];                          defendedSquares = squaresToQueen & ei.attackedBy[Us][0];                            // If there is an enemy rook or queen attacking the pawn from behind'                          // add all X-ray attacks by the rook or queen. Otherwise consider only                          // the squares in the pawn's path attacked or occupied by the enemy.                          if (                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them])) != 0)                              &&                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) & pos.attacks_from_ROOK(s)) != 0)                              )                          {                              unsafeSquares = squaresToQueen;                          }                          else                          {                              unsafeSquares = squaresToQueen & (ei.attackedBy[Them][0] | pos.byColorBB[Them]);                          }                            // If there aren't enemy attacks or pieces along the path to queen give                          // huge bonus. Even bigger if we protect the pawn's path.                          if (unsafeSquares == 0)                              ebonus += (rr * (squaresToQueen == defendedSquares ? 17 : 15));                          else                              // OK' there are enemy attacks or pieces (but not pawns). Are those                              // squares which are attacked by the enemy also attacked by us ?                              // If yes' big bonus (but smaller than when there are no enemy attacks)'                              // if no' somewhat smaller bonus.                              ebonus += (rr * ((unsafeSquares & defendedSquares) == unsafeSquares ? 13 : 8));                      }                  } // rr != 0                    // Increase the bonus if the passed pawn is supported by a friendly pawn                  // on the same rank and a bit smaller if it's on the previous rank.                  supportingPawns = (pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Us]) & Utils.AdjacentFilesBB[s & 7];                  if ((supportingPawns & Utils.RankBB[s >> 3]) != 0)                      ebonus += (r * 20);                  else if ((supportingPawns & Utils.RankBB[(s - (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)) >> 3]) != 0)                      ebonus += (r * 12);                    // Rook pawns are a special case: They are sometimes worse' and                  // sometimes better than other passed pawns. It is difficult to find                  // good rules for determining whether they are good or bad. For now'                  // we try the following: Increase the value for rook pawns if the                  // other side has no pieces apart from a knight' and decrease the                  // value if the other side has a rook or queen.                  if ((s & 7) == FileC.FILE_A || (s & 7) == FileC.FILE_H)                  {                      if ((Them == 0 ? pos.st.npMaterialWHITE : pos.st.npMaterialBLACK) <= Constants.KnightValueMidgame)                          ebonus += ebonus / 4;                      else if (((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) != 0)                          ebonus -= ebonus / 4;                  }                  score += ((mbonus << 16) + ebonus);                } while (b != 0);
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_passed_pawns,The following statement contains a magic number: do              {  #if X64                  Bitboard bb = b;                  b &= (b - 1);                  Square s = (Utils.BSFTable[((bb & (0xffffffffffffffff - bb + 1)) * 0x218A392CD3D5DBFUL) >> 58]);  #else                  Square s = Utils.pop_1st_bit(ref b);  #endif                  Debug.Assert(pos.pawn_is_passed(Us' s));                    int r = ((s >> 3) ^ (Us * 7)) - RankC.RANK_2;                  int rr = r * (r - 1);                    // Base bonus based on rank                  Value mbonus = (20 * rr);                  Value ebonus = (10 * (rr + r + 1));                    if (rr != 0)                  {                      Square blockSq = s + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                        // Adjust bonus based on kings proximity                      ebonus += (Utils.SquareDistance[pos.pieceList[Them][PieceTypeC.KING][0]][blockSq] * 5 * rr);                      ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq] * 2 * rr);                        // If blockSq is not the queening square then consider also a second push                      if ((blockSq >> 3) != (Us == ColorC.WHITE ? RankC.RANK_8 : RankC.RANK_1))                      {                          ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)] * rr);                      }                        // If the pawn is free to advance' increase bonus                      if (pos.board[blockSq] == PieceC.NO_PIECE)                      {                          squaresToQueen = Utils.ForwardBB[Us][s];                          defendedSquares = squaresToQueen & ei.attackedBy[Us][0];                            // If there is an enemy rook or queen attacking the pawn from behind'                          // add all X-ray attacks by the rook or queen. Otherwise consider only                          // the squares in the pawn's path attacked or occupied by the enemy.                          if (                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them])) != 0)                              &&                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) & pos.attacks_from_ROOK(s)) != 0)                              )                          {                              unsafeSquares = squaresToQueen;                          }                          else                          {                              unsafeSquares = squaresToQueen & (ei.attackedBy[Them][0] | pos.byColorBB[Them]);                          }                            // If there aren't enemy attacks or pieces along the path to queen give                          // huge bonus. Even bigger if we protect the pawn's path.                          if (unsafeSquares == 0)                              ebonus += (rr * (squaresToQueen == defendedSquares ? 17 : 15));                          else                              // OK' there are enemy attacks or pieces (but not pawns). Are those                              // squares which are attacked by the enemy also attacked by us ?                              // If yes' big bonus (but smaller than when there are no enemy attacks)'                              // if no' somewhat smaller bonus.                              ebonus += (rr * ((unsafeSquares & defendedSquares) == unsafeSquares ? 13 : 8));                      }                  } // rr != 0                    // Increase the bonus if the passed pawn is supported by a friendly pawn                  // on the same rank and a bit smaller if it's on the previous rank.                  supportingPawns = (pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Us]) & Utils.AdjacentFilesBB[s & 7];                  if ((supportingPawns & Utils.RankBB[s >> 3]) != 0)                      ebonus += (r * 20);                  else if ((supportingPawns & Utils.RankBB[(s - (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)) >> 3]) != 0)                      ebonus += (r * 12);                    // Rook pawns are a special case: They are sometimes worse' and                  // sometimes better than other passed pawns. It is difficult to find                  // good rules for determining whether they are good or bad. For now'                  // we try the following: Increase the value for rook pawns if the                  // other side has no pieces apart from a knight' and decrease the                  // value if the other side has a rook or queen.                  if ((s & 7) == FileC.FILE_A || (s & 7) == FileC.FILE_H)                  {                      if ((Them == 0 ? pos.st.npMaterialWHITE : pos.st.npMaterialBLACK) <= Constants.KnightValueMidgame)                          ebonus += ebonus / 4;                      else if (((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) != 0)                          ebonus -= ebonus / 4;                  }                  score += ((mbonus << 16) + ebonus);                } while (b != 0);
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_passed_pawns,The following statement contains a magic number: do              {  #if X64                  Bitboard bb = b;                  b &= (b - 1);                  Square s = (Utils.BSFTable[((bb & (0xffffffffffffffff - bb + 1)) * 0x218A392CD3D5DBFUL) >> 58]);  #else                  Square s = Utils.pop_1st_bit(ref b);  #endif                  Debug.Assert(pos.pawn_is_passed(Us' s));                    int r = ((s >> 3) ^ (Us * 7)) - RankC.RANK_2;                  int rr = r * (r - 1);                    // Base bonus based on rank                  Value mbonus = (20 * rr);                  Value ebonus = (10 * (rr + r + 1));                    if (rr != 0)                  {                      Square blockSq = s + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                        // Adjust bonus based on kings proximity                      ebonus += (Utils.SquareDistance[pos.pieceList[Them][PieceTypeC.KING][0]][blockSq] * 5 * rr);                      ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq] * 2 * rr);                        // If blockSq is not the queening square then consider also a second push                      if ((blockSq >> 3) != (Us == ColorC.WHITE ? RankC.RANK_8 : RankC.RANK_1))                      {                          ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)] * rr);                      }                        // If the pawn is free to advance' increase bonus                      if (pos.board[blockSq] == PieceC.NO_PIECE)                      {                          squaresToQueen = Utils.ForwardBB[Us][s];                          defendedSquares = squaresToQueen & ei.attackedBy[Us][0];                            // If there is an enemy rook or queen attacking the pawn from behind'                          // add all X-ray attacks by the rook or queen. Otherwise consider only                          // the squares in the pawn's path attacked or occupied by the enemy.                          if (                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them])) != 0)                              &&                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) & pos.attacks_from_ROOK(s)) != 0)                              )                          {                              unsafeSquares = squaresToQueen;                          }                          else                          {                              unsafeSquares = squaresToQueen & (ei.attackedBy[Them][0] | pos.byColorBB[Them]);                          }                            // If there aren't enemy attacks or pieces along the path to queen give                          // huge bonus. Even bigger if we protect the pawn's path.                          if (unsafeSquares == 0)                              ebonus += (rr * (squaresToQueen == defendedSquares ? 17 : 15));                          else                              // OK' there are enemy attacks or pieces (but not pawns). Are those                              // squares which are attacked by the enemy also attacked by us ?                              // If yes' big bonus (but smaller than when there are no enemy attacks)'                              // if no' somewhat smaller bonus.                              ebonus += (rr * ((unsafeSquares & defendedSquares) == unsafeSquares ? 13 : 8));                      }                  } // rr != 0                    // Increase the bonus if the passed pawn is supported by a friendly pawn                  // on the same rank and a bit smaller if it's on the previous rank.                  supportingPawns = (pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Us]) & Utils.AdjacentFilesBB[s & 7];                  if ((supportingPawns & Utils.RankBB[s >> 3]) != 0)                      ebonus += (r * 20);                  else if ((supportingPawns & Utils.RankBB[(s - (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)) >> 3]) != 0)                      ebonus += (r * 12);                    // Rook pawns are a special case: They are sometimes worse' and                  // sometimes better than other passed pawns. It is difficult to find                  // good rules for determining whether they are good or bad. For now'                  // we try the following: Increase the value for rook pawns if the                  // other side has no pieces apart from a knight' and decrease the                  // value if the other side has a rook or queen.                  if ((s & 7) == FileC.FILE_A || (s & 7) == FileC.FILE_H)                  {                      if ((Them == 0 ? pos.st.npMaterialWHITE : pos.st.npMaterialBLACK) <= Constants.KnightValueMidgame)                          ebonus += ebonus / 4;                      else if (((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) != 0)                          ebonus -= ebonus / 4;                  }                  score += ((mbonus << 16) + ebonus);                } while (b != 0);
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_passed_pawns,The following statement contains a magic number: do              {  #if X64                  Bitboard bb = b;                  b &= (b - 1);                  Square s = (Utils.BSFTable[((bb & (0xffffffffffffffff - bb + 1)) * 0x218A392CD3D5DBFUL) >> 58]);  #else                  Square s = Utils.pop_1st_bit(ref b);  #endif                  Debug.Assert(pos.pawn_is_passed(Us' s));                    int r = ((s >> 3) ^ (Us * 7)) - RankC.RANK_2;                  int rr = r * (r - 1);                    // Base bonus based on rank                  Value mbonus = (20 * rr);                  Value ebonus = (10 * (rr + r + 1));                    if (rr != 0)                  {                      Square blockSq = s + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                        // Adjust bonus based on kings proximity                      ebonus += (Utils.SquareDistance[pos.pieceList[Them][PieceTypeC.KING][0]][blockSq] * 5 * rr);                      ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq] * 2 * rr);                        // If blockSq is not the queening square then consider also a second push                      if ((blockSq >> 3) != (Us == ColorC.WHITE ? RankC.RANK_8 : RankC.RANK_1))                      {                          ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)] * rr);                      }                        // If the pawn is free to advance' increase bonus                      if (pos.board[blockSq] == PieceC.NO_PIECE)                      {                          squaresToQueen = Utils.ForwardBB[Us][s];                          defendedSquares = squaresToQueen & ei.attackedBy[Us][0];                            // If there is an enemy rook or queen attacking the pawn from behind'                          // add all X-ray attacks by the rook or queen. Otherwise consider only                          // the squares in the pawn's path attacked or occupied by the enemy.                          if (                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them])) != 0)                              &&                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) & pos.attacks_from_ROOK(s)) != 0)                              )                          {                              unsafeSquares = squaresToQueen;                          }                          else                          {                              unsafeSquares = squaresToQueen & (ei.attackedBy[Them][0] | pos.byColorBB[Them]);                          }                            // If there aren't enemy attacks or pieces along the path to queen give                          // huge bonus. Even bigger if we protect the pawn's path.                          if (unsafeSquares == 0)                              ebonus += (rr * (squaresToQueen == defendedSquares ? 17 : 15));                          else                              // OK' there are enemy attacks or pieces (but not pawns). Are those                              // squares which are attacked by the enemy also attacked by us ?                              // If yes' big bonus (but smaller than when there are no enemy attacks)'                              // if no' somewhat smaller bonus.                              ebonus += (rr * ((unsafeSquares & defendedSquares) == unsafeSquares ? 13 : 8));                      }                  } // rr != 0                    // Increase the bonus if the passed pawn is supported by a friendly pawn                  // on the same rank and a bit smaller if it's on the previous rank.                  supportingPawns = (pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Us]) & Utils.AdjacentFilesBB[s & 7];                  if ((supportingPawns & Utils.RankBB[s >> 3]) != 0)                      ebonus += (r * 20);                  else if ((supportingPawns & Utils.RankBB[(s - (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)) >> 3]) != 0)                      ebonus += (r * 12);                    // Rook pawns are a special case: They are sometimes worse' and                  // sometimes better than other passed pawns. It is difficult to find                  // good rules for determining whether they are good or bad. For now'                  // we try the following: Increase the value for rook pawns if the                  // other side has no pieces apart from a knight' and decrease the                  // value if the other side has a rook or queen.                  if ((s & 7) == FileC.FILE_A || (s & 7) == FileC.FILE_H)                  {                      if ((Them == 0 ? pos.st.npMaterialWHITE : pos.st.npMaterialBLACK) <= Constants.KnightValueMidgame)                          ebonus += ebonus / 4;                      else if (((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) != 0)                          ebonus -= ebonus / 4;                  }                  score += ((mbonus << 16) + ebonus);                } while (b != 0);
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_passed_pawns,The following statement contains a magic number: do              {  #if X64                  Bitboard bb = b;                  b &= (b - 1);                  Square s = (Utils.BSFTable[((bb & (0xffffffffffffffff - bb + 1)) * 0x218A392CD3D5DBFUL) >> 58]);  #else                  Square s = Utils.pop_1st_bit(ref b);  #endif                  Debug.Assert(pos.pawn_is_passed(Us' s));                    int r = ((s >> 3) ^ (Us * 7)) - RankC.RANK_2;                  int rr = r * (r - 1);                    // Base bonus based on rank                  Value mbonus = (20 * rr);                  Value ebonus = (10 * (rr + r + 1));                    if (rr != 0)                  {                      Square blockSq = s + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                        // Adjust bonus based on kings proximity                      ebonus += (Utils.SquareDistance[pos.pieceList[Them][PieceTypeC.KING][0]][blockSq] * 5 * rr);                      ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq] * 2 * rr);                        // If blockSq is not the queening square then consider also a second push                      if ((blockSq >> 3) != (Us == ColorC.WHITE ? RankC.RANK_8 : RankC.RANK_1))                      {                          ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)] * rr);                      }                        // If the pawn is free to advance' increase bonus                      if (pos.board[blockSq] == PieceC.NO_PIECE)                      {                          squaresToQueen = Utils.ForwardBB[Us][s];                          defendedSquares = squaresToQueen & ei.attackedBy[Us][0];                            // If there is an enemy rook or queen attacking the pawn from behind'                          // add all X-ray attacks by the rook or queen. Otherwise consider only                          // the squares in the pawn's path attacked or occupied by the enemy.                          if (                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them])) != 0)                              &&                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) & pos.attacks_from_ROOK(s)) != 0)                              )                          {                              unsafeSquares = squaresToQueen;                          }                          else                          {                              unsafeSquares = squaresToQueen & (ei.attackedBy[Them][0] | pos.byColorBB[Them]);                          }                            // If there aren't enemy attacks or pieces along the path to queen give                          // huge bonus. Even bigger if we protect the pawn's path.                          if (unsafeSquares == 0)                              ebonus += (rr * (squaresToQueen == defendedSquares ? 17 : 15));                          else                              // OK' there are enemy attacks or pieces (but not pawns). Are those                              // squares which are attacked by the enemy also attacked by us ?                              // If yes' big bonus (but smaller than when there are no enemy attacks)'                              // if no' somewhat smaller bonus.                              ebonus += (rr * ((unsafeSquares & defendedSquares) == unsafeSquares ? 13 : 8));                      }                  } // rr != 0                    // Increase the bonus if the passed pawn is supported by a friendly pawn                  // on the same rank and a bit smaller if it's on the previous rank.                  supportingPawns = (pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Us]) & Utils.AdjacentFilesBB[s & 7];                  if ((supportingPawns & Utils.RankBB[s >> 3]) != 0)                      ebonus += (r * 20);                  else if ((supportingPawns & Utils.RankBB[(s - (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)) >> 3]) != 0)                      ebonus += (r * 12);                    // Rook pawns are a special case: They are sometimes worse' and                  // sometimes better than other passed pawns. It is difficult to find                  // good rules for determining whether they are good or bad. For now'                  // we try the following: Increase the value for rook pawns if the                  // other side has no pieces apart from a knight' and decrease the                  // value if the other side has a rook or queen.                  if ((s & 7) == FileC.FILE_A || (s & 7) == FileC.FILE_H)                  {                      if ((Them == 0 ? pos.st.npMaterialWHITE : pos.st.npMaterialBLACK) <= Constants.KnightValueMidgame)                          ebonus += ebonus / 4;                      else if (((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) != 0)                          ebonus -= ebonus / 4;                  }                  score += ((mbonus << 16) + ebonus);                } while (b != 0);
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_passed_pawns,The following statement contains a magic number: do              {  #if X64                  Bitboard bb = b;                  b &= (b - 1);                  Square s = (Utils.BSFTable[((bb & (0xffffffffffffffff - bb + 1)) * 0x218A392CD3D5DBFUL) >> 58]);  #else                  Square s = Utils.pop_1st_bit(ref b);  #endif                  Debug.Assert(pos.pawn_is_passed(Us' s));                    int r = ((s >> 3) ^ (Us * 7)) - RankC.RANK_2;                  int rr = r * (r - 1);                    // Base bonus based on rank                  Value mbonus = (20 * rr);                  Value ebonus = (10 * (rr + r + 1));                    if (rr != 0)                  {                      Square blockSq = s + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                        // Adjust bonus based on kings proximity                      ebonus += (Utils.SquareDistance[pos.pieceList[Them][PieceTypeC.KING][0]][blockSq] * 5 * rr);                      ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq] * 2 * rr);                        // If blockSq is not the queening square then consider also a second push                      if ((blockSq >> 3) != (Us == ColorC.WHITE ? RankC.RANK_8 : RankC.RANK_1))                      {                          ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)] * rr);                      }                        // If the pawn is free to advance' increase bonus                      if (pos.board[blockSq] == PieceC.NO_PIECE)                      {                          squaresToQueen = Utils.ForwardBB[Us][s];                          defendedSquares = squaresToQueen & ei.attackedBy[Us][0];                            // If there is an enemy rook or queen attacking the pawn from behind'                          // add all X-ray attacks by the rook or queen. Otherwise consider only                          // the squares in the pawn's path attacked or occupied by the enemy.                          if (                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them])) != 0)                              &&                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) & pos.attacks_from_ROOK(s)) != 0)                              )                          {                              unsafeSquares = squaresToQueen;                          }                          else                          {                              unsafeSquares = squaresToQueen & (ei.attackedBy[Them][0] | pos.byColorBB[Them]);                          }                            // If there aren't enemy attacks or pieces along the path to queen give                          // huge bonus. Even bigger if we protect the pawn's path.                          if (unsafeSquares == 0)                              ebonus += (rr * (squaresToQueen == defendedSquares ? 17 : 15));                          else                              // OK' there are enemy attacks or pieces (but not pawns). Are those                              // squares which are attacked by the enemy also attacked by us ?                              // If yes' big bonus (but smaller than when there are no enemy attacks)'                              // if no' somewhat smaller bonus.                              ebonus += (rr * ((unsafeSquares & defendedSquares) == unsafeSquares ? 13 : 8));                      }                  } // rr != 0                    // Increase the bonus if the passed pawn is supported by a friendly pawn                  // on the same rank and a bit smaller if it's on the previous rank.                  supportingPawns = (pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Us]) & Utils.AdjacentFilesBB[s & 7];                  if ((supportingPawns & Utils.RankBB[s >> 3]) != 0)                      ebonus += (r * 20);                  else if ((supportingPawns & Utils.RankBB[(s - (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)) >> 3]) != 0)                      ebonus += (r * 12);                    // Rook pawns are a special case: They are sometimes worse' and                  // sometimes better than other passed pawns. It is difficult to find                  // good rules for determining whether they are good or bad. For now'                  // we try the following: Increase the value for rook pawns if the                  // other side has no pieces apart from a knight' and decrease the                  // value if the other side has a rook or queen.                  if ((s & 7) == FileC.FILE_A || (s & 7) == FileC.FILE_H)                  {                      if ((Them == 0 ? pos.st.npMaterialWHITE : pos.st.npMaterialBLACK) <= Constants.KnightValueMidgame)                          ebonus += ebonus / 4;                      else if (((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) != 0)                          ebonus -= ebonus / 4;                  }                  score += ((mbonus << 16) + ebonus);                } while (b != 0);
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_passed_pawns,The following statement contains a magic number: do              {  #if X64                  Bitboard bb = b;                  b &= (b - 1);                  Square s = (Utils.BSFTable[((bb & (0xffffffffffffffff - bb + 1)) * 0x218A392CD3D5DBFUL) >> 58]);  #else                  Square s = Utils.pop_1st_bit(ref b);  #endif                  Debug.Assert(pos.pawn_is_passed(Us' s));                    int r = ((s >> 3) ^ (Us * 7)) - RankC.RANK_2;                  int rr = r * (r - 1);                    // Base bonus based on rank                  Value mbonus = (20 * rr);                  Value ebonus = (10 * (rr + r + 1));                    if (rr != 0)                  {                      Square blockSq = s + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                        // Adjust bonus based on kings proximity                      ebonus += (Utils.SquareDistance[pos.pieceList[Them][PieceTypeC.KING][0]][blockSq] * 5 * rr);                      ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq] * 2 * rr);                        // If blockSq is not the queening square then consider also a second push                      if ((blockSq >> 3) != (Us == ColorC.WHITE ? RankC.RANK_8 : RankC.RANK_1))                      {                          ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)] * rr);                      }                        // If the pawn is free to advance' increase bonus                      if (pos.board[blockSq] == PieceC.NO_PIECE)                      {                          squaresToQueen = Utils.ForwardBB[Us][s];                          defendedSquares = squaresToQueen & ei.attackedBy[Us][0];                            // If there is an enemy rook or queen attacking the pawn from behind'                          // add all X-ray attacks by the rook or queen. Otherwise consider only                          // the squares in the pawn's path attacked or occupied by the enemy.                          if (                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them])) != 0)                              &&                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) & pos.attacks_from_ROOK(s)) != 0)                              )                          {                              unsafeSquares = squaresToQueen;                          }                          else                          {                              unsafeSquares = squaresToQueen & (ei.attackedBy[Them][0] | pos.byColorBB[Them]);                          }                            // If there aren't enemy attacks or pieces along the path to queen give                          // huge bonus. Even bigger if we protect the pawn's path.                          if (unsafeSquares == 0)                              ebonus += (rr * (squaresToQueen == defendedSquares ? 17 : 15));                          else                              // OK' there are enemy attacks or pieces (but not pawns). Are those                              // squares which are attacked by the enemy also attacked by us ?                              // If yes' big bonus (but smaller than when there are no enemy attacks)'                              // if no' somewhat smaller bonus.                              ebonus += (rr * ((unsafeSquares & defendedSquares) == unsafeSquares ? 13 : 8));                      }                  } // rr != 0                    // Increase the bonus if the passed pawn is supported by a friendly pawn                  // on the same rank and a bit smaller if it's on the previous rank.                  supportingPawns = (pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Us]) & Utils.AdjacentFilesBB[s & 7];                  if ((supportingPawns & Utils.RankBB[s >> 3]) != 0)                      ebonus += (r * 20);                  else if ((supportingPawns & Utils.RankBB[(s - (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)) >> 3]) != 0)                      ebonus += (r * 12);                    // Rook pawns are a special case: They are sometimes worse' and                  // sometimes better than other passed pawns. It is difficult to find                  // good rules for determining whether they are good or bad. For now'                  // we try the following: Increase the value for rook pawns if the                  // other side has no pieces apart from a knight' and decrease the                  // value if the other side has a rook or queen.                  if ((s & 7) == FileC.FILE_A || (s & 7) == FileC.FILE_H)                  {                      if ((Them == 0 ? pos.st.npMaterialWHITE : pos.st.npMaterialBLACK) <= Constants.KnightValueMidgame)                          ebonus += ebonus / 4;                      else if (((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) != 0)                          ebonus -= ebonus / 4;                  }                  score += ((mbonus << 16) + ebonus);                } while (b != 0);
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_passed_pawns,The following statement contains a magic number: do              {  #if X64                  Bitboard bb = b;                  b &= (b - 1);                  Square s = (Utils.BSFTable[((bb & (0xffffffffffffffff - bb + 1)) * 0x218A392CD3D5DBFUL) >> 58]);  #else                  Square s = Utils.pop_1st_bit(ref b);  #endif                  Debug.Assert(pos.pawn_is_passed(Us' s));                    int r = ((s >> 3) ^ (Us * 7)) - RankC.RANK_2;                  int rr = r * (r - 1);                    // Base bonus based on rank                  Value mbonus = (20 * rr);                  Value ebonus = (10 * (rr + r + 1));                    if (rr != 0)                  {                      Square blockSq = s + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                        // Adjust bonus based on kings proximity                      ebonus += (Utils.SquareDistance[pos.pieceList[Them][PieceTypeC.KING][0]][blockSq] * 5 * rr);                      ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq] * 2 * rr);                        // If blockSq is not the queening square then consider also a second push                      if ((blockSq >> 3) != (Us == ColorC.WHITE ? RankC.RANK_8 : RankC.RANK_1))                      {                          ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)] * rr);                      }                        // If the pawn is free to advance' increase bonus                      if (pos.board[blockSq] == PieceC.NO_PIECE)                      {                          squaresToQueen = Utils.ForwardBB[Us][s];                          defendedSquares = squaresToQueen & ei.attackedBy[Us][0];                            // If there is an enemy rook or queen attacking the pawn from behind'                          // add all X-ray attacks by the rook or queen. Otherwise consider only                          // the squares in the pawn's path attacked or occupied by the enemy.                          if (                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them])) != 0)                              &&                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) & pos.attacks_from_ROOK(s)) != 0)                              )                          {                              unsafeSquares = squaresToQueen;                          }                          else                          {                              unsafeSquares = squaresToQueen & (ei.attackedBy[Them][0] | pos.byColorBB[Them]);                          }                            // If there aren't enemy attacks or pieces along the path to queen give                          // huge bonus. Even bigger if we protect the pawn's path.                          if (unsafeSquares == 0)                              ebonus += (rr * (squaresToQueen == defendedSquares ? 17 : 15));                          else                              // OK' there are enemy attacks or pieces (but not pawns). Are those                              // squares which are attacked by the enemy also attacked by us ?                              // If yes' big bonus (but smaller than when there are no enemy attacks)'                              // if no' somewhat smaller bonus.                              ebonus += (rr * ((unsafeSquares & defendedSquares) == unsafeSquares ? 13 : 8));                      }                  } // rr != 0                    // Increase the bonus if the passed pawn is supported by a friendly pawn                  // on the same rank and a bit smaller if it's on the previous rank.                  supportingPawns = (pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Us]) & Utils.AdjacentFilesBB[s & 7];                  if ((supportingPawns & Utils.RankBB[s >> 3]) != 0)                      ebonus += (r * 20);                  else if ((supportingPawns & Utils.RankBB[(s - (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)) >> 3]) != 0)                      ebonus += (r * 12);                    // Rook pawns are a special case: They are sometimes worse' and                  // sometimes better than other passed pawns. It is difficult to find                  // good rules for determining whether they are good or bad. For now'                  // we try the following: Increase the value for rook pawns if the                  // other side has no pieces apart from a knight' and decrease the                  // value if the other side has a rook or queen.                  if ((s & 7) == FileC.FILE_A || (s & 7) == FileC.FILE_H)                  {                      if ((Them == 0 ? pos.st.npMaterialWHITE : pos.st.npMaterialBLACK) <= Constants.KnightValueMidgame)                          ebonus += ebonus / 4;                      else if (((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) != 0)                          ebonus -= ebonus / 4;                  }                  score += ((mbonus << 16) + ebonus);                } while (b != 0);
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_passed_pawns,The following statement contains a magic number: do              {  #if X64                  Bitboard bb = b;                  b &= (b - 1);                  Square s = (Utils.BSFTable[((bb & (0xffffffffffffffff - bb + 1)) * 0x218A392CD3D5DBFUL) >> 58]);  #else                  Square s = Utils.pop_1st_bit(ref b);  #endif                  Debug.Assert(pos.pawn_is_passed(Us' s));                    int r = ((s >> 3) ^ (Us * 7)) - RankC.RANK_2;                  int rr = r * (r - 1);                    // Base bonus based on rank                  Value mbonus = (20 * rr);                  Value ebonus = (10 * (rr + r + 1));                    if (rr != 0)                  {                      Square blockSq = s + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                        // Adjust bonus based on kings proximity                      ebonus += (Utils.SquareDistance[pos.pieceList[Them][PieceTypeC.KING][0]][blockSq] * 5 * rr);                      ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq] * 2 * rr);                        // If blockSq is not the queening square then consider also a second push                      if ((blockSq >> 3) != (Us == ColorC.WHITE ? RankC.RANK_8 : RankC.RANK_1))                      {                          ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)] * rr);                      }                        // If the pawn is free to advance' increase bonus                      if (pos.board[blockSq] == PieceC.NO_PIECE)                      {                          squaresToQueen = Utils.ForwardBB[Us][s];                          defendedSquares = squaresToQueen & ei.attackedBy[Us][0];                            // If there is an enemy rook or queen attacking the pawn from behind'                          // add all X-ray attacks by the rook or queen. Otherwise consider only                          // the squares in the pawn's path attacked or occupied by the enemy.                          if (                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them])) != 0)                              &&                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) & pos.attacks_from_ROOK(s)) != 0)                              )                          {                              unsafeSquares = squaresToQueen;                          }                          else                          {                              unsafeSquares = squaresToQueen & (ei.attackedBy[Them][0] | pos.byColorBB[Them]);                          }                            // If there aren't enemy attacks or pieces along the path to queen give                          // huge bonus. Even bigger if we protect the pawn's path.                          if (unsafeSquares == 0)                              ebonus += (rr * (squaresToQueen == defendedSquares ? 17 : 15));                          else                              // OK' there are enemy attacks or pieces (but not pawns). Are those                              // squares which are attacked by the enemy also attacked by us ?                              // If yes' big bonus (but smaller than when there are no enemy attacks)'                              // if no' somewhat smaller bonus.                              ebonus += (rr * ((unsafeSquares & defendedSquares) == unsafeSquares ? 13 : 8));                      }                  } // rr != 0                    // Increase the bonus if the passed pawn is supported by a friendly pawn                  // on the same rank and a bit smaller if it's on the previous rank.                  supportingPawns = (pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Us]) & Utils.AdjacentFilesBB[s & 7];                  if ((supportingPawns & Utils.RankBB[s >> 3]) != 0)                      ebonus += (r * 20);                  else if ((supportingPawns & Utils.RankBB[(s - (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)) >> 3]) != 0)                      ebonus += (r * 12);                    // Rook pawns are a special case: They are sometimes worse' and                  // sometimes better than other passed pawns. It is difficult to find                  // good rules for determining whether they are good or bad. For now'                  // we try the following: Increase the value for rook pawns if the                  // other side has no pieces apart from a knight' and decrease the                  // value if the other side has a rook or queen.                  if ((s & 7) == FileC.FILE_A || (s & 7) == FileC.FILE_H)                  {                      if ((Them == 0 ? pos.st.npMaterialWHITE : pos.st.npMaterialBLACK) <= Constants.KnightValueMidgame)                          ebonus += ebonus / 4;                      else if (((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) != 0)                          ebonus -= ebonus / 4;                  }                  score += ((mbonus << 16) + ebonus);                } while (b != 0);
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_passed_pawns,The following statement contains a magic number: do              {  #if X64                  Bitboard bb = b;                  b &= (b - 1);                  Square s = (Utils.BSFTable[((bb & (0xffffffffffffffff - bb + 1)) * 0x218A392CD3D5DBFUL) >> 58]);  #else                  Square s = Utils.pop_1st_bit(ref b);  #endif                  Debug.Assert(pos.pawn_is_passed(Us' s));                    int r = ((s >> 3) ^ (Us * 7)) - RankC.RANK_2;                  int rr = r * (r - 1);                    // Base bonus based on rank                  Value mbonus = (20 * rr);                  Value ebonus = (10 * (rr + r + 1));                    if (rr != 0)                  {                      Square blockSq = s + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                        // Adjust bonus based on kings proximity                      ebonus += (Utils.SquareDistance[pos.pieceList[Them][PieceTypeC.KING][0]][blockSq] * 5 * rr);                      ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq] * 2 * rr);                        // If blockSq is not the queening square then consider also a second push                      if ((blockSq >> 3) != (Us == ColorC.WHITE ? RankC.RANK_8 : RankC.RANK_1))                      {                          ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)] * rr);                      }                        // If the pawn is free to advance' increase bonus                      if (pos.board[blockSq] == PieceC.NO_PIECE)                      {                          squaresToQueen = Utils.ForwardBB[Us][s];                          defendedSquares = squaresToQueen & ei.attackedBy[Us][0];                            // If there is an enemy rook or queen attacking the pawn from behind'                          // add all X-ray attacks by the rook or queen. Otherwise consider only                          // the squares in the pawn's path attacked or occupied by the enemy.                          if (                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them])) != 0)                              &&                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) & pos.attacks_from_ROOK(s)) != 0)                              )                          {                              unsafeSquares = squaresToQueen;                          }                          else                          {                              unsafeSquares = squaresToQueen & (ei.attackedBy[Them][0] | pos.byColorBB[Them]);                          }                            // If there aren't enemy attacks or pieces along the path to queen give                          // huge bonus. Even bigger if we protect the pawn's path.                          if (unsafeSquares == 0)                              ebonus += (rr * (squaresToQueen == defendedSquares ? 17 : 15));                          else                              // OK' there are enemy attacks or pieces (but not pawns). Are those                              // squares which are attacked by the enemy also attacked by us ?                              // If yes' big bonus (but smaller than when there are no enemy attacks)'                              // if no' somewhat smaller bonus.                              ebonus += (rr * ((unsafeSquares & defendedSquares) == unsafeSquares ? 13 : 8));                      }                  } // rr != 0                    // Increase the bonus if the passed pawn is supported by a friendly pawn                  // on the same rank and a bit smaller if it's on the previous rank.                  supportingPawns = (pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Us]) & Utils.AdjacentFilesBB[s & 7];                  if ((supportingPawns & Utils.RankBB[s >> 3]) != 0)                      ebonus += (r * 20);                  else if ((supportingPawns & Utils.RankBB[(s - (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)) >> 3]) != 0)                      ebonus += (r * 12);                    // Rook pawns are a special case: They are sometimes worse' and                  // sometimes better than other passed pawns. It is difficult to find                  // good rules for determining whether they are good or bad. For now'                  // we try the following: Increase the value for rook pawns if the                  // other side has no pieces apart from a knight' and decrease the                  // value if the other side has a rook or queen.                  if ((s & 7) == FileC.FILE_A || (s & 7) == FileC.FILE_H)                  {                      if ((Them == 0 ? pos.st.npMaterialWHITE : pos.st.npMaterialBLACK) <= Constants.KnightValueMidgame)                          ebonus += ebonus / 4;                      else if (((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) != 0)                          ebonus -= ebonus / 4;                  }                  score += ((mbonus << 16) + ebonus);                } while (b != 0);
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_passed_pawns,The following statement contains a magic number: do              {  #if X64                  Bitboard bb = b;                  b &= (b - 1);                  Square s = (Utils.BSFTable[((bb & (0xffffffffffffffff - bb + 1)) * 0x218A392CD3D5DBFUL) >> 58]);  #else                  Square s = Utils.pop_1st_bit(ref b);  #endif                  Debug.Assert(pos.pawn_is_passed(Us' s));                    int r = ((s >> 3) ^ (Us * 7)) - RankC.RANK_2;                  int rr = r * (r - 1);                    // Base bonus based on rank                  Value mbonus = (20 * rr);                  Value ebonus = (10 * (rr + r + 1));                    if (rr != 0)                  {                      Square blockSq = s + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                        // Adjust bonus based on kings proximity                      ebonus += (Utils.SquareDistance[pos.pieceList[Them][PieceTypeC.KING][0]][blockSq] * 5 * rr);                      ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq] * 2 * rr);                        // If blockSq is not the queening square then consider also a second push                      if ((blockSq >> 3) != (Us == ColorC.WHITE ? RankC.RANK_8 : RankC.RANK_1))                      {                          ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)] * rr);                      }                        // If the pawn is free to advance' increase bonus                      if (pos.board[blockSq] == PieceC.NO_PIECE)                      {                          squaresToQueen = Utils.ForwardBB[Us][s];                          defendedSquares = squaresToQueen & ei.attackedBy[Us][0];                            // If there is an enemy rook or queen attacking the pawn from behind'                          // add all X-ray attacks by the rook or queen. Otherwise consider only                          // the squares in the pawn's path attacked or occupied by the enemy.                          if (                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them])) != 0)                              &&                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) & pos.attacks_from_ROOK(s)) != 0)                              )                          {                              unsafeSquares = squaresToQueen;                          }                          else                          {                              unsafeSquares = squaresToQueen & (ei.attackedBy[Them][0] | pos.byColorBB[Them]);                          }                            // If there aren't enemy attacks or pieces along the path to queen give                          // huge bonus. Even bigger if we protect the pawn's path.                          if (unsafeSquares == 0)                              ebonus += (rr * (squaresToQueen == defendedSquares ? 17 : 15));                          else                              // OK' there are enemy attacks or pieces (but not pawns). Are those                              // squares which are attacked by the enemy also attacked by us ?                              // If yes' big bonus (but smaller than when there are no enemy attacks)'                              // if no' somewhat smaller bonus.                              ebonus += (rr * ((unsafeSquares & defendedSquares) == unsafeSquares ? 13 : 8));                      }                  } // rr != 0                    // Increase the bonus if the passed pawn is supported by a friendly pawn                  // on the same rank and a bit smaller if it's on the previous rank.                  supportingPawns = (pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Us]) & Utils.AdjacentFilesBB[s & 7];                  if ((supportingPawns & Utils.RankBB[s >> 3]) != 0)                      ebonus += (r * 20);                  else if ((supportingPawns & Utils.RankBB[(s - (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)) >> 3]) != 0)                      ebonus += (r * 12);                    // Rook pawns are a special case: They are sometimes worse' and                  // sometimes better than other passed pawns. It is difficult to find                  // good rules for determining whether they are good or bad. For now'                  // we try the following: Increase the value for rook pawns if the                  // other side has no pieces apart from a knight' and decrease the                  // value if the other side has a rook or queen.                  if ((s & 7) == FileC.FILE_A || (s & 7) == FileC.FILE_H)                  {                      if ((Them == 0 ? pos.st.npMaterialWHITE : pos.st.npMaterialBLACK) <= Constants.KnightValueMidgame)                          ebonus += ebonus / 4;                      else if (((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) != 0)                          ebonus -= ebonus / 4;                  }                  score += ((mbonus << 16) + ebonus);                } while (b != 0);
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_passed_pawns,The following statement contains a magic number: do              {  #if X64                  Bitboard bb = b;                  b &= (b - 1);                  Square s = (Utils.BSFTable[((bb & (0xffffffffffffffff - bb + 1)) * 0x218A392CD3D5DBFUL) >> 58]);  #else                  Square s = Utils.pop_1st_bit(ref b);  #endif                  Debug.Assert(pos.pawn_is_passed(Us' s));                    int r = ((s >> 3) ^ (Us * 7)) - RankC.RANK_2;                  int rr = r * (r - 1);                    // Base bonus based on rank                  Value mbonus = (20 * rr);                  Value ebonus = (10 * (rr + r + 1));                    if (rr != 0)                  {                      Square blockSq = s + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                        // Adjust bonus based on kings proximity                      ebonus += (Utils.SquareDistance[pos.pieceList[Them][PieceTypeC.KING][0]][blockSq] * 5 * rr);                      ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq] * 2 * rr);                        // If blockSq is not the queening square then consider also a second push                      if ((blockSq >> 3) != (Us == ColorC.WHITE ? RankC.RANK_8 : RankC.RANK_1))                      {                          ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)] * rr);                      }                        // If the pawn is free to advance' increase bonus                      if (pos.board[blockSq] == PieceC.NO_PIECE)                      {                          squaresToQueen = Utils.ForwardBB[Us][s];                          defendedSquares = squaresToQueen & ei.attackedBy[Us][0];                            // If there is an enemy rook or queen attacking the pawn from behind'                          // add all X-ray attacks by the rook or queen. Otherwise consider only                          // the squares in the pawn's path attacked or occupied by the enemy.                          if (                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them])) != 0)                              &&                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) & pos.attacks_from_ROOK(s)) != 0)                              )                          {                              unsafeSquares = squaresToQueen;                          }                          else                          {                              unsafeSquares = squaresToQueen & (ei.attackedBy[Them][0] | pos.byColorBB[Them]);                          }                            // If there aren't enemy attacks or pieces along the path to queen give                          // huge bonus. Even bigger if we protect the pawn's path.                          if (unsafeSquares == 0)                              ebonus += (rr * (squaresToQueen == defendedSquares ? 17 : 15));                          else                              // OK' there are enemy attacks or pieces (but not pawns). Are those                              // squares which are attacked by the enemy also attacked by us ?                              // If yes' big bonus (but smaller than when there are no enemy attacks)'                              // if no' somewhat smaller bonus.                              ebonus += (rr * ((unsafeSquares & defendedSquares) == unsafeSquares ? 13 : 8));                      }                  } // rr != 0                    // Increase the bonus if the passed pawn is supported by a friendly pawn                  // on the same rank and a bit smaller if it's on the previous rank.                  supportingPawns = (pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Us]) & Utils.AdjacentFilesBB[s & 7];                  if ((supportingPawns & Utils.RankBB[s >> 3]) != 0)                      ebonus += (r * 20);                  else if ((supportingPawns & Utils.RankBB[(s - (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)) >> 3]) != 0)                      ebonus += (r * 12);                    // Rook pawns are a special case: They are sometimes worse' and                  // sometimes better than other passed pawns. It is difficult to find                  // good rules for determining whether they are good or bad. For now'                  // we try the following: Increase the value for rook pawns if the                  // other side has no pieces apart from a knight' and decrease the                  // value if the other side has a rook or queen.                  if ((s & 7) == FileC.FILE_A || (s & 7) == FileC.FILE_H)                  {                      if ((Them == 0 ? pos.st.npMaterialWHITE : pos.st.npMaterialBLACK) <= Constants.KnightValueMidgame)                          ebonus += ebonus / 4;                      else if (((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) != 0)                          ebonus -= ebonus / 4;                  }                  score += ((mbonus << 16) + ebonus);                } while (b != 0);
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_passed_pawns,The following statement contains a magic number: do              {  #if X64                  Bitboard bb = b;                  b &= (b - 1);                  Square s = (Utils.BSFTable[((bb & (0xffffffffffffffff - bb + 1)) * 0x218A392CD3D5DBFUL) >> 58]);  #else                  Square s = Utils.pop_1st_bit(ref b);  #endif                  Debug.Assert(pos.pawn_is_passed(Us' s));                    int r = ((s >> 3) ^ (Us * 7)) - RankC.RANK_2;                  int rr = r * (r - 1);                    // Base bonus based on rank                  Value mbonus = (20 * rr);                  Value ebonus = (10 * (rr + r + 1));                    if (rr != 0)                  {                      Square blockSq = s + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                        // Adjust bonus based on kings proximity                      ebonus += (Utils.SquareDistance[pos.pieceList[Them][PieceTypeC.KING][0]][blockSq] * 5 * rr);                      ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq] * 2 * rr);                        // If blockSq is not the queening square then consider also a second push                      if ((blockSq >> 3) != (Us == ColorC.WHITE ? RankC.RANK_8 : RankC.RANK_1))                      {                          ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)] * rr);                      }                        // If the pawn is free to advance' increase bonus                      if (pos.board[blockSq] == PieceC.NO_PIECE)                      {                          squaresToQueen = Utils.ForwardBB[Us][s];                          defendedSquares = squaresToQueen & ei.attackedBy[Us][0];                            // If there is an enemy rook or queen attacking the pawn from behind'                          // add all X-ray attacks by the rook or queen. Otherwise consider only                          // the squares in the pawn's path attacked or occupied by the enemy.                          if (                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them])) != 0)                              &&                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) & pos.attacks_from_ROOK(s)) != 0)                              )                          {                              unsafeSquares = squaresToQueen;                          }                          else                          {                              unsafeSquares = squaresToQueen & (ei.attackedBy[Them][0] | pos.byColorBB[Them]);                          }                            // If there aren't enemy attacks or pieces along the path to queen give                          // huge bonus. Even bigger if we protect the pawn's path.                          if (unsafeSquares == 0)                              ebonus += (rr * (squaresToQueen == defendedSquares ? 17 : 15));                          else                              // OK' there are enemy attacks or pieces (but not pawns). Are those                              // squares which are attacked by the enemy also attacked by us ?                              // If yes' big bonus (but smaller than when there are no enemy attacks)'                              // if no' somewhat smaller bonus.                              ebonus += (rr * ((unsafeSquares & defendedSquares) == unsafeSquares ? 13 : 8));                      }                  } // rr != 0                    // Increase the bonus if the passed pawn is supported by a friendly pawn                  // on the same rank and a bit smaller if it's on the previous rank.                  supportingPawns = (pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Us]) & Utils.AdjacentFilesBB[s & 7];                  if ((supportingPawns & Utils.RankBB[s >> 3]) != 0)                      ebonus += (r * 20);                  else if ((supportingPawns & Utils.RankBB[(s - (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)) >> 3]) != 0)                      ebonus += (r * 12);                    // Rook pawns are a special case: They are sometimes worse' and                  // sometimes better than other passed pawns. It is difficult to find                  // good rules for determining whether they are good or bad. For now'                  // we try the following: Increase the value for rook pawns if the                  // other side has no pieces apart from a knight' and decrease the                  // value if the other side has a rook or queen.                  if ((s & 7) == FileC.FILE_A || (s & 7) == FileC.FILE_H)                  {                      if ((Them == 0 ? pos.st.npMaterialWHITE : pos.st.npMaterialBLACK) <= Constants.KnightValueMidgame)                          ebonus += ebonus / 4;                      else if (((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) != 0)                          ebonus -= ebonus / 4;                  }                  score += ((mbonus << 16) + ebonus);                } while (b != 0);
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_passed_pawns,The following statement contains a magic number: do              {  #if X64                  Bitboard bb = b;                  b &= (b - 1);                  Square s = (Utils.BSFTable[((bb & (0xffffffffffffffff - bb + 1)) * 0x218A392CD3D5DBFUL) >> 58]);  #else                  Square s = Utils.pop_1st_bit(ref b);  #endif                  Debug.Assert(pos.pawn_is_passed(Us' s));                    int r = ((s >> 3) ^ (Us * 7)) - RankC.RANK_2;                  int rr = r * (r - 1);                    // Base bonus based on rank                  Value mbonus = (20 * rr);                  Value ebonus = (10 * (rr + r + 1));                    if (rr != 0)                  {                      Square blockSq = s + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                        // Adjust bonus based on kings proximity                      ebonus += (Utils.SquareDistance[pos.pieceList[Them][PieceTypeC.KING][0]][blockSq] * 5 * rr);                      ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq] * 2 * rr);                        // If blockSq is not the queening square then consider also a second push                      if ((blockSq >> 3) != (Us == ColorC.WHITE ? RankC.RANK_8 : RankC.RANK_1))                      {                          ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)] * rr);                      }                        // If the pawn is free to advance' increase bonus                      if (pos.board[blockSq] == PieceC.NO_PIECE)                      {                          squaresToQueen = Utils.ForwardBB[Us][s];                          defendedSquares = squaresToQueen & ei.attackedBy[Us][0];                            // If there is an enemy rook or queen attacking the pawn from behind'                          // add all X-ray attacks by the rook or queen. Otherwise consider only                          // the squares in the pawn's path attacked or occupied by the enemy.                          if (                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them])) != 0)                              &&                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) & pos.attacks_from_ROOK(s)) != 0)                              )                          {                              unsafeSquares = squaresToQueen;                          }                          else                          {                              unsafeSquares = squaresToQueen & (ei.attackedBy[Them][0] | pos.byColorBB[Them]);                          }                            // If there aren't enemy attacks or pieces along the path to queen give                          // huge bonus. Even bigger if we protect the pawn's path.                          if (unsafeSquares == 0)                              ebonus += (rr * (squaresToQueen == defendedSquares ? 17 : 15));                          else                              // OK' there are enemy attacks or pieces (but not pawns). Are those                              // squares which are attacked by the enemy also attacked by us ?                              // If yes' big bonus (but smaller than when there are no enemy attacks)'                              // if no' somewhat smaller bonus.                              ebonus += (rr * ((unsafeSquares & defendedSquares) == unsafeSquares ? 13 : 8));                      }                  } // rr != 0                    // Increase the bonus if the passed pawn is supported by a friendly pawn                  // on the same rank and a bit smaller if it's on the previous rank.                  supportingPawns = (pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Us]) & Utils.AdjacentFilesBB[s & 7];                  if ((supportingPawns & Utils.RankBB[s >> 3]) != 0)                      ebonus += (r * 20);                  else if ((supportingPawns & Utils.RankBB[(s - (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)) >> 3]) != 0)                      ebonus += (r * 12);                    // Rook pawns are a special case: They are sometimes worse' and                  // sometimes better than other passed pawns. It is difficult to find                  // good rules for determining whether they are good or bad. For now'                  // we try the following: Increase the value for rook pawns if the                  // other side has no pieces apart from a knight' and decrease the                  // value if the other side has a rook or queen.                  if ((s & 7) == FileC.FILE_A || (s & 7) == FileC.FILE_H)                  {                      if ((Them == 0 ? pos.st.npMaterialWHITE : pos.st.npMaterialBLACK) <= Constants.KnightValueMidgame)                          ebonus += ebonus / 4;                      else if (((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) != 0)                          ebonus -= ebonus / 4;                  }                  score += ((mbonus << 16) + ebonus);                } while (b != 0);
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_passed_pawns,The following statement contains a magic number: do              {  #if X64                  Bitboard bb = b;                  b &= (b - 1);                  Square s = (Utils.BSFTable[((bb & (0xffffffffffffffff - bb + 1)) * 0x218A392CD3D5DBFUL) >> 58]);  #else                  Square s = Utils.pop_1st_bit(ref b);  #endif                  Debug.Assert(pos.pawn_is_passed(Us' s));                    int r = ((s >> 3) ^ (Us * 7)) - RankC.RANK_2;                  int rr = r * (r - 1);                    // Base bonus based on rank                  Value mbonus = (20 * rr);                  Value ebonus = (10 * (rr + r + 1));                    if (rr != 0)                  {                      Square blockSq = s + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                        // Adjust bonus based on kings proximity                      ebonus += (Utils.SquareDistance[pos.pieceList[Them][PieceTypeC.KING][0]][blockSq] * 5 * rr);                      ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq] * 2 * rr);                        // If blockSq is not the queening square then consider also a second push                      if ((blockSq >> 3) != (Us == ColorC.WHITE ? RankC.RANK_8 : RankC.RANK_1))                      {                          ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)] * rr);                      }                        // If the pawn is free to advance' increase bonus                      if (pos.board[blockSq] == PieceC.NO_PIECE)                      {                          squaresToQueen = Utils.ForwardBB[Us][s];                          defendedSquares = squaresToQueen & ei.attackedBy[Us][0];                            // If there is an enemy rook or queen attacking the pawn from behind'                          // add all X-ray attacks by the rook or queen. Otherwise consider only                          // the squares in the pawn's path attacked or occupied by the enemy.                          if (                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them])) != 0)                              &&                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) & pos.attacks_from_ROOK(s)) != 0)                              )                          {                              unsafeSquares = squaresToQueen;                          }                          else                          {                              unsafeSquares = squaresToQueen & (ei.attackedBy[Them][0] | pos.byColorBB[Them]);                          }                            // If there aren't enemy attacks or pieces along the path to queen give                          // huge bonus. Even bigger if we protect the pawn's path.                          if (unsafeSquares == 0)                              ebonus += (rr * (squaresToQueen == defendedSquares ? 17 : 15));                          else                              // OK' there are enemy attacks or pieces (but not pawns). Are those                              // squares which are attacked by the enemy also attacked by us ?                              // If yes' big bonus (but smaller than when there are no enemy attacks)'                              // if no' somewhat smaller bonus.                              ebonus += (rr * ((unsafeSquares & defendedSquares) == unsafeSquares ? 13 : 8));                      }                  } // rr != 0                    // Increase the bonus if the passed pawn is supported by a friendly pawn                  // on the same rank and a bit smaller if it's on the previous rank.                  supportingPawns = (pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Us]) & Utils.AdjacentFilesBB[s & 7];                  if ((supportingPawns & Utils.RankBB[s >> 3]) != 0)                      ebonus += (r * 20);                  else if ((supportingPawns & Utils.RankBB[(s - (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)) >> 3]) != 0)                      ebonus += (r * 12);                    // Rook pawns are a special case: They are sometimes worse' and                  // sometimes better than other passed pawns. It is difficult to find                  // good rules for determining whether they are good or bad. For now'                  // we try the following: Increase the value for rook pawns if the                  // other side has no pieces apart from a knight' and decrease the                  // value if the other side has a rook or queen.                  if ((s & 7) == FileC.FILE_A || (s & 7) == FileC.FILE_H)                  {                      if ((Them == 0 ? pos.st.npMaterialWHITE : pos.st.npMaterialBLACK) <= Constants.KnightValueMidgame)                          ebonus += ebonus / 4;                      else if (((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) != 0)                          ebonus -= ebonus / 4;                  }                  score += ((mbonus << 16) + ebonus);                } while (b != 0);
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_passed_pawns,The following statement contains a magic number: do              {  #if X64                  Bitboard bb = b;                  b &= (b - 1);                  Square s = (Utils.BSFTable[((bb & (0xffffffffffffffff - bb + 1)) * 0x218A392CD3D5DBFUL) >> 58]);  #else                  Square s = Utils.pop_1st_bit(ref b);  #endif                  Debug.Assert(pos.pawn_is_passed(Us' s));                    int r = ((s >> 3) ^ (Us * 7)) - RankC.RANK_2;                  int rr = r * (r - 1);                    // Base bonus based on rank                  Value mbonus = (20 * rr);                  Value ebonus = (10 * (rr + r + 1));                    if (rr != 0)                  {                      Square blockSq = s + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                        // Adjust bonus based on kings proximity                      ebonus += (Utils.SquareDistance[pos.pieceList[Them][PieceTypeC.KING][0]][blockSq] * 5 * rr);                      ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq] * 2 * rr);                        // If blockSq is not the queening square then consider also a second push                      if ((blockSq >> 3) != (Us == ColorC.WHITE ? RankC.RANK_8 : RankC.RANK_1))                      {                          ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)] * rr);                      }                        // If the pawn is free to advance' increase bonus                      if (pos.board[blockSq] == PieceC.NO_PIECE)                      {                          squaresToQueen = Utils.ForwardBB[Us][s];                          defendedSquares = squaresToQueen & ei.attackedBy[Us][0];                            // If there is an enemy rook or queen attacking the pawn from behind'                          // add all X-ray attacks by the rook or queen. Otherwise consider only                          // the squares in the pawn's path attacked or occupied by the enemy.                          if (                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them])) != 0)                              &&                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) & pos.attacks_from_ROOK(s)) != 0)                              )                          {                              unsafeSquares = squaresToQueen;                          }                          else                          {                              unsafeSquares = squaresToQueen & (ei.attackedBy[Them][0] | pos.byColorBB[Them]);                          }                            // If there aren't enemy attacks or pieces along the path to queen give                          // huge bonus. Even bigger if we protect the pawn's path.                          if (unsafeSquares == 0)                              ebonus += (rr * (squaresToQueen == defendedSquares ? 17 : 15));                          else                              // OK' there are enemy attacks or pieces (but not pawns). Are those                              // squares which are attacked by the enemy also attacked by us ?                              // If yes' big bonus (but smaller than when there are no enemy attacks)'                              // if no' somewhat smaller bonus.                              ebonus += (rr * ((unsafeSquares & defendedSquares) == unsafeSquares ? 13 : 8));                      }                  } // rr != 0                    // Increase the bonus if the passed pawn is supported by a friendly pawn                  // on the same rank and a bit smaller if it's on the previous rank.                  supportingPawns = (pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Us]) & Utils.AdjacentFilesBB[s & 7];                  if ((supportingPawns & Utils.RankBB[s >> 3]) != 0)                      ebonus += (r * 20);                  else if ((supportingPawns & Utils.RankBB[(s - (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)) >> 3]) != 0)                      ebonus += (r * 12);                    // Rook pawns are a special case: They are sometimes worse' and                  // sometimes better than other passed pawns. It is difficult to find                  // good rules for determining whether they are good or bad. For now'                  // we try the following: Increase the value for rook pawns if the                  // other side has no pieces apart from a knight' and decrease the                  // value if the other side has a rook or queen.                  if ((s & 7) == FileC.FILE_A || (s & 7) == FileC.FILE_H)                  {                      if ((Them == 0 ? pos.st.npMaterialWHITE : pos.st.npMaterialBLACK) <= Constants.KnightValueMidgame)                          ebonus += ebonus / 4;                      else if (((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) != 0)                          ebonus -= ebonus / 4;                  }                  score += ((mbonus << 16) + ebonus);                } while (b != 0);
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_passed_pawns,The following statement contains a magic number: do              {  #if X64                  Bitboard bb = b;                  b &= (b - 1);                  Square s = (Utils.BSFTable[((bb & (0xffffffffffffffff - bb + 1)) * 0x218A392CD3D5DBFUL) >> 58]);  #else                  Square s = Utils.pop_1st_bit(ref b);  #endif                  Debug.Assert(pos.pawn_is_passed(Us' s));                    int r = ((s >> 3) ^ (Us * 7)) - RankC.RANK_2;                  int rr = r * (r - 1);                    // Base bonus based on rank                  Value mbonus = (20 * rr);                  Value ebonus = (10 * (rr + r + 1));                    if (rr != 0)                  {                      Square blockSq = s + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                        // Adjust bonus based on kings proximity                      ebonus += (Utils.SquareDistance[pos.pieceList[Them][PieceTypeC.KING][0]][blockSq] * 5 * rr);                      ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq] * 2 * rr);                        // If blockSq is not the queening square then consider also a second push                      if ((blockSq >> 3) != (Us == ColorC.WHITE ? RankC.RANK_8 : RankC.RANK_1))                      {                          ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)] * rr);                      }                        // If the pawn is free to advance' increase bonus                      if (pos.board[blockSq] == PieceC.NO_PIECE)                      {                          squaresToQueen = Utils.ForwardBB[Us][s];                          defendedSquares = squaresToQueen & ei.attackedBy[Us][0];                            // If there is an enemy rook or queen attacking the pawn from behind'                          // add all X-ray attacks by the rook or queen. Otherwise consider only                          // the squares in the pawn's path attacked or occupied by the enemy.                          if (                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them])) != 0)                              &&                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) & pos.attacks_from_ROOK(s)) != 0)                              )                          {                              unsafeSquares = squaresToQueen;                          }                          else                          {                              unsafeSquares = squaresToQueen & (ei.attackedBy[Them][0] | pos.byColorBB[Them]);                          }                            // If there aren't enemy attacks or pieces along the path to queen give                          // huge bonus. Even bigger if we protect the pawn's path.                          if (unsafeSquares == 0)                              ebonus += (rr * (squaresToQueen == defendedSquares ? 17 : 15));                          else                              // OK' there are enemy attacks or pieces (but not pawns). Are those                              // squares which are attacked by the enemy also attacked by us ?                              // If yes' big bonus (but smaller than when there are no enemy attacks)'                              // if no' somewhat smaller bonus.                              ebonus += (rr * ((unsafeSquares & defendedSquares) == unsafeSquares ? 13 : 8));                      }                  } // rr != 0                    // Increase the bonus if the passed pawn is supported by a friendly pawn                  // on the same rank and a bit smaller if it's on the previous rank.                  supportingPawns = (pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Us]) & Utils.AdjacentFilesBB[s & 7];                  if ((supportingPawns & Utils.RankBB[s >> 3]) != 0)                      ebonus += (r * 20);                  else if ((supportingPawns & Utils.RankBB[(s - (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)) >> 3]) != 0)                      ebonus += (r * 12);                    // Rook pawns are a special case: They are sometimes worse' and                  // sometimes better than other passed pawns. It is difficult to find                  // good rules for determining whether they are good or bad. For now'                  // we try the following: Increase the value for rook pawns if the                  // other side has no pieces apart from a knight' and decrease the                  // value if the other side has a rook or queen.                  if ((s & 7) == FileC.FILE_A || (s & 7) == FileC.FILE_H)                  {                      if ((Them == 0 ? pos.st.npMaterialWHITE : pos.st.npMaterialBLACK) <= Constants.KnightValueMidgame)                          ebonus += ebonus / 4;                      else if (((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) != 0)                          ebonus -= ebonus / 4;                  }                  score += ((mbonus << 16) + ebonus);                } while (b != 0);
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_passed_pawns,The following statement contains a magic number: do              {  #if X64                  Bitboard bb = b;                  b &= (b - 1);                  Square s = (Utils.BSFTable[((bb & (0xffffffffffffffff - bb + 1)) * 0x218A392CD3D5DBFUL) >> 58]);  #else                  Square s = Utils.pop_1st_bit(ref b);  #endif                  Debug.Assert(pos.pawn_is_passed(Us' s));                    int r = ((s >> 3) ^ (Us * 7)) - RankC.RANK_2;                  int rr = r * (r - 1);                    // Base bonus based on rank                  Value mbonus = (20 * rr);                  Value ebonus = (10 * (rr + r + 1));                    if (rr != 0)                  {                      Square blockSq = s + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                        // Adjust bonus based on kings proximity                      ebonus += (Utils.SquareDistance[pos.pieceList[Them][PieceTypeC.KING][0]][blockSq] * 5 * rr);                      ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq] * 2 * rr);                        // If blockSq is not the queening square then consider also a second push                      if ((blockSq >> 3) != (Us == ColorC.WHITE ? RankC.RANK_8 : RankC.RANK_1))                      {                          ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)] * rr);                      }                        // If the pawn is free to advance' increase bonus                      if (pos.board[blockSq] == PieceC.NO_PIECE)                      {                          squaresToQueen = Utils.ForwardBB[Us][s];                          defendedSquares = squaresToQueen & ei.attackedBy[Us][0];                            // If there is an enemy rook or queen attacking the pawn from behind'                          // add all X-ray attacks by the rook or queen. Otherwise consider only                          // the squares in the pawn's path attacked or occupied by the enemy.                          if (                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them])) != 0)                              &&                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) & pos.attacks_from_ROOK(s)) != 0)                              )                          {                              unsafeSquares = squaresToQueen;                          }                          else                          {                              unsafeSquares = squaresToQueen & (ei.attackedBy[Them][0] | pos.byColorBB[Them]);                          }                            // If there aren't enemy attacks or pieces along the path to queen give                          // huge bonus. Even bigger if we protect the pawn's path.                          if (unsafeSquares == 0)                              ebonus += (rr * (squaresToQueen == defendedSquares ? 17 : 15));                          else                              // OK' there are enemy attacks or pieces (but not pawns). Are those                              // squares which are attacked by the enemy also attacked by us ?                              // If yes' big bonus (but smaller than when there are no enemy attacks)'                              // if no' somewhat smaller bonus.                              ebonus += (rr * ((unsafeSquares & defendedSquares) == unsafeSquares ? 13 : 8));                      }                  } // rr != 0                    // Increase the bonus if the passed pawn is supported by a friendly pawn                  // on the same rank and a bit smaller if it's on the previous rank.                  supportingPawns = (pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Us]) & Utils.AdjacentFilesBB[s & 7];                  if ((supportingPawns & Utils.RankBB[s >> 3]) != 0)                      ebonus += (r * 20);                  else if ((supportingPawns & Utils.RankBB[(s - (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)) >> 3]) != 0)                      ebonus += (r * 12);                    // Rook pawns are a special case: They are sometimes worse' and                  // sometimes better than other passed pawns. It is difficult to find                  // good rules for determining whether they are good or bad. For now'                  // we try the following: Increase the value for rook pawns if the                  // other side has no pieces apart from a knight' and decrease the                  // value if the other side has a rook or queen.                  if ((s & 7) == FileC.FILE_A || (s & 7) == FileC.FILE_H)                  {                      if ((Them == 0 ? pos.st.npMaterialWHITE : pos.st.npMaterialBLACK) <= Constants.KnightValueMidgame)                          ebonus += ebonus / 4;                      else if (((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) != 0)                          ebonus -= ebonus / 4;                  }                  score += ((mbonus << 16) + ebonus);                } while (b != 0);
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_passed_pawns,The following statement contains a magic number: do              {  #if X64                  Bitboard bb = b;                  b &= (b - 1);                  Square s = (Utils.BSFTable[((bb & (0xffffffffffffffff - bb + 1)) * 0x218A392CD3D5DBFUL) >> 58]);  #else                  Square s = Utils.pop_1st_bit(ref b);  #endif                  Debug.Assert(pos.pawn_is_passed(Us' s));                    int r = ((s >> 3) ^ (Us * 7)) - RankC.RANK_2;                  int rr = r * (r - 1);                    // Base bonus based on rank                  Value mbonus = (20 * rr);                  Value ebonus = (10 * (rr + r + 1));                    if (rr != 0)                  {                      Square blockSq = s + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                        // Adjust bonus based on kings proximity                      ebonus += (Utils.SquareDistance[pos.pieceList[Them][PieceTypeC.KING][0]][blockSq] * 5 * rr);                      ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq] * 2 * rr);                        // If blockSq is not the queening square then consider also a second push                      if ((blockSq >> 3) != (Us == ColorC.WHITE ? RankC.RANK_8 : RankC.RANK_1))                      {                          ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)] * rr);                      }                        // If the pawn is free to advance' increase bonus                      if (pos.board[blockSq] == PieceC.NO_PIECE)                      {                          squaresToQueen = Utils.ForwardBB[Us][s];                          defendedSquares = squaresToQueen & ei.attackedBy[Us][0];                            // If there is an enemy rook or queen attacking the pawn from behind'                          // add all X-ray attacks by the rook or queen. Otherwise consider only                          // the squares in the pawn's path attacked or occupied by the enemy.                          if (                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them])) != 0)                              &&                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) & pos.attacks_from_ROOK(s)) != 0)                              )                          {                              unsafeSquares = squaresToQueen;                          }                          else                          {                              unsafeSquares = squaresToQueen & (ei.attackedBy[Them][0] | pos.byColorBB[Them]);                          }                            // If there aren't enemy attacks or pieces along the path to queen give                          // huge bonus. Even bigger if we protect the pawn's path.                          if (unsafeSquares == 0)                              ebonus += (rr * (squaresToQueen == defendedSquares ? 17 : 15));                          else                              // OK' there are enemy attacks or pieces (but not pawns). Are those                              // squares which are attacked by the enemy also attacked by us ?                              // If yes' big bonus (but smaller than when there are no enemy attacks)'                              // if no' somewhat smaller bonus.                              ebonus += (rr * ((unsafeSquares & defendedSquares) == unsafeSquares ? 13 : 8));                      }                  } // rr != 0                    // Increase the bonus if the passed pawn is supported by a friendly pawn                  // on the same rank and a bit smaller if it's on the previous rank.                  supportingPawns = (pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Us]) & Utils.AdjacentFilesBB[s & 7];                  if ((supportingPawns & Utils.RankBB[s >> 3]) != 0)                      ebonus += (r * 20);                  else if ((supportingPawns & Utils.RankBB[(s - (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)) >> 3]) != 0)                      ebonus += (r * 12);                    // Rook pawns are a special case: They are sometimes worse' and                  // sometimes better than other passed pawns. It is difficult to find                  // good rules for determining whether they are good or bad. For now'                  // we try the following: Increase the value for rook pawns if the                  // other side has no pieces apart from a knight' and decrease the                  // value if the other side has a rook or queen.                  if ((s & 7) == FileC.FILE_A || (s & 7) == FileC.FILE_H)                  {                      if ((Them == 0 ? pos.st.npMaterialWHITE : pos.st.npMaterialBLACK) <= Constants.KnightValueMidgame)                          ebonus += ebonus / 4;                      else if (((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) != 0)                          ebonus -= ebonus / 4;                  }                  score += ((mbonus << 16) + ebonus);                } while (b != 0);
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_passed_pawns,The following statement contains a magic number: do              {  #if X64                  Bitboard bb = b;                  b &= (b - 1);                  Square s = (Utils.BSFTable[((bb & (0xffffffffffffffff - bb + 1)) * 0x218A392CD3D5DBFUL) >> 58]);  #else                  Square s = Utils.pop_1st_bit(ref b);  #endif                  Debug.Assert(pos.pawn_is_passed(Us' s));                    int r = ((s >> 3) ^ (Us * 7)) - RankC.RANK_2;                  int rr = r * (r - 1);                    // Base bonus based on rank                  Value mbonus = (20 * rr);                  Value ebonus = (10 * (rr + r + 1));                    if (rr != 0)                  {                      Square blockSq = s + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                        // Adjust bonus based on kings proximity                      ebonus += (Utils.SquareDistance[pos.pieceList[Them][PieceTypeC.KING][0]][blockSq] * 5 * rr);                      ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq] * 2 * rr);                        // If blockSq is not the queening square then consider also a second push                      if ((blockSq >> 3) != (Us == ColorC.WHITE ? RankC.RANK_8 : RankC.RANK_1))                      {                          ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)] * rr);                      }                        // If the pawn is free to advance' increase bonus                      if (pos.board[blockSq] == PieceC.NO_PIECE)                      {                          squaresToQueen = Utils.ForwardBB[Us][s];                          defendedSquares = squaresToQueen & ei.attackedBy[Us][0];                            // If there is an enemy rook or queen attacking the pawn from behind'                          // add all X-ray attacks by the rook or queen. Otherwise consider only                          // the squares in the pawn's path attacked or occupied by the enemy.                          if (                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them])) != 0)                              &&                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) & pos.attacks_from_ROOK(s)) != 0)                              )                          {                              unsafeSquares = squaresToQueen;                          }                          else                          {                              unsafeSquares = squaresToQueen & (ei.attackedBy[Them][0] | pos.byColorBB[Them]);                          }                            // If there aren't enemy attacks or pieces along the path to queen give                          // huge bonus. Even bigger if we protect the pawn's path.                          if (unsafeSquares == 0)                              ebonus += (rr * (squaresToQueen == defendedSquares ? 17 : 15));                          else                              // OK' there are enemy attacks or pieces (but not pawns). Are those                              // squares which are attacked by the enemy also attacked by us ?                              // If yes' big bonus (but smaller than when there are no enemy attacks)'                              // if no' somewhat smaller bonus.                              ebonus += (rr * ((unsafeSquares & defendedSquares) == unsafeSquares ? 13 : 8));                      }                  } // rr != 0                    // Increase the bonus if the passed pawn is supported by a friendly pawn                  // on the same rank and a bit smaller if it's on the previous rank.                  supportingPawns = (pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Us]) & Utils.AdjacentFilesBB[s & 7];                  if ((supportingPawns & Utils.RankBB[s >> 3]) != 0)                      ebonus += (r * 20);                  else if ((supportingPawns & Utils.RankBB[(s - (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)) >> 3]) != 0)                      ebonus += (r * 12);                    // Rook pawns are a special case: They are sometimes worse' and                  // sometimes better than other passed pawns. It is difficult to find                  // good rules for determining whether they are good or bad. For now'                  // we try the following: Increase the value for rook pawns if the                  // other side has no pieces apart from a knight' and decrease the                  // value if the other side has a rook or queen.                  if ((s & 7) == FileC.FILE_A || (s & 7) == FileC.FILE_H)                  {                      if ((Them == 0 ? pos.st.npMaterialWHITE : pos.st.npMaterialBLACK) <= Constants.KnightValueMidgame)                          ebonus += ebonus / 4;                      else if (((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) != 0)                          ebonus -= ebonus / 4;                  }                  score += ((mbonus << 16) + ebonus);                } while (b != 0);
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_passed_pawns,The following statement contains a magic number: do              {  #if X64                  Bitboard bb = b;                  b &= (b - 1);                  Square s = (Utils.BSFTable[((bb & (0xffffffffffffffff - bb + 1)) * 0x218A392CD3D5DBFUL) >> 58]);  #else                  Square s = Utils.pop_1st_bit(ref b);  #endif                  Debug.Assert(pos.pawn_is_passed(Us' s));                    int r = ((s >> 3) ^ (Us * 7)) - RankC.RANK_2;                  int rr = r * (r - 1);                    // Base bonus based on rank                  Value mbonus = (20 * rr);                  Value ebonus = (10 * (rr + r + 1));                    if (rr != 0)                  {                      Square blockSq = s + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                        // Adjust bonus based on kings proximity                      ebonus += (Utils.SquareDistance[pos.pieceList[Them][PieceTypeC.KING][0]][blockSq] * 5 * rr);                      ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq] * 2 * rr);                        // If blockSq is not the queening square then consider also a second push                      if ((blockSq >> 3) != (Us == ColorC.WHITE ? RankC.RANK_8 : RankC.RANK_1))                      {                          ebonus -= (Utils.SquareDistance[pos.pieceList[Us][PieceTypeC.KING][0]][blockSq + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)] * rr);                      }                        // If the pawn is free to advance' increase bonus                      if (pos.board[blockSq] == PieceC.NO_PIECE)                      {                          squaresToQueen = Utils.ForwardBB[Us][s];                          defendedSquares = squaresToQueen & ei.attackedBy[Us][0];                            // If there is an enemy rook or queen attacking the pawn from behind'                          // add all X-ray attacks by the rook or queen. Otherwise consider only                          // the squares in the pawn's path attacked or occupied by the enemy.                          if (                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them])) != 0)                              &&                              ((Utils.ForwardBB[Them][s] & ((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) & pos.attacks_from_ROOK(s)) != 0)                              )                          {                              unsafeSquares = squaresToQueen;                          }                          else                          {                              unsafeSquares = squaresToQueen & (ei.attackedBy[Them][0] | pos.byColorBB[Them]);                          }                            // If there aren't enemy attacks or pieces along the path to queen give                          // huge bonus. Even bigger if we protect the pawn's path.                          if (unsafeSquares == 0)                              ebonus += (rr * (squaresToQueen == defendedSquares ? 17 : 15));                          else                              // OK' there are enemy attacks or pieces (but not pawns). Are those                              // squares which are attacked by the enemy also attacked by us ?                              // If yes' big bonus (but smaller than when there are no enemy attacks)'                              // if no' somewhat smaller bonus.                              ebonus += (rr * ((unsafeSquares & defendedSquares) == unsafeSquares ? 13 : 8));                      }                  } // rr != 0                    // Increase the bonus if the passed pawn is supported by a friendly pawn                  // on the same rank and a bit smaller if it's on the previous rank.                  supportingPawns = (pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[Us]) & Utils.AdjacentFilesBB[s & 7];                  if ((supportingPawns & Utils.RankBB[s >> 3]) != 0)                      ebonus += (r * 20);                  else if ((supportingPawns & Utils.RankBB[(s - (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)) >> 3]) != 0)                      ebonus += (r * 12);                    // Rook pawns are a special case: They are sometimes worse' and                  // sometimes better than other passed pawns. It is difficult to find                  // good rules for determining whether they are good or bad. For now'                  // we try the following: Increase the value for rook pawns if the                  // other side has no pieces apart from a knight' and decrease the                  // value if the other side has a rook or queen.                  if ((s & 7) == FileC.FILE_A || (s & 7) == FileC.FILE_H)                  {                      if ((Them == 0 ? pos.st.npMaterialWHITE : pos.st.npMaterialBLACK) <= Constants.KnightValueMidgame)                          ebonus += ebonus / 4;                      else if (((pos.byTypeBB[PieceTypeC.ROOK] | pos.byTypeBB[PieceTypeC.QUEEN]) & pos.byColorBB[Them]) != 0)                          ebonus -= ebonus / 4;                  }                  score += ((mbonus << 16) + ebonus);                } while (b != 0);
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_unstoppable_pawns,The following statement contains a magic number: int pliesToQueenWHITE = 256' pliesToQueenBLACK = 256' pliesToQueenWinner = 256;
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_unstoppable_pawns,The following statement contains a magic number: int pliesToQueenWHITE = 256' pliesToQueenBLACK = 256' pliesToQueenWinner = 256;
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_unstoppable_pawns,The following statement contains a magic number: int pliesToQueenWHITE = 256' pliesToQueenBLACK = 256' pliesToQueenWinner = 256;
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_unstoppable_pawns,The following statement contains a magic number: for (c = ColorC.WHITE; c <= ColorC.BLACK; c++)              {                  // Skip if other side has non-pawn pieces                  if (pos.non_pawn_material(Utils.flip_C(c)) != 0)                      continue;                    b = ei.pi.passed_pawns(c);                    while (b != 0)                  {                      s = Utils.pop_1st_bit(ref b);                      queeningSquare = Utils.relative_square(c' Utils.make_square(Utils.file_of(s)' RankC.RANK_8));                      queeningPath = Utils.forward_bb(c' s);                        // Compute plies to queening and check direct advancement                      movesToGo = Utils.rank_distance(s' queeningSquare) - (Utils.relative_rank_CS(c' s) == RankC.RANK_2 ? 1 : 0);                      oppMovesToGo = Utils.square_distance(pos.king_square(Utils.flip_C(c))' queeningSquare) - ((c != pos.sideToMove) ? 1 : 0);                      pathDefended = ((ei.attackedBy[c][0] & queeningPath) == queeningPath);                        if (movesToGo >= oppMovesToGo && !pathDefended)                          continue;                        // Opponent king cannot block because path is defended and position                      // is not in check. So only friendly pieces can be blockers.                      Debug.Assert(!pos.in_check());                      Debug.Assert((queeningPath & pos.occupied_squares) == (queeningPath & pos.pieces_C(c)));                        // Add moves needed to free the path from friendly pieces and retest condition                      movesToGo += Bitcount.popcount_1s_Max15(queeningPath & pos.pieces_C(c));                        if (movesToGo >= oppMovesToGo && !pathDefended)                          continue;                        pliesToGo = 2 * movesToGo - ((c == pos.sideToMove) ? 1 : 0);                        if (c == ColorC.WHITE)                      {                          pliesToQueenWHITE = Math.Min(pliesToQueenWHITE' pliesToGo);                      }                      else                      {                          pliesToQueenBLACK = Math.Min(pliesToQueenBLACK' pliesToGo);                      }                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_unstoppable_pawns,The following statement contains a magic number: if (Math.Abs(pliesToQueenWHITE - pliesToQueenBLACK) < 3)                  return ScoreC.SCORE_ZERO;
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_unstoppable_pawns,The following statement contains a magic number: while (b != 0)              {                  s = Utils.pop_1st_bit(ref b);                    // Compute plies from queening                  queeningSquare = Utils.relative_square(loserSide' Utils.make_square(Utils.file_of(s)' RankC.RANK_8));                  movesToGo = Utils.rank_distance(s' queeningSquare) - ((Utils.relative_rank_CS(loserSide' s) == RankC.RANK_2) ? 1 : 0);                  pliesToGo = 2 * movesToGo - ((loserSide == pos.sideToMove) ? 1 : 0);                    // Check if (without even considering any obstacles) we're too far away or doubled                  if (                      (pliesToQueenWinner + 3 <= pliesToGo)                      ||                      ((Utils.forward_bb(loserSide' s) & pos.pieces_PTC(PieceTypeC.PAWN' loserSide)) != 0)                      )                  {                      Utils.xor_bit(ref candidates' s);                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_unstoppable_pawns,The following statement contains a magic number: while (b != 0)              {                  s = Utils.pop_1st_bit(ref b);                    // Compute plies from queening                  queeningSquare = Utils.relative_square(loserSide' Utils.make_square(Utils.file_of(s)' RankC.RANK_8));                  movesToGo = Utils.rank_distance(s' queeningSquare) - ((Utils.relative_rank_CS(loserSide' s) == RankC.RANK_2) ? 1 : 0);                  pliesToGo = 2 * movesToGo - ((loserSide == pos.sideToMove) ? 1 : 0);                    // Check if (without even considering any obstacles) we're too far away or doubled                  if (                      (pliesToQueenWinner + 3 <= pliesToGo)                      ||                      ((Utils.forward_bb(loserSide' s) & pos.pieces_PTC(PieceTypeC.PAWN' loserSide)) != 0)                      )                  {                      Utils.xor_bit(ref candidates' s);                  }              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_unstoppable_pawns,The following statement contains a magic number: while (b != 0)              {                  s = Utils.pop_1st_bit(ref b);                  sacptg = blockersCount = 0;                  minKingDist = kingptg = 256;                    // Compute plies from queening                  queeningSquare = Utils.relative_square(loserSide' Utils.make_square(Utils.file_of(s)' RankC.RANK_8));                  movesToGo = Utils.rank_distance(s' queeningSquare) - ((Utils.relative_rank_CS(loserSide' s) == RankC.RANK_2) ? 1 : 0);                  pliesToGo = 2 * movesToGo - ((loserSide == pos.sideToMove) ? 1 : 0);                    // Generate list of blocking pawns and supporters                  supporters = Utils.adjacent_files_bb(Utils.file_of(s)) & candidates;                  opposed = (Utils.forward_bb(loserSide' s) & pos.pieces_PTC(PieceTypeC.PAWN' winnerSide)) != 0;                  blockers = Utils.passed_pawn_mask(loserSide' s) & pos.pieces_PTC(PieceTypeC.PAWN' winnerSide);                    Debug.Assert(blockers != 0);                    // How many plies does it take to remove all the blocking pawns?                  while (blockers != 0)                  {                      blockSq = Utils.pop_1st_bit(ref blockers);                      movesToGo = 256;                        // Check pawns that can give support to overcome obstacle' for instance                      // black pawns: a4' b4 white: b2 then pawn in b4 is giving support.                      if (!opposed)                      {                          b2 = supporters & Utils.in_front_bb_CS(winnerSide' blockSq + Utils.pawn_push(winnerSide));                            while (b2 != 0) // This while-loop could be replaced with LSB/MSB (depending on color)                          {                              d = Utils.square_distance(blockSq' Utils.pop_1st_bit(ref b2)) - 2;                              movesToGo = Math.Min(movesToGo' d);                          }                      }                        // Check pawns that can be sacrificed against the blocking pawn                      b2 = Utils.attack_span_mask(winnerSide' blockSq) & candidates & ~(1UL << s);                        while (b2 != 0) // This while-loop could be replaced with LSB/MSB (depending on color)                      {                          d = Utils.square_distance(blockSq' Utils.pop_1st_bit(ref b2)) - 2;                          movesToGo = Math.Min(movesToGo' d);                      }                        // If obstacle can be destroyed with an immediate pawn exchange / sacrifice'                      // it's not a real obstacle and we have nothing to add to pliesToGo.                      if (movesToGo <= 0)                          continue;                        // Plies needed to sacrifice against all the blocking pawns                      sacptg += movesToGo * 2;                      blockersCount++;                        // Plies needed for the king to capture all the blocking pawns                      d = Utils.square_distance(pos.king_square(loserSide)' blockSq);                      minKingDist = Math.Min(minKingDist' d);                      kingptg = (minKingDist + blockersCount) * 2;                  }                    // Check if pawn sacrifice plan _may_ save the day                  if (pliesToQueenWinner + 3 > pliesToGo + sacptg)                      return ScoreC.SCORE_ZERO;                    // Check if king capture plan _may_ save the day (contains some false positives)                  if (pliesToQueenWinner + 3 > pliesToGo + kingptg)                      return ScoreC.SCORE_ZERO;              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_unstoppable_pawns,The following statement contains a magic number: while (b != 0)              {                  s = Utils.pop_1st_bit(ref b);                  sacptg = blockersCount = 0;                  minKingDist = kingptg = 256;                    // Compute plies from queening                  queeningSquare = Utils.relative_square(loserSide' Utils.make_square(Utils.file_of(s)' RankC.RANK_8));                  movesToGo = Utils.rank_distance(s' queeningSquare) - ((Utils.relative_rank_CS(loserSide' s) == RankC.RANK_2) ? 1 : 0);                  pliesToGo = 2 * movesToGo - ((loserSide == pos.sideToMove) ? 1 : 0);                    // Generate list of blocking pawns and supporters                  supporters = Utils.adjacent_files_bb(Utils.file_of(s)) & candidates;                  opposed = (Utils.forward_bb(loserSide' s) & pos.pieces_PTC(PieceTypeC.PAWN' winnerSide)) != 0;                  blockers = Utils.passed_pawn_mask(loserSide' s) & pos.pieces_PTC(PieceTypeC.PAWN' winnerSide);                    Debug.Assert(blockers != 0);                    // How many plies does it take to remove all the blocking pawns?                  while (blockers != 0)                  {                      blockSq = Utils.pop_1st_bit(ref blockers);                      movesToGo = 256;                        // Check pawns that can give support to overcome obstacle' for instance                      // black pawns: a4' b4 white: b2 then pawn in b4 is giving support.                      if (!opposed)                      {                          b2 = supporters & Utils.in_front_bb_CS(winnerSide' blockSq + Utils.pawn_push(winnerSide));                            while (b2 != 0) // This while-loop could be replaced with LSB/MSB (depending on color)                          {                              d = Utils.square_distance(blockSq' Utils.pop_1st_bit(ref b2)) - 2;                              movesToGo = Math.Min(movesToGo' d);                          }                      }                        // Check pawns that can be sacrificed against the blocking pawn                      b2 = Utils.attack_span_mask(winnerSide' blockSq) & candidates & ~(1UL << s);                        while (b2 != 0) // This while-loop could be replaced with LSB/MSB (depending on color)                      {                          d = Utils.square_distance(blockSq' Utils.pop_1st_bit(ref b2)) - 2;                          movesToGo = Math.Min(movesToGo' d);                      }                        // If obstacle can be destroyed with an immediate pawn exchange / sacrifice'                      // it's not a real obstacle and we have nothing to add to pliesToGo.                      if (movesToGo <= 0)                          continue;                        // Plies needed to sacrifice against all the blocking pawns                      sacptg += movesToGo * 2;                      blockersCount++;                        // Plies needed for the king to capture all the blocking pawns                      d = Utils.square_distance(pos.king_square(loserSide)' blockSq);                      minKingDist = Math.Min(minKingDist' d);                      kingptg = (minKingDist + blockersCount) * 2;                  }                    // Check if pawn sacrifice plan _may_ save the day                  if (pliesToQueenWinner + 3 > pliesToGo + sacptg)                      return ScoreC.SCORE_ZERO;                    // Check if king capture plan _may_ save the day (contains some false positives)                  if (pliesToQueenWinner + 3 > pliesToGo + kingptg)                      return ScoreC.SCORE_ZERO;              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_unstoppable_pawns,The following statement contains a magic number: while (b != 0)              {                  s = Utils.pop_1st_bit(ref b);                  sacptg = blockersCount = 0;                  minKingDist = kingptg = 256;                    // Compute plies from queening                  queeningSquare = Utils.relative_square(loserSide' Utils.make_square(Utils.file_of(s)' RankC.RANK_8));                  movesToGo = Utils.rank_distance(s' queeningSquare) - ((Utils.relative_rank_CS(loserSide' s) == RankC.RANK_2) ? 1 : 0);                  pliesToGo = 2 * movesToGo - ((loserSide == pos.sideToMove) ? 1 : 0);                    // Generate list of blocking pawns and supporters                  supporters = Utils.adjacent_files_bb(Utils.file_of(s)) & candidates;                  opposed = (Utils.forward_bb(loserSide' s) & pos.pieces_PTC(PieceTypeC.PAWN' winnerSide)) != 0;                  blockers = Utils.passed_pawn_mask(loserSide' s) & pos.pieces_PTC(PieceTypeC.PAWN' winnerSide);                    Debug.Assert(blockers != 0);                    // How many plies does it take to remove all the blocking pawns?                  while (blockers != 0)                  {                      blockSq = Utils.pop_1st_bit(ref blockers);                      movesToGo = 256;                        // Check pawns that can give support to overcome obstacle' for instance                      // black pawns: a4' b4 white: b2 then pawn in b4 is giving support.                      if (!opposed)                      {                          b2 = supporters & Utils.in_front_bb_CS(winnerSide' blockSq + Utils.pawn_push(winnerSide));                            while (b2 != 0) // This while-loop could be replaced with LSB/MSB (depending on color)                          {                              d = Utils.square_distance(blockSq' Utils.pop_1st_bit(ref b2)) - 2;                              movesToGo = Math.Min(movesToGo' d);                          }                      }                        // Check pawns that can be sacrificed against the blocking pawn                      b2 = Utils.attack_span_mask(winnerSide' blockSq) & candidates & ~(1UL << s);                        while (b2 != 0) // This while-loop could be replaced with LSB/MSB (depending on color)                      {                          d = Utils.square_distance(blockSq' Utils.pop_1st_bit(ref b2)) - 2;                          movesToGo = Math.Min(movesToGo' d);                      }                        // If obstacle can be destroyed with an immediate pawn exchange / sacrifice'                      // it's not a real obstacle and we have nothing to add to pliesToGo.                      if (movesToGo <= 0)                          continue;                        // Plies needed to sacrifice against all the blocking pawns                      sacptg += movesToGo * 2;                      blockersCount++;                        // Plies needed for the king to capture all the blocking pawns                      d = Utils.square_distance(pos.king_square(loserSide)' blockSq);                      minKingDist = Math.Min(minKingDist' d);                      kingptg = (minKingDist + blockersCount) * 2;                  }                    // Check if pawn sacrifice plan _may_ save the day                  if (pliesToQueenWinner + 3 > pliesToGo + sacptg)                      return ScoreC.SCORE_ZERO;                    // Check if king capture plan _may_ save the day (contains some false positives)                  if (pliesToQueenWinner + 3 > pliesToGo + kingptg)                      return ScoreC.SCORE_ZERO;              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_unstoppable_pawns,The following statement contains a magic number: while (b != 0)              {                  s = Utils.pop_1st_bit(ref b);                  sacptg = blockersCount = 0;                  minKingDist = kingptg = 256;                    // Compute plies from queening                  queeningSquare = Utils.relative_square(loserSide' Utils.make_square(Utils.file_of(s)' RankC.RANK_8));                  movesToGo = Utils.rank_distance(s' queeningSquare) - ((Utils.relative_rank_CS(loserSide' s) == RankC.RANK_2) ? 1 : 0);                  pliesToGo = 2 * movesToGo - ((loserSide == pos.sideToMove) ? 1 : 0);                    // Generate list of blocking pawns and supporters                  supporters = Utils.adjacent_files_bb(Utils.file_of(s)) & candidates;                  opposed = (Utils.forward_bb(loserSide' s) & pos.pieces_PTC(PieceTypeC.PAWN' winnerSide)) != 0;                  blockers = Utils.passed_pawn_mask(loserSide' s) & pos.pieces_PTC(PieceTypeC.PAWN' winnerSide);                    Debug.Assert(blockers != 0);                    // How many plies does it take to remove all the blocking pawns?                  while (blockers != 0)                  {                      blockSq = Utils.pop_1st_bit(ref blockers);                      movesToGo = 256;                        // Check pawns that can give support to overcome obstacle' for instance                      // black pawns: a4' b4 white: b2 then pawn in b4 is giving support.                      if (!opposed)                      {                          b2 = supporters & Utils.in_front_bb_CS(winnerSide' blockSq + Utils.pawn_push(winnerSide));                            while (b2 != 0) // This while-loop could be replaced with LSB/MSB (depending on color)                          {                              d = Utils.square_distance(blockSq' Utils.pop_1st_bit(ref b2)) - 2;                              movesToGo = Math.Min(movesToGo' d);                          }                      }                        // Check pawns that can be sacrificed against the blocking pawn                      b2 = Utils.attack_span_mask(winnerSide' blockSq) & candidates & ~(1UL << s);                        while (b2 != 0) // This while-loop could be replaced with LSB/MSB (depending on color)                      {                          d = Utils.square_distance(blockSq' Utils.pop_1st_bit(ref b2)) - 2;                          movesToGo = Math.Min(movesToGo' d);                      }                        // If obstacle can be destroyed with an immediate pawn exchange / sacrifice'                      // it's not a real obstacle and we have nothing to add to pliesToGo.                      if (movesToGo <= 0)                          continue;                        // Plies needed to sacrifice against all the blocking pawns                      sacptg += movesToGo * 2;                      blockersCount++;                        // Plies needed for the king to capture all the blocking pawns                      d = Utils.square_distance(pos.king_square(loserSide)' blockSq);                      minKingDist = Math.Min(minKingDist' d);                      kingptg = (minKingDist + blockersCount) * 2;                  }                    // Check if pawn sacrifice plan _may_ save the day                  if (pliesToQueenWinner + 3 > pliesToGo + sacptg)                      return ScoreC.SCORE_ZERO;                    // Check if king capture plan _may_ save the day (contains some false positives)                  if (pliesToQueenWinner + 3 > pliesToGo + kingptg)                      return ScoreC.SCORE_ZERO;              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_unstoppable_pawns,The following statement contains a magic number: while (b != 0)              {                  s = Utils.pop_1st_bit(ref b);                  sacptg = blockersCount = 0;                  minKingDist = kingptg = 256;                    // Compute plies from queening                  queeningSquare = Utils.relative_square(loserSide' Utils.make_square(Utils.file_of(s)' RankC.RANK_8));                  movesToGo = Utils.rank_distance(s' queeningSquare) - ((Utils.relative_rank_CS(loserSide' s) == RankC.RANK_2) ? 1 : 0);                  pliesToGo = 2 * movesToGo - ((loserSide == pos.sideToMove) ? 1 : 0);                    // Generate list of blocking pawns and supporters                  supporters = Utils.adjacent_files_bb(Utils.file_of(s)) & candidates;                  opposed = (Utils.forward_bb(loserSide' s) & pos.pieces_PTC(PieceTypeC.PAWN' winnerSide)) != 0;                  blockers = Utils.passed_pawn_mask(loserSide' s) & pos.pieces_PTC(PieceTypeC.PAWN' winnerSide);                    Debug.Assert(blockers != 0);                    // How many plies does it take to remove all the blocking pawns?                  while (blockers != 0)                  {                      blockSq = Utils.pop_1st_bit(ref blockers);                      movesToGo = 256;                        // Check pawns that can give support to overcome obstacle' for instance                      // black pawns: a4' b4 white: b2 then pawn in b4 is giving support.                      if (!opposed)                      {                          b2 = supporters & Utils.in_front_bb_CS(winnerSide' blockSq + Utils.pawn_push(winnerSide));                            while (b2 != 0) // This while-loop could be replaced with LSB/MSB (depending on color)                          {                              d = Utils.square_distance(blockSq' Utils.pop_1st_bit(ref b2)) - 2;                              movesToGo = Math.Min(movesToGo' d);                          }                      }                        // Check pawns that can be sacrificed against the blocking pawn                      b2 = Utils.attack_span_mask(winnerSide' blockSq) & candidates & ~(1UL << s);                        while (b2 != 0) // This while-loop could be replaced with LSB/MSB (depending on color)                      {                          d = Utils.square_distance(blockSq' Utils.pop_1st_bit(ref b2)) - 2;                          movesToGo = Math.Min(movesToGo' d);                      }                        // If obstacle can be destroyed with an immediate pawn exchange / sacrifice'                      // it's not a real obstacle and we have nothing to add to pliesToGo.                      if (movesToGo <= 0)                          continue;                        // Plies needed to sacrifice against all the blocking pawns                      sacptg += movesToGo * 2;                      blockersCount++;                        // Plies needed for the king to capture all the blocking pawns                      d = Utils.square_distance(pos.king_square(loserSide)' blockSq);                      minKingDist = Math.Min(minKingDist' d);                      kingptg = (minKingDist + blockersCount) * 2;                  }                    // Check if pawn sacrifice plan _may_ save the day                  if (pliesToQueenWinner + 3 > pliesToGo + sacptg)                      return ScoreC.SCORE_ZERO;                    // Check if king capture plan _may_ save the day (contains some false positives)                  if (pliesToQueenWinner + 3 > pliesToGo + kingptg)                      return ScoreC.SCORE_ZERO;              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_unstoppable_pawns,The following statement contains a magic number: while (b != 0)              {                  s = Utils.pop_1st_bit(ref b);                  sacptg = blockersCount = 0;                  minKingDist = kingptg = 256;                    // Compute plies from queening                  queeningSquare = Utils.relative_square(loserSide' Utils.make_square(Utils.file_of(s)' RankC.RANK_8));                  movesToGo = Utils.rank_distance(s' queeningSquare) - ((Utils.relative_rank_CS(loserSide' s) == RankC.RANK_2) ? 1 : 0);                  pliesToGo = 2 * movesToGo - ((loserSide == pos.sideToMove) ? 1 : 0);                    // Generate list of blocking pawns and supporters                  supporters = Utils.adjacent_files_bb(Utils.file_of(s)) & candidates;                  opposed = (Utils.forward_bb(loserSide' s) & pos.pieces_PTC(PieceTypeC.PAWN' winnerSide)) != 0;                  blockers = Utils.passed_pawn_mask(loserSide' s) & pos.pieces_PTC(PieceTypeC.PAWN' winnerSide);                    Debug.Assert(blockers != 0);                    // How many plies does it take to remove all the blocking pawns?                  while (blockers != 0)                  {                      blockSq = Utils.pop_1st_bit(ref blockers);                      movesToGo = 256;                        // Check pawns that can give support to overcome obstacle' for instance                      // black pawns: a4' b4 white: b2 then pawn in b4 is giving support.                      if (!opposed)                      {                          b2 = supporters & Utils.in_front_bb_CS(winnerSide' blockSq + Utils.pawn_push(winnerSide));                            while (b2 != 0) // This while-loop could be replaced with LSB/MSB (depending on color)                          {                              d = Utils.square_distance(blockSq' Utils.pop_1st_bit(ref b2)) - 2;                              movesToGo = Math.Min(movesToGo' d);                          }                      }                        // Check pawns that can be sacrificed against the blocking pawn                      b2 = Utils.attack_span_mask(winnerSide' blockSq) & candidates & ~(1UL << s);                        while (b2 != 0) // This while-loop could be replaced with LSB/MSB (depending on color)                      {                          d = Utils.square_distance(blockSq' Utils.pop_1st_bit(ref b2)) - 2;                          movesToGo = Math.Min(movesToGo' d);                      }                        // If obstacle can be destroyed with an immediate pawn exchange / sacrifice'                      // it's not a real obstacle and we have nothing to add to pliesToGo.                      if (movesToGo <= 0)                          continue;                        // Plies needed to sacrifice against all the blocking pawns                      sacptg += movesToGo * 2;                      blockersCount++;                        // Plies needed for the king to capture all the blocking pawns                      d = Utils.square_distance(pos.king_square(loserSide)' blockSq);                      minKingDist = Math.Min(minKingDist' d);                      kingptg = (minKingDist + blockersCount) * 2;                  }                    // Check if pawn sacrifice plan _may_ save the day                  if (pliesToQueenWinner + 3 > pliesToGo + sacptg)                      return ScoreC.SCORE_ZERO;                    // Check if king capture plan _may_ save the day (contains some false positives)                  if (pliesToQueenWinner + 3 > pliesToGo + kingptg)                      return ScoreC.SCORE_ZERO;              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_unstoppable_pawns,The following statement contains a magic number: while (b != 0)              {                  s = Utils.pop_1st_bit(ref b);                  sacptg = blockersCount = 0;                  minKingDist = kingptg = 256;                    // Compute plies from queening                  queeningSquare = Utils.relative_square(loserSide' Utils.make_square(Utils.file_of(s)' RankC.RANK_8));                  movesToGo = Utils.rank_distance(s' queeningSquare) - ((Utils.relative_rank_CS(loserSide' s) == RankC.RANK_2) ? 1 : 0);                  pliesToGo = 2 * movesToGo - ((loserSide == pos.sideToMove) ? 1 : 0);                    // Generate list of blocking pawns and supporters                  supporters = Utils.adjacent_files_bb(Utils.file_of(s)) & candidates;                  opposed = (Utils.forward_bb(loserSide' s) & pos.pieces_PTC(PieceTypeC.PAWN' winnerSide)) != 0;                  blockers = Utils.passed_pawn_mask(loserSide' s) & pos.pieces_PTC(PieceTypeC.PAWN' winnerSide);                    Debug.Assert(blockers != 0);                    // How many plies does it take to remove all the blocking pawns?                  while (blockers != 0)                  {                      blockSq = Utils.pop_1st_bit(ref blockers);                      movesToGo = 256;                        // Check pawns that can give support to overcome obstacle' for instance                      // black pawns: a4' b4 white: b2 then pawn in b4 is giving support.                      if (!opposed)                      {                          b2 = supporters & Utils.in_front_bb_CS(winnerSide' blockSq + Utils.pawn_push(winnerSide));                            while (b2 != 0) // This while-loop could be replaced with LSB/MSB (depending on color)                          {                              d = Utils.square_distance(blockSq' Utils.pop_1st_bit(ref b2)) - 2;                              movesToGo = Math.Min(movesToGo' d);                          }                      }                        // Check pawns that can be sacrificed against the blocking pawn                      b2 = Utils.attack_span_mask(winnerSide' blockSq) & candidates & ~(1UL << s);                        while (b2 != 0) // This while-loop could be replaced with LSB/MSB (depending on color)                      {                          d = Utils.square_distance(blockSq' Utils.pop_1st_bit(ref b2)) - 2;                          movesToGo = Math.Min(movesToGo' d);                      }                        // If obstacle can be destroyed with an immediate pawn exchange / sacrifice'                      // it's not a real obstacle and we have nothing to add to pliesToGo.                      if (movesToGo <= 0)                          continue;                        // Plies needed to sacrifice against all the blocking pawns                      sacptg += movesToGo * 2;                      blockersCount++;                        // Plies needed for the king to capture all the blocking pawns                      d = Utils.square_distance(pos.king_square(loserSide)' blockSq);                      minKingDist = Math.Min(minKingDist' d);                      kingptg = (minKingDist + blockersCount) * 2;                  }                    // Check if pawn sacrifice plan _may_ save the day                  if (pliesToQueenWinner + 3 > pliesToGo + sacptg)                      return ScoreC.SCORE_ZERO;                    // Check if king capture plan _may_ save the day (contains some false positives)                  if (pliesToQueenWinner + 3 > pliesToGo + kingptg)                      return ScoreC.SCORE_ZERO;              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_unstoppable_pawns,The following statement contains a magic number: while (b != 0)              {                  s = Utils.pop_1st_bit(ref b);                  sacptg = blockersCount = 0;                  minKingDist = kingptg = 256;                    // Compute plies from queening                  queeningSquare = Utils.relative_square(loserSide' Utils.make_square(Utils.file_of(s)' RankC.RANK_8));                  movesToGo = Utils.rank_distance(s' queeningSquare) - ((Utils.relative_rank_CS(loserSide' s) == RankC.RANK_2) ? 1 : 0);                  pliesToGo = 2 * movesToGo - ((loserSide == pos.sideToMove) ? 1 : 0);                    // Generate list of blocking pawns and supporters                  supporters = Utils.adjacent_files_bb(Utils.file_of(s)) & candidates;                  opposed = (Utils.forward_bb(loserSide' s) & pos.pieces_PTC(PieceTypeC.PAWN' winnerSide)) != 0;                  blockers = Utils.passed_pawn_mask(loserSide' s) & pos.pieces_PTC(PieceTypeC.PAWN' winnerSide);                    Debug.Assert(blockers != 0);                    // How many plies does it take to remove all the blocking pawns?                  while (blockers != 0)                  {                      blockSq = Utils.pop_1st_bit(ref blockers);                      movesToGo = 256;                        // Check pawns that can give support to overcome obstacle' for instance                      // black pawns: a4' b4 white: b2 then pawn in b4 is giving support.                      if (!opposed)                      {                          b2 = supporters & Utils.in_front_bb_CS(winnerSide' blockSq + Utils.pawn_push(winnerSide));                            while (b2 != 0) // This while-loop could be replaced with LSB/MSB (depending on color)                          {                              d = Utils.square_distance(blockSq' Utils.pop_1st_bit(ref b2)) - 2;                              movesToGo = Math.Min(movesToGo' d);                          }                      }                        // Check pawns that can be sacrificed against the blocking pawn                      b2 = Utils.attack_span_mask(winnerSide' blockSq) & candidates & ~(1UL << s);                        while (b2 != 0) // This while-loop could be replaced with LSB/MSB (depending on color)                      {                          d = Utils.square_distance(blockSq' Utils.pop_1st_bit(ref b2)) - 2;                          movesToGo = Math.Min(movesToGo' d);                      }                        // If obstacle can be destroyed with an immediate pawn exchange / sacrifice'                      // it's not a real obstacle and we have nothing to add to pliesToGo.                      if (movesToGo <= 0)                          continue;                        // Plies needed to sacrifice against all the blocking pawns                      sacptg += movesToGo * 2;                      blockersCount++;                        // Plies needed for the king to capture all the blocking pawns                      d = Utils.square_distance(pos.king_square(loserSide)' blockSq);                      minKingDist = Math.Min(minKingDist' d);                      kingptg = (minKingDist + blockersCount) * 2;                  }                    // Check if pawn sacrifice plan _may_ save the day                  if (pliesToQueenWinner + 3 > pliesToGo + sacptg)                      return ScoreC.SCORE_ZERO;                    // Check if king capture plan _may_ save the day (contains some false positives)                  if (pliesToQueenWinner + 3 > pliesToGo + kingptg)                      return ScoreC.SCORE_ZERO;              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_unstoppable_pawns,The following statement contains a magic number: while (b != 0)              {                  s = Utils.pop_1st_bit(ref b);                  sacptg = blockersCount = 0;                  minKingDist = kingptg = 256;                    // Compute plies from queening                  queeningSquare = Utils.relative_square(loserSide' Utils.make_square(Utils.file_of(s)' RankC.RANK_8));                  movesToGo = Utils.rank_distance(s' queeningSquare) - ((Utils.relative_rank_CS(loserSide' s) == RankC.RANK_2) ? 1 : 0);                  pliesToGo = 2 * movesToGo - ((loserSide == pos.sideToMove) ? 1 : 0);                    // Generate list of blocking pawns and supporters                  supporters = Utils.adjacent_files_bb(Utils.file_of(s)) & candidates;                  opposed = (Utils.forward_bb(loserSide' s) & pos.pieces_PTC(PieceTypeC.PAWN' winnerSide)) != 0;                  blockers = Utils.passed_pawn_mask(loserSide' s) & pos.pieces_PTC(PieceTypeC.PAWN' winnerSide);                    Debug.Assert(blockers != 0);                    // How many plies does it take to remove all the blocking pawns?                  while (blockers != 0)                  {                      blockSq = Utils.pop_1st_bit(ref blockers);                      movesToGo = 256;                        // Check pawns that can give support to overcome obstacle' for instance                      // black pawns: a4' b4 white: b2 then pawn in b4 is giving support.                      if (!opposed)                      {                          b2 = supporters & Utils.in_front_bb_CS(winnerSide' blockSq + Utils.pawn_push(winnerSide));                            while (b2 != 0) // This while-loop could be replaced with LSB/MSB (depending on color)                          {                              d = Utils.square_distance(blockSq' Utils.pop_1st_bit(ref b2)) - 2;                              movesToGo = Math.Min(movesToGo' d);                          }                      }                        // Check pawns that can be sacrificed against the blocking pawn                      b2 = Utils.attack_span_mask(winnerSide' blockSq) & candidates & ~(1UL << s);                        while (b2 != 0) // This while-loop could be replaced with LSB/MSB (depending on color)                      {                          d = Utils.square_distance(blockSq' Utils.pop_1st_bit(ref b2)) - 2;                          movesToGo = Math.Min(movesToGo' d);                      }                        // If obstacle can be destroyed with an immediate pawn exchange / sacrifice'                      // it's not a real obstacle and we have nothing to add to pliesToGo.                      if (movesToGo <= 0)                          continue;                        // Plies needed to sacrifice against all the blocking pawns                      sacptg += movesToGo * 2;                      blockersCount++;                        // Plies needed for the king to capture all the blocking pawns                      d = Utils.square_distance(pos.king_square(loserSide)' blockSq);                      minKingDist = Math.Min(minKingDist' d);                      kingptg = (minKingDist + blockersCount) * 2;                  }                    // Check if pawn sacrifice plan _may_ save the day                  if (pliesToQueenWinner + 3 > pliesToGo + sacptg)                      return ScoreC.SCORE_ZERO;                    // Check if king capture plan _may_ save the day (contains some false positives)                  if (pliesToQueenWinner + 3 > pliesToGo + kingptg)                      return ScoreC.SCORE_ZERO;              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_space,The following statement contains a magic number: behind |= (Us == ColorC.WHITE ? behind >> 8 : behind << 8);
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_space,The following statement contains a magic number: behind |= (Us == ColorC.WHITE ? behind >> 8 : behind << 8);
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_space,The following statement contains a magic number: behind |= (Us == ColorC.WHITE ? behind >> 16 : behind << 16);
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,evaluate_space,The following statement contains a magic number: behind |= (Us == ColorC.WHITE ? behind >> 16 : behind << 16);
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,weight_option,The following statement contains a magic number: int mg = int.Parse(OptionMap.Instance[mgOpt].v) * 256 / 100;
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,weight_option,The following statement contains a magic number: int mg = int.Parse(OptionMap.Instance[mgOpt].v) * 256 / 100;
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,weight_option,The following statement contains a magic number: int eg = int.Parse(OptionMap.Instance[egOpt].v) * 256 / 100;
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,weight_option,The following statement contains a magic number: int eg = int.Parse(OptionMap.Instance[egOpt].v) * 256 / 100;
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,trace_row,The following statement contains a magic number: switch (idx)              {                  case TracedTypeC.PST:                  case TracedTypeC.IMBALANCE:                  case PieceTypeC.PAWN:                  case TracedTypeC.UNSTOPPABLE:                  case TracedTypeC.TOTAL:                      TraceStream.Append(name.PadLeft(20' ' '));                      TraceStream.Append(" |   ---   --- |   ---   --- | ");                      TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(wScore))' 6' true));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(wScore))' 6' true));                      TraceStream.Append(" \n");                      break;                  default:                      TraceStream.Append(name.PadLeft(20' ' '));                      TraceStream.Append(" | ");                      TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(wScore))' 5' false));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(wScore))' 5' false));                      TraceStream.Append(" | ");                      TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(bScore))' 5' false));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(bScore))' 5' false));                      TraceStream.Append(" | ");                        TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(wScore - bScore))' 6' true));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(wScore - bScore))' 6' true));                      TraceStream.Append(" \n");                      break;              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,trace_row,The following statement contains a magic number: switch (idx)              {                  case TracedTypeC.PST:                  case TracedTypeC.IMBALANCE:                  case PieceTypeC.PAWN:                  case TracedTypeC.UNSTOPPABLE:                  case TracedTypeC.TOTAL:                      TraceStream.Append(name.PadLeft(20' ' '));                      TraceStream.Append(" |   ---   --- |   ---   --- | ");                      TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(wScore))' 6' true));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(wScore))' 6' true));                      TraceStream.Append(" \n");                      break;                  default:                      TraceStream.Append(name.PadLeft(20' ' '));                      TraceStream.Append(" | ");                      TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(wScore))' 5' false));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(wScore))' 5' false));                      TraceStream.Append(" | ");                      TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(bScore))' 5' false));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(bScore))' 5' false));                      TraceStream.Append(" | ");                        TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(wScore - bScore))' 6' true));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(wScore - bScore))' 6' true));                      TraceStream.Append(" \n");                      break;              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,trace_row,The following statement contains a magic number: switch (idx)              {                  case TracedTypeC.PST:                  case TracedTypeC.IMBALANCE:                  case PieceTypeC.PAWN:                  case TracedTypeC.UNSTOPPABLE:                  case TracedTypeC.TOTAL:                      TraceStream.Append(name.PadLeft(20' ' '));                      TraceStream.Append(" |   ---   --- |   ---   --- | ");                      TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(wScore))' 6' true));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(wScore))' 6' true));                      TraceStream.Append(" \n");                      break;                  default:                      TraceStream.Append(name.PadLeft(20' ' '));                      TraceStream.Append(" | ");                      TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(wScore))' 5' false));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(wScore))' 5' false));                      TraceStream.Append(" | ");                      TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(bScore))' 5' false));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(bScore))' 5' false));                      TraceStream.Append(" | ");                        TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(wScore - bScore))' 6' true));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(wScore - bScore))' 6' true));                      TraceStream.Append(" \n");                      break;              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,trace_row,The following statement contains a magic number: switch (idx)              {                  case TracedTypeC.PST:                  case TracedTypeC.IMBALANCE:                  case PieceTypeC.PAWN:                  case TracedTypeC.UNSTOPPABLE:                  case TracedTypeC.TOTAL:                      TraceStream.Append(name.PadLeft(20' ' '));                      TraceStream.Append(" |   ---   --- |   ---   --- | ");                      TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(wScore))' 6' true));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(wScore))' 6' true));                      TraceStream.Append(" \n");                      break;                  default:                      TraceStream.Append(name.PadLeft(20' ' '));                      TraceStream.Append(" | ");                      TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(wScore))' 5' false));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(wScore))' 5' false));                      TraceStream.Append(" | ");                      TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(bScore))' 5' false));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(bScore))' 5' false));                      TraceStream.Append(" | ");                        TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(wScore - bScore))' 6' true));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(wScore - bScore))' 6' true));                      TraceStream.Append(" \n");                      break;              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,trace_row,The following statement contains a magic number: switch (idx)              {                  case TracedTypeC.PST:                  case TracedTypeC.IMBALANCE:                  case PieceTypeC.PAWN:                  case TracedTypeC.UNSTOPPABLE:                  case TracedTypeC.TOTAL:                      TraceStream.Append(name.PadLeft(20' ' '));                      TraceStream.Append(" |   ---   --- |   ---   --- | ");                      TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(wScore))' 6' true));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(wScore))' 6' true));                      TraceStream.Append(" \n");                      break;                  default:                      TraceStream.Append(name.PadLeft(20' ' '));                      TraceStream.Append(" | ");                      TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(wScore))' 5' false));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(wScore))' 5' false));                      TraceStream.Append(" | ");                      TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(bScore))' 5' false));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(bScore))' 5' false));                      TraceStream.Append(" | ");                        TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(wScore - bScore))' 6' true));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(wScore - bScore))' 6' true));                      TraceStream.Append(" \n");                      break;              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,trace_row,The following statement contains a magic number: switch (idx)              {                  case TracedTypeC.PST:                  case TracedTypeC.IMBALANCE:                  case PieceTypeC.PAWN:                  case TracedTypeC.UNSTOPPABLE:                  case TracedTypeC.TOTAL:                      TraceStream.Append(name.PadLeft(20' ' '));                      TraceStream.Append(" |   ---   --- |   ---   --- | ");                      TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(wScore))' 6' true));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(wScore))' 6' true));                      TraceStream.Append(" \n");                      break;                  default:                      TraceStream.Append(name.PadLeft(20' ' '));                      TraceStream.Append(" | ");                      TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(wScore))' 5' false));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(wScore))' 5' false));                      TraceStream.Append(" | ");                      TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(bScore))' 5' false));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(bScore))' 5' false));                      TraceStream.Append(" | ");                        TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(wScore - bScore))' 6' true));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(wScore - bScore))' 6' true));                      TraceStream.Append(" \n");                      break;              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,trace_row,The following statement contains a magic number: switch (idx)              {                  case TracedTypeC.PST:                  case TracedTypeC.IMBALANCE:                  case PieceTypeC.PAWN:                  case TracedTypeC.UNSTOPPABLE:                  case TracedTypeC.TOTAL:                      TraceStream.Append(name.PadLeft(20' ' '));                      TraceStream.Append(" |   ---   --- |   ---   --- | ");                      TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(wScore))' 6' true));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(wScore))' 6' true));                      TraceStream.Append(" \n");                      break;                  default:                      TraceStream.Append(name.PadLeft(20' ' '));                      TraceStream.Append(" | ");                      TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(wScore))' 5' false));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(wScore))' 5' false));                      TraceStream.Append(" | ");                      TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(bScore))' 5' false));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(bScore))' 5' false));                      TraceStream.Append(" | ");                        TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(wScore - bScore))' 6' true));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(wScore - bScore))' 6' true));                      TraceStream.Append(" \n");                      break;              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,trace_row,The following statement contains a magic number: switch (idx)              {                  case TracedTypeC.PST:                  case TracedTypeC.IMBALANCE:                  case PieceTypeC.PAWN:                  case TracedTypeC.UNSTOPPABLE:                  case TracedTypeC.TOTAL:                      TraceStream.Append(name.PadLeft(20' ' '));                      TraceStream.Append(" |   ---   --- |   ---   --- | ");                      TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(wScore))' 6' true));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(wScore))' 6' true));                      TraceStream.Append(" \n");                      break;                  default:                      TraceStream.Append(name.PadLeft(20' ' '));                      TraceStream.Append(" | ");                      TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(wScore))' 5' false));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(wScore))' 5' false));                      TraceStream.Append(" | ");                      TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(bScore))' 5' false));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(bScore))' 5' false));                      TraceStream.Append(" | ");                        TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(wScore - bScore))' 6' true));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(wScore - bScore))' 6' true));                      TraceStream.Append(" \n");                      break;              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,trace_row,The following statement contains a magic number: switch (idx)              {                  case TracedTypeC.PST:                  case TracedTypeC.IMBALANCE:                  case PieceTypeC.PAWN:                  case TracedTypeC.UNSTOPPABLE:                  case TracedTypeC.TOTAL:                      TraceStream.Append(name.PadLeft(20' ' '));                      TraceStream.Append(" |   ---   --- |   ---   --- | ");                      TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(wScore))' 6' true));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(wScore))' 6' true));                      TraceStream.Append(" \n");                      break;                  default:                      TraceStream.Append(name.PadLeft(20' ' '));                      TraceStream.Append(" | ");                      TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(wScore))' 5' false));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(wScore))' 5' false));                      TraceStream.Append(" | ");                      TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(bScore))' 5' false));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(bScore))' 5' false));                      TraceStream.Append(" | ");                        TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(wScore - bScore))' 6' true));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(wScore - bScore))' 6' true));                      TraceStream.Append(" \n");                      break;              }
Magic Number,Portfish,Evaluate,C:\repos\bpfliegel_Portfish\src\Evaluate.cs,trace_row,The following statement contains a magic number: switch (idx)              {                  case TracedTypeC.PST:                  case TracedTypeC.IMBALANCE:                  case PieceTypeC.PAWN:                  case TracedTypeC.UNSTOPPABLE:                  case TracedTypeC.TOTAL:                      TraceStream.Append(name.PadLeft(20' ' '));                      TraceStream.Append(" |   ---   --- |   ---   --- | ");                      TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(wScore))' 6' true));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(wScore))' 6' true));                      TraceStream.Append(" \n");                      break;                  default:                      TraceStream.Append(name.PadLeft(20' ' '));                      TraceStream.Append(" | ");                      TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(wScore))' 5' false));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(wScore))' 5' false));                      TraceStream.Append(" | ");                      TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(bScore))' 5' false));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(bScore))' 5' false));                      TraceStream.Append(" | ");                        TraceStream.Append(FormatDouble(to_cp(Utils.mg_value(wScore - bScore))' 6' true));                      TraceStream.Append(" ");                      TraceStream.Append(FormatDouble(to_cp(Utils.eg_value(wScore - bScore))' 6' true));                      TraceStream.Append(" \n");                      break;              }
Magic Number,Portfish,History,C:\repos\bpfliegel_Portfish\src\History.cs,History,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  history[i] = new Value[64];                  maxGains[i] = new Value[64];              }
Magic Number,Portfish,History,C:\repos\bpfliegel_Portfish\src\History.cs,History,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  history[i] = new Value[64];                  maxGains[i] = new Value[64];              }
Magic Number,Portfish,History,C:\repos\bpfliegel_Portfish\src\History.cs,History,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  history[i] = new Value[64];                  maxGains[i] = new Value[64];              }
Magic Number,Portfish,History,C:\repos\bpfliegel_Portfish\src\History.cs,clear,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  Array.Clear(history[i]' 0' 64);                  Array.Clear(maxGains[i]' 0' 64);              }
Magic Number,Portfish,History,C:\repos\bpfliegel_Portfish\src\History.cs,clear,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  Array.Clear(history[i]' 0' 64);                  Array.Clear(maxGains[i]' 0' 64);              }
Magic Number,Portfish,History,C:\repos\bpfliegel_Portfish\src\History.cs,clear,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  Array.Clear(history[i]' 0' 64);                  Array.Clear(maxGains[i]' 0' 64);              }
Magic Number,Portfish,MaterialTable,C:\repos\bpfliegel_Portfish\src\Material.cs,MaterialTable,The following statement contains a magic number: pieceCount[0] = new int[6];
Magic Number,Portfish,MaterialTable,C:\repos\bpfliegel_Portfish\src\Material.cs,MaterialTable,The following statement contains a magic number: pieceCount[1] = new int[6];
Magic Number,Portfish,MaterialTable,C:\repos\bpfliegel_Portfish\src\Material.cs,probe,The following statement contains a magic number: e.gamePhase = npm >= MidgameLimit ? PhaseC.PHASE_MIDGAME                    : npm <= EndgameLimit ? PhaseC.PHASE_ENDGAME                    : (((npm - EndgameLimit) * 128) / (MidgameLimit - EndgameLimit));
Magic Number,Portfish,MaterialTable,C:\repos\bpfliegel_Portfish\src\Material.cs,probe,The following statement contains a magic number: if ((pos.pieces_PT(PieceTypeC.PAWN) == 0) && (pos.pieces_PT(PieceTypeC.ROOK) == 0) && (pos.pieces_PT(PieceTypeC.QUEEN) == 0))              {                  // Minor piece endgame with at least one minor piece per side and                  // no pawns. Note that the case KmmK is already handled by KXK.                  Debug.Assert((pos.pieces_PTC(PieceTypeC.KNIGHT' ColorC.WHITE) | pos.pieces_PTC(PieceTypeC.BISHOP' ColorC.WHITE)) != 0);                  Debug.Assert((pos.pieces_PTC(PieceTypeC.KNIGHT' ColorC.BLACK) | pos.pieces_PTC(PieceTypeC.BISHOP' ColorC.BLACK)) != 0);                    if (pos.piece_count(ColorC.WHITE' PieceTypeC.BISHOP) + pos.piece_count(ColorC.WHITE' PieceTypeC.KNIGHT) <= 2                      && pos.piece_count(ColorC.BLACK' PieceTypeC.BISHOP) + pos.piece_count(ColorC.BLACK' PieceTypeC.KNIGHT) <= 2)                  {                      e.evaluationFunction = Endgame.Endgame_KmmKm;                      e.evaluationFunctionColor = pos.sideToMove;                      return;                  }              }
Magic Number,Portfish,MaterialTable,C:\repos\bpfliegel_Portfish\src\Material.cs,probe,The following statement contains a magic number: if ((pos.pieces_PT(PieceTypeC.PAWN) == 0) && (pos.pieces_PT(PieceTypeC.ROOK) == 0) && (pos.pieces_PT(PieceTypeC.QUEEN) == 0))              {                  // Minor piece endgame with at least one minor piece per side and                  // no pawns. Note that the case KmmK is already handled by KXK.                  Debug.Assert((pos.pieces_PTC(PieceTypeC.KNIGHT' ColorC.WHITE) | pos.pieces_PTC(PieceTypeC.BISHOP' ColorC.WHITE)) != 0);                  Debug.Assert((pos.pieces_PTC(PieceTypeC.KNIGHT' ColorC.BLACK) | pos.pieces_PTC(PieceTypeC.BISHOP' ColorC.BLACK)) != 0);                    if (pos.piece_count(ColorC.WHITE' PieceTypeC.BISHOP) + pos.piece_count(ColorC.WHITE' PieceTypeC.KNIGHT) <= 2                      && pos.piece_count(ColorC.BLACK' PieceTypeC.BISHOP) + pos.piece_count(ColorC.BLACK' PieceTypeC.KNIGHT) <= 2)                  {                      e.evaluationFunction = Endgame.Endgame_KmmKm;                      e.evaluationFunctionColor = pos.sideToMove;                      return;                  }              }
Magic Number,Portfish,MaterialTable,C:\repos\bpfliegel_Portfish\src\Material.cs,probe,The following statement contains a magic number: if (npm_w + npm_b == ValueC.VALUE_ZERO)              {                  if (pos.piece_count(ColorC.BLACK' PieceTypeC.PAWN) == 0)                  {                      Debug.Assert(pos.piece_count(ColorC.WHITE' PieceTypeC.PAWN) >= 2);                      e.scalingFunctionWHITE = Endgame.Endgame_KPsK;                  }                  else if (pos.piece_count(ColorC.WHITE' PieceTypeC.PAWN) == 0)                  {                      Debug.Assert(pos.piece_count(ColorC.BLACK' PieceTypeC.PAWN) >= 2);                      e.scalingFunctionBLACK = Endgame.Endgame_KPsK;                  }                  else if (pos.piece_count(ColorC.WHITE' PieceTypeC.PAWN) == 1 && pos.piece_count(ColorC.BLACK' PieceTypeC.PAWN) == 1)                  {                      // This is a special case because we set scaling functions                      // for both colors instead of only one.                      e.scalingFunctionWHITE = Endgame.Endgame_KPKP;                      e.scalingFunctionBLACK = Endgame.Endgame_KPKP;                  }              }
Magic Number,Portfish,MaterialTable,C:\repos\bpfliegel_Portfish\src\Material.cs,probe,The following statement contains a magic number: if (npm_w + npm_b == ValueC.VALUE_ZERO)              {                  if (pos.piece_count(ColorC.BLACK' PieceTypeC.PAWN) == 0)                  {                      Debug.Assert(pos.piece_count(ColorC.WHITE' PieceTypeC.PAWN) >= 2);                      e.scalingFunctionWHITE = Endgame.Endgame_KPsK;                  }                  else if (pos.piece_count(ColorC.WHITE' PieceTypeC.PAWN) == 0)                  {                      Debug.Assert(pos.piece_count(ColorC.BLACK' PieceTypeC.PAWN) >= 2);                      e.scalingFunctionBLACK = Endgame.Endgame_KPsK;                  }                  else if (pos.piece_count(ColorC.WHITE' PieceTypeC.PAWN) == 1 && pos.piece_count(ColorC.BLACK' PieceTypeC.PAWN) == 1)                  {                      // This is a special case because we set scaling functions                      // for both colors instead of only one.                      e.scalingFunctionWHITE = Endgame.Endgame_KPKP;                      e.scalingFunctionBLACK = Endgame.Endgame_KPKP;                  }              }
Magic Number,Portfish,MaterialTable,C:\repos\bpfliegel_Portfish\src\Material.cs,probe,The following statement contains a magic number: if (pos.piece_count(ColorC.WHITE' PieceTypeC.PAWN) == 0 && npm_w - npm_b <= Constants.BishopValueMidgame)              {                  e.factorWHITE = (byte)                  (npm_w == npm_b || npm_w < Constants.RookValueMidgame ? 0 : NoPawnsSF[Math.Min(pos.piece_count(ColorC.WHITE' PieceTypeC.BISHOP)' 2)]);              }
Magic Number,Portfish,MaterialTable,C:\repos\bpfliegel_Portfish\src\Material.cs,probe,The following statement contains a magic number: if (pos.piece_count(ColorC.BLACK' PieceTypeC.PAWN) == 0 && npm_b - npm_w <= Constants.BishopValueMidgame)              {                  e.factorBLACK = (byte)                  (npm_w == npm_b || npm_b < Constants.RookValueMidgame ? 0 : NoPawnsSF[Math.Min(pos.piece_count(ColorC.BLACK' PieceTypeC.BISHOP)' 2)]);              }
Magic Number,Portfish,MaterialTable,C:\repos\bpfliegel_Portfish\src\Material.cs,probe,The following statement contains a magic number: if (npm_w + npm_b >= 2 * Constants.QueenValueMidgame + 4 * Constants.RookValueMidgame + 2 * Constants.KnightValueMidgame)              {                  int minorPieceCount = pos.piece_count(ColorC.WHITE' PieceTypeC.KNIGHT) + pos.piece_count(ColorC.WHITE' PieceTypeC.BISHOP)                                       + pos.piece_count(ColorC.BLACK' PieceTypeC.KNIGHT) + pos.piece_count(ColorC.BLACK' PieceTypeC.BISHOP);                    e.spaceWeight = minorPieceCount * minorPieceCount;              }
Magic Number,Portfish,MaterialTable,C:\repos\bpfliegel_Portfish\src\Material.cs,probe,The following statement contains a magic number: if (npm_w + npm_b >= 2 * Constants.QueenValueMidgame + 4 * Constants.RookValueMidgame + 2 * Constants.KnightValueMidgame)              {                  int minorPieceCount = pos.piece_count(ColorC.WHITE' PieceTypeC.KNIGHT) + pos.piece_count(ColorC.WHITE' PieceTypeC.BISHOP)                                       + pos.piece_count(ColorC.BLACK' PieceTypeC.KNIGHT) + pos.piece_count(ColorC.BLACK' PieceTypeC.BISHOP);                    e.spaceWeight = minorPieceCount * minorPieceCount;              }
Magic Number,Portfish,MaterialTable,C:\repos\bpfliegel_Portfish\src\Material.cs,probe,The following statement contains a magic number: if (npm_w + npm_b >= 2 * Constants.QueenValueMidgame + 4 * Constants.RookValueMidgame + 2 * Constants.KnightValueMidgame)              {                  int minorPieceCount = pos.piece_count(ColorC.WHITE' PieceTypeC.KNIGHT) + pos.piece_count(ColorC.WHITE' PieceTypeC.BISHOP)                                       + pos.piece_count(ColorC.BLACK' PieceTypeC.KNIGHT) + pos.piece_count(ColorC.BLACK' PieceTypeC.BISHOP);                    e.spaceWeight = minorPieceCount * minorPieceCount;              }
Magic Number,Portfish,MaterialTable,C:\repos\bpfliegel_Portfish\src\Material.cs,probe,The following statement contains a magic number: pieceCount[0][2] = pos.piece_count(ColorC.WHITE' PieceTypeC.KNIGHT);
Magic Number,Portfish,MaterialTable,C:\repos\bpfliegel_Portfish\src\Material.cs,probe,The following statement contains a magic number: pieceCount[0][3] = pos.piece_count(ColorC.WHITE' PieceTypeC.BISHOP);
Magic Number,Portfish,MaterialTable,C:\repos\bpfliegel_Portfish\src\Material.cs,probe,The following statement contains a magic number: pieceCount[0][4] = pos.piece_count(ColorC.WHITE' PieceTypeC.ROOK);
Magic Number,Portfish,MaterialTable,C:\repos\bpfliegel_Portfish\src\Material.cs,probe,The following statement contains a magic number: pieceCount[0][5] = pos.piece_count(ColorC.WHITE' PieceTypeC.QUEEN);
Magic Number,Portfish,MaterialTable,C:\repos\bpfliegel_Portfish\src\Material.cs,probe,The following statement contains a magic number: pieceCount[1][2] = pos.piece_count(ColorC.BLACK' PieceTypeC.KNIGHT);
Magic Number,Portfish,MaterialTable,C:\repos\bpfliegel_Portfish\src\Material.cs,probe,The following statement contains a magic number: pieceCount[1][3] = pos.piece_count(ColorC.BLACK' PieceTypeC.BISHOP);
Magic Number,Portfish,MaterialTable,C:\repos\bpfliegel_Portfish\src\Material.cs,probe,The following statement contains a magic number: pieceCount[1][4] = pos.piece_count(ColorC.BLACK' PieceTypeC.ROOK);
Magic Number,Portfish,MaterialTable,C:\repos\bpfliegel_Portfish\src\Material.cs,probe,The following statement contains a magic number: pieceCount[1][5] = pos.piece_count(ColorC.BLACK' PieceTypeC.QUEEN);
Magic Number,Portfish,MaterialTable,C:\repos\bpfliegel_Portfish\src\Material.cs,probe,The following statement contains a magic number: e.value = (Int16)((imbalance(ColorC.WHITE) - imbalance(ColorC.BLACK)) / 16);
Magic Number,Portfish,Movegen,C:\repos\bpfliegel_Portfish\src\Movegen.cs,move_pawns,The following statement contains a magic number: return Delta == SquareC.DELTA_N ? p << 8                : Delta == SquareC.DELTA_S ? p >> 8                : Delta == SquareC.DELTA_NE ? (p & ~Constants.FileHBB) << 9                : Delta == SquareC.DELTA_SE ? (p & ~Constants.FileHBB) >> 7                : Delta == SquareC.DELTA_NW ? (p & ~Constants.FileABB) << 7                : Delta == SquareC.DELTA_SW ? (p & ~Constants.FileABB) >> 9 : 0;
Magic Number,Portfish,Movegen,C:\repos\bpfliegel_Portfish\src\Movegen.cs,move_pawns,The following statement contains a magic number: return Delta == SquareC.DELTA_N ? p << 8                : Delta == SquareC.DELTA_S ? p >> 8                : Delta == SquareC.DELTA_NE ? (p & ~Constants.FileHBB) << 9                : Delta == SquareC.DELTA_SE ? (p & ~Constants.FileHBB) >> 7                : Delta == SquareC.DELTA_NW ? (p & ~Constants.FileABB) << 7                : Delta == SquareC.DELTA_SW ? (p & ~Constants.FileABB) >> 9 : 0;
Magic Number,Portfish,Movegen,C:\repos\bpfliegel_Portfish\src\Movegen.cs,move_pawns,The following statement contains a magic number: return Delta == SquareC.DELTA_N ? p << 8                : Delta == SquareC.DELTA_S ? p >> 8                : Delta == SquareC.DELTA_NE ? (p & ~Constants.FileHBB) << 9                : Delta == SquareC.DELTA_SE ? (p & ~Constants.FileHBB) >> 7                : Delta == SquareC.DELTA_NW ? (p & ~Constants.FileABB) << 7                : Delta == SquareC.DELTA_SW ? (p & ~Constants.FileABB) >> 9 : 0;
Magic Number,Portfish,Movegen,C:\repos\bpfliegel_Portfish\src\Movegen.cs,move_pawns,The following statement contains a magic number: return Delta == SquareC.DELTA_N ? p << 8                : Delta == SquareC.DELTA_S ? p >> 8                : Delta == SquareC.DELTA_NE ? (p & ~Constants.FileHBB) << 9                : Delta == SquareC.DELTA_SE ? (p & ~Constants.FileHBB) >> 7                : Delta == SquareC.DELTA_NW ? (p & ~Constants.FileABB) << 7                : Delta == SquareC.DELTA_SW ? (p & ~Constants.FileABB) >> 9 : 0;
Magic Number,Portfish,Movegen,C:\repos\bpfliegel_Portfish\src\Movegen.cs,move_pawns,The following statement contains a magic number: return Delta == SquareC.DELTA_N ? p << 8                : Delta == SquareC.DELTA_S ? p >> 8                : Delta == SquareC.DELTA_NE ? (p & ~Constants.FileHBB) << 9                : Delta == SquareC.DELTA_SE ? (p & ~Constants.FileHBB) >> 7                : Delta == SquareC.DELTA_NW ? (p & ~Constants.FileABB) << 7                : Delta == SquareC.DELTA_SW ? (p & ~Constants.FileABB) >> 9 : 0;
Magic Number,Portfish,Movegen,C:\repos\bpfliegel_Portfish\src\Movegen.cs,move_pawns,The following statement contains a magic number: return Delta == SquareC.DELTA_N ? p << 8                : Delta == SquareC.DELTA_S ? p >> 8                : Delta == SquareC.DELTA_NE ? (p & ~Constants.FileHBB) << 9                : Delta == SquareC.DELTA_SE ? (p & ~Constants.FileHBB) >> 7                : Delta == SquareC.DELTA_NW ? (p & ~Constants.FileABB) << 7                : Delta == SquareC.DELTA_SW ? (p & ~Constants.FileABB) >> 9 : 0;
Magic Number,Portfish,Movegen,C:\repos\bpfliegel_Portfish\src\Movegen.cs,generate_pawn_moves,The following statement contains a magic number: if (Type != MoveType.MV_CAPTURE)              {                  emptySquares = (Type == MoveType.MV_QUIET ? target : ~pos.occupied_squares);                    b1 = move_pawns(UP' pawnsNotOn7) & emptySquares;                  b2 = move_pawns(UP' b1 & TRank3BB) & emptySquares;                    if (Type == MoveType.MV_EVASION) // Consider only blocking squares                  {                      b1 &= target;                      b2 &= target;                  }                    if (Type == MoveType.MV_QUIET_CHECK)                  {                      b1 &= Utils.StepAttacksBB[((Them << 3) | PieceTypeC.PAWN)][ksq];                      b2 &= Utils.StepAttacksBB[((Them << 3) | PieceTypeC.PAWN)][ksq];                        // Add pawn pushes which give discovered check. This is possible only                      // if the pawn is not on the same file as the enemy king' because we                      // don't generate captures. Note that a possible discovery check                      // promotion has been already generated among captures.                      if ((pawnsNotOn7 & target) != 0) // Target is dc bitboard                      {                          dc1 = move_pawns(UP' pawnsNotOn7 & target) & emptySquares & ~(Utils.FileBB[ksq & 7]);                          dc2 = move_pawns(UP' dc1 & TRank3BB) & emptySquares;                            b1 |= dc1;                          b2 |= dc2;                      }                  }                    while (b1 != 0) { to = Utils.pop_1st_bit(ref b1); ms[mpos++].move = (to | ((to - UP) << 6)); }                  while (b2 != 0) { to = Utils.pop_1st_bit(ref b2); ms[mpos++].move = (to | ((to - UP - UP) << 6)); }              }
Magic Number,Portfish,Movegen,C:\repos\bpfliegel_Portfish\src\Movegen.cs,generate_pawn_moves,The following statement contains a magic number: if (Type != MoveType.MV_CAPTURE)              {                  emptySquares = (Type == MoveType.MV_QUIET ? target : ~pos.occupied_squares);                    b1 = move_pawns(UP' pawnsNotOn7) & emptySquares;                  b2 = move_pawns(UP' b1 & TRank3BB) & emptySquares;                    if (Type == MoveType.MV_EVASION) // Consider only blocking squares                  {                      b1 &= target;                      b2 &= target;                  }                    if (Type == MoveType.MV_QUIET_CHECK)                  {                      b1 &= Utils.StepAttacksBB[((Them << 3) | PieceTypeC.PAWN)][ksq];                      b2 &= Utils.StepAttacksBB[((Them << 3) | PieceTypeC.PAWN)][ksq];                        // Add pawn pushes which give discovered check. This is possible only                      // if the pawn is not on the same file as the enemy king' because we                      // don't generate captures. Note that a possible discovery check                      // promotion has been already generated among captures.                      if ((pawnsNotOn7 & target) != 0) // Target is dc bitboard                      {                          dc1 = move_pawns(UP' pawnsNotOn7 & target) & emptySquares & ~(Utils.FileBB[ksq & 7]);                          dc2 = move_pawns(UP' dc1 & TRank3BB) & emptySquares;                            b1 |= dc1;                          b2 |= dc2;                      }                  }                    while (b1 != 0) { to = Utils.pop_1st_bit(ref b1); ms[mpos++].move = (to | ((to - UP) << 6)); }                  while (b2 != 0) { to = Utils.pop_1st_bit(ref b2); ms[mpos++].move = (to | ((to - UP - UP) << 6)); }              }
Magic Number,Portfish,Movegen,C:\repos\bpfliegel_Portfish\src\Movegen.cs,generate_pawn_moves,The following statement contains a magic number: if (Type != MoveType.MV_CAPTURE)              {                  emptySquares = (Type == MoveType.MV_QUIET ? target : ~pos.occupied_squares);                    b1 = move_pawns(UP' pawnsNotOn7) & emptySquares;                  b2 = move_pawns(UP' b1 & TRank3BB) & emptySquares;                    if (Type == MoveType.MV_EVASION) // Consider only blocking squares                  {                      b1 &= target;                      b2 &= target;                  }                    if (Type == MoveType.MV_QUIET_CHECK)                  {                      b1 &= Utils.StepAttacksBB[((Them << 3) | PieceTypeC.PAWN)][ksq];                      b2 &= Utils.StepAttacksBB[((Them << 3) | PieceTypeC.PAWN)][ksq];                        // Add pawn pushes which give discovered check. This is possible only                      // if the pawn is not on the same file as the enemy king' because we                      // don't generate captures. Note that a possible discovery check                      // promotion has been already generated among captures.                      if ((pawnsNotOn7 & target) != 0) // Target is dc bitboard                      {                          dc1 = move_pawns(UP' pawnsNotOn7 & target) & emptySquares & ~(Utils.FileBB[ksq & 7]);                          dc2 = move_pawns(UP' dc1 & TRank3BB) & emptySquares;                            b1 |= dc1;                          b2 |= dc2;                      }                  }                    while (b1 != 0) { to = Utils.pop_1st_bit(ref b1); ms[mpos++].move = (to | ((to - UP) << 6)); }                  while (b2 != 0) { to = Utils.pop_1st_bit(ref b2); ms[mpos++].move = (to | ((to - UP - UP) << 6)); }              }
Magic Number,Portfish,Movegen,C:\repos\bpfliegel_Portfish\src\Movegen.cs,generate_pawn_moves,The following statement contains a magic number: if (Type != MoveType.MV_CAPTURE)              {                  emptySquares = (Type == MoveType.MV_QUIET ? target : ~pos.occupied_squares);                    b1 = move_pawns(UP' pawnsNotOn7) & emptySquares;                  b2 = move_pawns(UP' b1 & TRank3BB) & emptySquares;                    if (Type == MoveType.MV_EVASION) // Consider only blocking squares                  {                      b1 &= target;                      b2 &= target;                  }                    if (Type == MoveType.MV_QUIET_CHECK)                  {                      b1 &= Utils.StepAttacksBB[((Them << 3) | PieceTypeC.PAWN)][ksq];                      b2 &= Utils.StepAttacksBB[((Them << 3) | PieceTypeC.PAWN)][ksq];                        // Add pawn pushes which give discovered check. This is possible only                      // if the pawn is not on the same file as the enemy king' because we                      // don't generate captures. Note that a possible discovery check                      // promotion has been already generated among captures.                      if ((pawnsNotOn7 & target) != 0) // Target is dc bitboard                      {                          dc1 = move_pawns(UP' pawnsNotOn7 & target) & emptySquares & ~(Utils.FileBB[ksq & 7]);                          dc2 = move_pawns(UP' dc1 & TRank3BB) & emptySquares;                            b1 |= dc1;                          b2 |= dc2;                      }                  }                    while (b1 != 0) { to = Utils.pop_1st_bit(ref b1); ms[mpos++].move = (to | ((to - UP) << 6)); }                  while (b2 != 0) { to = Utils.pop_1st_bit(ref b2); ms[mpos++].move = (to | ((to - UP - UP) << 6)); }              }
Magic Number,Portfish,Movegen,C:\repos\bpfliegel_Portfish\src\Movegen.cs,generate_pawn_moves,The following statement contains a magic number: if (Type != MoveType.MV_CAPTURE)              {                  emptySquares = (Type == MoveType.MV_QUIET ? target : ~pos.occupied_squares);                    b1 = move_pawns(UP' pawnsNotOn7) & emptySquares;                  b2 = move_pawns(UP' b1 & TRank3BB) & emptySquares;                    if (Type == MoveType.MV_EVASION) // Consider only blocking squares                  {                      b1 &= target;                      b2 &= target;                  }                    if (Type == MoveType.MV_QUIET_CHECK)                  {                      b1 &= Utils.StepAttacksBB[((Them << 3) | PieceTypeC.PAWN)][ksq];                      b2 &= Utils.StepAttacksBB[((Them << 3) | PieceTypeC.PAWN)][ksq];                        // Add pawn pushes which give discovered check. This is possible only                      // if the pawn is not on the same file as the enemy king' because we                      // don't generate captures. Note that a possible discovery check                      // promotion has been already generated among captures.                      if ((pawnsNotOn7 & target) != 0) // Target is dc bitboard                      {                          dc1 = move_pawns(UP' pawnsNotOn7 & target) & emptySquares & ~(Utils.FileBB[ksq & 7]);                          dc2 = move_pawns(UP' dc1 & TRank3BB) & emptySquares;                            b1 |= dc1;                          b2 |= dc2;                      }                  }                    while (b1 != 0) { to = Utils.pop_1st_bit(ref b1); ms[mpos++].move = (to | ((to - UP) << 6)); }                  while (b2 != 0) { to = Utils.pop_1st_bit(ref b2); ms[mpos++].move = (to | ((to - UP - UP) << 6)); }              }
Magic Number,Portfish,Movegen,C:\repos\bpfliegel_Portfish\src\Movegen.cs,generate_pawn_moves,The following statement contains a magic number: if (Type == MoveType.MV_CAPTURE || Type == MoveType.MV_EVASION || Type == MoveType.MV_NON_EVASION)              {                  b1 = move_pawns(RIGHT' pawnsNotOn7) & enemies;                  b2 = move_pawns(LEFT' pawnsNotOn7) & enemies;                    while (b1 != 0) { to = Utils.pop_1st_bit(ref b1); ms[mpos++].move = (to | ((to - RIGHT) << 6)); }                  while (b2 != 0) { to = Utils.pop_1st_bit(ref b2); ms[mpos++].move = (to | ((to - LEFT) << 6)); }                    if (pos.st.epSquare != SquareC.SQ_NONE)                  {                      Debug.Assert(Utils.rank_of(pos.st.epSquare) == Utils.relative_rank_CR(Us' RankC.RANK_6));                        // An en passant capture can be an evasion only if the checking piece                      // is the double pushed pawn and so is in the target. Otherwise this                      // is a discovery check and we are forced to do otherwise.                      if (Type == MoveType.MV_EVASION && (((target & Utils.SquareBB[pos.st.epSquare - UP]) == 0)))                          return;                        b1 = pawnsNotOn7 & Utils.StepAttacksBB[((Them << 3) | PieceTypeC.PAWN)][pos.st.epSquare];                        Debug.Assert(b1 != 0);                        while (b1 != 0)                      {                          ms[mpos++].move = (pos.st.epSquare | (Utils.pop_1st_bit(ref b1) << 6) | (2 << 14));                      }                  }              }
Magic Number,Portfish,Movegen,C:\repos\bpfliegel_Portfish\src\Movegen.cs,generate_pawn_moves,The following statement contains a magic number: if (Type == MoveType.MV_CAPTURE || Type == MoveType.MV_EVASION || Type == MoveType.MV_NON_EVASION)              {                  b1 = move_pawns(RIGHT' pawnsNotOn7) & enemies;                  b2 = move_pawns(LEFT' pawnsNotOn7) & enemies;                    while (b1 != 0) { to = Utils.pop_1st_bit(ref b1); ms[mpos++].move = (to | ((to - RIGHT) << 6)); }                  while (b2 != 0) { to = Utils.pop_1st_bit(ref b2); ms[mpos++].move = (to | ((to - LEFT) << 6)); }                    if (pos.st.epSquare != SquareC.SQ_NONE)                  {                      Debug.Assert(Utils.rank_of(pos.st.epSquare) == Utils.relative_rank_CR(Us' RankC.RANK_6));                        // An en passant capture can be an evasion only if the checking piece                      // is the double pushed pawn and so is in the target. Otherwise this                      // is a discovery check and we are forced to do otherwise.                      if (Type == MoveType.MV_EVASION && (((target & Utils.SquareBB[pos.st.epSquare - UP]) == 0)))                          return;                        b1 = pawnsNotOn7 & Utils.StepAttacksBB[((Them << 3) | PieceTypeC.PAWN)][pos.st.epSquare];                        Debug.Assert(b1 != 0);                        while (b1 != 0)                      {                          ms[mpos++].move = (pos.st.epSquare | (Utils.pop_1st_bit(ref b1) << 6) | (2 << 14));                      }                  }              }
Magic Number,Portfish,Movegen,C:\repos\bpfliegel_Portfish\src\Movegen.cs,generate_pawn_moves,The following statement contains a magic number: if (Type == MoveType.MV_CAPTURE || Type == MoveType.MV_EVASION || Type == MoveType.MV_NON_EVASION)              {                  b1 = move_pawns(RIGHT' pawnsNotOn7) & enemies;                  b2 = move_pawns(LEFT' pawnsNotOn7) & enemies;                    while (b1 != 0) { to = Utils.pop_1st_bit(ref b1); ms[mpos++].move = (to | ((to - RIGHT) << 6)); }                  while (b2 != 0) { to = Utils.pop_1st_bit(ref b2); ms[mpos++].move = (to | ((to - LEFT) << 6)); }                    if (pos.st.epSquare != SquareC.SQ_NONE)                  {                      Debug.Assert(Utils.rank_of(pos.st.epSquare) == Utils.relative_rank_CR(Us' RankC.RANK_6));                        // An en passant capture can be an evasion only if the checking piece                      // is the double pushed pawn and so is in the target. Otherwise this                      // is a discovery check and we are forced to do otherwise.                      if (Type == MoveType.MV_EVASION && (((target & Utils.SquareBB[pos.st.epSquare - UP]) == 0)))                          return;                        b1 = pawnsNotOn7 & Utils.StepAttacksBB[((Them << 3) | PieceTypeC.PAWN)][pos.st.epSquare];                        Debug.Assert(b1 != 0);                        while (b1 != 0)                      {                          ms[mpos++].move = (pos.st.epSquare | (Utils.pop_1st_bit(ref b1) << 6) | (2 << 14));                      }                  }              }
Magic Number,Portfish,Movegen,C:\repos\bpfliegel_Portfish\src\Movegen.cs,generate_pawn_moves,The following statement contains a magic number: if (Type == MoveType.MV_CAPTURE || Type == MoveType.MV_EVASION || Type == MoveType.MV_NON_EVASION)              {                  b1 = move_pawns(RIGHT' pawnsNotOn7) & enemies;                  b2 = move_pawns(LEFT' pawnsNotOn7) & enemies;                    while (b1 != 0) { to = Utils.pop_1st_bit(ref b1); ms[mpos++].move = (to | ((to - RIGHT) << 6)); }                  while (b2 != 0) { to = Utils.pop_1st_bit(ref b2); ms[mpos++].move = (to | ((to - LEFT) << 6)); }                    if (pos.st.epSquare != SquareC.SQ_NONE)                  {                      Debug.Assert(Utils.rank_of(pos.st.epSquare) == Utils.relative_rank_CR(Us' RankC.RANK_6));                        // An en passant capture can be an evasion only if the checking piece                      // is the double pushed pawn and so is in the target. Otherwise this                      // is a discovery check and we are forced to do otherwise.                      if (Type == MoveType.MV_EVASION && (((target & Utils.SquareBB[pos.st.epSquare - UP]) == 0)))                          return;                        b1 = pawnsNotOn7 & Utils.StepAttacksBB[((Them << 3) | PieceTypeC.PAWN)][pos.st.epSquare];                        Debug.Assert(b1 != 0);                        while (b1 != 0)                      {                          ms[mpos++].move = (pos.st.epSquare | (Utils.pop_1st_bit(ref b1) << 6) | (2 << 14));                      }                  }              }
Magic Number,Portfish,Movegen,C:\repos\bpfliegel_Portfish\src\Movegen.cs,generate_pawn_moves,The following statement contains a magic number: if (Type == MoveType.MV_CAPTURE || Type == MoveType.MV_EVASION || Type == MoveType.MV_NON_EVASION)              {                  b1 = move_pawns(RIGHT' pawnsNotOn7) & enemies;                  b2 = move_pawns(LEFT' pawnsNotOn7) & enemies;                    while (b1 != 0) { to = Utils.pop_1st_bit(ref b1); ms[mpos++].move = (to | ((to - RIGHT) << 6)); }                  while (b2 != 0) { to = Utils.pop_1st_bit(ref b2); ms[mpos++].move = (to | ((to - LEFT) << 6)); }                    if (pos.st.epSquare != SquareC.SQ_NONE)                  {                      Debug.Assert(Utils.rank_of(pos.st.epSquare) == Utils.relative_rank_CR(Us' RankC.RANK_6));                        // An en passant capture can be an evasion only if the checking piece                      // is the double pushed pawn and so is in the target. Otherwise this                      // is a discovery check and we are forced to do otherwise.                      if (Type == MoveType.MV_EVASION && (((target & Utils.SquareBB[pos.st.epSquare - UP]) == 0)))                          return;                        b1 = pawnsNotOn7 & Utils.StepAttacksBB[((Them << 3) | PieceTypeC.PAWN)][pos.st.epSquare];                        Debug.Assert(b1 != 0);                        while (b1 != 0)                      {                          ms[mpos++].move = (pos.st.epSquare | (Utils.pop_1st_bit(ref b1) << 6) | (2 << 14));                      }                  }              }
Magic Number,Portfish,Movegen,C:\repos\bpfliegel_Portfish\src\Movegen.cs,generate_pawn_moves,The following statement contains a magic number: if (Type == MoveType.MV_CAPTURE || Type == MoveType.MV_EVASION || Type == MoveType.MV_NON_EVASION)              {                  b1 = move_pawns(RIGHT' pawnsNotOn7) & enemies;                  b2 = move_pawns(LEFT' pawnsNotOn7) & enemies;                    while (b1 != 0) { to = Utils.pop_1st_bit(ref b1); ms[mpos++].move = (to | ((to - RIGHT) << 6)); }                  while (b2 != 0) { to = Utils.pop_1st_bit(ref b2); ms[mpos++].move = (to | ((to - LEFT) << 6)); }                    if (pos.st.epSquare != SquareC.SQ_NONE)                  {                      Debug.Assert(Utils.rank_of(pos.st.epSquare) == Utils.relative_rank_CR(Us' RankC.RANK_6));                        // An en passant capture can be an evasion only if the checking piece                      // is the double pushed pawn and so is in the target. Otherwise this                      // is a discovery check and we are forced to do otherwise.                      if (Type == MoveType.MV_EVASION && (((target & Utils.SquareBB[pos.st.epSquare - UP]) == 0)))                          return;                        b1 = pawnsNotOn7 & Utils.StepAttacksBB[((Them << 3) | PieceTypeC.PAWN)][pos.st.epSquare];                        Debug.Assert(b1 != 0);                        while (b1 != 0)                      {                          ms[mpos++].move = (pos.st.epSquare | (Utils.pop_1st_bit(ref b1) << 6) | (2 << 14));                      }                  }              }
Magic Number,Portfish,Movegen,C:\repos\bpfliegel_Portfish\src\Movegen.cs,generate_king_moves,The following statement contains a magic number: while (b != 0)               {  #if X64                  Bitboard bb = b;                  b &= (b - 1);                  ms[mpos++].move = ((Utils.BSFTable[((bb & (0xffffffffffffffff - bb + 1)) * 0x218A392CD3D5DBFUL) >> 58]) | (from << 6));  #else                  ms[mpos++].move = Utils.make_move(from' Utils.pop_1st_bit(ref b));  #endif              }
Magic Number,Portfish,Movegen,C:\repos\bpfliegel_Portfish\src\Movegen.cs,generate_king_moves,The following statement contains a magic number: while (b != 0)               {  #if X64                  Bitboard bb = b;                  b &= (b - 1);                  ms[mpos++].move = ((Utils.BSFTable[((bb & (0xffffffffffffffff - bb + 1)) * 0x218A392CD3D5DBFUL) >> 58]) | (from << 6));  #else                  ms[mpos++].move = Utils.make_move(from' Utils.pop_1st_bit(ref b));  #endif              }
Magic Number,Portfish,Movegen,C:\repos\bpfliegel_Portfish\src\Movegen.cs,generate_moves,The following statement contains a magic number: for (PieceType pieceType = PieceTypeC.KNIGHT; pieceType < PieceTypeC.KING; pieceType++)              {                  Square[] pl = pos.pieceList[us][pieceType];                  Square s = pl[plPos = 0];                  if (s != SquareC.SQ_NONE)                  {                      do                      {  #if X64                          if (pieceType == PieceTypeC.BISHOP) { b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] & target; }                          else if (pieceType == PieceTypeC.ROOK) { b = Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])] & target; }                          else if (pieceType == PieceTypeC.QUEEN) { b = (Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])]) & target; }                          else b = Utils.StepAttacksBB[pieceType][s] & target;                            while (b != 0)                           {                              Bitboard bb = b;                              b &= (b - 1);                              ms[mpos++].move = (Utils.BSFTable[((bb & (0xffffffffffffffff - bb + 1)) * 0x218A392CD3D5DBFUL) >> 58]) | (s << 6);                          }  #else                          if (pieceType == PieceTypeC.BISHOP) { b = Utils.bishop_attacks_bb(s' pos.occupied_squares) & target; ; }                          else if (pieceType == PieceTypeC.ROOK) { b = Utils.rook_attacks_bb(s' pos.occupied_squares) & target; ; }                          else if (pieceType == PieceTypeC.QUEEN) { b = (Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares)) & target; }                          else b = Utils.StepAttacksBB[pieceType][s] & target;                            while (b != 0) { ms[mpos++].move = Utils.make_move(s' Utils.pop_1st_bit(ref b)); }  #endif                      }                      while ((s = pl[++plPos]) != SquareC.SQ_NONE);                  }              }
Magic Number,Portfish,Movegen,C:\repos\bpfliegel_Portfish\src\Movegen.cs,generate_moves,The following statement contains a magic number: for (PieceType pieceType = PieceTypeC.KNIGHT; pieceType < PieceTypeC.KING; pieceType++)              {                  Square[] pl = pos.pieceList[us][pieceType];                  Square s = pl[plPos = 0];                  if (s != SquareC.SQ_NONE)                  {                      do                      {  #if X64                          if (pieceType == PieceTypeC.BISHOP) { b = Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] & target; }                          else if (pieceType == PieceTypeC.ROOK) { b = Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])] & target; }                          else if (pieceType == PieceTypeC.QUEEN) { b = (Utils.BAttacks[s][(((pos.occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])] | Utils.RAttacks[s][(((pos.occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])]) & target; }                          else b = Utils.StepAttacksBB[pieceType][s] & target;                            while (b != 0)                           {                              Bitboard bb = b;                              b &= (b - 1);                              ms[mpos++].move = (Utils.BSFTable[((bb & (0xffffffffffffffff - bb + 1)) * 0x218A392CD3D5DBFUL) >> 58]) | (s << 6);                          }  #else                          if (pieceType == PieceTypeC.BISHOP) { b = Utils.bishop_attacks_bb(s' pos.occupied_squares) & target; ; }                          else if (pieceType == PieceTypeC.ROOK) { b = Utils.rook_attacks_bb(s' pos.occupied_squares) & target; ; }                          else if (pieceType == PieceTypeC.QUEEN) { b = (Utils.bishop_attacks_bb(s' pos.occupied_squares) | Utils.rook_attacks_bb(s' pos.occupied_squares)) & target; }                          else b = Utils.StepAttacksBB[pieceType][s] & target;                            while (b != 0) { ms[mpos++].move = Utils.make_move(s' Utils.pop_1st_bit(ref b)); }  #endif                      }                      while ((s = pl[++plPos]) != SquareC.SQ_NONE);                  }              }
Magic Number,Portfish,MovePicker,C:\repos\bpfliegel_Portfish\src\MovePicker.cs,MovePickerC,The following statement contains a magic number: if (p.in_check())              {                  phase = SequencerC.EVASION;              }              else              {                  phase = SequencerC.MAIN_SEARCH;                    ms[Constants.MAX_MOVES].move = ss.killers0;                  ms[Constants.MAX_MOVES + 1].move = ss.killers1;                    // Consider sligtly negative captures as good if at low depth and far from beta                  if (ss.eval < beta - Constants.PawnValueMidgame && d < 3 * DepthC.ONE_PLY)                      captureThreshold = -Constants.PawnValueMidgame;                    // Consider negative captures as good if still enough to reach beta                  else if (ss.eval > beta)                      captureThreshold = beta - ss.eval;              }
Magic Number,Portfish,MovePicker,C:\repos\bpfliegel_Portfish\src\MovePicker.cs,score_captures,The following statement contains a magic number: for (int idx = 0; idx < lastMovePos; idx++)              {                  Move m = ms[idx].move;                  ms[idx].score = Position.PieceValueMidgame[pos.board[m & 0x3F]] - (pos.board[((m >> 6) & 0x3F)] & 7);                  if ((m & (3 << 14)) == (1 << 14))                  {                      ms[idx].score += Position.PieceValueMidgame[(((m >> 12) & 3) + 2)];                  }              }
Magic Number,Portfish,MovePicker,C:\repos\bpfliegel_Portfish\src\MovePicker.cs,score_captures,The following statement contains a magic number: for (int idx = 0; idx < lastMovePos; idx++)              {                  Move m = ms[idx].move;                  ms[idx].score = Position.PieceValueMidgame[pos.board[m & 0x3F]] - (pos.board[((m >> 6) & 0x3F)] & 7);                  if ((m & (3 << 14)) == (1 << 14))                  {                      ms[idx].score += Position.PieceValueMidgame[(((m >> 12) & 3) + 2)];                  }              }
Magic Number,Portfish,MovePicker,C:\repos\bpfliegel_Portfish\src\MovePicker.cs,score_captures,The following statement contains a magic number: for (int idx = 0; idx < lastMovePos; idx++)              {                  Move m = ms[idx].move;                  ms[idx].score = Position.PieceValueMidgame[pos.board[m & 0x3F]] - (pos.board[((m >> 6) & 0x3F)] & 7);                  if ((m & (3 << 14)) == (1 << 14))                  {                      ms[idx].score += Position.PieceValueMidgame[(((m >> 12) & 3) + 2)];                  }              }
Magic Number,Portfish,MovePicker,C:\repos\bpfliegel_Portfish\src\MovePicker.cs,score_captures,The following statement contains a magic number: for (int idx = 0; idx < lastMovePos; idx++)              {                  Move m = ms[idx].move;                  ms[idx].score = Position.PieceValueMidgame[pos.board[m & 0x3F]] - (pos.board[((m >> 6) & 0x3F)] & 7);                  if ((m & (3 << 14)) == (1 << 14))                  {                      ms[idx].score += Position.PieceValueMidgame[(((m >> 12) & 3) + 2)];                  }              }
Magic Number,Portfish,MovePicker,C:\repos\bpfliegel_Portfish\src\MovePicker.cs,score_captures,The following statement contains a magic number: for (int idx = 0; idx < lastMovePos; idx++)              {                  Move m = ms[idx].move;                  ms[idx].score = Position.PieceValueMidgame[pos.board[m & 0x3F]] - (pos.board[((m >> 6) & 0x3F)] & 7);                  if ((m & (3 << 14)) == (1 << 14))                  {                      ms[idx].score += Position.PieceValueMidgame[(((m >> 12) & 3) + 2)];                  }              }
Magic Number,Portfish,MovePicker,C:\repos\bpfliegel_Portfish\src\MovePicker.cs,score_captures,The following statement contains a magic number: for (int idx = 0; idx < lastMovePos; idx++)              {                  Move m = ms[idx].move;                  ms[idx].score = Position.PieceValueMidgame[pos.board[m & 0x3F]] - (pos.board[((m >> 6) & 0x3F)] & 7);                  if ((m & (3 << 14)) == (1 << 14))                  {                      ms[idx].score += Position.PieceValueMidgame[(((m >> 12) & 3) + 2)];                  }              }
Magic Number,Portfish,MovePicker,C:\repos\bpfliegel_Portfish\src\MovePicker.cs,score_captures,The following statement contains a magic number: for (int idx = 0; idx < lastMovePos; idx++)              {                  Move m = ms[idx].move;                  ms[idx].score = Position.PieceValueMidgame[pos.board[m & 0x3F]] - (pos.board[((m >> 6) & 0x3F)] & 7);                  if ((m & (3 << 14)) == (1 << 14))                  {                      ms[idx].score += Position.PieceValueMidgame[(((m >> 12) & 3) + 2)];                  }              }
Magic Number,Portfish,MovePicker,C:\repos\bpfliegel_Portfish\src\MovePicker.cs,score_captures,The following statement contains a magic number: for (int idx = 0; idx < lastMovePos; idx++)              {                  Move m = ms[idx].move;                  ms[idx].score = Position.PieceValueMidgame[pos.board[m & 0x3F]] - (pos.board[((m >> 6) & 0x3F)] & 7);                  if ((m & (3 << 14)) == (1 << 14))                  {                      ms[idx].score += Position.PieceValueMidgame[(((m >> 12) & 3) + 2)];                  }              }
Magic Number,Portfish,MovePicker,C:\repos\bpfliegel_Portfish\src\MovePicker.cs,score_noncaptures,The following statement contains a magic number: for (int idx = 0; idx < lastMovePos; idx++)              {                  ms[idx].score = H.history[pos.board[((ms[idx].move >> 6) & 0x3F)]][ms[idx].move & 0x3F];              }
Magic Number,Portfish,MovePicker,C:\repos\bpfliegel_Portfish\src\MovePicker.cs,score_evasions,The following statement contains a magic number: if (lastMovePos < 2)                  return;
Magic Number,Portfish,MovePicker,C:\repos\bpfliegel_Portfish\src\MovePicker.cs,score_evasions,The following statement contains a magic number: for (int idx = 0; idx < lastMovePos; idx++)              {                  Move m = ms[idx].move;                  if ((seeScore = ((Position.PieceValueMidgame[pos.board[m & 0x3F]] >= Position.PieceValueMidgame[pos.board[((m >> 6) & 0x3F)]]) ? 1 : pos.see(m' false))) < 0)                  {                      ms[idx].score = seeScore - History.MaxValue; // Be sure we are at the bottom                  }                  else if (((pos.board[m & 0x3F] != PieceC.NO_PIECE) && !((m & (3 << 14)) == (3 << 14))) || ((m & (3 << 14)) == (2 << 14)))                  {                      ms[idx].score = Position.PieceValueMidgame[pos.board[(m & 0x3F)]] - (pos.board[((m >> 6) & 0x3F)] & 7) + History.MaxValue;                  }                  else                  {                      ms[idx].score = H.value(pos.board[((m >> 6) & 0x3F)]' (m & 0x3F));                  }              }
Magic Number,Portfish,MovePicker,C:\repos\bpfliegel_Portfish\src\MovePicker.cs,score_evasions,The following statement contains a magic number: for (int idx = 0; idx < lastMovePos; idx++)              {                  Move m = ms[idx].move;                  if ((seeScore = ((Position.PieceValueMidgame[pos.board[m & 0x3F]] >= Position.PieceValueMidgame[pos.board[((m >> 6) & 0x3F)]]) ? 1 : pos.see(m' false))) < 0)                  {                      ms[idx].score = seeScore - History.MaxValue; // Be sure we are at the bottom                  }                  else if (((pos.board[m & 0x3F] != PieceC.NO_PIECE) && !((m & (3 << 14)) == (3 << 14))) || ((m & (3 << 14)) == (2 << 14)))                  {                      ms[idx].score = Position.PieceValueMidgame[pos.board[(m & 0x3F)]] - (pos.board[((m >> 6) & 0x3F)] & 7) + History.MaxValue;                  }                  else                  {                      ms[idx].score = H.value(pos.board[((m >> 6) & 0x3F)]' (m & 0x3F));                  }              }
Magic Number,Portfish,MovePicker,C:\repos\bpfliegel_Portfish\src\MovePicker.cs,score_evasions,The following statement contains a magic number: for (int idx = 0; idx < lastMovePos; idx++)              {                  Move m = ms[idx].move;                  if ((seeScore = ((Position.PieceValueMidgame[pos.board[m & 0x3F]] >= Position.PieceValueMidgame[pos.board[((m >> 6) & 0x3F)]]) ? 1 : pos.see(m' false))) < 0)                  {                      ms[idx].score = seeScore - History.MaxValue; // Be sure we are at the bottom                  }                  else if (((pos.board[m & 0x3F] != PieceC.NO_PIECE) && !((m & (3 << 14)) == (3 << 14))) || ((m & (3 << 14)) == (2 << 14)))                  {                      ms[idx].score = Position.PieceValueMidgame[pos.board[(m & 0x3F)]] - (pos.board[((m >> 6) & 0x3F)] & 7) + History.MaxValue;                  }                  else                  {                      ms[idx].score = H.value(pos.board[((m >> 6) & 0x3F)]' (m & 0x3F));                  }              }
Magic Number,Portfish,MovePicker,C:\repos\bpfliegel_Portfish\src\MovePicker.cs,score_evasions,The following statement contains a magic number: for (int idx = 0; idx < lastMovePos; idx++)              {                  Move m = ms[idx].move;                  if ((seeScore = ((Position.PieceValueMidgame[pos.board[m & 0x3F]] >= Position.PieceValueMidgame[pos.board[((m >> 6) & 0x3F)]]) ? 1 : pos.see(m' false))) < 0)                  {                      ms[idx].score = seeScore - History.MaxValue; // Be sure we are at the bottom                  }                  else if (((pos.board[m & 0x3F] != PieceC.NO_PIECE) && !((m & (3 << 14)) == (3 << 14))) || ((m & (3 << 14)) == (2 << 14)))                  {                      ms[idx].score = Position.PieceValueMidgame[pos.board[(m & 0x3F)]] - (pos.board[((m >> 6) & 0x3F)] & 7) + History.MaxValue;                  }                  else                  {                      ms[idx].score = H.value(pos.board[((m >> 6) & 0x3F)]' (m & 0x3F));                  }              }
Magic Number,Portfish,MovePicker,C:\repos\bpfliegel_Portfish\src\MovePicker.cs,score_evasions,The following statement contains a magic number: for (int idx = 0; idx < lastMovePos; idx++)              {                  Move m = ms[idx].move;                  if ((seeScore = ((Position.PieceValueMidgame[pos.board[m & 0x3F]] >= Position.PieceValueMidgame[pos.board[((m >> 6) & 0x3F)]]) ? 1 : pos.see(m' false))) < 0)                  {                      ms[idx].score = seeScore - History.MaxValue; // Be sure we are at the bottom                  }                  else if (((pos.board[m & 0x3F] != PieceC.NO_PIECE) && !((m & (3 << 14)) == (3 << 14))) || ((m & (3 << 14)) == (2 << 14)))                  {                      ms[idx].score = Position.PieceValueMidgame[pos.board[(m & 0x3F)]] - (pos.board[((m >> 6) & 0x3F)] & 7) + History.MaxValue;                  }                  else                  {                      ms[idx].score = H.value(pos.board[((m >> 6) & 0x3F)]' (m & 0x3F));                  }              }
Magic Number,Portfish,MovePicker,C:\repos\bpfliegel_Portfish\src\MovePicker.cs,score_evasions,The following statement contains a magic number: for (int idx = 0; idx < lastMovePos; idx++)              {                  Move m = ms[idx].move;                  if ((seeScore = ((Position.PieceValueMidgame[pos.board[m & 0x3F]] >= Position.PieceValueMidgame[pos.board[((m >> 6) & 0x3F)]]) ? 1 : pos.see(m' false))) < 0)                  {                      ms[idx].score = seeScore - History.MaxValue; // Be sure we are at the bottom                  }                  else if (((pos.board[m & 0x3F] != PieceC.NO_PIECE) && !((m & (3 << 14)) == (3 << 14))) || ((m & (3 << 14)) == (2 << 14)))                  {                      ms[idx].score = Position.PieceValueMidgame[pos.board[(m & 0x3F)]] - (pos.board[((m >> 6) & 0x3F)] & 7) + History.MaxValue;                  }                  else                  {                      ms[idx].score = H.value(pos.board[((m >> 6) & 0x3F)]' (m & 0x3F));                  }              }
Magic Number,Portfish,MovePicker,C:\repos\bpfliegel_Portfish\src\MovePicker.cs,score_evasions,The following statement contains a magic number: for (int idx = 0; idx < lastMovePos; idx++)              {                  Move m = ms[idx].move;                  if ((seeScore = ((Position.PieceValueMidgame[pos.board[m & 0x3F]] >= Position.PieceValueMidgame[pos.board[((m >> 6) & 0x3F)]]) ? 1 : pos.see(m' false))) < 0)                  {                      ms[idx].score = seeScore - History.MaxValue; // Be sure we are at the bottom                  }                  else if (((pos.board[m & 0x3F] != PieceC.NO_PIECE) && !((m & (3 << 14)) == (3 << 14))) || ((m & (3 << 14)) == (2 << 14)))                  {                      ms[idx].score = Position.PieceValueMidgame[pos.board[(m & 0x3F)]] - (pos.board[((m >> 6) & 0x3F)] & 7) + History.MaxValue;                  }                  else                  {                      ms[idx].score = H.value(pos.board[((m >> 6) & 0x3F)]' (m & 0x3F));                  }              }
Magic Number,Portfish,MovePicker,C:\repos\bpfliegel_Portfish\src\MovePicker.cs,score_evasions,The following statement contains a magic number: for (int idx = 0; idx < lastMovePos; idx++)              {                  Move m = ms[idx].move;                  if ((seeScore = ((Position.PieceValueMidgame[pos.board[m & 0x3F]] >= Position.PieceValueMidgame[pos.board[((m >> 6) & 0x3F)]]) ? 1 : pos.see(m' false))) < 0)                  {                      ms[idx].score = seeScore - History.MaxValue; // Be sure we are at the bottom                  }                  else if (((pos.board[m & 0x3F] != PieceC.NO_PIECE) && !((m & (3 << 14)) == (3 << 14))) || ((m & (3 << 14)) == (2 << 14)))                  {                      ms[idx].score = Position.PieceValueMidgame[pos.board[(m & 0x3F)]] - (pos.board[((m >> 6) & 0x3F)] & 7) + History.MaxValue;                  }                  else                  {                      ms[idx].score = H.value(pos.board[((m >> 6) & 0x3F)]' (m & 0x3F));                  }              }
Magic Number,Portfish,MovePicker,C:\repos\bpfliegel_Portfish\src\MovePicker.cs,score_evasions,The following statement contains a magic number: for (int idx = 0; idx < lastMovePos; idx++)              {                  Move m = ms[idx].move;                  if ((seeScore = ((Position.PieceValueMidgame[pos.board[m & 0x3F]] >= Position.PieceValueMidgame[pos.board[((m >> 6) & 0x3F)]]) ? 1 : pos.see(m' false))) < 0)                  {                      ms[idx].score = seeScore - History.MaxValue; // Be sure we are at the bottom                  }                  else if (((pos.board[m & 0x3F] != PieceC.NO_PIECE) && !((m & (3 << 14)) == (3 << 14))) || ((m & (3 << 14)) == (2 << 14)))                  {                      ms[idx].score = Position.PieceValueMidgame[pos.board[(m & 0x3F)]] - (pos.board[((m >> 6) & 0x3F)] & 7) + History.MaxValue;                  }                  else                  {                      ms[idx].score = H.value(pos.board[((m >> 6) & 0x3F)]' (m & 0x3F));                  }              }
Magic Number,Portfish,MovePicker,C:\repos\bpfliegel_Portfish\src\MovePicker.cs,score_evasions,The following statement contains a magic number: for (int idx = 0; idx < lastMovePos; idx++)              {                  Move m = ms[idx].move;                  if ((seeScore = ((Position.PieceValueMidgame[pos.board[m & 0x3F]] >= Position.PieceValueMidgame[pos.board[((m >> 6) & 0x3F)]]) ? 1 : pos.see(m' false))) < 0)                  {                      ms[idx].score = seeScore - History.MaxValue; // Be sure we are at the bottom                  }                  else if (((pos.board[m & 0x3F] != PieceC.NO_PIECE) && !((m & (3 << 14)) == (3 << 14))) || ((m & (3 << 14)) == (2 << 14)))                  {                      ms[idx].score = Position.PieceValueMidgame[pos.board[(m & 0x3F)]] - (pos.board[((m >> 6) & 0x3F)] & 7) + History.MaxValue;                  }                  else                  {                      ms[idx].score = H.value(pos.board[((m >> 6) & 0x3F)]' (m & 0x3F));                  }              }
Magic Number,Portfish,MovePicker,C:\repos\bpfliegel_Portfish\src\MovePicker.cs,score_evasions,The following statement contains a magic number: for (int idx = 0; idx < lastMovePos; idx++)              {                  Move m = ms[idx].move;                  if ((seeScore = ((Position.PieceValueMidgame[pos.board[m & 0x3F]] >= Position.PieceValueMidgame[pos.board[((m >> 6) & 0x3F)]]) ? 1 : pos.see(m' false))) < 0)                  {                      ms[idx].score = seeScore - History.MaxValue; // Be sure we are at the bottom                  }                  else if (((pos.board[m & 0x3F] != PieceC.NO_PIECE) && !((m & (3 << 14)) == (3 << 14))) || ((m & (3 << 14)) == (2 << 14)))                  {                      ms[idx].score = Position.PieceValueMidgame[pos.board[(m & 0x3F)]] - (pos.board[((m >> 6) & 0x3F)] & 7) + History.MaxValue;                  }                  else                  {                      ms[idx].score = H.value(pos.board[((m >> 6) & 0x3F)]' (m & 0x3F));                  }              }
Magic Number,Portfish,MovePicker,C:\repos\bpfliegel_Portfish\src\MovePicker.cs,score_evasions,The following statement contains a magic number: for (int idx = 0; idx < lastMovePos; idx++)              {                  Move m = ms[idx].move;                  if ((seeScore = ((Position.PieceValueMidgame[pos.board[m & 0x3F]] >= Position.PieceValueMidgame[pos.board[((m >> 6) & 0x3F)]]) ? 1 : pos.see(m' false))) < 0)                  {                      ms[idx].score = seeScore - History.MaxValue; // Be sure we are at the bottom                  }                  else if (((pos.board[m & 0x3F] != PieceC.NO_PIECE) && !((m & (3 << 14)) == (3 << 14))) || ((m & (3 << 14)) == (2 << 14)))                  {                      ms[idx].score = Position.PieceValueMidgame[pos.board[(m & 0x3F)]] - (pos.board[((m >> 6) & 0x3F)] & 7) + History.MaxValue;                  }                  else                  {                      ms[idx].score = H.value(pos.board[((m >> 6) & 0x3F)]' (m & 0x3F));                  }              }
Magic Number,Portfish,MovePicker,C:\repos\bpfliegel_Portfish\src\MovePicker.cs,generate_next,The following statement contains a magic number: switch (++phase)              {                  case SequencerC.CAPTURES_S1:                  case SequencerC.CAPTURES_S3:                  case SequencerC.CAPTURES_S4:                  case SequencerC.CAPTURES_S5:                  case SequencerC.CAPTURES_S6:                      mpos = 0;                      Movegen.generate_capture(pos' ms' ref mpos);                      lastMovePos = mpos;                      score_captures();                      return;                    case SequencerC.KILLERS_S1:                      curMovePos = Constants.MAX_MOVES;//killers[0];                      lastMovePos = curMovePos + 2;                      return;                    case SequencerC.QUIETS_1_S1:                      mpos = 0;                      Movegen.generate_quiet(pos' ms' ref mpos);                      lastQuietPos = lastMovePos = mpos;                      score_noncaptures();                      lastMovePos = partition(curMovePos' lastMovePos);                      sort();                      return;                    case SequencerC.QUIETS_2_S1:                      curMovePos = lastMovePos;                      lastMovePos = lastQuietPos;                      if (depth >= 3 * DepthC.ONE_PLY)                      {                          sort();                      }                      return;                    case SequencerC.BAD_CAPTURES_S1:                      // Just pick them in reverse order to get MVV/LVA ordering                      curMovePos = Constants.MAX_MOVES - 1;                      lastMovePos = lastBadCapturePos;                      return;                    case SequencerC.EVASIONS_S2:                      mpos = 0;                      Movegen.generate_evasion(pos' ms' ref mpos);                      lastMovePos = mpos;                      score_evasions();                      return;                    case SequencerC.QUIET_CHECKS_S3:                      mpos = 0;                      Movegen.generate_quiet_check(pos' ms' ref mpos);                      lastMovePos = mpos;                      return;                    case SequencerC.EVASION:                  case SequencerC.QSEARCH_0:                  case SequencerC.QSEARCH_1:                  case SequencerC.PROBCUT:                  case SequencerC.RECAPTURE:                      phase = SequencerC.STOP;                      lastMovePos = curMovePos + 1; // Avoid another next_phase() call                      break;                    case SequencerC.STOP:                      lastMovePos = curMovePos + 1; // Avoid another next_phase() call                      return;                    default:                      Debug.Assert(false);                      break;              }
Magic Number,Portfish,MovePicker,C:\repos\bpfliegel_Portfish\src\MovePicker.cs,generate_next,The following statement contains a magic number: switch (++phase)              {                  case SequencerC.CAPTURES_S1:                  case SequencerC.CAPTURES_S3:                  case SequencerC.CAPTURES_S4:                  case SequencerC.CAPTURES_S5:                  case SequencerC.CAPTURES_S6:                      mpos = 0;                      Movegen.generate_capture(pos' ms' ref mpos);                      lastMovePos = mpos;                      score_captures();                      return;                    case SequencerC.KILLERS_S1:                      curMovePos = Constants.MAX_MOVES;//killers[0];                      lastMovePos = curMovePos + 2;                      return;                    case SequencerC.QUIETS_1_S1:                      mpos = 0;                      Movegen.generate_quiet(pos' ms' ref mpos);                      lastQuietPos = lastMovePos = mpos;                      score_noncaptures();                      lastMovePos = partition(curMovePos' lastMovePos);                      sort();                      return;                    case SequencerC.QUIETS_2_S1:                      curMovePos = lastMovePos;                      lastMovePos = lastQuietPos;                      if (depth >= 3 * DepthC.ONE_PLY)                      {                          sort();                      }                      return;                    case SequencerC.BAD_CAPTURES_S1:                      // Just pick them in reverse order to get MVV/LVA ordering                      curMovePos = Constants.MAX_MOVES - 1;                      lastMovePos = lastBadCapturePos;                      return;                    case SequencerC.EVASIONS_S2:                      mpos = 0;                      Movegen.generate_evasion(pos' ms' ref mpos);                      lastMovePos = mpos;                      score_evasions();                      return;                    case SequencerC.QUIET_CHECKS_S3:                      mpos = 0;                      Movegen.generate_quiet_check(pos' ms' ref mpos);                      lastMovePos = mpos;                      return;                    case SequencerC.EVASION:                  case SequencerC.QSEARCH_0:                  case SequencerC.QSEARCH_1:                  case SequencerC.PROBCUT:                  case SequencerC.RECAPTURE:                      phase = SequencerC.STOP;                      lastMovePos = curMovePos + 1; // Avoid another next_phase() call                      break;                    case SequencerC.STOP:                      lastMovePos = curMovePos + 1; // Avoid another next_phase() call                      return;                    default:                      Debug.Assert(false);                      break;              }
Magic Number,Portfish,BrokerManager,C:\repos\bpfliegel_Portfish\src\ObjectBroker.cs,Warmup,The following statement contains a magic number: brokerSize = 40;
Magic Number,Portfish,BrokerManager,C:\repos\bpfliegel_Portfish\src\ObjectBroker.cs,Warmup,The following statement contains a magic number: brokerSize = 4;
Magic Number,Portfish,BrokerManager,C:\repos\bpfliegel_Portfish\src\ObjectBroker.cs,Warmup,The following statement contains a magic number: brokerSize = 4;
Magic Number,Portfish,BrokerManager,C:\repos\bpfliegel_Portfish\src\ObjectBroker.cs,Warmup,The following statement contains a magic number: brokerSize = 36;
Magic Number,Portfish,BrokerManager,C:\repos\bpfliegel_Portfish\src\ObjectBroker.cs,Warmup,The following statement contains a magic number: brokerSize = 8;
Magic Number,Portfish,BrokerManager,C:\repos\bpfliegel_Portfish\src\ObjectBroker.cs,Warmup,The following statement contains a magic number: brokerSize = 4;
Magic Number,Portfish,BrokerManager,C:\repos\bpfliegel_Portfish\src\ObjectBroker.cs,Warmup,The following statement contains a magic number: brokerSize = 4;
Magic Number,Portfish,BrokerManager,C:\repos\bpfliegel_Portfish\src\ObjectBroker.cs,Warmup,The following statement contains a magic number: brokerSize = 36;
Magic Number,Portfish,BrokerManager,C:\repos\bpfliegel_Portfish\src\ObjectBroker.cs,Warmup,The following statement contains a magic number: brokerSize = 8;
Magic Number,Portfish,BrokerManager,C:\repos\bpfliegel_Portfish\src\ObjectBroker.cs,Warmup,The following statement contains a magic number: brokerSize = 40;
Magic Number,Portfish,PawnEntry,C:\repos\bpfliegel_Portfish\src\PawnInfo.cs,king_safety,The following statement contains a magic number: if (Us == ColorC.WHITE)              {                  return kingSquaresWHITE == ksq && castleRightsWHITE == (pos.st.castleRights & (CastleRightC.WHITE_ANY))                      ? kingSafetyWHITE : update_safety_WHITE(pos' ksq);              }              else              {                  return kingSquaresBLACK == ksq && castleRightsBLACK == (pos.st.castleRights & (CastleRightC.WHITE_ANY << 2))                      ? kingSafetyBLACK : update_safety_BLACK(pos' ksq);              }
Magic Number,Portfish,PawnEntry,C:\repos\bpfliegel_Portfish\src\PawnInfo.cs,shelter_storm,The following statement contains a magic number: Bitboard b = pos.byTypeBB[PieceTypeC.PAWN] & (Utils.InFrontBB[Us][ksq >> 3] | Utils.RankBB[ksq >> 3]);
Magic Number,Portfish,PawnEntry,C:\repos\bpfliegel_Portfish\src\PawnInfo.cs,shelter_storm,The following statement contains a magic number: Bitboard b = pos.byTypeBB[PieceTypeC.PAWN] & (Utils.InFrontBB[Us][ksq >> 3] | Utils.RankBB[ksq >> 3]);
Magic Number,Portfish,PawnEntry,C:\repos\bpfliegel_Portfish\src\PawnInfo.cs,shelter_storm,The following statement contains a magic number: Bitboard ourPawns = b & pos.byColorBB[Us] & ~Utils.RankBB[ksq >> 3];
Magic Number,Portfish,PawnEntry,C:\repos\bpfliegel_Portfish\src\PawnInfo.cs,shelter_storm,The following statement contains a magic number: File kf = ksq & 7;
Magic Number,Portfish,PawnEntry,C:\repos\bpfliegel_Portfish\src\PawnInfo.cs,shelter_storm,The following statement contains a magic number: for (int f = kf - 1; f <= kf + 1; f++)              {                  // Shelter penalty is higher for the pawn in front of the king                  b = ourPawns & Utils.FileBB[f];                  rkUs = (b != 0) ? ((Us == ColorC.WHITE ? Utils.first_1(b) : (Utils.last_1(b) ^ 56)) >> 3) : RankC.RANK_1;                  safety -= PawnTable.ShelterWeakness[f != kf ? 1 : 0][rkUs];                    // Storm danger is smaller if enemy pawn is blocked                  b = theirPawns & Utils.FileBB[f];                  rkThem = (b != 0) ? ((Us == ColorC.WHITE ? Utils.first_1(b) : (Utils.last_1(b) ^ 56)) >> 3) : RankC.RANK_1;                  safety -= PawnTable.StormDanger[rkThem == rkUs + 1 ? 1 : 0][rkThem];              }
Magic Number,Portfish,PawnEntry,C:\repos\bpfliegel_Portfish\src\PawnInfo.cs,shelter_storm,The following statement contains a magic number: for (int f = kf - 1; f <= kf + 1; f++)              {                  // Shelter penalty is higher for the pawn in front of the king                  b = ourPawns & Utils.FileBB[f];                  rkUs = (b != 0) ? ((Us == ColorC.WHITE ? Utils.first_1(b) : (Utils.last_1(b) ^ 56)) >> 3) : RankC.RANK_1;                  safety -= PawnTable.ShelterWeakness[f != kf ? 1 : 0][rkUs];                    // Storm danger is smaller if enemy pawn is blocked                  b = theirPawns & Utils.FileBB[f];                  rkThem = (b != 0) ? ((Us == ColorC.WHITE ? Utils.first_1(b) : (Utils.last_1(b) ^ 56)) >> 3) : RankC.RANK_1;                  safety -= PawnTable.StormDanger[rkThem == rkUs + 1 ? 1 : 0][rkThem];              }
Magic Number,Portfish,PawnEntry,C:\repos\bpfliegel_Portfish\src\PawnInfo.cs,shelter_storm,The following statement contains a magic number: for (int f = kf - 1; f <= kf + 1; f++)              {                  // Shelter penalty is higher for the pawn in front of the king                  b = ourPawns & Utils.FileBB[f];                  rkUs = (b != 0) ? ((Us == ColorC.WHITE ? Utils.first_1(b) : (Utils.last_1(b) ^ 56)) >> 3) : RankC.RANK_1;                  safety -= PawnTable.ShelterWeakness[f != kf ? 1 : 0][rkUs];                    // Storm danger is smaller if enemy pawn is blocked                  b = theirPawns & Utils.FileBB[f];                  rkThem = (b != 0) ? ((Us == ColorC.WHITE ? Utils.first_1(b) : (Utils.last_1(b) ^ 56)) >> 3) : RankC.RANK_1;                  safety -= PawnTable.StormDanger[rkThem == rkUs + 1 ? 1 : 0][rkThem];              }
Magic Number,Portfish,PawnEntry,C:\repos\bpfliegel_Portfish\src\PawnInfo.cs,shelter_storm,The following statement contains a magic number: for (int f = kf - 1; f <= kf + 1; f++)              {                  // Shelter penalty is higher for the pawn in front of the king                  b = ourPawns & Utils.FileBB[f];                  rkUs = (b != 0) ? ((Us == ColorC.WHITE ? Utils.first_1(b) : (Utils.last_1(b) ^ 56)) >> 3) : RankC.RANK_1;                  safety -= PawnTable.ShelterWeakness[f != kf ? 1 : 0][rkUs];                    // Storm danger is smaller if enemy pawn is blocked                  b = theirPawns & Utils.FileBB[f];                  rkThem = (b != 0) ? ((Us == ColorC.WHITE ? Utils.first_1(b) : (Utils.last_1(b) ^ 56)) >> 3) : RankC.RANK_1;                  safety -= PawnTable.StormDanger[rkThem == rkUs + 1 ? 1 : 0][rkThem];              }
Magic Number,Portfish,PawnEntry,C:\repos\bpfliegel_Portfish\src\PawnInfo.cs,update_safety_WHITE,The following statement contains a magic number: if (((ksq >> 3) ^ (ColorC.WHITE * 7)) > RankC.RANK_4)                  return kingSafetyWHITE = ScoreC.SCORE_ZERO;
Magic Number,Portfish,PawnEntry,C:\repos\bpfliegel_Portfish\src\PawnInfo.cs,update_safety_WHITE,The following statement contains a magic number: if (((ksq >> 3) ^ (ColorC.WHITE * 7)) > RankC.RANK_4)                  return kingSafetyWHITE = ScoreC.SCORE_ZERO;
Magic Number,Portfish,PawnEntry,C:\repos\bpfliegel_Portfish\src\PawnInfo.cs,update_safety_WHITE,The following statement contains a magic number: if ((pos.st.castleRights & CastleRightC.WHITE_OO)!=0)                  bonus = Math.Max(bonus' shelter_storm(ColorC.WHITE' pos' (SquareC.SQ_G1 ^ (ColorC.WHITE * 56))));
Magic Number,Portfish,PawnEntry,C:\repos\bpfliegel_Portfish\src\PawnInfo.cs,update_safety_WHITE,The following statement contains a magic number: if ((pos.st.castleRights & CastleRightC.WHITE_OOO) != 0)                  bonus = Math.Max(bonus' shelter_storm(ColorC.WHITE' pos' (SquareC.SQ_C1 ^ (ColorC.WHITE * 56))));
Magic Number,Portfish,PawnEntry,C:\repos\bpfliegel_Portfish\src\PawnInfo.cs,update_safety_WHITE,The following statement contains a magic number: return kingSafetyWHITE = (bonus << 16);
Magic Number,Portfish,PawnEntry,C:\repos\bpfliegel_Portfish\src\PawnInfo.cs,update_safety_BLACK,The following statement contains a magic number: if (((ksq >> 3) ^ (ColorC.BLACK * 7)) > RankC.RANK_4)                  return kingSafetyBLACK = ScoreC.SCORE_ZERO;
Magic Number,Portfish,PawnEntry,C:\repos\bpfliegel_Portfish\src\PawnInfo.cs,update_safety_BLACK,The following statement contains a magic number: if (((ksq >> 3) ^ (ColorC.BLACK * 7)) > RankC.RANK_4)                  return kingSafetyBLACK = ScoreC.SCORE_ZERO;
Magic Number,Portfish,PawnEntry,C:\repos\bpfliegel_Portfish\src\PawnInfo.cs,update_safety_BLACK,The following statement contains a magic number: if ((pos.st.castleRights & CastleRightC.BLACK_OO) != 0)                  bonus = Math.Max(bonus' shelter_storm(ColorC.BLACK' pos' (SquareC.SQ_G1 ^ (ColorC.BLACK * 56))));
Magic Number,Portfish,PawnEntry,C:\repos\bpfliegel_Portfish\src\PawnInfo.cs,update_safety_BLACK,The following statement contains a magic number: if ((pos.st.castleRights & CastleRightC.BLACK_OOO) != 0)                  bonus = Math.Max(bonus' shelter_storm(ColorC.BLACK' pos' (SquareC.SQ_C1 ^ (ColorC.BLACK * 56))));
Magic Number,Portfish,PawnEntry,C:\repos\bpfliegel_Portfish\src\PawnInfo.cs,update_safety_BLACK,The following statement contains a magic number: return kingSafetyBLACK = (bonus << 16);
Magic Number,Portfish,PawnTable,C:\repos\bpfliegel_Portfish\src\PawnInfo.cs,probe,The following statement contains a magic number: e.pawnAttacksWHITE = ((wPawns & ~Constants.FileHBB) << 9) | ((wPawns & ~Constants.FileABB) << 7);
Magic Number,Portfish,PawnTable,C:\repos\bpfliegel_Portfish\src\PawnInfo.cs,probe,The following statement contains a magic number: e.pawnAttacksWHITE = ((wPawns & ~Constants.FileHBB) << 9) | ((wPawns & ~Constants.FileABB) << 7);
Magic Number,Portfish,PawnTable,C:\repos\bpfliegel_Portfish\src\PawnInfo.cs,probe,The following statement contains a magic number: e.pawnAttacksBLACK = ((bPawns & ~Constants.FileHBB) >> 7) | ((bPawns & ~Constants.FileABB) >> 9);
Magic Number,Portfish,PawnTable,C:\repos\bpfliegel_Portfish\src\PawnInfo.cs,probe,The following statement contains a magic number: e.pawnAttacksBLACK = ((bPawns & ~Constants.FileHBB) >> 7) | ((bPawns & ~Constants.FileABB) >> 9);
Magic Number,Portfish,PawnTable,C:\repos\bpfliegel_Portfish\src\PawnInfo.cs,evaluate_pawns,The following statement contains a magic number: while ((s = pl[plPos++]) != SquareC.SQ_NONE)              {                  Debug.Assert(pos.piece_on(s) == Utils.make_piece(Us' PieceTypeC.PAWN));                    f = (s & 7);                  r = (s >> 3);                    // This file cannot be half open                  if (Us == ColorC.WHITE)                  {                      e.halfOpenFilesWHITE &= ~(1 << f);                  }                  else                  {                      e.halfOpenFilesBLACK &= ~(1 << f);                  }                    // Our rank plus previous one. Used for chain detection                  b = Utils.RankBB[r] | Utils.RankBB[Us == ColorC.WHITE ? r - 1 : r + 1];                    // Flag the pawn as passed' isolated' doubled or member of a pawn                  // chain (but not the backward one).                  chain = (ourPawns & Utils.AdjacentFilesBB[f] & b) != 0;                  isolated = (ourPawns & Utils.AdjacentFilesBB[f]) == 0;                  doubled = (ourPawns & Utils.ForwardBB[Us][s]) != 0;                  opposed = (theirPawns & Utils.ForwardBB[Us][s]) != 0;                  passed = (theirPawns & Utils.PassedPawnMask[Us][s]) == 0;                    // Test for backward pawn                  backward = false;                    // If the pawn is passed' isolated' or member of a pawn chain it cannot                  // be backward. If there are friendly pawns behind on adjacent files                  // or if can capture an enemy pawn it cannot be backward either.                  if (!(passed | isolated | chain)                      && (((ourPawns & Utils.AttackSpanMask[Them][s])) == 0)                      && ((((Utils.StepAttacksBB[((Us << 3) | PieceTypeC.PAWN)][s]) & theirPawns)) == 0))                  {                      // We now know that there are no friendly pawns beside or behind this                      // pawn on adjacent files. We now check whether the pawn is                      // backward by looking in the forward direction on the adjacent                      // files' and seeing whether we meet a friendly or an enemy pawn first.                      b = Utils.StepAttacksBB[((Us << 3) | PieceTypeC.PAWN)][s];                        // Note that we are sure to find something because pawn is not passed                      // nor isolated' so loop is potentially infinite' but it isn't.                      while ((b & (ourPawns | theirPawns)) == 0)                      {                          if (Us == ColorC.WHITE) { b <<= 8; } else { b >>= 8; }                      }                        // The friendly pawn needs to be at least two ranks closer than the                      // enemy pawn in order to help the potentially backward pawn advance.                      backward = (((b | (Us == ColorC.WHITE ? b << 8 : b >> 8)) & theirPawns) != 0);                  }                    Debug.Assert(opposed | passed | (((Utils.AttackSpanMask[Us][s] & theirPawns)) != 0));                    // A not passed pawn is a candidate to become passed if it is free to                  // advance and if the number of friendly pawns beside or behind this                  // pawn on adjacent files is higher or equal than the number of                  // enemy pawns in the forward direction on the adjacent files.                  candidate = !(opposed | passed | backward | isolated)                             && (b = Utils.AttackSpanMask[Them][s + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)] & ourPawns) != 0                             && Bitcount.popcount_1s_Max15(b) >= Bitcount.popcount_1s_Max15(Utils.AttackSpanMask[Us][s] & theirPawns);                    // Passed pawns will be properly scored in evaluation because we need                  // full attack info to evaluate passed pawns. Only the frontmost passed                  // pawn on each file is considered a true passed pawn.                  if (passed && !doubled)                  {                      if (Us == ColorC.WHITE)                      {                          e.passedPawnsWHITE |= Utils.SquareBB[s];                      }                      else                      {                          e.passedPawnsBLACK |= Utils.SquareBB[s];                      }                  }                    // Score this pawn                  if (isolated)                      value -= IsolatedPawnPenalty[opposed ? 1 : 0][f];                    if (doubled)                      value -= DoubledPawnPenalty[opposed ? 1 : 0][f];                    if (backward)                      value -= BackwardPawnPenalty[opposed ? 1 : 0][f];                    if (chain)                      value += ChainBonus[f];                    if (candidate)                      value += CandidateBonus[((s >> 3) ^ (Us * 7))];              }
Magic Number,Portfish,PawnTable,C:\repos\bpfliegel_Portfish\src\PawnInfo.cs,evaluate_pawns,The following statement contains a magic number: while ((s = pl[plPos++]) != SquareC.SQ_NONE)              {                  Debug.Assert(pos.piece_on(s) == Utils.make_piece(Us' PieceTypeC.PAWN));                    f = (s & 7);                  r = (s >> 3);                    // This file cannot be half open                  if (Us == ColorC.WHITE)                  {                      e.halfOpenFilesWHITE &= ~(1 << f);                  }                  else                  {                      e.halfOpenFilesBLACK &= ~(1 << f);                  }                    // Our rank plus previous one. Used for chain detection                  b = Utils.RankBB[r] | Utils.RankBB[Us == ColorC.WHITE ? r - 1 : r + 1];                    // Flag the pawn as passed' isolated' doubled or member of a pawn                  // chain (but not the backward one).                  chain = (ourPawns & Utils.AdjacentFilesBB[f] & b) != 0;                  isolated = (ourPawns & Utils.AdjacentFilesBB[f]) == 0;                  doubled = (ourPawns & Utils.ForwardBB[Us][s]) != 0;                  opposed = (theirPawns & Utils.ForwardBB[Us][s]) != 0;                  passed = (theirPawns & Utils.PassedPawnMask[Us][s]) == 0;                    // Test for backward pawn                  backward = false;                    // If the pawn is passed' isolated' or member of a pawn chain it cannot                  // be backward. If there are friendly pawns behind on adjacent files                  // or if can capture an enemy pawn it cannot be backward either.                  if (!(passed | isolated | chain)                      && (((ourPawns & Utils.AttackSpanMask[Them][s])) == 0)                      && ((((Utils.StepAttacksBB[((Us << 3) | PieceTypeC.PAWN)][s]) & theirPawns)) == 0))                  {                      // We now know that there are no friendly pawns beside or behind this                      // pawn on adjacent files. We now check whether the pawn is                      // backward by looking in the forward direction on the adjacent                      // files' and seeing whether we meet a friendly or an enemy pawn first.                      b = Utils.StepAttacksBB[((Us << 3) | PieceTypeC.PAWN)][s];                        // Note that we are sure to find something because pawn is not passed                      // nor isolated' so loop is potentially infinite' but it isn't.                      while ((b & (ourPawns | theirPawns)) == 0)                      {                          if (Us == ColorC.WHITE) { b <<= 8; } else { b >>= 8; }                      }                        // The friendly pawn needs to be at least two ranks closer than the                      // enemy pawn in order to help the potentially backward pawn advance.                      backward = (((b | (Us == ColorC.WHITE ? b << 8 : b >> 8)) & theirPawns) != 0);                  }                    Debug.Assert(opposed | passed | (((Utils.AttackSpanMask[Us][s] & theirPawns)) != 0));                    // A not passed pawn is a candidate to become passed if it is free to                  // advance and if the number of friendly pawns beside or behind this                  // pawn on adjacent files is higher or equal than the number of                  // enemy pawns in the forward direction on the adjacent files.                  candidate = !(opposed | passed | backward | isolated)                             && (b = Utils.AttackSpanMask[Them][s + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)] & ourPawns) != 0                             && Bitcount.popcount_1s_Max15(b) >= Bitcount.popcount_1s_Max15(Utils.AttackSpanMask[Us][s] & theirPawns);                    // Passed pawns will be properly scored in evaluation because we need                  // full attack info to evaluate passed pawns. Only the frontmost passed                  // pawn on each file is considered a true passed pawn.                  if (passed && !doubled)                  {                      if (Us == ColorC.WHITE)                      {                          e.passedPawnsWHITE |= Utils.SquareBB[s];                      }                      else                      {                          e.passedPawnsBLACK |= Utils.SquareBB[s];                      }                  }                    // Score this pawn                  if (isolated)                      value -= IsolatedPawnPenalty[opposed ? 1 : 0][f];                    if (doubled)                      value -= DoubledPawnPenalty[opposed ? 1 : 0][f];                    if (backward)                      value -= BackwardPawnPenalty[opposed ? 1 : 0][f];                    if (chain)                      value += ChainBonus[f];                    if (candidate)                      value += CandidateBonus[((s >> 3) ^ (Us * 7))];              }
Magic Number,Portfish,PawnTable,C:\repos\bpfliegel_Portfish\src\PawnInfo.cs,evaluate_pawns,The following statement contains a magic number: while ((s = pl[plPos++]) != SquareC.SQ_NONE)              {                  Debug.Assert(pos.piece_on(s) == Utils.make_piece(Us' PieceTypeC.PAWN));                    f = (s & 7);                  r = (s >> 3);                    // This file cannot be half open                  if (Us == ColorC.WHITE)                  {                      e.halfOpenFilesWHITE &= ~(1 << f);                  }                  else                  {                      e.halfOpenFilesBLACK &= ~(1 << f);                  }                    // Our rank plus previous one. Used for chain detection                  b = Utils.RankBB[r] | Utils.RankBB[Us == ColorC.WHITE ? r - 1 : r + 1];                    // Flag the pawn as passed' isolated' doubled or member of a pawn                  // chain (but not the backward one).                  chain = (ourPawns & Utils.AdjacentFilesBB[f] & b) != 0;                  isolated = (ourPawns & Utils.AdjacentFilesBB[f]) == 0;                  doubled = (ourPawns & Utils.ForwardBB[Us][s]) != 0;                  opposed = (theirPawns & Utils.ForwardBB[Us][s]) != 0;                  passed = (theirPawns & Utils.PassedPawnMask[Us][s]) == 0;                    // Test for backward pawn                  backward = false;                    // If the pawn is passed' isolated' or member of a pawn chain it cannot                  // be backward. If there are friendly pawns behind on adjacent files                  // or if can capture an enemy pawn it cannot be backward either.                  if (!(passed | isolated | chain)                      && (((ourPawns & Utils.AttackSpanMask[Them][s])) == 0)                      && ((((Utils.StepAttacksBB[((Us << 3) | PieceTypeC.PAWN)][s]) & theirPawns)) == 0))                  {                      // We now know that there are no friendly pawns beside or behind this                      // pawn on adjacent files. We now check whether the pawn is                      // backward by looking in the forward direction on the adjacent                      // files' and seeing whether we meet a friendly or an enemy pawn first.                      b = Utils.StepAttacksBB[((Us << 3) | PieceTypeC.PAWN)][s];                        // Note that we are sure to find something because pawn is not passed                      // nor isolated' so loop is potentially infinite' but it isn't.                      while ((b & (ourPawns | theirPawns)) == 0)                      {                          if (Us == ColorC.WHITE) { b <<= 8; } else { b >>= 8; }                      }                        // The friendly pawn needs to be at least two ranks closer than the                      // enemy pawn in order to help the potentially backward pawn advance.                      backward = (((b | (Us == ColorC.WHITE ? b << 8 : b >> 8)) & theirPawns) != 0);                  }                    Debug.Assert(opposed | passed | (((Utils.AttackSpanMask[Us][s] & theirPawns)) != 0));                    // A not passed pawn is a candidate to become passed if it is free to                  // advance and if the number of friendly pawns beside or behind this                  // pawn on adjacent files is higher or equal than the number of                  // enemy pawns in the forward direction on the adjacent files.                  candidate = !(opposed | passed | backward | isolated)                             && (b = Utils.AttackSpanMask[Them][s + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)] & ourPawns) != 0                             && Bitcount.popcount_1s_Max15(b) >= Bitcount.popcount_1s_Max15(Utils.AttackSpanMask[Us][s] & theirPawns);                    // Passed pawns will be properly scored in evaluation because we need                  // full attack info to evaluate passed pawns. Only the frontmost passed                  // pawn on each file is considered a true passed pawn.                  if (passed && !doubled)                  {                      if (Us == ColorC.WHITE)                      {                          e.passedPawnsWHITE |= Utils.SquareBB[s];                      }                      else                      {                          e.passedPawnsBLACK |= Utils.SquareBB[s];                      }                  }                    // Score this pawn                  if (isolated)                      value -= IsolatedPawnPenalty[opposed ? 1 : 0][f];                    if (doubled)                      value -= DoubledPawnPenalty[opposed ? 1 : 0][f];                    if (backward)                      value -= BackwardPawnPenalty[opposed ? 1 : 0][f];                    if (chain)                      value += ChainBonus[f];                    if (candidate)                      value += CandidateBonus[((s >> 3) ^ (Us * 7))];              }
Magic Number,Portfish,PawnTable,C:\repos\bpfliegel_Portfish\src\PawnInfo.cs,evaluate_pawns,The following statement contains a magic number: while ((s = pl[plPos++]) != SquareC.SQ_NONE)              {                  Debug.Assert(pos.piece_on(s) == Utils.make_piece(Us' PieceTypeC.PAWN));                    f = (s & 7);                  r = (s >> 3);                    // This file cannot be half open                  if (Us == ColorC.WHITE)                  {                      e.halfOpenFilesWHITE &= ~(1 << f);                  }                  else                  {                      e.halfOpenFilesBLACK &= ~(1 << f);                  }                    // Our rank plus previous one. Used for chain detection                  b = Utils.RankBB[r] | Utils.RankBB[Us == ColorC.WHITE ? r - 1 : r + 1];                    // Flag the pawn as passed' isolated' doubled or member of a pawn                  // chain (but not the backward one).                  chain = (ourPawns & Utils.AdjacentFilesBB[f] & b) != 0;                  isolated = (ourPawns & Utils.AdjacentFilesBB[f]) == 0;                  doubled = (ourPawns & Utils.ForwardBB[Us][s]) != 0;                  opposed = (theirPawns & Utils.ForwardBB[Us][s]) != 0;                  passed = (theirPawns & Utils.PassedPawnMask[Us][s]) == 0;                    // Test for backward pawn                  backward = false;                    // If the pawn is passed' isolated' or member of a pawn chain it cannot                  // be backward. If there are friendly pawns behind on adjacent files                  // or if can capture an enemy pawn it cannot be backward either.                  if (!(passed | isolated | chain)                      && (((ourPawns & Utils.AttackSpanMask[Them][s])) == 0)                      && ((((Utils.StepAttacksBB[((Us << 3) | PieceTypeC.PAWN)][s]) & theirPawns)) == 0))                  {                      // We now know that there are no friendly pawns beside or behind this                      // pawn on adjacent files. We now check whether the pawn is                      // backward by looking in the forward direction on the adjacent                      // files' and seeing whether we meet a friendly or an enemy pawn first.                      b = Utils.StepAttacksBB[((Us << 3) | PieceTypeC.PAWN)][s];                        // Note that we are sure to find something because pawn is not passed                      // nor isolated' so loop is potentially infinite' but it isn't.                      while ((b & (ourPawns | theirPawns)) == 0)                      {                          if (Us == ColorC.WHITE) { b <<= 8; } else { b >>= 8; }                      }                        // The friendly pawn needs to be at least two ranks closer than the                      // enemy pawn in order to help the potentially backward pawn advance.                      backward = (((b | (Us == ColorC.WHITE ? b << 8 : b >> 8)) & theirPawns) != 0);                  }                    Debug.Assert(opposed | passed | (((Utils.AttackSpanMask[Us][s] & theirPawns)) != 0));                    // A not passed pawn is a candidate to become passed if it is free to                  // advance and if the number of friendly pawns beside or behind this                  // pawn on adjacent files is higher or equal than the number of                  // enemy pawns in the forward direction on the adjacent files.                  candidate = !(opposed | passed | backward | isolated)                             && (b = Utils.AttackSpanMask[Them][s + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)] & ourPawns) != 0                             && Bitcount.popcount_1s_Max15(b) >= Bitcount.popcount_1s_Max15(Utils.AttackSpanMask[Us][s] & theirPawns);                    // Passed pawns will be properly scored in evaluation because we need                  // full attack info to evaluate passed pawns. Only the frontmost passed                  // pawn on each file is considered a true passed pawn.                  if (passed && !doubled)                  {                      if (Us == ColorC.WHITE)                      {                          e.passedPawnsWHITE |= Utils.SquareBB[s];                      }                      else                      {                          e.passedPawnsBLACK |= Utils.SquareBB[s];                      }                  }                    // Score this pawn                  if (isolated)                      value -= IsolatedPawnPenalty[opposed ? 1 : 0][f];                    if (doubled)                      value -= DoubledPawnPenalty[opposed ? 1 : 0][f];                    if (backward)                      value -= BackwardPawnPenalty[opposed ? 1 : 0][f];                    if (chain)                      value += ChainBonus[f];                    if (candidate)                      value += CandidateBonus[((s >> 3) ^ (Us * 7))];              }
Magic Number,Portfish,PawnTable,C:\repos\bpfliegel_Portfish\src\PawnInfo.cs,evaluate_pawns,The following statement contains a magic number: while ((s = pl[plPos++]) != SquareC.SQ_NONE)              {                  Debug.Assert(pos.piece_on(s) == Utils.make_piece(Us' PieceTypeC.PAWN));                    f = (s & 7);                  r = (s >> 3);                    // This file cannot be half open                  if (Us == ColorC.WHITE)                  {                      e.halfOpenFilesWHITE &= ~(1 << f);                  }                  else                  {                      e.halfOpenFilesBLACK &= ~(1 << f);                  }                    // Our rank plus previous one. Used for chain detection                  b = Utils.RankBB[r] | Utils.RankBB[Us == ColorC.WHITE ? r - 1 : r + 1];                    // Flag the pawn as passed' isolated' doubled or member of a pawn                  // chain (but not the backward one).                  chain = (ourPawns & Utils.AdjacentFilesBB[f] & b) != 0;                  isolated = (ourPawns & Utils.AdjacentFilesBB[f]) == 0;                  doubled = (ourPawns & Utils.ForwardBB[Us][s]) != 0;                  opposed = (theirPawns & Utils.ForwardBB[Us][s]) != 0;                  passed = (theirPawns & Utils.PassedPawnMask[Us][s]) == 0;                    // Test for backward pawn                  backward = false;                    // If the pawn is passed' isolated' or member of a pawn chain it cannot                  // be backward. If there are friendly pawns behind on adjacent files                  // or if can capture an enemy pawn it cannot be backward either.                  if (!(passed | isolated | chain)                      && (((ourPawns & Utils.AttackSpanMask[Them][s])) == 0)                      && ((((Utils.StepAttacksBB[((Us << 3) | PieceTypeC.PAWN)][s]) & theirPawns)) == 0))                  {                      // We now know that there are no friendly pawns beside or behind this                      // pawn on adjacent files. We now check whether the pawn is                      // backward by looking in the forward direction on the adjacent                      // files' and seeing whether we meet a friendly or an enemy pawn first.                      b = Utils.StepAttacksBB[((Us << 3) | PieceTypeC.PAWN)][s];                        // Note that we are sure to find something because pawn is not passed                      // nor isolated' so loop is potentially infinite' but it isn't.                      while ((b & (ourPawns | theirPawns)) == 0)                      {                          if (Us == ColorC.WHITE) { b <<= 8; } else { b >>= 8; }                      }                        // The friendly pawn needs to be at least two ranks closer than the                      // enemy pawn in order to help the potentially backward pawn advance.                      backward = (((b | (Us == ColorC.WHITE ? b << 8 : b >> 8)) & theirPawns) != 0);                  }                    Debug.Assert(opposed | passed | (((Utils.AttackSpanMask[Us][s] & theirPawns)) != 0));                    // A not passed pawn is a candidate to become passed if it is free to                  // advance and if the number of friendly pawns beside or behind this                  // pawn on adjacent files is higher or equal than the number of                  // enemy pawns in the forward direction on the adjacent files.                  candidate = !(opposed | passed | backward | isolated)                             && (b = Utils.AttackSpanMask[Them][s + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)] & ourPawns) != 0                             && Bitcount.popcount_1s_Max15(b) >= Bitcount.popcount_1s_Max15(Utils.AttackSpanMask[Us][s] & theirPawns);                    // Passed pawns will be properly scored in evaluation because we need                  // full attack info to evaluate passed pawns. Only the frontmost passed                  // pawn on each file is considered a true passed pawn.                  if (passed && !doubled)                  {                      if (Us == ColorC.WHITE)                      {                          e.passedPawnsWHITE |= Utils.SquareBB[s];                      }                      else                      {                          e.passedPawnsBLACK |= Utils.SquareBB[s];                      }                  }                    // Score this pawn                  if (isolated)                      value -= IsolatedPawnPenalty[opposed ? 1 : 0][f];                    if (doubled)                      value -= DoubledPawnPenalty[opposed ? 1 : 0][f];                    if (backward)                      value -= BackwardPawnPenalty[opposed ? 1 : 0][f];                    if (chain)                      value += ChainBonus[f];                    if (candidate)                      value += CandidateBonus[((s >> 3) ^ (Us * 7))];              }
Magic Number,Portfish,PawnTable,C:\repos\bpfliegel_Portfish\src\PawnInfo.cs,evaluate_pawns,The following statement contains a magic number: while ((s = pl[plPos++]) != SquareC.SQ_NONE)              {                  Debug.Assert(pos.piece_on(s) == Utils.make_piece(Us' PieceTypeC.PAWN));                    f = (s & 7);                  r = (s >> 3);                    // This file cannot be half open                  if (Us == ColorC.WHITE)                  {                      e.halfOpenFilesWHITE &= ~(1 << f);                  }                  else                  {                      e.halfOpenFilesBLACK &= ~(1 << f);                  }                    // Our rank plus previous one. Used for chain detection                  b = Utils.RankBB[r] | Utils.RankBB[Us == ColorC.WHITE ? r - 1 : r + 1];                    // Flag the pawn as passed' isolated' doubled or member of a pawn                  // chain (but not the backward one).                  chain = (ourPawns & Utils.AdjacentFilesBB[f] & b) != 0;                  isolated = (ourPawns & Utils.AdjacentFilesBB[f]) == 0;                  doubled = (ourPawns & Utils.ForwardBB[Us][s]) != 0;                  opposed = (theirPawns & Utils.ForwardBB[Us][s]) != 0;                  passed = (theirPawns & Utils.PassedPawnMask[Us][s]) == 0;                    // Test for backward pawn                  backward = false;                    // If the pawn is passed' isolated' or member of a pawn chain it cannot                  // be backward. If there are friendly pawns behind on adjacent files                  // or if can capture an enemy pawn it cannot be backward either.                  if (!(passed | isolated | chain)                      && (((ourPawns & Utils.AttackSpanMask[Them][s])) == 0)                      && ((((Utils.StepAttacksBB[((Us << 3) | PieceTypeC.PAWN)][s]) & theirPawns)) == 0))                  {                      // We now know that there are no friendly pawns beside or behind this                      // pawn on adjacent files. We now check whether the pawn is                      // backward by looking in the forward direction on the adjacent                      // files' and seeing whether we meet a friendly or an enemy pawn first.                      b = Utils.StepAttacksBB[((Us << 3) | PieceTypeC.PAWN)][s];                        // Note that we are sure to find something because pawn is not passed                      // nor isolated' so loop is potentially infinite' but it isn't.                      while ((b & (ourPawns | theirPawns)) == 0)                      {                          if (Us == ColorC.WHITE) { b <<= 8; } else { b >>= 8; }                      }                        // The friendly pawn needs to be at least two ranks closer than the                      // enemy pawn in order to help the potentially backward pawn advance.                      backward = (((b | (Us == ColorC.WHITE ? b << 8 : b >> 8)) & theirPawns) != 0);                  }                    Debug.Assert(opposed | passed | (((Utils.AttackSpanMask[Us][s] & theirPawns)) != 0));                    // A not passed pawn is a candidate to become passed if it is free to                  // advance and if the number of friendly pawns beside or behind this                  // pawn on adjacent files is higher or equal than the number of                  // enemy pawns in the forward direction on the adjacent files.                  candidate = !(opposed | passed | backward | isolated)                             && (b = Utils.AttackSpanMask[Them][s + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)] & ourPawns) != 0                             && Bitcount.popcount_1s_Max15(b) >= Bitcount.popcount_1s_Max15(Utils.AttackSpanMask[Us][s] & theirPawns);                    // Passed pawns will be properly scored in evaluation because we need                  // full attack info to evaluate passed pawns. Only the frontmost passed                  // pawn on each file is considered a true passed pawn.                  if (passed && !doubled)                  {                      if (Us == ColorC.WHITE)                      {                          e.passedPawnsWHITE |= Utils.SquareBB[s];                      }                      else                      {                          e.passedPawnsBLACK |= Utils.SquareBB[s];                      }                  }                    // Score this pawn                  if (isolated)                      value -= IsolatedPawnPenalty[opposed ? 1 : 0][f];                    if (doubled)                      value -= DoubledPawnPenalty[opposed ? 1 : 0][f];                    if (backward)                      value -= BackwardPawnPenalty[opposed ? 1 : 0][f];                    if (chain)                      value += ChainBonus[f];                    if (candidate)                      value += CandidateBonus[((s >> 3) ^ (Us * 7))];              }
Magic Number,Portfish,PawnTable,C:\repos\bpfliegel_Portfish\src\PawnInfo.cs,evaluate_pawns,The following statement contains a magic number: while ((s = pl[plPos++]) != SquareC.SQ_NONE)              {                  Debug.Assert(pos.piece_on(s) == Utils.make_piece(Us' PieceTypeC.PAWN));                    f = (s & 7);                  r = (s >> 3);                    // This file cannot be half open                  if (Us == ColorC.WHITE)                  {                      e.halfOpenFilesWHITE &= ~(1 << f);                  }                  else                  {                      e.halfOpenFilesBLACK &= ~(1 << f);                  }                    // Our rank plus previous one. Used for chain detection                  b = Utils.RankBB[r] | Utils.RankBB[Us == ColorC.WHITE ? r - 1 : r + 1];                    // Flag the pawn as passed' isolated' doubled or member of a pawn                  // chain (but not the backward one).                  chain = (ourPawns & Utils.AdjacentFilesBB[f] & b) != 0;                  isolated = (ourPawns & Utils.AdjacentFilesBB[f]) == 0;                  doubled = (ourPawns & Utils.ForwardBB[Us][s]) != 0;                  opposed = (theirPawns & Utils.ForwardBB[Us][s]) != 0;                  passed = (theirPawns & Utils.PassedPawnMask[Us][s]) == 0;                    // Test for backward pawn                  backward = false;                    // If the pawn is passed' isolated' or member of a pawn chain it cannot                  // be backward. If there are friendly pawns behind on adjacent files                  // or if can capture an enemy pawn it cannot be backward either.                  if (!(passed | isolated | chain)                      && (((ourPawns & Utils.AttackSpanMask[Them][s])) == 0)                      && ((((Utils.StepAttacksBB[((Us << 3) | PieceTypeC.PAWN)][s]) & theirPawns)) == 0))                  {                      // We now know that there are no friendly pawns beside or behind this                      // pawn on adjacent files. We now check whether the pawn is                      // backward by looking in the forward direction on the adjacent                      // files' and seeing whether we meet a friendly or an enemy pawn first.                      b = Utils.StepAttacksBB[((Us << 3) | PieceTypeC.PAWN)][s];                        // Note that we are sure to find something because pawn is not passed                      // nor isolated' so loop is potentially infinite' but it isn't.                      while ((b & (ourPawns | theirPawns)) == 0)                      {                          if (Us == ColorC.WHITE) { b <<= 8; } else { b >>= 8; }                      }                        // The friendly pawn needs to be at least two ranks closer than the                      // enemy pawn in order to help the potentially backward pawn advance.                      backward = (((b | (Us == ColorC.WHITE ? b << 8 : b >> 8)) & theirPawns) != 0);                  }                    Debug.Assert(opposed | passed | (((Utils.AttackSpanMask[Us][s] & theirPawns)) != 0));                    // A not passed pawn is a candidate to become passed if it is free to                  // advance and if the number of friendly pawns beside or behind this                  // pawn on adjacent files is higher or equal than the number of                  // enemy pawns in the forward direction on the adjacent files.                  candidate = !(opposed | passed | backward | isolated)                             && (b = Utils.AttackSpanMask[Them][s + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)] & ourPawns) != 0                             && Bitcount.popcount_1s_Max15(b) >= Bitcount.popcount_1s_Max15(Utils.AttackSpanMask[Us][s] & theirPawns);                    // Passed pawns will be properly scored in evaluation because we need                  // full attack info to evaluate passed pawns. Only the frontmost passed                  // pawn on each file is considered a true passed pawn.                  if (passed && !doubled)                  {                      if (Us == ColorC.WHITE)                      {                          e.passedPawnsWHITE |= Utils.SquareBB[s];                      }                      else                      {                          e.passedPawnsBLACK |= Utils.SquareBB[s];                      }                  }                    // Score this pawn                  if (isolated)                      value -= IsolatedPawnPenalty[opposed ? 1 : 0][f];                    if (doubled)                      value -= DoubledPawnPenalty[opposed ? 1 : 0][f];                    if (backward)                      value -= BackwardPawnPenalty[opposed ? 1 : 0][f];                    if (chain)                      value += ChainBonus[f];                    if (candidate)                      value += CandidateBonus[((s >> 3) ^ (Us * 7))];              }
Magic Number,Portfish,PawnTable,C:\repos\bpfliegel_Portfish\src\PawnInfo.cs,evaluate_pawns,The following statement contains a magic number: while ((s = pl[plPos++]) != SquareC.SQ_NONE)              {                  Debug.Assert(pos.piece_on(s) == Utils.make_piece(Us' PieceTypeC.PAWN));                    f = (s & 7);                  r = (s >> 3);                    // This file cannot be half open                  if (Us == ColorC.WHITE)                  {                      e.halfOpenFilesWHITE &= ~(1 << f);                  }                  else                  {                      e.halfOpenFilesBLACK &= ~(1 << f);                  }                    // Our rank plus previous one. Used for chain detection                  b = Utils.RankBB[r] | Utils.RankBB[Us == ColorC.WHITE ? r - 1 : r + 1];                    // Flag the pawn as passed' isolated' doubled or member of a pawn                  // chain (but not the backward one).                  chain = (ourPawns & Utils.AdjacentFilesBB[f] & b) != 0;                  isolated = (ourPawns & Utils.AdjacentFilesBB[f]) == 0;                  doubled = (ourPawns & Utils.ForwardBB[Us][s]) != 0;                  opposed = (theirPawns & Utils.ForwardBB[Us][s]) != 0;                  passed = (theirPawns & Utils.PassedPawnMask[Us][s]) == 0;                    // Test for backward pawn                  backward = false;                    // If the pawn is passed' isolated' or member of a pawn chain it cannot                  // be backward. If there are friendly pawns behind on adjacent files                  // or if can capture an enemy pawn it cannot be backward either.                  if (!(passed | isolated | chain)                      && (((ourPawns & Utils.AttackSpanMask[Them][s])) == 0)                      && ((((Utils.StepAttacksBB[((Us << 3) | PieceTypeC.PAWN)][s]) & theirPawns)) == 0))                  {                      // We now know that there are no friendly pawns beside or behind this                      // pawn on adjacent files. We now check whether the pawn is                      // backward by looking in the forward direction on the adjacent                      // files' and seeing whether we meet a friendly or an enemy pawn first.                      b = Utils.StepAttacksBB[((Us << 3) | PieceTypeC.PAWN)][s];                        // Note that we are sure to find something because pawn is not passed                      // nor isolated' so loop is potentially infinite' but it isn't.                      while ((b & (ourPawns | theirPawns)) == 0)                      {                          if (Us == ColorC.WHITE) { b <<= 8; } else { b >>= 8; }                      }                        // The friendly pawn needs to be at least two ranks closer than the                      // enemy pawn in order to help the potentially backward pawn advance.                      backward = (((b | (Us == ColorC.WHITE ? b << 8 : b >> 8)) & theirPawns) != 0);                  }                    Debug.Assert(opposed | passed | (((Utils.AttackSpanMask[Us][s] & theirPawns)) != 0));                    // A not passed pawn is a candidate to become passed if it is free to                  // advance and if the number of friendly pawns beside or behind this                  // pawn on adjacent files is higher or equal than the number of                  // enemy pawns in the forward direction on the adjacent files.                  candidate = !(opposed | passed | backward | isolated)                             && (b = Utils.AttackSpanMask[Them][s + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)] & ourPawns) != 0                             && Bitcount.popcount_1s_Max15(b) >= Bitcount.popcount_1s_Max15(Utils.AttackSpanMask[Us][s] & theirPawns);                    // Passed pawns will be properly scored in evaluation because we need                  // full attack info to evaluate passed pawns. Only the frontmost passed                  // pawn on each file is considered a true passed pawn.                  if (passed && !doubled)                  {                      if (Us == ColorC.WHITE)                      {                          e.passedPawnsWHITE |= Utils.SquareBB[s];                      }                      else                      {                          e.passedPawnsBLACK |= Utils.SquareBB[s];                      }                  }                    // Score this pawn                  if (isolated)                      value -= IsolatedPawnPenalty[opposed ? 1 : 0][f];                    if (doubled)                      value -= DoubledPawnPenalty[opposed ? 1 : 0][f];                    if (backward)                      value -= BackwardPawnPenalty[opposed ? 1 : 0][f];                    if (chain)                      value += ChainBonus[f];                    if (candidate)                      value += CandidateBonus[((s >> 3) ^ (Us * 7))];              }
Magic Number,Portfish,PawnTable,C:\repos\bpfliegel_Portfish\src\PawnInfo.cs,evaluate_pawns,The following statement contains a magic number: while ((s = pl[plPos++]) != SquareC.SQ_NONE)              {                  Debug.Assert(pos.piece_on(s) == Utils.make_piece(Us' PieceTypeC.PAWN));                    f = (s & 7);                  r = (s >> 3);                    // This file cannot be half open                  if (Us == ColorC.WHITE)                  {                      e.halfOpenFilesWHITE &= ~(1 << f);                  }                  else                  {                      e.halfOpenFilesBLACK &= ~(1 << f);                  }                    // Our rank plus previous one. Used for chain detection                  b = Utils.RankBB[r] | Utils.RankBB[Us == ColorC.WHITE ? r - 1 : r + 1];                    // Flag the pawn as passed' isolated' doubled or member of a pawn                  // chain (but not the backward one).                  chain = (ourPawns & Utils.AdjacentFilesBB[f] & b) != 0;                  isolated = (ourPawns & Utils.AdjacentFilesBB[f]) == 0;                  doubled = (ourPawns & Utils.ForwardBB[Us][s]) != 0;                  opposed = (theirPawns & Utils.ForwardBB[Us][s]) != 0;                  passed = (theirPawns & Utils.PassedPawnMask[Us][s]) == 0;                    // Test for backward pawn                  backward = false;                    // If the pawn is passed' isolated' or member of a pawn chain it cannot                  // be backward. If there are friendly pawns behind on adjacent files                  // or if can capture an enemy pawn it cannot be backward either.                  if (!(passed | isolated | chain)                      && (((ourPawns & Utils.AttackSpanMask[Them][s])) == 0)                      && ((((Utils.StepAttacksBB[((Us << 3) | PieceTypeC.PAWN)][s]) & theirPawns)) == 0))                  {                      // We now know that there are no friendly pawns beside or behind this                      // pawn on adjacent files. We now check whether the pawn is                      // backward by looking in the forward direction on the adjacent                      // files' and seeing whether we meet a friendly or an enemy pawn first.                      b = Utils.StepAttacksBB[((Us << 3) | PieceTypeC.PAWN)][s];                        // Note that we are sure to find something because pawn is not passed                      // nor isolated' so loop is potentially infinite' but it isn't.                      while ((b & (ourPawns | theirPawns)) == 0)                      {                          if (Us == ColorC.WHITE) { b <<= 8; } else { b >>= 8; }                      }                        // The friendly pawn needs to be at least two ranks closer than the                      // enemy pawn in order to help the potentially backward pawn advance.                      backward = (((b | (Us == ColorC.WHITE ? b << 8 : b >> 8)) & theirPawns) != 0);                  }                    Debug.Assert(opposed | passed | (((Utils.AttackSpanMask[Us][s] & theirPawns)) != 0));                    // A not passed pawn is a candidate to become passed if it is free to                  // advance and if the number of friendly pawns beside or behind this                  // pawn on adjacent files is higher or equal than the number of                  // enemy pawns in the forward direction on the adjacent files.                  candidate = !(opposed | passed | backward | isolated)                             && (b = Utils.AttackSpanMask[Them][s + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)] & ourPawns) != 0                             && Bitcount.popcount_1s_Max15(b) >= Bitcount.popcount_1s_Max15(Utils.AttackSpanMask[Us][s] & theirPawns);                    // Passed pawns will be properly scored in evaluation because we need                  // full attack info to evaluate passed pawns. Only the frontmost passed                  // pawn on each file is considered a true passed pawn.                  if (passed && !doubled)                  {                      if (Us == ColorC.WHITE)                      {                          e.passedPawnsWHITE |= Utils.SquareBB[s];                      }                      else                      {                          e.passedPawnsBLACK |= Utils.SquareBB[s];                      }                  }                    // Score this pawn                  if (isolated)                      value -= IsolatedPawnPenalty[opposed ? 1 : 0][f];                    if (doubled)                      value -= DoubledPawnPenalty[opposed ? 1 : 0][f];                    if (backward)                      value -= BackwardPawnPenalty[opposed ? 1 : 0][f];                    if (chain)                      value += ChainBonus[f];                    if (candidate)                      value += CandidateBonus[((s >> 3) ^ (Us * 7))];              }
Magic Number,Portfish,PawnTable,C:\repos\bpfliegel_Portfish\src\PawnInfo.cs,evaluate_pawns,The following statement contains a magic number: while ((s = pl[plPos++]) != SquareC.SQ_NONE)              {                  Debug.Assert(pos.piece_on(s) == Utils.make_piece(Us' PieceTypeC.PAWN));                    f = (s & 7);                  r = (s >> 3);                    // This file cannot be half open                  if (Us == ColorC.WHITE)                  {                      e.halfOpenFilesWHITE &= ~(1 << f);                  }                  else                  {                      e.halfOpenFilesBLACK &= ~(1 << f);                  }                    // Our rank plus previous one. Used for chain detection                  b = Utils.RankBB[r] | Utils.RankBB[Us == ColorC.WHITE ? r - 1 : r + 1];                    // Flag the pawn as passed' isolated' doubled or member of a pawn                  // chain (but not the backward one).                  chain = (ourPawns & Utils.AdjacentFilesBB[f] & b) != 0;                  isolated = (ourPawns & Utils.AdjacentFilesBB[f]) == 0;                  doubled = (ourPawns & Utils.ForwardBB[Us][s]) != 0;                  opposed = (theirPawns & Utils.ForwardBB[Us][s]) != 0;                  passed = (theirPawns & Utils.PassedPawnMask[Us][s]) == 0;                    // Test for backward pawn                  backward = false;                    // If the pawn is passed' isolated' or member of a pawn chain it cannot                  // be backward. If there are friendly pawns behind on adjacent files                  // or if can capture an enemy pawn it cannot be backward either.                  if (!(passed | isolated | chain)                      && (((ourPawns & Utils.AttackSpanMask[Them][s])) == 0)                      && ((((Utils.StepAttacksBB[((Us << 3) | PieceTypeC.PAWN)][s]) & theirPawns)) == 0))                  {                      // We now know that there are no friendly pawns beside or behind this                      // pawn on adjacent files. We now check whether the pawn is                      // backward by looking in the forward direction on the adjacent                      // files' and seeing whether we meet a friendly or an enemy pawn first.                      b = Utils.StepAttacksBB[((Us << 3) | PieceTypeC.PAWN)][s];                        // Note that we are sure to find something because pawn is not passed                      // nor isolated' so loop is potentially infinite' but it isn't.                      while ((b & (ourPawns | theirPawns)) == 0)                      {                          if (Us == ColorC.WHITE) { b <<= 8; } else { b >>= 8; }                      }                        // The friendly pawn needs to be at least two ranks closer than the                      // enemy pawn in order to help the potentially backward pawn advance.                      backward = (((b | (Us == ColorC.WHITE ? b << 8 : b >> 8)) & theirPawns) != 0);                  }                    Debug.Assert(opposed | passed | (((Utils.AttackSpanMask[Us][s] & theirPawns)) != 0));                    // A not passed pawn is a candidate to become passed if it is free to                  // advance and if the number of friendly pawns beside or behind this                  // pawn on adjacent files is higher or equal than the number of                  // enemy pawns in the forward direction on the adjacent files.                  candidate = !(opposed | passed | backward | isolated)                             && (b = Utils.AttackSpanMask[Them][s + (Us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)] & ourPawns) != 0                             && Bitcount.popcount_1s_Max15(b) >= Bitcount.popcount_1s_Max15(Utils.AttackSpanMask[Us][s] & theirPawns);                    // Passed pawns will be properly scored in evaluation because we need                  // full attack info to evaluate passed pawns. Only the frontmost passed                  // pawn on each file is considered a true passed pawn.                  if (passed && !doubled)                  {                      if (Us == ColorC.WHITE)                      {                          e.passedPawnsWHITE |= Utils.SquareBB[s];                      }                      else                      {                          e.passedPawnsBLACK |= Utils.SquareBB[s];                      }                  }                    // Score this pawn                  if (isolated)                      value -= IsolatedPawnPenalty[opposed ? 1 : 0][f];                    if (doubled)                      value -= DoubledPawnPenalty[opposed ? 1 : 0][f];                    if (backward)                      value -= BackwardPawnPenalty[opposed ? 1 : 0][f];                    if (chain)                      value += ChainBonus[f];                    if (candidate)                      value += CandidateBonus[((s >> 3) ^ (Us * 7))];              }
Magic Number,Portfish,CheckInfo,C:\repos\bpfliegel_Portfish\src\Position.cs,CreateCheckInfo,The following statement contains a magic number: checkSq[PieceTypeC.PAWN] = Utils.StepAttacksBB[((them << 3) | PieceTypeC.PAWN)][ksq];
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,piece_moved,The following statement contains a magic number: return board[((m >> 6) & 0x3F)];
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,attacks_from_PAWN,The following statement contains a magic number: return Utils.StepAttacksBB[((c << 3) | PieceTypeC.PAWN)][s];
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,attackers_to,The following statement contains a magic number: return ((Utils.StepAttacksBB[((ColorC.BLACK << 3) | PieceTypeC.PAWN)][s]) & (byTypeBB[PieceTypeC.PAWN] & byColorBB[ColorC.WHITE]))                    | ((Utils.StepAttacksBB[((ColorC.WHITE << 3) | PieceTypeC.PAWN)][s]) & (byTypeBB[PieceTypeC.PAWN] & byColorBB[ColorC.BLACK]))                    | (Utils.StepAttacksBB[PieceTypeC.KNIGHT][s] & byTypeBB[PieceTypeC.KNIGHT])                    | ((Utils.RAttacks[s][(((occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])]) & (byTypeBB[PieceTypeC.ROOK] | byTypeBB[PieceTypeC.QUEEN]))                    | ((Utils.BAttacks[s][(((occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])]) & (byTypeBB[PieceTypeC.BISHOP] | byTypeBB[PieceTypeC.QUEEN]))                    | (Utils.StepAttacksBB[PieceTypeC.KING][s] & byTypeBB[PieceTypeC.KING]);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,attackers_to,The following statement contains a magic number: return ((Utils.StepAttacksBB[((ColorC.BLACK << 3) | PieceTypeC.PAWN)][s]) & (byTypeBB[PieceTypeC.PAWN] & byColorBB[ColorC.WHITE]))                    | ((Utils.StepAttacksBB[((ColorC.WHITE << 3) | PieceTypeC.PAWN)][s]) & (byTypeBB[PieceTypeC.PAWN] & byColorBB[ColorC.BLACK]))                    | (Utils.StepAttacksBB[PieceTypeC.KNIGHT][s] & byTypeBB[PieceTypeC.KNIGHT])                    | ((Utils.RAttacks[s][(((occupied_squares & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])]) & (byTypeBB[PieceTypeC.ROOK] | byTypeBB[PieceTypeC.QUEEN]))                    | ((Utils.BAttacks[s][(((occupied_squares & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])]) & (byTypeBB[PieceTypeC.BISHOP] | byTypeBB[PieceTypeC.QUEEN]))                    | (Utils.StepAttacksBB[PieceTypeC.KING][s] & byTypeBB[PieceTypeC.KING]);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,attackers_to,The following statement contains a magic number: return ((Utils.StepAttacksBB[((ColorC.BLACK << 3) | PieceTypeC.PAWN)][s]) & (byTypeBB[PieceTypeC.PAWN] & byColorBB[ColorC.WHITE]))                    | ((Utils.StepAttacksBB[((ColorC.WHITE << 3) | PieceTypeC.PAWN)][s]) & (byTypeBB[PieceTypeC.PAWN] & byColorBB[ColorC.BLACK]))                    | (Utils.StepAttacksBB[PieceTypeC.KNIGHT][s] & byTypeBB[PieceTypeC.KNIGHT])                    | ((Utils.RAttacks[s][(((occ & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])]) & (byTypeBB[PieceTypeC.ROOK] | byTypeBB[PieceTypeC.QUEEN]))                    | ((Utils.BAttacks[s][(((occ & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])]) & (byTypeBB[PieceTypeC.BISHOP] | byTypeBB[PieceTypeC.QUEEN]))                    | (Utils.StepAttacksBB[PieceTypeC.KING][s] & byTypeBB[PieceTypeC.KING]);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,attackers_to,The following statement contains a magic number: return ((Utils.StepAttacksBB[((ColorC.BLACK << 3) | PieceTypeC.PAWN)][s]) & (byTypeBB[PieceTypeC.PAWN] & byColorBB[ColorC.WHITE]))                    | ((Utils.StepAttacksBB[((ColorC.WHITE << 3) | PieceTypeC.PAWN)][s]) & (byTypeBB[PieceTypeC.PAWN] & byColorBB[ColorC.BLACK]))                    | (Utils.StepAttacksBB[PieceTypeC.KNIGHT][s] & byTypeBB[PieceTypeC.KNIGHT])                    | ((Utils.RAttacks[s][(((occ & Utils.RMasks[s]) * Utils.RMagics[s]) >> Utils.RShifts[s])]) & (byTypeBB[PieceTypeC.ROOK] | byTypeBB[PieceTypeC.QUEEN]))                    | ((Utils.BAttacks[s][(((occ & Utils.BMasks[s]) * Utils.BMagics[s]) >> Utils.BShifts[s])]) & (byTypeBB[PieceTypeC.BISHOP] | byTypeBB[PieceTypeC.QUEEN]))                    | (Utils.StepAttacksBB[PieceTypeC.KING][s] & byTypeBB[PieceTypeC.KING]);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,discovered_check_candidates,The following statement contains a magic number: while (pinners != 0)              {  #if X64                  Bitboard bb = pinners;                  pinners &= (pinners - 1);                  b = (Utils.BetweenBB[ksq][(Utils.BSFTable[((bb & (0xffffffffffffffff - bb + 1)) * 0x218A392CD3D5DBFUL) >> 58])]) & occupied_squares;  #else                  b = (Utils.BetweenBB[ksq][Utils.pop_1st_bit(ref pinners)]) & occupied_squares;  #endif                  // Only one bit set and is an our piece?                  if ((b != 0) && ((b & (b - 1)) == 0) && ((b & byColorBB[sideToMove]) != 0))                  {                      result |= b;                  }              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,pinned_pieces,The following statement contains a magic number: while (pinners != 0)              {  #if X64                  Bitboard bb = pinners;                  pinners &= (pinners - 1);                  b = (Utils.BetweenBB[ksq][(Utils.BSFTable[((bb & (0xffffffffffffffff - bb + 1)) * 0x218A392CD3D5DBFUL) >> 58])]) & occupied_squares;  #else                  b = (Utils.BetweenBB[ksq][Utils.pop_1st_bit(ref pinners)]) & occupied_squares;  #endif                  // Only one bit set and is an our piece?                  if ((b != 0) && ((b & (b - 1)) == 0) && ((b & byColorBB[sideToMove]) != 0))                  {                      result |= b;                  }              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,is_passed_pawn_push,The following statement contains a magic number: return (board[((m >> 6) & 0x3F)] & 7) == PieceTypeC.PAWN                  && (((byTypeBB[PieceTypeC.PAWN] & byColorBB[sideToMove ^ 1]) & Utils.PassedPawnMask[sideToMove][m & 0x3F]) == 0);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,is_passed_pawn_push,The following statement contains a magic number: return (board[((m >> 6) & 0x3F)] & 7) == PieceTypeC.PAWN                  && (((byTypeBB[PieceTypeC.PAWN] & byColorBB[sideToMove ^ 1]) & Utils.PassedPawnMask[sideToMove][m & 0x3F]) == 0);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,bishop_pair,The following statement contains a magic number: return pieceCount[c][PieceTypeC.BISHOP] >= 2 &&                      Utils.opposite_colors(pieceList[c][PieceTypeC.BISHOP][0]' pieceList[c][PieceTypeC.BISHOP][1]);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,is_capture_or_promotion,The following statement contains a magic number: return ((m & (3 << 14)) != 0) ? ((m & (3 << 14)) != (3 << 14)) : (board[m & 0x3F] != PieceC.NO_PIECE);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,is_capture_or_promotion,The following statement contains a magic number: return ((m & (3 << 14)) != 0) ? ((m & (3 << 14)) != (3 << 14)) : (board[m & 0x3F] != PieceC.NO_PIECE);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,is_capture_or_promotion,The following statement contains a magic number: return ((m & (3 << 14)) != 0) ? ((m & (3 << 14)) != (3 << 14)) : (board[m & 0x3F] != PieceC.NO_PIECE);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,is_capture_or_promotion,The following statement contains a magic number: return ((m & (3 << 14)) != 0) ? ((m & (3 << 14)) != (3 << 14)) : (board[m & 0x3F] != PieceC.NO_PIECE);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,is_capture_or_promotion,The following statement contains a magic number: return ((m & (3 << 14)) != 0) ? ((m & (3 << 14)) != (3 << 14)) : (board[m & 0x3F] != PieceC.NO_PIECE);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,is_capture_or_promotion,The following statement contains a magic number: return ((m & (3 << 14)) != 0) ? ((m & (3 << 14)) != (3 << 14)) : (board[m & 0x3F] != PieceC.NO_PIECE);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,is_capture,The following statement contains a magic number: return ((board[m & 0x3F] != PieceC.NO_PIECE) && !((m & (3 << 14)) == (3 << 14))) || ((m & (3 << 14)) == (2 << 14));
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,is_capture,The following statement contains a magic number: return ((board[m & 0x3F] != PieceC.NO_PIECE) && !((m & (3 << 14)) == (3 << 14))) || ((m & (3 << 14)) == (2 << 14));
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,is_capture,The following statement contains a magic number: return ((board[m & 0x3F] != PieceC.NO_PIECE) && !((m & (3 << 14)) == (3 << 14))) || ((m & (3 << 14)) == (2 << 14));
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,is_capture,The following statement contains a magic number: return ((board[m & 0x3F] != PieceC.NO_PIECE) && !((m & (3 << 14)) == (3 << 14))) || ((m & (3 << 14)) == (2 << 14));
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,is_capture,The following statement contains a magic number: return ((board[m & 0x3F] != PieceC.NO_PIECE) && !((m & (3 << 14)) == (3 << 14))) || ((m & (3 << 14)) == (2 << 14));
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,is_capture,The following statement contains a magic number: return ((board[m & 0x3F] != PieceC.NO_PIECE) && !((m & (3 << 14)) == (3 << 14))) || ((m & (3 << 14)) == (2 << 14));
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,is_capture,The following statement contains a magic number: return ((board[m & 0x3F] != PieceC.NO_PIECE) && !((m & (3 << 14)) == (3 << 14))) || ((m & (3 << 14)) == (2 << 14));
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,is_capture,The following statement contains a magic number: return ((board[m & 0x3F] != PieceC.NO_PIECE) && !((m & (3 << 14)) == (3 << 14))) || ((m & (3 << 14)) == (2 << 14));
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,copy,The following statement contains a magic number: Array.Copy(pos.board' this.board' 64);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,copy,The following statement contains a magic number: Array.Copy(pos.byTypeBB' this.byTypeBB' 8);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,copy,The following statement contains a magic number: Array.Copy(pos.byColorBB' this.byColorBB' 2);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,copy,The following statement contains a magic number: for (int i = 0; i < 2; i++)              {                  Array.Copy(pos.castleRookSquare[i]' this.castleRookSquare[i]' 2);                  Array.Copy(pos.castlePath[i]' this.castlePath[i]' 2);                  Array.Copy(pos.pieceCount[i]' this.pieceCount[i]' 8);                  for (int j = 0; j < 8; j++)                  {                      Array.Copy(pos.pieceList[i][j]' this.pieceList[i][j]' 16);                  }              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,copy,The following statement contains a magic number: for (int i = 0; i < 2; i++)              {                  Array.Copy(pos.castleRookSquare[i]' this.castleRookSquare[i]' 2);                  Array.Copy(pos.castlePath[i]' this.castlePath[i]' 2);                  Array.Copy(pos.pieceCount[i]' this.pieceCount[i]' 8);                  for (int j = 0; j < 8; j++)                  {                      Array.Copy(pos.pieceList[i][j]' this.pieceList[i][j]' 16);                  }              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,copy,The following statement contains a magic number: for (int i = 0; i < 2; i++)              {                  Array.Copy(pos.castleRookSquare[i]' this.castleRookSquare[i]' 2);                  Array.Copy(pos.castlePath[i]' this.castlePath[i]' 2);                  Array.Copy(pos.pieceCount[i]' this.pieceCount[i]' 8);                  for (int j = 0; j < 8; j++)                  {                      Array.Copy(pos.pieceList[i][j]' this.pieceList[i][j]' 16);                  }              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,copy,The following statement contains a magic number: for (int i = 0; i < 2; i++)              {                  Array.Copy(pos.castleRookSquare[i]' this.castleRookSquare[i]' 2);                  Array.Copy(pos.castlePath[i]' this.castlePath[i]' 2);                  Array.Copy(pos.pieceCount[i]' this.pieceCount[i]' 8);                  for (int j = 0; j < 8; j++)                  {                      Array.Copy(pos.pieceList[i][j]' this.pieceList[i][j]' 16);                  }              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,copy,The following statement contains a magic number: for (int i = 0; i < 2; i++)              {                  Array.Copy(pos.castleRookSquare[i]' this.castleRookSquare[i]' 2);                  Array.Copy(pos.castlePath[i]' this.castlePath[i]' 2);                  Array.Copy(pos.pieceCount[i]' this.pieceCount[i]' 8);                  for (int j = 0; j < 8; j++)                  {                      Array.Copy(pos.pieceList[i][j]' this.pieceList[i][j]' 16);                  }              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,copy,The following statement contains a magic number: for (int i = 0; i < 2; i++)              {                  Array.Copy(pos.castleRookSquare[i]' this.castleRookSquare[i]' 2);                  Array.Copy(pos.castlePath[i]' this.castlePath[i]' 2);                  Array.Copy(pos.pieceCount[i]' this.pieceCount[i]' 8);                  for (int j = 0; j < 8; j++)                  {                      Array.Copy(pos.pieceList[i][j]' this.pieceList[i][j]' 16);                  }              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,copy,The following statement contains a magic number: Array.Copy(pos.index' this.index' 64);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,copy,The following statement contains a magic number: Array.Copy(pos.castleRightsMask' this.castleRightsMask' 64);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,Position,The following statement contains a magic number: for (int i = 0; i < 2; i++)              {                  castleRookSquare[i] = new Square[2];                  castlePath[i] = new Bitboard[2];                  pieceCount[i] = new int[8];                  pieceList[i] = new int[8][];                  for (int j = 0; j < 8; j++)                  {                      pieceList[i][j] = new int[16];                  }              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,Position,The following statement contains a magic number: for (int i = 0; i < 2; i++)              {                  castleRookSquare[i] = new Square[2];                  castlePath[i] = new Bitboard[2];                  pieceCount[i] = new int[8];                  pieceList[i] = new int[8][];                  for (int j = 0; j < 8; j++)                  {                      pieceList[i][j] = new int[16];                  }              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,Position,The following statement contains a magic number: for (int i = 0; i < 2; i++)              {                  castleRookSquare[i] = new Square[2];                  castlePath[i] = new Bitboard[2];                  pieceCount[i] = new int[8];                  pieceList[i] = new int[8][];                  for (int j = 0; j < 8; j++)                  {                      pieceList[i][j] = new int[16];                  }              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,Position,The following statement contains a magic number: for (int i = 0; i < 2; i++)              {                  castleRookSquare[i] = new Square[2];                  castlePath[i] = new Bitboard[2];                  pieceCount[i] = new int[8];                  pieceList[i] = new int[8][];                  for (int j = 0; j < 8; j++)                  {                      pieceList[i][j] = new int[16];                  }              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,Position,The following statement contains a magic number: for (int i = 0; i < 2; i++)              {                  castleRookSquare[i] = new Square[2];                  castlePath[i] = new Bitboard[2];                  pieceCount[i] = new int[8];                  pieceList[i] = new int[8][];                  for (int j = 0; j < 8; j++)                  {                      pieceList[i][j] = new int[16];                  }              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,Position,The following statement contains a magic number: for (int i = 0; i < 2; i++)              {                  castleRookSquare[i] = new Square[2];                  castlePath[i] = new Bitboard[2];                  pieceCount[i] = new int[8];                  pieceList[i] = new int[8][];                  for (int j = 0; j < 8; j++)                  {                      pieceList[i][j] = new int[16];                  }              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,Position,The following statement contains a magic number: for (int i = 0; i < 2; i++)              {                  castleRookSquare[i] = new Square[2];                  castlePath[i] = new Bitboard[2];                  pieceCount[i] = new int[8];                  pieceList[i] = new int[8][];                  for (int j = 0; j < 8; j++)                  {                      pieceList[i][j] = new int[16];                  }              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,from_fen,The following statement contains a magic number: while ((token = fen[fenPos++]) != ' ')              {                  if (Utils.isdigit(token))                      sq += (token - '0'); // Advance the given number of files                  else if (token == '/')                      sq -= 16;                  else                  {                      p = PieceToChar.IndexOf(token);                      if (p > -1)                      {                          put_piece(p' sq);                          sq++;                      }                  }                }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,from_fen,The following statement contains a magic number: startPosPly = Math.Max(2 * (startPosPly - 1)' 0) + ((sideToMove == ColorC.BLACK) ? 1 : 0);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,to_fen,The following statement contains a magic number: fen.Append(st.rule50).Append(" ").Append(1 + (startPosPly - (sideToMove == ColorC.BLACK ? 1 : 0)) / 2);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,pl_move_is_legal,The following statement contains a magic number: Square from = ((m >> 6) & 0x3F);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,pl_move_is_legal,The following statement contains a magic number: if ((m & (3 << 14)) == (2 << 14))              {                  Color them = us ^ 1;                  Square to = (m & 0x3F);                  Square capsq = to + (them == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                  Square ksq = pieceList[us][PieceTypeC.KING][0];                  Bitboard b = (occupied_squares ^ Utils.SquareBB[from] ^ Utils.SquareBB[capsq]) | Utils.SquareBB[to];                    Debug.Assert(to == st.epSquare);                  Debug.Assert(piece_moved(m) == Utils.make_piece(us' PieceTypeC.PAWN));                  Debug.Assert(piece_on(capsq) == Utils.make_piece(them' PieceTypeC.PAWN));                  Debug.Assert(piece_on(to) == PieceC.NO_PIECE);                    return ((Utils.rook_attacks_bb(ksq' b) & ((byTypeBB[PieceTypeC.ROOK] | byTypeBB[PieceTypeC.QUEEN]) & byColorBB[them])) == 0)                        && ((Utils.bishop_attacks_bb(ksq' b) & ((byTypeBB[PieceTypeC.BISHOP] | byTypeBB[PieceTypeC.QUEEN]) & byColorBB[them])) == 0);              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,pl_move_is_legal,The following statement contains a magic number: if ((m & (3 << 14)) == (2 << 14))              {                  Color them = us ^ 1;                  Square to = (m & 0x3F);                  Square capsq = to + (them == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                  Square ksq = pieceList[us][PieceTypeC.KING][0];                  Bitboard b = (occupied_squares ^ Utils.SquareBB[from] ^ Utils.SquareBB[capsq]) | Utils.SquareBB[to];                    Debug.Assert(to == st.epSquare);                  Debug.Assert(piece_moved(m) == Utils.make_piece(us' PieceTypeC.PAWN));                  Debug.Assert(piece_on(capsq) == Utils.make_piece(them' PieceTypeC.PAWN));                  Debug.Assert(piece_on(to) == PieceC.NO_PIECE);                    return ((Utils.rook_attacks_bb(ksq' b) & ((byTypeBB[PieceTypeC.ROOK] | byTypeBB[PieceTypeC.QUEEN]) & byColorBB[them])) == 0)                        && ((Utils.bishop_attacks_bb(ksq' b) & ((byTypeBB[PieceTypeC.BISHOP] | byTypeBB[PieceTypeC.QUEEN]) & byColorBB[them])) == 0);              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,pl_move_is_legal,The following statement contains a magic number: if ((m & (3 << 14)) == (2 << 14))              {                  Color them = us ^ 1;                  Square to = (m & 0x3F);                  Square capsq = to + (them == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                  Square ksq = pieceList[us][PieceTypeC.KING][0];                  Bitboard b = (occupied_squares ^ Utils.SquareBB[from] ^ Utils.SquareBB[capsq]) | Utils.SquareBB[to];                    Debug.Assert(to == st.epSquare);                  Debug.Assert(piece_moved(m) == Utils.make_piece(us' PieceTypeC.PAWN));                  Debug.Assert(piece_on(capsq) == Utils.make_piece(them' PieceTypeC.PAWN));                  Debug.Assert(piece_on(to) == PieceC.NO_PIECE);                    return ((Utils.rook_attacks_bb(ksq' b) & ((byTypeBB[PieceTypeC.ROOK] | byTypeBB[PieceTypeC.QUEEN]) & byColorBB[them])) == 0)                        && ((Utils.bishop_attacks_bb(ksq' b) & ((byTypeBB[PieceTypeC.BISHOP] | byTypeBB[PieceTypeC.QUEEN]) & byColorBB[them])) == 0);              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,pl_move_is_legal,The following statement contains a magic number: if ((m & (3 << 14)) == (2 << 14))              {                  Color them = us ^ 1;                  Square to = (m & 0x3F);                  Square capsq = to + (them == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                  Square ksq = pieceList[us][PieceTypeC.KING][0];                  Bitboard b = (occupied_squares ^ Utils.SquareBB[from] ^ Utils.SquareBB[capsq]) | Utils.SquareBB[to];                    Debug.Assert(to == st.epSquare);                  Debug.Assert(piece_moved(m) == Utils.make_piece(us' PieceTypeC.PAWN));                  Debug.Assert(piece_on(capsq) == Utils.make_piece(them' PieceTypeC.PAWN));                  Debug.Assert(piece_on(to) == PieceC.NO_PIECE);                    return ((Utils.rook_attacks_bb(ksq' b) & ((byTypeBB[PieceTypeC.ROOK] | byTypeBB[PieceTypeC.QUEEN]) & byColorBB[them])) == 0)                        && ((Utils.bishop_attacks_bb(ksq' b) & ((byTypeBB[PieceTypeC.BISHOP] | byTypeBB[PieceTypeC.QUEEN]) & byColorBB[them])) == 0);              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,pl_move_is_legal,The following statement contains a magic number: if ((board[from] & 7) == PieceTypeC.KING)                  return ((m & (3 << 14)) == (3 << 14)) || ((attackers_to((m & 0x3F)) & byColorBB[us ^ 1]) == 0);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,pl_move_is_legal,The following statement contains a magic number: if ((board[from] & 7) == PieceTypeC.KING)                  return ((m & (3 << 14)) == (3 << 14)) || ((attackers_to((m & 0x3F)) & byColorBB[us ^ 1]) == 0);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,pl_move_is_legal,The following statement contains a magic number: if ((board[from] & 7) == PieceTypeC.KING)                  return ((m & (3 << 14)) == (3 << 14)) || ((attackers_to((m & 0x3F)) & byColorBB[us ^ 1]) == 0);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,pl_move_is_legal,The following statement contains a magic number: if ((board[from] & 7) == PieceTypeC.KING)                  return ((m & (3 << 14)) == (3 << 14)) || ((attackers_to((m & 0x3F)) & byColorBB[us ^ 1]) == 0);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,pl_move_is_legal,The following statement contains a magic number: if ((board[from] & 7) == PieceTypeC.KING)                  return ((m & (3 << 14)) == (3 << 14)) || ((attackers_to((m & 0x3F)) & byColorBB[us ^ 1]) == 0);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,is_pseudo_legal,The following statement contains a magic number: Square from = ((m >> 6) & 0x3F);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,is_pseudo_legal,The following statement contains a magic number: Piece pc = board[((m >> 6) & 0x3F)];
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,is_pseudo_legal,The following statement contains a magic number: if ((m & (3 << 14)) != 0)                  return move_is_legal(m);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,is_pseudo_legal,The following statement contains a magic number: if ((m & (3 << 14)) != 0)                  return move_is_legal(m);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,is_pseudo_legal,The following statement contains a magic number: if (((m >> 12) & 3) != PieceTypeC.NO_PIECE_TYPE)                  return false;
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,is_pseudo_legal,The following statement contains a magic number: if (((m >> 12) & 3) != PieceTypeC.NO_PIECE_TYPE)                  return false;
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,is_pseudo_legal,The following statement contains a magic number: if (pc == PieceC.NO_PIECE || (pc >> 3) != us)                  return false;
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,is_pseudo_legal,The following statement contains a magic number: if ((board[to] >> 3) == us)                  return false;
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,is_pseudo_legal,The following statement contains a magic number: if ((pc & 7) == PieceTypeC.PAWN)              {                  // Move direction must be compatible with pawn color                  int direction = to - from;                  if ((us == ColorC.WHITE) != (direction > 0))                      return false;                    // We have already handled promotion moves' so destination                  // cannot be on the 8/1th rank.                  if ((to >> 3) == RankC.RANK_8 || (to >> 3) == RankC.RANK_1)                      return false;                    // Proceed according to the square delta between the origin and                  // destination squares.                  switch (direction)                  {                      case SquareC.DELTA_NW:                      case SquareC.DELTA_NE:                      case SquareC.DELTA_SW:                      case SquareC.DELTA_SE:                          // Capture. The destination square must be occupied by an enemy                          // piece (en passant captures was handled earlier).                          if ((board[to] >> 3) != them)                              return false;                            // From and to files must be one file apart' avoids a7h5                          if (Math.Abs((from & 7) - (to & 7)) != 1)                              return false;                          break;                        case SquareC.DELTA_N:                      case SquareC.DELTA_S:                          // Pawn push. The destination square must be empty.                          if (board[to] != PieceC.NO_PIECE)                              return false;                          break;                        case SquareC.DELTA_NN:                          // Double white pawn push. The destination square must be on the fourth                          // rank' and both the destination square and the square between the                          // source and destination squares must be empty.                          if ((to >> 3) != RankC.RANK_4                              || (board[to] != PieceC.NO_PIECE)                              || (board[from + SquareC.DELTA_N] != PieceC.NO_PIECE))                              return false;                          break;                        case SquareC.DELTA_SS:                          // Double black pawn push. The destination square must be on the fifth                          // rank' and both the destination square and the square between the                          // source and destination squares must be empty.                          if ((to >> 3) != RankC.RANK_5                              || (board[to] != PieceC.NO_PIECE)                              || (board[from + SquareC.DELTA_S] != PieceC.NO_PIECE))                              return false;                          break;                        default:                          return false;                  }              }              else if ((attacks_from(pc' from' occupied_squares) & Utils.SquareBB[to]) == 0)                  return false;
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,is_pseudo_legal,The following statement contains a magic number: if ((pc & 7) == PieceTypeC.PAWN)              {                  // Move direction must be compatible with pawn color                  int direction = to - from;                  if ((us == ColorC.WHITE) != (direction > 0))                      return false;                    // We have already handled promotion moves' so destination                  // cannot be on the 8/1th rank.                  if ((to >> 3) == RankC.RANK_8 || (to >> 3) == RankC.RANK_1)                      return false;                    // Proceed according to the square delta between the origin and                  // destination squares.                  switch (direction)                  {                      case SquareC.DELTA_NW:                      case SquareC.DELTA_NE:                      case SquareC.DELTA_SW:                      case SquareC.DELTA_SE:                          // Capture. The destination square must be occupied by an enemy                          // piece (en passant captures was handled earlier).                          if ((board[to] >> 3) != them)                              return false;                            // From and to files must be one file apart' avoids a7h5                          if (Math.Abs((from & 7) - (to & 7)) != 1)                              return false;                          break;                        case SquareC.DELTA_N:                      case SquareC.DELTA_S:                          // Pawn push. The destination square must be empty.                          if (board[to] != PieceC.NO_PIECE)                              return false;                          break;                        case SquareC.DELTA_NN:                          // Double white pawn push. The destination square must be on the fourth                          // rank' and both the destination square and the square between the                          // source and destination squares must be empty.                          if ((to >> 3) != RankC.RANK_4                              || (board[to] != PieceC.NO_PIECE)                              || (board[from + SquareC.DELTA_N] != PieceC.NO_PIECE))                              return false;                          break;                        case SquareC.DELTA_SS:                          // Double black pawn push. The destination square must be on the fifth                          // rank' and both the destination square and the square between the                          // source and destination squares must be empty.                          if ((to >> 3) != RankC.RANK_5                              || (board[to] != PieceC.NO_PIECE)                              || (board[from + SquareC.DELTA_S] != PieceC.NO_PIECE))                              return false;                          break;                        default:                          return false;                  }              }              else if ((attacks_from(pc' from' occupied_squares) & Utils.SquareBB[to]) == 0)                  return false;
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,is_pseudo_legal,The following statement contains a magic number: if ((pc & 7) == PieceTypeC.PAWN)              {                  // Move direction must be compatible with pawn color                  int direction = to - from;                  if ((us == ColorC.WHITE) != (direction > 0))                      return false;                    // We have already handled promotion moves' so destination                  // cannot be on the 8/1th rank.                  if ((to >> 3) == RankC.RANK_8 || (to >> 3) == RankC.RANK_1)                      return false;                    // Proceed according to the square delta between the origin and                  // destination squares.                  switch (direction)                  {                      case SquareC.DELTA_NW:                      case SquareC.DELTA_NE:                      case SquareC.DELTA_SW:                      case SquareC.DELTA_SE:                          // Capture. The destination square must be occupied by an enemy                          // piece (en passant captures was handled earlier).                          if ((board[to] >> 3) != them)                              return false;                            // From and to files must be one file apart' avoids a7h5                          if (Math.Abs((from & 7) - (to & 7)) != 1)                              return false;                          break;                        case SquareC.DELTA_N:                      case SquareC.DELTA_S:                          // Pawn push. The destination square must be empty.                          if (board[to] != PieceC.NO_PIECE)                              return false;                          break;                        case SquareC.DELTA_NN:                          // Double white pawn push. The destination square must be on the fourth                          // rank' and both the destination square and the square between the                          // source and destination squares must be empty.                          if ((to >> 3) != RankC.RANK_4                              || (board[to] != PieceC.NO_PIECE)                              || (board[from + SquareC.DELTA_N] != PieceC.NO_PIECE))                              return false;                          break;                        case SquareC.DELTA_SS:                          // Double black pawn push. The destination square must be on the fifth                          // rank' and both the destination square and the square between the                          // source and destination squares must be empty.                          if ((to >> 3) != RankC.RANK_5                              || (board[to] != PieceC.NO_PIECE)                              || (board[from + SquareC.DELTA_S] != PieceC.NO_PIECE))                              return false;                          break;                        default:                          return false;                  }              }              else if ((attacks_from(pc' from' occupied_squares) & Utils.SquareBB[to]) == 0)                  return false;
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,is_pseudo_legal,The following statement contains a magic number: if ((pc & 7) == PieceTypeC.PAWN)              {                  // Move direction must be compatible with pawn color                  int direction = to - from;                  if ((us == ColorC.WHITE) != (direction > 0))                      return false;                    // We have already handled promotion moves' so destination                  // cannot be on the 8/1th rank.                  if ((to >> 3) == RankC.RANK_8 || (to >> 3) == RankC.RANK_1)                      return false;                    // Proceed according to the square delta between the origin and                  // destination squares.                  switch (direction)                  {                      case SquareC.DELTA_NW:                      case SquareC.DELTA_NE:                      case SquareC.DELTA_SW:                      case SquareC.DELTA_SE:                          // Capture. The destination square must be occupied by an enemy                          // piece (en passant captures was handled earlier).                          if ((board[to] >> 3) != them)                              return false;                            // From and to files must be one file apart' avoids a7h5                          if (Math.Abs((from & 7) - (to & 7)) != 1)                              return false;                          break;                        case SquareC.DELTA_N:                      case SquareC.DELTA_S:                          // Pawn push. The destination square must be empty.                          if (board[to] != PieceC.NO_PIECE)                              return false;                          break;                        case SquareC.DELTA_NN:                          // Double white pawn push. The destination square must be on the fourth                          // rank' and both the destination square and the square between the                          // source and destination squares must be empty.                          if ((to >> 3) != RankC.RANK_4                              || (board[to] != PieceC.NO_PIECE)                              || (board[from + SquareC.DELTA_N] != PieceC.NO_PIECE))                              return false;                          break;                        case SquareC.DELTA_SS:                          // Double black pawn push. The destination square must be on the fifth                          // rank' and both the destination square and the square between the                          // source and destination squares must be empty.                          if ((to >> 3) != RankC.RANK_5                              || (board[to] != PieceC.NO_PIECE)                              || (board[from + SquareC.DELTA_S] != PieceC.NO_PIECE))                              return false;                          break;                        default:                          return false;                  }              }              else if ((attacks_from(pc' from' occupied_squares) & Utils.SquareBB[to]) == 0)                  return false;
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,is_pseudo_legal,The following statement contains a magic number: if ((pc & 7) == PieceTypeC.PAWN)              {                  // Move direction must be compatible with pawn color                  int direction = to - from;                  if ((us == ColorC.WHITE) != (direction > 0))                      return false;                    // We have already handled promotion moves' so destination                  // cannot be on the 8/1th rank.                  if ((to >> 3) == RankC.RANK_8 || (to >> 3) == RankC.RANK_1)                      return false;                    // Proceed according to the square delta between the origin and                  // destination squares.                  switch (direction)                  {                      case SquareC.DELTA_NW:                      case SquareC.DELTA_NE:                      case SquareC.DELTA_SW:                      case SquareC.DELTA_SE:                          // Capture. The destination square must be occupied by an enemy                          // piece (en passant captures was handled earlier).                          if ((board[to] >> 3) != them)                              return false;                            // From and to files must be one file apart' avoids a7h5                          if (Math.Abs((from & 7) - (to & 7)) != 1)                              return false;                          break;                        case SquareC.DELTA_N:                      case SquareC.DELTA_S:                          // Pawn push. The destination square must be empty.                          if (board[to] != PieceC.NO_PIECE)                              return false;                          break;                        case SquareC.DELTA_NN:                          // Double white pawn push. The destination square must be on the fourth                          // rank' and both the destination square and the square between the                          // source and destination squares must be empty.                          if ((to >> 3) != RankC.RANK_4                              || (board[to] != PieceC.NO_PIECE)                              || (board[from + SquareC.DELTA_N] != PieceC.NO_PIECE))                              return false;                          break;                        case SquareC.DELTA_SS:                          // Double black pawn push. The destination square must be on the fifth                          // rank' and both the destination square and the square between the                          // source and destination squares must be empty.                          if ((to >> 3) != RankC.RANK_5                              || (board[to] != PieceC.NO_PIECE)                              || (board[from + SquareC.DELTA_S] != PieceC.NO_PIECE))                              return false;                          break;                        default:                          return false;                  }              }              else if ((attacks_from(pc' from' occupied_squares) & Utils.SquareBB[to]) == 0)                  return false;
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,is_pseudo_legal,The following statement contains a magic number: if ((pc & 7) == PieceTypeC.PAWN)              {                  // Move direction must be compatible with pawn color                  int direction = to - from;                  if ((us == ColorC.WHITE) != (direction > 0))                      return false;                    // We have already handled promotion moves' so destination                  // cannot be on the 8/1th rank.                  if ((to >> 3) == RankC.RANK_8 || (to >> 3) == RankC.RANK_1)                      return false;                    // Proceed according to the square delta between the origin and                  // destination squares.                  switch (direction)                  {                      case SquareC.DELTA_NW:                      case SquareC.DELTA_NE:                      case SquareC.DELTA_SW:                      case SquareC.DELTA_SE:                          // Capture. The destination square must be occupied by an enemy                          // piece (en passant captures was handled earlier).                          if ((board[to] >> 3) != them)                              return false;                            // From and to files must be one file apart' avoids a7h5                          if (Math.Abs((from & 7) - (to & 7)) != 1)                              return false;                          break;                        case SquareC.DELTA_N:                      case SquareC.DELTA_S:                          // Pawn push. The destination square must be empty.                          if (board[to] != PieceC.NO_PIECE)                              return false;                          break;                        case SquareC.DELTA_NN:                          // Double white pawn push. The destination square must be on the fourth                          // rank' and both the destination square and the square between the                          // source and destination squares must be empty.                          if ((to >> 3) != RankC.RANK_4                              || (board[to] != PieceC.NO_PIECE)                              || (board[from + SquareC.DELTA_N] != PieceC.NO_PIECE))                              return false;                          break;                        case SquareC.DELTA_SS:                          // Double black pawn push. The destination square must be on the fifth                          // rank' and both the destination square and the square between the                          // source and destination squares must be empty.                          if ((to >> 3) != RankC.RANK_5                              || (board[to] != PieceC.NO_PIECE)                              || (board[from + SquareC.DELTA_S] != PieceC.NO_PIECE))                              return false;                          break;                        default:                          return false;                  }              }              else if ((attacks_from(pc' from' occupied_squares) & Utils.SquareBB[to]) == 0)                  return false;
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,is_pseudo_legal,The following statement contains a magic number: if ((pc & 7) == PieceTypeC.PAWN)              {                  // Move direction must be compatible with pawn color                  int direction = to - from;                  if ((us == ColorC.WHITE) != (direction > 0))                      return false;                    // We have already handled promotion moves' so destination                  // cannot be on the 8/1th rank.                  if ((to >> 3) == RankC.RANK_8 || (to >> 3) == RankC.RANK_1)                      return false;                    // Proceed according to the square delta between the origin and                  // destination squares.                  switch (direction)                  {                      case SquareC.DELTA_NW:                      case SquareC.DELTA_NE:                      case SquareC.DELTA_SW:                      case SquareC.DELTA_SE:                          // Capture. The destination square must be occupied by an enemy                          // piece (en passant captures was handled earlier).                          if ((board[to] >> 3) != them)                              return false;                            // From and to files must be one file apart' avoids a7h5                          if (Math.Abs((from & 7) - (to & 7)) != 1)                              return false;                          break;                        case SquareC.DELTA_N:                      case SquareC.DELTA_S:                          // Pawn push. The destination square must be empty.                          if (board[to] != PieceC.NO_PIECE)                              return false;                          break;                        case SquareC.DELTA_NN:                          // Double white pawn push. The destination square must be on the fourth                          // rank' and both the destination square and the square between the                          // source and destination squares must be empty.                          if ((to >> 3) != RankC.RANK_4                              || (board[to] != PieceC.NO_PIECE)                              || (board[from + SquareC.DELTA_N] != PieceC.NO_PIECE))                              return false;                          break;                        case SquareC.DELTA_SS:                          // Double black pawn push. The destination square must be on the fifth                          // rank' and both the destination square and the square between the                          // source and destination squares must be empty.                          if ((to >> 3) != RankC.RANK_5                              || (board[to] != PieceC.NO_PIECE)                              || (board[from + SquareC.DELTA_S] != PieceC.NO_PIECE))                              return false;                          break;                        default:                          return false;                  }              }              else if ((attacks_from(pc' from' occupied_squares) & Utils.SquareBB[to]) == 0)                  return false;
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,is_pseudo_legal,The following statement contains a magic number: if ((pc & 7) == PieceTypeC.PAWN)              {                  // Move direction must be compatible with pawn color                  int direction = to - from;                  if ((us == ColorC.WHITE) != (direction > 0))                      return false;                    // We have already handled promotion moves' so destination                  // cannot be on the 8/1th rank.                  if ((to >> 3) == RankC.RANK_8 || (to >> 3) == RankC.RANK_1)                      return false;                    // Proceed according to the square delta between the origin and                  // destination squares.                  switch (direction)                  {                      case SquareC.DELTA_NW:                      case SquareC.DELTA_NE:                      case SquareC.DELTA_SW:                      case SquareC.DELTA_SE:                          // Capture. The destination square must be occupied by an enemy                          // piece (en passant captures was handled earlier).                          if ((board[to] >> 3) != them)                              return false;                            // From and to files must be one file apart' avoids a7h5                          if (Math.Abs((from & 7) - (to & 7)) != 1)                              return false;                          break;                        case SquareC.DELTA_N:                      case SquareC.DELTA_S:                          // Pawn push. The destination square must be empty.                          if (board[to] != PieceC.NO_PIECE)                              return false;                          break;                        case SquareC.DELTA_NN:                          // Double white pawn push. The destination square must be on the fourth                          // rank' and both the destination square and the square between the                          // source and destination squares must be empty.                          if ((to >> 3) != RankC.RANK_4                              || (board[to] != PieceC.NO_PIECE)                              || (board[from + SquareC.DELTA_N] != PieceC.NO_PIECE))                              return false;                          break;                        case SquareC.DELTA_SS:                          // Double black pawn push. The destination square must be on the fifth                          // rank' and both the destination square and the square between the                          // source and destination squares must be empty.                          if ((to >> 3) != RankC.RANK_5                              || (board[to] != PieceC.NO_PIECE)                              || (board[from + SquareC.DELTA_S] != PieceC.NO_PIECE))                              return false;                          break;                        default:                          return false;                  }              }              else if ((attacks_from(pc' from' occupied_squares) & Utils.SquareBB[to]) == 0)                  return false;
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,is_pseudo_legal,The following statement contains a magic number: if (st.checkersBB != 0)              {                  if ((pc & 7) != PieceTypeC.KING)                  {                      Bitboard b = st.checkersBB;                      Square checksq = Utils.pop_1st_bit(ref b);                        if (b != 0) // double check ? In this case a king move is required                          return false;                        // Our move must be a blocking evasion or a capture of the checking piece                      if (((Utils.BetweenBB[checksq][pieceList[us][PieceTypeC.KING][0]] | st.checkersBB) & Utils.SquareBB[to]) == 0)                          return false;                  }                  // In case of king moves under check we have to remove king so to catch                  // as invalid moves like b1a1 when opposite queen is on c1.                  else if ((attackers_to(to' (occupied_squares ^ Utils.SquareBB[from])) & byColorBB[us ^ 1]) != 0)                      return false;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,move_gives_check,The following statement contains a magic number: Square from = (m >> 6) & 0x3F;
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,move_gives_check,The following statement contains a magic number: PieceType pt = board[from] & 7;
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,move_gives_check,The following statement contains a magic number: if ((m & (3 << 14)) == 0)                  return false;
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,move_gives_check,The following statement contains a magic number: if ((m & (3 << 14)) == 0)                  return false;
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,move_gives_check,The following statement contains a magic number: if ((m & (3 << 14)) == (1 << 14))              {                  return (attacks_from((((m >> 12) & 3) + 2)' to' occupied_squares ^ Utils.SquareBB[from]) & Utils.SquareBB[ksq]) != 0;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,move_gives_check,The following statement contains a magic number: if ((m & (3 << 14)) == (1 << 14))              {                  return (attacks_from((((m >> 12) & 3) + 2)' to' occupied_squares ^ Utils.SquareBB[from]) & Utils.SquareBB[ksq]) != 0;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,move_gives_check,The following statement contains a magic number: if ((m & (3 << 14)) == (1 << 14))              {                  return (attacks_from((((m >> 12) & 3) + 2)' to' occupied_squares ^ Utils.SquareBB[from]) & Utils.SquareBB[ksq]) != 0;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,move_gives_check,The following statement contains a magic number: if ((m & (3 << 14)) == (1 << 14))              {                  return (attacks_from((((m >> 12) & 3) + 2)' to' occupied_squares ^ Utils.SquareBB[from]) & Utils.SquareBB[ksq]) != 0;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,move_gives_check,The following statement contains a magic number: if ((m & (3 << 14)) == (1 << 14))              {                  return (attacks_from((((m >> 12) & 3) + 2)' to' occupied_squares ^ Utils.SquareBB[from]) & Utils.SquareBB[ksq]) != 0;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,move_gives_check,The following statement contains a magic number: if ((m & (3 << 14)) == (1 << 14))              {                  return (attacks_from((((m >> 12) & 3) + 2)' to' occupied_squares ^ Utils.SquareBB[from]) & Utils.SquareBB[ksq]) != 0;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,move_gives_check,The following statement contains a magic number: if ((m & (3 << 14)) == (2 << 14))              {                  Square capsq = (((from >> 3) << 3) | (to & 7));                  Bitboard b = (occupied_squares ^ Utils.SquareBB[from] ^ Utils.SquareBB[capsq]) | Utils.SquareBB[to];                  return ((Utils.rook_attacks_bb(ksq' b) & ((byTypeBB[PieceTypeC.ROOK] | byTypeBB[PieceTypeC.QUEEN]) & byColorBB[us])) != 0)                        || ((Utils.bishop_attacks_bb(ksq' b) & ((byTypeBB[PieceTypeC.BISHOP] | byTypeBB[PieceTypeC.QUEEN]) & byColorBB[us])) != 0);              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,move_gives_check,The following statement contains a magic number: if ((m & (3 << 14)) == (2 << 14))              {                  Square capsq = (((from >> 3) << 3) | (to & 7));                  Bitboard b = (occupied_squares ^ Utils.SquareBB[from] ^ Utils.SquareBB[capsq]) | Utils.SquareBB[to];                  return ((Utils.rook_attacks_bb(ksq' b) & ((byTypeBB[PieceTypeC.ROOK] | byTypeBB[PieceTypeC.QUEEN]) & byColorBB[us])) != 0)                        || ((Utils.bishop_attacks_bb(ksq' b) & ((byTypeBB[PieceTypeC.BISHOP] | byTypeBB[PieceTypeC.QUEEN]) & byColorBB[us])) != 0);              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,move_gives_check,The following statement contains a magic number: if ((m & (3 << 14)) == (2 << 14))              {                  Square capsq = (((from >> 3) << 3) | (to & 7));                  Bitboard b = (occupied_squares ^ Utils.SquareBB[from] ^ Utils.SquareBB[capsq]) | Utils.SquareBB[to];                  return ((Utils.rook_attacks_bb(ksq' b) & ((byTypeBB[PieceTypeC.ROOK] | byTypeBB[PieceTypeC.QUEEN]) & byColorBB[us])) != 0)                        || ((Utils.bishop_attacks_bb(ksq' b) & ((byTypeBB[PieceTypeC.BISHOP] | byTypeBB[PieceTypeC.QUEEN]) & byColorBB[us])) != 0);              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,move_gives_check,The following statement contains a magic number: if ((m & (3 << 14)) == (2 << 14))              {                  Square capsq = (((from >> 3) << 3) | (to & 7));                  Bitboard b = (occupied_squares ^ Utils.SquareBB[from] ^ Utils.SquareBB[capsq]) | Utils.SquareBB[to];                  return ((Utils.rook_attacks_bb(ksq' b) & ((byTypeBB[PieceTypeC.ROOK] | byTypeBB[PieceTypeC.QUEEN]) & byColorBB[us])) != 0)                        || ((Utils.bishop_attacks_bb(ksq' b) & ((byTypeBB[PieceTypeC.BISHOP] | byTypeBB[PieceTypeC.QUEEN]) & byColorBB[us])) != 0);              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,move_gives_check,The following statement contains a magic number: if ((m & (3 << 14)) == (2 << 14))              {                  Square capsq = (((from >> 3) << 3) | (to & 7));                  Bitboard b = (occupied_squares ^ Utils.SquareBB[from] ^ Utils.SquareBB[capsq]) | Utils.SquareBB[to];                  return ((Utils.rook_attacks_bb(ksq' b) & ((byTypeBB[PieceTypeC.ROOK] | byTypeBB[PieceTypeC.QUEEN]) & byColorBB[us])) != 0)                        || ((Utils.bishop_attacks_bb(ksq' b) & ((byTypeBB[PieceTypeC.BISHOP] | byTypeBB[PieceTypeC.QUEEN]) & byColorBB[us])) != 0);              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,move_gives_check,The following statement contains a magic number: if ((m & (3 << 14)) == (2 << 14))              {                  Square capsq = (((from >> 3) << 3) | (to & 7));                  Bitboard b = (occupied_squares ^ Utils.SquareBB[from] ^ Utils.SquareBB[capsq]) | Utils.SquareBB[to];                  return ((Utils.rook_attacks_bb(ksq' b) & ((byTypeBB[PieceTypeC.ROOK] | byTypeBB[PieceTypeC.QUEEN]) & byColorBB[us])) != 0)                        || ((Utils.bishop_attacks_bb(ksq' b) & ((byTypeBB[PieceTypeC.BISHOP] | byTypeBB[PieceTypeC.QUEEN]) & byColorBB[us])) != 0);              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,move_gives_check,The following statement contains a magic number: if ((m & (3 << 14)) == (2 << 14))              {                  Square capsq = (((from >> 3) << 3) | (to & 7));                  Bitboard b = (occupied_squares ^ Utils.SquareBB[from] ^ Utils.SquareBB[capsq]) | Utils.SquareBB[to];                  return ((Utils.rook_attacks_bb(ksq' b) & ((byTypeBB[PieceTypeC.ROOK] | byTypeBB[PieceTypeC.QUEEN]) & byColorBB[us])) != 0)                        || ((Utils.bishop_attacks_bb(ksq' b) & ((byTypeBB[PieceTypeC.BISHOP] | byTypeBB[PieceTypeC.QUEEN]) & byColorBB[us])) != 0);              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,move_gives_check,The following statement contains a magic number: if ((m & (3 << 14)) == (3 << 14))              {                  Square kfrom = from;                  Square rfrom = to; // 'King captures the rook' notation                  Square kto = ((rfrom > kfrom ? SquareC.SQ_G1 : SquareC.SQ_C1) ^ (us * 56));                  Square rto = ((rfrom > kfrom ? SquareC.SQ_F1 : SquareC.SQ_D1) ^ (us * 56));                  Bitboard b = (occupied_squares ^ Utils.SquareBB[kfrom] ^ Utils.SquareBB[rfrom]) | Utils.SquareBB[rto] | Utils.SquareBB[kto];                  return (Utils.rook_attacks_bb(rto' b) & Utils.SquareBB[ksq]) != 0;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,move_gives_check,The following statement contains a magic number: if ((m & (3 << 14)) == (3 << 14))              {                  Square kfrom = from;                  Square rfrom = to; // 'King captures the rook' notation                  Square kto = ((rfrom > kfrom ? SquareC.SQ_G1 : SquareC.SQ_C1) ^ (us * 56));                  Square rto = ((rfrom > kfrom ? SquareC.SQ_F1 : SquareC.SQ_D1) ^ (us * 56));                  Bitboard b = (occupied_squares ^ Utils.SquareBB[kfrom] ^ Utils.SquareBB[rfrom]) | Utils.SquareBB[rto] | Utils.SquareBB[kto];                  return (Utils.rook_attacks_bb(rto' b) & Utils.SquareBB[ksq]) != 0;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,move_gives_check,The following statement contains a magic number: if ((m & (3 << 14)) == (3 << 14))              {                  Square kfrom = from;                  Square rfrom = to; // 'King captures the rook' notation                  Square kto = ((rfrom > kfrom ? SquareC.SQ_G1 : SquareC.SQ_C1) ^ (us * 56));                  Square rto = ((rfrom > kfrom ? SquareC.SQ_F1 : SquareC.SQ_D1) ^ (us * 56));                  Bitboard b = (occupied_squares ^ Utils.SquareBB[kfrom] ^ Utils.SquareBB[rfrom]) | Utils.SquareBB[rto] | Utils.SquareBB[kto];                  return (Utils.rook_attacks_bb(rto' b) & Utils.SquareBB[ksq]) != 0;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,move_gives_check,The following statement contains a magic number: if ((m & (3 << 14)) == (3 << 14))              {                  Square kfrom = from;                  Square rfrom = to; // 'King captures the rook' notation                  Square kto = ((rfrom > kfrom ? SquareC.SQ_G1 : SquareC.SQ_C1) ^ (us * 56));                  Square rto = ((rfrom > kfrom ? SquareC.SQ_F1 : SquareC.SQ_D1) ^ (us * 56));                  Bitboard b = (occupied_squares ^ Utils.SquareBB[kfrom] ^ Utils.SquareBB[rfrom]) | Utils.SquareBB[rto] | Utils.SquareBB[kto];                  return (Utils.rook_attacks_bb(rto' b) & Utils.SquareBB[ksq]) != 0;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,move_gives_check,The following statement contains a magic number: if ((m & (3 << 14)) == (3 << 14))              {                  Square kfrom = from;                  Square rfrom = to; // 'King captures the rook' notation                  Square kto = ((rfrom > kfrom ? SquareC.SQ_G1 : SquareC.SQ_C1) ^ (us * 56));                  Square rto = ((rfrom > kfrom ? SquareC.SQ_F1 : SquareC.SQ_D1) ^ (us * 56));                  Bitboard b = (occupied_squares ^ Utils.SquareBB[kfrom] ^ Utils.SquareBB[rfrom]) | Utils.SquareBB[rto] | Utils.SquareBB[kto];                  return (Utils.rook_attacks_bb(rto' b) & Utils.SquareBB[ksq]) != 0;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,move_gives_check,The following statement contains a magic number: if ((m & (3 << 14)) == (3 << 14))              {                  Square kfrom = from;                  Square rfrom = to; // 'King captures the rook' notation                  Square kto = ((rfrom > kfrom ? SquareC.SQ_G1 : SquareC.SQ_C1) ^ (us * 56));                  Square rto = ((rfrom > kfrom ? SquareC.SQ_F1 : SquareC.SQ_D1) ^ (us * 56));                  Bitboard b = (occupied_squares ^ Utils.SquareBB[kfrom] ^ Utils.SquareBB[rfrom]) | Utils.SquareBB[rto] | Utils.SquareBB[kto];                  return (Utils.rook_attacks_bb(rto' b) & Utils.SquareBB[ksq]) != 0;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,do_move,The following statement contains a magic number: if ((m & (3 << 14)) == (3 << 14))              {                  st.key = k;                  do_castle_move(true' m);                  return;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,do_move,The following statement contains a magic number: if ((m & (3 << 14)) == (3 << 14))              {                  st.key = k;                  do_castle_move(true' m);                  return;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,do_move,The following statement contains a magic number: if ((m & (3 << 14)) == (3 << 14))              {                  st.key = k;                  do_castle_move(true' m);                  return;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,do_move,The following statement contains a magic number: if ((m & (3 << 14)) == (3 << 14))              {                  st.key = k;                  do_castle_move(true' m);                  return;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,do_move,The following statement contains a magic number: Square from = ((m >> 6) & 0x3F);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,do_move,The following statement contains a magic number: PieceType pt = (piece & 7);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,do_move,The following statement contains a magic number: PieceType capture = ((m & (3 << 14)) == (2 << 14)) ? PieceTypeC.PAWN : (board[to] & 7);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,do_move,The following statement contains a magic number: PieceType capture = ((m & (3 << 14)) == (2 << 14)) ? PieceTypeC.PAWN : (board[to] & 7);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,do_move,The following statement contains a magic number: PieceType capture = ((m & (3 << 14)) == (2 << 14)) ? PieceTypeC.PAWN : (board[to] & 7);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,do_move,The following statement contains a magic number: PieceType capture = ((m & (3 << 14)) == (2 << 14)) ? PieceTypeC.PAWN : (board[to] & 7);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,do_move,The following statement contains a magic number: PieceType capture = ((m & (3 << 14)) == (2 << 14)) ? PieceTypeC.PAWN : (board[to] & 7);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,do_move,The following statement contains a magic number: if (capture != 0)              {                  Square capsq = to;                    // If the captured piece is a pawn' update pawn hash key' otherwise                  // update non-pawn material.                  if (capture == PieceTypeC.PAWN)                  {                      if ((m & (3 << 14)) == (2 << 14))                      {                          capsq += (them == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                            Debug.Assert(pt == PieceTypeC.PAWN);                          Debug.Assert(to == st.epSquare);                          Debug.Assert(Utils.relative_rank_CS(us' to) == RankC.RANK_6);                          Debug.Assert(piece_on(to) == PieceC.NO_PIECE);                          Debug.Assert(piece_on(capsq) == Utils.make_piece(them' PieceTypeC.PAWN));                            board[capsq] = PieceC.NO_PIECE;                      }                        st.pawnKey ^= zobrist[them][PieceTypeC.PAWN][capsq];                  }                  else                  {                      if (them == 0) { st.npMaterialWHITE -= PieceValueMidgame[capture]; } else { st.npMaterialBLACK -= PieceValueMidgame[capture]; }                  }                    // Remove the captured piece                  Bitboard capPieceMask = Utils.SquareBB[capsq];                  occupied_squares ^= capPieceMask;                  byTypeBB[capture] ^= capPieceMask;                  byColorBB[them] ^= capPieceMask;                    // Update piece list' move the last piece at index[capsq] position and                  // shrink the list.                  //                  // WARNING: This is a not revresible operation. When we will reinsert the                  // captured piece in undo_move() we will put it at the end of the list and                  // not in its original place' it means index[] and pieceList[] are not                  // guaranteed to be invariant to a do_move() + undo_move() sequence.                  int[] plThemCapture = pieceList[them][capture];                  int pcThemCapture = --pieceCount[them][capture];                  Square lastSquare = plThemCapture[pcThemCapture];                  index[lastSquare] = index[capsq];                  plThemCapture[index[lastSquare]] = lastSquare;                  plThemCapture[pcThemCapture] = SquareC.SQ_NONE;                    // Update hash keys                  k ^= zobrist[them][capture][capsq];                  st.materialKey ^= zobrist[them][capture][pcThemCapture];                    // Update incremental scores                  st.psqScore -= pieceSquareTable[((them << 3) | capture)][capsq];                    // Reset rule 50 counter                  st.rule50 = 0;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,do_move,The following statement contains a magic number: if (capture != 0)              {                  Square capsq = to;                    // If the captured piece is a pawn' update pawn hash key' otherwise                  // update non-pawn material.                  if (capture == PieceTypeC.PAWN)                  {                      if ((m & (3 << 14)) == (2 << 14))                      {                          capsq += (them == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                            Debug.Assert(pt == PieceTypeC.PAWN);                          Debug.Assert(to == st.epSquare);                          Debug.Assert(Utils.relative_rank_CS(us' to) == RankC.RANK_6);                          Debug.Assert(piece_on(to) == PieceC.NO_PIECE);                          Debug.Assert(piece_on(capsq) == Utils.make_piece(them' PieceTypeC.PAWN));                            board[capsq] = PieceC.NO_PIECE;                      }                        st.pawnKey ^= zobrist[them][PieceTypeC.PAWN][capsq];                  }                  else                  {                      if (them == 0) { st.npMaterialWHITE -= PieceValueMidgame[capture]; } else { st.npMaterialBLACK -= PieceValueMidgame[capture]; }                  }                    // Remove the captured piece                  Bitboard capPieceMask = Utils.SquareBB[capsq];                  occupied_squares ^= capPieceMask;                  byTypeBB[capture] ^= capPieceMask;                  byColorBB[them] ^= capPieceMask;                    // Update piece list' move the last piece at index[capsq] position and                  // shrink the list.                  //                  // WARNING: This is a not revresible operation. When we will reinsert the                  // captured piece in undo_move() we will put it at the end of the list and                  // not in its original place' it means index[] and pieceList[] are not                  // guaranteed to be invariant to a do_move() + undo_move() sequence.                  int[] plThemCapture = pieceList[them][capture];                  int pcThemCapture = --pieceCount[them][capture];                  Square lastSquare = plThemCapture[pcThemCapture];                  index[lastSquare] = index[capsq];                  plThemCapture[index[lastSquare]] = lastSquare;                  plThemCapture[pcThemCapture] = SquareC.SQ_NONE;                    // Update hash keys                  k ^= zobrist[them][capture][capsq];                  st.materialKey ^= zobrist[them][capture][pcThemCapture];                    // Update incremental scores                  st.psqScore -= pieceSquareTable[((them << 3) | capture)][capsq];                    // Reset rule 50 counter                  st.rule50 = 0;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,do_move,The following statement contains a magic number: if (capture != 0)              {                  Square capsq = to;                    // If the captured piece is a pawn' update pawn hash key' otherwise                  // update non-pawn material.                  if (capture == PieceTypeC.PAWN)                  {                      if ((m & (3 << 14)) == (2 << 14))                      {                          capsq += (them == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                            Debug.Assert(pt == PieceTypeC.PAWN);                          Debug.Assert(to == st.epSquare);                          Debug.Assert(Utils.relative_rank_CS(us' to) == RankC.RANK_6);                          Debug.Assert(piece_on(to) == PieceC.NO_PIECE);                          Debug.Assert(piece_on(capsq) == Utils.make_piece(them' PieceTypeC.PAWN));                            board[capsq] = PieceC.NO_PIECE;                      }                        st.pawnKey ^= zobrist[them][PieceTypeC.PAWN][capsq];                  }                  else                  {                      if (them == 0) { st.npMaterialWHITE -= PieceValueMidgame[capture]; } else { st.npMaterialBLACK -= PieceValueMidgame[capture]; }                  }                    // Remove the captured piece                  Bitboard capPieceMask = Utils.SquareBB[capsq];                  occupied_squares ^= capPieceMask;                  byTypeBB[capture] ^= capPieceMask;                  byColorBB[them] ^= capPieceMask;                    // Update piece list' move the last piece at index[capsq] position and                  // shrink the list.                  //                  // WARNING: This is a not revresible operation. When we will reinsert the                  // captured piece in undo_move() we will put it at the end of the list and                  // not in its original place' it means index[] and pieceList[] are not                  // guaranteed to be invariant to a do_move() + undo_move() sequence.                  int[] plThemCapture = pieceList[them][capture];                  int pcThemCapture = --pieceCount[them][capture];                  Square lastSquare = plThemCapture[pcThemCapture];                  index[lastSquare] = index[capsq];                  plThemCapture[index[lastSquare]] = lastSquare;                  plThemCapture[pcThemCapture] = SquareC.SQ_NONE;                    // Update hash keys                  k ^= zobrist[them][capture][capsq];                  st.materialKey ^= zobrist[them][capture][pcThemCapture];                    // Update incremental scores                  st.psqScore -= pieceSquareTable[((them << 3) | capture)][capsq];                    // Reset rule 50 counter                  st.rule50 = 0;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,do_move,The following statement contains a magic number: if (capture != 0)              {                  Square capsq = to;                    // If the captured piece is a pawn' update pawn hash key' otherwise                  // update non-pawn material.                  if (capture == PieceTypeC.PAWN)                  {                      if ((m & (3 << 14)) == (2 << 14))                      {                          capsq += (them == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                            Debug.Assert(pt == PieceTypeC.PAWN);                          Debug.Assert(to == st.epSquare);                          Debug.Assert(Utils.relative_rank_CS(us' to) == RankC.RANK_6);                          Debug.Assert(piece_on(to) == PieceC.NO_PIECE);                          Debug.Assert(piece_on(capsq) == Utils.make_piece(them' PieceTypeC.PAWN));                            board[capsq] = PieceC.NO_PIECE;                      }                        st.pawnKey ^= zobrist[them][PieceTypeC.PAWN][capsq];                  }                  else                  {                      if (them == 0) { st.npMaterialWHITE -= PieceValueMidgame[capture]; } else { st.npMaterialBLACK -= PieceValueMidgame[capture]; }                  }                    // Remove the captured piece                  Bitboard capPieceMask = Utils.SquareBB[capsq];                  occupied_squares ^= capPieceMask;                  byTypeBB[capture] ^= capPieceMask;                  byColorBB[them] ^= capPieceMask;                    // Update piece list' move the last piece at index[capsq] position and                  // shrink the list.                  //                  // WARNING: This is a not revresible operation. When we will reinsert the                  // captured piece in undo_move() we will put it at the end of the list and                  // not in its original place' it means index[] and pieceList[] are not                  // guaranteed to be invariant to a do_move() + undo_move() sequence.                  int[] plThemCapture = pieceList[them][capture];                  int pcThemCapture = --pieceCount[them][capture];                  Square lastSquare = plThemCapture[pcThemCapture];                  index[lastSquare] = index[capsq];                  plThemCapture[index[lastSquare]] = lastSquare;                  plThemCapture[pcThemCapture] = SquareC.SQ_NONE;                    // Update hash keys                  k ^= zobrist[them][capture][capsq];                  st.materialKey ^= zobrist[them][capture][pcThemCapture];                    // Update incremental scores                  st.psqScore -= pieceSquareTable[((them << 3) | capture)][capsq];                    // Reset rule 50 counter                  st.rule50 = 0;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,do_move,The following statement contains a magic number: if (capture != 0)              {                  Square capsq = to;                    // If the captured piece is a pawn' update pawn hash key' otherwise                  // update non-pawn material.                  if (capture == PieceTypeC.PAWN)                  {                      if ((m & (3 << 14)) == (2 << 14))                      {                          capsq += (them == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                            Debug.Assert(pt == PieceTypeC.PAWN);                          Debug.Assert(to == st.epSquare);                          Debug.Assert(Utils.relative_rank_CS(us' to) == RankC.RANK_6);                          Debug.Assert(piece_on(to) == PieceC.NO_PIECE);                          Debug.Assert(piece_on(capsq) == Utils.make_piece(them' PieceTypeC.PAWN));                            board[capsq] = PieceC.NO_PIECE;                      }                        st.pawnKey ^= zobrist[them][PieceTypeC.PAWN][capsq];                  }                  else                  {                      if (them == 0) { st.npMaterialWHITE -= PieceValueMidgame[capture]; } else { st.npMaterialBLACK -= PieceValueMidgame[capture]; }                  }                    // Remove the captured piece                  Bitboard capPieceMask = Utils.SquareBB[capsq];                  occupied_squares ^= capPieceMask;                  byTypeBB[capture] ^= capPieceMask;                  byColorBB[them] ^= capPieceMask;                    // Update piece list' move the last piece at index[capsq] position and                  // shrink the list.                  //                  // WARNING: This is a not revresible operation. When we will reinsert the                  // captured piece in undo_move() we will put it at the end of the list and                  // not in its original place' it means index[] and pieceList[] are not                  // guaranteed to be invariant to a do_move() + undo_move() sequence.                  int[] plThemCapture = pieceList[them][capture];                  int pcThemCapture = --pieceCount[them][capture];                  Square lastSquare = plThemCapture[pcThemCapture];                  index[lastSquare] = index[capsq];                  plThemCapture[index[lastSquare]] = lastSquare;                  plThemCapture[pcThemCapture] = SquareC.SQ_NONE;                    // Update hash keys                  k ^= zobrist[them][capture][capsq];                  st.materialKey ^= zobrist[them][capture][pcThemCapture];                    // Update incremental scores                  st.psqScore -= pieceSquareTable[((them << 3) | capture)][capsq];                    // Reset rule 50 counter                  st.rule50 = 0;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,do_move,The following statement contains a magic number: if (st.epSquare != SquareC.SQ_NONE)              {                  k ^= zobEp[st.epSquare & 7];                  st.epSquare = SquareC.SQ_NONE;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,do_move,The following statement contains a magic number: if (pt == PieceTypeC.PAWN)              {                  // Set en-passant square' only if moved pawn can be captured                  if ((to ^ from) == 16                      && ((((Utils.StepAttacksBB[((us << 3) | PieceTypeC.PAWN)][from + (us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)]) & (byTypeBB[PieceTypeC.PAWN] & byColorBB[them]))) != 0))                  {                      st.epSquare = ((from + to) / 2);                      k ^= zobEp[st.epSquare & 7];                  }                    if ((m & (3 << 14)) == (1 << 14))                  {                      PieceType promotion = (((m >> 12) & 3) + 2);                        Debug.Assert(Utils.relative_rank_CS(us' to) == RankC.RANK_8);                      Debug.Assert(promotion >= PieceTypeC.KNIGHT && promotion <= PieceTypeC.QUEEN);                        // Replace the pawn with the promoted piece                      byTypeBB[PieceTypeC.PAWN] ^= Utils.SquareBB[to];                      byTypeBB[promotion] |= Utils.SquareBB[to];                      board[to] = ((us << 3) | promotion);                        // Update piece lists' move the last pawn at index[to] position                      // and shrink the list. Add a new promotion piece to the list.                      int[] plUsPawn = pieceList[us][PieceTypeC.PAWN];                      Square lastSquare = plUsPawn[--pieceCount[us][PieceTypeC.PAWN]];                      index[lastSquare] = index[to];                      plUsPawn[index[lastSquare]] = lastSquare;                      plUsPawn[pieceCount[us][PieceTypeC.PAWN]] = SquareC.SQ_NONE;                      index[to] = pieceCount[us][promotion];                      pieceList[us][promotion][index[to]] = to;                        // Update hash keys                      k ^= zobrist[us][PieceTypeC.PAWN][to] ^ zobrist[us][promotion][to];                      st.pawnKey ^= zobrist[us][PieceTypeC.PAWN][to];                      st.materialKey ^= zobrist[us][promotion][pieceCount[us][promotion]++]                                        ^ zobrist[us][PieceTypeC.PAWN][pieceCount[us][PieceTypeC.PAWN]];                        // Update incremental score                      st.psqScore += pieceSquareTable[((us << 3) | promotion)][to] - pieceSquareTable[((us << 3) | PieceTypeC.PAWN)][to];                        // Update material                      if (us == 0) { st.npMaterialWHITE += PieceValueMidgame[promotion]; }                      else { st.npMaterialBLACK += PieceValueMidgame[promotion]; }                  }                    // Update pawn hash key                  st.pawnKey ^= zobrist[us][PieceTypeC.PAWN][from] ^ zobrist[us][PieceTypeC.PAWN][to];                    // Reset rule 50 draw counter                  st.rule50 = 0;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,do_move,The following statement contains a magic number: if (pt == PieceTypeC.PAWN)              {                  // Set en-passant square' only if moved pawn can be captured                  if ((to ^ from) == 16                      && ((((Utils.StepAttacksBB[((us << 3) | PieceTypeC.PAWN)][from + (us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)]) & (byTypeBB[PieceTypeC.PAWN] & byColorBB[them]))) != 0))                  {                      st.epSquare = ((from + to) / 2);                      k ^= zobEp[st.epSquare & 7];                  }                    if ((m & (3 << 14)) == (1 << 14))                  {                      PieceType promotion = (((m >> 12) & 3) + 2);                        Debug.Assert(Utils.relative_rank_CS(us' to) == RankC.RANK_8);                      Debug.Assert(promotion >= PieceTypeC.KNIGHT && promotion <= PieceTypeC.QUEEN);                        // Replace the pawn with the promoted piece                      byTypeBB[PieceTypeC.PAWN] ^= Utils.SquareBB[to];                      byTypeBB[promotion] |= Utils.SquareBB[to];                      board[to] = ((us << 3) | promotion);                        // Update piece lists' move the last pawn at index[to] position                      // and shrink the list. Add a new promotion piece to the list.                      int[] plUsPawn = pieceList[us][PieceTypeC.PAWN];                      Square lastSquare = plUsPawn[--pieceCount[us][PieceTypeC.PAWN]];                      index[lastSquare] = index[to];                      plUsPawn[index[lastSquare]] = lastSquare;                      plUsPawn[pieceCount[us][PieceTypeC.PAWN]] = SquareC.SQ_NONE;                      index[to] = pieceCount[us][promotion];                      pieceList[us][promotion][index[to]] = to;                        // Update hash keys                      k ^= zobrist[us][PieceTypeC.PAWN][to] ^ zobrist[us][promotion][to];                      st.pawnKey ^= zobrist[us][PieceTypeC.PAWN][to];                      st.materialKey ^= zobrist[us][promotion][pieceCount[us][promotion]++]                                        ^ zobrist[us][PieceTypeC.PAWN][pieceCount[us][PieceTypeC.PAWN]];                        // Update incremental score                      st.psqScore += pieceSquareTable[((us << 3) | promotion)][to] - pieceSquareTable[((us << 3) | PieceTypeC.PAWN)][to];                        // Update material                      if (us == 0) { st.npMaterialWHITE += PieceValueMidgame[promotion]; }                      else { st.npMaterialBLACK += PieceValueMidgame[promotion]; }                  }                    // Update pawn hash key                  st.pawnKey ^= zobrist[us][PieceTypeC.PAWN][from] ^ zobrist[us][PieceTypeC.PAWN][to];                    // Reset rule 50 draw counter                  st.rule50 = 0;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,do_move,The following statement contains a magic number: if (pt == PieceTypeC.PAWN)              {                  // Set en-passant square' only if moved pawn can be captured                  if ((to ^ from) == 16                      && ((((Utils.StepAttacksBB[((us << 3) | PieceTypeC.PAWN)][from + (us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)]) & (byTypeBB[PieceTypeC.PAWN] & byColorBB[them]))) != 0))                  {                      st.epSquare = ((from + to) / 2);                      k ^= zobEp[st.epSquare & 7];                  }                    if ((m & (3 << 14)) == (1 << 14))                  {                      PieceType promotion = (((m >> 12) & 3) + 2);                        Debug.Assert(Utils.relative_rank_CS(us' to) == RankC.RANK_8);                      Debug.Assert(promotion >= PieceTypeC.KNIGHT && promotion <= PieceTypeC.QUEEN);                        // Replace the pawn with the promoted piece                      byTypeBB[PieceTypeC.PAWN] ^= Utils.SquareBB[to];                      byTypeBB[promotion] |= Utils.SquareBB[to];                      board[to] = ((us << 3) | promotion);                        // Update piece lists' move the last pawn at index[to] position                      // and shrink the list. Add a new promotion piece to the list.                      int[] plUsPawn = pieceList[us][PieceTypeC.PAWN];                      Square lastSquare = plUsPawn[--pieceCount[us][PieceTypeC.PAWN]];                      index[lastSquare] = index[to];                      plUsPawn[index[lastSquare]] = lastSquare;                      plUsPawn[pieceCount[us][PieceTypeC.PAWN]] = SquareC.SQ_NONE;                      index[to] = pieceCount[us][promotion];                      pieceList[us][promotion][index[to]] = to;                        // Update hash keys                      k ^= zobrist[us][PieceTypeC.PAWN][to] ^ zobrist[us][promotion][to];                      st.pawnKey ^= zobrist[us][PieceTypeC.PAWN][to];                      st.materialKey ^= zobrist[us][promotion][pieceCount[us][promotion]++]                                        ^ zobrist[us][PieceTypeC.PAWN][pieceCount[us][PieceTypeC.PAWN]];                        // Update incremental score                      st.psqScore += pieceSquareTable[((us << 3) | promotion)][to] - pieceSquareTable[((us << 3) | PieceTypeC.PAWN)][to];                        // Update material                      if (us == 0) { st.npMaterialWHITE += PieceValueMidgame[promotion]; }                      else { st.npMaterialBLACK += PieceValueMidgame[promotion]; }                  }                    // Update pawn hash key                  st.pawnKey ^= zobrist[us][PieceTypeC.PAWN][from] ^ zobrist[us][PieceTypeC.PAWN][to];                    // Reset rule 50 draw counter                  st.rule50 = 0;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,do_move,The following statement contains a magic number: if (pt == PieceTypeC.PAWN)              {                  // Set en-passant square' only if moved pawn can be captured                  if ((to ^ from) == 16                      && ((((Utils.StepAttacksBB[((us << 3) | PieceTypeC.PAWN)][from + (us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)]) & (byTypeBB[PieceTypeC.PAWN] & byColorBB[them]))) != 0))                  {                      st.epSquare = ((from + to) / 2);                      k ^= zobEp[st.epSquare & 7];                  }                    if ((m & (3 << 14)) == (1 << 14))                  {                      PieceType promotion = (((m >> 12) & 3) + 2);                        Debug.Assert(Utils.relative_rank_CS(us' to) == RankC.RANK_8);                      Debug.Assert(promotion >= PieceTypeC.KNIGHT && promotion <= PieceTypeC.QUEEN);                        // Replace the pawn with the promoted piece                      byTypeBB[PieceTypeC.PAWN] ^= Utils.SquareBB[to];                      byTypeBB[promotion] |= Utils.SquareBB[to];                      board[to] = ((us << 3) | promotion);                        // Update piece lists' move the last pawn at index[to] position                      // and shrink the list. Add a new promotion piece to the list.                      int[] plUsPawn = pieceList[us][PieceTypeC.PAWN];                      Square lastSquare = plUsPawn[--pieceCount[us][PieceTypeC.PAWN]];                      index[lastSquare] = index[to];                      plUsPawn[index[lastSquare]] = lastSquare;                      plUsPawn[pieceCount[us][PieceTypeC.PAWN]] = SquareC.SQ_NONE;                      index[to] = pieceCount[us][promotion];                      pieceList[us][promotion][index[to]] = to;                        // Update hash keys                      k ^= zobrist[us][PieceTypeC.PAWN][to] ^ zobrist[us][promotion][to];                      st.pawnKey ^= zobrist[us][PieceTypeC.PAWN][to];                      st.materialKey ^= zobrist[us][promotion][pieceCount[us][promotion]++]                                        ^ zobrist[us][PieceTypeC.PAWN][pieceCount[us][PieceTypeC.PAWN]];                        // Update incremental score                      st.psqScore += pieceSquareTable[((us << 3) | promotion)][to] - pieceSquareTable[((us << 3) | PieceTypeC.PAWN)][to];                        // Update material                      if (us == 0) { st.npMaterialWHITE += PieceValueMidgame[promotion]; }                      else { st.npMaterialBLACK += PieceValueMidgame[promotion]; }                  }                    // Update pawn hash key                  st.pawnKey ^= zobrist[us][PieceTypeC.PAWN][from] ^ zobrist[us][PieceTypeC.PAWN][to];                    // Reset rule 50 draw counter                  st.rule50 = 0;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,do_move,The following statement contains a magic number: if (pt == PieceTypeC.PAWN)              {                  // Set en-passant square' only if moved pawn can be captured                  if ((to ^ from) == 16                      && ((((Utils.StepAttacksBB[((us << 3) | PieceTypeC.PAWN)][from + (us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)]) & (byTypeBB[PieceTypeC.PAWN] & byColorBB[them]))) != 0))                  {                      st.epSquare = ((from + to) / 2);                      k ^= zobEp[st.epSquare & 7];                  }                    if ((m & (3 << 14)) == (1 << 14))                  {                      PieceType promotion = (((m >> 12) & 3) + 2);                        Debug.Assert(Utils.relative_rank_CS(us' to) == RankC.RANK_8);                      Debug.Assert(promotion >= PieceTypeC.KNIGHT && promotion <= PieceTypeC.QUEEN);                        // Replace the pawn with the promoted piece                      byTypeBB[PieceTypeC.PAWN] ^= Utils.SquareBB[to];                      byTypeBB[promotion] |= Utils.SquareBB[to];                      board[to] = ((us << 3) | promotion);                        // Update piece lists' move the last pawn at index[to] position                      // and shrink the list. Add a new promotion piece to the list.                      int[] plUsPawn = pieceList[us][PieceTypeC.PAWN];                      Square lastSquare = plUsPawn[--pieceCount[us][PieceTypeC.PAWN]];                      index[lastSquare] = index[to];                      plUsPawn[index[lastSquare]] = lastSquare;                      plUsPawn[pieceCount[us][PieceTypeC.PAWN]] = SquareC.SQ_NONE;                      index[to] = pieceCount[us][promotion];                      pieceList[us][promotion][index[to]] = to;                        // Update hash keys                      k ^= zobrist[us][PieceTypeC.PAWN][to] ^ zobrist[us][promotion][to];                      st.pawnKey ^= zobrist[us][PieceTypeC.PAWN][to];                      st.materialKey ^= zobrist[us][promotion][pieceCount[us][promotion]++]                                        ^ zobrist[us][PieceTypeC.PAWN][pieceCount[us][PieceTypeC.PAWN]];                        // Update incremental score                      st.psqScore += pieceSquareTable[((us << 3) | promotion)][to] - pieceSquareTable[((us << 3) | PieceTypeC.PAWN)][to];                        // Update material                      if (us == 0) { st.npMaterialWHITE += PieceValueMidgame[promotion]; }                      else { st.npMaterialBLACK += PieceValueMidgame[promotion]; }                  }                    // Update pawn hash key                  st.pawnKey ^= zobrist[us][PieceTypeC.PAWN][from] ^ zobrist[us][PieceTypeC.PAWN][to];                    // Reset rule 50 draw counter                  st.rule50 = 0;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,do_move,The following statement contains a magic number: if (pt == PieceTypeC.PAWN)              {                  // Set en-passant square' only if moved pawn can be captured                  if ((to ^ from) == 16                      && ((((Utils.StepAttacksBB[((us << 3) | PieceTypeC.PAWN)][from + (us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)]) & (byTypeBB[PieceTypeC.PAWN] & byColorBB[them]))) != 0))                  {                      st.epSquare = ((from + to) / 2);                      k ^= zobEp[st.epSquare & 7];                  }                    if ((m & (3 << 14)) == (1 << 14))                  {                      PieceType promotion = (((m >> 12) & 3) + 2);                        Debug.Assert(Utils.relative_rank_CS(us' to) == RankC.RANK_8);                      Debug.Assert(promotion >= PieceTypeC.KNIGHT && promotion <= PieceTypeC.QUEEN);                        // Replace the pawn with the promoted piece                      byTypeBB[PieceTypeC.PAWN] ^= Utils.SquareBB[to];                      byTypeBB[promotion] |= Utils.SquareBB[to];                      board[to] = ((us << 3) | promotion);                        // Update piece lists' move the last pawn at index[to] position                      // and shrink the list. Add a new promotion piece to the list.                      int[] plUsPawn = pieceList[us][PieceTypeC.PAWN];                      Square lastSquare = plUsPawn[--pieceCount[us][PieceTypeC.PAWN]];                      index[lastSquare] = index[to];                      plUsPawn[index[lastSquare]] = lastSquare;                      plUsPawn[pieceCount[us][PieceTypeC.PAWN]] = SquareC.SQ_NONE;                      index[to] = pieceCount[us][promotion];                      pieceList[us][promotion][index[to]] = to;                        // Update hash keys                      k ^= zobrist[us][PieceTypeC.PAWN][to] ^ zobrist[us][promotion][to];                      st.pawnKey ^= zobrist[us][PieceTypeC.PAWN][to];                      st.materialKey ^= zobrist[us][promotion][pieceCount[us][promotion]++]                                        ^ zobrist[us][PieceTypeC.PAWN][pieceCount[us][PieceTypeC.PAWN]];                        // Update incremental score                      st.psqScore += pieceSquareTable[((us << 3) | promotion)][to] - pieceSquareTable[((us << 3) | PieceTypeC.PAWN)][to];                        // Update material                      if (us == 0) { st.npMaterialWHITE += PieceValueMidgame[promotion]; }                      else { st.npMaterialBLACK += PieceValueMidgame[promotion]; }                  }                    // Update pawn hash key                  st.pawnKey ^= zobrist[us][PieceTypeC.PAWN][from] ^ zobrist[us][PieceTypeC.PAWN][to];                    // Reset rule 50 draw counter                  st.rule50 = 0;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,do_move,The following statement contains a magic number: if (pt == PieceTypeC.PAWN)              {                  // Set en-passant square' only if moved pawn can be captured                  if ((to ^ from) == 16                      && ((((Utils.StepAttacksBB[((us << 3) | PieceTypeC.PAWN)][from + (us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)]) & (byTypeBB[PieceTypeC.PAWN] & byColorBB[them]))) != 0))                  {                      st.epSquare = ((from + to) / 2);                      k ^= zobEp[st.epSquare & 7];                  }                    if ((m & (3 << 14)) == (1 << 14))                  {                      PieceType promotion = (((m >> 12) & 3) + 2);                        Debug.Assert(Utils.relative_rank_CS(us' to) == RankC.RANK_8);                      Debug.Assert(promotion >= PieceTypeC.KNIGHT && promotion <= PieceTypeC.QUEEN);                        // Replace the pawn with the promoted piece                      byTypeBB[PieceTypeC.PAWN] ^= Utils.SquareBB[to];                      byTypeBB[promotion] |= Utils.SquareBB[to];                      board[to] = ((us << 3) | promotion);                        // Update piece lists' move the last pawn at index[to] position                      // and shrink the list. Add a new promotion piece to the list.                      int[] plUsPawn = pieceList[us][PieceTypeC.PAWN];                      Square lastSquare = plUsPawn[--pieceCount[us][PieceTypeC.PAWN]];                      index[lastSquare] = index[to];                      plUsPawn[index[lastSquare]] = lastSquare;                      plUsPawn[pieceCount[us][PieceTypeC.PAWN]] = SquareC.SQ_NONE;                      index[to] = pieceCount[us][promotion];                      pieceList[us][promotion][index[to]] = to;                        // Update hash keys                      k ^= zobrist[us][PieceTypeC.PAWN][to] ^ zobrist[us][promotion][to];                      st.pawnKey ^= zobrist[us][PieceTypeC.PAWN][to];                      st.materialKey ^= zobrist[us][promotion][pieceCount[us][promotion]++]                                        ^ zobrist[us][PieceTypeC.PAWN][pieceCount[us][PieceTypeC.PAWN]];                        // Update incremental score                      st.psqScore += pieceSquareTable[((us << 3) | promotion)][to] - pieceSquareTable[((us << 3) | PieceTypeC.PAWN)][to];                        // Update material                      if (us == 0) { st.npMaterialWHITE += PieceValueMidgame[promotion]; }                      else { st.npMaterialBLACK += PieceValueMidgame[promotion]; }                  }                    // Update pawn hash key                  st.pawnKey ^= zobrist[us][PieceTypeC.PAWN][from] ^ zobrist[us][PieceTypeC.PAWN][to];                    // Reset rule 50 draw counter                  st.rule50 = 0;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,do_move,The following statement contains a magic number: if (pt == PieceTypeC.PAWN)              {                  // Set en-passant square' only if moved pawn can be captured                  if ((to ^ from) == 16                      && ((((Utils.StepAttacksBB[((us << 3) | PieceTypeC.PAWN)][from + (us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)]) & (byTypeBB[PieceTypeC.PAWN] & byColorBB[them]))) != 0))                  {                      st.epSquare = ((from + to) / 2);                      k ^= zobEp[st.epSquare & 7];                  }                    if ((m & (3 << 14)) == (1 << 14))                  {                      PieceType promotion = (((m >> 12) & 3) + 2);                        Debug.Assert(Utils.relative_rank_CS(us' to) == RankC.RANK_8);                      Debug.Assert(promotion >= PieceTypeC.KNIGHT && promotion <= PieceTypeC.QUEEN);                        // Replace the pawn with the promoted piece                      byTypeBB[PieceTypeC.PAWN] ^= Utils.SquareBB[to];                      byTypeBB[promotion] |= Utils.SquareBB[to];                      board[to] = ((us << 3) | promotion);                        // Update piece lists' move the last pawn at index[to] position                      // and shrink the list. Add a new promotion piece to the list.                      int[] plUsPawn = pieceList[us][PieceTypeC.PAWN];                      Square lastSquare = plUsPawn[--pieceCount[us][PieceTypeC.PAWN]];                      index[lastSquare] = index[to];                      plUsPawn[index[lastSquare]] = lastSquare;                      plUsPawn[pieceCount[us][PieceTypeC.PAWN]] = SquareC.SQ_NONE;                      index[to] = pieceCount[us][promotion];                      pieceList[us][promotion][index[to]] = to;                        // Update hash keys                      k ^= zobrist[us][PieceTypeC.PAWN][to] ^ zobrist[us][promotion][to];                      st.pawnKey ^= zobrist[us][PieceTypeC.PAWN][to];                      st.materialKey ^= zobrist[us][promotion][pieceCount[us][promotion]++]                                        ^ zobrist[us][PieceTypeC.PAWN][pieceCount[us][PieceTypeC.PAWN]];                        // Update incremental score                      st.psqScore += pieceSquareTable[((us << 3) | promotion)][to] - pieceSquareTable[((us << 3) | PieceTypeC.PAWN)][to];                        // Update material                      if (us == 0) { st.npMaterialWHITE += PieceValueMidgame[promotion]; }                      else { st.npMaterialBLACK += PieceValueMidgame[promotion]; }                  }                    // Update pawn hash key                  st.pawnKey ^= zobrist[us][PieceTypeC.PAWN][from] ^ zobrist[us][PieceTypeC.PAWN][to];                    // Reset rule 50 draw counter                  st.rule50 = 0;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,do_move,The following statement contains a magic number: if (pt == PieceTypeC.PAWN)              {                  // Set en-passant square' only if moved pawn can be captured                  if ((to ^ from) == 16                      && ((((Utils.StepAttacksBB[((us << 3) | PieceTypeC.PAWN)][from + (us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)]) & (byTypeBB[PieceTypeC.PAWN] & byColorBB[them]))) != 0))                  {                      st.epSquare = ((from + to) / 2);                      k ^= zobEp[st.epSquare & 7];                  }                    if ((m & (3 << 14)) == (1 << 14))                  {                      PieceType promotion = (((m >> 12) & 3) + 2);                        Debug.Assert(Utils.relative_rank_CS(us' to) == RankC.RANK_8);                      Debug.Assert(promotion >= PieceTypeC.KNIGHT && promotion <= PieceTypeC.QUEEN);                        // Replace the pawn with the promoted piece                      byTypeBB[PieceTypeC.PAWN] ^= Utils.SquareBB[to];                      byTypeBB[promotion] |= Utils.SquareBB[to];                      board[to] = ((us << 3) | promotion);                        // Update piece lists' move the last pawn at index[to] position                      // and shrink the list. Add a new promotion piece to the list.                      int[] plUsPawn = pieceList[us][PieceTypeC.PAWN];                      Square lastSquare = plUsPawn[--pieceCount[us][PieceTypeC.PAWN]];                      index[lastSquare] = index[to];                      plUsPawn[index[lastSquare]] = lastSquare;                      plUsPawn[pieceCount[us][PieceTypeC.PAWN]] = SquareC.SQ_NONE;                      index[to] = pieceCount[us][promotion];                      pieceList[us][promotion][index[to]] = to;                        // Update hash keys                      k ^= zobrist[us][PieceTypeC.PAWN][to] ^ zobrist[us][promotion][to];                      st.pawnKey ^= zobrist[us][PieceTypeC.PAWN][to];                      st.materialKey ^= zobrist[us][promotion][pieceCount[us][promotion]++]                                        ^ zobrist[us][PieceTypeC.PAWN][pieceCount[us][PieceTypeC.PAWN]];                        // Update incremental score                      st.psqScore += pieceSquareTable[((us << 3) | promotion)][to] - pieceSquareTable[((us << 3) | PieceTypeC.PAWN)][to];                        // Update material                      if (us == 0) { st.npMaterialWHITE += PieceValueMidgame[promotion]; }                      else { st.npMaterialBLACK += PieceValueMidgame[promotion]; }                  }                    // Update pawn hash key                  st.pawnKey ^= zobrist[us][PieceTypeC.PAWN][from] ^ zobrist[us][PieceTypeC.PAWN][to];                    // Reset rule 50 draw counter                  st.rule50 = 0;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,do_move,The following statement contains a magic number: if (pt == PieceTypeC.PAWN)              {                  // Set en-passant square' only if moved pawn can be captured                  if ((to ^ from) == 16                      && ((((Utils.StepAttacksBB[((us << 3) | PieceTypeC.PAWN)][from + (us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)]) & (byTypeBB[PieceTypeC.PAWN] & byColorBB[them]))) != 0))                  {                      st.epSquare = ((from + to) / 2);                      k ^= zobEp[st.epSquare & 7];                  }                    if ((m & (3 << 14)) == (1 << 14))                  {                      PieceType promotion = (((m >> 12) & 3) + 2);                        Debug.Assert(Utils.relative_rank_CS(us' to) == RankC.RANK_8);                      Debug.Assert(promotion >= PieceTypeC.KNIGHT && promotion <= PieceTypeC.QUEEN);                        // Replace the pawn with the promoted piece                      byTypeBB[PieceTypeC.PAWN] ^= Utils.SquareBB[to];                      byTypeBB[promotion] |= Utils.SquareBB[to];                      board[to] = ((us << 3) | promotion);                        // Update piece lists' move the last pawn at index[to] position                      // and shrink the list. Add a new promotion piece to the list.                      int[] plUsPawn = pieceList[us][PieceTypeC.PAWN];                      Square lastSquare = plUsPawn[--pieceCount[us][PieceTypeC.PAWN]];                      index[lastSquare] = index[to];                      plUsPawn[index[lastSquare]] = lastSquare;                      plUsPawn[pieceCount[us][PieceTypeC.PAWN]] = SquareC.SQ_NONE;                      index[to] = pieceCount[us][promotion];                      pieceList[us][promotion][index[to]] = to;                        // Update hash keys                      k ^= zobrist[us][PieceTypeC.PAWN][to] ^ zobrist[us][promotion][to];                      st.pawnKey ^= zobrist[us][PieceTypeC.PAWN][to];                      st.materialKey ^= zobrist[us][promotion][pieceCount[us][promotion]++]                                        ^ zobrist[us][PieceTypeC.PAWN][pieceCount[us][PieceTypeC.PAWN]];                        // Update incremental score                      st.psqScore += pieceSquareTable[((us << 3) | promotion)][to] - pieceSquareTable[((us << 3) | PieceTypeC.PAWN)][to];                        // Update material                      if (us == 0) { st.npMaterialWHITE += PieceValueMidgame[promotion]; }                      else { st.npMaterialBLACK += PieceValueMidgame[promotion]; }                  }                    // Update pawn hash key                  st.pawnKey ^= zobrist[us][PieceTypeC.PAWN][from] ^ zobrist[us][PieceTypeC.PAWN][to];                    // Reset rule 50 draw counter                  st.rule50 = 0;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,do_move,The following statement contains a magic number: if (pt == PieceTypeC.PAWN)              {                  // Set en-passant square' only if moved pawn can be captured                  if ((to ^ from) == 16                      && ((((Utils.StepAttacksBB[((us << 3) | PieceTypeC.PAWN)][from + (us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)]) & (byTypeBB[PieceTypeC.PAWN] & byColorBB[them]))) != 0))                  {                      st.epSquare = ((from + to) / 2);                      k ^= zobEp[st.epSquare & 7];                  }                    if ((m & (3 << 14)) == (1 << 14))                  {                      PieceType promotion = (((m >> 12) & 3) + 2);                        Debug.Assert(Utils.relative_rank_CS(us' to) == RankC.RANK_8);                      Debug.Assert(promotion >= PieceTypeC.KNIGHT && promotion <= PieceTypeC.QUEEN);                        // Replace the pawn with the promoted piece                      byTypeBB[PieceTypeC.PAWN] ^= Utils.SquareBB[to];                      byTypeBB[promotion] |= Utils.SquareBB[to];                      board[to] = ((us << 3) | promotion);                        // Update piece lists' move the last pawn at index[to] position                      // and shrink the list. Add a new promotion piece to the list.                      int[] plUsPawn = pieceList[us][PieceTypeC.PAWN];                      Square lastSquare = plUsPawn[--pieceCount[us][PieceTypeC.PAWN]];                      index[lastSquare] = index[to];                      plUsPawn[index[lastSquare]] = lastSquare;                      plUsPawn[pieceCount[us][PieceTypeC.PAWN]] = SquareC.SQ_NONE;                      index[to] = pieceCount[us][promotion];                      pieceList[us][promotion][index[to]] = to;                        // Update hash keys                      k ^= zobrist[us][PieceTypeC.PAWN][to] ^ zobrist[us][promotion][to];                      st.pawnKey ^= zobrist[us][PieceTypeC.PAWN][to];                      st.materialKey ^= zobrist[us][promotion][pieceCount[us][promotion]++]                                        ^ zobrist[us][PieceTypeC.PAWN][pieceCount[us][PieceTypeC.PAWN]];                        // Update incremental score                      st.psqScore += pieceSquareTable[((us << 3) | promotion)][to] - pieceSquareTable[((us << 3) | PieceTypeC.PAWN)][to];                        // Update material                      if (us == 0) { st.npMaterialWHITE += PieceValueMidgame[promotion]; }                      else { st.npMaterialBLACK += PieceValueMidgame[promotion]; }                  }                    // Update pawn hash key                  st.pawnKey ^= zobrist[us][PieceTypeC.PAWN][from] ^ zobrist[us][PieceTypeC.PAWN][to];                    // Reset rule 50 draw counter                  st.rule50 = 0;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,do_move,The following statement contains a magic number: if (pt == PieceTypeC.PAWN)              {                  // Set en-passant square' only if moved pawn can be captured                  if ((to ^ from) == 16                      && ((((Utils.StepAttacksBB[((us << 3) | PieceTypeC.PAWN)][from + (us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)]) & (byTypeBB[PieceTypeC.PAWN] & byColorBB[them]))) != 0))                  {                      st.epSquare = ((from + to) / 2);                      k ^= zobEp[st.epSquare & 7];                  }                    if ((m & (3 << 14)) == (1 << 14))                  {                      PieceType promotion = (((m >> 12) & 3) + 2);                        Debug.Assert(Utils.relative_rank_CS(us' to) == RankC.RANK_8);                      Debug.Assert(promotion >= PieceTypeC.KNIGHT && promotion <= PieceTypeC.QUEEN);                        // Replace the pawn with the promoted piece                      byTypeBB[PieceTypeC.PAWN] ^= Utils.SquareBB[to];                      byTypeBB[promotion] |= Utils.SquareBB[to];                      board[to] = ((us << 3) | promotion);                        // Update piece lists' move the last pawn at index[to] position                      // and shrink the list. Add a new promotion piece to the list.                      int[] plUsPawn = pieceList[us][PieceTypeC.PAWN];                      Square lastSquare = plUsPawn[--pieceCount[us][PieceTypeC.PAWN]];                      index[lastSquare] = index[to];                      plUsPawn[index[lastSquare]] = lastSquare;                      plUsPawn[pieceCount[us][PieceTypeC.PAWN]] = SquareC.SQ_NONE;                      index[to] = pieceCount[us][promotion];                      pieceList[us][promotion][index[to]] = to;                        // Update hash keys                      k ^= zobrist[us][PieceTypeC.PAWN][to] ^ zobrist[us][promotion][to];                      st.pawnKey ^= zobrist[us][PieceTypeC.PAWN][to];                      st.materialKey ^= zobrist[us][promotion][pieceCount[us][promotion]++]                                        ^ zobrist[us][PieceTypeC.PAWN][pieceCount[us][PieceTypeC.PAWN]];                        // Update incremental score                      st.psqScore += pieceSquareTable[((us << 3) | promotion)][to] - pieceSquareTable[((us << 3) | PieceTypeC.PAWN)][to];                        // Update material                      if (us == 0) { st.npMaterialWHITE += PieceValueMidgame[promotion]; }                      else { st.npMaterialBLACK += PieceValueMidgame[promotion]; }                  }                    // Update pawn hash key                  st.pawnKey ^= zobrist[us][PieceTypeC.PAWN][from] ^ zobrist[us][PieceTypeC.PAWN][to];                    // Reset rule 50 draw counter                  st.rule50 = 0;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,do_move,The following statement contains a magic number: if (pt == PieceTypeC.PAWN)              {                  // Set en-passant square' only if moved pawn can be captured                  if ((to ^ from) == 16                      && ((((Utils.StepAttacksBB[((us << 3) | PieceTypeC.PAWN)][from + (us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S)]) & (byTypeBB[PieceTypeC.PAWN] & byColorBB[them]))) != 0))                  {                      st.epSquare = ((from + to) / 2);                      k ^= zobEp[st.epSquare & 7];                  }                    if ((m & (3 << 14)) == (1 << 14))                  {                      PieceType promotion = (((m >> 12) & 3) + 2);                        Debug.Assert(Utils.relative_rank_CS(us' to) == RankC.RANK_8);                      Debug.Assert(promotion >= PieceTypeC.KNIGHT && promotion <= PieceTypeC.QUEEN);                        // Replace the pawn with the promoted piece                      byTypeBB[PieceTypeC.PAWN] ^= Utils.SquareBB[to];                      byTypeBB[promotion] |= Utils.SquareBB[to];                      board[to] = ((us << 3) | promotion);                        // Update piece lists' move the last pawn at index[to] position                      // and shrink the list. Add a new promotion piece to the list.                      int[] plUsPawn = pieceList[us][PieceTypeC.PAWN];                      Square lastSquare = plUsPawn[--pieceCount[us][PieceTypeC.PAWN]];                      index[lastSquare] = index[to];                      plUsPawn[index[lastSquare]] = lastSquare;                      plUsPawn[pieceCount[us][PieceTypeC.PAWN]] = SquareC.SQ_NONE;                      index[to] = pieceCount[us][promotion];                      pieceList[us][promotion][index[to]] = to;                        // Update hash keys                      k ^= zobrist[us][PieceTypeC.PAWN][to] ^ zobrist[us][promotion][to];                      st.pawnKey ^= zobrist[us][PieceTypeC.PAWN][to];                      st.materialKey ^= zobrist[us][promotion][pieceCount[us][promotion]++]                                        ^ zobrist[us][PieceTypeC.PAWN][pieceCount[us][PieceTypeC.PAWN]];                        // Update incremental score                      st.psqScore += pieceSquareTable[((us << 3) | promotion)][to] - pieceSquareTable[((us << 3) | PieceTypeC.PAWN)][to];                        // Update material                      if (us == 0) { st.npMaterialWHITE += PieceValueMidgame[promotion]; }                      else { st.npMaterialBLACK += PieceValueMidgame[promotion]; }                  }                    // Update pawn hash key                  st.pawnKey ^= zobrist[us][PieceTypeC.PAWN][from] ^ zobrist[us][PieceTypeC.PAWN][to];                    // Reset rule 50 draw counter                  st.rule50 = 0;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,do_move,The following statement contains a magic number: if (moveIsCheck)              {                  if ((m & (3 << 14)) != 0)                      st.checkersBB = attackers_to(pieceList[them][PieceTypeC.KING][0]) & byColorBB[us];                  else                  {                      // Direct checks                      if ((ci.checkSq[pt] & Utils.SquareBB[to]) != 0)                      {                          st.checkersBB |= Utils.SquareBB[to];                      }                        // Discovery checks                      if ((ci.dcCandidates != 0) && ((ci.dcCandidates & Utils.SquareBB[from]) != 0))                      {                          if (pt != PieceTypeC.ROOK)                              st.checkersBB |= attacks_from_ROOK(pieceList[them][PieceTypeC.KING][0]) & ((byTypeBB[PieceTypeC.ROOK] | byTypeBB[PieceTypeC.QUEEN]) & byColorBB[us]);                            if (pt != PieceTypeC.BISHOP)                              st.checkersBB |= attacks_from_BISHOP(pieceList[them][PieceTypeC.KING][0]) & ((byTypeBB[PieceTypeC.BISHOP] | byTypeBB[PieceTypeC.QUEEN]) & byColorBB[us]);                      }                  }              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,do_move,The following statement contains a magic number: if (moveIsCheck)              {                  if ((m & (3 << 14)) != 0)                      st.checkersBB = attackers_to(pieceList[them][PieceTypeC.KING][0]) & byColorBB[us];                  else                  {                      // Direct checks                      if ((ci.checkSq[pt] & Utils.SquareBB[to]) != 0)                      {                          st.checkersBB |= Utils.SquareBB[to];                      }                        // Discovery checks                      if ((ci.dcCandidates != 0) && ((ci.dcCandidates & Utils.SquareBB[from]) != 0))                      {                          if (pt != PieceTypeC.ROOK)                              st.checkersBB |= attacks_from_ROOK(pieceList[them][PieceTypeC.KING][0]) & ((byTypeBB[PieceTypeC.ROOK] | byTypeBB[PieceTypeC.QUEEN]) & byColorBB[us]);                            if (pt != PieceTypeC.BISHOP)                              st.checkersBB |= attacks_from_BISHOP(pieceList[them][PieceTypeC.KING][0]) & ((byTypeBB[PieceTypeC.BISHOP] | byTypeBB[PieceTypeC.QUEEN]) & byColorBB[us]);                      }                  }              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,undo_move,The following statement contains a magic number: if ((m & (3 << 14)) == (3 << 14))              {                  do_castle_move(false' m);                  return;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,undo_move,The following statement contains a magic number: if ((m & (3 << 14)) == (3 << 14))              {                  do_castle_move(false' m);                  return;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,undo_move,The following statement contains a magic number: if ((m & (3 << 14)) == (3 << 14))              {                  do_castle_move(false' m);                  return;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,undo_move,The following statement contains a magic number: if ((m & (3 << 14)) == (3 << 14))              {                  do_castle_move(false' m);                  return;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,undo_move,The following statement contains a magic number: Square from = ((m >> 6) & 0x3F);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,undo_move,The following statement contains a magic number: PieceType pt = piece & 7;
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,undo_move,The following statement contains a magic number: if ((m & (3 << 14)) == (1 << 14))              {                  PieceType promotion = (((m >> 12) & 3) + 2);                    Debug.Assert(promotion == pt);                  Debug.Assert(Utils.relative_rank_CS(us' to) == RankC.RANK_8);                  Debug.Assert(promotion >= PieceTypeC.KNIGHT && promotion <= PieceTypeC.QUEEN);                    // Replace the promoted piece with the pawn                  byTypeBB[promotion] ^= Utils.SquareBB[to];                  byTypeBB[PieceTypeC.PAWN] |= Utils.SquareBB[to];                  board[to] = ((us << 3) | PieceTypeC.PAWN);                    // Update piece lists' move the last promoted piece at index[to] position                  // and shrink the list. Add a new pawn to the list.                  Square lastSquare = pieceList[us][promotion][--pieceCount[us][promotion]];                  index[lastSquare] = index[to];                  int[] plUsPromotion = pieceList[us][promotion];                  plUsPromotion[index[lastSquare]] = lastSquare;                  plUsPromotion[pieceCount[us][promotion]] = SquareC.SQ_NONE;                  index[to] = pieceCount[us][PieceTypeC.PAWN]++;                  pieceList[us][PieceTypeC.PAWN][index[to]] = to;                    pt = PieceTypeC.PAWN;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,undo_move,The following statement contains a magic number: if ((m & (3 << 14)) == (1 << 14))              {                  PieceType promotion = (((m >> 12) & 3) + 2);                    Debug.Assert(promotion == pt);                  Debug.Assert(Utils.relative_rank_CS(us' to) == RankC.RANK_8);                  Debug.Assert(promotion >= PieceTypeC.KNIGHT && promotion <= PieceTypeC.QUEEN);                    // Replace the promoted piece with the pawn                  byTypeBB[promotion] ^= Utils.SquareBB[to];                  byTypeBB[PieceTypeC.PAWN] |= Utils.SquareBB[to];                  board[to] = ((us << 3) | PieceTypeC.PAWN);                    // Update piece lists' move the last promoted piece at index[to] position                  // and shrink the list. Add a new pawn to the list.                  Square lastSquare = pieceList[us][promotion][--pieceCount[us][promotion]];                  index[lastSquare] = index[to];                  int[] plUsPromotion = pieceList[us][promotion];                  plUsPromotion[index[lastSquare]] = lastSquare;                  plUsPromotion[pieceCount[us][promotion]] = SquareC.SQ_NONE;                  index[to] = pieceCount[us][PieceTypeC.PAWN]++;                  pieceList[us][PieceTypeC.PAWN][index[to]] = to;                    pt = PieceTypeC.PAWN;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,undo_move,The following statement contains a magic number: if ((m & (3 << 14)) == (1 << 14))              {                  PieceType promotion = (((m >> 12) & 3) + 2);                    Debug.Assert(promotion == pt);                  Debug.Assert(Utils.relative_rank_CS(us' to) == RankC.RANK_8);                  Debug.Assert(promotion >= PieceTypeC.KNIGHT && promotion <= PieceTypeC.QUEEN);                    // Replace the promoted piece with the pawn                  byTypeBB[promotion] ^= Utils.SquareBB[to];                  byTypeBB[PieceTypeC.PAWN] |= Utils.SquareBB[to];                  board[to] = ((us << 3) | PieceTypeC.PAWN);                    // Update piece lists' move the last promoted piece at index[to] position                  // and shrink the list. Add a new pawn to the list.                  Square lastSquare = pieceList[us][promotion][--pieceCount[us][promotion]];                  index[lastSquare] = index[to];                  int[] plUsPromotion = pieceList[us][promotion];                  plUsPromotion[index[lastSquare]] = lastSquare;                  plUsPromotion[pieceCount[us][promotion]] = SquareC.SQ_NONE;                  index[to] = pieceCount[us][PieceTypeC.PAWN]++;                  pieceList[us][PieceTypeC.PAWN][index[to]] = to;                    pt = PieceTypeC.PAWN;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,undo_move,The following statement contains a magic number: if ((m & (3 << 14)) == (1 << 14))              {                  PieceType promotion = (((m >> 12) & 3) + 2);                    Debug.Assert(promotion == pt);                  Debug.Assert(Utils.relative_rank_CS(us' to) == RankC.RANK_8);                  Debug.Assert(promotion >= PieceTypeC.KNIGHT && promotion <= PieceTypeC.QUEEN);                    // Replace the promoted piece with the pawn                  byTypeBB[promotion] ^= Utils.SquareBB[to];                  byTypeBB[PieceTypeC.PAWN] |= Utils.SquareBB[to];                  board[to] = ((us << 3) | PieceTypeC.PAWN);                    // Update piece lists' move the last promoted piece at index[to] position                  // and shrink the list. Add a new pawn to the list.                  Square lastSquare = pieceList[us][promotion][--pieceCount[us][promotion]];                  index[lastSquare] = index[to];                  int[] plUsPromotion = pieceList[us][promotion];                  plUsPromotion[index[lastSquare]] = lastSquare;                  plUsPromotion[pieceCount[us][promotion]] = SquareC.SQ_NONE;                  index[to] = pieceCount[us][PieceTypeC.PAWN]++;                  pieceList[us][PieceTypeC.PAWN][index[to]] = to;                    pt = PieceTypeC.PAWN;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,undo_move,The following statement contains a magic number: if ((m & (3 << 14)) == (1 << 14))              {                  PieceType promotion = (((m >> 12) & 3) + 2);                    Debug.Assert(promotion == pt);                  Debug.Assert(Utils.relative_rank_CS(us' to) == RankC.RANK_8);                  Debug.Assert(promotion >= PieceTypeC.KNIGHT && promotion <= PieceTypeC.QUEEN);                    // Replace the promoted piece with the pawn                  byTypeBB[promotion] ^= Utils.SquareBB[to];                  byTypeBB[PieceTypeC.PAWN] |= Utils.SquareBB[to];                  board[to] = ((us << 3) | PieceTypeC.PAWN);                    // Update piece lists' move the last promoted piece at index[to] position                  // and shrink the list. Add a new pawn to the list.                  Square lastSquare = pieceList[us][promotion][--pieceCount[us][promotion]];                  index[lastSquare] = index[to];                  int[] plUsPromotion = pieceList[us][promotion];                  plUsPromotion[index[lastSquare]] = lastSquare;                  plUsPromotion[pieceCount[us][promotion]] = SquareC.SQ_NONE;                  index[to] = pieceCount[us][PieceTypeC.PAWN]++;                  pieceList[us][PieceTypeC.PAWN][index[to]] = to;                    pt = PieceTypeC.PAWN;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,undo_move,The following statement contains a magic number: if ((m & (3 << 14)) == (1 << 14))              {                  PieceType promotion = (((m >> 12) & 3) + 2);                    Debug.Assert(promotion == pt);                  Debug.Assert(Utils.relative_rank_CS(us' to) == RankC.RANK_8);                  Debug.Assert(promotion >= PieceTypeC.KNIGHT && promotion <= PieceTypeC.QUEEN);                    // Replace the promoted piece with the pawn                  byTypeBB[promotion] ^= Utils.SquareBB[to];                  byTypeBB[PieceTypeC.PAWN] |= Utils.SquareBB[to];                  board[to] = ((us << 3) | PieceTypeC.PAWN);                    // Update piece lists' move the last promoted piece at index[to] position                  // and shrink the list. Add a new pawn to the list.                  Square lastSquare = pieceList[us][promotion][--pieceCount[us][promotion]];                  index[lastSquare] = index[to];                  int[] plUsPromotion = pieceList[us][promotion];                  plUsPromotion[index[lastSquare]] = lastSquare;                  plUsPromotion[pieceCount[us][promotion]] = SquareC.SQ_NONE;                  index[to] = pieceCount[us][PieceTypeC.PAWN]++;                  pieceList[us][PieceTypeC.PAWN][index[to]] = to;                    pt = PieceTypeC.PAWN;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,undo_move,The following statement contains a magic number: if ((m & (3 << 14)) == (1 << 14))              {                  PieceType promotion = (((m >> 12) & 3) + 2);                    Debug.Assert(promotion == pt);                  Debug.Assert(Utils.relative_rank_CS(us' to) == RankC.RANK_8);                  Debug.Assert(promotion >= PieceTypeC.KNIGHT && promotion <= PieceTypeC.QUEEN);                    // Replace the promoted piece with the pawn                  byTypeBB[promotion] ^= Utils.SquareBB[to];                  byTypeBB[PieceTypeC.PAWN] |= Utils.SquareBB[to];                  board[to] = ((us << 3) | PieceTypeC.PAWN);                    // Update piece lists' move the last promoted piece at index[to] position                  // and shrink the list. Add a new pawn to the list.                  Square lastSquare = pieceList[us][promotion][--pieceCount[us][promotion]];                  index[lastSquare] = index[to];                  int[] plUsPromotion = pieceList[us][promotion];                  plUsPromotion[index[lastSquare]] = lastSquare;                  plUsPromotion[pieceCount[us][promotion]] = SquareC.SQ_NONE;                  index[to] = pieceCount[us][PieceTypeC.PAWN]++;                  pieceList[us][PieceTypeC.PAWN][index[to]] = to;                    pt = PieceTypeC.PAWN;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,undo_move,The following statement contains a magic number: if (capture != 0)              {                  Square capsq = to;                    if ((m & (3 << 14)) == (2 << 14))                  {                      capsq -= (us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                        Debug.Assert(pt == PieceTypeC.PAWN);                      Debug.Assert(to == st.previous.epSquare);                      Debug.Assert(Utils.relative_rank_CS(us' to) == RankC.RANK_6);                      Debug.Assert(piece_on(capsq) == PieceC.NO_PIECE);                  }                    // Restore the captured piece                  Bitboard capSqMask = Utils.SquareBB[capsq];                  occupied_squares |= capSqMask;                  byTypeBB[capture] |= capSqMask;                  byColorBB[them] |= capSqMask;                  board[capsq] = ((them << 3) | capture);                    // Update piece list' add a new captured piece in capsq square                  index[capsq] = pieceCount[them][capture]++;                  pieceList[them][capture][index[capsq]] = capsq;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,undo_move,The following statement contains a magic number: if (capture != 0)              {                  Square capsq = to;                    if ((m & (3 << 14)) == (2 << 14))                  {                      capsq -= (us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                        Debug.Assert(pt == PieceTypeC.PAWN);                      Debug.Assert(to == st.previous.epSquare);                      Debug.Assert(Utils.relative_rank_CS(us' to) == RankC.RANK_6);                      Debug.Assert(piece_on(capsq) == PieceC.NO_PIECE);                  }                    // Restore the captured piece                  Bitboard capSqMask = Utils.SquareBB[capsq];                  occupied_squares |= capSqMask;                  byTypeBB[capture] |= capSqMask;                  byColorBB[them] |= capSqMask;                  board[capsq] = ((them << 3) | capture);                    // Update piece list' add a new captured piece in capsq square                  index[capsq] = pieceCount[them][capture]++;                  pieceList[them][capture][index[capsq]] = capsq;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,undo_move,The following statement contains a magic number: if (capture != 0)              {                  Square capsq = to;                    if ((m & (3 << 14)) == (2 << 14))                  {                      capsq -= (us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                        Debug.Assert(pt == PieceTypeC.PAWN);                      Debug.Assert(to == st.previous.epSquare);                      Debug.Assert(Utils.relative_rank_CS(us' to) == RankC.RANK_6);                      Debug.Assert(piece_on(capsq) == PieceC.NO_PIECE);                  }                    // Restore the captured piece                  Bitboard capSqMask = Utils.SquareBB[capsq];                  occupied_squares |= capSqMask;                  byTypeBB[capture] |= capSqMask;                  byColorBB[them] |= capSqMask;                  board[capsq] = ((them << 3) | capture);                    // Update piece list' add a new captured piece in capsq square                  index[capsq] = pieceCount[them][capture]++;                  pieceList[them][capture][index[capsq]] = capsq;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,undo_move,The following statement contains a magic number: if (capture != 0)              {                  Square capsq = to;                    if ((m & (3 << 14)) == (2 << 14))                  {                      capsq -= (us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                        Debug.Assert(pt == PieceTypeC.PAWN);                      Debug.Assert(to == st.previous.epSquare);                      Debug.Assert(Utils.relative_rank_CS(us' to) == RankC.RANK_6);                      Debug.Assert(piece_on(capsq) == PieceC.NO_PIECE);                  }                    // Restore the captured piece                  Bitboard capSqMask = Utils.SquareBB[capsq];                  occupied_squares |= capSqMask;                  byTypeBB[capture] |= capSqMask;                  byColorBB[them] |= capSqMask;                  board[capsq] = ((them << 3) | capture);                    // Update piece list' add a new captured piece in capsq square                  index[capsq] = pieceCount[them][capture]++;                  pieceList[them][capture][index[capsq]] = capsq;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,undo_move,The following statement contains a magic number: if (capture != 0)              {                  Square capsq = to;                    if ((m & (3 << 14)) == (2 << 14))                  {                      capsq -= (us == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                        Debug.Assert(pt == PieceTypeC.PAWN);                      Debug.Assert(to == st.previous.epSquare);                      Debug.Assert(Utils.relative_rank_CS(us' to) == RankC.RANK_6);                      Debug.Assert(piece_on(capsq) == PieceC.NO_PIECE);                  }                    // Restore the captured piece                  Bitboard capSqMask = Utils.SquareBB[capsq];                  occupied_squares |= capSqMask;                  byTypeBB[capture] |= capSqMask;                  byColorBB[them] |= capSqMask;                  board[capsq] = ((them << 3) | capture);                    // Update piece list' add a new captured piece in capsq square                  index[capsq] = pieceCount[them][capture]++;                  pieceList[them][capture][index[capsq]] = capsq;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,see,The following statement contains a magic number: if ((with_sign) && (PieceValueMidgame[board[m & 0x3F]] >= PieceValueMidgame[board[((m >> 6) & 0x3F)]]))                  return 1;
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,see,The following statement contains a magic number: if ((m & (3 << 14)) == (3 << 14))                  return 0;
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,see,The following statement contains a magic number: if ((m & (3 << 14)) == (3 << 14))                  return 0;
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,see,The following statement contains a magic number: if ((m & (3 << 14)) == (3 << 14))                  return 0;
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,see,The following statement contains a magic number: if ((m & (3 << 14)) == (3 << 14))                  return 0;
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,see,The following statement contains a magic number: from = ((m >> 6) & 0x3F);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,see,The following statement contains a magic number: capturedType = board[to] & 7;
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,see,The following statement contains a magic number: if ((m & (3 << 14)) == (2 << 14))              {                  Square capQq = to - (sideToMove == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                    Debug.Assert(capturedType == 0);                  Debug.Assert(Utils.type_of(piece_on(capQq)) == PieceTypeC.PAWN);                    // Remove the captured pawn                  occ ^= Utils.SquareBB[capQq];                  capturedType = PieceTypeC.PAWN;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,see,The following statement contains a magic number: if ((m & (3 << 14)) == (2 << 14))              {                  Square capQq = to - (sideToMove == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                    Debug.Assert(capturedType == 0);                  Debug.Assert(Utils.type_of(piece_on(capQq)) == PieceTypeC.PAWN);                    // Remove the captured pawn                  occ ^= Utils.SquareBB[capQq];                  capturedType = PieceTypeC.PAWN;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,see,The following statement contains a magic number: if ((m & (3 << 14)) == (2 << 14))              {                  Square capQq = to - (sideToMove == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                    Debug.Assert(capturedType == 0);                  Debug.Assert(Utils.type_of(piece_on(capQq)) == PieceTypeC.PAWN);                    // Remove the captured pawn                  occ ^= Utils.SquareBB[capQq];                  capturedType = PieceTypeC.PAWN;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,see,The following statement contains a magic number: if ((m & (3 << 14)) == (2 << 14))              {                  Square capQq = to - (sideToMove == ColorC.WHITE ? SquareC.DELTA_N : SquareC.DELTA_S);                    Debug.Assert(capturedType == 0);                  Debug.Assert(Utils.type_of(piece_on(capQq)) == PieceTypeC.PAWN);                    // Remove the captured pawn                  occ ^= Utils.SquareBB[capQq];                  capturedType = PieceTypeC.PAWN;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,see,The following statement contains a magic number: stm = ((board[from] >> 3) ^ 1);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,see,The following statement contains a magic number: capturedType = board[from] & 7;
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,see,The following statement contains a magic number: do              {                  // Locate the least valuable attacker for the side to move. The loop                  // below looks like it is potentially infinite' but it isn't. We know                  // that the side to move still has at least one attacker left.                  for (pt = PieceTypeC.PAWN; (stmAttackers & byTypeBB[pt]) == 0; pt++)                      Debug.Assert(pt < PieceTypeC.KING);                    // Remove the attacker we just found from the 'occupied' bitboard'                  // and scan for new X-ray attacks behind the attacker.                  b = stmAttackers & byTypeBB[pt];                  occ ^= (b & (~b + 1));    #if X64                  attackers |= ((Utils.RAttacks[to][(((occ & Utils.RMasks[to]) * Utils.RMagics[to]) >> Utils.RShifts[to])]) & (byTypeBB[PieceTypeC.ROOK] | byTypeBB[PieceTypeC.QUEEN]))                              | ((Utils.BAttacks[to][(((occ & Utils.BMasks[to]) * Utils.BMagics[to]) >> Utils.BShifts[to])]) & (byTypeBB[PieceTypeC.BISHOP] | byTypeBB[PieceTypeC.QUEEN]));  #else                  attackers |= (Utils.rook_attacks_bb(to' occ) & (byTypeBB[PieceTypeC.ROOK] | byTypeBB[PieceTypeC.QUEEN]))                              | (Utils.bishop_attacks_bb(to' occ) & (byTypeBB[PieceTypeC.BISHOP] | byTypeBB[PieceTypeC.QUEEN]));  #endif                    attackers &= occ; // Cut out pieces we've already done                    // Add the new entry to the swap list                  Debug.Assert(slIndex < 32);                  swapList[slIndex] = -swapList[slIndex - 1] + PieceValueMidgame[capturedType];                  slIndex++;                    // Remember the value of the capturing piece' and change the side to                  // move before beginning the next iteration.                  capturedType = pt;                  stm = stm ^ 1;                  stmAttackers = attackers & byColorBB[stm];                    // Stop before processing a king capture                  if (capturedType == PieceTypeC.KING && (stmAttackers != 0))                  {                      Debug.Assert(slIndex < 32);                      swapList[slIndex++] = Constants.QueenValueMidgame * 10;                      break;                  }              } while (stmAttackers != 0);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,see,The following statement contains a magic number: do              {                  // Locate the least valuable attacker for the side to move. The loop                  // below looks like it is potentially infinite' but it isn't. We know                  // that the side to move still has at least one attacker left.                  for (pt = PieceTypeC.PAWN; (stmAttackers & byTypeBB[pt]) == 0; pt++)                      Debug.Assert(pt < PieceTypeC.KING);                    // Remove the attacker we just found from the 'occupied' bitboard'                  // and scan for new X-ray attacks behind the attacker.                  b = stmAttackers & byTypeBB[pt];                  occ ^= (b & (~b + 1));    #if X64                  attackers |= ((Utils.RAttacks[to][(((occ & Utils.RMasks[to]) * Utils.RMagics[to]) >> Utils.RShifts[to])]) & (byTypeBB[PieceTypeC.ROOK] | byTypeBB[PieceTypeC.QUEEN]))                              | ((Utils.BAttacks[to][(((occ & Utils.BMasks[to]) * Utils.BMagics[to]) >> Utils.BShifts[to])]) & (byTypeBB[PieceTypeC.BISHOP] | byTypeBB[PieceTypeC.QUEEN]));  #else                  attackers |= (Utils.rook_attacks_bb(to' occ) & (byTypeBB[PieceTypeC.ROOK] | byTypeBB[PieceTypeC.QUEEN]))                              | (Utils.bishop_attacks_bb(to' occ) & (byTypeBB[PieceTypeC.BISHOP] | byTypeBB[PieceTypeC.QUEEN]));  #endif                    attackers &= occ; // Cut out pieces we've already done                    // Add the new entry to the swap list                  Debug.Assert(slIndex < 32);                  swapList[slIndex] = -swapList[slIndex - 1] + PieceValueMidgame[capturedType];                  slIndex++;                    // Remember the value of the capturing piece' and change the side to                  // move before beginning the next iteration.                  capturedType = pt;                  stm = stm ^ 1;                  stmAttackers = attackers & byColorBB[stm];                    // Stop before processing a king capture                  if (capturedType == PieceTypeC.KING && (stmAttackers != 0))                  {                      Debug.Assert(slIndex < 32);                      swapList[slIndex++] = Constants.QueenValueMidgame * 10;                      break;                  }              } while (stmAttackers != 0);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,see,The following statement contains a magic number: do              {                  // Locate the least valuable attacker for the side to move. The loop                  // below looks like it is potentially infinite' but it isn't. We know                  // that the side to move still has at least one attacker left.                  for (pt = PieceTypeC.PAWN; (stmAttackers & byTypeBB[pt]) == 0; pt++)                      Debug.Assert(pt < PieceTypeC.KING);                    // Remove the attacker we just found from the 'occupied' bitboard'                  // and scan for new X-ray attacks behind the attacker.                  b = stmAttackers & byTypeBB[pt];                  occ ^= (b & (~b + 1));    #if X64                  attackers |= ((Utils.RAttacks[to][(((occ & Utils.RMasks[to]) * Utils.RMagics[to]) >> Utils.RShifts[to])]) & (byTypeBB[PieceTypeC.ROOK] | byTypeBB[PieceTypeC.QUEEN]))                              | ((Utils.BAttacks[to][(((occ & Utils.BMasks[to]) * Utils.BMagics[to]) >> Utils.BShifts[to])]) & (byTypeBB[PieceTypeC.BISHOP] | byTypeBB[PieceTypeC.QUEEN]));  #else                  attackers |= (Utils.rook_attacks_bb(to' occ) & (byTypeBB[PieceTypeC.ROOK] | byTypeBB[PieceTypeC.QUEEN]))                              | (Utils.bishop_attacks_bb(to' occ) & (byTypeBB[PieceTypeC.BISHOP] | byTypeBB[PieceTypeC.QUEEN]));  #endif                    attackers &= occ; // Cut out pieces we've already done                    // Add the new entry to the swap list                  Debug.Assert(slIndex < 32);                  swapList[slIndex] = -swapList[slIndex - 1] + PieceValueMidgame[capturedType];                  slIndex++;                    // Remember the value of the capturing piece' and change the side to                  // move before beginning the next iteration.                  capturedType = pt;                  stm = stm ^ 1;                  stmAttackers = attackers & byColorBB[stm];                    // Stop before processing a king capture                  if (capturedType == PieceTypeC.KING && (stmAttackers != 0))                  {                      Debug.Assert(slIndex < 32);                      swapList[slIndex++] = Constants.QueenValueMidgame * 10;                      break;                  }              } while (stmAttackers != 0);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,clear,The following statement contains a magic number: Array.Clear(byColorBB' 0' 2);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,clear,The following statement contains a magic number: Array.Clear(byTypeBB' 0' 8);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,clear,The following statement contains a magic number: Array.Clear(pieceCount[0]' 0' 8);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,clear,The following statement contains a magic number: Array.Clear(pieceCount[1]' 0' 8);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,clear,The following statement contains a magic number: Array.Clear(index' 0' 64);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,clear,The following statement contains a magic number: Array.Clear(castleRightsMask' 0' 64);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,clear,The following statement contains a magic number: Array.Clear(castleRookSquare[0]' 0' 2);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,clear,The following statement contains a magic number: Array.Clear(castleRookSquare[1]' 0' 2);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,clear,The following statement contains a magic number: Array.Clear(castlePath[0]' 0' 2);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,clear,The following statement contains a magic number: Array.Clear(castlePath[1]' 0' 2);
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,clear,The following statement contains a magic number: for (int i = 0; i < 8; i++)                  for (int j = 0; j < 16; j++)                      pieceList[0][i][j] = pieceList[1][i][j] = SquareC.SQ_NONE;
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,clear,The following statement contains a magic number: for (int i = 0; i < 8; i++)                  for (int j = 0; j < 16; j++)                      pieceList[0][i][j] = pieceList[1][i][j] = SquareC.SQ_NONE;
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,is_draw,The following statement contains a magic number: if (st.rule50 > 99)              {                  if (st.checkersBB == 0) return true;                  MList mlist = MListBroker.GetObject(); mlist.pos = 0;                  Position pos2 = this;                  Movegen.generate_legal(pos2' mlist.moves' ref mlist.pos);                  bool any = mlist.pos > 0;                  MListBroker.Free();                  if (any)                  {                      return true;                  }              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,is_draw,The following statement contains a magic number: if (!SkipRepetition)              {                  int i = 4' e = Math.Min(st.rule50' st.pliesFromNull);                  if (i <= e)                  {                      StateInfo stp = st.previous.previous;                      do                      {                          stp = stp.previous.previous;                          if (stp.key == st.key)                              return true;                          i += 2;                      } while (i <= e);                  }              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,is_draw,The following statement contains a magic number: if (!SkipRepetition)              {                  int i = 4' e = Math.Min(st.rule50' st.pliesFromNull);                  if (i <= e)                  {                      StateInfo stp = st.previous.previous;                      do                      {                          stp = stp.previous.previous;                          if (stp.key == st.key)                              return true;                          i += 2;                      } while (i <= e);                  }              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,init,The following statement contains a magic number: for (Color c = ColorC.WHITE; c <= ColorC.BLACK; c++)              {                  zobrist[c] = new Bitboard[8][];                  for (PieceType pt = PieceTypeC.PAWN; pt <= PieceTypeC.KING; pt++)                  {                      zobrist[c][pt] = new Bitboard[64];                      for (Square s = SquareC.SQ_A1; s <= SquareC.SQ_H8; s++)                      {                          zobrist[c][pt][s] = rk.rand();                      }                  }              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,init,The following statement contains a magic number: for (Color c = ColorC.WHITE; c <= ColorC.BLACK; c++)              {                  zobrist[c] = new Bitboard[8][];                  for (PieceType pt = PieceTypeC.PAWN; pt <= PieceTypeC.KING; pt++)                  {                      zobrist[c][pt] = new Bitboard[64];                      for (Square s = SquareC.SQ_A1; s <= SquareC.SQ_H8; s++)                      {                          zobrist[c][pt][s] = rk.rand();                      }                  }              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,init,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  pieceSquareTable[i] = new Score[64];              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,init,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  pieceSquareTable[i] = new Score[64];              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,flip,The following statement contains a magic number: for (Square s = SquareC.SQ_A1; s <= SquareC.SQ_H8; s++)                  if (!pos.is_empty(s))                      put_piece((pos.piece_on(s) ^ 8)' Utils.flip_S(s));
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,pos_is_ok,The following statement contains a magic number: if (debugKingCount)              {                  int[] kingCount = new int[2];                    for (Square s = SquareC.SQ_A1; s <= SquareC.SQ_H8; s++)                      if (Utils.type_of(piece_on(s)) == PieceTypeC.KING)                          kingCount[Utils.color_of(piece_on(s))]++;                    if (kingCount[0] != 1 || kingCount[1] != 1)                      return false;              }
Magic Number,Portfish,Position,C:\repos\bpfliegel_Portfish\src\Position.cs,pos_is_ok,The following statement contains a magic number: if (debugCheckerCount && Bitcount.popcount_1s_Full(st.checkersBB) > 2)                  return false;
Magic Number,Portfish,RKISS,C:\repos\bpfliegel_Portfish\src\RKISS.cs,RKISS,The following statement contains a magic number: for (int i = 0; i < 73; i++)              {                  rand();              }
Magic Number,Portfish,RKISS,C:\repos\bpfliegel_Portfish\src\RKISS.cs,rand,The following statement contains a magic number: e = a - ((b << 7) | (b >> 57));
Magic Number,Portfish,RKISS,C:\repos\bpfliegel_Portfish\src\RKISS.cs,rand,The following statement contains a magic number: e = a - ((b << 7) | (b >> 57));
Magic Number,Portfish,RKISS,C:\repos\bpfliegel_Portfish\src\RKISS.cs,rand,The following statement contains a magic number: a = b ^ ((c << 13) | (c >> 51));
Magic Number,Portfish,RKISS,C:\repos\bpfliegel_Portfish\src\RKISS.cs,rand,The following statement contains a magic number: a = b ^ ((c << 13) | (c >> 51));
Magic Number,Portfish,RKISS,C:\repos\bpfliegel_Portfish\src\RKISS.cs,rand,The following statement contains a magic number: b = c + ((d << 37) | (d >> 27));
Magic Number,Portfish,RKISS,C:\repos\bpfliegel_Portfish\src\RKISS.cs,rand,The following statement contains a magic number: b = c + ((d << 37) | (d >> 27));
Magic Number,Portfish,RootMove,C:\repos\bpfliegel_Portfish\src\Search.cs,extract_pv_from_tt,The following statement contains a magic number: while (TT.probe(pos.key()' ref ttePos' out tte)                && (m = tte.move()) != MoveC.MOVE_NONE // Local copy' TT entry could change                && pos.is_pseudo_legal(m)                && pos.pl_move_is_legal(m' pos.pinned_pieces())                && ply < Constants.MAX_PLY                && (!pos.is_draw(false) || ply < 2))             {                 pv.Add(m);                 pos.do_move(m' sia.state[stPos++]);                 ply++;             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,futility_margin,The following statement contains a magic number: return d < 7 * DepthC.ONE_PLY ? FutilityMargins[Math.Max(d' 1)][Math.Min(mn' 63)]                                    : 2 * ValueC.VALUE_INFINITE;
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,futility_margin,The following statement contains a magic number: return d < 7 * DepthC.ONE_PLY ? FutilityMargins[Math.Max(d' 1)][Math.Min(mn' 63)]                                    : 2 * ValueC.VALUE_INFINITE;
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,futility_margin,The following statement contains a magic number: return d < 7 * DepthC.ONE_PLY ? FutilityMargins[Math.Max(d' 1)][Math.Min(mn' 63)]                                    : 2 * ValueC.VALUE_INFINITE;
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,futility_move_count,The following statement contains a magic number: return d < 16 * DepthC.ONE_PLY ? FutilityMoveCounts[d] : Constants.MAX_MOVES;
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,reduction,The following statement contains a magic number: return (Depth)Reductions[PvNode ? 1 : 0][Math.Min((d) / DepthC.ONE_PLY' 63)][Math.Min(mn' 63)];
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,reduction,The following statement contains a magic number: return (Depth)Reductions[PvNode ? 1 : 0][Math.Min((d) / DepthC.ONE_PLY' 63)][Math.Min(mn' 63)];
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,is_dangerous,The following statement contains a magic number: if ((pos.board[((m >> 6) & 0x3F)] & 7) == PieceTypeC.PAWN)             {                 Color c = pos.sideToMove;                 if (Utils.relative_rank_CS(c' (m & 0x3F)) == RankC.RANK_7                     ||                     (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[c ^ 1]) & Utils.PassedPawnMask[c][(m & 0x3F)]) == 0)                     )                     return true;             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,is_dangerous,The following statement contains a magic number: if ((pos.board[((m >> 6) & 0x3F)] & 7) == PieceTypeC.PAWN)             {                 Color c = pos.sideToMove;                 if (Utils.relative_rank_CS(c' (m & 0x3F)) == RankC.RANK_7                     ||                     (((pos.byTypeBB[PieceTypeC.PAWN] & pos.byColorBB[c ^ 1]) & Utils.PassedPawnMask[c][(m & 0x3F)]) == 0)                     )                     return true;             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,is_dangerous,The following statement contains a magic number: if (captureOrPromotion                 && (pos.board[m & 0x3F] & 7) != PieceTypeC.PAWN                 && ((m & (3 << 14)) == 0)                 && (pos.st.npMaterialWHITE + pos.st.npMaterialBLACK - Position.PieceValueMidgame[pos.board[m & 0x3F]] == ValueC.VALUE_ZERO)                 )                 return true;
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,is_dangerous,The following statement contains a magic number: if (captureOrPromotion                 && (pos.board[m & 0x3F] & 7) != PieceTypeC.PAWN                 && ((m & (3 << 14)) == 0)                 && (pos.st.npMaterialWHITE + pos.st.npMaterialBLACK - Position.PieceValueMidgame[pos.board[m & 0x3F]] == ValueC.VALUE_ZERO)                 )                 return true;
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,is_dangerous,The following statement contains a magic number: if (captureOrPromotion                 && (pos.board[m & 0x3F] & 7) != PieceTypeC.PAWN                 && ((m & (3 << 14)) == 0)                 && (pos.st.npMaterialWHITE + pos.st.npMaterialBLACK - Position.PieceValueMidgame[pos.board[m & 0x3F]] == ValueC.VALUE_ZERO)                 )                 return true;
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,init,The following statement contains a magic number: Reductions[0] = new sbyte[64][];
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,init,The following statement contains a magic number: Reductions[1] = new sbyte[64][];
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,init,The following statement contains a magic number: for (hd = 0; hd < 64; hd++)             {                 Reductions[0][hd] = new sbyte[64];                 Reductions[1][hd] = new sbyte[64];                 if (hd != 0)                 {                     for (mc = 1; mc < 64; mc++)                     {                         double pvRed = Math.Log((double)(hd)) * Math.Log((double)(mc)) / 3.0;                         double nonPVRed = 0.33 + Math.Log((double)(hd)) * Math.Log((double)(mc)) / 2.25;                         Reductions[1][hd][mc] = (sbyte)(pvRed >= 1.0 ? Math.Floor(pvRed * (int)(DepthC.ONE_PLY)) : 0);                         Reductions[0][hd][mc] = (sbyte)(nonPVRed >= 1.0 ? Math.Floor(nonPVRed * (int)(DepthC.ONE_PLY)) : 0);                     }                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,init,The following statement contains a magic number: for (hd = 0; hd < 64; hd++)             {                 Reductions[0][hd] = new sbyte[64];                 Reductions[1][hd] = new sbyte[64];                 if (hd != 0)                 {                     for (mc = 1; mc < 64; mc++)                     {                         double pvRed = Math.Log((double)(hd)) * Math.Log((double)(mc)) / 3.0;                         double nonPVRed = 0.33 + Math.Log((double)(hd)) * Math.Log((double)(mc)) / 2.25;                         Reductions[1][hd][mc] = (sbyte)(pvRed >= 1.0 ? Math.Floor(pvRed * (int)(DepthC.ONE_PLY)) : 0);                         Reductions[0][hd][mc] = (sbyte)(nonPVRed >= 1.0 ? Math.Floor(nonPVRed * (int)(DepthC.ONE_PLY)) : 0);                     }                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,init,The following statement contains a magic number: for (hd = 0; hd < 64; hd++)             {                 Reductions[0][hd] = new sbyte[64];                 Reductions[1][hd] = new sbyte[64];                 if (hd != 0)                 {                     for (mc = 1; mc < 64; mc++)                     {                         double pvRed = Math.Log((double)(hd)) * Math.Log((double)(mc)) / 3.0;                         double nonPVRed = 0.33 + Math.Log((double)(hd)) * Math.Log((double)(mc)) / 2.25;                         Reductions[1][hd][mc] = (sbyte)(pvRed >= 1.0 ? Math.Floor(pvRed * (int)(DepthC.ONE_PLY)) : 0);                         Reductions[0][hd][mc] = (sbyte)(nonPVRed >= 1.0 ? Math.Floor(nonPVRed * (int)(DepthC.ONE_PLY)) : 0);                     }                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,init,The following statement contains a magic number: for (hd = 0; hd < 64; hd++)             {                 Reductions[0][hd] = new sbyte[64];                 Reductions[1][hd] = new sbyte[64];                 if (hd != 0)                 {                     for (mc = 1; mc < 64; mc++)                     {                         double pvRed = Math.Log((double)(hd)) * Math.Log((double)(mc)) / 3.0;                         double nonPVRed = 0.33 + Math.Log((double)(hd)) * Math.Log((double)(mc)) / 2.25;                         Reductions[1][hd][mc] = (sbyte)(pvRed >= 1.0 ? Math.Floor(pvRed * (int)(DepthC.ONE_PLY)) : 0);                         Reductions[0][hd][mc] = (sbyte)(nonPVRed >= 1.0 ? Math.Floor(nonPVRed * (int)(DepthC.ONE_PLY)) : 0);                     }                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,init,The following statement contains a magic number: for (hd = 0; hd < 64; hd++)             {                 Reductions[0][hd] = new sbyte[64];                 Reductions[1][hd] = new sbyte[64];                 if (hd != 0)                 {                     for (mc = 1; mc < 64; mc++)                     {                         double pvRed = Math.Log((double)(hd)) * Math.Log((double)(mc)) / 3.0;                         double nonPVRed = 0.33 + Math.Log((double)(hd)) * Math.Log((double)(mc)) / 2.25;                         Reductions[1][hd][mc] = (sbyte)(pvRed >= 1.0 ? Math.Floor(pvRed * (int)(DepthC.ONE_PLY)) : 0);                         Reductions[0][hd][mc] = (sbyte)(nonPVRed >= 1.0 ? Math.Floor(nonPVRed * (int)(DepthC.ONE_PLY)) : 0);                     }                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,init,The following statement contains a magic number: for (hd = 0; hd < 64; hd++)             {                 Reductions[0][hd] = new sbyte[64];                 Reductions[1][hd] = new sbyte[64];                 if (hd != 0)                 {                     for (mc = 1; mc < 64; mc++)                     {                         double pvRed = Math.Log((double)(hd)) * Math.Log((double)(mc)) / 3.0;                         double nonPVRed = 0.33 + Math.Log((double)(hd)) * Math.Log((double)(mc)) / 2.25;                         Reductions[1][hd][mc] = (sbyte)(pvRed >= 1.0 ? Math.Floor(pvRed * (int)(DepthC.ONE_PLY)) : 0);                         Reductions[0][hd][mc] = (sbyte)(nonPVRed >= 1.0 ? Math.Floor(nonPVRed * (int)(DepthC.ONE_PLY)) : 0);                     }                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,init,The following statement contains a magic number: for (hd = 0; hd < 64; hd++)             {                 Reductions[0][hd] = new sbyte[64];                 Reductions[1][hd] = new sbyte[64];                 if (hd != 0)                 {                     for (mc = 1; mc < 64; mc++)                     {                         double pvRed = Math.Log((double)(hd)) * Math.Log((double)(mc)) / 3.0;                         double nonPVRed = 0.33 + Math.Log((double)(hd)) * Math.Log((double)(mc)) / 2.25;                         Reductions[1][hd][mc] = (sbyte)(pvRed >= 1.0 ? Math.Floor(pvRed * (int)(DepthC.ONE_PLY)) : 0);                         Reductions[0][hd][mc] = (sbyte)(nonPVRed >= 1.0 ? Math.Floor(nonPVRed * (int)(DepthC.ONE_PLY)) : 0);                     }                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,init,The following statement contains a magic number: for (d = 0; d < 16; d++)             {                 FutilityMargins[d] = new Value[64];                 if (d != 0)                 {                     for (mc = 0; mc < 64; mc++)                     {                         FutilityMargins[d][mc] = (112 * (int)(Math.Log((double)(d * d) / 2) / Math.Log(2.0) + 1.001) - 8 * mc + 45);                     }                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,init,The following statement contains a magic number: for (d = 0; d < 16; d++)             {                 FutilityMargins[d] = new Value[64];                 if (d != 0)                 {                     for (mc = 0; mc < 64; mc++)                     {                         FutilityMargins[d][mc] = (112 * (int)(Math.Log((double)(d * d) / 2) / Math.Log(2.0) + 1.001) - 8 * mc + 45);                     }                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,init,The following statement contains a magic number: for (d = 0; d < 16; d++)             {                 FutilityMargins[d] = new Value[64];                 if (d != 0)                 {                     for (mc = 0; mc < 64; mc++)                     {                         FutilityMargins[d][mc] = (112 * (int)(Math.Log((double)(d * d) / 2) / Math.Log(2.0) + 1.001) - 8 * mc + 45);                     }                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,init,The following statement contains a magic number: for (d = 0; d < 16; d++)             {                 FutilityMargins[d] = new Value[64];                 if (d != 0)                 {                     for (mc = 0; mc < 64; mc++)                     {                         FutilityMargins[d][mc] = (112 * (int)(Math.Log((double)(d * d) / 2) / Math.Log(2.0) + 1.001) - 8 * mc + 45);                     }                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,init,The following statement contains a magic number: for (d = 0; d < 16; d++)             {                 FutilityMargins[d] = new Value[64];                 if (d != 0)                 {                     for (mc = 0; mc < 64; mc++)                     {                         FutilityMargins[d][mc] = (112 * (int)(Math.Log((double)(d * d) / 2) / Math.Log(2.0) + 1.001) - 8 * mc + 45);                     }                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,init,The following statement contains a magic number: for (d = 0; d < 16; d++)             {                 FutilityMargins[d] = new Value[64];                 if (d != 0)                 {                     for (mc = 0; mc < 64; mc++)                     {                         FutilityMargins[d][mc] = (112 * (int)(Math.Log((double)(d * d) / 2) / Math.Log(2.0) + 1.001) - 8 * mc + 45);                     }                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,init,The following statement contains a magic number: for (d = 0; d < 16; d++)             {                 FutilityMargins[d] = new Value[64];                 if (d != 0)                 {                     for (mc = 0; mc < 64; mc++)                     {                         FutilityMargins[d][mc] = (112 * (int)(Math.Log((double)(d * d) / 2) / Math.Log(2.0) + 1.001) - 8 * mc + 45);                     }                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,init,The following statement contains a magic number: for (d = 0; d < 16; d++)             {                 FutilityMargins[d] = new Value[64];                 if (d != 0)                 {                     for (mc = 0; mc < 64; mc++)                     {                         FutilityMargins[d][mc] = (112 * (int)(Math.Log((double)(d * d) / 2) / Math.Log(2.0) + 1.001) - 8 * mc + 45);                     }                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,init,The following statement contains a magic number: for (d = 0; d < 16; d++)             {                 FutilityMargins[d] = new Value[64];                 if (d != 0)                 {                     for (mc = 0; mc < 64; mc++)                     {                         FutilityMargins[d][mc] = (112 * (int)(Math.Log((double)(d * d) / 2) / Math.Log(2.0) + 1.001) - 8 * mc + 45);                     }                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,init,The following statement contains a magic number: for (d = 0; d < 32; d++)                 FutilityMoveCounts[d] = (int)(3.001 + 0.25 * Math.Pow(d' 2.0));
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,init,The following statement contains a magic number: for (d = 0; d < 32; d++)                 FutilityMoveCounts[d] = (int)(3.001 + 0.25 * Math.Pow(d' 2.0));
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,init,The following statement contains a magic number: for (d = 0; d < 32; d++)                 FutilityMoveCounts[d] = (int)(3.001 + 0.25 * Math.Pow(d' 2.0));
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,init,The following statement contains a magic number: for (d = 0; d < 32; d++)                 FutilityMoveCounts[d] = (int)(3.001 + 0.25 * Math.Pow(d' 2.0));
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,validmoves,The following statement contains a magic number: if (stack.Count > 0)              {                  string squareFromString = stack.Pop();                    StateInfo st = new StateInfo();                  MList mlist = MListBroker.GetObject(); mlist.pos = 0;                  Movegen.generate_legal(pos' mlist.moves' ref mlist.pos);                    bool firstOne = true;                  for (int i = 0; i < mlist.pos; ++i)                  {                      MoveStack ms = mlist.moves[i];                      Move m = ms.move;                      Square from = ((m >> 6) & 0x3F);                      if (Utils.square_to_string(from) == squareFromString)                      {                          if (!firstOne) { Plug.Write(" "); }                          Plug.Write(Utils.move_to_uci(m' false));                          firstOne = false;                      }                  }                  MListBroker.Free();              }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,think,The following statement contains a magic number: SkillLevelEnabled = (SkillLevel < 20);
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,think,The following statement contains a magic number: MultiPV = (SkillLevelEnabled ? Math.Max(UCIMultiPV' (Int32)4) : UCIMultiPV);
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,think,The following statement contains a magic number: if (Limits.use_time_management())                 Threads.set_timer(Math.Min(100' Math.Max(TimeMgr.available_time() / 16' TimerResolution)));             else                 Threads.set_timer(100);
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,think,The following statement contains a magic number: if (Limits.use_time_management())                 Threads.set_timer(Math.Min(100' Math.Max(TimeMgr.available_time() / 16' TimerResolution)));             else                 Threads.set_timer(100);
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,think,The following statement contains a magic number: if (Limits.use_time_management())                 Threads.set_timer(Math.Min(100' Math.Max(TimeMgr.available_time() / 16' TimerResolution)));             else                 Threads.set_timer(100);
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,id_loop,The following statement contains a magic number: while (!SignalsStop && ++depth <= Constants.MAX_PLY && ((Limits.depth == 0) || depth <= Limits.depth))             {                 // Save last iteration's scores before first PV line is searched and all                 // the move scores but the (new) PV are set to -VALUE_INFINITE.                 for (int i = 0; i < RootMoves.Count; i++)                     RootMoves[i].prevScore = RootMoves[i].score;                  prevBestMoveChanges = BestMoveChanges;                 BestMoveChanges = 0;                  // MultiPV loop. We perform a full root search for each PV line                 for (PVIdx = 0; PVIdx < Math.Min(MultiPV' RootMoves.Count); PVIdx++)                 {                     // Set aspiration window default width                     if (depth >= 5 && Math.Abs(RootMoves[PVIdx].prevScore) < ValueC.VALUE_KNOWN_WIN)                     {                         delta = 16;                         alpha = RootMoves[PVIdx].prevScore - delta;                         beta = RootMoves[PVIdx].prevScore + delta;                     }                     else                     {                         alpha = -ValueC.VALUE_INFINITE;                         beta = ValueC.VALUE_INFINITE;                     }                      // Start with a small aspiration window and' in case of fail high/low'                     // research with bigger window until not failing high/low anymore.                     do                     {                         // Search starts from ss+1 to allow referencing (ss-1). This is                         // needed by update gains and ss copy when splitting at Root.                         bestValue = search(NodeTypeC.Root' pos' ss' ssPos + 1' alpha' beta' depth * DepthC.ONE_PLY);                          // Bring to front the best move. It is critical that sorting is                         // done with a stable algorithm because all the values but the first                         // and eventually the new best one are set to -VALUE_INFINITE and                         // we want to keep the same order for all the moves but the new                         // PV that goes to the front. Note that in case of MultiPV search                         // the already searched PV lines are preserved.                         Utils.sort(RootMoves' PVIdx' RootMoves.Count);                         //sort<RootMove>(RootMoves.begin() + PVIdx' RootMoves.end());                          // In case we have found an exact score and we are going to leave                         // the fail high/low loop then reorder the PV moves' otherwise                         // leave the last PV move in its position so to be searched again.                         // Of course this is needed only in MultiPV search.                         if ((PVIdx != 0) && bestValue > alpha && bestValue < beta)                         {                             Utils.sort(RootMoves' 0' PVIdx);                         }                          // Write PV back to transposition table in case the relevant                         // entries have been overwritten during the search.                         for (int i = 0; i <= PVIdx; i++)                             RootMoves[i].insert_pv_in_tt(pos);                          // If search has been stopped exit the aspiration window loop.                         // Sorting and writing PV back to TT is safe becuase RootMoves                         // is still valid' although refers to previous iteration.                         if (SignalsStop)                             break;                          // Send full PV info to GUI if we are going to leave the loop or                         // if we have a fail high/low and we are deep in the search.                         if ((bestValue > alpha && bestValue < beta) || SearchTime.ElapsedMilliseconds > 2000)                             pv_info_to_uci(pos' depth' alpha' beta);                          // In case of failing high/low increase aspiration window and                         // research' otherwise exit the fail high/low loop.                         if (bestValue >= beta)                         {                             beta += delta;                             delta += delta / 2;                         }                         else if (bestValue <= alpha)                         {                             SignalsFailedLowAtRoot = true;                             SignalsStopOnPonderhit = false;                              alpha -= delta;                             delta += delta / 2;                         }                         else                             break;                          Debug.Assert(alpha >= -ValueC.VALUE_INFINITE && beta <= ValueC.VALUE_INFINITE);                      } while (Math.Abs(bestValue) < ValueC.VALUE_KNOWN_WIN);                 }                  // Skills: Do we need to pick now the best move ?                 if (SkillLevelEnabled && depth == 1 + SkillLevel)                     skillBest = do_skill_level();                  // Filter out startup noise when monitoring best move stability                 if (depth > 2 && (BestMoveChanges != 0))                     bestMoveNeverChanged = false;                  // Do we have time for the next iteration? Can we stop searching now?                 if (!SignalsStop && !SignalsStopOnPonderhit && Limits.use_time_management())                 {                     bool stop = false; // Local variable' not the volatile Signals.stop                      // Take in account some extra time if the best move has changed                     if (depth > 4 && depth < 50)                         TimeMgr.pv_instability(BestMoveChanges' prevBestMoveChanges);                      // Stop search if most of available time is already consumed. We                     // probably don't have enough time to search the first move at the                     // next iteration anyway.                     if (SearchTime.ElapsedMilliseconds > (TimeMgr.available_time() * 62) / 100)                         stop = true;                      // Stop search early if one move seems to be much better than others                     if (depth >= 12                         && !stop                         && ((bestMoveNeverChanged && (pos.captured_piece_type() != 0))                             || SearchTime.ElapsedMilliseconds > (TimeMgr.available_time() * 40) / 100))                     {                         Value rBeta = bestValue - EasyMoveMargin;                         ss[ssPos + 1].excludedMove = RootMoves[0].pv[0];                         ss[ssPos + 1].skipNullMove = 1;                         Value v = search(NodeTypeC.NonPV' pos' ss' ssPos + 1' rBeta - 1' rBeta' (depth - 3) * DepthC.ONE_PLY);                         ss[ssPos + 1].skipNullMove = 0;                         ss[ssPos + 1].excludedMove = MoveC.MOVE_NONE;                          if (v < rBeta)                             stop = true;                     }                      if (stop)                     {                         // If we are allowed to ponder do not stop the search now but                         // keep pondering until GUI sends "ponderhit" or "stop".                         if (Limits.ponder)                             SignalsStopOnPonderhit = true;                         else                             SignalsStop = true;                     }                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,id_loop,The following statement contains a magic number: while (!SignalsStop && ++depth <= Constants.MAX_PLY && ((Limits.depth == 0) || depth <= Limits.depth))             {                 // Save last iteration's scores before first PV line is searched and all                 // the move scores but the (new) PV are set to -VALUE_INFINITE.                 for (int i = 0; i < RootMoves.Count; i++)                     RootMoves[i].prevScore = RootMoves[i].score;                  prevBestMoveChanges = BestMoveChanges;                 BestMoveChanges = 0;                  // MultiPV loop. We perform a full root search for each PV line                 for (PVIdx = 0; PVIdx < Math.Min(MultiPV' RootMoves.Count); PVIdx++)                 {                     // Set aspiration window default width                     if (depth >= 5 && Math.Abs(RootMoves[PVIdx].prevScore) < ValueC.VALUE_KNOWN_WIN)                     {                         delta = 16;                         alpha = RootMoves[PVIdx].prevScore - delta;                         beta = RootMoves[PVIdx].prevScore + delta;                     }                     else                     {                         alpha = -ValueC.VALUE_INFINITE;                         beta = ValueC.VALUE_INFINITE;                     }                      // Start with a small aspiration window and' in case of fail high/low'                     // research with bigger window until not failing high/low anymore.                     do                     {                         // Search starts from ss+1 to allow referencing (ss-1). This is                         // needed by update gains and ss copy when splitting at Root.                         bestValue = search(NodeTypeC.Root' pos' ss' ssPos + 1' alpha' beta' depth * DepthC.ONE_PLY);                          // Bring to front the best move. It is critical that sorting is                         // done with a stable algorithm because all the values but the first                         // and eventually the new best one are set to -VALUE_INFINITE and                         // we want to keep the same order for all the moves but the new                         // PV that goes to the front. Note that in case of MultiPV search                         // the already searched PV lines are preserved.                         Utils.sort(RootMoves' PVIdx' RootMoves.Count);                         //sort<RootMove>(RootMoves.begin() + PVIdx' RootMoves.end());                          // In case we have found an exact score and we are going to leave                         // the fail high/low loop then reorder the PV moves' otherwise                         // leave the last PV move in its position so to be searched again.                         // Of course this is needed only in MultiPV search.                         if ((PVIdx != 0) && bestValue > alpha && bestValue < beta)                         {                             Utils.sort(RootMoves' 0' PVIdx);                         }                          // Write PV back to transposition table in case the relevant                         // entries have been overwritten during the search.                         for (int i = 0; i <= PVIdx; i++)                             RootMoves[i].insert_pv_in_tt(pos);                          // If search has been stopped exit the aspiration window loop.                         // Sorting and writing PV back to TT is safe becuase RootMoves                         // is still valid' although refers to previous iteration.                         if (SignalsStop)                             break;                          // Send full PV info to GUI if we are going to leave the loop or                         // if we have a fail high/low and we are deep in the search.                         if ((bestValue > alpha && bestValue < beta) || SearchTime.ElapsedMilliseconds > 2000)                             pv_info_to_uci(pos' depth' alpha' beta);                          // In case of failing high/low increase aspiration window and                         // research' otherwise exit the fail high/low loop.                         if (bestValue >= beta)                         {                             beta += delta;                             delta += delta / 2;                         }                         else if (bestValue <= alpha)                         {                             SignalsFailedLowAtRoot = true;                             SignalsStopOnPonderhit = false;                              alpha -= delta;                             delta += delta / 2;                         }                         else                             break;                          Debug.Assert(alpha >= -ValueC.VALUE_INFINITE && beta <= ValueC.VALUE_INFINITE);                      } while (Math.Abs(bestValue) < ValueC.VALUE_KNOWN_WIN);                 }                  // Skills: Do we need to pick now the best move ?                 if (SkillLevelEnabled && depth == 1 + SkillLevel)                     skillBest = do_skill_level();                  // Filter out startup noise when monitoring best move stability                 if (depth > 2 && (BestMoveChanges != 0))                     bestMoveNeverChanged = false;                  // Do we have time for the next iteration? Can we stop searching now?                 if (!SignalsStop && !SignalsStopOnPonderhit && Limits.use_time_management())                 {                     bool stop = false; // Local variable' not the volatile Signals.stop                      // Take in account some extra time if the best move has changed                     if (depth > 4 && depth < 50)                         TimeMgr.pv_instability(BestMoveChanges' prevBestMoveChanges);                      // Stop search if most of available time is already consumed. We                     // probably don't have enough time to search the first move at the                     // next iteration anyway.                     if (SearchTime.ElapsedMilliseconds > (TimeMgr.available_time() * 62) / 100)                         stop = true;                      // Stop search early if one move seems to be much better than others                     if (depth >= 12                         && !stop                         && ((bestMoveNeverChanged && (pos.captured_piece_type() != 0))                             || SearchTime.ElapsedMilliseconds > (TimeMgr.available_time() * 40) / 100))                     {                         Value rBeta = bestValue - EasyMoveMargin;                         ss[ssPos + 1].excludedMove = RootMoves[0].pv[0];                         ss[ssPos + 1].skipNullMove = 1;                         Value v = search(NodeTypeC.NonPV' pos' ss' ssPos + 1' rBeta - 1' rBeta' (depth - 3) * DepthC.ONE_PLY);                         ss[ssPos + 1].skipNullMove = 0;                         ss[ssPos + 1].excludedMove = MoveC.MOVE_NONE;                          if (v < rBeta)                             stop = true;                     }                      if (stop)                     {                         // If we are allowed to ponder do not stop the search now but                         // keep pondering until GUI sends "ponderhit" or "stop".                         if (Limits.ponder)                             SignalsStopOnPonderhit = true;                         else                             SignalsStop = true;                     }                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,id_loop,The following statement contains a magic number: while (!SignalsStop && ++depth <= Constants.MAX_PLY && ((Limits.depth == 0) || depth <= Limits.depth))             {                 // Save last iteration's scores before first PV line is searched and all                 // the move scores but the (new) PV are set to -VALUE_INFINITE.                 for (int i = 0; i < RootMoves.Count; i++)                     RootMoves[i].prevScore = RootMoves[i].score;                  prevBestMoveChanges = BestMoveChanges;                 BestMoveChanges = 0;                  // MultiPV loop. We perform a full root search for each PV line                 for (PVIdx = 0; PVIdx < Math.Min(MultiPV' RootMoves.Count); PVIdx++)                 {                     // Set aspiration window default width                     if (depth >= 5 && Math.Abs(RootMoves[PVIdx].prevScore) < ValueC.VALUE_KNOWN_WIN)                     {                         delta = 16;                         alpha = RootMoves[PVIdx].prevScore - delta;                         beta = RootMoves[PVIdx].prevScore + delta;                     }                     else                     {                         alpha = -ValueC.VALUE_INFINITE;                         beta = ValueC.VALUE_INFINITE;                     }                      // Start with a small aspiration window and' in case of fail high/low'                     // research with bigger window until not failing high/low anymore.                     do                     {                         // Search starts from ss+1 to allow referencing (ss-1). This is                         // needed by update gains and ss copy when splitting at Root.                         bestValue = search(NodeTypeC.Root' pos' ss' ssPos + 1' alpha' beta' depth * DepthC.ONE_PLY);                          // Bring to front the best move. It is critical that sorting is                         // done with a stable algorithm because all the values but the first                         // and eventually the new best one are set to -VALUE_INFINITE and                         // we want to keep the same order for all the moves but the new                         // PV that goes to the front. Note that in case of MultiPV search                         // the already searched PV lines are preserved.                         Utils.sort(RootMoves' PVIdx' RootMoves.Count);                         //sort<RootMove>(RootMoves.begin() + PVIdx' RootMoves.end());                          // In case we have found an exact score and we are going to leave                         // the fail high/low loop then reorder the PV moves' otherwise                         // leave the last PV move in its position so to be searched again.                         // Of course this is needed only in MultiPV search.                         if ((PVIdx != 0) && bestValue > alpha && bestValue < beta)                         {                             Utils.sort(RootMoves' 0' PVIdx);                         }                          // Write PV back to transposition table in case the relevant                         // entries have been overwritten during the search.                         for (int i = 0; i <= PVIdx; i++)                             RootMoves[i].insert_pv_in_tt(pos);                          // If search has been stopped exit the aspiration window loop.                         // Sorting and writing PV back to TT is safe becuase RootMoves                         // is still valid' although refers to previous iteration.                         if (SignalsStop)                             break;                          // Send full PV info to GUI if we are going to leave the loop or                         // if we have a fail high/low and we are deep in the search.                         if ((bestValue > alpha && bestValue < beta) || SearchTime.ElapsedMilliseconds > 2000)                             pv_info_to_uci(pos' depth' alpha' beta);                          // In case of failing high/low increase aspiration window and                         // research' otherwise exit the fail high/low loop.                         if (bestValue >= beta)                         {                             beta += delta;                             delta += delta / 2;                         }                         else if (bestValue <= alpha)                         {                             SignalsFailedLowAtRoot = true;                             SignalsStopOnPonderhit = false;                              alpha -= delta;                             delta += delta / 2;                         }                         else                             break;                          Debug.Assert(alpha >= -ValueC.VALUE_INFINITE && beta <= ValueC.VALUE_INFINITE);                      } while (Math.Abs(bestValue) < ValueC.VALUE_KNOWN_WIN);                 }                  // Skills: Do we need to pick now the best move ?                 if (SkillLevelEnabled && depth == 1 + SkillLevel)                     skillBest = do_skill_level();                  // Filter out startup noise when monitoring best move stability                 if (depth > 2 && (BestMoveChanges != 0))                     bestMoveNeverChanged = false;                  // Do we have time for the next iteration? Can we stop searching now?                 if (!SignalsStop && !SignalsStopOnPonderhit && Limits.use_time_management())                 {                     bool stop = false; // Local variable' not the volatile Signals.stop                      // Take in account some extra time if the best move has changed                     if (depth > 4 && depth < 50)                         TimeMgr.pv_instability(BestMoveChanges' prevBestMoveChanges);                      // Stop search if most of available time is already consumed. We                     // probably don't have enough time to search the first move at the                     // next iteration anyway.                     if (SearchTime.ElapsedMilliseconds > (TimeMgr.available_time() * 62) / 100)                         stop = true;                      // Stop search early if one move seems to be much better than others                     if (depth >= 12                         && !stop                         && ((bestMoveNeverChanged && (pos.captured_piece_type() != 0))                             || SearchTime.ElapsedMilliseconds > (TimeMgr.available_time() * 40) / 100))                     {                         Value rBeta = bestValue - EasyMoveMargin;                         ss[ssPos + 1].excludedMove = RootMoves[0].pv[0];                         ss[ssPos + 1].skipNullMove = 1;                         Value v = search(NodeTypeC.NonPV' pos' ss' ssPos + 1' rBeta - 1' rBeta' (depth - 3) * DepthC.ONE_PLY);                         ss[ssPos + 1].skipNullMove = 0;                         ss[ssPos + 1].excludedMove = MoveC.MOVE_NONE;                          if (v < rBeta)                             stop = true;                     }                      if (stop)                     {                         // If we are allowed to ponder do not stop the search now but                         // keep pondering until GUI sends "ponderhit" or "stop".                         if (Limits.ponder)                             SignalsStopOnPonderhit = true;                         else                             SignalsStop = true;                     }                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,id_loop,The following statement contains a magic number: while (!SignalsStop && ++depth <= Constants.MAX_PLY && ((Limits.depth == 0) || depth <= Limits.depth))             {                 // Save last iteration's scores before first PV line is searched and all                 // the move scores but the (new) PV are set to -VALUE_INFINITE.                 for (int i = 0; i < RootMoves.Count; i++)                     RootMoves[i].prevScore = RootMoves[i].score;                  prevBestMoveChanges = BestMoveChanges;                 BestMoveChanges = 0;                  // MultiPV loop. We perform a full root search for each PV line                 for (PVIdx = 0; PVIdx < Math.Min(MultiPV' RootMoves.Count); PVIdx++)                 {                     // Set aspiration window default width                     if (depth >= 5 && Math.Abs(RootMoves[PVIdx].prevScore) < ValueC.VALUE_KNOWN_WIN)                     {                         delta = 16;                         alpha = RootMoves[PVIdx].prevScore - delta;                         beta = RootMoves[PVIdx].prevScore + delta;                     }                     else                     {                         alpha = -ValueC.VALUE_INFINITE;                         beta = ValueC.VALUE_INFINITE;                     }                      // Start with a small aspiration window and' in case of fail high/low'                     // research with bigger window until not failing high/low anymore.                     do                     {                         // Search starts from ss+1 to allow referencing (ss-1). This is                         // needed by update gains and ss copy when splitting at Root.                         bestValue = search(NodeTypeC.Root' pos' ss' ssPos + 1' alpha' beta' depth * DepthC.ONE_PLY);                          // Bring to front the best move. It is critical that sorting is                         // done with a stable algorithm because all the values but the first                         // and eventually the new best one are set to -VALUE_INFINITE and                         // we want to keep the same order for all the moves but the new                         // PV that goes to the front. Note that in case of MultiPV search                         // the already searched PV lines are preserved.                         Utils.sort(RootMoves' PVIdx' RootMoves.Count);                         //sort<RootMove>(RootMoves.begin() + PVIdx' RootMoves.end());                          // In case we have found an exact score and we are going to leave                         // the fail high/low loop then reorder the PV moves' otherwise                         // leave the last PV move in its position so to be searched again.                         // Of course this is needed only in MultiPV search.                         if ((PVIdx != 0) && bestValue > alpha && bestValue < beta)                         {                             Utils.sort(RootMoves' 0' PVIdx);                         }                          // Write PV back to transposition table in case the relevant                         // entries have been overwritten during the search.                         for (int i = 0; i <= PVIdx; i++)                             RootMoves[i].insert_pv_in_tt(pos);                          // If search has been stopped exit the aspiration window loop.                         // Sorting and writing PV back to TT is safe becuase RootMoves                         // is still valid' although refers to previous iteration.                         if (SignalsStop)                             break;                          // Send full PV info to GUI if we are going to leave the loop or                         // if we have a fail high/low and we are deep in the search.                         if ((bestValue > alpha && bestValue < beta) || SearchTime.ElapsedMilliseconds > 2000)                             pv_info_to_uci(pos' depth' alpha' beta);                          // In case of failing high/low increase aspiration window and                         // research' otherwise exit the fail high/low loop.                         if (bestValue >= beta)                         {                             beta += delta;                             delta += delta / 2;                         }                         else if (bestValue <= alpha)                         {                             SignalsFailedLowAtRoot = true;                             SignalsStopOnPonderhit = false;                              alpha -= delta;                             delta += delta / 2;                         }                         else                             break;                          Debug.Assert(alpha >= -ValueC.VALUE_INFINITE && beta <= ValueC.VALUE_INFINITE);                      } while (Math.Abs(bestValue) < ValueC.VALUE_KNOWN_WIN);                 }                  // Skills: Do we need to pick now the best move ?                 if (SkillLevelEnabled && depth == 1 + SkillLevel)                     skillBest = do_skill_level();                  // Filter out startup noise when monitoring best move stability                 if (depth > 2 && (BestMoveChanges != 0))                     bestMoveNeverChanged = false;                  // Do we have time for the next iteration? Can we stop searching now?                 if (!SignalsStop && !SignalsStopOnPonderhit && Limits.use_time_management())                 {                     bool stop = false; // Local variable' not the volatile Signals.stop                      // Take in account some extra time if the best move has changed                     if (depth > 4 && depth < 50)                         TimeMgr.pv_instability(BestMoveChanges' prevBestMoveChanges);                      // Stop search if most of available time is already consumed. We                     // probably don't have enough time to search the first move at the                     // next iteration anyway.                     if (SearchTime.ElapsedMilliseconds > (TimeMgr.available_time() * 62) / 100)                         stop = true;                      // Stop search early if one move seems to be much better than others                     if (depth >= 12                         && !stop                         && ((bestMoveNeverChanged && (pos.captured_piece_type() != 0))                             || SearchTime.ElapsedMilliseconds > (TimeMgr.available_time() * 40) / 100))                     {                         Value rBeta = bestValue - EasyMoveMargin;                         ss[ssPos + 1].excludedMove = RootMoves[0].pv[0];                         ss[ssPos + 1].skipNullMove = 1;                         Value v = search(NodeTypeC.NonPV' pos' ss' ssPos + 1' rBeta - 1' rBeta' (depth - 3) * DepthC.ONE_PLY);                         ss[ssPos + 1].skipNullMove = 0;                         ss[ssPos + 1].excludedMove = MoveC.MOVE_NONE;                          if (v < rBeta)                             stop = true;                     }                      if (stop)                     {                         // If we are allowed to ponder do not stop the search now but                         // keep pondering until GUI sends "ponderhit" or "stop".                         if (Limits.ponder)                             SignalsStopOnPonderhit = true;                         else                             SignalsStop = true;                     }                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,id_loop,The following statement contains a magic number: while (!SignalsStop && ++depth <= Constants.MAX_PLY && ((Limits.depth == 0) || depth <= Limits.depth))             {                 // Save last iteration's scores before first PV line is searched and all                 // the move scores but the (new) PV are set to -VALUE_INFINITE.                 for (int i = 0; i < RootMoves.Count; i++)                     RootMoves[i].prevScore = RootMoves[i].score;                  prevBestMoveChanges = BestMoveChanges;                 BestMoveChanges = 0;                  // MultiPV loop. We perform a full root search for each PV line                 for (PVIdx = 0; PVIdx < Math.Min(MultiPV' RootMoves.Count); PVIdx++)                 {                     // Set aspiration window default width                     if (depth >= 5 && Math.Abs(RootMoves[PVIdx].prevScore) < ValueC.VALUE_KNOWN_WIN)                     {                         delta = 16;                         alpha = RootMoves[PVIdx].prevScore - delta;                         beta = RootMoves[PVIdx].prevScore + delta;                     }                     else                     {                         alpha = -ValueC.VALUE_INFINITE;                         beta = ValueC.VALUE_INFINITE;                     }                      // Start with a small aspiration window and' in case of fail high/low'                     // research with bigger window until not failing high/low anymore.                     do                     {                         // Search starts from ss+1 to allow referencing (ss-1). This is                         // needed by update gains and ss copy when splitting at Root.                         bestValue = search(NodeTypeC.Root' pos' ss' ssPos + 1' alpha' beta' depth * DepthC.ONE_PLY);                          // Bring to front the best move. It is critical that sorting is                         // done with a stable algorithm because all the values but the first                         // and eventually the new best one are set to -VALUE_INFINITE and                         // we want to keep the same order for all the moves but the new                         // PV that goes to the front. Note that in case of MultiPV search                         // the already searched PV lines are preserved.                         Utils.sort(RootMoves' PVIdx' RootMoves.Count);                         //sort<RootMove>(RootMoves.begin() + PVIdx' RootMoves.end());                          // In case we have found an exact score and we are going to leave                         // the fail high/low loop then reorder the PV moves' otherwise                         // leave the last PV move in its position so to be searched again.                         // Of course this is needed only in MultiPV search.                         if ((PVIdx != 0) && bestValue > alpha && bestValue < beta)                         {                             Utils.sort(RootMoves' 0' PVIdx);                         }                          // Write PV back to transposition table in case the relevant                         // entries have been overwritten during the search.                         for (int i = 0; i <= PVIdx; i++)                             RootMoves[i].insert_pv_in_tt(pos);                          // If search has been stopped exit the aspiration window loop.                         // Sorting and writing PV back to TT is safe becuase RootMoves                         // is still valid' although refers to previous iteration.                         if (SignalsStop)                             break;                          // Send full PV info to GUI if we are going to leave the loop or                         // if we have a fail high/low and we are deep in the search.                         if ((bestValue > alpha && bestValue < beta) || SearchTime.ElapsedMilliseconds > 2000)                             pv_info_to_uci(pos' depth' alpha' beta);                          // In case of failing high/low increase aspiration window and                         // research' otherwise exit the fail high/low loop.                         if (bestValue >= beta)                         {                             beta += delta;                             delta += delta / 2;                         }                         else if (bestValue <= alpha)                         {                             SignalsFailedLowAtRoot = true;                             SignalsStopOnPonderhit = false;                              alpha -= delta;                             delta += delta / 2;                         }                         else                             break;                          Debug.Assert(alpha >= -ValueC.VALUE_INFINITE && beta <= ValueC.VALUE_INFINITE);                      } while (Math.Abs(bestValue) < ValueC.VALUE_KNOWN_WIN);                 }                  // Skills: Do we need to pick now the best move ?                 if (SkillLevelEnabled && depth == 1 + SkillLevel)                     skillBest = do_skill_level();                  // Filter out startup noise when monitoring best move stability                 if (depth > 2 && (BestMoveChanges != 0))                     bestMoveNeverChanged = false;                  // Do we have time for the next iteration? Can we stop searching now?                 if (!SignalsStop && !SignalsStopOnPonderhit && Limits.use_time_management())                 {                     bool stop = false; // Local variable' not the volatile Signals.stop                      // Take in account some extra time if the best move has changed                     if (depth > 4 && depth < 50)                         TimeMgr.pv_instability(BestMoveChanges' prevBestMoveChanges);                      // Stop search if most of available time is already consumed. We                     // probably don't have enough time to search the first move at the                     // next iteration anyway.                     if (SearchTime.ElapsedMilliseconds > (TimeMgr.available_time() * 62) / 100)                         stop = true;                      // Stop search early if one move seems to be much better than others                     if (depth >= 12                         && !stop                         && ((bestMoveNeverChanged && (pos.captured_piece_type() != 0))                             || SearchTime.ElapsedMilliseconds > (TimeMgr.available_time() * 40) / 100))                     {                         Value rBeta = bestValue - EasyMoveMargin;                         ss[ssPos + 1].excludedMove = RootMoves[0].pv[0];                         ss[ssPos + 1].skipNullMove = 1;                         Value v = search(NodeTypeC.NonPV' pos' ss' ssPos + 1' rBeta - 1' rBeta' (depth - 3) * DepthC.ONE_PLY);                         ss[ssPos + 1].skipNullMove = 0;                         ss[ssPos + 1].excludedMove = MoveC.MOVE_NONE;                          if (v < rBeta)                             stop = true;                     }                      if (stop)                     {                         // If we are allowed to ponder do not stop the search now but                         // keep pondering until GUI sends "ponderhit" or "stop".                         if (Limits.ponder)                             SignalsStopOnPonderhit = true;                         else                             SignalsStop = true;                     }                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,id_loop,The following statement contains a magic number: while (!SignalsStop && ++depth <= Constants.MAX_PLY && ((Limits.depth == 0) || depth <= Limits.depth))             {                 // Save last iteration's scores before first PV line is searched and all                 // the move scores but the (new) PV are set to -VALUE_INFINITE.                 for (int i = 0; i < RootMoves.Count; i++)                     RootMoves[i].prevScore = RootMoves[i].score;                  prevBestMoveChanges = BestMoveChanges;                 BestMoveChanges = 0;                  // MultiPV loop. We perform a full root search for each PV line                 for (PVIdx = 0; PVIdx < Math.Min(MultiPV' RootMoves.Count); PVIdx++)                 {                     // Set aspiration window default width                     if (depth >= 5 && Math.Abs(RootMoves[PVIdx].prevScore) < ValueC.VALUE_KNOWN_WIN)                     {                         delta = 16;                         alpha = RootMoves[PVIdx].prevScore - delta;                         beta = RootMoves[PVIdx].prevScore + delta;                     }                     else                     {                         alpha = -ValueC.VALUE_INFINITE;                         beta = ValueC.VALUE_INFINITE;                     }                      // Start with a small aspiration window and' in case of fail high/low'                     // research with bigger window until not failing high/low anymore.                     do                     {                         // Search starts from ss+1 to allow referencing (ss-1). This is                         // needed by update gains and ss copy when splitting at Root.                         bestValue = search(NodeTypeC.Root' pos' ss' ssPos + 1' alpha' beta' depth * DepthC.ONE_PLY);                          // Bring to front the best move. It is critical that sorting is                         // done with a stable algorithm because all the values but the first                         // and eventually the new best one are set to -VALUE_INFINITE and                         // we want to keep the same order for all the moves but the new                         // PV that goes to the front. Note that in case of MultiPV search                         // the already searched PV lines are preserved.                         Utils.sort(RootMoves' PVIdx' RootMoves.Count);                         //sort<RootMove>(RootMoves.begin() + PVIdx' RootMoves.end());                          // In case we have found an exact score and we are going to leave                         // the fail high/low loop then reorder the PV moves' otherwise                         // leave the last PV move in its position so to be searched again.                         // Of course this is needed only in MultiPV search.                         if ((PVIdx != 0) && bestValue > alpha && bestValue < beta)                         {                             Utils.sort(RootMoves' 0' PVIdx);                         }                          // Write PV back to transposition table in case the relevant                         // entries have been overwritten during the search.                         for (int i = 0; i <= PVIdx; i++)                             RootMoves[i].insert_pv_in_tt(pos);                          // If search has been stopped exit the aspiration window loop.                         // Sorting and writing PV back to TT is safe becuase RootMoves                         // is still valid' although refers to previous iteration.                         if (SignalsStop)                             break;                          // Send full PV info to GUI if we are going to leave the loop or                         // if we have a fail high/low and we are deep in the search.                         if ((bestValue > alpha && bestValue < beta) || SearchTime.ElapsedMilliseconds > 2000)                             pv_info_to_uci(pos' depth' alpha' beta);                          // In case of failing high/low increase aspiration window and                         // research' otherwise exit the fail high/low loop.                         if (bestValue >= beta)                         {                             beta += delta;                             delta += delta / 2;                         }                         else if (bestValue <= alpha)                         {                             SignalsFailedLowAtRoot = true;                             SignalsStopOnPonderhit = false;                              alpha -= delta;                             delta += delta / 2;                         }                         else                             break;                          Debug.Assert(alpha >= -ValueC.VALUE_INFINITE && beta <= ValueC.VALUE_INFINITE);                      } while (Math.Abs(bestValue) < ValueC.VALUE_KNOWN_WIN);                 }                  // Skills: Do we need to pick now the best move ?                 if (SkillLevelEnabled && depth == 1 + SkillLevel)                     skillBest = do_skill_level();                  // Filter out startup noise when monitoring best move stability                 if (depth > 2 && (BestMoveChanges != 0))                     bestMoveNeverChanged = false;                  // Do we have time for the next iteration? Can we stop searching now?                 if (!SignalsStop && !SignalsStopOnPonderhit && Limits.use_time_management())                 {                     bool stop = false; // Local variable' not the volatile Signals.stop                      // Take in account some extra time if the best move has changed                     if (depth > 4 && depth < 50)                         TimeMgr.pv_instability(BestMoveChanges' prevBestMoveChanges);                      // Stop search if most of available time is already consumed. We                     // probably don't have enough time to search the first move at the                     // next iteration anyway.                     if (SearchTime.ElapsedMilliseconds > (TimeMgr.available_time() * 62) / 100)                         stop = true;                      // Stop search early if one move seems to be much better than others                     if (depth >= 12                         && !stop                         && ((bestMoveNeverChanged && (pos.captured_piece_type() != 0))                             || SearchTime.ElapsedMilliseconds > (TimeMgr.available_time() * 40) / 100))                     {                         Value rBeta = bestValue - EasyMoveMargin;                         ss[ssPos + 1].excludedMove = RootMoves[0].pv[0];                         ss[ssPos + 1].skipNullMove = 1;                         Value v = search(NodeTypeC.NonPV' pos' ss' ssPos + 1' rBeta - 1' rBeta' (depth - 3) * DepthC.ONE_PLY);                         ss[ssPos + 1].skipNullMove = 0;                         ss[ssPos + 1].excludedMove = MoveC.MOVE_NONE;                          if (v < rBeta)                             stop = true;                     }                      if (stop)                     {                         // If we are allowed to ponder do not stop the search now but                         // keep pondering until GUI sends "ponderhit" or "stop".                         if (Limits.ponder)                             SignalsStopOnPonderhit = true;                         else                             SignalsStop = true;                     }                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,id_loop,The following statement contains a magic number: while (!SignalsStop && ++depth <= Constants.MAX_PLY && ((Limits.depth == 0) || depth <= Limits.depth))             {                 // Save last iteration's scores before first PV line is searched and all                 // the move scores but the (new) PV are set to -VALUE_INFINITE.                 for (int i = 0; i < RootMoves.Count; i++)                     RootMoves[i].prevScore = RootMoves[i].score;                  prevBestMoveChanges = BestMoveChanges;                 BestMoveChanges = 0;                  // MultiPV loop. We perform a full root search for each PV line                 for (PVIdx = 0; PVIdx < Math.Min(MultiPV' RootMoves.Count); PVIdx++)                 {                     // Set aspiration window default width                     if (depth >= 5 && Math.Abs(RootMoves[PVIdx].prevScore) < ValueC.VALUE_KNOWN_WIN)                     {                         delta = 16;                         alpha = RootMoves[PVIdx].prevScore - delta;                         beta = RootMoves[PVIdx].prevScore + delta;                     }                     else                     {                         alpha = -ValueC.VALUE_INFINITE;                         beta = ValueC.VALUE_INFINITE;                     }                      // Start with a small aspiration window and' in case of fail high/low'                     // research with bigger window until not failing high/low anymore.                     do                     {                         // Search starts from ss+1 to allow referencing (ss-1). This is                         // needed by update gains and ss copy when splitting at Root.                         bestValue = search(NodeTypeC.Root' pos' ss' ssPos + 1' alpha' beta' depth * DepthC.ONE_PLY);                          // Bring to front the best move. It is critical that sorting is                         // done with a stable algorithm because all the values but the first                         // and eventually the new best one are set to -VALUE_INFINITE and                         // we want to keep the same order for all the moves but the new                         // PV that goes to the front. Note that in case of MultiPV search                         // the already searched PV lines are preserved.                         Utils.sort(RootMoves' PVIdx' RootMoves.Count);                         //sort<RootMove>(RootMoves.begin() + PVIdx' RootMoves.end());                          // In case we have found an exact score and we are going to leave                         // the fail high/low loop then reorder the PV moves' otherwise                         // leave the last PV move in its position so to be searched again.                         // Of course this is needed only in MultiPV search.                         if ((PVIdx != 0) && bestValue > alpha && bestValue < beta)                         {                             Utils.sort(RootMoves' 0' PVIdx);                         }                          // Write PV back to transposition table in case the relevant                         // entries have been overwritten during the search.                         for (int i = 0; i <= PVIdx; i++)                             RootMoves[i].insert_pv_in_tt(pos);                          // If search has been stopped exit the aspiration window loop.                         // Sorting and writing PV back to TT is safe becuase RootMoves                         // is still valid' although refers to previous iteration.                         if (SignalsStop)                             break;                          // Send full PV info to GUI if we are going to leave the loop or                         // if we have a fail high/low and we are deep in the search.                         if ((bestValue > alpha && bestValue < beta) || SearchTime.ElapsedMilliseconds > 2000)                             pv_info_to_uci(pos' depth' alpha' beta);                          // In case of failing high/low increase aspiration window and                         // research' otherwise exit the fail high/low loop.                         if (bestValue >= beta)                         {                             beta += delta;                             delta += delta / 2;                         }                         else if (bestValue <= alpha)                         {                             SignalsFailedLowAtRoot = true;                             SignalsStopOnPonderhit = false;                              alpha -= delta;                             delta += delta / 2;                         }                         else                             break;                          Debug.Assert(alpha >= -ValueC.VALUE_INFINITE && beta <= ValueC.VALUE_INFINITE);                      } while (Math.Abs(bestValue) < ValueC.VALUE_KNOWN_WIN);                 }                  // Skills: Do we need to pick now the best move ?                 if (SkillLevelEnabled && depth == 1 + SkillLevel)                     skillBest = do_skill_level();                  // Filter out startup noise when monitoring best move stability                 if (depth > 2 && (BestMoveChanges != 0))                     bestMoveNeverChanged = false;                  // Do we have time for the next iteration? Can we stop searching now?                 if (!SignalsStop && !SignalsStopOnPonderhit && Limits.use_time_management())                 {                     bool stop = false; // Local variable' not the volatile Signals.stop                      // Take in account some extra time if the best move has changed                     if (depth > 4 && depth < 50)                         TimeMgr.pv_instability(BestMoveChanges' prevBestMoveChanges);                      // Stop search if most of available time is already consumed. We                     // probably don't have enough time to search the first move at the                     // next iteration anyway.                     if (SearchTime.ElapsedMilliseconds > (TimeMgr.available_time() * 62) / 100)                         stop = true;                      // Stop search early if one move seems to be much better than others                     if (depth >= 12                         && !stop                         && ((bestMoveNeverChanged && (pos.captured_piece_type() != 0))                             || SearchTime.ElapsedMilliseconds > (TimeMgr.available_time() * 40) / 100))                     {                         Value rBeta = bestValue - EasyMoveMargin;                         ss[ssPos + 1].excludedMove = RootMoves[0].pv[0];                         ss[ssPos + 1].skipNullMove = 1;                         Value v = search(NodeTypeC.NonPV' pos' ss' ssPos + 1' rBeta - 1' rBeta' (depth - 3) * DepthC.ONE_PLY);                         ss[ssPos + 1].skipNullMove = 0;                         ss[ssPos + 1].excludedMove = MoveC.MOVE_NONE;                          if (v < rBeta)                             stop = true;                     }                      if (stop)                     {                         // If we are allowed to ponder do not stop the search now but                         // keep pondering until GUI sends "ponderhit" or "stop".                         if (Limits.ponder)                             SignalsStopOnPonderhit = true;                         else                             SignalsStop = true;                     }                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,id_loop,The following statement contains a magic number: while (!SignalsStop && ++depth <= Constants.MAX_PLY && ((Limits.depth == 0) || depth <= Limits.depth))             {                 // Save last iteration's scores before first PV line is searched and all                 // the move scores but the (new) PV are set to -VALUE_INFINITE.                 for (int i = 0; i < RootMoves.Count; i++)                     RootMoves[i].prevScore = RootMoves[i].score;                  prevBestMoveChanges = BestMoveChanges;                 BestMoveChanges = 0;                  // MultiPV loop. We perform a full root search for each PV line                 for (PVIdx = 0; PVIdx < Math.Min(MultiPV' RootMoves.Count); PVIdx++)                 {                     // Set aspiration window default width                     if (depth >= 5 && Math.Abs(RootMoves[PVIdx].prevScore) < ValueC.VALUE_KNOWN_WIN)                     {                         delta = 16;                         alpha = RootMoves[PVIdx].prevScore - delta;                         beta = RootMoves[PVIdx].prevScore + delta;                     }                     else                     {                         alpha = -ValueC.VALUE_INFINITE;                         beta = ValueC.VALUE_INFINITE;                     }                      // Start with a small aspiration window and' in case of fail high/low'                     // research with bigger window until not failing high/low anymore.                     do                     {                         // Search starts from ss+1 to allow referencing (ss-1). This is                         // needed by update gains and ss copy when splitting at Root.                         bestValue = search(NodeTypeC.Root' pos' ss' ssPos + 1' alpha' beta' depth * DepthC.ONE_PLY);                          // Bring to front the best move. It is critical that sorting is                         // done with a stable algorithm because all the values but the first                         // and eventually the new best one are set to -VALUE_INFINITE and                         // we want to keep the same order for all the moves but the new                         // PV that goes to the front. Note that in case of MultiPV search                         // the already searched PV lines are preserved.                         Utils.sort(RootMoves' PVIdx' RootMoves.Count);                         //sort<RootMove>(RootMoves.begin() + PVIdx' RootMoves.end());                          // In case we have found an exact score and we are going to leave                         // the fail high/low loop then reorder the PV moves' otherwise                         // leave the last PV move in its position so to be searched again.                         // Of course this is needed only in MultiPV search.                         if ((PVIdx != 0) && bestValue > alpha && bestValue < beta)                         {                             Utils.sort(RootMoves' 0' PVIdx);                         }                          // Write PV back to transposition table in case the relevant                         // entries have been overwritten during the search.                         for (int i = 0; i <= PVIdx; i++)                             RootMoves[i].insert_pv_in_tt(pos);                          // If search has been stopped exit the aspiration window loop.                         // Sorting and writing PV back to TT is safe becuase RootMoves                         // is still valid' although refers to previous iteration.                         if (SignalsStop)                             break;                          // Send full PV info to GUI if we are going to leave the loop or                         // if we have a fail high/low and we are deep in the search.                         if ((bestValue > alpha && bestValue < beta) || SearchTime.ElapsedMilliseconds > 2000)                             pv_info_to_uci(pos' depth' alpha' beta);                          // In case of failing high/low increase aspiration window and                         // research' otherwise exit the fail high/low loop.                         if (bestValue >= beta)                         {                             beta += delta;                             delta += delta / 2;                         }                         else if (bestValue <= alpha)                         {                             SignalsFailedLowAtRoot = true;                             SignalsStopOnPonderhit = false;                              alpha -= delta;                             delta += delta / 2;                         }                         else                             break;                          Debug.Assert(alpha >= -ValueC.VALUE_INFINITE && beta <= ValueC.VALUE_INFINITE);                      } while (Math.Abs(bestValue) < ValueC.VALUE_KNOWN_WIN);                 }                  // Skills: Do we need to pick now the best move ?                 if (SkillLevelEnabled && depth == 1 + SkillLevel)                     skillBest = do_skill_level();                  // Filter out startup noise when monitoring best move stability                 if (depth > 2 && (BestMoveChanges != 0))                     bestMoveNeverChanged = false;                  // Do we have time for the next iteration? Can we stop searching now?                 if (!SignalsStop && !SignalsStopOnPonderhit && Limits.use_time_management())                 {                     bool stop = false; // Local variable' not the volatile Signals.stop                      // Take in account some extra time if the best move has changed                     if (depth > 4 && depth < 50)                         TimeMgr.pv_instability(BestMoveChanges' prevBestMoveChanges);                      // Stop search if most of available time is already consumed. We                     // probably don't have enough time to search the first move at the                     // next iteration anyway.                     if (SearchTime.ElapsedMilliseconds > (TimeMgr.available_time() * 62) / 100)                         stop = true;                      // Stop search early if one move seems to be much better than others                     if (depth >= 12                         && !stop                         && ((bestMoveNeverChanged && (pos.captured_piece_type() != 0))                             || SearchTime.ElapsedMilliseconds > (TimeMgr.available_time() * 40) / 100))                     {                         Value rBeta = bestValue - EasyMoveMargin;                         ss[ssPos + 1].excludedMove = RootMoves[0].pv[0];                         ss[ssPos + 1].skipNullMove = 1;                         Value v = search(NodeTypeC.NonPV' pos' ss' ssPos + 1' rBeta - 1' rBeta' (depth - 3) * DepthC.ONE_PLY);                         ss[ssPos + 1].skipNullMove = 0;                         ss[ssPos + 1].excludedMove = MoveC.MOVE_NONE;                          if (v < rBeta)                             stop = true;                     }                      if (stop)                     {                         // If we are allowed to ponder do not stop the search now but                         // keep pondering until GUI sends "ponderhit" or "stop".                         if (Limits.ponder)                             SignalsStopOnPonderhit = true;                         else                             SignalsStop = true;                     }                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,id_loop,The following statement contains a magic number: while (!SignalsStop && ++depth <= Constants.MAX_PLY && ((Limits.depth == 0) || depth <= Limits.depth))             {                 // Save last iteration's scores before first PV line is searched and all                 // the move scores but the (new) PV are set to -VALUE_INFINITE.                 for (int i = 0; i < RootMoves.Count; i++)                     RootMoves[i].prevScore = RootMoves[i].score;                  prevBestMoveChanges = BestMoveChanges;                 BestMoveChanges = 0;                  // MultiPV loop. We perform a full root search for each PV line                 for (PVIdx = 0; PVIdx < Math.Min(MultiPV' RootMoves.Count); PVIdx++)                 {                     // Set aspiration window default width                     if (depth >= 5 && Math.Abs(RootMoves[PVIdx].prevScore) < ValueC.VALUE_KNOWN_WIN)                     {                         delta = 16;                         alpha = RootMoves[PVIdx].prevScore - delta;                         beta = RootMoves[PVIdx].prevScore + delta;                     }                     else                     {                         alpha = -ValueC.VALUE_INFINITE;                         beta = ValueC.VALUE_INFINITE;                     }                      // Start with a small aspiration window and' in case of fail high/low'                     // research with bigger window until not failing high/low anymore.                     do                     {                         // Search starts from ss+1 to allow referencing (ss-1). This is                         // needed by update gains and ss copy when splitting at Root.                         bestValue = search(NodeTypeC.Root' pos' ss' ssPos + 1' alpha' beta' depth * DepthC.ONE_PLY);                          // Bring to front the best move. It is critical that sorting is                         // done with a stable algorithm because all the values but the first                         // and eventually the new best one are set to -VALUE_INFINITE and                         // we want to keep the same order for all the moves but the new                         // PV that goes to the front. Note that in case of MultiPV search                         // the already searched PV lines are preserved.                         Utils.sort(RootMoves' PVIdx' RootMoves.Count);                         //sort<RootMove>(RootMoves.begin() + PVIdx' RootMoves.end());                          // In case we have found an exact score and we are going to leave                         // the fail high/low loop then reorder the PV moves' otherwise                         // leave the last PV move in its position so to be searched again.                         // Of course this is needed only in MultiPV search.                         if ((PVIdx != 0) && bestValue > alpha && bestValue < beta)                         {                             Utils.sort(RootMoves' 0' PVIdx);                         }                          // Write PV back to transposition table in case the relevant                         // entries have been overwritten during the search.                         for (int i = 0; i <= PVIdx; i++)                             RootMoves[i].insert_pv_in_tt(pos);                          // If search has been stopped exit the aspiration window loop.                         // Sorting and writing PV back to TT is safe becuase RootMoves                         // is still valid' although refers to previous iteration.                         if (SignalsStop)                             break;                          // Send full PV info to GUI if we are going to leave the loop or                         // if we have a fail high/low and we are deep in the search.                         if ((bestValue > alpha && bestValue < beta) || SearchTime.ElapsedMilliseconds > 2000)                             pv_info_to_uci(pos' depth' alpha' beta);                          // In case of failing high/low increase aspiration window and                         // research' otherwise exit the fail high/low loop.                         if (bestValue >= beta)                         {                             beta += delta;                             delta += delta / 2;                         }                         else if (bestValue <= alpha)                         {                             SignalsFailedLowAtRoot = true;                             SignalsStopOnPonderhit = false;                              alpha -= delta;                             delta += delta / 2;                         }                         else                             break;                          Debug.Assert(alpha >= -ValueC.VALUE_INFINITE && beta <= ValueC.VALUE_INFINITE);                      } while (Math.Abs(bestValue) < ValueC.VALUE_KNOWN_WIN);                 }                  // Skills: Do we need to pick now the best move ?                 if (SkillLevelEnabled && depth == 1 + SkillLevel)                     skillBest = do_skill_level();                  // Filter out startup noise when monitoring best move stability                 if (depth > 2 && (BestMoveChanges != 0))                     bestMoveNeverChanged = false;                  // Do we have time for the next iteration? Can we stop searching now?                 if (!SignalsStop && !SignalsStopOnPonderhit && Limits.use_time_management())                 {                     bool stop = false; // Local variable' not the volatile Signals.stop                      // Take in account some extra time if the best move has changed                     if (depth > 4 && depth < 50)                         TimeMgr.pv_instability(BestMoveChanges' prevBestMoveChanges);                      // Stop search if most of available time is already consumed. We                     // probably don't have enough time to search the first move at the                     // next iteration anyway.                     if (SearchTime.ElapsedMilliseconds > (TimeMgr.available_time() * 62) / 100)                         stop = true;                      // Stop search early if one move seems to be much better than others                     if (depth >= 12                         && !stop                         && ((bestMoveNeverChanged && (pos.captured_piece_type() != 0))                             || SearchTime.ElapsedMilliseconds > (TimeMgr.available_time() * 40) / 100))                     {                         Value rBeta = bestValue - EasyMoveMargin;                         ss[ssPos + 1].excludedMove = RootMoves[0].pv[0];                         ss[ssPos + 1].skipNullMove = 1;                         Value v = search(NodeTypeC.NonPV' pos' ss' ssPos + 1' rBeta - 1' rBeta' (depth - 3) * DepthC.ONE_PLY);                         ss[ssPos + 1].skipNullMove = 0;                         ss[ssPos + 1].excludedMove = MoveC.MOVE_NONE;                          if (v < rBeta)                             stop = true;                     }                      if (stop)                     {                         // If we are allowed to ponder do not stop the search now but                         // keep pondering until GUI sends "ponderhit" or "stop".                         if (Limits.ponder)                             SignalsStopOnPonderhit = true;                         else                             SignalsStop = true;                     }                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,id_loop,The following statement contains a magic number: while (!SignalsStop && ++depth <= Constants.MAX_PLY && ((Limits.depth == 0) || depth <= Limits.depth))             {                 // Save last iteration's scores before first PV line is searched and all                 // the move scores but the (new) PV are set to -VALUE_INFINITE.                 for (int i = 0; i < RootMoves.Count; i++)                     RootMoves[i].prevScore = RootMoves[i].score;                  prevBestMoveChanges = BestMoveChanges;                 BestMoveChanges = 0;                  // MultiPV loop. We perform a full root search for each PV line                 for (PVIdx = 0; PVIdx < Math.Min(MultiPV' RootMoves.Count); PVIdx++)                 {                     // Set aspiration window default width                     if (depth >= 5 && Math.Abs(RootMoves[PVIdx].prevScore) < ValueC.VALUE_KNOWN_WIN)                     {                         delta = 16;                         alpha = RootMoves[PVIdx].prevScore - delta;                         beta = RootMoves[PVIdx].prevScore + delta;                     }                     else                     {                         alpha = -ValueC.VALUE_INFINITE;                         beta = ValueC.VALUE_INFINITE;                     }                      // Start with a small aspiration window and' in case of fail high/low'                     // research with bigger window until not failing high/low anymore.                     do                     {                         // Search starts from ss+1 to allow referencing (ss-1). This is                         // needed by update gains and ss copy when splitting at Root.                         bestValue = search(NodeTypeC.Root' pos' ss' ssPos + 1' alpha' beta' depth * DepthC.ONE_PLY);                          // Bring to front the best move. It is critical that sorting is                         // done with a stable algorithm because all the values but the first                         // and eventually the new best one are set to -VALUE_INFINITE and                         // we want to keep the same order for all the moves but the new                         // PV that goes to the front. Note that in case of MultiPV search                         // the already searched PV lines are preserved.                         Utils.sort(RootMoves' PVIdx' RootMoves.Count);                         //sort<RootMove>(RootMoves.begin() + PVIdx' RootMoves.end());                          // In case we have found an exact score and we are going to leave                         // the fail high/low loop then reorder the PV moves' otherwise                         // leave the last PV move in its position so to be searched again.                         // Of course this is needed only in MultiPV search.                         if ((PVIdx != 0) && bestValue > alpha && bestValue < beta)                         {                             Utils.sort(RootMoves' 0' PVIdx);                         }                          // Write PV back to transposition table in case the relevant                         // entries have been overwritten during the search.                         for (int i = 0; i <= PVIdx; i++)                             RootMoves[i].insert_pv_in_tt(pos);                          // If search has been stopped exit the aspiration window loop.                         // Sorting and writing PV back to TT is safe becuase RootMoves                         // is still valid' although refers to previous iteration.                         if (SignalsStop)                             break;                          // Send full PV info to GUI if we are going to leave the loop or                         // if we have a fail high/low and we are deep in the search.                         if ((bestValue > alpha && bestValue < beta) || SearchTime.ElapsedMilliseconds > 2000)                             pv_info_to_uci(pos' depth' alpha' beta);                          // In case of failing high/low increase aspiration window and                         // research' otherwise exit the fail high/low loop.                         if (bestValue >= beta)                         {                             beta += delta;                             delta += delta / 2;                         }                         else if (bestValue <= alpha)                         {                             SignalsFailedLowAtRoot = true;                             SignalsStopOnPonderhit = false;                              alpha -= delta;                             delta += delta / 2;                         }                         else                             break;                          Debug.Assert(alpha >= -ValueC.VALUE_INFINITE && beta <= ValueC.VALUE_INFINITE);                      } while (Math.Abs(bestValue) < ValueC.VALUE_KNOWN_WIN);                 }                  // Skills: Do we need to pick now the best move ?                 if (SkillLevelEnabled && depth == 1 + SkillLevel)                     skillBest = do_skill_level();                  // Filter out startup noise when monitoring best move stability                 if (depth > 2 && (BestMoveChanges != 0))                     bestMoveNeverChanged = false;                  // Do we have time for the next iteration? Can we stop searching now?                 if (!SignalsStop && !SignalsStopOnPonderhit && Limits.use_time_management())                 {                     bool stop = false; // Local variable' not the volatile Signals.stop                      // Take in account some extra time if the best move has changed                     if (depth > 4 && depth < 50)                         TimeMgr.pv_instability(BestMoveChanges' prevBestMoveChanges);                      // Stop search if most of available time is already consumed. We                     // probably don't have enough time to search the first move at the                     // next iteration anyway.                     if (SearchTime.ElapsedMilliseconds > (TimeMgr.available_time() * 62) / 100)                         stop = true;                      // Stop search early if one move seems to be much better than others                     if (depth >= 12                         && !stop                         && ((bestMoveNeverChanged && (pos.captured_piece_type() != 0))                             || SearchTime.ElapsedMilliseconds > (TimeMgr.available_time() * 40) / 100))                     {                         Value rBeta = bestValue - EasyMoveMargin;                         ss[ssPos + 1].excludedMove = RootMoves[0].pv[0];                         ss[ssPos + 1].skipNullMove = 1;                         Value v = search(NodeTypeC.NonPV' pos' ss' ssPos + 1' rBeta - 1' rBeta' (depth - 3) * DepthC.ONE_PLY);                         ss[ssPos + 1].skipNullMove = 0;                         ss[ssPos + 1].excludedMove = MoveC.MOVE_NONE;                          if (v < rBeta)                             stop = true;                     }                      if (stop)                     {                         // If we are allowed to ponder do not stop the search now but                         // keep pondering until GUI sends "ponderhit" or "stop".                         if (Limits.ponder)                             SignalsStopOnPonderhit = true;                         else                             SignalsStop = true;                     }                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,id_loop,The following statement contains a magic number: while (!SignalsStop && ++depth <= Constants.MAX_PLY && ((Limits.depth == 0) || depth <= Limits.depth))             {                 // Save last iteration's scores before first PV line is searched and all                 // the move scores but the (new) PV are set to -VALUE_INFINITE.                 for (int i = 0; i < RootMoves.Count; i++)                     RootMoves[i].prevScore = RootMoves[i].score;                  prevBestMoveChanges = BestMoveChanges;                 BestMoveChanges = 0;                  // MultiPV loop. We perform a full root search for each PV line                 for (PVIdx = 0; PVIdx < Math.Min(MultiPV' RootMoves.Count); PVIdx++)                 {                     // Set aspiration window default width                     if (depth >= 5 && Math.Abs(RootMoves[PVIdx].prevScore) < ValueC.VALUE_KNOWN_WIN)                     {                         delta = 16;                         alpha = RootMoves[PVIdx].prevScore - delta;                         beta = RootMoves[PVIdx].prevScore + delta;                     }                     else                     {                         alpha = -ValueC.VALUE_INFINITE;                         beta = ValueC.VALUE_INFINITE;                     }                      // Start with a small aspiration window and' in case of fail high/low'                     // research with bigger window until not failing high/low anymore.                     do                     {                         // Search starts from ss+1 to allow referencing (ss-1). This is                         // needed by update gains and ss copy when splitting at Root.                         bestValue = search(NodeTypeC.Root' pos' ss' ssPos + 1' alpha' beta' depth * DepthC.ONE_PLY);                          // Bring to front the best move. It is critical that sorting is                         // done with a stable algorithm because all the values but the first                         // and eventually the new best one are set to -VALUE_INFINITE and                         // we want to keep the same order for all the moves but the new                         // PV that goes to the front. Note that in case of MultiPV search                         // the already searched PV lines are preserved.                         Utils.sort(RootMoves' PVIdx' RootMoves.Count);                         //sort<RootMove>(RootMoves.begin() + PVIdx' RootMoves.end());                          // In case we have found an exact score and we are going to leave                         // the fail high/low loop then reorder the PV moves' otherwise                         // leave the last PV move in its position so to be searched again.                         // Of course this is needed only in MultiPV search.                         if ((PVIdx != 0) && bestValue > alpha && bestValue < beta)                         {                             Utils.sort(RootMoves' 0' PVIdx);                         }                          // Write PV back to transposition table in case the relevant                         // entries have been overwritten during the search.                         for (int i = 0; i <= PVIdx; i++)                             RootMoves[i].insert_pv_in_tt(pos);                          // If search has been stopped exit the aspiration window loop.                         // Sorting and writing PV back to TT is safe becuase RootMoves                         // is still valid' although refers to previous iteration.                         if (SignalsStop)                             break;                          // Send full PV info to GUI if we are going to leave the loop or                         // if we have a fail high/low and we are deep in the search.                         if ((bestValue > alpha && bestValue < beta) || SearchTime.ElapsedMilliseconds > 2000)                             pv_info_to_uci(pos' depth' alpha' beta);                          // In case of failing high/low increase aspiration window and                         // research' otherwise exit the fail high/low loop.                         if (bestValue >= beta)                         {                             beta += delta;                             delta += delta / 2;                         }                         else if (bestValue <= alpha)                         {                             SignalsFailedLowAtRoot = true;                             SignalsStopOnPonderhit = false;                              alpha -= delta;                             delta += delta / 2;                         }                         else                             break;                          Debug.Assert(alpha >= -ValueC.VALUE_INFINITE && beta <= ValueC.VALUE_INFINITE);                      } while (Math.Abs(bestValue) < ValueC.VALUE_KNOWN_WIN);                 }                  // Skills: Do we need to pick now the best move ?                 if (SkillLevelEnabled && depth == 1 + SkillLevel)                     skillBest = do_skill_level();                  // Filter out startup noise when monitoring best move stability                 if (depth > 2 && (BestMoveChanges != 0))                     bestMoveNeverChanged = false;                  // Do we have time for the next iteration? Can we stop searching now?                 if (!SignalsStop && !SignalsStopOnPonderhit && Limits.use_time_management())                 {                     bool stop = false; // Local variable' not the volatile Signals.stop                      // Take in account some extra time if the best move has changed                     if (depth > 4 && depth < 50)                         TimeMgr.pv_instability(BestMoveChanges' prevBestMoveChanges);                      // Stop search if most of available time is already consumed. We                     // probably don't have enough time to search the first move at the                     // next iteration anyway.                     if (SearchTime.ElapsedMilliseconds > (TimeMgr.available_time() * 62) / 100)                         stop = true;                      // Stop search early if one move seems to be much better than others                     if (depth >= 12                         && !stop                         && ((bestMoveNeverChanged && (pos.captured_piece_type() != 0))                             || SearchTime.ElapsedMilliseconds > (TimeMgr.available_time() * 40) / 100))                     {                         Value rBeta = bestValue - EasyMoveMargin;                         ss[ssPos + 1].excludedMove = RootMoves[0].pv[0];                         ss[ssPos + 1].skipNullMove = 1;                         Value v = search(NodeTypeC.NonPV' pos' ss' ssPos + 1' rBeta - 1' rBeta' (depth - 3) * DepthC.ONE_PLY);                         ss[ssPos + 1].skipNullMove = 0;                         ss[ssPos + 1].excludedMove = MoveC.MOVE_NONE;                          if (v < rBeta)                             stop = true;                     }                      if (stop)                     {                         // If we are allowed to ponder do not stop the search now but                         // keep pondering until GUI sends "ponderhit" or "stop".                         if (Limits.ponder)                             SignalsStopOnPonderhit = true;                         else                             SignalsStop = true;                     }                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,id_loop,The following statement contains a magic number: while (!SignalsStop && ++depth <= Constants.MAX_PLY && ((Limits.depth == 0) || depth <= Limits.depth))             {                 // Save last iteration's scores before first PV line is searched and all                 // the move scores but the (new) PV are set to -VALUE_INFINITE.                 for (int i = 0; i < RootMoves.Count; i++)                     RootMoves[i].prevScore = RootMoves[i].score;                  prevBestMoveChanges = BestMoveChanges;                 BestMoveChanges = 0;                  // MultiPV loop. We perform a full root search for each PV line                 for (PVIdx = 0; PVIdx < Math.Min(MultiPV' RootMoves.Count); PVIdx++)                 {                     // Set aspiration window default width                     if (depth >= 5 && Math.Abs(RootMoves[PVIdx].prevScore) < ValueC.VALUE_KNOWN_WIN)                     {                         delta = 16;                         alpha = RootMoves[PVIdx].prevScore - delta;                         beta = RootMoves[PVIdx].prevScore + delta;                     }                     else                     {                         alpha = -ValueC.VALUE_INFINITE;                         beta = ValueC.VALUE_INFINITE;                     }                      // Start with a small aspiration window and' in case of fail high/low'                     // research with bigger window until not failing high/low anymore.                     do                     {                         // Search starts from ss+1 to allow referencing (ss-1). This is                         // needed by update gains and ss copy when splitting at Root.                         bestValue = search(NodeTypeC.Root' pos' ss' ssPos + 1' alpha' beta' depth * DepthC.ONE_PLY);                          // Bring to front the best move. It is critical that sorting is                         // done with a stable algorithm because all the values but the first                         // and eventually the new best one are set to -VALUE_INFINITE and                         // we want to keep the same order for all the moves but the new                         // PV that goes to the front. Note that in case of MultiPV search                         // the already searched PV lines are preserved.                         Utils.sort(RootMoves' PVIdx' RootMoves.Count);                         //sort<RootMove>(RootMoves.begin() + PVIdx' RootMoves.end());                          // In case we have found an exact score and we are going to leave                         // the fail high/low loop then reorder the PV moves' otherwise                         // leave the last PV move in its position so to be searched again.                         // Of course this is needed only in MultiPV search.                         if ((PVIdx != 0) && bestValue > alpha && bestValue < beta)                         {                             Utils.sort(RootMoves' 0' PVIdx);                         }                          // Write PV back to transposition table in case the relevant                         // entries have been overwritten during the search.                         for (int i = 0; i <= PVIdx; i++)                             RootMoves[i].insert_pv_in_tt(pos);                          // If search has been stopped exit the aspiration window loop.                         // Sorting and writing PV back to TT is safe becuase RootMoves                         // is still valid' although refers to previous iteration.                         if (SignalsStop)                             break;                          // Send full PV info to GUI if we are going to leave the loop or                         // if we have a fail high/low and we are deep in the search.                         if ((bestValue > alpha && bestValue < beta) || SearchTime.ElapsedMilliseconds > 2000)                             pv_info_to_uci(pos' depth' alpha' beta);                          // In case of failing high/low increase aspiration window and                         // research' otherwise exit the fail high/low loop.                         if (bestValue >= beta)                         {                             beta += delta;                             delta += delta / 2;                         }                         else if (bestValue <= alpha)                         {                             SignalsFailedLowAtRoot = true;                             SignalsStopOnPonderhit = false;                              alpha -= delta;                             delta += delta / 2;                         }                         else                             break;                          Debug.Assert(alpha >= -ValueC.VALUE_INFINITE && beta <= ValueC.VALUE_INFINITE);                      } while (Math.Abs(bestValue) < ValueC.VALUE_KNOWN_WIN);                 }                  // Skills: Do we need to pick now the best move ?                 if (SkillLevelEnabled && depth == 1 + SkillLevel)                     skillBest = do_skill_level();                  // Filter out startup noise when monitoring best move stability                 if (depth > 2 && (BestMoveChanges != 0))                     bestMoveNeverChanged = false;                  // Do we have time for the next iteration? Can we stop searching now?                 if (!SignalsStop && !SignalsStopOnPonderhit && Limits.use_time_management())                 {                     bool stop = false; // Local variable' not the volatile Signals.stop                      // Take in account some extra time if the best move has changed                     if (depth > 4 && depth < 50)                         TimeMgr.pv_instability(BestMoveChanges' prevBestMoveChanges);                      // Stop search if most of available time is already consumed. We                     // probably don't have enough time to search the first move at the                     // next iteration anyway.                     if (SearchTime.ElapsedMilliseconds > (TimeMgr.available_time() * 62) / 100)                         stop = true;                      // Stop search early if one move seems to be much better than others                     if (depth >= 12                         && !stop                         && ((bestMoveNeverChanged && (pos.captured_piece_type() != 0))                             || SearchTime.ElapsedMilliseconds > (TimeMgr.available_time() * 40) / 100))                     {                         Value rBeta = bestValue - EasyMoveMargin;                         ss[ssPos + 1].excludedMove = RootMoves[0].pv[0];                         ss[ssPos + 1].skipNullMove = 1;                         Value v = search(NodeTypeC.NonPV' pos' ss' ssPos + 1' rBeta - 1' rBeta' (depth - 3) * DepthC.ONE_PLY);                         ss[ssPos + 1].skipNullMove = 0;                         ss[ssPos + 1].excludedMove = MoveC.MOVE_NONE;                          if (v < rBeta)                             stop = true;                     }                      if (stop)                     {                         // If we are allowed to ponder do not stop the search now but                         // keep pondering until GUI sends "ponderhit" or "stop".                         if (Limits.ponder)                             SignalsStopOnPonderhit = true;                         else                             SignalsStop = true;                     }                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,id_loop,The following statement contains a magic number: while (!SignalsStop && ++depth <= Constants.MAX_PLY && ((Limits.depth == 0) || depth <= Limits.depth))             {                 // Save last iteration's scores before first PV line is searched and all                 // the move scores but the (new) PV are set to -VALUE_INFINITE.                 for (int i = 0; i < RootMoves.Count; i++)                     RootMoves[i].prevScore = RootMoves[i].score;                  prevBestMoveChanges = BestMoveChanges;                 BestMoveChanges = 0;                  // MultiPV loop. We perform a full root search for each PV line                 for (PVIdx = 0; PVIdx < Math.Min(MultiPV' RootMoves.Count); PVIdx++)                 {                     // Set aspiration window default width                     if (depth >= 5 && Math.Abs(RootMoves[PVIdx].prevScore) < ValueC.VALUE_KNOWN_WIN)                     {                         delta = 16;                         alpha = RootMoves[PVIdx].prevScore - delta;                         beta = RootMoves[PVIdx].prevScore + delta;                     }                     else                     {                         alpha = -ValueC.VALUE_INFINITE;                         beta = ValueC.VALUE_INFINITE;                     }                      // Start with a small aspiration window and' in case of fail high/low'                     // research with bigger window until not failing high/low anymore.                     do                     {                         // Search starts from ss+1 to allow referencing (ss-1). This is                         // needed by update gains and ss copy when splitting at Root.                         bestValue = search(NodeTypeC.Root' pos' ss' ssPos + 1' alpha' beta' depth * DepthC.ONE_PLY);                          // Bring to front the best move. It is critical that sorting is                         // done with a stable algorithm because all the values but the first                         // and eventually the new best one are set to -VALUE_INFINITE and                         // we want to keep the same order for all the moves but the new                         // PV that goes to the front. Note that in case of MultiPV search                         // the already searched PV lines are preserved.                         Utils.sort(RootMoves' PVIdx' RootMoves.Count);                         //sort<RootMove>(RootMoves.begin() + PVIdx' RootMoves.end());                          // In case we have found an exact score and we are going to leave                         // the fail high/low loop then reorder the PV moves' otherwise                         // leave the last PV move in its position so to be searched again.                         // Of course this is needed only in MultiPV search.                         if ((PVIdx != 0) && bestValue > alpha && bestValue < beta)                         {                             Utils.sort(RootMoves' 0' PVIdx);                         }                          // Write PV back to transposition table in case the relevant                         // entries have been overwritten during the search.                         for (int i = 0; i <= PVIdx; i++)                             RootMoves[i].insert_pv_in_tt(pos);                          // If search has been stopped exit the aspiration window loop.                         // Sorting and writing PV back to TT is safe becuase RootMoves                         // is still valid' although refers to previous iteration.                         if (SignalsStop)                             break;                          // Send full PV info to GUI if we are going to leave the loop or                         // if we have a fail high/low and we are deep in the search.                         if ((bestValue > alpha && bestValue < beta) || SearchTime.ElapsedMilliseconds > 2000)                             pv_info_to_uci(pos' depth' alpha' beta);                          // In case of failing high/low increase aspiration window and                         // research' otherwise exit the fail high/low loop.                         if (bestValue >= beta)                         {                             beta += delta;                             delta += delta / 2;                         }                         else if (bestValue <= alpha)                         {                             SignalsFailedLowAtRoot = true;                             SignalsStopOnPonderhit = false;                              alpha -= delta;                             delta += delta / 2;                         }                         else                             break;                          Debug.Assert(alpha >= -ValueC.VALUE_INFINITE && beta <= ValueC.VALUE_INFINITE);                      } while (Math.Abs(bestValue) < ValueC.VALUE_KNOWN_WIN);                 }                  // Skills: Do we need to pick now the best move ?                 if (SkillLevelEnabled && depth == 1 + SkillLevel)                     skillBest = do_skill_level();                  // Filter out startup noise when monitoring best move stability                 if (depth > 2 && (BestMoveChanges != 0))                     bestMoveNeverChanged = false;                  // Do we have time for the next iteration? Can we stop searching now?                 if (!SignalsStop && !SignalsStopOnPonderhit && Limits.use_time_management())                 {                     bool stop = false; // Local variable' not the volatile Signals.stop                      // Take in account some extra time if the best move has changed                     if (depth > 4 && depth < 50)                         TimeMgr.pv_instability(BestMoveChanges' prevBestMoveChanges);                      // Stop search if most of available time is already consumed. We                     // probably don't have enough time to search the first move at the                     // next iteration anyway.                     if (SearchTime.ElapsedMilliseconds > (TimeMgr.available_time() * 62) / 100)                         stop = true;                      // Stop search early if one move seems to be much better than others                     if (depth >= 12                         && !stop                         && ((bestMoveNeverChanged && (pos.captured_piece_type() != 0))                             || SearchTime.ElapsedMilliseconds > (TimeMgr.available_time() * 40) / 100))                     {                         Value rBeta = bestValue - EasyMoveMargin;                         ss[ssPos + 1].excludedMove = RootMoves[0].pv[0];                         ss[ssPos + 1].skipNullMove = 1;                         Value v = search(NodeTypeC.NonPV' pos' ss' ssPos + 1' rBeta - 1' rBeta' (depth - 3) * DepthC.ONE_PLY);                         ss[ssPos + 1].skipNullMove = 0;                         ss[ssPos + 1].excludedMove = MoveC.MOVE_NONE;                          if (v < rBeta)                             stop = true;                     }                      if (stop)                     {                         // If we are allowed to ponder do not stop the search now but                         // keep pondering until GUI sends "ponderhit" or "stop".                         if (Limits.ponder)                             SignalsStopOnPonderhit = true;                         else                             SignalsStop = true;                     }                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,id_loop,The following statement contains a magic number: while (!SignalsStop && ++depth <= Constants.MAX_PLY && ((Limits.depth == 0) || depth <= Limits.depth))             {                 // Save last iteration's scores before first PV line is searched and all                 // the move scores but the (new) PV are set to -VALUE_INFINITE.                 for (int i = 0; i < RootMoves.Count; i++)                     RootMoves[i].prevScore = RootMoves[i].score;                  prevBestMoveChanges = BestMoveChanges;                 BestMoveChanges = 0;                  // MultiPV loop. We perform a full root search for each PV line                 for (PVIdx = 0; PVIdx < Math.Min(MultiPV' RootMoves.Count); PVIdx++)                 {                     // Set aspiration window default width                     if (depth >= 5 && Math.Abs(RootMoves[PVIdx].prevScore) < ValueC.VALUE_KNOWN_WIN)                     {                         delta = 16;                         alpha = RootMoves[PVIdx].prevScore - delta;                         beta = RootMoves[PVIdx].prevScore + delta;                     }                     else                     {                         alpha = -ValueC.VALUE_INFINITE;                         beta = ValueC.VALUE_INFINITE;                     }                      // Start with a small aspiration window and' in case of fail high/low'                     // research with bigger window until not failing high/low anymore.                     do                     {                         // Search starts from ss+1 to allow referencing (ss-1). This is                         // needed by update gains and ss copy when splitting at Root.                         bestValue = search(NodeTypeC.Root' pos' ss' ssPos + 1' alpha' beta' depth * DepthC.ONE_PLY);                          // Bring to front the best move. It is critical that sorting is                         // done with a stable algorithm because all the values but the first                         // and eventually the new best one are set to -VALUE_INFINITE and                         // we want to keep the same order for all the moves but the new                         // PV that goes to the front. Note that in case of MultiPV search                         // the already searched PV lines are preserved.                         Utils.sort(RootMoves' PVIdx' RootMoves.Count);                         //sort<RootMove>(RootMoves.begin() + PVIdx' RootMoves.end());                          // In case we have found an exact score and we are going to leave                         // the fail high/low loop then reorder the PV moves' otherwise                         // leave the last PV move in its position so to be searched again.                         // Of course this is needed only in MultiPV search.                         if ((PVIdx != 0) && bestValue > alpha && bestValue < beta)                         {                             Utils.sort(RootMoves' 0' PVIdx);                         }                          // Write PV back to transposition table in case the relevant                         // entries have been overwritten during the search.                         for (int i = 0; i <= PVIdx; i++)                             RootMoves[i].insert_pv_in_tt(pos);                          // If search has been stopped exit the aspiration window loop.                         // Sorting and writing PV back to TT is safe becuase RootMoves                         // is still valid' although refers to previous iteration.                         if (SignalsStop)                             break;                          // Send full PV info to GUI if we are going to leave the loop or                         // if we have a fail high/low and we are deep in the search.                         if ((bestValue > alpha && bestValue < beta) || SearchTime.ElapsedMilliseconds > 2000)                             pv_info_to_uci(pos' depth' alpha' beta);                          // In case of failing high/low increase aspiration window and                         // research' otherwise exit the fail high/low loop.                         if (bestValue >= beta)                         {                             beta += delta;                             delta += delta / 2;                         }                         else if (bestValue <= alpha)                         {                             SignalsFailedLowAtRoot = true;                             SignalsStopOnPonderhit = false;                              alpha -= delta;                             delta += delta / 2;                         }                         else                             break;                          Debug.Assert(alpha >= -ValueC.VALUE_INFINITE && beta <= ValueC.VALUE_INFINITE);                      } while (Math.Abs(bestValue) < ValueC.VALUE_KNOWN_WIN);                 }                  // Skills: Do we need to pick now the best move ?                 if (SkillLevelEnabled && depth == 1 + SkillLevel)                     skillBest = do_skill_level();                  // Filter out startup noise when monitoring best move stability                 if (depth > 2 && (BestMoveChanges != 0))                     bestMoveNeverChanged = false;                  // Do we have time for the next iteration? Can we stop searching now?                 if (!SignalsStop && !SignalsStopOnPonderhit && Limits.use_time_management())                 {                     bool stop = false; // Local variable' not the volatile Signals.stop                      // Take in account some extra time if the best move has changed                     if (depth > 4 && depth < 50)                         TimeMgr.pv_instability(BestMoveChanges' prevBestMoveChanges);                      // Stop search if most of available time is already consumed. We                     // probably don't have enough time to search the first move at the                     // next iteration anyway.                     if (SearchTime.ElapsedMilliseconds > (TimeMgr.available_time() * 62) / 100)                         stop = true;                      // Stop search early if one move seems to be much better than others                     if (depth >= 12                         && !stop                         && ((bestMoveNeverChanged && (pos.captured_piece_type() != 0))                             || SearchTime.ElapsedMilliseconds > (TimeMgr.available_time() * 40) / 100))                     {                         Value rBeta = bestValue - EasyMoveMargin;                         ss[ssPos + 1].excludedMove = RootMoves[0].pv[0];                         ss[ssPos + 1].skipNullMove = 1;                         Value v = search(NodeTypeC.NonPV' pos' ss' ssPos + 1' rBeta - 1' rBeta' (depth - 3) * DepthC.ONE_PLY);                         ss[ssPos + 1].skipNullMove = 0;                         ss[ssPos + 1].excludedMove = MoveC.MOVE_NONE;                          if (v < rBeta)                             stop = true;                     }                      if (stop)                     {                         // If we are allowed to ponder do not stop the search now but                         // keep pondering until GUI sends "ponderhit" or "stop".                         if (Limits.ponder)                             SignalsStopOnPonderhit = true;                         else                             SignalsStop = true;                     }                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The following statement contains a magic number: if (SpNode)             {                 ttMove = excludedMove = MoveC.MOVE_NONE;                 ttValue = ValueC.VALUE_ZERO;                  sp = ss[ssPos].sp;                 bestMove = sp.bestMove;                 threatMove = sp.threatMove;                 bestValue = sp.bestValue;                 moveCount = sp.moveCount; // Lock must be held here                  Debug.Assert(bestValue > -ValueC.VALUE_INFINITE && moveCount > 0);                  goto split_point_start;             }             else             {                 ss[ssPos].currentMove = threatMove = ss[ssPos + 1].excludedMove = bestMove = MoveC.MOVE_NONE;                 ss[ssPos + 1].skipNullMove = 0; ss[ssPos + 1].reduction = DepthC.DEPTH_ZERO;                 ss[ssPos + 2].killers0 = ss[ssPos + 2].killers1 = MoveC.MOVE_NONE;             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The following statement contains a magic number: if (SpNode)             {                 ttMove = excludedMove = MoveC.MOVE_NONE;                 ttValue = ValueC.VALUE_ZERO;                  sp = ss[ssPos].sp;                 bestMove = sp.bestMove;                 threatMove = sp.threatMove;                 bestValue = sp.bestValue;                 moveCount = sp.moveCount; // Lock must be held here                  Debug.Assert(bestValue > -ValueC.VALUE_INFINITE && moveCount > 0);                  goto split_point_start;             }             else             {                 ss[ssPos].currentMove = threatMove = ss[ssPos + 1].excludedMove = bestMove = MoveC.MOVE_NONE;                 ss[ssPos + 1].skipNullMove = 0; ss[ssPos + 1].reduction = DepthC.DEPTH_ZERO;                 ss[ssPos + 2].killers0 = ss[ssPos + 2].killers1 = MoveC.MOVE_NONE;             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The following statement contains a magic number: if (!PvNode && !inCheck                 && (ss[ssPos].skipNullMove == 0)                 && depth > DepthC.ONE_PLY                 && refinedValue >= beta                 && Math.Abs(beta) < ValueC.VALUE_MATE_IN_MAX_PLY                 && (pos.non_pawn_material(pos.sideToMove) != 0))             {                 ss[ssPos].currentMove = MoveC.MOVE_NULL;                  // Null move dynamic reduction based on depth                 int R = 3 + (depth >= 5 * DepthC.ONE_PLY ? depth / 8 : 0);                  // Null move dynamic reduction based on value                 if (refinedValue - Constants.PawnValueMidgame > beta)                     R++;                  if (st == null) { st = StateInfoBroker.GetObject(); }                 pos.do_null_move(true' st);                 ss[ssPos + 1].skipNullMove = 1;                 nullValue = depth - R * DepthC.ONE_PLY < DepthC.ONE_PLY ? -qsearch(NodeTypeC.NonPV' pos' ss' ssPos + 1' -beta' -alpha' DepthC.DEPTH_ZERO)                                                       : -search(NodeTypeC.NonPV' pos' ss' ssPos + 1' -beta' -alpha' depth - R * DepthC.ONE_PLY);                 ss[ssPos + 1].skipNullMove = 0;                 pos.do_null_move(false' st);                  if (nullValue >= beta)                 {                     // Do not return unproven mate scores                     if (nullValue >= ValueC.VALUE_MATE_IN_MAX_PLY)                         nullValue = beta;                      if (depth < 6 * DepthC.ONE_PLY)                     {                         if (st != null) { st.previous = null; StateInfoBroker.Free(); }                         MovesSearchedBroker.Free();                         return nullValue;                     }                      // Do verification search at high depths                     ss[ssPos].skipNullMove = 1;                     Value v = search(NodeTypeC.NonPV' pos' ss' ssPos' alpha' beta' depth - R * DepthC.ONE_PLY);                     ss[ssPos].skipNullMove = 0;                      if (v >= beta)                     {                         if (st != null) { st.previous = null; StateInfoBroker.Free(); }                         MovesSearchedBroker.Free();                         return nullValue;                     }                 }                 else                 {                     // The null move failed low' which means that we may be faced with                     // some kind of threat. If the previous move was reduced' check if                     // the move that refuted the null move was somehow connected to the                     // move which was reduced. If a connection is found' return a fail                     // low score (which will cause the reduced move to fail high in the                     // parent node' which will trigger a re-search with full depth).                     threatMove = ss[ssPos + 1].currentMove;                      if (depth < ThreatDepth                         && (ss[ssPos - 1].reduction != 0)                         && threatMove != MoveC.MOVE_NONE                         && connected_moves(pos' ss[ssPos - 1].currentMove' threatMove))                     {                         if (st != null) { st.previous = null; StateInfoBroker.Free(); }                         MovesSearchedBroker.Free();                         return beta - 1;                     }                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The following statement contains a magic number: if (!PvNode && !inCheck                 && (ss[ssPos].skipNullMove == 0)                 && depth > DepthC.ONE_PLY                 && refinedValue >= beta                 && Math.Abs(beta) < ValueC.VALUE_MATE_IN_MAX_PLY                 && (pos.non_pawn_material(pos.sideToMove) != 0))             {                 ss[ssPos].currentMove = MoveC.MOVE_NULL;                  // Null move dynamic reduction based on depth                 int R = 3 + (depth >= 5 * DepthC.ONE_PLY ? depth / 8 : 0);                  // Null move dynamic reduction based on value                 if (refinedValue - Constants.PawnValueMidgame > beta)                     R++;                  if (st == null) { st = StateInfoBroker.GetObject(); }                 pos.do_null_move(true' st);                 ss[ssPos + 1].skipNullMove = 1;                 nullValue = depth - R * DepthC.ONE_PLY < DepthC.ONE_PLY ? -qsearch(NodeTypeC.NonPV' pos' ss' ssPos + 1' -beta' -alpha' DepthC.DEPTH_ZERO)                                                       : -search(NodeTypeC.NonPV' pos' ss' ssPos + 1' -beta' -alpha' depth - R * DepthC.ONE_PLY);                 ss[ssPos + 1].skipNullMove = 0;                 pos.do_null_move(false' st);                  if (nullValue >= beta)                 {                     // Do not return unproven mate scores                     if (nullValue >= ValueC.VALUE_MATE_IN_MAX_PLY)                         nullValue = beta;                      if (depth < 6 * DepthC.ONE_PLY)                     {                         if (st != null) { st.previous = null; StateInfoBroker.Free(); }                         MovesSearchedBroker.Free();                         return nullValue;                     }                      // Do verification search at high depths                     ss[ssPos].skipNullMove = 1;                     Value v = search(NodeTypeC.NonPV' pos' ss' ssPos' alpha' beta' depth - R * DepthC.ONE_PLY);                     ss[ssPos].skipNullMove = 0;                      if (v >= beta)                     {                         if (st != null) { st.previous = null; StateInfoBroker.Free(); }                         MovesSearchedBroker.Free();                         return nullValue;                     }                 }                 else                 {                     // The null move failed low' which means that we may be faced with                     // some kind of threat. If the previous move was reduced' check if                     // the move that refuted the null move was somehow connected to the                     // move which was reduced. If a connection is found' return a fail                     // low score (which will cause the reduced move to fail high in the                     // parent node' which will trigger a re-search with full depth).                     threatMove = ss[ssPos + 1].currentMove;                      if (depth < ThreatDepth                         && (ss[ssPos - 1].reduction != 0)                         && threatMove != MoveC.MOVE_NONE                         && connected_moves(pos' ss[ssPos - 1].currentMove' threatMove))                     {                         if (st != null) { st.previous = null; StateInfoBroker.Free(); }                         MovesSearchedBroker.Free();                         return beta - 1;                     }                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The following statement contains a magic number: if (!PvNode && !inCheck                 && (ss[ssPos].skipNullMove == 0)                 && depth > DepthC.ONE_PLY                 && refinedValue >= beta                 && Math.Abs(beta) < ValueC.VALUE_MATE_IN_MAX_PLY                 && (pos.non_pawn_material(pos.sideToMove) != 0))             {                 ss[ssPos].currentMove = MoveC.MOVE_NULL;                  // Null move dynamic reduction based on depth                 int R = 3 + (depth >= 5 * DepthC.ONE_PLY ? depth / 8 : 0);                  // Null move dynamic reduction based on value                 if (refinedValue - Constants.PawnValueMidgame > beta)                     R++;                  if (st == null) { st = StateInfoBroker.GetObject(); }                 pos.do_null_move(true' st);                 ss[ssPos + 1].skipNullMove = 1;                 nullValue = depth - R * DepthC.ONE_PLY < DepthC.ONE_PLY ? -qsearch(NodeTypeC.NonPV' pos' ss' ssPos + 1' -beta' -alpha' DepthC.DEPTH_ZERO)                                                       : -search(NodeTypeC.NonPV' pos' ss' ssPos + 1' -beta' -alpha' depth - R * DepthC.ONE_PLY);                 ss[ssPos + 1].skipNullMove = 0;                 pos.do_null_move(false' st);                  if (nullValue >= beta)                 {                     // Do not return unproven mate scores                     if (nullValue >= ValueC.VALUE_MATE_IN_MAX_PLY)                         nullValue = beta;                      if (depth < 6 * DepthC.ONE_PLY)                     {                         if (st != null) { st.previous = null; StateInfoBroker.Free(); }                         MovesSearchedBroker.Free();                         return nullValue;                     }                      // Do verification search at high depths                     ss[ssPos].skipNullMove = 1;                     Value v = search(NodeTypeC.NonPV' pos' ss' ssPos' alpha' beta' depth - R * DepthC.ONE_PLY);                     ss[ssPos].skipNullMove = 0;                      if (v >= beta)                     {                         if (st != null) { st.previous = null; StateInfoBroker.Free(); }                         MovesSearchedBroker.Free();                         return nullValue;                     }                 }                 else                 {                     // The null move failed low' which means that we may be faced with                     // some kind of threat. If the previous move was reduced' check if                     // the move that refuted the null move was somehow connected to the                     // move which was reduced. If a connection is found' return a fail                     // low score (which will cause the reduced move to fail high in the                     // parent node' which will trigger a re-search with full depth).                     threatMove = ss[ssPos + 1].currentMove;                      if (depth < ThreatDepth                         && (ss[ssPos - 1].reduction != 0)                         && threatMove != MoveC.MOVE_NONE                         && connected_moves(pos' ss[ssPos - 1].currentMove' threatMove))                     {                         if (st != null) { st.previous = null; StateInfoBroker.Free(); }                         MovesSearchedBroker.Free();                         return beta - 1;                     }                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The following statement contains a magic number: if (!PvNode && !inCheck                 && (ss[ssPos].skipNullMove == 0)                 && depth > DepthC.ONE_PLY                 && refinedValue >= beta                 && Math.Abs(beta) < ValueC.VALUE_MATE_IN_MAX_PLY                 && (pos.non_pawn_material(pos.sideToMove) != 0))             {                 ss[ssPos].currentMove = MoveC.MOVE_NULL;                  // Null move dynamic reduction based on depth                 int R = 3 + (depth >= 5 * DepthC.ONE_PLY ? depth / 8 : 0);                  // Null move dynamic reduction based on value                 if (refinedValue - Constants.PawnValueMidgame > beta)                     R++;                  if (st == null) { st = StateInfoBroker.GetObject(); }                 pos.do_null_move(true' st);                 ss[ssPos + 1].skipNullMove = 1;                 nullValue = depth - R * DepthC.ONE_PLY < DepthC.ONE_PLY ? -qsearch(NodeTypeC.NonPV' pos' ss' ssPos + 1' -beta' -alpha' DepthC.DEPTH_ZERO)                                                       : -search(NodeTypeC.NonPV' pos' ss' ssPos + 1' -beta' -alpha' depth - R * DepthC.ONE_PLY);                 ss[ssPos + 1].skipNullMove = 0;                 pos.do_null_move(false' st);                  if (nullValue >= beta)                 {                     // Do not return unproven mate scores                     if (nullValue >= ValueC.VALUE_MATE_IN_MAX_PLY)                         nullValue = beta;                      if (depth < 6 * DepthC.ONE_PLY)                     {                         if (st != null) { st.previous = null; StateInfoBroker.Free(); }                         MovesSearchedBroker.Free();                         return nullValue;                     }                      // Do verification search at high depths                     ss[ssPos].skipNullMove = 1;                     Value v = search(NodeTypeC.NonPV' pos' ss' ssPos' alpha' beta' depth - R * DepthC.ONE_PLY);                     ss[ssPos].skipNullMove = 0;                      if (v >= beta)                     {                         if (st != null) { st.previous = null; StateInfoBroker.Free(); }                         MovesSearchedBroker.Free();                         return nullValue;                     }                 }                 else                 {                     // The null move failed low' which means that we may be faced with                     // some kind of threat. If the previous move was reduced' check if                     // the move that refuted the null move was somehow connected to the                     // move which was reduced. If a connection is found' return a fail                     // low score (which will cause the reduced move to fail high in the                     // parent node' which will trigger a re-search with full depth).                     threatMove = ss[ssPos + 1].currentMove;                      if (depth < ThreatDepth                         && (ss[ssPos - 1].reduction != 0)                         && threatMove != MoveC.MOVE_NONE                         && connected_moves(pos' ss[ssPos - 1].currentMove' threatMove))                     {                         if (st != null) { st.previous = null; StateInfoBroker.Free(); }                         MovesSearchedBroker.Free();                         return beta - 1;                     }                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The following statement contains a magic number: if (!PvNode && !inCheck                 && excludedMove == MoveC.MOVE_NONE                 && depth >= RazorDepth + DepthC.ONE_PLY                 && (ss[ssPos].skipNullMove == 0)                 && Math.Abs(beta) < ValueC.VALUE_MATE_IN_MAX_PLY)             {                 Value rbeta = beta + 200;                 Depth rdepth = depth - DepthC.ONE_PLY - 3 * DepthC.ONE_PLY;                  Debug.Assert(rdepth >= DepthC.ONE_PLY);                 Debug.Assert(ss[ssPos - 1].currentMove != MoveC.MOVE_NONE);                 Debug.Assert(ss[ssPos - 1].currentMove != MoveC.MOVE_NULL);                  MovePicker mp2 = MovePickerBroker.GetObject();                 mp2.MovePickerC(pos' ttMove' H' pos.captured_piece_type());                 CheckInfo ci2 = CheckInfoBroker.GetObject();                 ci2.CreateCheckInfo(pos);                  while ((move = mp2.next_move()) != MoveC.MOVE_NONE)                 {                     if (pos.pl_move_is_legal(move' ci2.pinned))                     {                         ss[ssPos].currentMove = move;                         if (st == null) { st = StateInfoBroker.GetObject(); }                         pos.do_move(move' st' ci2' pos.move_gives_check(move' ci2));                         value = -search(NodeTypeC.NonPV' pos' ss' ssPos + 1' -rbeta' -rbeta + 1' rdepth);                         pos.undo_move(move);                         if (value >= rbeta)                         {                             if (st != null) { st.previous = null; StateInfoBroker.Free(); }                             CheckInfoBroker.Free();                             MovePickerBroker.Free(mp2);                             MovesSearchedBroker.Free();                             return value;                         }                     }                 }                  CheckInfoBroker.Free();                 MovePickerBroker.Free(mp2);             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The following statement contains a magic number: if (!PvNode && !inCheck                 && excludedMove == MoveC.MOVE_NONE                 && depth >= RazorDepth + DepthC.ONE_PLY                 && (ss[ssPos].skipNullMove == 0)                 && Math.Abs(beta) < ValueC.VALUE_MATE_IN_MAX_PLY)             {                 Value rbeta = beta + 200;                 Depth rdepth = depth - DepthC.ONE_PLY - 3 * DepthC.ONE_PLY;                  Debug.Assert(rdepth >= DepthC.ONE_PLY);                 Debug.Assert(ss[ssPos - 1].currentMove != MoveC.MOVE_NONE);                 Debug.Assert(ss[ssPos - 1].currentMove != MoveC.MOVE_NULL);                  MovePicker mp2 = MovePickerBroker.GetObject();                 mp2.MovePickerC(pos' ttMove' H' pos.captured_piece_type());                 CheckInfo ci2 = CheckInfoBroker.GetObject();                 ci2.CreateCheckInfo(pos);                  while ((move = mp2.next_move()) != MoveC.MOVE_NONE)                 {                     if (pos.pl_move_is_legal(move' ci2.pinned))                     {                         ss[ssPos].currentMove = move;                         if (st == null) { st = StateInfoBroker.GetObject(); }                         pos.do_move(move' st' ci2' pos.move_gives_check(move' ci2));                         value = -search(NodeTypeC.NonPV' pos' ss' ssPos + 1' -rbeta' -rbeta + 1' rdepth);                         pos.undo_move(move);                         if (value >= rbeta)                         {                             if (st != null) { st.previous = null; StateInfoBroker.Free(); }                             CheckInfoBroker.Free();                             MovePickerBroker.Free(mp2);                             MovesSearchedBroker.Free();                             return value;                         }                     }                 }                  CheckInfoBroker.Free();                 MovePickerBroker.Free(mp2);             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The following statement contains a magic number: if (ttMove == MoveC.MOVE_NONE                 && depth >= IIDDepth[PvNode ? 1 : 0]                 && (PvNode || (!inCheck && ss[ssPos].eval + IIDMargin >= beta)))             {                 Depth d = (PvNode ? depth - 2 * DepthC.ONE_PLY : depth / 2);                  ss[ssPos].skipNullMove = 1;                 search(PvNode ? NodeTypeC.PV : NodeTypeC.NonPV' pos' ss' ssPos' alpha' beta' d);                 ss[ssPos].skipNullMove = 0;                  tteHasValue = TT.probe(posKey' ref ttePos' out tte);                 ttMove = (tteHasValue) ? tte.move() : MoveC.MOVE_NONE;             }             else             {                 // Re-read (needed as TTEntry is a struct in the port)                 if ((tteHasValue) && (TT.entries[ttePos].key == tte.key)) { tte = TT.entries[ttePos]; }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The following statement contains a magic number: if (ttMove == MoveC.MOVE_NONE                 && depth >= IIDDepth[PvNode ? 1 : 0]                 && (PvNode || (!inCheck && ss[ssPos].eval + IIDMargin >= beta)))             {                 Depth d = (PvNode ? depth - 2 * DepthC.ONE_PLY : depth / 2);                  ss[ssPos].skipNullMove = 1;                 search(PvNode ? NodeTypeC.PV : NodeTypeC.NonPV' pos' ss' ssPos' alpha' beta' d);                 ss[ssPos].skipNullMove = 0;                  tteHasValue = TT.probe(posKey' ref ttePos' out tte);                 ttMove = (tteHasValue) ? tte.move() : MoveC.MOVE_NONE;             }             else             {                 // Re-read (needed as TTEntry is a struct in the port)                 if ((tteHasValue) && (TT.entries[ttePos].key == tte.key)) { tte = TT.entries[ttePos]; }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The following statement contains a magic number: singularExtensionNode = !RootNode                                    && !SpNode                                    && depth >= SingularExtensionDepth[PvNode ? 1 : 0]                                    && ttMove != MoveC.MOVE_NONE                                    && (excludedMove == 0) // Recursive singular search is not allowed                                    && ((tte.type() & Bound.BOUND_LOWER) != 0) // FIXME: uninitialized!                                    && tte.depth() >= depth - 3 * DepthC.ONE_PLY;
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The following statement contains a magic number: while (bestValue < beta                    && (move = mp.next_move()) != MoveC.MOVE_NONE                     && !thisThread.cutoff_occurred()                     && !SignalsStop)             {                 Debug.Assert(Utils.is_ok_M(move));                  if (move == excludedMove)                     continue;                  // At root obey the "searchmoves" option and skip moves not listed in Root                 // Move List' as a consequence any illegal move is also skipped. In MultiPV                 // mode we also skip PV moves which have been already searched.                  // If we find none' it means !count                 if (RootNode && (find(RootMoves' PVIdx' RootMoves.Count' move) == -1))                     continue;                  // At PV and SpNode nodes we want all moves to be legal since the beginning                 if ((PvNode || SpNode) && !pos.pl_move_is_legal(move' ci.pinned))                     continue;                  if (SpNode)                 {                     moveCount = ++sp.moveCount;                     ThreadHelper.lock_release(sp.Lock);                 }                 else                     moveCount++;                  if (RootNode)                 {                     SignalsFirstRootMove = (moveCount == 1);                      if (thisThread == Threads.main_thread() && SearchTime.ElapsedMilliseconds > 2000)                     {                         Plug.Write("info depth ");                         Plug.Write((depth / DepthC.ONE_PLY).ToString());                         Plug.Write(" currmove ");                         Plug.Write(Utils.move_to_uci(move' Chess960));                         Plug.Write(" nodes ");                         Plug.Write(pos.nodes.ToString());                         Plug.Write(" currmovenumber ");                         Plug.Write((moveCount + PVIdx).ToString());                         Plug.Write(Constants.endl);                     }                 }                  isPvMove = (PvNode && moveCount <= 1);                 captureOrPromotion = pos.is_capture_or_promotion(move);                 givesCheck = pos.move_gives_check(move' ci);                 dangerous = givesCheck || is_dangerous(pos' move' captureOrPromotion);                 ext = DepthC.DEPTH_ZERO;                  // Step 12. Extend checks and' in PV nodes' also dangerous moves                 if (PvNode && dangerous)                     ext = DepthC.ONE_PLY;                  else if (givesCheck && pos.see(move' true) >= 0)                     ext = DepthC.ONE_PLY / 2;                  // Singular extension search. If all moves but one fail low on a search of                 // (alpha-s' beta-s)' and just one fails high on (alpha' beta)' then that move                 // is singular and should be extended. To verify this we do a reduced search                 // on all the other moves but the ttMove' if result is lower than ttValue minus                 // a margin then we extend ttMove.                 if (singularExtensionNode                     && (ext == 0)                     && move == ttMove                     && pos.pl_move_is_legal(move' ci.pinned))                 {                     if (Math.Abs(ttValue) < ValueC.VALUE_KNOWN_WIN)                     {                         Value rBeta = ttValue - (int)(depth);                         ss[ssPos].excludedMove = move;                         ss[ssPos].skipNullMove = 1;                         value = search(NodeTypeC.NonPV' pos' ss' ssPos' rBeta - 1' rBeta' depth / 2);                         ss[ssPos].skipNullMove = 0;                         ss[ssPos].excludedMove = MoveC.MOVE_NONE;                         if (value < rBeta)                             ext = DepthC.ONE_PLY;                     }                 }                  // Update current move (this must be done after singular extension search)                 newDepth = depth - DepthC.ONE_PLY + ext;                  // Step 13. Futility pruning (is omitted in PV nodes)                 if (!PvNode && !inCheck                     && !captureOrPromotion                     && !dangerous                     && move != ttMove                     && (bestValue > ValueC.VALUE_MATED_IN_MAX_PLY || bestValue == -ValueC.VALUE_INFINITE)                     && !Utils.is_castle(move))                 {                     // Move count based pruning                     if (moveCount >= futility_move_count(depth)                         && ((threatMove == 0) || !connected_threat(pos' move' threatMove)))                     {                         if (SpNode)                             ThreadHelper.lock_grab(sp.Lock);                          continue;                     }                      // Value based pruning                     // We illogically ignore reduction condition depth >= 3*ONE_PLY for predicted depth'                     // but fixing this made program slightly weaker.                     Depth predictedDepth = newDepth - reduction(PvNode' depth' moveCount);                     futilityValue = futilityBase + futility_margin(predictedDepth' moveCount)                                                  + H.gain(pos.piece_moved(move)' Utils.to_sq(move));                      if (futilityValue < beta)                     {                         if (SpNode)                             ThreadHelper.lock_grab(sp.Lock);                          continue;                     }                      // Prune moves with negative SEE at low depths                     if (predictedDepth < 2 * DepthC.ONE_PLY                         && pos.see(move' true) < 0)                     {                         if (SpNode)                             ThreadHelper.lock_grab(sp.Lock);                          continue;                     }                 }                  // Check for legality only before to do the move                 if (!pos.pl_move_is_legal(move' ci.pinned))                 {                     moveCount--;                     continue;                 }                  ss[ssPos].currentMove = move;                 if (!SpNode && !captureOrPromotion && playedMoveCount < 64)                     movesSearched[playedMoveCount++] = move;                  // Step 14. Make the move                 if (st == null) { st = StateInfoBroker.GetObject(); }                 pos.do_move(move' st' ci' givesCheck);                  // Step 15. Reduced depth search (LMR). If the move fails high will be                 // re-searched at full depth.                 if (                     !isPvMove                     && !captureOrPromotion                     && !dangerous                     && ss[ssPos].killers0 != move                     && ss[ssPos].killers1 != move                     && depth > 3 * DepthC.ONE_PLY                     && !Utils.is_castle(move))                 {                     ss[ssPos].reduction = reduction(PvNode' depth' moveCount);                     Depth d = Math.Max(newDepth - ss[ssPos].reduction' DepthC.ONE_PLY);                     alpha = SpNode ? sp.alpha : alpha;                      value = -search(NodeTypeC.NonPV' pos' ss' ssPos + 1' -(alpha + 1)' -alpha' d);                      doFullDepthSearch = (value > alpha && ss[ssPos].reduction != DepthC.DEPTH_ZERO);                     ss[ssPos].reduction = DepthC.DEPTH_ZERO;                 }                 else                     doFullDepthSearch = !isPvMove;                  // Step 16. Full depth search' when LMR is skipped or fails high                 if (doFullDepthSearch)                 {                     alpha = SpNode ? sp.alpha : alpha;                     value = newDepth < DepthC.ONE_PLY ? -qsearch(NodeTypeC.NonPV' pos' ss' ssPos + 1' -(alpha + 1)' -alpha' DepthC.DEPTH_ZERO)                                                : -search(NodeTypeC.NonPV' pos' ss' ssPos + 1' -(alpha + 1)' -alpha' newDepth);                 }                  // Only for PV nodes do a full PV search on the first move or after a fail                 // high' in the latter case search only if value < beta' otherwise let the                 // parent node to fail low with value <= alpha and to try another move.                 if (PvNode && (isPvMove || (value > alpha && (RootNode || value < beta))))                 {                     value = newDepth < DepthC.ONE_PLY ? -qsearch(NodeTypeC.PV' pos' ss' ssPos + 1' -beta' -alpha' DepthC.DEPTH_ZERO)                                                : -search(NodeTypeC.PV' pos' ss' ssPos + 1' -beta' -alpha' newDepth);                 }                  // Step 17. Undo move                 pos.undo_move(move);                  Debug.Assert(value > -ValueC.VALUE_INFINITE && value < ValueC.VALUE_INFINITE);                  // Step 18. Check for new best move                 if (SpNode)                 {                     ThreadHelper.lock_grab(sp.Lock);                     bestValue = sp.bestValue;                     alpha = sp.alpha;                 }                  // Finished searching the move. If Signals.stop is true' the search                 // was aborted because the user interrupted the search or because we                 // ran out of time. In this case' the return value of the search cannot                 // be trusted' and we don't update the best move and/or PV.                 if (RootNode && !SignalsStop)                 {                     int rmPos = find(RootMoves' 0' RootMoves.Count' move);                      // PV move or new best move ?                     if (isPvMove || value > alpha)                     {                         RootMoves[rmPos].score = value;                         RootMoves[rmPos].extract_pv_from_tt(pos);                          // We record how often the best move has been changed in each                         // iteration. This information is used for time management: When                         // the best move changes frequently' we allocate some more time.                         if (!isPvMove && MultiPV == 1)                             BestMoveChanges++;                     }                     else                         // All other moves but the PV are set to the lowest value' this                         // is not a problem when sorting becuase sort is stable and move                         // position in the list is preserved' just the PV is pushed up.                         RootMoves[rmPos].score = -ValueC.VALUE_INFINITE;                  }                  if (value > bestValue)                 {                     bestValue = value;                     bestMove = move;                      if (PvNode                         && value > alpha                         && value < beta) // We want always alpha < beta                         alpha = value;                      if (SpNode && !thisThread.cutoff_occurred())                     {                         sp.bestValue = value;                         sp.bestMove = move;                         sp.alpha = alpha;                          if (value >= beta)                             sp.cutoff = true;                     }                 }                  // Step 19. Check for split                 if (!SpNode                   && depth >= Threads.min_split_depth()                   && bestValue < beta                   && Threads.available_slave_exists(thisThread)                   && !SignalsStop                   && !thisThread.cutoff_occurred())                 {                     bestValue = Threads.split(Constants.FakeSplit' pos' ss' ssPos' alpha' beta' bestValue' ref bestMove' depth' threatMove' moveCount' mp' NT);                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The following statement contains a magic number: while (bestValue < beta                    && (move = mp.next_move()) != MoveC.MOVE_NONE                     && !thisThread.cutoff_occurred()                     && !SignalsStop)             {                 Debug.Assert(Utils.is_ok_M(move));                  if (move == excludedMove)                     continue;                  // At root obey the "searchmoves" option and skip moves not listed in Root                 // Move List' as a consequence any illegal move is also skipped. In MultiPV                 // mode we also skip PV moves which have been already searched.                  // If we find none' it means !count                 if (RootNode && (find(RootMoves' PVIdx' RootMoves.Count' move) == -1))                     continue;                  // At PV and SpNode nodes we want all moves to be legal since the beginning                 if ((PvNode || SpNode) && !pos.pl_move_is_legal(move' ci.pinned))                     continue;                  if (SpNode)                 {                     moveCount = ++sp.moveCount;                     ThreadHelper.lock_release(sp.Lock);                 }                 else                     moveCount++;                  if (RootNode)                 {                     SignalsFirstRootMove = (moveCount == 1);                      if (thisThread == Threads.main_thread() && SearchTime.ElapsedMilliseconds > 2000)                     {                         Plug.Write("info depth ");                         Plug.Write((depth / DepthC.ONE_PLY).ToString());                         Plug.Write(" currmove ");                         Plug.Write(Utils.move_to_uci(move' Chess960));                         Plug.Write(" nodes ");                         Plug.Write(pos.nodes.ToString());                         Plug.Write(" currmovenumber ");                         Plug.Write((moveCount + PVIdx).ToString());                         Plug.Write(Constants.endl);                     }                 }                  isPvMove = (PvNode && moveCount <= 1);                 captureOrPromotion = pos.is_capture_or_promotion(move);                 givesCheck = pos.move_gives_check(move' ci);                 dangerous = givesCheck || is_dangerous(pos' move' captureOrPromotion);                 ext = DepthC.DEPTH_ZERO;                  // Step 12. Extend checks and' in PV nodes' also dangerous moves                 if (PvNode && dangerous)                     ext = DepthC.ONE_PLY;                  else if (givesCheck && pos.see(move' true) >= 0)                     ext = DepthC.ONE_PLY / 2;                  // Singular extension search. If all moves but one fail low on a search of                 // (alpha-s' beta-s)' and just one fails high on (alpha' beta)' then that move                 // is singular and should be extended. To verify this we do a reduced search                 // on all the other moves but the ttMove' if result is lower than ttValue minus                 // a margin then we extend ttMove.                 if (singularExtensionNode                     && (ext == 0)                     && move == ttMove                     && pos.pl_move_is_legal(move' ci.pinned))                 {                     if (Math.Abs(ttValue) < ValueC.VALUE_KNOWN_WIN)                     {                         Value rBeta = ttValue - (int)(depth);                         ss[ssPos].excludedMove = move;                         ss[ssPos].skipNullMove = 1;                         value = search(NodeTypeC.NonPV' pos' ss' ssPos' rBeta - 1' rBeta' depth / 2);                         ss[ssPos].skipNullMove = 0;                         ss[ssPos].excludedMove = MoveC.MOVE_NONE;                         if (value < rBeta)                             ext = DepthC.ONE_PLY;                     }                 }                  // Update current move (this must be done after singular extension search)                 newDepth = depth - DepthC.ONE_PLY + ext;                  // Step 13. Futility pruning (is omitted in PV nodes)                 if (!PvNode && !inCheck                     && !captureOrPromotion                     && !dangerous                     && move != ttMove                     && (bestValue > ValueC.VALUE_MATED_IN_MAX_PLY || bestValue == -ValueC.VALUE_INFINITE)                     && !Utils.is_castle(move))                 {                     // Move count based pruning                     if (moveCount >= futility_move_count(depth)                         && ((threatMove == 0) || !connected_threat(pos' move' threatMove)))                     {                         if (SpNode)                             ThreadHelper.lock_grab(sp.Lock);                          continue;                     }                      // Value based pruning                     // We illogically ignore reduction condition depth >= 3*ONE_PLY for predicted depth'                     // but fixing this made program slightly weaker.                     Depth predictedDepth = newDepth - reduction(PvNode' depth' moveCount);                     futilityValue = futilityBase + futility_margin(predictedDepth' moveCount)                                                  + H.gain(pos.piece_moved(move)' Utils.to_sq(move));                      if (futilityValue < beta)                     {                         if (SpNode)                             ThreadHelper.lock_grab(sp.Lock);                          continue;                     }                      // Prune moves with negative SEE at low depths                     if (predictedDepth < 2 * DepthC.ONE_PLY                         && pos.see(move' true) < 0)                     {                         if (SpNode)                             ThreadHelper.lock_grab(sp.Lock);                          continue;                     }                 }                  // Check for legality only before to do the move                 if (!pos.pl_move_is_legal(move' ci.pinned))                 {                     moveCount--;                     continue;                 }                  ss[ssPos].currentMove = move;                 if (!SpNode && !captureOrPromotion && playedMoveCount < 64)                     movesSearched[playedMoveCount++] = move;                  // Step 14. Make the move                 if (st == null) { st = StateInfoBroker.GetObject(); }                 pos.do_move(move' st' ci' givesCheck);                  // Step 15. Reduced depth search (LMR). If the move fails high will be                 // re-searched at full depth.                 if (                     !isPvMove                     && !captureOrPromotion                     && !dangerous                     && ss[ssPos].killers0 != move                     && ss[ssPos].killers1 != move                     && depth > 3 * DepthC.ONE_PLY                     && !Utils.is_castle(move))                 {                     ss[ssPos].reduction = reduction(PvNode' depth' moveCount);                     Depth d = Math.Max(newDepth - ss[ssPos].reduction' DepthC.ONE_PLY);                     alpha = SpNode ? sp.alpha : alpha;                      value = -search(NodeTypeC.NonPV' pos' ss' ssPos + 1' -(alpha + 1)' -alpha' d);                      doFullDepthSearch = (value > alpha && ss[ssPos].reduction != DepthC.DEPTH_ZERO);                     ss[ssPos].reduction = DepthC.DEPTH_ZERO;                 }                 else                     doFullDepthSearch = !isPvMove;                  // Step 16. Full depth search' when LMR is skipped or fails high                 if (doFullDepthSearch)                 {                     alpha = SpNode ? sp.alpha : alpha;                     value = newDepth < DepthC.ONE_PLY ? -qsearch(NodeTypeC.NonPV' pos' ss' ssPos + 1' -(alpha + 1)' -alpha' DepthC.DEPTH_ZERO)                                                : -search(NodeTypeC.NonPV' pos' ss' ssPos + 1' -(alpha + 1)' -alpha' newDepth);                 }                  // Only for PV nodes do a full PV search on the first move or after a fail                 // high' in the latter case search only if value < beta' otherwise let the                 // parent node to fail low with value <= alpha and to try another move.                 if (PvNode && (isPvMove || (value > alpha && (RootNode || value < beta))))                 {                     value = newDepth < DepthC.ONE_PLY ? -qsearch(NodeTypeC.PV' pos' ss' ssPos + 1' -beta' -alpha' DepthC.DEPTH_ZERO)                                                : -search(NodeTypeC.PV' pos' ss' ssPos + 1' -beta' -alpha' newDepth);                 }                  // Step 17. Undo move                 pos.undo_move(move);                  Debug.Assert(value > -ValueC.VALUE_INFINITE && value < ValueC.VALUE_INFINITE);                  // Step 18. Check for new best move                 if (SpNode)                 {                     ThreadHelper.lock_grab(sp.Lock);                     bestValue = sp.bestValue;                     alpha = sp.alpha;                 }                  // Finished searching the move. If Signals.stop is true' the search                 // was aborted because the user interrupted the search or because we                 // ran out of time. In this case' the return value of the search cannot                 // be trusted' and we don't update the best move and/or PV.                 if (RootNode && !SignalsStop)                 {                     int rmPos = find(RootMoves' 0' RootMoves.Count' move);                      // PV move or new best move ?                     if (isPvMove || value > alpha)                     {                         RootMoves[rmPos].score = value;                         RootMoves[rmPos].extract_pv_from_tt(pos);                          // We record how often the best move has been changed in each                         // iteration. This information is used for time management: When                         // the best move changes frequently' we allocate some more time.                         if (!isPvMove && MultiPV == 1)                             BestMoveChanges++;                     }                     else                         // All other moves but the PV are set to the lowest value' this                         // is not a problem when sorting becuase sort is stable and move                         // position in the list is preserved' just the PV is pushed up.                         RootMoves[rmPos].score = -ValueC.VALUE_INFINITE;                  }                  if (value > bestValue)                 {                     bestValue = value;                     bestMove = move;                      if (PvNode                         && value > alpha                         && value < beta) // We want always alpha < beta                         alpha = value;                      if (SpNode && !thisThread.cutoff_occurred())                     {                         sp.bestValue = value;                         sp.bestMove = move;                         sp.alpha = alpha;                          if (value >= beta)                             sp.cutoff = true;                     }                 }                  // Step 19. Check for split                 if (!SpNode                   && depth >= Threads.min_split_depth()                   && bestValue < beta                   && Threads.available_slave_exists(thisThread)                   && !SignalsStop                   && !thisThread.cutoff_occurred())                 {                     bestValue = Threads.split(Constants.FakeSplit' pos' ss' ssPos' alpha' beta' bestValue' ref bestMove' depth' threatMove' moveCount' mp' NT);                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The following statement contains a magic number: while (bestValue < beta                    && (move = mp.next_move()) != MoveC.MOVE_NONE                     && !thisThread.cutoff_occurred()                     && !SignalsStop)             {                 Debug.Assert(Utils.is_ok_M(move));                  if (move == excludedMove)                     continue;                  // At root obey the "searchmoves" option and skip moves not listed in Root                 // Move List' as a consequence any illegal move is also skipped. In MultiPV                 // mode we also skip PV moves which have been already searched.                  // If we find none' it means !count                 if (RootNode && (find(RootMoves' PVIdx' RootMoves.Count' move) == -1))                     continue;                  // At PV and SpNode nodes we want all moves to be legal since the beginning                 if ((PvNode || SpNode) && !pos.pl_move_is_legal(move' ci.pinned))                     continue;                  if (SpNode)                 {                     moveCount = ++sp.moveCount;                     ThreadHelper.lock_release(sp.Lock);                 }                 else                     moveCount++;                  if (RootNode)                 {                     SignalsFirstRootMove = (moveCount == 1);                      if (thisThread == Threads.main_thread() && SearchTime.ElapsedMilliseconds > 2000)                     {                         Plug.Write("info depth ");                         Plug.Write((depth / DepthC.ONE_PLY).ToString());                         Plug.Write(" currmove ");                         Plug.Write(Utils.move_to_uci(move' Chess960));                         Plug.Write(" nodes ");                         Plug.Write(pos.nodes.ToString());                         Plug.Write(" currmovenumber ");                         Plug.Write((moveCount + PVIdx).ToString());                         Plug.Write(Constants.endl);                     }                 }                  isPvMove = (PvNode && moveCount <= 1);                 captureOrPromotion = pos.is_capture_or_promotion(move);                 givesCheck = pos.move_gives_check(move' ci);                 dangerous = givesCheck || is_dangerous(pos' move' captureOrPromotion);                 ext = DepthC.DEPTH_ZERO;                  // Step 12. Extend checks and' in PV nodes' also dangerous moves                 if (PvNode && dangerous)                     ext = DepthC.ONE_PLY;                  else if (givesCheck && pos.see(move' true) >= 0)                     ext = DepthC.ONE_PLY / 2;                  // Singular extension search. If all moves but one fail low on a search of                 // (alpha-s' beta-s)' and just one fails high on (alpha' beta)' then that move                 // is singular and should be extended. To verify this we do a reduced search                 // on all the other moves but the ttMove' if result is lower than ttValue minus                 // a margin then we extend ttMove.                 if (singularExtensionNode                     && (ext == 0)                     && move == ttMove                     && pos.pl_move_is_legal(move' ci.pinned))                 {                     if (Math.Abs(ttValue) < ValueC.VALUE_KNOWN_WIN)                     {                         Value rBeta = ttValue - (int)(depth);                         ss[ssPos].excludedMove = move;                         ss[ssPos].skipNullMove = 1;                         value = search(NodeTypeC.NonPV' pos' ss' ssPos' rBeta - 1' rBeta' depth / 2);                         ss[ssPos].skipNullMove = 0;                         ss[ssPos].excludedMove = MoveC.MOVE_NONE;                         if (value < rBeta)                             ext = DepthC.ONE_PLY;                     }                 }                  // Update current move (this must be done after singular extension search)                 newDepth = depth - DepthC.ONE_PLY + ext;                  // Step 13. Futility pruning (is omitted in PV nodes)                 if (!PvNode && !inCheck                     && !captureOrPromotion                     && !dangerous                     && move != ttMove                     && (bestValue > ValueC.VALUE_MATED_IN_MAX_PLY || bestValue == -ValueC.VALUE_INFINITE)                     && !Utils.is_castle(move))                 {                     // Move count based pruning                     if (moveCount >= futility_move_count(depth)                         && ((threatMove == 0) || !connected_threat(pos' move' threatMove)))                     {                         if (SpNode)                             ThreadHelper.lock_grab(sp.Lock);                          continue;                     }                      // Value based pruning                     // We illogically ignore reduction condition depth >= 3*ONE_PLY for predicted depth'                     // but fixing this made program slightly weaker.                     Depth predictedDepth = newDepth - reduction(PvNode' depth' moveCount);                     futilityValue = futilityBase + futility_margin(predictedDepth' moveCount)                                                  + H.gain(pos.piece_moved(move)' Utils.to_sq(move));                      if (futilityValue < beta)                     {                         if (SpNode)                             ThreadHelper.lock_grab(sp.Lock);                          continue;                     }                      // Prune moves with negative SEE at low depths                     if (predictedDepth < 2 * DepthC.ONE_PLY                         && pos.see(move' true) < 0)                     {                         if (SpNode)                             ThreadHelper.lock_grab(sp.Lock);                          continue;                     }                 }                  // Check for legality only before to do the move                 if (!pos.pl_move_is_legal(move' ci.pinned))                 {                     moveCount--;                     continue;                 }                  ss[ssPos].currentMove = move;                 if (!SpNode && !captureOrPromotion && playedMoveCount < 64)                     movesSearched[playedMoveCount++] = move;                  // Step 14. Make the move                 if (st == null) { st = StateInfoBroker.GetObject(); }                 pos.do_move(move' st' ci' givesCheck);                  // Step 15. Reduced depth search (LMR). If the move fails high will be                 // re-searched at full depth.                 if (                     !isPvMove                     && !captureOrPromotion                     && !dangerous                     && ss[ssPos].killers0 != move                     && ss[ssPos].killers1 != move                     && depth > 3 * DepthC.ONE_PLY                     && !Utils.is_castle(move))                 {                     ss[ssPos].reduction = reduction(PvNode' depth' moveCount);                     Depth d = Math.Max(newDepth - ss[ssPos].reduction' DepthC.ONE_PLY);                     alpha = SpNode ? sp.alpha : alpha;                      value = -search(NodeTypeC.NonPV' pos' ss' ssPos + 1' -(alpha + 1)' -alpha' d);                      doFullDepthSearch = (value > alpha && ss[ssPos].reduction != DepthC.DEPTH_ZERO);                     ss[ssPos].reduction = DepthC.DEPTH_ZERO;                 }                 else                     doFullDepthSearch = !isPvMove;                  // Step 16. Full depth search' when LMR is skipped or fails high                 if (doFullDepthSearch)                 {                     alpha = SpNode ? sp.alpha : alpha;                     value = newDepth < DepthC.ONE_PLY ? -qsearch(NodeTypeC.NonPV' pos' ss' ssPos + 1' -(alpha + 1)' -alpha' DepthC.DEPTH_ZERO)                                                : -search(NodeTypeC.NonPV' pos' ss' ssPos + 1' -(alpha + 1)' -alpha' newDepth);                 }                  // Only for PV nodes do a full PV search on the first move or after a fail                 // high' in the latter case search only if value < beta' otherwise let the                 // parent node to fail low with value <= alpha and to try another move.                 if (PvNode && (isPvMove || (value > alpha && (RootNode || value < beta))))                 {                     value = newDepth < DepthC.ONE_PLY ? -qsearch(NodeTypeC.PV' pos' ss' ssPos + 1' -beta' -alpha' DepthC.DEPTH_ZERO)                                                : -search(NodeTypeC.PV' pos' ss' ssPos + 1' -beta' -alpha' newDepth);                 }                  // Step 17. Undo move                 pos.undo_move(move);                  Debug.Assert(value > -ValueC.VALUE_INFINITE && value < ValueC.VALUE_INFINITE);                  // Step 18. Check for new best move                 if (SpNode)                 {                     ThreadHelper.lock_grab(sp.Lock);                     bestValue = sp.bestValue;                     alpha = sp.alpha;                 }                  // Finished searching the move. If Signals.stop is true' the search                 // was aborted because the user interrupted the search or because we                 // ran out of time. In this case' the return value of the search cannot                 // be trusted' and we don't update the best move and/or PV.                 if (RootNode && !SignalsStop)                 {                     int rmPos = find(RootMoves' 0' RootMoves.Count' move);                      // PV move or new best move ?                     if (isPvMove || value > alpha)                     {                         RootMoves[rmPos].score = value;                         RootMoves[rmPos].extract_pv_from_tt(pos);                          // We record how often the best move has been changed in each                         // iteration. This information is used for time management: When                         // the best move changes frequently' we allocate some more time.                         if (!isPvMove && MultiPV == 1)                             BestMoveChanges++;                     }                     else                         // All other moves but the PV are set to the lowest value' this                         // is not a problem when sorting becuase sort is stable and move                         // position in the list is preserved' just the PV is pushed up.                         RootMoves[rmPos].score = -ValueC.VALUE_INFINITE;                  }                  if (value > bestValue)                 {                     bestValue = value;                     bestMove = move;                      if (PvNode                         && value > alpha                         && value < beta) // We want always alpha < beta                         alpha = value;                      if (SpNode && !thisThread.cutoff_occurred())                     {                         sp.bestValue = value;                         sp.bestMove = move;                         sp.alpha = alpha;                          if (value >= beta)                             sp.cutoff = true;                     }                 }                  // Step 19. Check for split                 if (!SpNode                   && depth >= Threads.min_split_depth()                   && bestValue < beta                   && Threads.available_slave_exists(thisThread)                   && !SignalsStop                   && !thisThread.cutoff_occurred())                 {                     bestValue = Threads.split(Constants.FakeSplit' pos' ss' ssPos' alpha' beta' bestValue' ref bestMove' depth' threatMove' moveCount' mp' NT);                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The following statement contains a magic number: while (bestValue < beta                    && (move = mp.next_move()) != MoveC.MOVE_NONE                     && !thisThread.cutoff_occurred()                     && !SignalsStop)             {                 Debug.Assert(Utils.is_ok_M(move));                  if (move == excludedMove)                     continue;                  // At root obey the "searchmoves" option and skip moves not listed in Root                 // Move List' as a consequence any illegal move is also skipped. In MultiPV                 // mode we also skip PV moves which have been already searched.                  // If we find none' it means !count                 if (RootNode && (find(RootMoves' PVIdx' RootMoves.Count' move) == -1))                     continue;                  // At PV and SpNode nodes we want all moves to be legal since the beginning                 if ((PvNode || SpNode) && !pos.pl_move_is_legal(move' ci.pinned))                     continue;                  if (SpNode)                 {                     moveCount = ++sp.moveCount;                     ThreadHelper.lock_release(sp.Lock);                 }                 else                     moveCount++;                  if (RootNode)                 {                     SignalsFirstRootMove = (moveCount == 1);                      if (thisThread == Threads.main_thread() && SearchTime.ElapsedMilliseconds > 2000)                     {                         Plug.Write("info depth ");                         Plug.Write((depth / DepthC.ONE_PLY).ToString());                         Plug.Write(" currmove ");                         Plug.Write(Utils.move_to_uci(move' Chess960));                         Plug.Write(" nodes ");                         Plug.Write(pos.nodes.ToString());                         Plug.Write(" currmovenumber ");                         Plug.Write((moveCount + PVIdx).ToString());                         Plug.Write(Constants.endl);                     }                 }                  isPvMove = (PvNode && moveCount <= 1);                 captureOrPromotion = pos.is_capture_or_promotion(move);                 givesCheck = pos.move_gives_check(move' ci);                 dangerous = givesCheck || is_dangerous(pos' move' captureOrPromotion);                 ext = DepthC.DEPTH_ZERO;                  // Step 12. Extend checks and' in PV nodes' also dangerous moves                 if (PvNode && dangerous)                     ext = DepthC.ONE_PLY;                  else if (givesCheck && pos.see(move' true) >= 0)                     ext = DepthC.ONE_PLY / 2;                  // Singular extension search. If all moves but one fail low on a search of                 // (alpha-s' beta-s)' and just one fails high on (alpha' beta)' then that move                 // is singular and should be extended. To verify this we do a reduced search                 // on all the other moves but the ttMove' if result is lower than ttValue minus                 // a margin then we extend ttMove.                 if (singularExtensionNode                     && (ext == 0)                     && move == ttMove                     && pos.pl_move_is_legal(move' ci.pinned))                 {                     if (Math.Abs(ttValue) < ValueC.VALUE_KNOWN_WIN)                     {                         Value rBeta = ttValue - (int)(depth);                         ss[ssPos].excludedMove = move;                         ss[ssPos].skipNullMove = 1;                         value = search(NodeTypeC.NonPV' pos' ss' ssPos' rBeta - 1' rBeta' depth / 2);                         ss[ssPos].skipNullMove = 0;                         ss[ssPos].excludedMove = MoveC.MOVE_NONE;                         if (value < rBeta)                             ext = DepthC.ONE_PLY;                     }                 }                  // Update current move (this must be done after singular extension search)                 newDepth = depth - DepthC.ONE_PLY + ext;                  // Step 13. Futility pruning (is omitted in PV nodes)                 if (!PvNode && !inCheck                     && !captureOrPromotion                     && !dangerous                     && move != ttMove                     && (bestValue > ValueC.VALUE_MATED_IN_MAX_PLY || bestValue == -ValueC.VALUE_INFINITE)                     && !Utils.is_castle(move))                 {                     // Move count based pruning                     if (moveCount >= futility_move_count(depth)                         && ((threatMove == 0) || !connected_threat(pos' move' threatMove)))                     {                         if (SpNode)                             ThreadHelper.lock_grab(sp.Lock);                          continue;                     }                      // Value based pruning                     // We illogically ignore reduction condition depth >= 3*ONE_PLY for predicted depth'                     // but fixing this made program slightly weaker.                     Depth predictedDepth = newDepth - reduction(PvNode' depth' moveCount);                     futilityValue = futilityBase + futility_margin(predictedDepth' moveCount)                                                  + H.gain(pos.piece_moved(move)' Utils.to_sq(move));                      if (futilityValue < beta)                     {                         if (SpNode)                             ThreadHelper.lock_grab(sp.Lock);                          continue;                     }                      // Prune moves with negative SEE at low depths                     if (predictedDepth < 2 * DepthC.ONE_PLY                         && pos.see(move' true) < 0)                     {                         if (SpNode)                             ThreadHelper.lock_grab(sp.Lock);                          continue;                     }                 }                  // Check for legality only before to do the move                 if (!pos.pl_move_is_legal(move' ci.pinned))                 {                     moveCount--;                     continue;                 }                  ss[ssPos].currentMove = move;                 if (!SpNode && !captureOrPromotion && playedMoveCount < 64)                     movesSearched[playedMoveCount++] = move;                  // Step 14. Make the move                 if (st == null) { st = StateInfoBroker.GetObject(); }                 pos.do_move(move' st' ci' givesCheck);                  // Step 15. Reduced depth search (LMR). If the move fails high will be                 // re-searched at full depth.                 if (                     !isPvMove                     && !captureOrPromotion                     && !dangerous                     && ss[ssPos].killers0 != move                     && ss[ssPos].killers1 != move                     && depth > 3 * DepthC.ONE_PLY                     && !Utils.is_castle(move))                 {                     ss[ssPos].reduction = reduction(PvNode' depth' moveCount);                     Depth d = Math.Max(newDepth - ss[ssPos].reduction' DepthC.ONE_PLY);                     alpha = SpNode ? sp.alpha : alpha;                      value = -search(NodeTypeC.NonPV' pos' ss' ssPos + 1' -(alpha + 1)' -alpha' d);                      doFullDepthSearch = (value > alpha && ss[ssPos].reduction != DepthC.DEPTH_ZERO);                     ss[ssPos].reduction = DepthC.DEPTH_ZERO;                 }                 else                     doFullDepthSearch = !isPvMove;                  // Step 16. Full depth search' when LMR is skipped or fails high                 if (doFullDepthSearch)                 {                     alpha = SpNode ? sp.alpha : alpha;                     value = newDepth < DepthC.ONE_PLY ? -qsearch(NodeTypeC.NonPV' pos' ss' ssPos + 1' -(alpha + 1)' -alpha' DepthC.DEPTH_ZERO)                                                : -search(NodeTypeC.NonPV' pos' ss' ssPos + 1' -(alpha + 1)' -alpha' newDepth);                 }                  // Only for PV nodes do a full PV search on the first move or after a fail                 // high' in the latter case search only if value < beta' otherwise let the                 // parent node to fail low with value <= alpha and to try another move.                 if (PvNode && (isPvMove || (value > alpha && (RootNode || value < beta))))                 {                     value = newDepth < DepthC.ONE_PLY ? -qsearch(NodeTypeC.PV' pos' ss' ssPos + 1' -beta' -alpha' DepthC.DEPTH_ZERO)                                                : -search(NodeTypeC.PV' pos' ss' ssPos + 1' -beta' -alpha' newDepth);                 }                  // Step 17. Undo move                 pos.undo_move(move);                  Debug.Assert(value > -ValueC.VALUE_INFINITE && value < ValueC.VALUE_INFINITE);                  // Step 18. Check for new best move                 if (SpNode)                 {                     ThreadHelper.lock_grab(sp.Lock);                     bestValue = sp.bestValue;                     alpha = sp.alpha;                 }                  // Finished searching the move. If Signals.stop is true' the search                 // was aborted because the user interrupted the search or because we                 // ran out of time. In this case' the return value of the search cannot                 // be trusted' and we don't update the best move and/or PV.                 if (RootNode && !SignalsStop)                 {                     int rmPos = find(RootMoves' 0' RootMoves.Count' move);                      // PV move or new best move ?                     if (isPvMove || value > alpha)                     {                         RootMoves[rmPos].score = value;                         RootMoves[rmPos].extract_pv_from_tt(pos);                          // We record how often the best move has been changed in each                         // iteration. This information is used for time management: When                         // the best move changes frequently' we allocate some more time.                         if (!isPvMove && MultiPV == 1)                             BestMoveChanges++;                     }                     else                         // All other moves but the PV are set to the lowest value' this                         // is not a problem when sorting becuase sort is stable and move                         // position in the list is preserved' just the PV is pushed up.                         RootMoves[rmPos].score = -ValueC.VALUE_INFINITE;                  }                  if (value > bestValue)                 {                     bestValue = value;                     bestMove = move;                      if (PvNode                         && value > alpha                         && value < beta) // We want always alpha < beta                         alpha = value;                      if (SpNode && !thisThread.cutoff_occurred())                     {                         sp.bestValue = value;                         sp.bestMove = move;                         sp.alpha = alpha;                          if (value >= beta)                             sp.cutoff = true;                     }                 }                  // Step 19. Check for split                 if (!SpNode                   && depth >= Threads.min_split_depth()                   && bestValue < beta                   && Threads.available_slave_exists(thisThread)                   && !SignalsStop                   && !thisThread.cutoff_occurred())                 {                     bestValue = Threads.split(Constants.FakeSplit' pos' ss' ssPos' alpha' beta' bestValue' ref bestMove' depth' threatMove' moveCount' mp' NT);                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The following statement contains a magic number: while (bestValue < beta                    && (move = mp.next_move()) != MoveC.MOVE_NONE                     && !thisThread.cutoff_occurred()                     && !SignalsStop)             {                 Debug.Assert(Utils.is_ok_M(move));                  if (move == excludedMove)                     continue;                  // At root obey the "searchmoves" option and skip moves not listed in Root                 // Move List' as a consequence any illegal move is also skipped. In MultiPV                 // mode we also skip PV moves which have been already searched.                  // If we find none' it means !count                 if (RootNode && (find(RootMoves' PVIdx' RootMoves.Count' move) == -1))                     continue;                  // At PV and SpNode nodes we want all moves to be legal since the beginning                 if ((PvNode || SpNode) && !pos.pl_move_is_legal(move' ci.pinned))                     continue;                  if (SpNode)                 {                     moveCount = ++sp.moveCount;                     ThreadHelper.lock_release(sp.Lock);                 }                 else                     moveCount++;                  if (RootNode)                 {                     SignalsFirstRootMove = (moveCount == 1);                      if (thisThread == Threads.main_thread() && SearchTime.ElapsedMilliseconds > 2000)                     {                         Plug.Write("info depth ");                         Plug.Write((depth / DepthC.ONE_PLY).ToString());                         Plug.Write(" currmove ");                         Plug.Write(Utils.move_to_uci(move' Chess960));                         Plug.Write(" nodes ");                         Plug.Write(pos.nodes.ToString());                         Plug.Write(" currmovenumber ");                         Plug.Write((moveCount + PVIdx).ToString());                         Plug.Write(Constants.endl);                     }                 }                  isPvMove = (PvNode && moveCount <= 1);                 captureOrPromotion = pos.is_capture_or_promotion(move);                 givesCheck = pos.move_gives_check(move' ci);                 dangerous = givesCheck || is_dangerous(pos' move' captureOrPromotion);                 ext = DepthC.DEPTH_ZERO;                  // Step 12. Extend checks and' in PV nodes' also dangerous moves                 if (PvNode && dangerous)                     ext = DepthC.ONE_PLY;                  else if (givesCheck && pos.see(move' true) >= 0)                     ext = DepthC.ONE_PLY / 2;                  // Singular extension search. If all moves but one fail low on a search of                 // (alpha-s' beta-s)' and just one fails high on (alpha' beta)' then that move                 // is singular and should be extended. To verify this we do a reduced search                 // on all the other moves but the ttMove' if result is lower than ttValue minus                 // a margin then we extend ttMove.                 if (singularExtensionNode                     && (ext == 0)                     && move == ttMove                     && pos.pl_move_is_legal(move' ci.pinned))                 {                     if (Math.Abs(ttValue) < ValueC.VALUE_KNOWN_WIN)                     {                         Value rBeta = ttValue - (int)(depth);                         ss[ssPos].excludedMove = move;                         ss[ssPos].skipNullMove = 1;                         value = search(NodeTypeC.NonPV' pos' ss' ssPos' rBeta - 1' rBeta' depth / 2);                         ss[ssPos].skipNullMove = 0;                         ss[ssPos].excludedMove = MoveC.MOVE_NONE;                         if (value < rBeta)                             ext = DepthC.ONE_PLY;                     }                 }                  // Update current move (this must be done after singular extension search)                 newDepth = depth - DepthC.ONE_PLY + ext;                  // Step 13. Futility pruning (is omitted in PV nodes)                 if (!PvNode && !inCheck                     && !captureOrPromotion                     && !dangerous                     && move != ttMove                     && (bestValue > ValueC.VALUE_MATED_IN_MAX_PLY || bestValue == -ValueC.VALUE_INFINITE)                     && !Utils.is_castle(move))                 {                     // Move count based pruning                     if (moveCount >= futility_move_count(depth)                         && ((threatMove == 0) || !connected_threat(pos' move' threatMove)))                     {                         if (SpNode)                             ThreadHelper.lock_grab(sp.Lock);                          continue;                     }                      // Value based pruning                     // We illogically ignore reduction condition depth >= 3*ONE_PLY for predicted depth'                     // but fixing this made program slightly weaker.                     Depth predictedDepth = newDepth - reduction(PvNode' depth' moveCount);                     futilityValue = futilityBase + futility_margin(predictedDepth' moveCount)                                                  + H.gain(pos.piece_moved(move)' Utils.to_sq(move));                      if (futilityValue < beta)                     {                         if (SpNode)                             ThreadHelper.lock_grab(sp.Lock);                          continue;                     }                      // Prune moves with negative SEE at low depths                     if (predictedDepth < 2 * DepthC.ONE_PLY                         && pos.see(move' true) < 0)                     {                         if (SpNode)                             ThreadHelper.lock_grab(sp.Lock);                          continue;                     }                 }                  // Check for legality only before to do the move                 if (!pos.pl_move_is_legal(move' ci.pinned))                 {                     moveCount--;                     continue;                 }                  ss[ssPos].currentMove = move;                 if (!SpNode && !captureOrPromotion && playedMoveCount < 64)                     movesSearched[playedMoveCount++] = move;                  // Step 14. Make the move                 if (st == null) { st = StateInfoBroker.GetObject(); }                 pos.do_move(move' st' ci' givesCheck);                  // Step 15. Reduced depth search (LMR). If the move fails high will be                 // re-searched at full depth.                 if (                     !isPvMove                     && !captureOrPromotion                     && !dangerous                     && ss[ssPos].killers0 != move                     && ss[ssPos].killers1 != move                     && depth > 3 * DepthC.ONE_PLY                     && !Utils.is_castle(move))                 {                     ss[ssPos].reduction = reduction(PvNode' depth' moveCount);                     Depth d = Math.Max(newDepth - ss[ssPos].reduction' DepthC.ONE_PLY);                     alpha = SpNode ? sp.alpha : alpha;                      value = -search(NodeTypeC.NonPV' pos' ss' ssPos + 1' -(alpha + 1)' -alpha' d);                      doFullDepthSearch = (value > alpha && ss[ssPos].reduction != DepthC.DEPTH_ZERO);                     ss[ssPos].reduction = DepthC.DEPTH_ZERO;                 }                 else                     doFullDepthSearch = !isPvMove;                  // Step 16. Full depth search' when LMR is skipped or fails high                 if (doFullDepthSearch)                 {                     alpha = SpNode ? sp.alpha : alpha;                     value = newDepth < DepthC.ONE_PLY ? -qsearch(NodeTypeC.NonPV' pos' ss' ssPos + 1' -(alpha + 1)' -alpha' DepthC.DEPTH_ZERO)                                                : -search(NodeTypeC.NonPV' pos' ss' ssPos + 1' -(alpha + 1)' -alpha' newDepth);                 }                  // Only for PV nodes do a full PV search on the first move or after a fail                 // high' in the latter case search only if value < beta' otherwise let the                 // parent node to fail low with value <= alpha and to try another move.                 if (PvNode && (isPvMove || (value > alpha && (RootNode || value < beta))))                 {                     value = newDepth < DepthC.ONE_PLY ? -qsearch(NodeTypeC.PV' pos' ss' ssPos + 1' -beta' -alpha' DepthC.DEPTH_ZERO)                                                : -search(NodeTypeC.PV' pos' ss' ssPos + 1' -beta' -alpha' newDepth);                 }                  // Step 17. Undo move                 pos.undo_move(move);                  Debug.Assert(value > -ValueC.VALUE_INFINITE && value < ValueC.VALUE_INFINITE);                  // Step 18. Check for new best move                 if (SpNode)                 {                     ThreadHelper.lock_grab(sp.Lock);                     bestValue = sp.bestValue;                     alpha = sp.alpha;                 }                  // Finished searching the move. If Signals.stop is true' the search                 // was aborted because the user interrupted the search or because we                 // ran out of time. In this case' the return value of the search cannot                 // be trusted' and we don't update the best move and/or PV.                 if (RootNode && !SignalsStop)                 {                     int rmPos = find(RootMoves' 0' RootMoves.Count' move);                      // PV move or new best move ?                     if (isPvMove || value > alpha)                     {                         RootMoves[rmPos].score = value;                         RootMoves[rmPos].extract_pv_from_tt(pos);                          // We record how often the best move has been changed in each                         // iteration. This information is used for time management: When                         // the best move changes frequently' we allocate some more time.                         if (!isPvMove && MultiPV == 1)                             BestMoveChanges++;                     }                     else                         // All other moves but the PV are set to the lowest value' this                         // is not a problem when sorting becuase sort is stable and move                         // position in the list is preserved' just the PV is pushed up.                         RootMoves[rmPos].score = -ValueC.VALUE_INFINITE;                  }                  if (value > bestValue)                 {                     bestValue = value;                     bestMove = move;                      if (PvNode                         && value > alpha                         && value < beta) // We want always alpha < beta                         alpha = value;                      if (SpNode && !thisThread.cutoff_occurred())                     {                         sp.bestValue = value;                         sp.bestMove = move;                         sp.alpha = alpha;                          if (value >= beta)                             sp.cutoff = true;                     }                 }                  // Step 19. Check for split                 if (!SpNode                   && depth >= Threads.min_split_depth()                   && bestValue < beta                   && Threads.available_slave_exists(thisThread)                   && !SignalsStop                   && !thisThread.cutoff_occurred())                 {                     bestValue = Threads.split(Constants.FakeSplit' pos' ss' ssPos' alpha' beta' bestValue' ref bestMove' depth' threatMove' moveCount' mp' NT);                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,search,The following statement contains a magic number: while (bestValue < beta                    && (move = mp.next_move()) != MoveC.MOVE_NONE                     && !thisThread.cutoff_occurred()                     && !SignalsStop)             {                 Debug.Assert(Utils.is_ok_M(move));                  if (move == excludedMove)                     continue;                  // At root obey the "searchmoves" option and skip moves not listed in Root                 // Move List' as a consequence any illegal move is also skipped. In MultiPV                 // mode we also skip PV moves which have been already searched.                  // If we find none' it means !count                 if (RootNode && (find(RootMoves' PVIdx' RootMoves.Count' move) == -1))                     continue;                  // At PV and SpNode nodes we want all moves to be legal since the beginning                 if ((PvNode || SpNode) && !pos.pl_move_is_legal(move' ci.pinned))                     continue;                  if (SpNode)                 {                     moveCount = ++sp.moveCount;                     ThreadHelper.lock_release(sp.Lock);                 }                 else                     moveCount++;                  if (RootNode)                 {                     SignalsFirstRootMove = (moveCount == 1);                      if (thisThread == Threads.main_thread() && SearchTime.ElapsedMilliseconds > 2000)                     {                         Plug.Write("info depth ");                         Plug.Write((depth / DepthC.ONE_PLY).ToString());                         Plug.Write(" currmove ");                         Plug.Write(Utils.move_to_uci(move' Chess960));                         Plug.Write(" nodes ");                         Plug.Write(pos.nodes.ToString());                         Plug.Write(" currmovenumber ");                         Plug.Write((moveCount + PVIdx).ToString());                         Plug.Write(Constants.endl);                     }                 }                  isPvMove = (PvNode && moveCount <= 1);                 captureOrPromotion = pos.is_capture_or_promotion(move);                 givesCheck = pos.move_gives_check(move' ci);                 dangerous = givesCheck || is_dangerous(pos' move' captureOrPromotion);                 ext = DepthC.DEPTH_ZERO;                  // Step 12. Extend checks and' in PV nodes' also dangerous moves                 if (PvNode && dangerous)                     ext = DepthC.ONE_PLY;                  else if (givesCheck && pos.see(move' true) >= 0)                     ext = DepthC.ONE_PLY / 2;                  // Singular extension search. If all moves but one fail low on a search of                 // (alpha-s' beta-s)' and just one fails high on (alpha' beta)' then that move                 // is singular and should be extended. To verify this we do a reduced search                 // on all the other moves but the ttMove' if result is lower than ttValue minus                 // a margin then we extend ttMove.                 if (singularExtensionNode                     && (ext == 0)                     && move == ttMove                     && pos.pl_move_is_legal(move' ci.pinned))                 {                     if (Math.Abs(ttValue) < ValueC.VALUE_KNOWN_WIN)                     {                         Value rBeta = ttValue - (int)(depth);                         ss[ssPos].excludedMove = move;                         ss[ssPos].skipNullMove = 1;                         value = search(NodeTypeC.NonPV' pos' ss' ssPos' rBeta - 1' rBeta' depth / 2);                         ss[ssPos].skipNullMove = 0;                         ss[ssPos].excludedMove = MoveC.MOVE_NONE;                         if (value < rBeta)                             ext = DepthC.ONE_PLY;                     }                 }                  // Update current move (this must be done after singular extension search)                 newDepth = depth - DepthC.ONE_PLY + ext;                  // Step 13. Futility pruning (is omitted in PV nodes)                 if (!PvNode && !inCheck                     && !captureOrPromotion                     && !dangerous                     && move != ttMove                     && (bestValue > ValueC.VALUE_MATED_IN_MAX_PLY || bestValue == -ValueC.VALUE_INFINITE)                     && !Utils.is_castle(move))                 {                     // Move count based pruning                     if (moveCount >= futility_move_count(depth)                         && ((threatMove == 0) || !connected_threat(pos' move' threatMove)))                     {                         if (SpNode)                             ThreadHelper.lock_grab(sp.Lock);                          continue;                     }                      // Value based pruning                     // We illogically ignore reduction condition depth >= 3*ONE_PLY for predicted depth'                     // but fixing this made program slightly weaker.                     Depth predictedDepth = newDepth - reduction(PvNode' depth' moveCount);                     futilityValue = futilityBase + futility_margin(predictedDepth' moveCount)                                                  + H.gain(pos.piece_moved(move)' Utils.to_sq(move));                      if (futilityValue < beta)                     {                         if (SpNode)                             ThreadHelper.lock_grab(sp.Lock);                          continue;                     }                      // Prune moves with negative SEE at low depths                     if (predictedDepth < 2 * DepthC.ONE_PLY                         && pos.see(move' true) < 0)                     {                         if (SpNode)                             ThreadHelper.lock_grab(sp.Lock);                          continue;                     }                 }                  // Check for legality only before to do the move                 if (!pos.pl_move_is_legal(move' ci.pinned))                 {                     moveCount--;                     continue;                 }                  ss[ssPos].currentMove = move;                 if (!SpNode && !captureOrPromotion && playedMoveCount < 64)                     movesSearched[playedMoveCount++] = move;                  // Step 14. Make the move                 if (st == null) { st = StateInfoBroker.GetObject(); }                 pos.do_move(move' st' ci' givesCheck);                  // Step 15. Reduced depth search (LMR). If the move fails high will be                 // re-searched at full depth.                 if (                     !isPvMove                     && !captureOrPromotion                     && !dangerous                     && ss[ssPos].killers0 != move                     && ss[ssPos].killers1 != move                     && depth > 3 * DepthC.ONE_PLY                     && !Utils.is_castle(move))                 {                     ss[ssPos].reduction = reduction(PvNode' depth' moveCount);                     Depth d = Math.Max(newDepth - ss[ssPos].reduction' DepthC.ONE_PLY);                     alpha = SpNode ? sp.alpha : alpha;                      value = -search(NodeTypeC.NonPV' pos' ss' ssPos + 1' -(alpha + 1)' -alpha' d);                      doFullDepthSearch = (value > alpha && ss[ssPos].reduction != DepthC.DEPTH_ZERO);                     ss[ssPos].reduction = DepthC.DEPTH_ZERO;                 }                 else                     doFullDepthSearch = !isPvMove;                  // Step 16. Full depth search' when LMR is skipped or fails high                 if (doFullDepthSearch)                 {                     alpha = SpNode ? sp.alpha : alpha;                     value = newDepth < DepthC.ONE_PLY ? -qsearch(NodeTypeC.NonPV' pos' ss' ssPos + 1' -(alpha + 1)' -alpha' DepthC.DEPTH_ZERO)                                                : -search(NodeTypeC.NonPV' pos' ss' ssPos + 1' -(alpha + 1)' -alpha' newDepth);                 }                  // Only for PV nodes do a full PV search on the first move or after a fail                 // high' in the latter case search only if value < beta' otherwise let the                 // parent node to fail low with value <= alpha and to try another move.                 if (PvNode && (isPvMove || (value > alpha && (RootNode || value < beta))))                 {                     value = newDepth < DepthC.ONE_PLY ? -qsearch(NodeTypeC.PV' pos' ss' ssPos + 1' -beta' -alpha' DepthC.DEPTH_ZERO)                                                : -search(NodeTypeC.PV' pos' ss' ssPos + 1' -beta' -alpha' newDepth);                 }                  // Step 17. Undo move                 pos.undo_move(move);                  Debug.Assert(value > -ValueC.VALUE_INFINITE && value < ValueC.VALUE_INFINITE);                  // Step 18. Check for new best move                 if (SpNode)                 {                     ThreadHelper.lock_grab(sp.Lock);                     bestValue = sp.bestValue;                     alpha = sp.alpha;                 }                  // Finished searching the move. If Signals.stop is true' the search                 // was aborted because the user interrupted the search or because we                 // ran out of time. In this case' the return value of the search cannot                 // be trusted' and we don't update the best move and/or PV.                 if (RootNode && !SignalsStop)                 {                     int rmPos = find(RootMoves' 0' RootMoves.Count' move);                      // PV move or new best move ?                     if (isPvMove || value > alpha)                     {                         RootMoves[rmPos].score = value;                         RootMoves[rmPos].extract_pv_from_tt(pos);                          // We record how often the best move has been changed in each                         // iteration. This information is used for time management: When                         // the best move changes frequently' we allocate some more time.                         if (!isPvMove && MultiPV == 1)                             BestMoveChanges++;                     }                     else                         // All other moves but the PV are set to the lowest value' this                         // is not a problem when sorting becuase sort is stable and move                         // position in the list is preserved' just the PV is pushed up.                         RootMoves[rmPos].score = -ValueC.VALUE_INFINITE;                  }                  if (value > bestValue)                 {                     bestValue = value;                     bestMove = move;                      if (PvNode                         && value > alpha                         && value < beta) // We want always alpha < beta                         alpha = value;                      if (SpNode && !thisThread.cutoff_occurred())                     {                         sp.bestValue = value;                         sp.bestMove = move;                         sp.alpha = alpha;                          if (value >= beta)                             sp.cutoff = true;                     }                 }                  // Step 19. Check for split                 if (!SpNode                   && depth >= Threads.min_split_depth()                   && bestValue < beta                   && Threads.available_slave_exists(thisThread)                   && !SignalsStop                   && !thisThread.cutoff_occurred())                 {                     bestValue = Threads.split(Constants.FakeSplit' pos' ss' ssPos' alpha' beta' bestValue' ref bestMove' depth' threatMove' moveCount' mp' NT);                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,qsearch,The following statement contains a magic number: while (bestValue < beta                    && (move = mp.next_move()) != MoveC.MOVE_NONE)             {                 Debug.Assert(Utils.is_ok_M(move));                  givesCheck = pos.move_gives_check(move' ci);                  // Futility pruning                 if (!PvNode                     && !inCheck                     && !givesCheck                     && move != ttMove                     && enoughMaterial                     && ((move & (3 << 14)) != (1 << 14))                     && !pos.is_passed_pawn_push(move))                 {                     futilityValue = futilityBase                                    + Position.PieceValueEndgame[pos.board[move & 0x3F]]                                    + (((move & (3 << 14)) == (2 << 14)) ? Constants.PawnValueEndgame : ValueC.VALUE_ZERO);                      if (futilityValue < beta)                     {                         if (futilityValue > bestValue)                             bestValue = futilityValue;                          continue;                     }                      // Prune moves with negative or equal SEE                     if (futilityBase < beta                         && depth < DepthC.DEPTH_ZERO                         && pos.see(move' false) <= 0)                         continue;                 }                  // Detect non-capture evasions that are candidate to be pruned                 evasionPrunable = !PvNode                                  && inCheck                                  && bestValue > ValueC.VALUE_MATED_IN_MAX_PLY                                  && !(((pos.board[move & 0x3F] != PieceC.NO_PIECE) && !((move & (3 << 14)) == (3 << 14))) || ((move & (3 << 14)) == (2 << 14)))                                  && ((pos.st.castleRights & (CastleRightC.WHITE_ANY << (pos.sideToMove << 1))) == 0);                  // Don't search moves with negative SEE values                 if (!PvNode                     && move != ttMove                     && (!inCheck || evasionPrunable)                     && (move & (3 << 14)) != (1 << 14)                     && pos.see(move' true) < 0)                     continue;                  // Don't search useless checks                 if (!PvNode                     && !inCheck                     && givesCheck                     && move != ttMove                     && !(((move & (3 << 14)) != 0) ? ((move & (3 << 14)) != (3 << 14)) : (pos.board[move & 0x3F] != PieceC.NO_PIECE))                     && ss[ssPos].eval + Constants.PawnValueMidgame / 4 < beta                     && !check_is_dangerous(pos' move' futilityBase' beta))                     continue;                  // Check for legality only before to do the move                 if (!pos.pl_move_is_legal(move' ci.pinned))                     continue;                  ss[ssPos].currentMove = move;                  // Make and search the move                 if (st == null) { st = StateInfoBroker.GetObject(); }                 pos.do_move(move' st' ci' givesCheck);                 value = -qsearch(NT' pos' ss' ssPos + 1' -beta' -alpha' depth - DepthC.ONE_PLY);                 pos.undo_move(move);                  Debug.Assert(value > -ValueC.VALUE_INFINITE && value < ValueC.VALUE_INFINITE);                  // New best move?                 if (value > bestValue)                 {                     bestValue = value;                     bestMove = move;                      if (PvNode                         && value > alpha                         && value < beta) // We want always alpha < beta                         alpha = value;                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,qsearch,The following statement contains a magic number: while (bestValue < beta                    && (move = mp.next_move()) != MoveC.MOVE_NONE)             {                 Debug.Assert(Utils.is_ok_M(move));                  givesCheck = pos.move_gives_check(move' ci);                  // Futility pruning                 if (!PvNode                     && !inCheck                     && !givesCheck                     && move != ttMove                     && enoughMaterial                     && ((move & (3 << 14)) != (1 << 14))                     && !pos.is_passed_pawn_push(move))                 {                     futilityValue = futilityBase                                    + Position.PieceValueEndgame[pos.board[move & 0x3F]]                                    + (((move & (3 << 14)) == (2 << 14)) ? Constants.PawnValueEndgame : ValueC.VALUE_ZERO);                      if (futilityValue < beta)                     {                         if (futilityValue > bestValue)                             bestValue = futilityValue;                          continue;                     }                      // Prune moves with negative or equal SEE                     if (futilityBase < beta                         && depth < DepthC.DEPTH_ZERO                         && pos.see(move' false) <= 0)                         continue;                 }                  // Detect non-capture evasions that are candidate to be pruned                 evasionPrunable = !PvNode                                  && inCheck                                  && bestValue > ValueC.VALUE_MATED_IN_MAX_PLY                                  && !(((pos.board[move & 0x3F] != PieceC.NO_PIECE) && !((move & (3 << 14)) == (3 << 14))) || ((move & (3 << 14)) == (2 << 14)))                                  && ((pos.st.castleRights & (CastleRightC.WHITE_ANY << (pos.sideToMove << 1))) == 0);                  // Don't search moves with negative SEE values                 if (!PvNode                     && move != ttMove                     && (!inCheck || evasionPrunable)                     && (move & (3 << 14)) != (1 << 14)                     && pos.see(move' true) < 0)                     continue;                  // Don't search useless checks                 if (!PvNode                     && !inCheck                     && givesCheck                     && move != ttMove                     && !(((move & (3 << 14)) != 0) ? ((move & (3 << 14)) != (3 << 14)) : (pos.board[move & 0x3F] != PieceC.NO_PIECE))                     && ss[ssPos].eval + Constants.PawnValueMidgame / 4 < beta                     && !check_is_dangerous(pos' move' futilityBase' beta))                     continue;                  // Check for legality only before to do the move                 if (!pos.pl_move_is_legal(move' ci.pinned))                     continue;                  ss[ssPos].currentMove = move;                  // Make and search the move                 if (st == null) { st = StateInfoBroker.GetObject(); }                 pos.do_move(move' st' ci' givesCheck);                 value = -qsearch(NT' pos' ss' ssPos + 1' -beta' -alpha' depth - DepthC.ONE_PLY);                 pos.undo_move(move);                  Debug.Assert(value > -ValueC.VALUE_INFINITE && value < ValueC.VALUE_INFINITE);                  // New best move?                 if (value > bestValue)                 {                     bestValue = value;                     bestMove = move;                      if (PvNode                         && value > alpha                         && value < beta) // We want always alpha < beta                         alpha = value;                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,qsearch,The following statement contains a magic number: while (bestValue < beta                    && (move = mp.next_move()) != MoveC.MOVE_NONE)             {                 Debug.Assert(Utils.is_ok_M(move));                  givesCheck = pos.move_gives_check(move' ci);                  // Futility pruning                 if (!PvNode                     && !inCheck                     && !givesCheck                     && move != ttMove                     && enoughMaterial                     && ((move & (3 << 14)) != (1 << 14))                     && !pos.is_passed_pawn_push(move))                 {                     futilityValue = futilityBase                                    + Position.PieceValueEndgame[pos.board[move & 0x3F]]                                    + (((move & (3 << 14)) == (2 << 14)) ? Constants.PawnValueEndgame : ValueC.VALUE_ZERO);                      if (futilityValue < beta)                     {                         if (futilityValue > bestValue)                             bestValue = futilityValue;                          continue;                     }                      // Prune moves with negative or equal SEE                     if (futilityBase < beta                         && depth < DepthC.DEPTH_ZERO                         && pos.see(move' false) <= 0)                         continue;                 }                  // Detect non-capture evasions that are candidate to be pruned                 evasionPrunable = !PvNode                                  && inCheck                                  && bestValue > ValueC.VALUE_MATED_IN_MAX_PLY                                  && !(((pos.board[move & 0x3F] != PieceC.NO_PIECE) && !((move & (3 << 14)) == (3 << 14))) || ((move & (3 << 14)) == (2 << 14)))                                  && ((pos.st.castleRights & (CastleRightC.WHITE_ANY << (pos.sideToMove << 1))) == 0);                  // Don't search moves with negative SEE values                 if (!PvNode                     && move != ttMove                     && (!inCheck || evasionPrunable)                     && (move & (3 << 14)) != (1 << 14)                     && pos.see(move' true) < 0)                     continue;                  // Don't search useless checks                 if (!PvNode                     && !inCheck                     && givesCheck                     && move != ttMove                     && !(((move & (3 << 14)) != 0) ? ((move & (3 << 14)) != (3 << 14)) : (pos.board[move & 0x3F] != PieceC.NO_PIECE))                     && ss[ssPos].eval + Constants.PawnValueMidgame / 4 < beta                     && !check_is_dangerous(pos' move' futilityBase' beta))                     continue;                  // Check for legality only before to do the move                 if (!pos.pl_move_is_legal(move' ci.pinned))                     continue;                  ss[ssPos].currentMove = move;                  // Make and search the move                 if (st == null) { st = StateInfoBroker.GetObject(); }                 pos.do_move(move' st' ci' givesCheck);                 value = -qsearch(NT' pos' ss' ssPos + 1' -beta' -alpha' depth - DepthC.ONE_PLY);                 pos.undo_move(move);                  Debug.Assert(value > -ValueC.VALUE_INFINITE && value < ValueC.VALUE_INFINITE);                  // New best move?                 if (value > bestValue)                 {                     bestValue = value;                     bestMove = move;                      if (PvNode                         && value > alpha                         && value < beta) // We want always alpha < beta                         alpha = value;                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,qsearch,The following statement contains a magic number: while (bestValue < beta                    && (move = mp.next_move()) != MoveC.MOVE_NONE)             {                 Debug.Assert(Utils.is_ok_M(move));                  givesCheck = pos.move_gives_check(move' ci);                  // Futility pruning                 if (!PvNode                     && !inCheck                     && !givesCheck                     && move != ttMove                     && enoughMaterial                     && ((move & (3 << 14)) != (1 << 14))                     && !pos.is_passed_pawn_push(move))                 {                     futilityValue = futilityBase                                    + Position.PieceValueEndgame[pos.board[move & 0x3F]]                                    + (((move & (3 << 14)) == (2 << 14)) ? Constants.PawnValueEndgame : ValueC.VALUE_ZERO);                      if (futilityValue < beta)                     {                         if (futilityValue > bestValue)                             bestValue = futilityValue;                          continue;                     }                      // Prune moves with negative or equal SEE                     if (futilityBase < beta                         && depth < DepthC.DEPTH_ZERO                         && pos.see(move' false) <= 0)                         continue;                 }                  // Detect non-capture evasions that are candidate to be pruned                 evasionPrunable = !PvNode                                  && inCheck                                  && bestValue > ValueC.VALUE_MATED_IN_MAX_PLY                                  && !(((pos.board[move & 0x3F] != PieceC.NO_PIECE) && !((move & (3 << 14)) == (3 << 14))) || ((move & (3 << 14)) == (2 << 14)))                                  && ((pos.st.castleRights & (CastleRightC.WHITE_ANY << (pos.sideToMove << 1))) == 0);                  // Don't search moves with negative SEE values                 if (!PvNode                     && move != ttMove                     && (!inCheck || evasionPrunable)                     && (move & (3 << 14)) != (1 << 14)                     && pos.see(move' true) < 0)                     continue;                  // Don't search useless checks                 if (!PvNode                     && !inCheck                     && givesCheck                     && move != ttMove                     && !(((move & (3 << 14)) != 0) ? ((move & (3 << 14)) != (3 << 14)) : (pos.board[move & 0x3F] != PieceC.NO_PIECE))                     && ss[ssPos].eval + Constants.PawnValueMidgame / 4 < beta                     && !check_is_dangerous(pos' move' futilityBase' beta))                     continue;                  // Check for legality only before to do the move                 if (!pos.pl_move_is_legal(move' ci.pinned))                     continue;                  ss[ssPos].currentMove = move;                  // Make and search the move                 if (st == null) { st = StateInfoBroker.GetObject(); }                 pos.do_move(move' st' ci' givesCheck);                 value = -qsearch(NT' pos' ss' ssPos + 1' -beta' -alpha' depth - DepthC.ONE_PLY);                 pos.undo_move(move);                  Debug.Assert(value > -ValueC.VALUE_INFINITE && value < ValueC.VALUE_INFINITE);                  // New best move?                 if (value > bestValue)                 {                     bestValue = value;                     bestMove = move;                      if (PvNode                         && value > alpha                         && value < beta) // We want always alpha < beta                         alpha = value;                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,qsearch,The following statement contains a magic number: while (bestValue < beta                    && (move = mp.next_move()) != MoveC.MOVE_NONE)             {                 Debug.Assert(Utils.is_ok_M(move));                  givesCheck = pos.move_gives_check(move' ci);                  // Futility pruning                 if (!PvNode                     && !inCheck                     && !givesCheck                     && move != ttMove                     && enoughMaterial                     && ((move & (3 << 14)) != (1 << 14))                     && !pos.is_passed_pawn_push(move))                 {                     futilityValue = futilityBase                                    + Position.PieceValueEndgame[pos.board[move & 0x3F]]                                    + (((move & (3 << 14)) == (2 << 14)) ? Constants.PawnValueEndgame : ValueC.VALUE_ZERO);                      if (futilityValue < beta)                     {                         if (futilityValue > bestValue)                             bestValue = futilityValue;                          continue;                     }                      // Prune moves with negative or equal SEE                     if (futilityBase < beta                         && depth < DepthC.DEPTH_ZERO                         && pos.see(move' false) <= 0)                         continue;                 }                  // Detect non-capture evasions that are candidate to be pruned                 evasionPrunable = !PvNode                                  && inCheck                                  && bestValue > ValueC.VALUE_MATED_IN_MAX_PLY                                  && !(((pos.board[move & 0x3F] != PieceC.NO_PIECE) && !((move & (3 << 14)) == (3 << 14))) || ((move & (3 << 14)) == (2 << 14)))                                  && ((pos.st.castleRights & (CastleRightC.WHITE_ANY << (pos.sideToMove << 1))) == 0);                  // Don't search moves with negative SEE values                 if (!PvNode                     && move != ttMove                     && (!inCheck || evasionPrunable)                     && (move & (3 << 14)) != (1 << 14)                     && pos.see(move' true) < 0)                     continue;                  // Don't search useless checks                 if (!PvNode                     && !inCheck                     && givesCheck                     && move != ttMove                     && !(((move & (3 << 14)) != 0) ? ((move & (3 << 14)) != (3 << 14)) : (pos.board[move & 0x3F] != PieceC.NO_PIECE))                     && ss[ssPos].eval + Constants.PawnValueMidgame / 4 < beta                     && !check_is_dangerous(pos' move' futilityBase' beta))                     continue;                  // Check for legality only before to do the move                 if (!pos.pl_move_is_legal(move' ci.pinned))                     continue;                  ss[ssPos].currentMove = move;                  // Make and search the move                 if (st == null) { st = StateInfoBroker.GetObject(); }                 pos.do_move(move' st' ci' givesCheck);                 value = -qsearch(NT' pos' ss' ssPos + 1' -beta' -alpha' depth - DepthC.ONE_PLY);                 pos.undo_move(move);                  Debug.Assert(value > -ValueC.VALUE_INFINITE && value < ValueC.VALUE_INFINITE);                  // New best move?                 if (value > bestValue)                 {                     bestValue = value;                     bestMove = move;                      if (PvNode                         && value > alpha                         && value < beta) // We want always alpha < beta                         alpha = value;                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,qsearch,The following statement contains a magic number: while (bestValue < beta                    && (move = mp.next_move()) != MoveC.MOVE_NONE)             {                 Debug.Assert(Utils.is_ok_M(move));                  givesCheck = pos.move_gives_check(move' ci);                  // Futility pruning                 if (!PvNode                     && !inCheck                     && !givesCheck                     && move != ttMove                     && enoughMaterial                     && ((move & (3 << 14)) != (1 << 14))                     && !pos.is_passed_pawn_push(move))                 {                     futilityValue = futilityBase                                    + Position.PieceValueEndgame[pos.board[move & 0x3F]]                                    + (((move & (3 << 14)) == (2 << 14)) ? Constants.PawnValueEndgame : ValueC.VALUE_ZERO);                      if (futilityValue < beta)                     {                         if (futilityValue > bestValue)                             bestValue = futilityValue;                          continue;                     }                      // Prune moves with negative or equal SEE                     if (futilityBase < beta                         && depth < DepthC.DEPTH_ZERO                         && pos.see(move' false) <= 0)                         continue;                 }                  // Detect non-capture evasions that are candidate to be pruned                 evasionPrunable = !PvNode                                  && inCheck                                  && bestValue > ValueC.VALUE_MATED_IN_MAX_PLY                                  && !(((pos.board[move & 0x3F] != PieceC.NO_PIECE) && !((move & (3 << 14)) == (3 << 14))) || ((move & (3 << 14)) == (2 << 14)))                                  && ((pos.st.castleRights & (CastleRightC.WHITE_ANY << (pos.sideToMove << 1))) == 0);                  // Don't search moves with negative SEE values                 if (!PvNode                     && move != ttMove                     && (!inCheck || evasionPrunable)                     && (move & (3 << 14)) != (1 << 14)                     && pos.see(move' true) < 0)                     continue;                  // Don't search useless checks                 if (!PvNode                     && !inCheck                     && givesCheck                     && move != ttMove                     && !(((move & (3 << 14)) != 0) ? ((move & (3 << 14)) != (3 << 14)) : (pos.board[move & 0x3F] != PieceC.NO_PIECE))                     && ss[ssPos].eval + Constants.PawnValueMidgame / 4 < beta                     && !check_is_dangerous(pos' move' futilityBase' beta))                     continue;                  // Check for legality only before to do the move                 if (!pos.pl_move_is_legal(move' ci.pinned))                     continue;                  ss[ssPos].currentMove = move;                  // Make and search the move                 if (st == null) { st = StateInfoBroker.GetObject(); }                 pos.do_move(move' st' ci' givesCheck);                 value = -qsearch(NT' pos' ss' ssPos + 1' -beta' -alpha' depth - DepthC.ONE_PLY);                 pos.undo_move(move);                  Debug.Assert(value > -ValueC.VALUE_INFINITE && value < ValueC.VALUE_INFINITE);                  // New best move?                 if (value > bestValue)                 {                     bestValue = value;                     bestMove = move;                      if (PvNode                         && value > alpha                         && value < beta) // We want always alpha < beta                         alpha = value;                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,qsearch,The following statement contains a magic number: while (bestValue < beta                    && (move = mp.next_move()) != MoveC.MOVE_NONE)             {                 Debug.Assert(Utils.is_ok_M(move));                  givesCheck = pos.move_gives_check(move' ci);                  // Futility pruning                 if (!PvNode                     && !inCheck                     && !givesCheck                     && move != ttMove                     && enoughMaterial                     && ((move & (3 << 14)) != (1 << 14))                     && !pos.is_passed_pawn_push(move))                 {                     futilityValue = futilityBase                                    + Position.PieceValueEndgame[pos.board[move & 0x3F]]                                    + (((move & (3 << 14)) == (2 << 14)) ? Constants.PawnValueEndgame : ValueC.VALUE_ZERO);                      if (futilityValue < beta)                     {                         if (futilityValue > bestValue)                             bestValue = futilityValue;                          continue;                     }                      // Prune moves with negative or equal SEE                     if (futilityBase < beta                         && depth < DepthC.DEPTH_ZERO                         && pos.see(move' false) <= 0)                         continue;                 }                  // Detect non-capture evasions that are candidate to be pruned                 evasionPrunable = !PvNode                                  && inCheck                                  && bestValue > ValueC.VALUE_MATED_IN_MAX_PLY                                  && !(((pos.board[move & 0x3F] != PieceC.NO_PIECE) && !((move & (3 << 14)) == (3 << 14))) || ((move & (3 << 14)) == (2 << 14)))                                  && ((pos.st.castleRights & (CastleRightC.WHITE_ANY << (pos.sideToMove << 1))) == 0);                  // Don't search moves with negative SEE values                 if (!PvNode                     && move != ttMove                     && (!inCheck || evasionPrunable)                     && (move & (3 << 14)) != (1 << 14)                     && pos.see(move' true) < 0)                     continue;                  // Don't search useless checks                 if (!PvNode                     && !inCheck                     && givesCheck                     && move != ttMove                     && !(((move & (3 << 14)) != 0) ? ((move & (3 << 14)) != (3 << 14)) : (pos.board[move & 0x3F] != PieceC.NO_PIECE))                     && ss[ssPos].eval + Constants.PawnValueMidgame / 4 < beta                     && !check_is_dangerous(pos' move' futilityBase' beta))                     continue;                  // Check for legality only before to do the move                 if (!pos.pl_move_is_legal(move' ci.pinned))                     continue;                  ss[ssPos].currentMove = move;                  // Make and search the move                 if (st == null) { st = StateInfoBroker.GetObject(); }                 pos.do_move(move' st' ci' givesCheck);                 value = -qsearch(NT' pos' ss' ssPos + 1' -beta' -alpha' depth - DepthC.ONE_PLY);                 pos.undo_move(move);                  Debug.Assert(value > -ValueC.VALUE_INFINITE && value < ValueC.VALUE_INFINITE);                  // New best move?                 if (value > bestValue)                 {                     bestValue = value;                     bestMove = move;                      if (PvNode                         && value > alpha                         && value < beta) // We want always alpha < beta                         alpha = value;                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,qsearch,The following statement contains a magic number: while (bestValue < beta                    && (move = mp.next_move()) != MoveC.MOVE_NONE)             {                 Debug.Assert(Utils.is_ok_M(move));                  givesCheck = pos.move_gives_check(move' ci);                  // Futility pruning                 if (!PvNode                     && !inCheck                     && !givesCheck                     && move != ttMove                     && enoughMaterial                     && ((move & (3 << 14)) != (1 << 14))                     && !pos.is_passed_pawn_push(move))                 {                     futilityValue = futilityBase                                    + Position.PieceValueEndgame[pos.board[move & 0x3F]]                                    + (((move & (3 << 14)) == (2 << 14)) ? Constants.PawnValueEndgame : ValueC.VALUE_ZERO);                      if (futilityValue < beta)                     {                         if (futilityValue > bestValue)                             bestValue = futilityValue;                          continue;                     }                      // Prune moves with negative or equal SEE                     if (futilityBase < beta                         && depth < DepthC.DEPTH_ZERO                         && pos.see(move' false) <= 0)                         continue;                 }                  // Detect non-capture evasions that are candidate to be pruned                 evasionPrunable = !PvNode                                  && inCheck                                  && bestValue > ValueC.VALUE_MATED_IN_MAX_PLY                                  && !(((pos.board[move & 0x3F] != PieceC.NO_PIECE) && !((move & (3 << 14)) == (3 << 14))) || ((move & (3 << 14)) == (2 << 14)))                                  && ((pos.st.castleRights & (CastleRightC.WHITE_ANY << (pos.sideToMove << 1))) == 0);                  // Don't search moves with negative SEE values                 if (!PvNode                     && move != ttMove                     && (!inCheck || evasionPrunable)                     && (move & (3 << 14)) != (1 << 14)                     && pos.see(move' true) < 0)                     continue;                  // Don't search useless checks                 if (!PvNode                     && !inCheck                     && givesCheck                     && move != ttMove                     && !(((move & (3 << 14)) != 0) ? ((move & (3 << 14)) != (3 << 14)) : (pos.board[move & 0x3F] != PieceC.NO_PIECE))                     && ss[ssPos].eval + Constants.PawnValueMidgame / 4 < beta                     && !check_is_dangerous(pos' move' futilityBase' beta))                     continue;                  // Check for legality only before to do the move                 if (!pos.pl_move_is_legal(move' ci.pinned))                     continue;                  ss[ssPos].currentMove = move;                  // Make and search the move                 if (st == null) { st = StateInfoBroker.GetObject(); }                 pos.do_move(move' st' ci' givesCheck);                 value = -qsearch(NT' pos' ss' ssPos + 1' -beta' -alpha' depth - DepthC.ONE_PLY);                 pos.undo_move(move);                  Debug.Assert(value > -ValueC.VALUE_INFINITE && value < ValueC.VALUE_INFINITE);                  // New best move?                 if (value > bestValue)                 {                     bestValue = value;                     bestMove = move;                      if (PvNode                         && value > alpha                         && value < beta) // We want always alpha < beta                         alpha = value;                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,qsearch,The following statement contains a magic number: while (bestValue < beta                    && (move = mp.next_move()) != MoveC.MOVE_NONE)             {                 Debug.Assert(Utils.is_ok_M(move));                  givesCheck = pos.move_gives_check(move' ci);                  // Futility pruning                 if (!PvNode                     && !inCheck                     && !givesCheck                     && move != ttMove                     && enoughMaterial                     && ((move & (3 << 14)) != (1 << 14))                     && !pos.is_passed_pawn_push(move))                 {                     futilityValue = futilityBase                                    + Position.PieceValueEndgame[pos.board[move & 0x3F]]                                    + (((move & (3 << 14)) == (2 << 14)) ? Constants.PawnValueEndgame : ValueC.VALUE_ZERO);                      if (futilityValue < beta)                     {                         if (futilityValue > bestValue)                             bestValue = futilityValue;                          continue;                     }                      // Prune moves with negative or equal SEE                     if (futilityBase < beta                         && depth < DepthC.DEPTH_ZERO                         && pos.see(move' false) <= 0)                         continue;                 }                  // Detect non-capture evasions that are candidate to be pruned                 evasionPrunable = !PvNode                                  && inCheck                                  && bestValue > ValueC.VALUE_MATED_IN_MAX_PLY                                  && !(((pos.board[move & 0x3F] != PieceC.NO_PIECE) && !((move & (3 << 14)) == (3 << 14))) || ((move & (3 << 14)) == (2 << 14)))                                  && ((pos.st.castleRights & (CastleRightC.WHITE_ANY << (pos.sideToMove << 1))) == 0);                  // Don't search moves with negative SEE values                 if (!PvNode                     && move != ttMove                     && (!inCheck || evasionPrunable)                     && (move & (3 << 14)) != (1 << 14)                     && pos.see(move' true) < 0)                     continue;                  // Don't search useless checks                 if (!PvNode                     && !inCheck                     && givesCheck                     && move != ttMove                     && !(((move & (3 << 14)) != 0) ? ((move & (3 << 14)) != (3 << 14)) : (pos.board[move & 0x3F] != PieceC.NO_PIECE))                     && ss[ssPos].eval + Constants.PawnValueMidgame / 4 < beta                     && !check_is_dangerous(pos' move' futilityBase' beta))                     continue;                  // Check for legality only before to do the move                 if (!pos.pl_move_is_legal(move' ci.pinned))                     continue;                  ss[ssPos].currentMove = move;                  // Make and search the move                 if (st == null) { st = StateInfoBroker.GetObject(); }                 pos.do_move(move' st' ci' givesCheck);                 value = -qsearch(NT' pos' ss' ssPos + 1' -beta' -alpha' depth - DepthC.ONE_PLY);                 pos.undo_move(move);                  Debug.Assert(value > -ValueC.VALUE_INFINITE && value < ValueC.VALUE_INFINITE);                  // New best move?                 if (value > bestValue)                 {                     bestValue = value;                     bestMove = move;                      if (PvNode                         && value > alpha                         && value < beta) // We want always alpha < beta                         alpha = value;                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,qsearch,The following statement contains a magic number: while (bestValue < beta                    && (move = mp.next_move()) != MoveC.MOVE_NONE)             {                 Debug.Assert(Utils.is_ok_M(move));                  givesCheck = pos.move_gives_check(move' ci);                  // Futility pruning                 if (!PvNode                     && !inCheck                     && !givesCheck                     && move != ttMove                     && enoughMaterial                     && ((move & (3 << 14)) != (1 << 14))                     && !pos.is_passed_pawn_push(move))                 {                     futilityValue = futilityBase                                    + Position.PieceValueEndgame[pos.board[move & 0x3F]]                                    + (((move & (3 << 14)) == (2 << 14)) ? Constants.PawnValueEndgame : ValueC.VALUE_ZERO);                      if (futilityValue < beta)                     {                         if (futilityValue > bestValue)                             bestValue = futilityValue;                          continue;                     }                      // Prune moves with negative or equal SEE                     if (futilityBase < beta                         && depth < DepthC.DEPTH_ZERO                         && pos.see(move' false) <= 0)                         continue;                 }                  // Detect non-capture evasions that are candidate to be pruned                 evasionPrunable = !PvNode                                  && inCheck                                  && bestValue > ValueC.VALUE_MATED_IN_MAX_PLY                                  && !(((pos.board[move & 0x3F] != PieceC.NO_PIECE) && !((move & (3 << 14)) == (3 << 14))) || ((move & (3 << 14)) == (2 << 14)))                                  && ((pos.st.castleRights & (CastleRightC.WHITE_ANY << (pos.sideToMove << 1))) == 0);                  // Don't search moves with negative SEE values                 if (!PvNode                     && move != ttMove                     && (!inCheck || evasionPrunable)                     && (move & (3 << 14)) != (1 << 14)                     && pos.see(move' true) < 0)                     continue;                  // Don't search useless checks                 if (!PvNode                     && !inCheck                     && givesCheck                     && move != ttMove                     && !(((move & (3 << 14)) != 0) ? ((move & (3 << 14)) != (3 << 14)) : (pos.board[move & 0x3F] != PieceC.NO_PIECE))                     && ss[ssPos].eval + Constants.PawnValueMidgame / 4 < beta                     && !check_is_dangerous(pos' move' futilityBase' beta))                     continue;                  // Check for legality only before to do the move                 if (!pos.pl_move_is_legal(move' ci.pinned))                     continue;                  ss[ssPos].currentMove = move;                  // Make and search the move                 if (st == null) { st = StateInfoBroker.GetObject(); }                 pos.do_move(move' st' ci' givesCheck);                 value = -qsearch(NT' pos' ss' ssPos + 1' -beta' -alpha' depth - DepthC.ONE_PLY);                 pos.undo_move(move);                  Debug.Assert(value > -ValueC.VALUE_INFINITE && value < ValueC.VALUE_INFINITE);                  // New best move?                 if (value > bestValue)                 {                     bestValue = value;                     bestMove = move;                      if (PvNode                         && value > alpha                         && value < beta) // We want always alpha < beta                         alpha = value;                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,qsearch,The following statement contains a magic number: while (bestValue < beta                    && (move = mp.next_move()) != MoveC.MOVE_NONE)             {                 Debug.Assert(Utils.is_ok_M(move));                  givesCheck = pos.move_gives_check(move' ci);                  // Futility pruning                 if (!PvNode                     && !inCheck                     && !givesCheck                     && move != ttMove                     && enoughMaterial                     && ((move & (3 << 14)) != (1 << 14))                     && !pos.is_passed_pawn_push(move))                 {                     futilityValue = futilityBase                                    + Position.PieceValueEndgame[pos.board[move & 0x3F]]                                    + (((move & (3 << 14)) == (2 << 14)) ? Constants.PawnValueEndgame : ValueC.VALUE_ZERO);                      if (futilityValue < beta)                     {                         if (futilityValue > bestValue)                             bestValue = futilityValue;                          continue;                     }                      // Prune moves with negative or equal SEE                     if (futilityBase < beta                         && depth < DepthC.DEPTH_ZERO                         && pos.see(move' false) <= 0)                         continue;                 }                  // Detect non-capture evasions that are candidate to be pruned                 evasionPrunable = !PvNode                                  && inCheck                                  && bestValue > ValueC.VALUE_MATED_IN_MAX_PLY                                  && !(((pos.board[move & 0x3F] != PieceC.NO_PIECE) && !((move & (3 << 14)) == (3 << 14))) || ((move & (3 << 14)) == (2 << 14)))                                  && ((pos.st.castleRights & (CastleRightC.WHITE_ANY << (pos.sideToMove << 1))) == 0);                  // Don't search moves with negative SEE values                 if (!PvNode                     && move != ttMove                     && (!inCheck || evasionPrunable)                     && (move & (3 << 14)) != (1 << 14)                     && pos.see(move' true) < 0)                     continue;                  // Don't search useless checks                 if (!PvNode                     && !inCheck                     && givesCheck                     && move != ttMove                     && !(((move & (3 << 14)) != 0) ? ((move & (3 << 14)) != (3 << 14)) : (pos.board[move & 0x3F] != PieceC.NO_PIECE))                     && ss[ssPos].eval + Constants.PawnValueMidgame / 4 < beta                     && !check_is_dangerous(pos' move' futilityBase' beta))                     continue;                  // Check for legality only before to do the move                 if (!pos.pl_move_is_legal(move' ci.pinned))                     continue;                  ss[ssPos].currentMove = move;                  // Make and search the move                 if (st == null) { st = StateInfoBroker.GetObject(); }                 pos.do_move(move' st' ci' givesCheck);                 value = -qsearch(NT' pos' ss' ssPos + 1' -beta' -alpha' depth - DepthC.ONE_PLY);                 pos.undo_move(move);                  Debug.Assert(value > -ValueC.VALUE_INFINITE && value < ValueC.VALUE_INFINITE);                  // New best move?                 if (value > bestValue)                 {                     bestValue = value;                     bestMove = move;                      if (PvNode                         && value > alpha                         && value < beta) // We want always alpha < beta                         alpha = value;                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,qsearch,The following statement contains a magic number: while (bestValue < beta                    && (move = mp.next_move()) != MoveC.MOVE_NONE)             {                 Debug.Assert(Utils.is_ok_M(move));                  givesCheck = pos.move_gives_check(move' ci);                  // Futility pruning                 if (!PvNode                     && !inCheck                     && !givesCheck                     && move != ttMove                     && enoughMaterial                     && ((move & (3 << 14)) != (1 << 14))                     && !pos.is_passed_pawn_push(move))                 {                     futilityValue = futilityBase                                    + Position.PieceValueEndgame[pos.board[move & 0x3F]]                                    + (((move & (3 << 14)) == (2 << 14)) ? Constants.PawnValueEndgame : ValueC.VALUE_ZERO);                      if (futilityValue < beta)                     {                         if (futilityValue > bestValue)                             bestValue = futilityValue;                          continue;                     }                      // Prune moves with negative or equal SEE                     if (futilityBase < beta                         && depth < DepthC.DEPTH_ZERO                         && pos.see(move' false) <= 0)                         continue;                 }                  // Detect non-capture evasions that are candidate to be pruned                 evasionPrunable = !PvNode                                  && inCheck                                  && bestValue > ValueC.VALUE_MATED_IN_MAX_PLY                                  && !(((pos.board[move & 0x3F] != PieceC.NO_PIECE) && !((move & (3 << 14)) == (3 << 14))) || ((move & (3 << 14)) == (2 << 14)))                                  && ((pos.st.castleRights & (CastleRightC.WHITE_ANY << (pos.sideToMove << 1))) == 0);                  // Don't search moves with negative SEE values                 if (!PvNode                     && move != ttMove                     && (!inCheck || evasionPrunable)                     && (move & (3 << 14)) != (1 << 14)                     && pos.see(move' true) < 0)                     continue;                  // Don't search useless checks                 if (!PvNode                     && !inCheck                     && givesCheck                     && move != ttMove                     && !(((move & (3 << 14)) != 0) ? ((move & (3 << 14)) != (3 << 14)) : (pos.board[move & 0x3F] != PieceC.NO_PIECE))                     && ss[ssPos].eval + Constants.PawnValueMidgame / 4 < beta                     && !check_is_dangerous(pos' move' futilityBase' beta))                     continue;                  // Check for legality only before to do the move                 if (!pos.pl_move_is_legal(move' ci.pinned))                     continue;                  ss[ssPos].currentMove = move;                  // Make and search the move                 if (st == null) { st = StateInfoBroker.GetObject(); }                 pos.do_move(move' st' ci' givesCheck);                 value = -qsearch(NT' pos' ss' ssPos + 1' -beta' -alpha' depth - DepthC.ONE_PLY);                 pos.undo_move(move);                  Debug.Assert(value > -ValueC.VALUE_INFINITE && value < ValueC.VALUE_INFINITE);                  // New best move?                 if (value > bestValue)                 {                     bestValue = value;                     bestMove = move;                      if (PvNode                         && value > alpha                         && value < beta) // We want always alpha < beta                         alpha = value;                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,qsearch,The following statement contains a magic number: while (bestValue < beta                    && (move = mp.next_move()) != MoveC.MOVE_NONE)             {                 Debug.Assert(Utils.is_ok_M(move));                  givesCheck = pos.move_gives_check(move' ci);                  // Futility pruning                 if (!PvNode                     && !inCheck                     && !givesCheck                     && move != ttMove                     && enoughMaterial                     && ((move & (3 << 14)) != (1 << 14))                     && !pos.is_passed_pawn_push(move))                 {                     futilityValue = futilityBase                                    + Position.PieceValueEndgame[pos.board[move & 0x3F]]                                    + (((move & (3 << 14)) == (2 << 14)) ? Constants.PawnValueEndgame : ValueC.VALUE_ZERO);                      if (futilityValue < beta)                     {                         if (futilityValue > bestValue)                             bestValue = futilityValue;                          continue;                     }                      // Prune moves with negative or equal SEE                     if (futilityBase < beta                         && depth < DepthC.DEPTH_ZERO                         && pos.see(move' false) <= 0)                         continue;                 }                  // Detect non-capture evasions that are candidate to be pruned                 evasionPrunable = !PvNode                                  && inCheck                                  && bestValue > ValueC.VALUE_MATED_IN_MAX_PLY                                  && !(((pos.board[move & 0x3F] != PieceC.NO_PIECE) && !((move & (3 << 14)) == (3 << 14))) || ((move & (3 << 14)) == (2 << 14)))                                  && ((pos.st.castleRights & (CastleRightC.WHITE_ANY << (pos.sideToMove << 1))) == 0);                  // Don't search moves with negative SEE values                 if (!PvNode                     && move != ttMove                     && (!inCheck || evasionPrunable)                     && (move & (3 << 14)) != (1 << 14)                     && pos.see(move' true) < 0)                     continue;                  // Don't search useless checks                 if (!PvNode                     && !inCheck                     && givesCheck                     && move != ttMove                     && !(((move & (3 << 14)) != 0) ? ((move & (3 << 14)) != (3 << 14)) : (pos.board[move & 0x3F] != PieceC.NO_PIECE))                     && ss[ssPos].eval + Constants.PawnValueMidgame / 4 < beta                     && !check_is_dangerous(pos' move' futilityBase' beta))                     continue;                  // Check for legality only before to do the move                 if (!pos.pl_move_is_legal(move' ci.pinned))                     continue;                  ss[ssPos].currentMove = move;                  // Make and search the move                 if (st == null) { st = StateInfoBroker.GetObject(); }                 pos.do_move(move' st' ci' givesCheck);                 value = -qsearch(NT' pos' ss' ssPos + 1' -beta' -alpha' depth - DepthC.ONE_PLY);                 pos.undo_move(move);                  Debug.Assert(value > -ValueC.VALUE_INFINITE && value < ValueC.VALUE_INFINITE);                  // New best move?                 if (value > bestValue)                 {                     bestValue = value;                     bestMove = move;                      if (PvNode                         && value > alpha                         && value < beta) // We want always alpha < beta                         alpha = value;                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,qsearch,The following statement contains a magic number: while (bestValue < beta                    && (move = mp.next_move()) != MoveC.MOVE_NONE)             {                 Debug.Assert(Utils.is_ok_M(move));                  givesCheck = pos.move_gives_check(move' ci);                  // Futility pruning                 if (!PvNode                     && !inCheck                     && !givesCheck                     && move != ttMove                     && enoughMaterial                     && ((move & (3 << 14)) != (1 << 14))                     && !pos.is_passed_pawn_push(move))                 {                     futilityValue = futilityBase                                    + Position.PieceValueEndgame[pos.board[move & 0x3F]]                                    + (((move & (3 << 14)) == (2 << 14)) ? Constants.PawnValueEndgame : ValueC.VALUE_ZERO);                      if (futilityValue < beta)                     {                         if (futilityValue > bestValue)                             bestValue = futilityValue;                          continue;                     }                      // Prune moves with negative or equal SEE                     if (futilityBase < beta                         && depth < DepthC.DEPTH_ZERO                         && pos.see(move' false) <= 0)                         continue;                 }                  // Detect non-capture evasions that are candidate to be pruned                 evasionPrunable = !PvNode                                  && inCheck                                  && bestValue > ValueC.VALUE_MATED_IN_MAX_PLY                                  && !(((pos.board[move & 0x3F] != PieceC.NO_PIECE) && !((move & (3 << 14)) == (3 << 14))) || ((move & (3 << 14)) == (2 << 14)))                                  && ((pos.st.castleRights & (CastleRightC.WHITE_ANY << (pos.sideToMove << 1))) == 0);                  // Don't search moves with negative SEE values                 if (!PvNode                     && move != ttMove                     && (!inCheck || evasionPrunable)                     && (move & (3 << 14)) != (1 << 14)                     && pos.see(move' true) < 0)                     continue;                  // Don't search useless checks                 if (!PvNode                     && !inCheck                     && givesCheck                     && move != ttMove                     && !(((move & (3 << 14)) != 0) ? ((move & (3 << 14)) != (3 << 14)) : (pos.board[move & 0x3F] != PieceC.NO_PIECE))                     && ss[ssPos].eval + Constants.PawnValueMidgame / 4 < beta                     && !check_is_dangerous(pos' move' futilityBase' beta))                     continue;                  // Check for legality only before to do the move                 if (!pos.pl_move_is_legal(move' ci.pinned))                     continue;                  ss[ssPos].currentMove = move;                  // Make and search the move                 if (st == null) { st = StateInfoBroker.GetObject(); }                 pos.do_move(move' st' ci' givesCheck);                 value = -qsearch(NT' pos' ss' ssPos + 1' -beta' -alpha' depth - DepthC.ONE_PLY);                 pos.undo_move(move);                  Debug.Assert(value > -ValueC.VALUE_INFINITE && value < ValueC.VALUE_INFINITE);                  // New best move?                 if (value > bestValue)                 {                     bestValue = value;                     bestMove = move;                      if (PvNode                         && value > alpha                         && value < beta) // We want always alpha < beta                         alpha = value;                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,qsearch,The following statement contains a magic number: while (bestValue < beta                    && (move = mp.next_move()) != MoveC.MOVE_NONE)             {                 Debug.Assert(Utils.is_ok_M(move));                  givesCheck = pos.move_gives_check(move' ci);                  // Futility pruning                 if (!PvNode                     && !inCheck                     && !givesCheck                     && move != ttMove                     && enoughMaterial                     && ((move & (3 << 14)) != (1 << 14))                     && !pos.is_passed_pawn_push(move))                 {                     futilityValue = futilityBase                                    + Position.PieceValueEndgame[pos.board[move & 0x3F]]                                    + (((move & (3 << 14)) == (2 << 14)) ? Constants.PawnValueEndgame : ValueC.VALUE_ZERO);                      if (futilityValue < beta)                     {                         if (futilityValue > bestValue)                             bestValue = futilityValue;                          continue;                     }                      // Prune moves with negative or equal SEE                     if (futilityBase < beta                         && depth < DepthC.DEPTH_ZERO                         && pos.see(move' false) <= 0)                         continue;                 }                  // Detect non-capture evasions that are candidate to be pruned                 evasionPrunable = !PvNode                                  && inCheck                                  && bestValue > ValueC.VALUE_MATED_IN_MAX_PLY                                  && !(((pos.board[move & 0x3F] != PieceC.NO_PIECE) && !((move & (3 << 14)) == (3 << 14))) || ((move & (3 << 14)) == (2 << 14)))                                  && ((pos.st.castleRights & (CastleRightC.WHITE_ANY << (pos.sideToMove << 1))) == 0);                  // Don't search moves with negative SEE values                 if (!PvNode                     && move != ttMove                     && (!inCheck || evasionPrunable)                     && (move & (3 << 14)) != (1 << 14)                     && pos.see(move' true) < 0)                     continue;                  // Don't search useless checks                 if (!PvNode                     && !inCheck                     && givesCheck                     && move != ttMove                     && !(((move & (3 << 14)) != 0) ? ((move & (3 << 14)) != (3 << 14)) : (pos.board[move & 0x3F] != PieceC.NO_PIECE))                     && ss[ssPos].eval + Constants.PawnValueMidgame / 4 < beta                     && !check_is_dangerous(pos' move' futilityBase' beta))                     continue;                  // Check for legality only before to do the move                 if (!pos.pl_move_is_legal(move' ci.pinned))                     continue;                  ss[ssPos].currentMove = move;                  // Make and search the move                 if (st == null) { st = StateInfoBroker.GetObject(); }                 pos.do_move(move' st' ci' givesCheck);                 value = -qsearch(NT' pos' ss' ssPos + 1' -beta' -alpha' depth - DepthC.ONE_PLY);                 pos.undo_move(move);                  Debug.Assert(value > -ValueC.VALUE_INFINITE && value < ValueC.VALUE_INFINITE);                  // New best move?                 if (value > bestValue)                 {                     bestValue = value;                     bestMove = move;                      if (PvNode                         && value > alpha                         && value < beta) // We want always alpha < beta                         alpha = value;                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,qsearch,The following statement contains a magic number: while (bestValue < beta                    && (move = mp.next_move()) != MoveC.MOVE_NONE)             {                 Debug.Assert(Utils.is_ok_M(move));                  givesCheck = pos.move_gives_check(move' ci);                  // Futility pruning                 if (!PvNode                     && !inCheck                     && !givesCheck                     && move != ttMove                     && enoughMaterial                     && ((move & (3 << 14)) != (1 << 14))                     && !pos.is_passed_pawn_push(move))                 {                     futilityValue = futilityBase                                    + Position.PieceValueEndgame[pos.board[move & 0x3F]]                                    + (((move & (3 << 14)) == (2 << 14)) ? Constants.PawnValueEndgame : ValueC.VALUE_ZERO);                      if (futilityValue < beta)                     {                         if (futilityValue > bestValue)                             bestValue = futilityValue;                          continue;                     }                      // Prune moves with negative or equal SEE                     if (futilityBase < beta                         && depth < DepthC.DEPTH_ZERO                         && pos.see(move' false) <= 0)                         continue;                 }                  // Detect non-capture evasions that are candidate to be pruned                 evasionPrunable = !PvNode                                  && inCheck                                  && bestValue > ValueC.VALUE_MATED_IN_MAX_PLY                                  && !(((pos.board[move & 0x3F] != PieceC.NO_PIECE) && !((move & (3 << 14)) == (3 << 14))) || ((move & (3 << 14)) == (2 << 14)))                                  && ((pos.st.castleRights & (CastleRightC.WHITE_ANY << (pos.sideToMove << 1))) == 0);                  // Don't search moves with negative SEE values                 if (!PvNode                     && move != ttMove                     && (!inCheck || evasionPrunable)                     && (move & (3 << 14)) != (1 << 14)                     && pos.see(move' true) < 0)                     continue;                  // Don't search useless checks                 if (!PvNode                     && !inCheck                     && givesCheck                     && move != ttMove                     && !(((move & (3 << 14)) != 0) ? ((move & (3 << 14)) != (3 << 14)) : (pos.board[move & 0x3F] != PieceC.NO_PIECE))                     && ss[ssPos].eval + Constants.PawnValueMidgame / 4 < beta                     && !check_is_dangerous(pos' move' futilityBase' beta))                     continue;                  // Check for legality only before to do the move                 if (!pos.pl_move_is_legal(move' ci.pinned))                     continue;                  ss[ssPos].currentMove = move;                  // Make and search the move                 if (st == null) { st = StateInfoBroker.GetObject(); }                 pos.do_move(move' st' ci' givesCheck);                 value = -qsearch(NT' pos' ss' ssPos + 1' -beta' -alpha' depth - DepthC.ONE_PLY);                 pos.undo_move(move);                  Debug.Assert(value > -ValueC.VALUE_INFINITE && value < ValueC.VALUE_INFINITE);                  // New best move?                 if (value > bestValue)                 {                     bestValue = value;                     bestMove = move;                      if (PvNode                         && value > alpha                         && value < beta) // We want always alpha < beta                         alpha = value;                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,qsearch,The following statement contains a magic number: while (bestValue < beta                    && (move = mp.next_move()) != MoveC.MOVE_NONE)             {                 Debug.Assert(Utils.is_ok_M(move));                  givesCheck = pos.move_gives_check(move' ci);                  // Futility pruning                 if (!PvNode                     && !inCheck                     && !givesCheck                     && move != ttMove                     && enoughMaterial                     && ((move & (3 << 14)) != (1 << 14))                     && !pos.is_passed_pawn_push(move))                 {                     futilityValue = futilityBase                                    + Position.PieceValueEndgame[pos.board[move & 0x3F]]                                    + (((move & (3 << 14)) == (2 << 14)) ? Constants.PawnValueEndgame : ValueC.VALUE_ZERO);                      if (futilityValue < beta)                     {                         if (futilityValue > bestValue)                             bestValue = futilityValue;                          continue;                     }                      // Prune moves with negative or equal SEE                     if (futilityBase < beta                         && depth < DepthC.DEPTH_ZERO                         && pos.see(move' false) <= 0)                         continue;                 }                  // Detect non-capture evasions that are candidate to be pruned                 evasionPrunable = !PvNode                                  && inCheck                                  && bestValue > ValueC.VALUE_MATED_IN_MAX_PLY                                  && !(((pos.board[move & 0x3F] != PieceC.NO_PIECE) && !((move & (3 << 14)) == (3 << 14))) || ((move & (3 << 14)) == (2 << 14)))                                  && ((pos.st.castleRights & (CastleRightC.WHITE_ANY << (pos.sideToMove << 1))) == 0);                  // Don't search moves with negative SEE values                 if (!PvNode                     && move != ttMove                     && (!inCheck || evasionPrunable)                     && (move & (3 << 14)) != (1 << 14)                     && pos.see(move' true) < 0)                     continue;                  // Don't search useless checks                 if (!PvNode                     && !inCheck                     && givesCheck                     && move != ttMove                     && !(((move & (3 << 14)) != 0) ? ((move & (3 << 14)) != (3 << 14)) : (pos.board[move & 0x3F] != PieceC.NO_PIECE))                     && ss[ssPos].eval + Constants.PawnValueMidgame / 4 < beta                     && !check_is_dangerous(pos' move' futilityBase' beta))                     continue;                  // Check for legality only before to do the move                 if (!pos.pl_move_is_legal(move' ci.pinned))                     continue;                  ss[ssPos].currentMove = move;                  // Make and search the move                 if (st == null) { st = StateInfoBroker.GetObject(); }                 pos.do_move(move' st' ci' givesCheck);                 value = -qsearch(NT' pos' ss' ssPos + 1' -beta' -alpha' depth - DepthC.ONE_PLY);                 pos.undo_move(move);                  Debug.Assert(value > -ValueC.VALUE_INFINITE && value < ValueC.VALUE_INFINITE);                  // New best move?                 if (value > bestValue)                 {                     bestValue = value;                     bestMove = move;                      if (PvNode                         && value > alpha                         && value < beta) // We want always alpha < beta                         alpha = value;                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,qsearch,The following statement contains a magic number: while (bestValue < beta                    && (move = mp.next_move()) != MoveC.MOVE_NONE)             {                 Debug.Assert(Utils.is_ok_M(move));                  givesCheck = pos.move_gives_check(move' ci);                  // Futility pruning                 if (!PvNode                     && !inCheck                     && !givesCheck                     && move != ttMove                     && enoughMaterial                     && ((move & (3 << 14)) != (1 << 14))                     && !pos.is_passed_pawn_push(move))                 {                     futilityValue = futilityBase                                    + Position.PieceValueEndgame[pos.board[move & 0x3F]]                                    + (((move & (3 << 14)) == (2 << 14)) ? Constants.PawnValueEndgame : ValueC.VALUE_ZERO);                      if (futilityValue < beta)                     {                         if (futilityValue > bestValue)                             bestValue = futilityValue;                          continue;                     }                      // Prune moves with negative or equal SEE                     if (futilityBase < beta                         && depth < DepthC.DEPTH_ZERO                         && pos.see(move' false) <= 0)                         continue;                 }                  // Detect non-capture evasions that are candidate to be pruned                 evasionPrunable = !PvNode                                  && inCheck                                  && bestValue > ValueC.VALUE_MATED_IN_MAX_PLY                                  && !(((pos.board[move & 0x3F] != PieceC.NO_PIECE) && !((move & (3 << 14)) == (3 << 14))) || ((move & (3 << 14)) == (2 << 14)))                                  && ((pos.st.castleRights & (CastleRightC.WHITE_ANY << (pos.sideToMove << 1))) == 0);                  // Don't search moves with negative SEE values                 if (!PvNode                     && move != ttMove                     && (!inCheck || evasionPrunable)                     && (move & (3 << 14)) != (1 << 14)                     && pos.see(move' true) < 0)                     continue;                  // Don't search useless checks                 if (!PvNode                     && !inCheck                     && givesCheck                     && move != ttMove                     && !(((move & (3 << 14)) != 0) ? ((move & (3 << 14)) != (3 << 14)) : (pos.board[move & 0x3F] != PieceC.NO_PIECE))                     && ss[ssPos].eval + Constants.PawnValueMidgame / 4 < beta                     && !check_is_dangerous(pos' move' futilityBase' beta))                     continue;                  // Check for legality only before to do the move                 if (!pos.pl_move_is_legal(move' ci.pinned))                     continue;                  ss[ssPos].currentMove = move;                  // Make and search the move                 if (st == null) { st = StateInfoBroker.GetObject(); }                 pos.do_move(move' st' ci' givesCheck);                 value = -qsearch(NT' pos' ss' ssPos + 1' -beta' -alpha' depth - DepthC.ONE_PLY);                 pos.undo_move(move);                  Debug.Assert(value > -ValueC.VALUE_INFINITE && value < ValueC.VALUE_INFINITE);                  // New best move?                 if (value > bestValue)                 {                     bestValue = value;                     bestMove = move;                      if (PvNode                         && value > alpha                         && value < beta) // We want always alpha < beta                         alpha = value;                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,qsearch,The following statement contains a magic number: while (bestValue < beta                    && (move = mp.next_move()) != MoveC.MOVE_NONE)             {                 Debug.Assert(Utils.is_ok_M(move));                  givesCheck = pos.move_gives_check(move' ci);                  // Futility pruning                 if (!PvNode                     && !inCheck                     && !givesCheck                     && move != ttMove                     && enoughMaterial                     && ((move & (3 << 14)) != (1 << 14))                     && !pos.is_passed_pawn_push(move))                 {                     futilityValue = futilityBase                                    + Position.PieceValueEndgame[pos.board[move & 0x3F]]                                    + (((move & (3 << 14)) == (2 << 14)) ? Constants.PawnValueEndgame : ValueC.VALUE_ZERO);                      if (futilityValue < beta)                     {                         if (futilityValue > bestValue)                             bestValue = futilityValue;                          continue;                     }                      // Prune moves with negative or equal SEE                     if (futilityBase < beta                         && depth < DepthC.DEPTH_ZERO                         && pos.see(move' false) <= 0)                         continue;                 }                  // Detect non-capture evasions that are candidate to be pruned                 evasionPrunable = !PvNode                                  && inCheck                                  && bestValue > ValueC.VALUE_MATED_IN_MAX_PLY                                  && !(((pos.board[move & 0x3F] != PieceC.NO_PIECE) && !((move & (3 << 14)) == (3 << 14))) || ((move & (3 << 14)) == (2 << 14)))                                  && ((pos.st.castleRights & (CastleRightC.WHITE_ANY << (pos.sideToMove << 1))) == 0);                  // Don't search moves with negative SEE values                 if (!PvNode                     && move != ttMove                     && (!inCheck || evasionPrunable)                     && (move & (3 << 14)) != (1 << 14)                     && pos.see(move' true) < 0)                     continue;                  // Don't search useless checks                 if (!PvNode                     && !inCheck                     && givesCheck                     && move != ttMove                     && !(((move & (3 << 14)) != 0) ? ((move & (3 << 14)) != (3 << 14)) : (pos.board[move & 0x3F] != PieceC.NO_PIECE))                     && ss[ssPos].eval + Constants.PawnValueMidgame / 4 < beta                     && !check_is_dangerous(pos' move' futilityBase' beta))                     continue;                  // Check for legality only before to do the move                 if (!pos.pl_move_is_legal(move' ci.pinned))                     continue;                  ss[ssPos].currentMove = move;                  // Make and search the move                 if (st == null) { st = StateInfoBroker.GetObject(); }                 pos.do_move(move' st' ci' givesCheck);                 value = -qsearch(NT' pos' ss' ssPos + 1' -beta' -alpha' depth - DepthC.ONE_PLY);                 pos.undo_move(move);                  Debug.Assert(value > -ValueC.VALUE_INFINITE && value < ValueC.VALUE_INFINITE);                  // New best move?                 if (value > bestValue)                 {                     bestValue = value;                     bestMove = move;                      if (PvNode                         && value > alpha                         && value < beta) // We want always alpha < beta                         alpha = value;                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,qsearch,The following statement contains a magic number: while (bestValue < beta                    && (move = mp.next_move()) != MoveC.MOVE_NONE)             {                 Debug.Assert(Utils.is_ok_M(move));                  givesCheck = pos.move_gives_check(move' ci);                  // Futility pruning                 if (!PvNode                     && !inCheck                     && !givesCheck                     && move != ttMove                     && enoughMaterial                     && ((move & (3 << 14)) != (1 << 14))                     && !pos.is_passed_pawn_push(move))                 {                     futilityValue = futilityBase                                    + Position.PieceValueEndgame[pos.board[move & 0x3F]]                                    + (((move & (3 << 14)) == (2 << 14)) ? Constants.PawnValueEndgame : ValueC.VALUE_ZERO);                      if (futilityValue < beta)                     {                         if (futilityValue > bestValue)                             bestValue = futilityValue;                          continue;                     }                      // Prune moves with negative or equal SEE                     if (futilityBase < beta                         && depth < DepthC.DEPTH_ZERO                         && pos.see(move' false) <= 0)                         continue;                 }                  // Detect non-capture evasions that are candidate to be pruned                 evasionPrunable = !PvNode                                  && inCheck                                  && bestValue > ValueC.VALUE_MATED_IN_MAX_PLY                                  && !(((pos.board[move & 0x3F] != PieceC.NO_PIECE) && !((move & (3 << 14)) == (3 << 14))) || ((move & (3 << 14)) == (2 << 14)))                                  && ((pos.st.castleRights & (CastleRightC.WHITE_ANY << (pos.sideToMove << 1))) == 0);                  // Don't search moves with negative SEE values                 if (!PvNode                     && move != ttMove                     && (!inCheck || evasionPrunable)                     && (move & (3 << 14)) != (1 << 14)                     && pos.see(move' true) < 0)                     continue;                  // Don't search useless checks                 if (!PvNode                     && !inCheck                     && givesCheck                     && move != ttMove                     && !(((move & (3 << 14)) != 0) ? ((move & (3 << 14)) != (3 << 14)) : (pos.board[move & 0x3F] != PieceC.NO_PIECE))                     && ss[ssPos].eval + Constants.PawnValueMidgame / 4 < beta                     && !check_is_dangerous(pos' move' futilityBase' beta))                     continue;                  // Check for legality only before to do the move                 if (!pos.pl_move_is_legal(move' ci.pinned))                     continue;                  ss[ssPos].currentMove = move;                  // Make and search the move                 if (st == null) { st = StateInfoBroker.GetObject(); }                 pos.do_move(move' st' ci' givesCheck);                 value = -qsearch(NT' pos' ss' ssPos + 1' -beta' -alpha' depth - DepthC.ONE_PLY);                 pos.undo_move(move);                  Debug.Assert(value > -ValueC.VALUE_INFINITE && value < ValueC.VALUE_INFINITE);                  // New best move?                 if (value > bestValue)                 {                     bestValue = value;                     bestMove = move;                      if (PvNode                         && value > alpha                         && value < beta) // We want always alpha < beta                         alpha = value;                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,qsearch,The following statement contains a magic number: while (bestValue < beta                    && (move = mp.next_move()) != MoveC.MOVE_NONE)             {                 Debug.Assert(Utils.is_ok_M(move));                  givesCheck = pos.move_gives_check(move' ci);                  // Futility pruning                 if (!PvNode                     && !inCheck                     && !givesCheck                     && move != ttMove                     && enoughMaterial                     && ((move & (3 << 14)) != (1 << 14))                     && !pos.is_passed_pawn_push(move))                 {                     futilityValue = futilityBase                                    + Position.PieceValueEndgame[pos.board[move & 0x3F]]                                    + (((move & (3 << 14)) == (2 << 14)) ? Constants.PawnValueEndgame : ValueC.VALUE_ZERO);                      if (futilityValue < beta)                     {                         if (futilityValue > bestValue)                             bestValue = futilityValue;                          continue;                     }                      // Prune moves with negative or equal SEE                     if (futilityBase < beta                         && depth < DepthC.DEPTH_ZERO                         && pos.see(move' false) <= 0)                         continue;                 }                  // Detect non-capture evasions that are candidate to be pruned                 evasionPrunable = !PvNode                                  && inCheck                                  && bestValue > ValueC.VALUE_MATED_IN_MAX_PLY                                  && !(((pos.board[move & 0x3F] != PieceC.NO_PIECE) && !((move & (3 << 14)) == (3 << 14))) || ((move & (3 << 14)) == (2 << 14)))                                  && ((pos.st.castleRights & (CastleRightC.WHITE_ANY << (pos.sideToMove << 1))) == 0);                  // Don't search moves with negative SEE values                 if (!PvNode                     && move != ttMove                     && (!inCheck || evasionPrunable)                     && (move & (3 << 14)) != (1 << 14)                     && pos.see(move' true) < 0)                     continue;                  // Don't search useless checks                 if (!PvNode                     && !inCheck                     && givesCheck                     && move != ttMove                     && !(((move & (3 << 14)) != 0) ? ((move & (3 << 14)) != (3 << 14)) : (pos.board[move & 0x3F] != PieceC.NO_PIECE))                     && ss[ssPos].eval + Constants.PawnValueMidgame / 4 < beta                     && !check_is_dangerous(pos' move' futilityBase' beta))                     continue;                  // Check for legality only before to do the move                 if (!pos.pl_move_is_legal(move' ci.pinned))                     continue;                  ss[ssPos].currentMove = move;                  // Make and search the move                 if (st == null) { st = StateInfoBroker.GetObject(); }                 pos.do_move(move' st' ci' givesCheck);                 value = -qsearch(NT' pos' ss' ssPos + 1' -beta' -alpha' depth - DepthC.ONE_PLY);                 pos.undo_move(move);                  Debug.Assert(value > -ValueC.VALUE_INFINITE && value < ValueC.VALUE_INFINITE);                  // New best move?                 if (value > bestValue)                 {                     bestValue = value;                     bestMove = move;                      if (PvNode                         && value > alpha                         && value < beta) // We want always alpha < beta                         alpha = value;                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,qsearch,The following statement contains a magic number: while (bestValue < beta                    && (move = mp.next_move()) != MoveC.MOVE_NONE)             {                 Debug.Assert(Utils.is_ok_M(move));                  givesCheck = pos.move_gives_check(move' ci);                  // Futility pruning                 if (!PvNode                     && !inCheck                     && !givesCheck                     && move != ttMove                     && enoughMaterial                     && ((move & (3 << 14)) != (1 << 14))                     && !pos.is_passed_pawn_push(move))                 {                     futilityValue = futilityBase                                    + Position.PieceValueEndgame[pos.board[move & 0x3F]]                                    + (((move & (3 << 14)) == (2 << 14)) ? Constants.PawnValueEndgame : ValueC.VALUE_ZERO);                      if (futilityValue < beta)                     {                         if (futilityValue > bestValue)                             bestValue = futilityValue;                          continue;                     }                      // Prune moves with negative or equal SEE                     if (futilityBase < beta                         && depth < DepthC.DEPTH_ZERO                         && pos.see(move' false) <= 0)                         continue;                 }                  // Detect non-capture evasions that are candidate to be pruned                 evasionPrunable = !PvNode                                  && inCheck                                  && bestValue > ValueC.VALUE_MATED_IN_MAX_PLY                                  && !(((pos.board[move & 0x3F] != PieceC.NO_PIECE) && !((move & (3 << 14)) == (3 << 14))) || ((move & (3 << 14)) == (2 << 14)))                                  && ((pos.st.castleRights & (CastleRightC.WHITE_ANY << (pos.sideToMove << 1))) == 0);                  // Don't search moves with negative SEE values                 if (!PvNode                     && move != ttMove                     && (!inCheck || evasionPrunable)                     && (move & (3 << 14)) != (1 << 14)                     && pos.see(move' true) < 0)                     continue;                  // Don't search useless checks                 if (!PvNode                     && !inCheck                     && givesCheck                     && move != ttMove                     && !(((move & (3 << 14)) != 0) ? ((move & (3 << 14)) != (3 << 14)) : (pos.board[move & 0x3F] != PieceC.NO_PIECE))                     && ss[ssPos].eval + Constants.PawnValueMidgame / 4 < beta                     && !check_is_dangerous(pos' move' futilityBase' beta))                     continue;                  // Check for legality only before to do the move                 if (!pos.pl_move_is_legal(move' ci.pinned))                     continue;                  ss[ssPos].currentMove = move;                  // Make and search the move                 if (st == null) { st = StateInfoBroker.GetObject(); }                 pos.do_move(move' st' ci' givesCheck);                 value = -qsearch(NT' pos' ss' ssPos + 1' -beta' -alpha' depth - DepthC.ONE_PLY);                 pos.undo_move(move);                  Debug.Assert(value > -ValueC.VALUE_INFINITE && value < ValueC.VALUE_INFINITE);                  // New best move?                 if (value > bestValue)                 {                     bestValue = value;                     bestMove = move;                      if (PvNode                         && value > alpha                         && value < beta) // We want always alpha < beta                         alpha = value;                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,qsearch,The following statement contains a magic number: while (bestValue < beta                    && (move = mp.next_move()) != MoveC.MOVE_NONE)             {                 Debug.Assert(Utils.is_ok_M(move));                  givesCheck = pos.move_gives_check(move' ci);                  // Futility pruning                 if (!PvNode                     && !inCheck                     && !givesCheck                     && move != ttMove                     && enoughMaterial                     && ((move & (3 << 14)) != (1 << 14))                     && !pos.is_passed_pawn_push(move))                 {                     futilityValue = futilityBase                                    + Position.PieceValueEndgame[pos.board[move & 0x3F]]                                    + (((move & (3 << 14)) == (2 << 14)) ? Constants.PawnValueEndgame : ValueC.VALUE_ZERO);                      if (futilityValue < beta)                     {                         if (futilityValue > bestValue)                             bestValue = futilityValue;                          continue;                     }                      // Prune moves with negative or equal SEE                     if (futilityBase < beta                         && depth < DepthC.DEPTH_ZERO                         && pos.see(move' false) <= 0)                         continue;                 }                  // Detect non-capture evasions that are candidate to be pruned                 evasionPrunable = !PvNode                                  && inCheck                                  && bestValue > ValueC.VALUE_MATED_IN_MAX_PLY                                  && !(((pos.board[move & 0x3F] != PieceC.NO_PIECE) && !((move & (3 << 14)) == (3 << 14))) || ((move & (3 << 14)) == (2 << 14)))                                  && ((pos.st.castleRights & (CastleRightC.WHITE_ANY << (pos.sideToMove << 1))) == 0);                  // Don't search moves with negative SEE values                 if (!PvNode                     && move != ttMove                     && (!inCheck || evasionPrunable)                     && (move & (3 << 14)) != (1 << 14)                     && pos.see(move' true) < 0)                     continue;                  // Don't search useless checks                 if (!PvNode                     && !inCheck                     && givesCheck                     && move != ttMove                     && !(((move & (3 << 14)) != 0) ? ((move & (3 << 14)) != (3 << 14)) : (pos.board[move & 0x3F] != PieceC.NO_PIECE))                     && ss[ssPos].eval + Constants.PawnValueMidgame / 4 < beta                     && !check_is_dangerous(pos' move' futilityBase' beta))                     continue;                  // Check for legality only before to do the move                 if (!pos.pl_move_is_legal(move' ci.pinned))                     continue;                  ss[ssPos].currentMove = move;                  // Make and search the move                 if (st == null) { st = StateInfoBroker.GetObject(); }                 pos.do_move(move' st' ci' givesCheck);                 value = -qsearch(NT' pos' ss' ssPos + 1' -beta' -alpha' depth - DepthC.ONE_PLY);                 pos.undo_move(move);                  Debug.Assert(value > -ValueC.VALUE_INFINITE && value < ValueC.VALUE_INFINITE);                  // New best move?                 if (value > bestValue)                 {                     bestValue = value;                     bestMove = move;                      if (PvNode                         && value > alpha                         && value < beta) // We want always alpha < beta                         alpha = value;                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,qsearch,The following statement contains a magic number: while (bestValue < beta                    && (move = mp.next_move()) != MoveC.MOVE_NONE)             {                 Debug.Assert(Utils.is_ok_M(move));                  givesCheck = pos.move_gives_check(move' ci);                  // Futility pruning                 if (!PvNode                     && !inCheck                     && !givesCheck                     && move != ttMove                     && enoughMaterial                     && ((move & (3 << 14)) != (1 << 14))                     && !pos.is_passed_pawn_push(move))                 {                     futilityValue = futilityBase                                    + Position.PieceValueEndgame[pos.board[move & 0x3F]]                                    + (((move & (3 << 14)) == (2 << 14)) ? Constants.PawnValueEndgame : ValueC.VALUE_ZERO);                      if (futilityValue < beta)                     {                         if (futilityValue > bestValue)                             bestValue = futilityValue;                          continue;                     }                      // Prune moves with negative or equal SEE                     if (futilityBase < beta                         && depth < DepthC.DEPTH_ZERO                         && pos.see(move' false) <= 0)                         continue;                 }                  // Detect non-capture evasions that are candidate to be pruned                 evasionPrunable = !PvNode                                  && inCheck                                  && bestValue > ValueC.VALUE_MATED_IN_MAX_PLY                                  && !(((pos.board[move & 0x3F] != PieceC.NO_PIECE) && !((move & (3 << 14)) == (3 << 14))) || ((move & (3 << 14)) == (2 << 14)))                                  && ((pos.st.castleRights & (CastleRightC.WHITE_ANY << (pos.sideToMove << 1))) == 0);                  // Don't search moves with negative SEE values                 if (!PvNode                     && move != ttMove                     && (!inCheck || evasionPrunable)                     && (move & (3 << 14)) != (1 << 14)                     && pos.see(move' true) < 0)                     continue;                  // Don't search useless checks                 if (!PvNode                     && !inCheck                     && givesCheck                     && move != ttMove                     && !(((move & (3 << 14)) != 0) ? ((move & (3 << 14)) != (3 << 14)) : (pos.board[move & 0x3F] != PieceC.NO_PIECE))                     && ss[ssPos].eval + Constants.PawnValueMidgame / 4 < beta                     && !check_is_dangerous(pos' move' futilityBase' beta))                     continue;                  // Check for legality only before to do the move                 if (!pos.pl_move_is_legal(move' ci.pinned))                     continue;                  ss[ssPos].currentMove = move;                  // Make and search the move                 if (st == null) { st = StateInfoBroker.GetObject(); }                 pos.do_move(move' st' ci' givesCheck);                 value = -qsearch(NT' pos' ss' ssPos + 1' -beta' -alpha' depth - DepthC.ONE_PLY);                 pos.undo_move(move);                  Debug.Assert(value > -ValueC.VALUE_INFINITE && value < ValueC.VALUE_INFINITE);                  // New best move?                 if (value > bestValue)                 {                     bestValue = value;                     bestMove = move;                      if (PvNode                         && value > alpha                         && value < beta) // We want always alpha < beta                         alpha = value;                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,qsearch,The following statement contains a magic number: while (bestValue < beta                    && (move = mp.next_move()) != MoveC.MOVE_NONE)             {                 Debug.Assert(Utils.is_ok_M(move));                  givesCheck = pos.move_gives_check(move' ci);                  // Futility pruning                 if (!PvNode                     && !inCheck                     && !givesCheck                     && move != ttMove                     && enoughMaterial                     && ((move & (3 << 14)) != (1 << 14))                     && !pos.is_passed_pawn_push(move))                 {                     futilityValue = futilityBase                                    + Position.PieceValueEndgame[pos.board[move & 0x3F]]                                    + (((move & (3 << 14)) == (2 << 14)) ? Constants.PawnValueEndgame : ValueC.VALUE_ZERO);                      if (futilityValue < beta)                     {                         if (futilityValue > bestValue)                             bestValue = futilityValue;                          continue;                     }                      // Prune moves with negative or equal SEE                     if (futilityBase < beta                         && depth < DepthC.DEPTH_ZERO                         && pos.see(move' false) <= 0)                         continue;                 }                  // Detect non-capture evasions that are candidate to be pruned                 evasionPrunable = !PvNode                                  && inCheck                                  && bestValue > ValueC.VALUE_MATED_IN_MAX_PLY                                  && !(((pos.board[move & 0x3F] != PieceC.NO_PIECE) && !((move & (3 << 14)) == (3 << 14))) || ((move & (3 << 14)) == (2 << 14)))                                  && ((pos.st.castleRights & (CastleRightC.WHITE_ANY << (pos.sideToMove << 1))) == 0);                  // Don't search moves with negative SEE values                 if (!PvNode                     && move != ttMove                     && (!inCheck || evasionPrunable)                     && (move & (3 << 14)) != (1 << 14)                     && pos.see(move' true) < 0)                     continue;                  // Don't search useless checks                 if (!PvNode                     && !inCheck                     && givesCheck                     && move != ttMove                     && !(((move & (3 << 14)) != 0) ? ((move & (3 << 14)) != (3 << 14)) : (pos.board[move & 0x3F] != PieceC.NO_PIECE))                     && ss[ssPos].eval + Constants.PawnValueMidgame / 4 < beta                     && !check_is_dangerous(pos' move' futilityBase' beta))                     continue;                  // Check for legality only before to do the move                 if (!pos.pl_move_is_legal(move' ci.pinned))                     continue;                  ss[ssPos].currentMove = move;                  // Make and search the move                 if (st == null) { st = StateInfoBroker.GetObject(); }                 pos.do_move(move' st' ci' givesCheck);                 value = -qsearch(NT' pos' ss' ssPos + 1' -beta' -alpha' depth - DepthC.ONE_PLY);                 pos.undo_move(move);                  Debug.Assert(value > -ValueC.VALUE_INFINITE && value < ValueC.VALUE_INFINITE);                  // New best move?                 if (value > bestValue)                 {                     bestValue = value;                     bestMove = move;                      if (PvNode                         && value > alpha                         && value < beta) // We want always alpha < beta                         alpha = value;                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,pv_info_to_uci,The following statement contains a magic number: for (int i = 0; i < Math.Min(UCIMultiPV' RootMoves.Count); i++)             {                 bool updated = (i <= PVIdx);                  if (depth == 1 && !updated)                     continue;                  int d = (updated ? depth : depth - 1);                 Value v = (updated ? RootMoves[i].score : RootMoves[i].prevScore);                 StringBuilder s = new StringBuilder();                  for (int j = 0; RootMoves[i].pv[j] != MoveC.MOVE_NONE; j++)                 {                     s.Append(" ").Append(Utils.move_to_uci(RootMoves[i].pv[j]' Chess960));                 }                  Plug.Write("info depth ");                 Plug.Write(d.ToString());                 Plug.Write(" seldepth ");                 Plug.Write(selDepth.ToString());                 Plug.Write(" score ");                 Plug.Write((i == PVIdx ? score_to_uci(v' alpha' beta) : score_to_uci(v)));                 Plug.Write(" nodes ");                 Plug.Write(pos.nodes.ToString());                 Plug.Write(" nps ");                 Plug.Write(((t > 0 ? pos.nodes * 1000 / t : 0)).ToString());                 Plug.Write(" time ");                 Plug.Write(t.ToString());                 Plug.Write(" multipv ");                 Plug.Write((i + 1).ToString());                 Plug.Write(" pv");                 Plug.Write(s.ToString());                 Plug.Write(Constants.endl);             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,do_skill_level,The following statement contains a magic number: for (int i = Math.Abs(DateTime.Now.Millisecond % 50); i > 0; i--)             {                 rk.rand();             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,do_skill_level,The following statement contains a magic number: int weakness = 120 - 2 * SkillLevel;
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,do_skill_level,The following statement contains a magic number: int weakness = 120 - 2 * SkillLevel;
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,do_skill_level,The following statement contains a magic number: for (int i = 0; i < size; i++)             {                 int s = RootMoves[i].score;                  // Don't allow crazy blunders even at very low skills                 if (i > 0 && RootMoves[i - 1].score > s + EasyMoveMargin)                     break;                  // This is our magic formula                 s += (weakness * (int)(RootMoves[0].score - s)                       + variance * (int)(rk.rand() % (ulong)weakness)) / 128;                  if (s > max_s)                 {                     max_s = s;                     best = RootMoves[i].pv[0];                 }             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,score_to_uci,The following statement contains a magic number: if (Math.Abs(v) < ValueC.VALUE_MATE_IN_MAX_PLY)                 s.Append("cp ").Append(v * 100 / (int)(Constants.PawnValueMidgame));             else                 s.Append("mate ").Append((v > 0 ? ValueC.VALUE_MATE - v + 1 : -ValueC.VALUE_MATE - v) / 2);
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,score_to_uci,The following statement contains a magic number: if (Math.Abs(v) < ValueC.VALUE_MATE_IN_MAX_PLY)                 s.Append("cp ").Append(v * 100 / (int)(Constants.PawnValueMidgame));             else                 s.Append("mate ").Append((v > 0 ? ValueC.VALUE_MATE - v + 1 : -ValueC.VALUE_MATE - v) / 2);
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,check_time,The following statement contains a magic number: if (lastInfoTime.ElapsedMilliseconds >= 1000)             {                 lastInfoTime.Reset(); lastInfoTime.Start();                 Utils.dbg_print();             }
Magic Number,Portfish,Search,C:\repos\bpfliegel_Portfish\src\Search.cs,check_time,The following statement contains a magic number: bool noMoreTime = e > TimeMgr.maximum_time() - 2 * TimerResolution                            || stillAtFirstMove;
Magic Number,Portfish,Thread,C:\repos\bpfliegel_Portfish\src\Thread.cs,idle_loop,The following statement contains a magic number: while ((sp_master == null) || (sp_master.slavesMask != 0))              {                  // If we are not searching' wait for a condition to be signaled                  // instead of wasting CPU time polling for work.                  while (do_sleep                         || do_exit                         || (!is_searching && use_sleeping_threads))                  {                      if (do_exit)                      {                          Debug.Assert(sp_master == null);                          return;                      }                        // Grab the lock to avoid races with Thread::wake_up()                      ThreadHelper.lock_grab(sleepLock);                        // If we are master and all slaves have finished don't go to sleep                      if ((sp_master != null) && (sp_master.slavesMask == 0))                      {                          ThreadHelper.lock_release(sleepLock);                          break;                      }                        // Do sleep after retesting sleep conditions under lock protection' in                      // particular we need to avoid a deadlock in case a master thread has'                      // in the meanwhile' allocated us and sent the wake_up() call before we                      // had the chance to grab the lock.                      if (do_sleep || !is_searching)                          ThreadHelper.cond_wait(sleepCond' sleepLock);                        ThreadHelper.lock_release(sleepLock);                  }                    // If this thread has been assigned work' launch a search                  if (is_searching)                  {                      Debug.Assert(!do_sleep && !do_exit);                        ThreadHelper.lock_grab(Threads.splitLock);                        Debug.Assert(is_searching);                      SplitPoint sp = curSplitPoint;                        ThreadHelper.lock_release(Threads.splitLock);                        LoopStack ls = LoopStackBroker.GetObject();                      Stack[] ss = ls.ss;                      int ssPos = 0;                        Position pos = PositionBroker.GetObject();                      pos.copy(sp.pos' this);                        Array.Copy(sp.ss' sp.ssPos - 1' ss' ssPos' 4);                      ss[ssPos + 1].sp = sp;                        ThreadHelper.lock_grab(sp.Lock);                        if (sp.nodeType == NodeTypeC.Root)                      {                          Search.search(NodeTypeC.SplitPointRoot' pos' ss' ssPos + 1' sp.alpha' sp.beta' sp.depth);                      }                      else if (sp.nodeType == NodeTypeC.PV)                      {                          Search.search(NodeTypeC.SplitPointPV' pos' ss' ssPos + 1' sp.alpha' sp.beta' sp.depth);                      }                      else if (sp.nodeType == NodeTypeC.NonPV)                      {                          Search.search(NodeTypeC.SplitPointNonPV' pos' ss' ssPos + 1' sp.alpha' sp.beta' sp.depth);                      }                      else                      {                          Debug.Assert(false);                      }                        Debug.Assert(is_searching);                        is_searching = false;  #if ACTIVE_REPARENT                      sp.allSlavesRunning = false;  #endif                      sp.slavesMask &= ~(1UL << idx);                      sp.nodes += pos.nodes;                        // Wake up master thread so to allow it to return from the idle loop in                      // case we are the last slave of the split point.                      if (use_sleeping_threads                          && this != sp.master                          && !sp.master.is_searching)                          sp.master.wake_up();                        // After releasing the lock we cannot access anymore any SplitPoint                      // related data in a safe way becuase it could have been released under                      // our feet by the sp master. Also accessing other Thread objects is                      // unsafe because if we are exiting there is a chance are already freed.                      ThreadHelper.lock_release(sp.Lock);    #if ACTIVE_REPARENT                      // Try to reparent to the first split point' with still all slaves                      // running' where we are available as a possible slave.                      for (int i = 0; i < Threads.size(); i++)                      {                          Thread th = Threads.threads[i];                          int spCnt = th.splitPointsCnt;                          SplitPoint latest = th.splitPoints[spCnt != 0 ? spCnt - 1 : 0];                            if (this.is_available_to(th)                              && spCnt > 0                              && !th.cutoff_occurred()                              && latest.allSlavesRunning                              && Utils.more_than_one(latest.slavesMask))                          {                              ThreadHelper.lock_grab(latest.Lock);                              ThreadHelper.lock_grab(Threads.splitLock);                                // Retest all under lock protection' we are in the middle                              // of a race storm here !                              if (this.is_available_to(th)                                  && spCnt == th.splitPointsCnt                                  && !th.cutoff_occurred()                                  && latest.allSlavesRunning                                  && Utils.more_than_one(latest.slavesMask))                              {                                  latest.slavesMask |= 1UL << idx;                                  curSplitPoint = latest;                                  is_searching = true;                              }                                ThreadHelper.lock_release(Threads.splitLock);                              ThreadHelper.lock_release(latest.Lock);                                break; // Exit anyhow' only one try (enough in 99% of cases)                          }                      }  #endif                        pos.startState = null;                      pos.st = null;                      PositionBroker.Free();                      LoopStackBroker.Free(ls);                  }              }
Magic Number,Portfish,Threads,C:\repos\bpfliegel_Portfish\src\Thread.cs,read_uci_options,The following statement contains a magic number: while (size() < requested)              {                  if (initEvents == null)                  {                      threads.Add(new Thread(ThreadLoopType.Idle' null));                  }                  else                  {                      threads.Add(new Thread(ThreadLoopType.Idle' initEvents[current+2]));                      current++;                  }              }
Magic Number,Portfish,TimeMgr,C:\repos\bpfliegel_Portfish\src\Timeman.cs,move_importance,The following statement contains a magic number: return MoveImportance[Math.Min(ply' 511)];
Magic Number,Portfish,TimeMgr,C:\repos\bpfliegel_Portfish\src\Timeman.cs,pv_instability,The following statement contains a magic number: unstablePVExtraTime = curChanges * (optimumSearchTime / 2)                                   + prevChanges * (optimumSearchTime / 3);
Magic Number,Portfish,TimeMgr,C:\repos\bpfliegel_Portfish\src\Timeman.cs,pv_instability,The following statement contains a magic number: unstablePVExtraTime = curChanges * (optimumSearchTime / 2)                                   + prevChanges * (optimumSearchTime / 3);
Magic Number,Portfish,TimeMgr,C:\repos\bpfliegel_Portfish\src\Timeman.cs,init,The following statement contains a magic number: if (bool.Parse(OptionMap.Instance["Ponder"].v))                  optimumSearchTime += optimumSearchTime / 4;
Magic Number,Portfish,TimeMgr,C:\repos\bpfliegel_Portfish\src\Timeman.cs,remaining,The following statement contains a magic number: int thisMoveImportance = move_importance(currentPly) * slowMover / 100;
Magic Number,Portfish,TimeMgr,C:\repos\bpfliegel_Portfish\src\Timeman.cs,remaining,The following statement contains a magic number: for (int i = 1; i < movesToGo; i++)                  otherMovesImportance += move_importance(currentPly + 2 * i);
Magic Number,Portfish,TT,C:\repos\bpfliegel_Portfish\src\TT.cs,set_size,The following statement contains a magic number: UInt32 newSize = 1024;
Magic Number,Portfish,TT,C:\repos\bpfliegel_Portfish\src\TT.cs,set_size,The following statement contains a magic number: while (2UL * newSize * 64 <= (mbSize << 20))                  newSize *= 2;
Magic Number,Portfish,TT,C:\repos\bpfliegel_Portfish\src\TT.cs,set_size,The following statement contains a magic number: while (2UL * newSize * 64 <= (mbSize << 20))                  newSize *= 2;
Magic Number,Portfish,TT,C:\repos\bpfliegel_Portfish\src\TT.cs,set_size,The following statement contains a magic number: while (2UL * newSize * 64 <= (mbSize << 20))                  newSize *= 2;
Magic Number,Portfish,TT,C:\repos\bpfliegel_Portfish\src\TT.cs,set_size,The following statement contains a magic number: entries = new TTEntry[size * 4];
Magic Number,Portfish,TT,C:\repos\bpfliegel_Portfish\src\TT.cs,store,The following statement contains a magic number: UInt32 posKey32 = (UInt32)(posKey >> 32);
Magic Number,Portfish,TT,C:\repos\bpfliegel_Portfish\src\TT.cs,store,The following statement contains a magic number: ttePos = replacePos = (((UInt32)posKey) & sizeMask) << 2;
Magic Number,Portfish,TT,C:\repos\bpfliegel_Portfish\src\TT.cs,store,The following statement contains a magic number: for (UInt32 i = 0; i < Constants.ClusterSize; i++)              {                  TTEntry tte = entries[ttePos];                    if ((tte.key == 0) || tte.key == posKey32) // Empty or overwrite old                  {                      // Preserve any existing ttMove                      if (m == MoveC.MOVE_NONE)                      {                          m = (Move)tte.move16;                      }                        entries[ttePos].save(posKey32' v' t' d' m' generation' statV' kingD);                      return;                  }                    // Implement replace strategy                  //if ((entries[replacePos].generation8 == generation ? 2 : 0) + (tte.generation8 == generation || tte.bound == 3/*Bound.BOUND_EXACT*/ ? -2 : 0) + (tte.depth16 < entries[replacePos].depth16 ? 1 : 0) > 0)                  //{                  //    replacePos = ttePos;                  //}                    if (entries[replacePos].generation8 == generation)                  {                      // +2                      if (tte.generation8 == generation || tte.bound == 3/*Bound.BOUND_EXACT*/)                      {                          // 0                          if (tte.depth16 < entries[replacePos].depth16)                          {                              // +1                              replacePos = ttePos;                          }                      }                      else                      {                          // +2                          replacePos = ttePos;                      }                  }                  else                  {                      // 0                      if ((!(tte.generation8 == generation || tte.bound == 3/*Bound.BOUND_EXACT*/)) && (tte.depth16 < entries[replacePos].depth16))                      {                          // +1                          replacePos = ttePos;                      }                  }                    ttePos++;              }
Magic Number,Portfish,TT,C:\repos\bpfliegel_Portfish\src\TT.cs,store,The following statement contains a magic number: for (UInt32 i = 0; i < Constants.ClusterSize; i++)              {                  TTEntry tte = entries[ttePos];                    if ((tte.key == 0) || tte.key == posKey32) // Empty or overwrite old                  {                      // Preserve any existing ttMove                      if (m == MoveC.MOVE_NONE)                      {                          m = (Move)tte.move16;                      }                        entries[ttePos].save(posKey32' v' t' d' m' generation' statV' kingD);                      return;                  }                    // Implement replace strategy                  //if ((entries[replacePos].generation8 == generation ? 2 : 0) + (tte.generation8 == generation || tte.bound == 3/*Bound.BOUND_EXACT*/ ? -2 : 0) + (tte.depth16 < entries[replacePos].depth16 ? 1 : 0) > 0)                  //{                  //    replacePos = ttePos;                  //}                    if (entries[replacePos].generation8 == generation)                  {                      // +2                      if (tte.generation8 == generation || tte.bound == 3/*Bound.BOUND_EXACT*/)                      {                          // 0                          if (tte.depth16 < entries[replacePos].depth16)                          {                              // +1                              replacePos = ttePos;                          }                      }                      else                      {                          // +2                          replacePos = ttePos;                      }                  }                  else                  {                      // 0                      if ((!(tte.generation8 == generation || tte.bound == 3/*Bound.BOUND_EXACT*/)) && (tte.depth16 < entries[replacePos].depth16))                      {                          // +1                          replacePos = ttePos;                      }                  }                    ttePos++;              }
Magic Number,Portfish,TT,C:\repos\bpfliegel_Portfish\src\TT.cs,probe,The following statement contains a magic number: UInt32 posKey32 = (UInt32)(posKey >> 32);
Magic Number,Portfish,TT,C:\repos\bpfliegel_Portfish\src\TT.cs,probe,The following statement contains a magic number: UInt32 offset = (((UInt32)posKey) & sizeMask) << 2;
Magic Number,Portfish,Uci,C:\repos\bpfliegel_Portfish\src\Uci.cs,uci_loop,The following statement contains a magic number: for (int i = 0; i < 102; i++)             {                 StateRingBuf[i] = new StateInfo();             }
Magic Number,Portfish,Uci,C:\repos\bpfliegel_Portfish\src\Uci.cs,set_position,The following statement contains a magic number: while ((stack.Count > 0) && (m = Utils.move_from_uci(pos' token = stack.Pop())) != MoveC.MOVE_NONE)             {                 pos.do_move(m' StateRingBuf[SetupStatePos]);                  // Increment pointer to StateRingBuf circular buffer                 SetupStatePos = (SetupStatePos + 1) % 102;             }
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: int msd = cpus < 8 ? 4 : 7;
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: int msd = cpus < 8 ? 4 : 7;
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: int msd = cpus < 8 ? 4 : 7;
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: this.Add("Mobility (Middle Game)"' new UCIOption(idx++' 100' 0' 200' UCIOptionChanges.on_eval));
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: this.Add("Mobility (Middle Game)"' new UCIOption(idx++' 100' 0' 200' UCIOptionChanges.on_eval));
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: this.Add("Mobility (Endgame)"' new UCIOption(idx++' 100' 0' 200' UCIOptionChanges.on_eval));
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: this.Add("Mobility (Endgame)"' new UCIOption(idx++' 100' 0' 200' UCIOptionChanges.on_eval));
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: this.Add("Passed Pawns (Middle Game)"' new UCIOption(idx++' 100' 0' 200' UCIOptionChanges.on_eval));
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: this.Add("Passed Pawns (Middle Game)"' new UCIOption(idx++' 100' 0' 200' UCIOptionChanges.on_eval));
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: this.Add("Passed Pawns (Endgame)"' new UCIOption(idx++' 100' 0' 200' UCIOptionChanges.on_eval));
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: this.Add("Passed Pawns (Endgame)"' new UCIOption(idx++' 100' 0' 200' UCIOptionChanges.on_eval));
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: this.Add("Space"' new UCIOption(idx++' 100' 0' 200' UCIOptionChanges.on_eval));
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: this.Add("Space"' new UCIOption(idx++' 100' 0' 200' UCIOptionChanges.on_eval));
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: this.Add("Aggressiveness"' new UCIOption(idx++' 100' 0' 200' UCIOptionChanges.on_eval));
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: this.Add("Aggressiveness"' new UCIOption(idx++' 100' 0' 200' UCIOptionChanges.on_eval));
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: this.Add("Cowardice"' new UCIOption(idx++' 100' 0' 200' UCIOptionChanges.on_eval));
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: this.Add("Cowardice"' new UCIOption(idx++' 100' 0' 200' UCIOptionChanges.on_eval));
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: this.Add("Min Split Depth"' new UCIOption(idx++' msd' 4' 7' UCIOptionChanges.on_threads));
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: this.Add("Min Split Depth"' new UCIOption(idx++' msd' 4' 7' UCIOptionChanges.on_threads));
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: this.Add("Max Threads per Split Point"' new UCIOption(idx++' 5' 4' 8' UCIOptionChanges.on_threads));
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: this.Add("Max Threads per Split Point"' new UCIOption(idx++' 5' 4' 8' UCIOptionChanges.on_threads));
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: this.Add("Max Threads per Split Point"' new UCIOption(idx++' 5' 4' 8' UCIOptionChanges.on_threads));
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: this.Add("Hash"' new UCIOption(idx++' 32' 4' 8192' null));
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: this.Add("Hash"' new UCIOption(idx++' 32' 4' 8192' null));
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: this.Add("Hash"' new UCIOption(idx++' 32' 4' 8192' null));
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: this.Add("MultiPV"' new UCIOption(idx++' 1' 1' 500' null));
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: this.Add("Skill Level"' new UCIOption(idx++' 20' 0' 20' null));
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: this.Add("Skill Level"' new UCIOption(idx++' 20' 0' 20' null));
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: this.Add("Emergency Move Horizon"' new UCIOption(idx++' 40' 0' 50' null));
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: this.Add("Emergency Move Horizon"' new UCIOption(idx++' 40' 0' 50' null));
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: this.Add("Emergency Base Time"' new UCIOption(idx++' 200' 0' 30000' null));
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: this.Add("Emergency Base Time"' new UCIOption(idx++' 200' 0' 30000' null));
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: this.Add("Emergency Move Time"' new UCIOption(idx++' 70' 0' 5000' null));
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: this.Add("Emergency Move Time"' new UCIOption(idx++' 70' 0' 5000' null));
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: this.Add("Minimum Thinking Time"' new UCIOption(idx++' 20' 0' 5000' null));
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: this.Add("Minimum Thinking Time"' new UCIOption(idx++' 20' 0' 5000' null));
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: this.Add("Slow Mover"' new UCIOption(idx++' 100' 10' 1000' null));
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: this.Add("Slow Mover"' new UCIOption(idx++' 100' 10' 1000' null));
Magic Number,Portfish,OptionMap,C:\repos\bpfliegel_Portfish\src\UciOptions.cs,OptionMap,The following statement contains a magic number: this.Add("Slow Mover"' new UCIOption(idx++' 100' 10' 1000' null));
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,init,The following statement contains a magic number: for (int k = 0' i = 0; i < 8; i++)              {                  while (k < (2 << i))                  {                      MS1BTable[k++] = i;                  }              }
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,init,The following statement contains a magic number: for (int k = 0' i = 0; i < 8; i++)              {                  while (k < (2 << i))                  {                      MS1BTable[k++] = i;                  }              }
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,init,The following statement contains a magic number: for (Bitboard b = 0; b < 256; b++)              {                  BitCount8Bit[b] = (byte)(Bitcount.popcount_1s_Max15(b));              }
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,init,The following statement contains a magic number: for (int i = 1; i < 8; i++)              {                  FileBB[i] = FileBB[i - 1] << 1;                  RankBB[i] = RankBB[i - 1] << 8;              }
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,init,The following statement contains a magic number: for (int i = 1; i < 8; i++)              {                  FileBB[i] = FileBB[i - 1] << 1;                  RankBB[i] = RankBB[i - 1] << 8;              }
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,init,The following statement contains a magic number: InFrontBB[ColorC.WHITE] = new Bitboard[8];
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,init,The following statement contains a magic number: InFrontBB[ColorC.BLACK] = new Bitboard[8];
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,init,The following statement contains a magic number: for (Color c = ColorC.WHITE; c <= ColorC.BLACK; c++)              {                  ForwardBB[c] = new Bitboard[64];                  PassedPawnMask[c] = new Bitboard[64];                  AttackSpanMask[c] = new Bitboard[64];                  for (Square s = SquareC.SQ_A1; s <= SquareC.SQ_H8; s++)                  {                      ForwardBB[c][s] = InFrontBB[c][Utils.rank_of(s)] & FileBB[Utils.file_of(s)];                      PassedPawnMask[c][s] = InFrontBB[c][Utils.rank_of(s)] & ThisAndAdjacentFilesBB[Utils.file_of(s)];                      AttackSpanMask[c][s] = InFrontBB[c][Utils.rank_of(s)] & AdjacentFilesBB[Utils.file_of(s)];                  }              }
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,init,The following statement contains a magic number: for (Color c = ColorC.WHITE; c <= ColorC.BLACK; c++)              {                  ForwardBB[c] = new Bitboard[64];                  PassedPawnMask[c] = new Bitboard[64];                  AttackSpanMask[c] = new Bitboard[64];                  for (Square s = SquareC.SQ_A1; s <= SquareC.SQ_H8; s++)                  {                      ForwardBB[c][s] = InFrontBB[c][Utils.rank_of(s)] & FileBB[Utils.file_of(s)];                      PassedPawnMask[c][s] = InFrontBB[c][Utils.rank_of(s)] & ThisAndAdjacentFilesBB[Utils.file_of(s)];                      AttackSpanMask[c][s] = InFrontBB[c][Utils.rank_of(s)] & AdjacentFilesBB[Utils.file_of(s)];                  }              }
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,init,The following statement contains a magic number: for (Color c = ColorC.WHITE; c <= ColorC.BLACK; c++)              {                  ForwardBB[c] = new Bitboard[64];                  PassedPawnMask[c] = new Bitboard[64];                  AttackSpanMask[c] = new Bitboard[64];                  for (Square s = SquareC.SQ_A1; s <= SquareC.SQ_H8; s++)                  {                      ForwardBB[c][s] = InFrontBB[c][Utils.rank_of(s)] & FileBB[Utils.file_of(s)];                      PassedPawnMask[c][s] = InFrontBB[c][Utils.rank_of(s)] & ThisAndAdjacentFilesBB[Utils.file_of(s)];                      AttackSpanMask[c][s] = InFrontBB[c][Utils.rank_of(s)] & AdjacentFilesBB[Utils.file_of(s)];                  }              }
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,init,The following statement contains a magic number: for (Square s1 = SquareC.SQ_A1; s1 <= SquareC.SQ_H8; s1++)              {                  SquareDistance[s1] = new int[64];                  for (Square s2 = SquareC.SQ_A1; s2 <= SquareC.SQ_H8; s2++)                  {                      SquareDistance[s1][s2] = Math.Max(Utils.file_distance(s1' s2)' Utils.rank_distance(s1' s2));                  }              }
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,init,The following statement contains a magic number: for (int i = 0; i < 64; i++)              {                  BSFTable[((1UL << i) * 0x218A392CD3D5DBFUL) >> 58] = i;              }
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,init,The following statement contains a magic number: for (int i = 0; i < 64; i++)              {                  BSFTable[((1UL << i) * 0x218A392CD3D5DBFUL) >> 58] = i;              }
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,init,The following statement contains a magic number: for (Color c = ColorC.WHITE; c <= ColorC.BLACK; c++)              {                  for (PieceType pt = PieceTypeC.PAWN; pt <= PieceTypeC.KING; pt++)                  {                      Piece piece = Utils.make_piece(c' pt);                      StepAttacksBB[piece] = new Bitboard[64];                      for (Square s = SquareC.SQ_A1; s <= SquareC.SQ_H8; s++)                      {                          for (int k = 0; k < steps[pt].Length; k++)                          {                              Square to = s + (c == ColorC.WHITE ? steps[pt][k] : -steps[pt][k]);                              if (Utils.is_ok_S(to) && SquareDistance[s][to] < 3)                              {                                  StepAttacksBB[piece][s] |= SquareBB[to];                              }                          }                      }                  }              }
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,init,The following statement contains a magic number: for (Color c = ColorC.WHITE; c <= ColorC.BLACK; c++)              {                  for (PieceType pt = PieceTypeC.PAWN; pt <= PieceTypeC.KING; pt++)                  {                      Piece piece = Utils.make_piece(c' pt);                      StepAttacksBB[piece] = new Bitboard[64];                      for (Square s = SquareC.SQ_A1; s <= SquareC.SQ_H8; s++)                      {                          for (int k = 0; k < steps[pt].Length; k++)                          {                              Square to = s + (c == ColorC.WHITE ? steps[pt][k] : -steps[pt][k]);                              if (Utils.is_ok_S(to) && SquareDistance[s][to] < 3)                              {                                  StepAttacksBB[piece][s] |= SquareBB[to];                              }                          }                      }                  }              }
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,init,The following statement contains a magic number: for (int i = 0; i < 64; i++)              {                  StepAttacksBB_KING[i] = StepAttacksBB[PieceTypeC.KING][i];                  StepAttacksBB_KNIGHT[i] = StepAttacksBB[PieceTypeC.KNIGHT][i];              }
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,init,The following statement contains a magic number: for (int i = 0; i < 6; i++)              {                  PseudoAttacks[i] = new Bitboard[64];              }
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,init,The following statement contains a magic number: for (int i = 0; i < 6; i++)              {                  PseudoAttacks[i] = new Bitboard[64];              }
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,init,The following statement contains a magic number: for (Square s1 = SquareC.SQ_A1; s1 <= SquareC.SQ_H8; s1++)              {                  BetweenBB[s1] = new Bitboard[64];                  for (Square s2 = SquareC.SQ_A1; s2 <= SquareC.SQ_H8; s2++)                  {                      if ((PseudoAttacks[PieceTypeC.QUEEN][s1] & SquareBB[s2]) != 0)                      {                          Square delta = ((s2 - s1) / SquareDistance[s1][s2]);                          for (Square s = s1 + delta; s != s2; s += delta)                          {                              set_bit(ref BetweenBB[s1][s2]' s);                          }                      }                  }              }
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,sliding_attack,The following statement contains a magic number: for (int i = 0; i < 4; i++)                  for (Square s = sq + deltas[i];                       is_ok_S(s) && square_distance(s' s - deltas[i]) == 1;                       s += deltas[i])                  {                      Utils.set_bit(ref attack' s);                        if (Utils.bit_is_set(occupied' s) != 0)                          break;                  }
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,pick_random,The following statement contains a magic number: int s1 = booster & 63' s2 = (booster >> 6) & 63;
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,pick_random,The following statement contains a magic number: int s1 = booster & 63' s2 = (booster >> 6) & 63;
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,pick_random,The following statement contains a magic number: int s1 = booster & 63' s2 = (booster >> 6) & 63;
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,pick_random,The following statement contains a magic number: while (true)              {                  magic = rk.rand();                  magic = (magic >> s1) | (magic << (64 - s1));                  magic &= rk.rand();                  magic = (magic >> s2) | (magic << (64 - s2));                  magic &= rk.rand();                    if (BitCount8Bit[(mask * magic) >> 56] >= 6)                      return magic;              }
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,pick_random,The following statement contains a magic number: while (true)              {                  magic = rk.rand();                  magic = (magic >> s1) | (magic << (64 - s1));                  magic &= rk.rand();                  magic = (magic >> s2) | (magic << (64 - s2));                  magic &= rk.rand();                    if (BitCount8Bit[(mask * magic) >> 56] >= 6)                      return magic;              }
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,pick_random,The following statement contains a magic number: while (true)              {                  magic = rk.rand();                  magic = (magic >> s1) | (magic << (64 - s1));                  magic &= rk.rand();                  magic = (magic >> s2) | (magic << (64 - s2));                  magic &= rk.rand();                    if (BitCount8Bit[(mask * magic) >> 56] >= 6)                      return magic;              }
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,pick_random,The following statement contains a magic number: while (true)              {                  magic = rk.rand();                  magic = (magic >> s1) | (magic << (64 - s1));                  magic &= rk.rand();                  magic = (magic >> s2) | (magic << (64 - s2));                  magic &= rk.rand();                    if (BitCount8Bit[(mask * magic) >> 56] >= 6)                      return magic;              }
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,init_magics,The following statement contains a magic number: for (Square s = SquareC.SQ_A1; s <= SquareC.SQ_H8; s++)              {                  // Board edges are not considered in the relevant occupancies                  edges = ((Constants.Rank1BB | Constants.Rank8BB) & ~Utils.rank_bb_S(s)) | ((Constants.FileABB | Constants.FileHBB) & ~Utils.file_bb_S(s));                    // Given a square 's'' the mask is the bitboard of sliding attacks from                  // 's' computed on an empty board. The index must be big enough to contain                  // all the attacks for each possible subset of the mask and so is 2 power                  // the number of 1s of the mask. Hence we deduce the size of the shift to                  // apply to the 64 or 32 bits word to get the index.                  masks[s] = sliding_attack(deltas' s' 0) & ~edges;    #if X64                  shifts[s] = 64 - Bitcount.popcount_1s_Max15(masks[s]);  #else                  shifts[s] = 32 - Bitcount.popcount_1s_Max15(masks[s]);  #endif                    // Use Carry-Rippler trick to enumerate all subsets of masks[s] and                  // store the corresponding sliding attack bitboard in reference[].                  b = 0; size = 0;                  do                  {                      occupancy[size] = b;                      reference[size++] = sliding_attack(deltas' s' b);                      b = (b - masks[s]) & masks[s];                  } while (b != 0);                    // Set the offset for the table of the next square. We have individual                  // table sizes for each square with "Fancy Magic Bitboards".  #if X64                  booster = MagicBoosters[1][rank_of(s)];  #else                  booster = MagicBoosters[0][rank_of(s)];  #endif                    attacks[s] = new Bitboard[size];                    // Find a magic for square 's' picking up an (almost) random number                  // until we find the one that passes the verification test.                  do                  {                      magics[s] = pick_random(masks[s]' rk' booster);                      Array.Clear(attacks[s]' 0' size);                        // A good magic must map every possible occupancy to an index that                      // looks up the correct sliding attack in the attacks[s] database.                      // Note that we build up the database for square 's' as a side                      // effect of verifying the magic.                      for (i = 0; i < size; i++)                      {                          uint idx = index(Pt' s' occupancy[i]);                            Bitboard attack = attacks[s][idx];                            if ((attack != 0) && attack != reference[i])                              break;                            attacks[s][idx] = reference[i];                      }                  }                  while (i != size);              }
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,pop_1st_bit,The following statement contains a magic number: return (BSFTable[((bb & (0xffffffffffffffff - bb + 1)) * 0x218A392CD3D5DBFUL) >> 58]);
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,first_1,The following statement contains a magic number: return BSFTable[((b & (0xffffffffffffffff - b + 1)) * 0x218A392CD3D5DBFUL) >> 58];
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,last_1,The following statement contains a magic number: if (b > 0xFFFFFFFF)              {                  b >>= 32;                  result = 32;              }
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,last_1,The following statement contains a magic number: if (b > 0xFFFFFFFF)              {                  b >>= 32;                  result = 32;              }
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,last_1,The following statement contains a magic number: if (b > 0xFFFF)              {                  b >>= 16;                  result += 16;              }
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,last_1,The following statement contains a magic number: if (b > 0xFFFF)              {                  b >>= 16;                  result += 16;              }
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,last_1,The following statement contains a magic number: if (b > 0xFF)              {                  b >>= 8;                  result += 8;              }
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,last_1,The following statement contains a magic number: if (b > 0xFF)              {                  b >>= 8;                  result += 8;              }
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,make_piece,The following statement contains a magic number: return ((c << 3) | pt);
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,type_of,The following statement contains a magic number: return (p & 7);
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,color_of,The following statement contains a magic number: return (p >> 3);
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,make_square,The following statement contains a magic number: return ((r << 3) | f);
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,file_of,The following statement contains a magic number: return (s & 7);
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,rank_of,The following statement contains a magic number: return (s >> 3);
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,flip_S,The following statement contains a magic number: return (s ^ 56);
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,mirror,The following statement contains a magic number: return (s ^ 7);
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,relative_square,The following statement contains a magic number: return (s ^ (c * 56));
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,relative_rank_CR,The following statement contains a magic number: return (r ^ (c * 7));
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,relative_rank_CS,The following statement contains a magic number: return ((s >> 3) ^ (c * 7));
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,relative_rank_CS,The following statement contains a magic number: return ((s >> 3) ^ (c * 7));
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,opposite_colors,The following statement contains a magic number: return (((s >> 3) ^ s) & 1) != 0;
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,from_sq,The following statement contains a magic number: return ((m >> 6) & 0x3F);
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,is_special,The following statement contains a magic number: return (m & (3 << 14)) != 0;
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,is_special,The following statement contains a magic number: return (m & (3 << 14)) != 0;
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,is_promotion,The following statement contains a magic number: return (m & (3 << 14)) == (1 << 14);
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,is_promotion,The following statement contains a magic number: return (m & (3 << 14)) == (1 << 14);
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,is_promotion,The following statement contains a magic number: return (m & (3 << 14)) == (1 << 14);
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,is_enpassant,The following statement contains a magic number: return (m & (3 << 14)) == (2 << 14);
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,is_enpassant,The following statement contains a magic number: return (m & (3 << 14)) == (2 << 14);
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,is_enpassant,The following statement contains a magic number: return (m & (3 << 14)) == (2 << 14);
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,is_enpassant,The following statement contains a magic number: return (m & (3 << 14)) == (2 << 14);
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,is_castle,The following statement contains a magic number: return (m & (3 << 14)) == (3 << 14);
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,is_castle,The following statement contains a magic number: return (m & (3 << 14)) == (3 << 14);
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,is_castle,The following statement contains a magic number: return (m & (3 << 14)) == (3 << 14);
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,is_castle,The following statement contains a magic number: return (m & (3 << 14)) == (3 << 14);
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,promotion_type,The following statement contains a magic number: return (((m >> 12) & 3) + 2);
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,promotion_type,The following statement contains a magic number: return (((m >> 12) & 3) + 2);
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,promotion_type,The following statement contains a magic number: return (((m >> 12) & 3) + 2);
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,make_move,The following statement contains a magic number: return (to | (from << 6));
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,make_promotion,The following statement contains a magic number: return (to | (from << 6) | (1 << 14) | ((pt - 2) << 12));
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,make_promotion,The following statement contains a magic number: return (to | (from << 6) | (1 << 14) | ((pt - 2) << 12));
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,make_promotion,The following statement contains a magic number: return (to | (from << 6) | (1 << 14) | ((pt - 2) << 12));
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,make_promotion,The following statement contains a magic number: return (to | (from << 6) | (1 << 14) | ((pt - 2) << 12));
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,make_enpassant,The following statement contains a magic number: return (to | (from << 6) | (2 << 14));
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,make_enpassant,The following statement contains a magic number: return (to | (from << 6) | (2 << 14));
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,make_enpassant,The following statement contains a magic number: return (to | (from << 6) | (2 << 14));
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,make_castle,The following statement contains a magic number: return (to | (from << 6) | (3 << 14));
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,make_castle,The following statement contains a magic number: return (to | (from << 6) | (3 << 14));
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,make_castle,The following statement contains a magic number: return (to | (from << 6) | (3 << 14));
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,make_castle_right,The following statement contains a magic number: return CastleRightC.WHITE_OO << ((s == CastlingSideC.QUEEN_SIDE ? 1 : 0) + 2 * c);
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,engine_info,The following statement contains a magic number: string versionRaw = fullName.Substring(vspos + 8' vepos - vspos - 8);
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,engine_info,The following statement contains a magic number: string versionRaw = fullName.Substring(vspos + 8' vepos - vspos - 8);
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,engine_info,The following statement contains a magic number: DateTime buildDateTime = new DateTime(2000' 1' 1).Add(                  new TimeSpan(                      TimeSpan.TicksPerDay * version.Build + // days since 1 January 2000                      TimeSpan.TicksPerSecond * 2 * version.Revision));
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,engine_info,The following statement contains a magic number: DateTime buildDateTime = new DateTime(2000' 1' 1).Add(                  new TimeSpan(                      TimeSpan.TicksPerDay * version.Build + // days since 1 January 2000                      TimeSpan.TicksPerSecond * 2 * version.Revision));
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,engine_info,The following statement contains a magic number: string versionInfo = buildDateTime.Year.ToString() + buildDateTime.Month.ToString().PadLeft(2' '0') + buildDateTime.Day.ToString().PadLeft(2' '0');
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,engine_info,The following statement contains a magic number: string versionInfo = buildDateTime.Year.ToString() + buildDateTime.Month.ToString().PadLeft(2' '0') + buildDateTime.Day.ToString().PadLeft(2' '0');
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,move_to_uci,The following statement contains a magic number: if (is_castle(m) && !chess960)                  to = from + (file_of(to) == FileC.FILE_H ? 2 : -2);
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,move_to_uci,The following statement contains a magic number: if (is_castle(m) && !chess960)                  to = from + (file_of(to) == FileC.FILE_H ? 2 : -2);
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,move_from_uci,The following statement contains a magic number: string strLowerPromotion = (str.Length == 5 ? str.Substring(0' 4) + str.Substring(4).ToLowerInvariant() : str);
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,move_from_uci,The following statement contains a magic number: string strLowerPromotion = (str.Length == 5 ? str.Substring(0' 4) + str.Substring(4).ToLowerInvariant() : str);
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,move_from_uci,The following statement contains a magic number: string strLowerPromotion = (str.Length == 5 ? str.Substring(0' 4) + str.Substring(4).ToLowerInvariant() : str);
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,make_score,The following statement contains a magic number: return ((mg << 16) + eg);
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,mg_value,The following statement contains a magic number: return (((s + 32768) & ~0xffff) / 0x10000);
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,apply_weight,The following statement contains a magic number: return (((((int)((((v + 32768) & ~0xffff) / 0x10000)) * (((w + 32768) & ~0xffff) / 0x10000)) / 0x100) << 16) + (((int)(((Int16)(v & 0xffff))) * ((Int16)(w & 0xffff))) / 0x100));
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,apply_weight,The following statement contains a magic number: return (((((int)((((v + 32768) & ~0xffff) / 0x10000)) * (((w + 32768) & ~0xffff) / 0x10000)) / 0x100) << 16) + (((int)(((Int16)(v & 0xffff))) * ((Int16)(w & 0xffff))) / 0x100));
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,apply_weight,The following statement contains a magic number: return (((((int)((((v + 32768) & ~0xffff) / 0x10000)) * (((w + 32768) & ~0xffff) / 0x10000)) / 0x100) << 16) + (((int)(((Int16)(v & 0xffff))) * ((Int16)(w & 0xffff))) / 0x100));
Magic Number,Portfish,Utils,C:\repos\bpfliegel_Portfish\src\Utils.cs,dbg_print,The following statement contains a magic number: if (hits[0] != 0)              {                  Plug.Write("Total ");                  Plug.Write(hits[0].ToString());                  Plug.Write(" Hits ");                  Plug.Write(hits[1].ToString());                  Plug.Write(" hit rate (%) ");                  Plug.Write((100 * hits[1] / hits[0]).ToString());                  Plug.Write(Constants.endl);              }
Duplicate Code,Portfish,Book,C:\repos\bpfliegel_Portfish\src\Book.cs,probe,The method contains a code clone-set at the following line numbers (starting from the method definition): ((21' 40)' (61' 80))
