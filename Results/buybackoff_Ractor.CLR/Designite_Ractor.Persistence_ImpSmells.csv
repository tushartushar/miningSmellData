Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Ractor,DatabasePersistor,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\DatabasePersistor.cs,CheckOrGenerateGuid,Cyclomatic complexity of the method is 8
Complex Method,Ractor,DummyEncryptor,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Encryption.cs,Encrypt,Cyclomatic complexity of the method is 8
Complex Method,Ractor,DummyEncryptor,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Encryption.cs,Decrypt,Cyclomatic complexity of the method is 8
Long Parameter List,Ractor,DatabasePersistor,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\DatabasePersistor.cs,DatabasePersistor,The method has 6 parameters. Parameters: connectionName' migrationConfig' distributedMigrationConfig' readOnlyShards' guidType' updateMigrations
Long Parameter List,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,LInsert,The method has 6 parameters. Parameters: root' after' pivot' value' listKey' fireAndForget
Long Parameter List,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,LInsertAsync,The method has 6 parameters. Parameters: root' after' pivot' value' listKey' fireAndForget
Long Parameter List,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,LInsert,The method has 5 parameters. Parameters: fullKey' after' pivot' value' fireAndForget
Long Parameter List,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,LInsertAsync,The method has 5 parameters. Parameters: fullKey' after' pivot' value' fireAndForget
Long Parameter List,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,LPush,The method has 5 parameters. Parameters: root' value' listKey' when' fireAndForget
Long Parameter List,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,LPushAsync,The method has 5 parameters. Parameters: root' value' listKey' when' fireAndForget
Long Parameter List,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,LRem,The method has 5 parameters. Parameters: root' count' value' listKey' fireAndForget
Long Parameter List,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,LRemAsync,The method has 5 parameters. Parameters: root' count' value' listKey' fireAndForget
Long Parameter List,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,LSet,The method has 5 parameters. Parameters: root' index' value' listKey' fireAndForget
Long Parameter List,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,LSetAsync,The method has 5 parameters. Parameters: root' index' value' listKey' fireAndForget
Long Parameter List,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,RPush,The method has 5 parameters. Parameters: root' value' listKey' when' fireAndForget
Long Parameter List,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,RPushAsync,The method has 5 parameters. Parameters: root' value' listKey' when' fireAndForget
Long Parameter List,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,HSet,The method has 5 parameters. Parameters: root' valueWithKey' hashKey' when' fireAndForget
Long Parameter List,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,HSetAsync,The method has 5 parameters. Parameters: root' valueWithKey' hashKey' when' fireAndForget
Long Parameter List,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,HSet,The method has 6 parameters. Parameters: root' field' value' hashKey' when' fireAndForget
Long Parameter List,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,HSetAsync,The method has 6 parameters. Parameters: root' field' value' hashKey' when' fireAndForget
Long Parameter List,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,HSet,The method has 5 parameters. Parameters: fullKey' field' value' when' fireAndForget
Long Parameter List,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,HSetAsync,The method has 5 parameters. Parameters: fullKey' field' value' when' fireAndForget
Long Parameter List,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,SAdd,The method has 5 parameters. Parameters: root' value' listKey' when' fireAndForget
Long Parameter List,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,SAddAsync,The method has 5 parameters. Parameters: root' value' listKey' when' fireAndForget
Long Parameter List,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,Set,The method has 5 parameters. Parameters: fullKey' value' expiry' when' fireAndForget
Long Parameter List,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,SetAsync,The method has 5 parameters. Parameters: fullKey' value' expiry' when' fireAndForget
Long Parameter List,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,Set,The method has 5 parameters. Parameters: root' valueWithKey' expiry' when' fireAndForget
Long Parameter List,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,SetAsync,The method has 5 parameters. Parameters: root' value' expiry' when' fireAndForget
Long Parameter List,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,Set,The method has 6 parameters. Parameters: root' stringKey' value' expiry' when' fireAndForget
Long Parameter List,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,SetAsync,The method has 6 parameters. Parameters: root' stringKey' value' expiry' when' fireAndForget
Long Statement,Ractor,RedisAsyncDictionary<T>,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\RedisAsyncDictionary.cs,TryFill,The length of the statement  "            return await _redis.SetAsync<T>(fullKey' value' (_timeout > 0 ? TimeSpan.FromMilliseconds(_timeout) : (TimeSpan?)null)' When.Always' false); " is 140.
Long Statement,Ractor,RedisAsyncDictionary<T>,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\RedisAsyncDictionary.cs,TryTake,The length of the statement  "                    // we dont'care who was the first' we recheck the result either on a signal or on retry timeout' but need to check for timeout " is 126.
Long Statement,Ractor,DatabasePersistor,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\DatabasePersistor.cs,Select,The length of the statement  "            return Query<T' List<T>>(db => (predicate == null ? db : db.Where(predicate)).ToList()' result => result.SelectMany(x => x).ToList()); " is 134.
Long Statement,Ractor,DatabasePersistor,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\DatabasePersistor.cs,GetByIds,The length of the statement  "            return Query<T' List<T>>(db => db.Where(t => guids.Contains(t.Id)).ToList()' result => result.SelectMany(x => x).ToList()); " is 123.
Long Statement,Ractor,DatabasePersistor,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\DatabasePersistor.cs,CheckOrGenerateGuid,The length of the statement  "                if (onlyWritable && _readOnlyShards.Contains(bucket)) throw new ReadOnlyException("Could not write to shard: " + bucket); " is 121.
Long Statement,Ractor,DatabasePersistor,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\DatabasePersistor.cs,CheckOrGenerateGuid,The length of the statement  "                    if (onlyWritable && _readOnlyShards.Contains(bucket)) throw new ReadOnlyException("Could not write to shard: " + bucket); " is 121.
Long Statement,Ractor,GuidGenerator,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\GuidGenerator.cs,GuidSequentialArray,The length of the statement  "            //if (bucket > 63) throw new ArgumentOutOfRangeException("bucket"' "Bucket is too large! 64 buckets ought to be enough for anybody!"); " is 134.
Long Statement,Ractor,DummyEncryptor,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Encryption.cs,Encrypt,The length of the statement  "            if (copy.IsEncrypted) throw new ApplicationException("Already encrypted"); // "return deepClone;" - could hide logic errors' need to throw here " is 143.
Long Statement,Ractor,DummyEncryptor,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Encryption.cs,Decrypt,The length of the statement  "            if (!copy.IsEncrypted) throw new ApplicationException("Already decrypted"); // "return deepClone;" - could hide logic errors' need to throw here " is 144.
Long Statement,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,RPopLPush,The length of the statement  "            var kDestination = _nameSpace + GetItemFullKey(destination) + ":lists:" + (destinationListName ?? GetTypePrefix<TValue>()); " is 123.
Long Statement,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,RPopLPushAsync,The length of the statement  "            var kDestination = _nameSpace + GetItemFullKey(destination) + ":lists:" + (destinationListName ?? GetTypePrefix<TValue>()); " is 123.
Long Statement,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,SDiff,The length of the statement  "            var k = listKeys.Select(listKey => (RedisKey)(_nameSpace + GetItemFullKey(root) + ":lists:" + (listKey ?? GetTypePrefix<TValue>()))).ToArray(); " is 143.
Long Statement,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,SDiffAsync,The length of the statement  "            var k = listKeys.Select(listKey => (RedisKey)(_nameSpace + GetItemFullKey(root) + ":lists:" + (listKey ?? GetTypePrefix<TValue>()))).ToArray(); " is 143.
Long Statement,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,SDiffStore,The length of the statement  "            var k = listKeys.Select(listKey => (RedisKey)(_nameSpace + GetItemFullKey(root) + ":lists:" + (listKey ?? GetTypePrefix<TValue>()))).ToArray(); " is 143.
Long Statement,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,SDiffStoreAsync,The length of the statement  "            var k = listKeys.Select(listKey => (RedisKey)(_nameSpace + GetItemFullKey(root) + ":lists:" + (listKey ?? GetTypePrefix<TValue>()))).ToArray(); " is 143.
Long Statement,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,SInter,The length of the statement  "            var k = listKeys.Select(listKey => (RedisKey)(_nameSpace + GetItemFullKey(root) + ":lists:" + (listKey ?? GetTypePrefix<TValue>()))).ToArray(); " is 143.
Long Statement,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,SInterAsync,The length of the statement  "            var k = listKeys.Select(listKey => (RedisKey)(_nameSpace + GetItemFullKey(root) + ":lists:" + (listKey ?? GetTypePrefix<TValue>()))).ToArray(); " is 143.
Long Statement,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,SInterStore,The length of the statement  "            var k = listKeys.Select(listKey => (RedisKey)(_nameSpace + GetItemFullKey(root) + ":lists:" + (listKey ?? GetTypePrefix<TValue>()))).ToArray(); " is 143.
Long Statement,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,SInterStoreAsync,The length of the statement  "            var k = listKeys.Select(listKey => (RedisKey)(_nameSpace + GetItemFullKey(root) + ":lists:" + (listKey ?? GetTypePrefix<TValue>()))).ToArray(); " is 143.
Long Statement,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,SUnion,The length of the statement  "            var k = listKeys.Select(listKey => (RedisKey)(_nameSpace + GetItemFullKey(root) + ":lists:" + (listKey ?? GetTypePrefix<TValue>()))).ToArray(); " is 143.
Long Statement,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,SUnionAsync,The length of the statement  "            var k = listKeys.Select(listKey => (RedisKey)(_nameSpace + GetItemFullKey(root) + ":lists:" + (listKey ?? GetTypePrefix<TValue>()))).ToArray(); " is 143.
Long Statement,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,SUnionStore,The length of the statement  "            var k = listKeys.Select(listKey => (RedisKey)(_nameSpace + GetItemFullKey(root) + ":lists:" + (listKey ?? GetTypePrefix<TValue>()))).ToArray(); " is 143.
Long Statement,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,SUnionStoreAsync,The length of the statement  "            var k = listKeys.Select(listKey => (RedisKey)(_nameSpace + GetItemFullKey(root) + ":lists:" + (listKey ?? GetTypePrefix<TValue>()))).ToArray(); " is 143.
Long Statement,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,MGet,The length of the statement  "            var k = stringKeys.Select(stringKey => (RedisKey)(_nameSpace + GetItemFullKey(root) + ":strings:" + stringKey)).ToArray(); " is 122.
Long Statement,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,MGetAsync,The length of the statement  "            var k = stringKeys.Select(stringKey => (RedisKey)(_nameSpace + GetItemFullKey(root) + ":strings:" + stringKey)).ToArray(); " is 122.
Long Statement,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,Set,The length of the statement  "                new KeyValuePair<RedisKey' RedisValue>(_nameSpace + GetItemFullKey(root) + ":strings:" + (valueWithKey.Key ?? GetItemKey(valueWithKey.Value))' " is 142.
Long Statement,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,SetAsync,The length of the statement  "                new KeyValuePair<RedisKey' RedisValue>(_nameSpace + GetItemFullKey(root) + ":strings:" + (valueWithKey.Key ?? GetItemKey(valueWithKey.Value))' " is 142.
Long Statement,Ractor,CacheInfo,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.cs,GetKey,The length of the statement  "                if (PrimaryKeyProperty == null) throw new Exception("Cannot determine cache key. Add CacheKey or PrimaryKey attribute to a key property"); " is 138.
Long Statement,Ractor,WaitHandleExtensions,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Utils\Utils.cs,WaitAsync,The length of the statement  "            tcs.Task.ContinueWith((_' state) => ((RegisteredWaitHandle)state).Unregister(null)' registration' TaskScheduler.Default); " is 121.
Empty Catch Block,Ractor,RedisAsyncDictionary<T>,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\RedisAsyncDictionary.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Ractor,RedisQueue<T>,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\RedisQueue.cs,Dispose,The method has an empty catch block.
Magic Number,Ractor,RedisAsyncDictionary<T>,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\RedisAsyncDictionary.cs,TryTake,The following statement contains a magic number: var timeout = (int)Math.Pow(2' Math.Min(attemts + 6' 20));
Magic Number,Ractor,RedisAsyncDictionary<T>,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\RedisAsyncDictionary.cs,TryTake,The following statement contains a magic number: var timeout = (int)Math.Pow(2' Math.Min(attemts + 6' 20));
Magic Number,Ractor,RedisAsyncDictionary<T>,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\RedisAsyncDictionary.cs,TryTake,The following statement contains a magic number: var timeout = (int)Math.Pow(2' Math.Min(attemts + 6' 20));
Magic Number,Ractor,RedisQueue<T>,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\RedisQueue.cs,RedisQueue,The following statement contains a magic number: Task.Run(async () => {                  if (_timeout <= 0) {                      // TODO instead of artifitial defaults' without timeout start monitoring                      // the length of the pipeline                      return;                  }                  // NB We need some finite timeout to clean up                  // However' the best practice is to set it                  var staleTimeout = _timeout > 0 ? _timeout : 60 * 60 * 1000;                  while (!_cts.Token.IsCancellationRequested) {                      const string pipelineScript = @"                          local previousKey = KEYS[1]..':previousKeys'                          local currentKey = KEYS[1]..':currentKeys'                          local currentItems = redis.call('HKEYS'' KEYS[1])                          local res = 0                          redis.call('DEL'' currentKey)                          if redis.call('HLEN'' KEYS[1]) > 0 then                             redis.call('SADD'' currentKey' unpack(currentItems))                             local intersect                             if redis.call('SCARD'' previousKey) > 0 then                                 intersect = redis.call('SINTER'' previousKey' currentKey)                                 if #intersect > 0 then                                      local values = redis.call('HMGET'' KEYS[1]' unpack(intersect))                                      redis.call('RPUSH'' KEYS[2]' unpack(values))                                      redis.call('HDEL'' KEYS[1]' unpack(intersect))                                      res = #intersect                                 end                             end                          end                          redis.call('DEL'' previousKey)                          if #currentItems > 0 then                              redis.call('SADD'' previousKey' unpack(currentItems))                          end                          return res                          ";                        var expiry = TimeSpan.FromMilliseconds(staleTimeout);                      var entered = redis.Set<string>(_lockKey' "collecting garbage"'                          expiry' When.NotExists' false);                      //Console.WriteLine("checking if entered: " + entered.ToString())                      if (entered && _started) {                          // ReSharper disable once UnusedVariable                          var n = redis.Eval<int>(pipelineScript' new[] { redis.KeyNameSpace + _pipelineKey' _inboxKey });                          //Console.WriteLine($"Returned from pipeline: {n}");                      }                        await Task.Delay(staleTimeout);                  }              }' _cts.Token);
Magic Number,Ractor,RedisQueue<T>,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\RedisQueue.cs,RedisQueue,The following statement contains a magic number: Task.Run(async () => {                  if (_timeout <= 0) {                      // TODO instead of artifitial defaults' without timeout start monitoring                      // the length of the pipeline                      return;                  }                  // NB We need some finite timeout to clean up                  // However' the best practice is to set it                  var staleTimeout = _timeout > 0 ? _timeout : 60 * 60 * 1000;                  while (!_cts.Token.IsCancellationRequested) {                      const string pipelineScript = @"                          local previousKey = KEYS[1]..':previousKeys'                          local currentKey = KEYS[1]..':currentKeys'                          local currentItems = redis.call('HKEYS'' KEYS[1])                          local res = 0                          redis.call('DEL'' currentKey)                          if redis.call('HLEN'' KEYS[1]) > 0 then                             redis.call('SADD'' currentKey' unpack(currentItems))                             local intersect                             if redis.call('SCARD'' previousKey) > 0 then                                 intersect = redis.call('SINTER'' previousKey' currentKey)                                 if #intersect > 0 then                                      local values = redis.call('HMGET'' KEYS[1]' unpack(intersect))                                      redis.call('RPUSH'' KEYS[2]' unpack(values))                                      redis.call('HDEL'' KEYS[1]' unpack(intersect))                                      res = #intersect                                 end                             end                          end                          redis.call('DEL'' previousKey)                          if #currentItems > 0 then                              redis.call('SADD'' previousKey' unpack(currentItems))                          end                          return res                          ";                        var expiry = TimeSpan.FromMilliseconds(staleTimeout);                      var entered = redis.Set<string>(_lockKey' "collecting garbage"'                          expiry' When.NotExists' false);                      //Console.WriteLine("checking if entered: " + entered.ToString())                      if (entered && _started) {                          // ReSharper disable once UnusedVariable                          var n = redis.Eval<int>(pipelineScript' new[] { redis.KeyNameSpace + _pipelineKey' _inboxKey });                          //Console.WriteLine($"Returned from pipeline: {n}");                      }                        await Task.Delay(staleTimeout);                  }              }' _cts.Token);
Magic Number,Ractor,RedisQueue<T>,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\RedisQueue.cs,RedisQueue,The following statement contains a magic number: Task.Run(async () => {                  if (_timeout <= 0) {                      // TODO instead of artifitial defaults' without timeout start monitoring                      // the length of the pipeline                      return;                  }                  // NB We need some finite timeout to clean up                  // However' the best practice is to set it                  var staleTimeout = _timeout > 0 ? _timeout : 60 * 60 * 1000;                  while (!_cts.Token.IsCancellationRequested) {                      const string pipelineScript = @"                          local previousKey = KEYS[1]..':previousKeys'                          local currentKey = KEYS[1]..':currentKeys'                          local currentItems = redis.call('HKEYS'' KEYS[1])                          local res = 0                          redis.call('DEL'' currentKey)                          if redis.call('HLEN'' KEYS[1]) > 0 then                             redis.call('SADD'' currentKey' unpack(currentItems))                             local intersect                             if redis.call('SCARD'' previousKey) > 0 then                                 intersect = redis.call('SINTER'' previousKey' currentKey)                                 if #intersect > 0 then                                      local values = redis.call('HMGET'' KEYS[1]' unpack(intersect))                                      redis.call('RPUSH'' KEYS[2]' unpack(values))                                      redis.call('HDEL'' KEYS[1]' unpack(intersect))                                      res = #intersect                                 end                             end                          end                          redis.call('DEL'' previousKey)                          if #currentItems > 0 then                              redis.call('SADD'' previousKey' unpack(currentItems))                          end                          return res                          ";                        var expiry = TimeSpan.FromMilliseconds(staleTimeout);                      var entered = redis.Set<string>(_lockKey' "collecting garbage"'                          expiry' When.NotExists' false);                      //Console.WriteLine("checking if entered: " + entered.ToString())                      if (entered && _started) {                          // ReSharper disable once UnusedVariable                          var n = redis.Eval<int>(pipelineScript' new[] { redis.KeyNameSpace + _pipelineKey' _inboxKey });                          //Console.WriteLine($"Returned from pipeline: {n}");                      }                        await Task.Delay(staleTimeout);                  }              }' _cts.Token);
Magic Number,Ractor,RedisQueue<T>,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\RedisQueue.cs,TryReceiveMessage,The following statement contains a magic number: var timeout = (int)Math.Pow(2' Math.Min(attemts + 3' 20));
Magic Number,Ractor,RedisQueue<T>,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\RedisQueue.cs,TryReceiveMessage,The following statement contains a magic number: var timeout = (int)Math.Pow(2' Math.Min(attemts + 3' 20));
Magic Number,Ractor,RedisQueue<T>,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\RedisQueue.cs,TryReceiveMessage,The following statement contains a magic number: var timeout = (int)Math.Pow(2' Math.Min(attemts + 3' 20));
Magic Number,Ractor,DatabasePersistor,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\DatabasePersistor.cs,CheckShardsAndSetEpoch,The following statement contains a magic number: numberOfShards > 254
Magic Number,Ractor,Config,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Config.cs,IsRunningOnAWS,The following statement contains a magic number: wr.Timeout = 250;
Magic Number,Ractor,GuidGenerator,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\GuidGenerator.cs,NewRandomBucketGuid,The following statement contains a magic number: return new Guid(GuidSequentialArray((byte)Rng.Next(1' 256)' guidType' utcDateTime));
Magic Number,Ractor,GuidGenerator,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\GuidGenerator.cs,NewBucketGuid,The following statement contains a magic number: return new Guid(GuidSequentialArray(rootGuid.ToByteArray()[8]' guidType));
Magic Number,Ractor,GuidGenerator,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\GuidGenerator.cs,GuidSequentialArray,The following statement contains a magic number: switch (guidType) {                  case SequentialGuidType.SequentialAsString:                  case SequentialGuidType.SequentialAsBinary:                      Array.Copy(ticksArray' 1' bytes' 0' 7); // 7 bytes for ticks ~ 228 years                        // If formatting as a string' we have to reverse the order                      // of the Data1 and Data2 blocks on little-endian systems.                      if (guidType == SequentialGuidType.SequentialAsString && BitConverter.IsLittleEndian) {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                    case SequentialGuidType.SequentialAtEnd:                      Buffer.BlockCopy(ticksArray' 1' bytes' 9' 7);                      break;              }
Magic Number,Ractor,GuidGenerator,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\GuidGenerator.cs,GuidSequentialArray,The following statement contains a magic number: switch (guidType) {                  case SequentialGuidType.SequentialAsString:                  case SequentialGuidType.SequentialAsBinary:                      Array.Copy(ticksArray' 1' bytes' 0' 7); // 7 bytes for ticks ~ 228 years                        // If formatting as a string' we have to reverse the order                      // of the Data1 and Data2 blocks on little-endian systems.                      if (guidType == SequentialGuidType.SequentialAsString && BitConverter.IsLittleEndian) {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                    case SequentialGuidType.SequentialAtEnd:                      Buffer.BlockCopy(ticksArray' 1' bytes' 9' 7);                      break;              }
Magic Number,Ractor,GuidGenerator,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\GuidGenerator.cs,GuidSequentialArray,The following statement contains a magic number: switch (guidType) {                  case SequentialGuidType.SequentialAsString:                  case SequentialGuidType.SequentialAsBinary:                      Array.Copy(ticksArray' 1' bytes' 0' 7); // 7 bytes for ticks ~ 228 years                        // If formatting as a string' we have to reverse the order                      // of the Data1 and Data2 blocks on little-endian systems.                      if (guidType == SequentialGuidType.SequentialAsString && BitConverter.IsLittleEndian) {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                    case SequentialGuidType.SequentialAtEnd:                      Buffer.BlockCopy(ticksArray' 1' bytes' 9' 7);                      break;              }
Magic Number,Ractor,GuidGenerator,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\GuidGenerator.cs,GuidSequentialArray,The following statement contains a magic number: switch (guidType) {                  case SequentialGuidType.SequentialAsString:                  case SequentialGuidType.SequentialAsBinary:                      Array.Copy(ticksArray' 1' bytes' 0' 7); // 7 bytes for ticks ~ 228 years                        // If formatting as a string' we have to reverse the order                      // of the Data1 and Data2 blocks on little-endian systems.                      if (guidType == SequentialGuidType.SequentialAsString && BitConverter.IsLittleEndian) {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                    case SequentialGuidType.SequentialAtEnd:                      Buffer.BlockCopy(ticksArray' 1' bytes' 9' 7);                      break;              }
Magic Number,Ractor,GuidGenerator,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\GuidGenerator.cs,GuidSequentialArray,The following statement contains a magic number: switch (guidType) {                  case SequentialGuidType.SequentialAsString:                  case SequentialGuidType.SequentialAsBinary:                      Array.Copy(ticksArray' 1' bytes' 0' 7); // 7 bytes for ticks ~ 228 years                        // If formatting as a string' we have to reverse the order                      // of the Data1 and Data2 blocks on little-endian systems.                      if (guidType == SequentialGuidType.SequentialAsString && BitConverter.IsLittleEndian) {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                    case SequentialGuidType.SequentialAtEnd:                      Buffer.BlockCopy(ticksArray' 1' bytes' 9' 7);                      break;              }
Magic Number,Ractor,GuidGenerator,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\GuidGenerator.cs,GuidSequentialArray,The following statement contains a magic number: switch (guidType) {                  case SequentialGuidType.SequentialAsString:                  case SequentialGuidType.SequentialAsBinary:                      Array.Copy(ticksArray' 1' bytes' 0' 7); // 7 bytes for ticks ~ 228 years                        // If formatting as a string' we have to reverse the order                      // of the Data1 and Data2 blocks on little-endian systems.                      if (guidType == SequentialGuidType.SequentialAsString && BitConverter.IsLittleEndian) {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                    case SequentialGuidType.SequentialAtEnd:                      Buffer.BlockCopy(ticksArray' 1' bytes' 9' 7);                      break;              }
Magic Number,Ractor,GuidGenerator,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\GuidGenerator.cs,GuidSequentialArray,The following statement contains a magic number: switch (guidType) {                  case SequentialGuidType.SequentialAsString:                  case SequentialGuidType.SequentialAsBinary:                      Array.Copy(ticksArray' 1' bytes' 0' 7); // 7 bytes for ticks ~ 228 years                        // If formatting as a string' we have to reverse the order                      // of the Data1 and Data2 blocks on little-endian systems.                      if (guidType == SequentialGuidType.SequentialAsString && BitConverter.IsLittleEndian) {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                    case SequentialGuidType.SequentialAtEnd:                      Buffer.BlockCopy(ticksArray' 1' bytes' 9' 7);                      break;              }
Magic Number,Ractor,GuidGenerator,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\GuidGenerator.cs,GuidSequentialArray,The following statement contains a magic number: switch (guidType) {                  case SequentialGuidType.SequentialAsString:                  case SequentialGuidType.SequentialAsBinary:                      Array.Copy(ticksArray' 1' bytes' 0' 7); // 7 bytes for ticks ~ 228 years                        // If formatting as a string' we have to reverse the order                      // of the Data1 and Data2 blocks on little-endian systems.                      if (guidType == SequentialGuidType.SequentialAsString && BitConverter.IsLittleEndian) {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                    case SequentialGuidType.SequentialAtEnd:                      Buffer.BlockCopy(ticksArray' 1' bytes' 9' 7);                      break;              }
Magic Number,Ractor,GuidGenerator,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\GuidGenerator.cs,GuidSequentialArray,The following statement contains a magic number: bytes[8] = (byte)(((guidTypeByte & 3) << 6) | (bucket & 63));
Magic Number,Ractor,GuidGenerator,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\GuidGenerator.cs,GuidSequentialArray,The following statement contains a magic number: bytes[8] = (byte)(((guidTypeByte & 3) << 6) | (bucket & 63));
Magic Number,Ractor,GuidGenerator,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\GuidGenerator.cs,GuidSequentialArray,The following statement contains a magic number: bytes[8] = (byte)(((guidTypeByte & 3) << 6) | (bucket & 63));
Magic Number,Ractor,GuidGenerator,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\GuidGenerator.cs,GuidSequentialArray,The following statement contains a magic number: bytes[8] = (byte)(((guidTypeByte & 3) << 6) | (bucket & 63));
Magic Number,Ractor,GuidGenerator,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\GuidGenerator.cs,Bucket,The following statement contains a magic number: return (byte)(bytes[8] & 63);
Magic Number,Ractor,GuidGenerator,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\GuidGenerator.cs,Bucket,The following statement contains a magic number: return (byte)(bytes[8] & 63);
Magic Number,Ractor,GuidGenerator,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\GuidGenerator.cs,SequentialType,The following statement contains a magic number: return (SequentialGuidType)(bytes[8] >> 6);
Magic Number,Ractor,GuidGenerator,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\GuidGenerator.cs,SequentialType,The following statement contains a magic number: return (SequentialGuidType)(bytes[8] >> 6);
Magic Number,Ractor,GuidExtensions,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\GuidGenerator.cs,MD5Guid,The following statement contains a magic number: bs[8] = 0;
Magic Number,Ractor,GuidExtensions,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\GuidGenerator.cs,Timestamp,The following statement contains a magic number: var tickBytes = new byte[8];
Magic Number,Ractor,GuidExtensions,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\GuidGenerator.cs,Timestamp,The following statement contains a magic number: switch (guidType) {                  case SequentialGuidType.SequentialAsString:                  case SequentialGuidType.SequentialAsBinary:                        if (guidType == SequentialGuidType.SequentialAsString && BitConverter.IsLittleEndian) {                          Array.Reverse(gbs' 0' 4);                          Array.Reverse(gbs' 4' 2);                          Array.Reverse(gbs' 6' 2);                      }                      Array.Copy(gbs' 0' tickBytes' 1' 7);                      break;                  case SequentialGuidType.SequentialAtEnd:                      Buffer.BlockCopy(gbs' 1' tickBytes' 9' 7);                      break;              }
Magic Number,Ractor,GuidExtensions,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\GuidGenerator.cs,Timestamp,The following statement contains a magic number: switch (guidType) {                  case SequentialGuidType.SequentialAsString:                  case SequentialGuidType.SequentialAsBinary:                        if (guidType == SequentialGuidType.SequentialAsString && BitConverter.IsLittleEndian) {                          Array.Reverse(gbs' 0' 4);                          Array.Reverse(gbs' 4' 2);                          Array.Reverse(gbs' 6' 2);                      }                      Array.Copy(gbs' 0' tickBytes' 1' 7);                      break;                  case SequentialGuidType.SequentialAtEnd:                      Buffer.BlockCopy(gbs' 1' tickBytes' 9' 7);                      break;              }
Magic Number,Ractor,GuidExtensions,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\GuidGenerator.cs,Timestamp,The following statement contains a magic number: switch (guidType) {                  case SequentialGuidType.SequentialAsString:                  case SequentialGuidType.SequentialAsBinary:                        if (guidType == SequentialGuidType.SequentialAsString && BitConverter.IsLittleEndian) {                          Array.Reverse(gbs' 0' 4);                          Array.Reverse(gbs' 4' 2);                          Array.Reverse(gbs' 6' 2);                      }                      Array.Copy(gbs' 0' tickBytes' 1' 7);                      break;                  case SequentialGuidType.SequentialAtEnd:                      Buffer.BlockCopy(gbs' 1' tickBytes' 9' 7);                      break;              }
Magic Number,Ractor,GuidExtensions,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\GuidGenerator.cs,Timestamp,The following statement contains a magic number: switch (guidType) {                  case SequentialGuidType.SequentialAsString:                  case SequentialGuidType.SequentialAsBinary:                        if (guidType == SequentialGuidType.SequentialAsString && BitConverter.IsLittleEndian) {                          Array.Reverse(gbs' 0' 4);                          Array.Reverse(gbs' 4' 2);                          Array.Reverse(gbs' 6' 2);                      }                      Array.Copy(gbs' 0' tickBytes' 1' 7);                      break;                  case SequentialGuidType.SequentialAtEnd:                      Buffer.BlockCopy(gbs' 1' tickBytes' 9' 7);                      break;              }
Magic Number,Ractor,GuidExtensions,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\GuidGenerator.cs,Timestamp,The following statement contains a magic number: switch (guidType) {                  case SequentialGuidType.SequentialAsString:                  case SequentialGuidType.SequentialAsBinary:                        if (guidType == SequentialGuidType.SequentialAsString && BitConverter.IsLittleEndian) {                          Array.Reverse(gbs' 0' 4);                          Array.Reverse(gbs' 4' 2);                          Array.Reverse(gbs' 6' 2);                      }                      Array.Copy(gbs' 0' tickBytes' 1' 7);                      break;                  case SequentialGuidType.SequentialAtEnd:                      Buffer.BlockCopy(gbs' 1' tickBytes' 9' 7);                      break;              }
Magic Number,Ractor,GuidExtensions,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\GuidGenerator.cs,Timestamp,The following statement contains a magic number: switch (guidType) {                  case SequentialGuidType.SequentialAsString:                  case SequentialGuidType.SequentialAsBinary:                        if (guidType == SequentialGuidType.SequentialAsString && BitConverter.IsLittleEndian) {                          Array.Reverse(gbs' 0' 4);                          Array.Reverse(gbs' 4' 2);                          Array.Reverse(gbs' 6' 2);                      }                      Array.Copy(gbs' 0' tickBytes' 1' 7);                      break;                  case SequentialGuidType.SequentialAtEnd:                      Buffer.BlockCopy(gbs' 1' tickBytes' 9' 7);                      break;              }
Magic Number,Ractor,GuidExtensions,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\GuidGenerator.cs,Timestamp,The following statement contains a magic number: switch (guidType) {                  case SequentialGuidType.SequentialAsString:                  case SequentialGuidType.SequentialAsBinary:                        if (guidType == SequentialGuidType.SequentialAsString && BitConverter.IsLittleEndian) {                          Array.Reverse(gbs' 0' 4);                          Array.Reverse(gbs' 4' 2);                          Array.Reverse(gbs' 6' 2);                      }                      Array.Copy(gbs' 0' tickBytes' 1' 7);                      break;                  case SequentialGuidType.SequentialAtEnd:                      Buffer.BlockCopy(gbs' 1' tickBytes' 9' 7);                      break;              }
Magic Number,Ractor,GuidExtensions,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\GuidGenerator.cs,Timestamp,The following statement contains a magic number: switch (guidType) {                  case SequentialGuidType.SequentialAsString:                  case SequentialGuidType.SequentialAsBinary:                        if (guidType == SequentialGuidType.SequentialAsString && BitConverter.IsLittleEndian) {                          Array.Reverse(gbs' 0' 4);                          Array.Reverse(gbs' 4' 2);                          Array.Reverse(gbs' 6' 2);                      }                      Array.Copy(gbs' 0' tickBytes' 1' 7);                      break;                  case SequentialGuidType.SequentialAtEnd:                      Buffer.BlockCopy(gbs' 1' tickBytes' 9' 7);                      break;              }
Magic Number,Ractor,CryptoExtentions,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Encryption.cs,Encrypt,The following statement contains a magic number: key.Length != _KEY_LENGTH / 8 || iv.Length != _KEY_LENGTH / 8
Magic Number,Ractor,CryptoExtentions,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Encryption.cs,Encrypt,The following statement contains a magic number: key.Length != _KEY_LENGTH / 8 || iv.Length != _KEY_LENGTH / 8
Magic Number,Ractor,CryptoExtentions,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Encryption.cs,Decrypt,The following statement contains a magic number: key.Length == _KEY_LENGTH / 8 && iv.Length == _KEY_LENGTH / 8
Magic Number,Ractor,CryptoExtentions,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Encryption.cs,Decrypt,The following statement contains a magic number: key.Length == _KEY_LENGTH / 8 && iv.Length == _KEY_LENGTH / 8
Missing Default,Ractor,GuidGenerator,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\GuidGenerator.cs,GuidSequentialArray,The following switch statement is missing a default case: switch (guidType) {                  case SequentialGuidType.SequentialAsString:                  case SequentialGuidType.SequentialAsBinary:                      Array.Copy(ticksArray' 1' bytes' 0' 7); // 7 bytes for ticks ~ 228 years                        // If formatting as a string' we have to reverse the order                      // of the Data1 and Data2 blocks on little-endian systems.                      if (guidType == SequentialGuidType.SequentialAsString && BitConverter.IsLittleEndian) {                          Array.Reverse(bytes' 0' 4);                          Array.Reverse(bytes' 4' 2);                          Array.Reverse(bytes' 6' 2);                      }                      break;                    case SequentialGuidType.SequentialAtEnd:                      Buffer.BlockCopy(ticksArray' 1' bytes' 9' 7);                      break;              }
Missing Default,Ractor,GuidExtensions,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\GuidGenerator.cs,Timestamp,The following switch statement is missing a default case: switch (guidType) {                  case SequentialGuidType.SequentialAsString:                  case SequentialGuidType.SequentialAsBinary:                        if (guidType == SequentialGuidType.SequentialAsString && BitConverter.IsLittleEndian) {                          Array.Reverse(gbs' 0' 4);                          Array.Reverse(gbs' 4' 2);                          Array.Reverse(gbs' 6' 2);                      }                      Array.Copy(gbs' 0' tickBytes' 1' 7);                      break;                  case SequentialGuidType.SequentialAtEnd:                      Buffer.BlockCopy(gbs' 1' tickBytes' 9' 7);                      break;              }
Missing Default,Ractor,Redis,D:\research\architectureSmells\repos\buybackoff_Ractor.CLR\src\Ractor.Persistence\Redis.Commands.Keys.cs,MapWhen,The following switch statement is missing a default case: switch (when) {                  case When.Always:                      return StackExchange.Redis.When.Always;                  case When.Exists:                      return StackExchange.Redis.When.Exists;                  case When.NotExists:                      return StackExchange.Redis.When.NotExists;              }
