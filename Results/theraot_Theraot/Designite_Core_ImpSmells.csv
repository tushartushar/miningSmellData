Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.Linq.Expressions,DebugViewWriter,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\DebugViewWriter.net30.cs,VisitBinary,The method has 173 lines of code.
Long Method,System.Linq.Expressions,DebugViewWriter,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\DebugViewWriter.net30.cs,GetOperatorPrecedence,The method has 103 lines of code.
Long Method,System.Linq.Expressions,ExpressionStringBuilder,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\ExpressionStringBuilder.net30.cs,VisitBinary,The method has 172 lines of code.
Long Method,System.Linq.Expressions.Compiler,ILGen,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitNumericConversion,The method has 141 lines of code.
Long Method,System.Linq.Expressions.Compiler,LambdaCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.net30.cs,EmitUnliftedBinaryOp,The method has 179 lines of code.
Long Method,System.Linq.Expressions.Compiler,LambdaCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.net30.cs,EmitLiftedRelational,The method has 104 lines of code.
Long Method,System.Linq.Expressions.Compiler,LambdaCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.net30.cs,EmitLift,The method has 169 lines of code.
Long Method,System.Linq.Expressions.Compiler,LambdaCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.net30.cs,EmitExpression,The method has 217 lines of code.
Long Method,System.Linq.Expressions.Compiler,LambdaCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.net30.cs,TryEmitHashtableSwitch,The method has 111 lines of code.
Long Method,System.Linq.Expressions.Compiler,LambdaCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.net30.cs,EmitUnaryOperator,The method has 149 lines of code.
Long Method,System.Linq.Expressions.Compiler,StackSpiller,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\StackSpiller.Bindings.net30.cs,RewriteExpression,The method has 224 lines of code.
Long Method,System.Linq.Expressions.Interpreter,EnterTryCatchFinallyInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\ControlFlowInstructions.net30.cs,Run,The method has 112 lines of code.
Long Method,System.Linq.Expressions.Interpreter,LightCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\LightCompiler.net30.cs,CompileBinaryExpression,The method has 189 lines of code.
Long Method,System.Linq.Expressions.Interpreter,LightCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\LightCompiler.net30.cs,CompileTryExpression,The method has 118 lines of code.
Long Method,System.Linq.Expressions.Interpreter,LightCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\LightCompiler.net30.cs,CompileNoLabelPush,The method has 231 lines of code.
Long Method,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,BigInteger,The method has 126 lines of code.
Long Method,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,FormatBigInteger,The method has 181 lines of code.
Long Method,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,ParseNumber,The method has 195 lines of code.
Long Method,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetWrap,The method has 182 lines of code.
Long Method,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,LehmerGcd,The method has 181 lines of code.
Long Method,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,ModDivCore,The method has 126 lines of code.
Long Method,System.Threading,Barrier,C:\repos\theraot_Theraot\Core\System\Threading\Barrier.net35.cs,SignalAndWait,The method has 127 lines of code.
Long Method,System.Threading,ReaderWriterLockSlim,C:\repos\theraot_Theraot\Core\System\Threading\ReaderWriterLockSlim.net35.cs,TryEnterWriteLock,The method has 110 lines of code.
Long Method,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,WaitAll,The method has 136 lines of code.
Long Method,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,IsImplicitNumericConversion,The method has 117 lines of code.
Complex Method,System.Dynamic.Utils,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Dynamic\Utils\DelegateHelpers.cs,CreateObjectArrayDelegateRefEmit,Cyclomatic complexity of the method is 10
Complex Method,System.Linq,Enumerable,C:\repos\theraot_Theraot\Core\System\Linq\Enumerable.join.net30.cs,Max,Cyclomatic complexity of the method is 10
Complex Method,System.Linq,Enumerable,C:\repos\theraot_Theraot\Core\System\Linq\Enumerable.join.net30.cs,Min,Cyclomatic complexity of the method is 10
Complex Method,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,IsCompatible,Cyclomatic complexity of the method is 8
Complex Method,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,ValidateIndexedProperty,Cyclomatic complexity of the method is 15
Complex Method,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,ValidateAccessorArgumentTypes,Cyclomatic complexity of the method is 11
Complex Method,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,ValidateNewArgs,Cyclomatic complexity of the method is 19
Complex Method,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,ValidateAnonymousTypeMember,Cyclomatic complexity of the method is 8
Complex Method,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Switch,Cyclomatic complexity of the method is 14
Complex Method,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,ValidateUserDefinedConditionalLogicOperator,Cyclomatic complexity of the method is 10
Complex Method,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,ValidateLambdaArgs,Cyclomatic complexity of the method is 13
Complex Method,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,NewArrayInit,Cyclomatic complexity of the method is 9
Complex Method,System.Linq.Expressions.Compiler,BoundConstants,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\BoundConstants.net30.cs,EmitCacheConstants,Cyclomatic complexity of the method is 8
Complex Method,System.Linq.Expressions.Compiler,ILGen,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitConstant,Cyclomatic complexity of the method is 8
Complex Method,System.Linq.Expressions.Compiler,LabelInfo,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\LabelInfo.cs,ValidateJump,Cyclomatic complexity of the method is 14
Complex Method,System.Linq.Expressions.Compiler,LambdaCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.net30.cs,TryEmitSwitchInstruction,Cyclomatic complexity of the method is 8
Complex Method,System.Linq.Expressions.Compiler,LambdaCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.net30.cs,EmitSwitchBucket,Cyclomatic complexity of the method is 8
Complex Method,System.Linq.Expressions.Compiler,LambdaCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.net30.cs,TryEmitHashtableSwitch,Cyclomatic complexity of the method is 10
Complex Method,System.Linq.Expressions.Compiler,LambdaCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.net30.cs,EmitTryExpression,Cyclomatic complexity of the method is 8
Complex Method,System.Linq.Expressions.Compiler,StackSpiller,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\StackSpiller.Bindings.net30.cs,RewriteSwitchExpression,Cyclomatic complexity of the method is 11
Complex Method,System.Linq.Expressions.Compiler,StackSpiller,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\StackSpiller.Bindings.net30.cs,RewriteTryExpression,Cyclomatic complexity of the method is 10
Complex Method,System.Linq.Expressions.Compiler,VariableBinder,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\VariableBinder.net30.cs,MergeScopes,Cyclomatic complexity of the method is 8
Complex Method,System.Linq.Expressions.Interpreter,InstructionList,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\InstructionList.net30.cs,EmitLoad,Cyclomatic complexity of the method is 10
Complex Method,System.Linq.Expressions.Interpreter,LabelInfo,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\LabelInfo.net30.cs,ValidateJump,Cyclomatic complexity of the method is 11
Complex Method,System.Linq.Expressions.Interpreter,LightCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\LightCompiler.net30.cs,CompileConvertToType,Cyclomatic complexity of the method is 11
Complex Method,System.Linq.Expressions.Interpreter,LightCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\LightCompiler.net30.cs,CompileSwitchExpression,Cyclomatic complexity of the method is 9
Complex Method,System.Linq.Expressions.Interpreter,LightCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\LightCompiler.net30.cs,CompileTryExpression,Cyclomatic complexity of the method is 12
Complex Method,System.Linq.Expressions.Interpreter,LightCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\LightCompiler.net30.cs,CompileMethodCallExpression,Cyclomatic complexity of the method is 8
Complex Method,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,BigInteger,Cyclomatic complexity of the method is 11
Complex Method,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,BigInteger,Cyclomatic complexity of the method is 11
Complex Method,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,CompareTo,Cyclomatic complexity of the method is 9
Complex Method,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,Log,Cyclomatic complexity of the method is 8
Complex Method,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,Pow,Cyclomatic complexity of the method is 17
Complex Method,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,ToByteArray,Cyclomatic complexity of the method is 8
Complex Method,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,FormatBigInteger,Cyclomatic complexity of the method is 10
Complex Method,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,CreateBuilder,Cyclomatic complexity of the method is 11
Complex Method,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,FormatBigIntegerToHexString,Cyclomatic complexity of the method is 8
Complex Method,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,GetIntegerParts,Cyclomatic complexity of the method is 8
Complex Method,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,LehmerGcd,Cyclomatic complexity of the method is 11
Complex Method,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,ModDivCore,Cyclomatic complexity of the method is 22
Complex Method,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,ShiftLeft,Cyclomatic complexity of the method is 8
Complex Method,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,Sub,Cyclomatic complexity of the method is 12
Complex Method,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,CompareTo,Cyclomatic complexity of the method is 8
Complex Method,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,CompareTo,Cyclomatic complexity of the method is 9
Complex Method,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,CompareTo,Cyclomatic complexity of the method is 8
Complex Method,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,CompareTo,Cyclomatic complexity of the method is 10
Complex Method,System,Tuple<T1;T2;T3;T4;T5;T6;T7;TRest>,C:\repos\theraot_Theraot\Core\System\Tuple8.net35.cs,CompareTo,Cyclomatic complexity of the method is 10
Complex Method,System,Tuple<T1;T2;T3;T4;T5;T6;T7>,C:\repos\theraot_Theraot\Core\System\Tuple7.net35.cs,CompareTo,Cyclomatic complexity of the method is 9
Complex Method,System,Tuple<T1;T2;T3;T4;T5;T6>,C:\repos\theraot_Theraot\Core\System\Tuple6.net35.cs,CompareTo,Cyclomatic complexity of the method is 8
Complex Method,System.Threading,Barrier,C:\repos\theraot_Theraot\Core\System\Threading\Barrier.net35.cs,AddParticipants,Cyclomatic complexity of the method is 8
Complex Method,System.Threading,Barrier,C:\repos\theraot_Theraot\Core\System\Threading\Barrier.net35.cs,RemoveParticipants,Cyclomatic complexity of the method is 8
Complex Method,System.Threading,Barrier,C:\repos\theraot_Theraot\Core\System\Threading\Barrier.net35.cs,SignalAndWait,Cyclomatic complexity of the method is 14
Complex Method,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,WhenAll,Cyclomatic complexity of the method is 8
Complex Method,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,WhenAll,Cyclomatic complexity of the method is 8
Complex Method,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,WaitAll,Cyclomatic complexity of the method is 21
Complex Method,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,FinishContinuations,Cyclomatic complexity of the method is 9
Complex Method,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,Task,Cyclomatic complexity of the method is 9
Complex Method,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,GCD,Cyclomatic complexity of the method is 8
Complex Method,Theraot.Core,PathHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\PathHelper.cs,Combine,Cyclomatic complexity of the method is 8
Complex Method,Theraot.Core,PathHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\PathHelper.cs,Combine,Cyclomatic complexity of the method is 9
Complex Method,Theraot.Core,PathHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\PathHelper.cs,Combine,Cyclomatic complexity of the method is 12
Complex Method,Theraot.Core,StringProcessor,C:\repos\theraot_Theraot\Core\Theraot\Core\StringProcessor.cs,SkipUntil,Cyclomatic complexity of the method is 8
Complex Method,Theraot.Core,StringProcessor,C:\repos\theraot_Theraot\Core\Theraot\Core\StringProcessor.cs,SkipUntil,Cyclomatic complexity of the method is 8
Complex Method,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,GetTypeCode,Cyclomatic complexity of the method is 19
Complex Method,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,HasReferenceConversion,Cyclomatic complexity of the method is 9
Complex Method,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,IsLegalExplicitVariantDelegateConversion,Cyclomatic complexity of the method is 10
Complex Method,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,IsValidInstanceType,Cyclomatic complexity of the method is 10
Complex Method,Theraot.Collections.Specialized,AVLNode,C:\repos\theraot_Theraot\Core\Theraot\Collections\Specialized\AVLTree.AVLNode.cs,EnumerateFrom,Cyclomatic complexity of the method is 8
Long Parameter List,System.Diagnostics.Contracts,ContractException,C:\repos\theraot_Theraot\Core\System\Diagnostics\Contracts\ContractException.net40.cs,ContractException,The method has 5 parameters. Parameters: kind' failure' userMessage' condition' innerException
Long Parameter List,System.Dynamic.Utils,ContractUtils,C:\repos\theraot_Theraot\Core\System\Dynamic\Utils\ContractsUtil.cs,RequiresArrayRange,The method has 5 parameters. Parameters: array' offset' count' offsetName' countName
Long Parameter List,System.Runtime.CompilerServices,ContractHelper,C:\repos\theraot_Theraot\Core\System\Runtime\CompilerServices\ContractHelper.net40.cs,TriggerFailure,The method has 5 parameters. Parameters: kind' displayMessage' userMessage' conditionText' innerException
Long Parameter List,System.Runtime.CompilerServices,ContractHelper,C:\repos\theraot_Theraot\Core\System\Runtime\CompilerServices\ContractHelper.net40.cs,RaiseContractFailedEventImplementation,The method has 5 parameters. Parameters: failureKind' userMessage' conditionText' innerException' resultFailureMessage
Long Parameter List,System.Runtime.CompilerServices,ContractHelper,C:\repos\theraot_Theraot\Core\System\Runtime\CompilerServices\ContractHelper.net40.cs,TriggerFailureImplementation,The method has 5 parameters. Parameters: kind' displayMessage' userMessage' conditionText' innerException
Long Parameter List,System.Linq,Enumerable,C:\repos\theraot_Theraot\Core\System\Linq\Enumerable.join.net30.cs,Join,The method has 6 parameters. Parameters: outer' inner' outerKeySelector' innerKeySelector' resultSelector' comparer
Long Parameter List,System.Linq,Enumerable,C:\repos\theraot_Theraot\Core\System\Linq\Enumerable.join.net30.cs,Join,The method has 5 parameters. Parameters: outer' inner' outerKeySelector' innerKeySelector' resultSelector
Long Parameter List,System.Linq,Enumerable,C:\repos\theraot_Theraot\Core\System\Linq\Enumerable.join.net30.cs,CreateJoinIterator,The method has 6 parameters. Parameters: outer' inner' outerKeySelector' innerKeySelector' resultSelector' comparer
Long Parameter List,System.Linq,Enumerable,C:\repos\theraot_Theraot\Core\System\Linq\Enumerable.join.net30.cs,GroupJoin,The method has 5 parameters. Parameters: outer' inner' outerKeySelector' innerKeySelector' resultSelector
Long Parameter List,System.Linq,Enumerable,C:\repos\theraot_Theraot\Core\System\Linq\Enumerable.join.net30.cs,GroupJoin,The method has 6 parameters. Parameters: outer' inner' outerKeySelector' innerKeySelector' resultSelector' comparer
Long Parameter List,System.Linq,Enumerable,C:\repos\theraot_Theraot\Core\System\Linq\Enumerable.join.net30.cs,CreateGroupJoinIterator,The method has 6 parameters. Parameters: outer' inner' outerKeySelector' innerKeySelector' resultSelector' comparer
Long Parameter List,System.Linq,Enumerable,C:\repos\theraot_Theraot\Core\System\Linq\Enumerable.join.net30.cs,GroupBy,The method has 5 parameters. Parameters: source' keySelector' elementSelector' resultSelector' comparer
Long Parameter List,System.Linq,Enumerable,C:\repos\theraot_Theraot\Core\System\Linq\Enumerable.join.net30.cs,CreateGroupByIterator,The method has 5 parameters. Parameters: source' keySelector' elementSelector' resultSelector' comparer
Long Parameter List,System.Linq,GroupedEnumerable<TSource;TKey;TElement;TResult>,C:\repos\theraot_Theraot\Core\System\Linq\Enumerable.groupby.net30.cs,GroupedEnumerable,The method has 5 parameters. Parameters: source' keySelector' elementSelector' resultSelector' comparer
Long Parameter List,System.Linq,LinqCheck,C:\repos\theraot_Theraot\Core\System\Linq\LinqCheck.cs,JoinSelectors,The method has 5 parameters. Parameters: outer' inner' outerKeySelector' innerKeySelector' resultSelector
Long Parameter List,System.Linq,OrderedSequence<TElement;TKey>,C:\repos\theraot_Theraot\Core\System\Linq\OrderedSequence.cs,OrderedSequence,The method has 5 parameters. Parameters: parent' source' keySelector' comparer' direction
Long Parameter List,System.Linq,Queryable,C:\repos\theraot_Theraot\Core\System\Linq\Queryable.net30.cs,GroupBy,The method has 5 parameters. Parameters: source' keySelector' elementSelector' resultSelector' comparer
Long Parameter List,System.Linq,Queryable,C:\repos\theraot_Theraot\Core\System\Linq\Queryable.net30.cs,GroupJoin,The method has 5 parameters. Parameters: outer' inner' outerKeySelector' innerKeySelector' resultSelector
Long Parameter List,System.Linq,Queryable,C:\repos\theraot_Theraot\Core\System\Linq\Queryable.net30.cs,GroupJoin,The method has 6 parameters. Parameters: outer' inner' outerKeySelector' innerKeySelector' resultSelector' comparer
Long Parameter List,System.Linq,Queryable,C:\repos\theraot_Theraot\Core\System\Linq\Queryable.net30.cs,Join,The method has 5 parameters. Parameters: outer' inner' outerKeySelector' innerKeySelector' resultSelector
Long Parameter List,System.Linq,Queryable,C:\repos\theraot_Theraot\Core\System\Linq\Queryable.net30.cs,Join,The method has 6 parameters. Parameters: outer' inner' outerKeySelector' innerKeySelector' resultSelector' comparer
Long Parameter List,System.Linq.Expressions,Block5,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Block5,The method has 5 parameters. Parameters: arg0' arg1' arg2' arg3' arg4
Long Parameter List,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Block,The method has 5 parameters. Parameters: arg0' arg1' arg2' arg3' arg4
Long Parameter List,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,DebugInfo,The method has 5 parameters. Parameters: document' startLine' startColumn' endLine' endColumn
Long Parameter List,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Switch,The method has 5 parameters. Parameters: type' switchValue' defaultBody' comparison' cases
Long Parameter List,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Switch,The method has 5 parameters. Parameters: type' switchValue' defaultBody' comparison' cases
Long Parameter List,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,MakeTry,The method has 5 parameters. Parameters: type' body' finally' fault' handlers
Long Parameter List,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,GetUserDefinedBinaryOperator,The method has 5 parameters. Parameters: binaryType' name' left' right' liftToNull
Long Parameter List,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,GetMethodBasedBinaryOperator,The method has 5 parameters. Parameters: binaryType' left' right' method' liftToNull
Long Parameter List,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,GetMethodBasedAssignOperator,The method has 6 parameters. Parameters: binaryType' left' right' method' conversion' liftToNull
Long Parameter List,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,GetUserDefinedBinaryOperatorOrThrow,The method has 5 parameters. Parameters: binaryType' name' left' right' liftToNull
Long Parameter List,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,GetUserDefinedAssignOperatorOrThrow,The method has 6 parameters. Parameters: binaryType' name' left' right' conversion' liftToNull
Long Parameter List,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,MakeBinary,The method has 5 parameters. Parameters: binaryType' left' right' liftToNull' method
Long Parameter List,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,MakeBinary,The method has 6 parameters. Parameters: binaryType' left' right' liftToNull' method' conversion
Long Parameter List,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,GetEqualityComparisonOperator,The method has 5 parameters. Parameters: binaryType' opName' left' right' liftToNull
Long Parameter List,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,GetComparisonOperator,The method has 5 parameters. Parameters: binaryType' opName' left' right' liftToNull
Long Parameter List,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,CreateLambda,The method has 5 parameters. Parameters: delegateType' body' name' tailCall' parameters
Long Parameter List,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Lambda,The method has 5 parameters. Parameters: delegateType' body' name' tailCall' parameters
Long Parameter List,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Call,The method has 5 parameters. Parameters: method' arg0' arg1' arg2' arg3
Long Parameter List,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Call,The method has 6 parameters. Parameters: method' arg0' arg1' arg2' arg3' arg4
Long Parameter List,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Call,The method has 5 parameters. Parameters: instance' method' arg0' arg1' arg2
Long Parameter List,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,FindMethod,The method has 5 parameters. Parameters: type' methodName' typeArgs' args' flags
Long Parameter List,System.Linq.Expressions,SpanDebugInfoExpression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\DebugInfoExpression.net30.cs,SpanDebugInfoExpression,The method has 5 parameters. Parameters: document' startLine' startColumn' endLine' endColumn
Long Parameter List,System.Linq.Expressions,SwitchExpression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\SwitchExpression.net30.cs,SwitchExpression,The method has 5 parameters. Parameters: type' switchValue' defaultBody' comparison' cases
Long Parameter List,System.Linq.Expressions,TryExpression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\TryExpression.net30.cs,TryExpression,The method has 5 parameters. Parameters: type' body' finally' fault' handlers
Long Parameter List,System.Linq.Expressions,BinaryExpression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BinaryExpression.net30.cs,Create,The method has 6 parameters. Parameters: nodeType' left' right' type' method' conversion
Long Parameter List,System.Linq.Expressions,OpAssignMethodConversionBinaryExpression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BinaryExpression.net30.cs,OpAssignMethodConversionBinaryExpression,The method has 6 parameters. Parameters: nodeType' left' right' type' method' conversion
Long Parameter List,System.Linq.Expressions,MethodBinaryExpression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BinaryExpression.net30.cs,MethodBinaryExpression,The method has 5 parameters. Parameters: nodeType' left' right' type' method
Long Parameter List,System.Linq.Expressions,LambdaExpression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\LambdaExpression.net30.cs,LambdaExpression,The method has 5 parameters. Parameters: delegateType' name' body' tailCall' parameters
Long Parameter List,System.Linq.Expressions,MethodCallExpression4,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\MethodCallExpression.net30.cs,MethodCallExpression4,The method has 5 parameters. Parameters: method' arg0' arg1' arg2' arg3
Long Parameter List,System.Linq.Expressions,MethodCallExpression5,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\MethodCallExpression.net30.cs,MethodCallExpression5,The method has 6 parameters. Parameters: method' arg0' arg1' arg2' arg3' arg4
Long Parameter List,System.Linq.Expressions,InstanceMethodCallExpression3,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\MethodCallExpression.net30.cs,InstanceMethodCallExpression3,The method has 5 parameters. Parameters: method' instance' arg0' arg1' arg2
Long Parameter List,System.Linq.Expressions.Compiler,LambdaCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.net30.cs,EmitBinaryOperator,The method has 5 parameters. Parameters: op' leftType' rightType' resultType' liftedToNull
Long Parameter List,System.Linq.Expressions.Compiler,LambdaCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.net30.cs,EmitLiftedBinaryOp,The method has 5 parameters. Parameters: op' leftType' rightType' resultType' liftedToNull
Long Parameter List,System.Linq.Expressions.Compiler,LambdaCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.net30.cs,EmitLiftedRelational,The method has 5 parameters. Parameters: op' leftType' rightType' resultType' liftedToNull
Long Parameter List,System.Linq.Expressions.Compiler,LambdaCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.net30.cs,EmitLift,The method has 5 parameters. Parameters: nodeType' resultType' mc' paramList' argList
Long Parameter List,System.Linq.Expressions.Compiler,LambdaCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.net30.cs,EmitSwitchCases,The method has 6 parameters. Parameters: node' labels' isGoto' default' end' flags
Long Parameter List,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The method has 5 parameters. Parameters: arg0' arg1' arg2' arg3' arg4
Long Parameter List,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The method has 6 parameters. Parameters: arg0' arg1' arg2' arg3' arg4' arg5
Long Parameter List,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The method has 7 parameters. Parameters: arg0' arg1' arg2' arg3' arg4' arg5' arg6
Long Parameter List,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The method has 8 parameters. Parameters: arg0' arg1' arg2' arg3' arg4' arg5' arg6' arg7
Long Parameter List,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The method has 9 parameters. Parameters: arg0' arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8
Long Parameter List,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,ArrayItemSetter3,The method has 5 parameters. Parameters: array' index0' index1' index2' value
Long Parameter List,System.Linq.Expressions.Interpreter,InstructionArray,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\InstructionList.net30.cs,InstructionArray,The method has 6 parameters. Parameters: maxStackDepth' maxContinuationDepth' instructions' objects' labels' debugCookies
Long Parameter List,System.Linq.Expressions.Interpreter,InstructionView,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\InstructionList.net30.cs,InstructionView,The method has 5 parameters. Parameters: instruction' name' index' stackDepth' continuationsDepth
Long Parameter List,System.Linq.Expressions.Interpreter,Interpreter,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\Interpreter.net30.cs,Interpreter,The method has 5 parameters. Parameters: name' locals' labelMapping' instructions' debugInfos
Long Parameter List,System.Linq.Expressions.Interpreter,ExceptionHandler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\LightCompiler.net30.cs,ExceptionHandler,The method has 6 parameters. Parameters: start' end' labelIndex' handlerStartIndex' handlerEndIndex' exceptionType
Long Parameter List,System.Linq.Expressions.Interpreter,TryCatchFinallyHandler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\LightCompiler.net30.cs,TryCatchFinallyHandler,The method has 5 parameters. Parameters: tryStart' tryEnd' gotoEndTargetIndex' finallyStart' finallyEnd
Long Parameter List,System.Linq.Expressions.Interpreter,TryCatchFinallyHandler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\LightCompiler.net30.cs,TryCatchFinallyHandler,The method has 6 parameters. Parameters: tryStart' tryEnd' gotoEndLabelIndex' finallyStart' finallyEnd' handlers
Long Parameter List,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,ModPowInner,The method has 5 parameters. Parameters: exp' regRes' regVal' regMod' regTmp
Long Parameter List,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,ModPowInner32,The method has 5 parameters. Parameters: exp' regRes' regVal' regMod' regTmp
Long Parameter List,System.Numerics,NumericsHelpers,C:\repos\theraot_Theraot\Core\System\Numerics\NumericsHelpers.cs,GetDoubleParts,The method has 5 parameters. Parameters: dbl' sign' exp' man' fFinite
Long Parameter List,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,Deconstruct,The method has 5 parameters. Parameters: value' item1' item2' item3' item4
Long Parameter List,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,Deconstruct,The method has 6 parameters. Parameters: value' item1' item2' item3' item4' item5
Long Parameter List,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,Deconstruct,The method has 7 parameters. Parameters: value' item1' item2' item3' item4' item5' item6
Long Parameter List,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,Deconstruct,The method has 8 parameters. Parameters: value' item1' item2' item3' item4' item5' item6' item7
Long Parameter List,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,Deconstruct,The method has 9 parameters. Parameters: value' item1' item2' item3' item4' item5' item6' item7' item8
Long Parameter List,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,Deconstruct,The method has 10 parameters. Parameters: value' item1' item2' item3' item4' item5' item6' item7' item8' item9
Long Parameter List,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,Deconstruct,The method has 11 parameters. Parameters: value' item1' item2' item3' item4' item5' item6' item7' item8' item9' item10
Long Parameter List,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,Deconstruct,The method has 12 parameters. Parameters: value' item1' item2' item3' item4' item5' item6' item7' item8' item9' item10' item11
Long Parameter List,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,Deconstruct,The method has 13 parameters. Parameters: value' item1' item2' item3' item4' item5' item6' item7' item8' item9' item10' item11' item12
Long Parameter List,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,Deconstruct,The method has 14 parameters. Parameters: value' item1' item2' item3' item4' item5' item6' item7' item8' item9' item10' item11' item12' item13
Long Parameter List,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,Deconstruct,The method has 15 parameters. Parameters: value' item1' item2' item3' item4' item5' item6' item7' item8' item9' item10' item11' item12' item13' item14
Long Parameter List,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,Deconstruct,The method has 16 parameters. Parameters: value' item1' item2' item3' item4' item5' item6' item7' item8' item9' item10' item11' item12' item13' item14' item15
Long Parameter List,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,Deconstruct,The method has 17 parameters. Parameters: value' item1' item2' item3' item4' item5' item6' item7' item8' item9' item10' item11' item12' item13' item14' item15' item16
Long Parameter List,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,Deconstruct,The method has 18 parameters. Parameters: value' item1' item2' item3' item4' item5' item6' item7' item8' item9' item10' item11' item12' item13' item14' item15' item16' item17
Long Parameter List,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,Deconstruct,The method has 19 parameters. Parameters: value' item1' item2' item3' item4' item5' item6' item7' item8' item9' item10' item11' item12' item13' item14' item15' item16' item17' item18
Long Parameter List,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,Deconstruct,The method has 20 parameters. Parameters: value' item1' item2' item3' item4' item5' item6' item7' item8' item9' item10' item11' item12' item13' item14' item15' item16' item17' item18' item19
Long Parameter List,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,Deconstruct,The method has 21 parameters. Parameters: value' item1' item2' item3' item4' item5' item6' item7' item8' item9' item10' item11' item12' item13' item14' item15' item16' item17' item18' item19' item20
Long Parameter List,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,Deconstruct,The method has 22 parameters. Parameters: value' item1' item2' item3' item4' item5' item6' item7' item8' item9' item10' item11' item12' item13' item14' item15' item16' item17' item18' item19' item20' item21
Long Parameter List,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,CreateLong,The method has 8 parameters. Parameters: item1' item2' item3' item4' item5' item6' item7' rest
Long Parameter List,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,CreateLongRef,The method has 8 parameters. Parameters: item1' item2' item3' item4' item5' item6' item7' rest
Long Parameter List,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,Create,The method has 5 parameters. Parameters: item1' item2' item3' item4' item5
Long Parameter List,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,Create,The method has 6 parameters. Parameters: item1' item2' item3' item4' item5' item6
Long Parameter List,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,Create,The method has 7 parameters. Parameters: item1' item2' item3' item4' item5' item6' item7
Long Parameter List,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,Create,The method has 8 parameters. Parameters: item1' item2' item3' item4' item5' item6' item7' item8
Long Parameter List,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,CombineHashCodes,The method has 5 parameters. Parameters: h1' h2' h3' h4' h5
Long Parameter List,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,CombineHashCodes,The method has 6 parameters. Parameters: h1' h2' h3' h4' h5' h6
Long Parameter List,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,CombineHashCodes,The method has 7 parameters. Parameters: h1' h2' h3' h4' h5' h6' h7
Long Parameter List,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,CombineHashCodes,The method has 8 parameters. Parameters: h1' h2' h3' h4' h5' h6' h7' h8
Long Parameter List,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,ValueTuple,The method has 5 parameters. Parameters: item1' item2' item3' item4' item5
Long Parameter List,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,ValueTuple,The method has 6 parameters. Parameters: item1' item2' item3' item4' item5' item6
Long Parameter List,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,ValueTuple,The method has 7 parameters. Parameters: item1' item2' item3' item4' item5' item6' item7
Long Parameter List,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,ValueTuple,The method has 8 parameters. Parameters: item1' item2' item3' item4' item5' item6' item7' rest
Long Parameter List,System,Tuple<T1;T2;T3;T4;T5;T6;T7;TRest>,C:\repos\theraot_Theraot\Core\System\Tuple8.net35.cs,Tuple,The method has 8 parameters. Parameters: item1' item2' item3' item4' item5' item6' item7' rest
Long Parameter List,System,Tuple<T1;T2;T3;T4;T5;T6;T7>,C:\repos\theraot_Theraot\Core\System\Tuple7.net35.cs,Tuple,The method has 7 parameters. Parameters: item1' item2' item3' item4' item5' item6' item7
Long Parameter List,System,Tuple<T1;T2;T3;T4;T5;T6>,C:\repos\theraot_Theraot\Core\System\Tuple6.net35.cs,Tuple,The method has 6 parameters. Parameters: item1' item2' item3' item4' item5' item6
Long Parameter List,System,Tuple<T1;T2;T3;T4;T5>,C:\repos\theraot_Theraot\Core\System\Tuple5.net35.cs,Tuple,The method has 5 parameters. Parameters: item1' item2' item3' item4' item5
Long Parameter List,System,Tuple,C:\repos\theraot_Theraot\Core\System\Tuple.net35.cs,Create,The method has 5 parameters. Parameters: item1' item2' item3' item4' item5
Long Parameter List,System,Tuple,C:\repos\theraot_Theraot\Core\System\Tuple.net35.cs,Create,The method has 6 parameters. Parameters: item1' item2' item3' item4' item5' item6
Long Parameter List,System,Tuple,C:\repos\theraot_Theraot\Core\System\Tuple.net35.cs,Create,The method has 7 parameters. Parameters: item1' item2' item3' item4' item5' item6' item7
Long Parameter List,System,Tuple,C:\repos\theraot_Theraot\Core\System\Tuple.net35.cs,Create,The method has 8 parameters. Parameters: item1' item2' item3' item4' item5' item6' item7' item8
Long Parameter List,System.Threading.Tasks,ContinuationResultTaskFromResultTask<TAntecedentResult;TResult>,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ContinuationResultTaskFromResultTask.cs,ContinuationResultTaskFromResultTask,The method has 5 parameters. Parameters: antecedent' function' state' creationOptions' internalOptions
Long Parameter List,System.Threading.Tasks,ContinuationResultTaskFromTask<TResult>,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ContinuationResultTaskFromTask.cs,ContinuationResultTaskFromTask,The method has 5 parameters. Parameters: antecedent' function' state' creationOptions' internalOptions
Long Parameter List,System.Threading.Tasks,ContinuationTaskFromResultTask<TAntecedentResult>,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ContinuationTaskFromResultTask.cs,ContinuationTaskFromResultTask,The method has 5 parameters. Parameters: antecedent' action' state' creationOptions' internalOptions
Long Parameter List,System.Threading.Tasks,ContinuationTaskFromTask,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ContinuationTaskFromTask.cs,ContinuationTaskFromTask,The method has 5 parameters. Parameters: antecedent' action' state' creationOptions' internalOptions
Long Parameter List,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,ContinueWith,The method has 5 parameters. Parameters: continuationAction' state' cancellationToken' continuationOptions' scheduler
Long Parameter List,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,ContinueWith,The method has 5 parameters. Parameters: continuationFunction' state' cancellationToken' continuationOptions' scheduler
Long Parameter List,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,ContinueWith,The method has 5 parameters. Parameters: continuationAction' state' scheduler' cancellationToken' continuationOptions
Long Parameter List,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,ContinueWith,The method has 5 parameters. Parameters: continuationFunction' state' scheduler' cancellationToken' continuationOptions
Long Parameter List,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,Task,The method has 7 parameters. Parameters: action' state' parent' cancellationToken' creationOptions' internalOptions' scheduler
Long Parameter List,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,Task,The method has 6 parameters. Parameters: action' parent' cancellationToken' creationOptions' internalOptions' scheduler
Long Parameter List,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,Task,The method has 7 parameters. Parameters: action' state' parent' cancellationToken' creationOptions' internalOptions' scheduler
Long Parameter List,System.Threading.Tasks,Task<TResult>,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\Task.await.net35.cs,ContinueWith,The method has 5 parameters. Parameters: continuationAction' state' cancellationToken' continuationOptions' scheduler
Long Parameter List,System.Threading.Tasks,Task<TResult>,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\Task.await.net35.cs,ContinueWith,The method has 5 parameters. Parameters: continuationFunction' state' cancellationToken' continuationOptions' scheduler
Long Parameter List,System.Threading.Tasks,Task<TResult>,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\Task.await.net35.cs,ContinueWith,The method has 5 parameters. Parameters: continuationAction' state' scheduler' cancellationToken' continuationOptions
Long Parameter List,System.Threading.Tasks,Task<TResult>,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\Task.await.net35.cs,ContinueWith,The method has 5 parameters. Parameters: continuationFunction' state' scheduler' cancellationToken' continuationOptions
Long Parameter List,System.Threading.Tasks,Task<TResult>,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\Task.await.net35.cs,Task,The method has 5 parameters. Parameters: function' state' cancellationToken' creationOptions' scheduler
Long Parameter List,System.Threading.Tasks,Task<TResult>,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\Task.await.net35.cs,Task,The method has 7 parameters. Parameters: function' state' parent' cancellationToken' creationOptions' internalOptions' scheduler
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\TaskFactory.net35.cs,StartNew,The method has 5 parameters. Parameters: action' state' cancellationToken' creationOptions' scheduler
Long Parameter List,System.Threading.Tasks,TaskFactory,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\TaskFactory.net35.cs,StartNew,The method has 5 parameters. Parameters: function' state' cancellationToken' creationOptions' scheduler
Long Parameter List,Theraot.Core,HelperNullAction<T1;T2;T3;T4;T5>,C:\repos\theraot_Theraot\Core\Theraot\Core\ActionHelper.cs,NullAction,The method has 5 parameters. Parameters: arg1' arg2' arg3' arg4' arg5
Long Parameter List,Theraot.Core,HelperNullAction<T1;T2;T3;T4;T5;T6>,C:\repos\theraot_Theraot\Core\Theraot\Core\ActionHelper.cs,NullAction,The method has 6 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6
Long Parameter List,Theraot.Core,HelperNullAction<T1;T2;T3;T4;T5;T6;T7>,C:\repos\theraot_Theraot\Core\Theraot\Core\ActionHelper.cs,NullAction,The method has 7 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7
Long Parameter List,Theraot.Core,HelperNullAction<T1;T2;T3;T4;T5;T6;T7;T8>,C:\repos\theraot_Theraot\Core\Theraot\Core\ActionHelper.cs,NullAction,The method has 8 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8
Long Parameter List,Theraot.Core,HelperNullAction<T1;T2;T3;T4;T5;T6;T7;T8;T9>,C:\repos\theraot_Theraot\Core\Theraot\Core\ActionHelper.cs,NullAction,The method has 9 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9
Long Parameter List,Theraot.Core,HelperNullAction<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10>,C:\repos\theraot_Theraot\Core\Theraot\Core\ActionHelper.cs,NullAction,The method has 10 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10
Long Parameter List,Theraot.Core,HelperNullAction<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11>,C:\repos\theraot_Theraot\Core\Theraot\Core\ActionHelper.cs,NullAction,The method has 11 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11
Long Parameter List,Theraot.Core,HelperNullAction<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12>,C:\repos\theraot_Theraot\Core\Theraot\Core\ActionHelper.cs,NullAction,The method has 12 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12
Long Parameter List,Theraot.Core,HelperNullAction<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13>,C:\repos\theraot_Theraot\Core\Theraot\Core\ActionHelper.cs,NullAction,The method has 13 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13
Long Parameter List,Theraot.Core,HelperNullAction<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14>,C:\repos\theraot_Theraot\Core\Theraot\Core\ActionHelper.cs,NullAction,The method has 14 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14
Long Parameter List,Theraot.Core,HelperNullAction<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;T15>,C:\repos\theraot_Theraot\Core\Theraot\Core\ActionHelper.cs,NullAction,The method has 15 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14' arg15
Long Parameter List,Theraot.Core,HelperNullAction<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;T15;T16>,C:\repos\theraot_Theraot\Core\Theraot\Core\ActionHelper.cs,NullAction,The method has 16 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14' arg15' arg16
Long Parameter List,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,GetDoubleParts,The method has 5 parameters. Parameters: dbl' sign' exp' man' fFinite
Long Parameter List,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,GetParts,The method has 5 parameters. Parameters: value' sign' mantissa' exponent' finite
Long Parameter List,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,GetParts,The method has 5 parameters. Parameters: value' sign' mantissa' exponent' finite
Long Parameter List,Theraot.Core,ValueActionClosure<T1;T2;T3;T4>,C:\repos\theraot_Theraot\Core\Theraot\Core\ValueActionClosure.cs,ValueActionClosure,The method has 5 parameters. Parameters: target' arg1' arg2' arg3' arg4
Long Parameter List,Theraot.Core,ValueActionClosure<T1;T2;T3;T4;T5>,C:\repos\theraot_Theraot\Core\Theraot\Core\ValueActionClosure.cs,ValueActionClosure,The method has 6 parameters. Parameters: target' arg1' arg2' arg3' arg4' arg5
Long Parameter List,Theraot.Core,ValueActionClosure<T1;T2;T3;T4;T5;T6>,C:\repos\theraot_Theraot\Core\Theraot\Core\ValueActionClosure.cs,ValueActionClosure,The method has 7 parameters. Parameters: target' arg1' arg2' arg3' arg4' arg5' arg6
Long Parameter List,Theraot.Core,ValueActionClosure<T1;T2;T3;T4;T5;T6;T7>,C:\repos\theraot_Theraot\Core\Theraot\Core\ValueActionClosure.cs,ValueActionClosure,The method has 8 parameters. Parameters: target' arg1' arg2' arg3' arg4' arg5' arg6' arg7
Long Parameter List,Theraot.Core,ValueActionClosure<T1;T2;T3;T4;T5;T6;T7;T8>,C:\repos\theraot_Theraot\Core\Theraot\Core\ValueActionClosure.cs,ValueActionClosure,The method has 9 parameters. Parameters: target' arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8
Long Parameter List,Theraot.Core,ValueActionClosure<T1;T2;T3;T4;T5;T6;T7;T8;T9>,C:\repos\theraot_Theraot\Core\Theraot\Core\ValueActionClosure.cs,ValueActionClosure,The method has 10 parameters. Parameters: target' arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9
Long Parameter List,Theraot.Core,ValueActionClosure<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10>,C:\repos\theraot_Theraot\Core\Theraot\Core\ValueActionClosure.cs,ValueActionClosure,The method has 11 parameters. Parameters: target' arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10
Long Parameter List,Theraot.Core,ValueActionClosure<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11>,C:\repos\theraot_Theraot\Core\Theraot\Core\ValueActionClosure.cs,ValueActionClosure,The method has 12 parameters. Parameters: target' arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11
Long Parameter List,Theraot.Core,ValueActionClosure<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12>,C:\repos\theraot_Theraot\Core\Theraot\Core\ValueActionClosure.cs,ValueActionClosure,The method has 13 parameters. Parameters: target' arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12
Long Parameter List,Theraot.Core,ValueActionClosure<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13>,C:\repos\theraot_Theraot\Core\Theraot\Core\ValueActionClosure.cs,ValueActionClosure,The method has 14 parameters. Parameters: target' arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13
Long Parameter List,Theraot.Core,ValueActionClosure<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14>,C:\repos\theraot_Theraot\Core\Theraot\Core\ValueActionClosure.cs,ValueActionClosure,The method has 15 parameters. Parameters: target' arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14
Long Parameter List,Theraot.Core,ValueActionClosure<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;T15>,C:\repos\theraot_Theraot\Core\Theraot\Core\ValueActionClosure.cs,ValueActionClosure,The method has 16 parameters. Parameters: target' arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14' arg15
Long Parameter List,Theraot.Core,ValueActionClosure<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;T15;T16>,C:\repos\theraot_Theraot\Core\Theraot\Core\ValueActionClosure.cs,ValueActionClosure,The method has 17 parameters. Parameters: target' arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14' arg15' arg16
Long Parameter List,Theraot.Core,ValueFuncClosure<T1;T2;T3;T4;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\ValueFuncClosure.cs,ValueFuncClosure,The method has 5 parameters. Parameters: target' arg1' arg2' arg3' arg4
Long Parameter List,Theraot.Core,ValueFuncClosure<T1;T2;T3;T4;T5;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\ValueFuncClosure.cs,ValueFuncClosure,The method has 6 parameters. Parameters: target' arg1' arg2' arg3' arg4' arg5
Long Parameter List,Theraot.Core,ValueFuncClosure<T1;T2;T3;T4;T5;T6;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\ValueFuncClosure.cs,ValueFuncClosure,The method has 7 parameters. Parameters: target' arg1' arg2' arg3' arg4' arg5' arg6
Long Parameter List,Theraot.Core,ValueFuncClosure<T1;T2;T3;T4;T5;T6;T7;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\ValueFuncClosure.cs,ValueFuncClosure,The method has 8 parameters. Parameters: target' arg1' arg2' arg3' arg4' arg5' arg6' arg7
Long Parameter List,Theraot.Core,ValueFuncClosure<T1;T2;T3;T4;T5;T6;T7;T8;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\ValueFuncClosure.cs,ValueFuncClosure,The method has 9 parameters. Parameters: target' arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8
Long Parameter List,Theraot.Core,ValueFuncClosure<T1;T2;T3;T4;T5;T6;T7;T8;T9;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\ValueFuncClosure.cs,ValueFuncClosure,The method has 10 parameters. Parameters: target' arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9
Long Parameter List,Theraot.Core,ValueFuncClosure<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\ValueFuncClosure.cs,ValueFuncClosure,The method has 11 parameters. Parameters: target' arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10
Long Parameter List,Theraot.Core,ValueFuncClosure<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\ValueFuncClosure.cs,ValueFuncClosure,The method has 12 parameters. Parameters: target' arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11
Long Parameter List,Theraot.Core,ValueFuncClosure<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\ValueFuncClosure.cs,ValueFuncClosure,The method has 13 parameters. Parameters: target' arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12
Long Parameter List,Theraot.Core,ValueFuncClosure<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\ValueFuncClosure.cs,ValueFuncClosure,The method has 14 parameters. Parameters: target' arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13
Long Parameter List,Theraot.Core,ValueFuncClosure<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\ValueFuncClosure.cs,ValueFuncClosure,The method has 15 parameters. Parameters: target' arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14
Long Parameter List,Theraot.Core,ValueFuncClosure<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;T15;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\ValueFuncClosure.cs,ValueFuncClosure,The method has 16 parameters. Parameters: target' arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14' arg15
Long Parameter List,Theraot.Core,ValueFuncClosure<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;T15;T16;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\ValueFuncClosure.cs,ValueFuncClosure,The method has 17 parameters. Parameters: target' arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14' arg15' arg16
Long Parameter List,Theraot.Core,HelperDefaultFunc<T1;T2;T3;T4;T5;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,DefaultFunc,The method has 5 parameters. Parameters: arg1' arg2' arg3' arg4' arg5
Long Parameter List,Theraot.Core,HelperDefaultFunc<T1;T2;T3;T4;T5;T6;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,DefaultFunc,The method has 6 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6
Long Parameter List,Theraot.Core,HelperDefaultFunc<T1;T2;T3;T4;T5;T6;T7;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,DefaultFunc,The method has 7 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7
Long Parameter List,Theraot.Core,HelperDefaultFunc<T1;T2;T3;T4;T5;T6;T7;T8;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,DefaultFunc,The method has 8 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8
Long Parameter List,Theraot.Core,HelperDefaultFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,DefaultFunc,The method has 9 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9
Long Parameter List,Theraot.Core,HelperDefaultFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,DefaultFunc,The method has 10 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10
Long Parameter List,Theraot.Core,HelperDefaultFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,DefaultFunc,The method has 11 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11
Long Parameter List,Theraot.Core,HelperDefaultFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,DefaultFunc,The method has 12 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12
Long Parameter List,Theraot.Core,HelperDefaultFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,DefaultFunc,The method has 13 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13
Long Parameter List,Theraot.Core,HelperDefaultFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,DefaultFunc,The method has 14 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14
Long Parameter List,Theraot.Core,HelperDefaultFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;T15;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,DefaultFunc,The method has 15 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14' arg15
Long Parameter List,Theraot.Core,HelperDefaultFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;T15;T16;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,DefaultFunc,The method has 16 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14' arg15' arg16
Long Parameter List,Theraot.Core,HelperFallacyFunc<T1;T2;T3;T4;T5>,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,FallacyFunc,The method has 5 parameters. Parameters: arg1' arg2' arg3' arg4' arg5
Long Parameter List,Theraot.Core,HelperFallacyFunc<T1;T2;T3;T4;T5;T6>,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,FallacyFunc,The method has 6 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6
Long Parameter List,Theraot.Core,HelperFallacyFunc<T1;T2;T3;T4;T5;T6;T7>,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,FallacyFunc,The method has 7 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7
Long Parameter List,Theraot.Core,HelperFallacyFunc<T1;T2;T3;T4;T5;T6;T7;T8>,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,FallacyFunc,The method has 8 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8
Long Parameter List,Theraot.Core,HelperFallacyFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9>,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,FallacyFunc,The method has 9 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9
Long Parameter List,Theraot.Core,HelperFallacyFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10>,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,FallacyFunc,The method has 10 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10
Long Parameter List,Theraot.Core,HelperFallacyFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11>,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,FallacyFunc,The method has 11 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11
Long Parameter List,Theraot.Core,HelperFallacyFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12>,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,FallacyFunc,The method has 12 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12
Long Parameter List,Theraot.Core,HelperFallacyFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13>,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,FallacyFunc,The method has 13 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13
Long Parameter List,Theraot.Core,HelperFallacyFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14>,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,FallacyFunc,The method has 14 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14
Long Parameter List,Theraot.Core,HelperFallacyFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;T15>,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,FallacyFunc,The method has 15 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14' arg15
Long Parameter List,Theraot.Core,HelperFallacyFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;T15;T16>,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,FallacyFunc,The method has 16 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14' arg15' arg16
Long Parameter List,Theraot.Core,HelperTautologyFunc<T1;T2;T3;T4;T5>,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,TautologyFunc,The method has 5 parameters. Parameters: arg1' arg2' arg3' arg4' arg5
Long Parameter List,Theraot.Core,HelperTautologyFunc<T1;T2;T3;T4;T5;T6>,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,TautologyFunc,The method has 6 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6
Long Parameter List,Theraot.Core,HelperTautologyFunc<T1;T2;T3;T4;T5;T6;T7>,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,TautologyFunc,The method has 7 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7
Long Parameter List,Theraot.Core,HelperTautologyFunc<T1;T2;T3;T4;T5;T6;T7;T8>,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,TautologyFunc,The method has 8 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8
Long Parameter List,Theraot.Core,HelperTautologyFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9>,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,TautologyFunc,The method has 9 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9
Long Parameter List,Theraot.Core,HelperTautologyFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10>,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,TautologyFunc,The method has 10 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10
Long Parameter List,Theraot.Core,HelperTautologyFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11>,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,TautologyFunc,The method has 11 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11
Long Parameter List,Theraot.Core,HelperTautologyFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12>,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,TautologyFunc,The method has 12 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12
Long Parameter List,Theraot.Core,HelperTautologyFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13>,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,TautologyFunc,The method has 13 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13
Long Parameter List,Theraot.Core,HelperTautologyFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14>,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,TautologyFunc,The method has 14 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14
Long Parameter List,Theraot.Core,HelperTautologyFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;T15>,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,TautologyFunc,The method has 15 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14' arg15
Long Parameter List,Theraot.Core,HelperTautologyFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;T15;T16>,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,TautologyFunc,The method has 16 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14' arg15' arg16
Long Parameter List,Theraot.Core,StringHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\StringHelper.cs,Implode,The method has 5 parameters. Parameters: separator' values' converter' start' end
Long Parameter List,Theraot.Core,StringHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\StringHelper.cs,Match,The method has 5 parameters. Parameters: text' regexPattern' regexOptions' startAt' length
Long Parameter List,Theraot.Core,StringHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\StringHelper.cs,Match,The method has 5 parameters. Parameters: text' regexPattern' ignoreCase' startAt' length
Long Parameter List,Theraot.Core,StringHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\StringHelper.cs,ImplodeExtractedExtracted,The method has 5 parameters. Parameters: separator' array' startIndex' maxIndex' length
Long Parameter List,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The method has 5 parameters. Parameters: arg1' arg2' arg3' arg4' arg5
Long Parameter List,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrDefault,The method has 5 parameters. Parameters: arg1' arg2' arg3' arg4' arg5
Long Parameter List,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrFail,The method has 5 parameters. Parameters: arg1' arg2' arg3' arg4' arg5
Long Parameter List,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The method has 6 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6
Long Parameter List,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrDefault,The method has 6 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6
Long Parameter List,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrFail,The method has 6 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6
Long Parameter List,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The method has 7 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7
Long Parameter List,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrDefault,The method has 7 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7
Long Parameter List,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrFail,The method has 7 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7
Long Parameter List,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The method has 8 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8
Long Parameter List,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrDefault,The method has 8 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8
Long Parameter List,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrFail,The method has 8 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8
Long Parameter List,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The method has 9 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9
Long Parameter List,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrDefault,The method has 9 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9
Long Parameter List,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrFail,The method has 9 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9
Long Parameter List,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The method has 10 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10
Long Parameter List,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrDefault,The method has 10 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10
Long Parameter List,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrFail,The method has 10 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10
Long Parameter List,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The method has 11 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11
Long Parameter List,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrDefault,The method has 11 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11
Long Parameter List,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrFail,The method has 11 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11
Long Parameter List,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The method has 12 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12
Long Parameter List,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrDefault,The method has 12 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12
Long Parameter List,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrFail,The method has 12 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12
Long Parameter List,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The method has 13 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13
Long Parameter List,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrDefault,The method has 13 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13
Long Parameter List,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrFail,The method has 13 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13
Long Parameter List,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The method has 14 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14
Long Parameter List,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrDefault,The method has 14 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14
Long Parameter List,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrFail,The method has 14 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14
Long Parameter List,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The method has 15 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14' arg15
Long Parameter List,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrDefault,The method has 15 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14' arg15
Long Parameter List,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrFail,The method has 15 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14' arg15
Long Parameter List,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The method has 16 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14' arg15' arg16
Long Parameter List,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrDefault,The method has 16 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14' arg15' arg16
Long Parameter List,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrFail,The method has 16 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14' arg15' arg16
Long Parameter List,Theraot.Core,ConstructorHelper<T1;T2;T3;T4;T5;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.ConstructorHelper.cs,InvokeConstructor,The method has 5 parameters. Parameters: arg1' arg2' arg3' arg4' arg5
Long Parameter List,Theraot.Core,ConstructorHelper<T1;T2;T3;T4;T5;T6;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.ConstructorHelper.cs,InvokeConstructor,The method has 6 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6
Long Parameter List,Theraot.Core,ConstructorHelper<T1;T2;T3;T4;T5;T6;T7;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.ConstructorHelper.cs,InvokeConstructor,The method has 7 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7
Long Parameter List,Theraot.Core,ConstructorHelper<T1;T2;T3;T4;T5;T6;T7;T8;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.ConstructorHelper.cs,InvokeConstructor,The method has 8 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8
Long Parameter List,Theraot.Core,ConstructorHelper<T1;T2;T3;T4;T5;T6;T7;T8;T9;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.ConstructorHelper.cs,InvokeConstructor,The method has 9 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9
Long Parameter List,Theraot.Core,ConstructorHelper<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.ConstructorHelper.cs,InvokeConstructor,The method has 10 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10
Long Parameter List,Theraot.Core,ConstructorHelper<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.ConstructorHelper.cs,InvokeConstructor,The method has 11 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11
Long Parameter List,Theraot.Core,ConstructorHelper<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.ConstructorHelper.cs,InvokeConstructor,The method has 12 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12
Long Parameter List,Theraot.Core,ConstructorHelper<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.ConstructorHelper.cs,InvokeConstructor,The method has 13 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13
Long Parameter List,Theraot.Core,ConstructorHelper<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.ConstructorHelper.cs,InvokeConstructor,The method has 14 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14
Long Parameter List,Theraot.Core,ConstructorHelper<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;T15;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.ConstructorHelper.cs,InvokeConstructor,The method has 15 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14' arg15
Long Parameter List,Theraot.Core,ConstructorHelper<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;T15;T16;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.ConstructorHelper.cs,InvokeConstructor,The method has 16 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14' arg15' arg16
Long Parameter List,Theraot.Collections,Extensions,C:\repos\theraot_Theraot\Core\Theraot\Collections\Extensions.partition.cs,IndexOf,The method has 5 parameters. Parameters: source' item' index' count' comparer
Long Parameter List,Theraot.Collections,Extensions,C:\repos\theraot_Theraot\Core\Theraot\Collections\Extensions.partition.cs,LastIndexOf,The method has 5 parameters. Parameters: source' item' index' count' comparer
Long Parameter List,Theraot.Collections,Extensions,C:\repos\theraot_Theraot\Core\Theraot\Collections\Extensions.partition.cs,TryFind,The method has 5 parameters. Parameters: source' index' count' predicate' founT
Long Parameter List,Theraot.Collections,Extensions,C:\repos\theraot_Theraot\Core\Theraot\Collections\Extensions.partition.cs,TryFindLast,The method has 5 parameters. Parameters: source' index' count' predicate' foundItem
Long Parameter List,Theraot.Collections.Specialized,AVLNode,C:\repos\theraot_Theraot\Core\Theraot\Collections\Specialized\AVLTree.AVLNode.cs,Bound,The method has 5 parameters. Parameters: node' key' comparison' lower' upper
Long Parameter List,Theraot.Collections.Specialized,AVLNode,C:\repos\theraot_Theraot\Core\Theraot\Collections\Specialized\AVLTree.AVLNode.cs,GetOrAdd,The method has 5 parameters. Parameters: node' key' factory' comparison' isNew
Long Parameter List,Theraot.Collections.Specialized,AVLNode,C:\repos\theraot_Theraot\Core\Theraot\Collections\Specialized\AVLTree.AVLNode.cs,AddNonDuplicateExtracted,The method has 5 parameters. Parameters: node' key' value' comparison' created
Long Parameter List,Theraot.Collections.Specialized,AVLNode,C:\repos\theraot_Theraot\Core\Theraot\Collections\Specialized\AVLTree.AVLNode.cs,GetOrAddExtracted,The method has 6 parameters. Parameters: node' key' factory' comparison' created' isNew
Long Parameter List,Theraot.Collections.ThreadSafe,BucketHelper,C:\repos\theraot_Theraot\Core\Theraot\Collections\ThreadSafe\BucketHelper.cs,InsertOrUpdate,The method has 5 parameters. Parameters: bucket' index' item' itemUpdateFactory' check
Long Parameter List,Theraot.Collections.ThreadSafe,BucketHelper,C:\repos\theraot_Theraot\Core\Theraot\Collections\ThreadSafe\BucketHelper.cs,InsertOrUpdate,The method has 6 parameters. Parameters: bucket' index' item' itemUpdateFactory' check' isNew
Long Parameter List,Theraot.Collections.ThreadSafe,BucketHelper,C:\repos\theraot_Theraot\Core\Theraot\Collections\ThreadSafe\BucketHelper.cs,InsertOrUpdate,The method has 5 parameters. Parameters: bucket' index' item' itemUpdateFactory' isNew
Long Parameter List,Theraot.Collections.ThreadSafe,BucketHelper,C:\repos\theraot_Theraot\Core\Theraot\Collections\ThreadSafe\BucketHelper.cs,InsertOrUpdate,The method has 5 parameters. Parameters: bucket' index' item' check' isNew
Long Parameter List,Theraot.Collections.ThreadSafe,BucketHelper,C:\repos\theraot_Theraot\Core\Theraot\Collections\ThreadSafe\BucketHelper.cs,InsertOrUpdate,The method has 5 parameters. Parameters: bucket' index' itemFactory' itemUpdateFactory' check
Long Parameter List,Theraot.Collections.ThreadSafe,BucketHelper,C:\repos\theraot_Theraot\Core\Theraot\Collections\ThreadSafe\BucketHelper.cs,InsertOrUpdate,The method has 6 parameters. Parameters: bucket' index' itemFactory' itemUpdateFactory' check' isNew
Long Parameter List,Theraot.Collections.ThreadSafe,BucketHelper,C:\repos\theraot_Theraot\Core\Theraot\Collections\ThreadSafe\BucketHelper.cs,InsertOrUpdate,The method has 5 parameters. Parameters: bucket' index' itemFactory' itemUpdateFactory' isNew
Long Parameter List,Theraot.Collections.ThreadSafe,BucketHelper,C:\repos\theraot_Theraot\Core\Theraot\Collections\ThreadSafe\BucketHelper.cs,InsertOrUpdate,The method has 5 parameters. Parameters: bucket' index' itemFactory' check' isNew
Long Parameter List,Theraot.Collections.ThreadSafe,BucketHelper,C:\repos\theraot_Theraot\Core\Theraot\Collections\ThreadSafe\BucketHelper.cs,Update,The method has 5 parameters. Parameters: bucket' index' item' check' isEmpty
Long Parameter List,Theraot.Collections.ThreadSafe,BucketCore,C:\repos\theraot_Theraot\Core\Theraot\Collections\ThreadSafe\BucketCore.cs,DoMayIncrement,The method has 5 parameters. Parameters: use' first' second' factory' callback
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitSet,The method has 5 parameters. Parameters: check' value' comparand' milliseconds' cancellationToken
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitSet,The method has 5 parameters. Parameters: check' value' comparand' timeout' cancellationToken
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitSet,The method has 5 parameters. Parameters: check' value' comparand' timeout' cancellationToken
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeExchange,The method has 5 parameters. Parameters: check' value' result' milliseconds' cancellationToken
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeExchange,The method has 5 parameters. Parameters: check' value' result' timeout' cancellationToken
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeExchange,The method has 5 parameters. Parameters: check' value' result' timeout' cancellationToken
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitSetUnless,The method has 5 parameters. Parameters: check' value' comparand' unless' cancellationToken
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitSetUnless,The method has 5 parameters. Parameters: check' value' comparand' unless' milliseconds
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitSetUnless,The method has 6 parameters. Parameters: check' value' comparand' unless' milliseconds' cancellationToken
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitSetUnless,The method has 5 parameters. Parameters: check' value' comparand' unless' timeout
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitSetUnless,The method has 6 parameters. Parameters: check' value' comparand' unless' timeout' cancellationToken
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitSetUnless,The method has 5 parameters. Parameters: check' value' comparand' unless' timeout
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitSetUnless,The method has 6 parameters. Parameters: check' value' comparand' unless' timeout' cancellationToken
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeSetUnless,The method has 5 parameters. Parameters: check' value' unless' milliseconds' cancellationToken
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeSetUnless,The method has 5 parameters. Parameters: check' value' unless' timeout' cancellationToken
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeSetUnless,The method has 5 parameters. Parameters: check' value' unless' timeout' cancellationToken
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeExchangeUnless,The method has 5 parameters. Parameters: check' value' unless' result' cancellationToken
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeExchangeUnless,The method has 5 parameters. Parameters: check' value' unless' result' milliseconds
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeExchangeUnless,The method has 6 parameters. Parameters: check' value' unless' result' milliseconds' cancellationToken
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeExchangeUnless,The method has 5 parameters. Parameters: check' value' unless' result' timeout
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeExchangeUnless,The method has 6 parameters. Parameters: check' value' unless' result' timeout' cancellationToken
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeExchangeUnless,The method has 5 parameters. Parameters: check' value' unless' result' timeout
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeExchangeUnless,The method has 6 parameters. Parameters: check' value' unless' result' timeout' cancellationToken
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeExchangeUnlessNegative,The method has 5 parameters. Parameters: check' value' lastValue' milliseconds' cancellationToken
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeExchangeUnlessNegative,The method has 5 parameters. Parameters: check' value' lastValue' timeout' cancellationToken
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeExchangeUnlessNegative,The method has 5 parameters. Parameters: check' value' lastValue' timeout' cancellationToken
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeSetUnlessExcess,The method has 5 parameters. Parameters: check' value' maxValue' milliseconds' cancellationToken
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeSetUnlessExcess,The method has 5 parameters. Parameters: check' value' maxValue' timeout' cancellationToken
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeSetUnlessExcess,The method has 5 parameters. Parameters: check' value' maxValue' timeout' cancellationToken
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeExchangeUnlessExcess,The method has 5 parameters. Parameters: check' value' maxValue' lastValue' cancellationToken
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeExchangeUnlessExcess,The method has 5 parameters. Parameters: check' value' maxValue' lastValue' milliseconds
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeExchangeUnlessExcess,The method has 6 parameters. Parameters: check' value' maxValue' lastValue' milliseconds' cancellationToken
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeExchangeUnlessExcess,The method has 5 parameters. Parameters: check' value' maxValue' lastValue' timeout
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeExchangeUnlessExcess,The method has 6 parameters. Parameters: check' value' maxValue' lastValue' timeout' cancellationToken
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeExchangeUnlessExcess,The method has 5 parameters. Parameters: check' value' maxValue' lastValue' timeout
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeExchangeUnlessExcess,The method has 6 parameters. Parameters: check' value' maxValue' lastValue' timeout' cancellationToken
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeSetBounded,The method has 5 parameters. Parameters: check' value' minValue' maxValue' cancellationToken
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeSetBounded,The method has 5 parameters. Parameters: check' value' minValue' maxValue' milliseconds
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeSetBounded,The method has 6 parameters. Parameters: check' value' minValue' maxValue' milliseconds' cancellationToken
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeSetBounded,The method has 5 parameters. Parameters: check' value' minValue' maxValue' timeout
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeSetBounded,The method has 6 parameters. Parameters: check' value' minValue' maxValue' timeout' cancellationToken
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeSetBounded,The method has 5 parameters. Parameters: check' value' minValue' maxValue' timeout
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeSetBounded,The method has 6 parameters. Parameters: check' value' minValue' maxValue' timeout' cancellationToken
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeExchangeBounded,The method has 5 parameters. Parameters: check' value' minValue' maxValue' lastValue
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeExchangeBounded,The method has 6 parameters. Parameters: check' value' minValue' maxValue' lastValue' cancellationToken
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeExchangeBounded,The method has 6 parameters. Parameters: check' value' minValue' maxValue' lastValue' milliseconds
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeExchangeBounded,The method has 7 parameters. Parameters: check' value' minValue' maxValue' lastValue' milliseconds' cancellationToken
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeExchangeBounded,The method has 6 parameters. Parameters: check' value' minValue' maxValue' lastValue' timeout
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeExchangeBounded,The method has 7 parameters. Parameters: check' value' minValue' maxValue' lastValue' timeout' cancellationToken
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeExchangeBounded,The method has 6 parameters. Parameters: check' value' minValue' maxValue' lastValue' timeout
Long Parameter List,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeExchangeBounded,The method has 7 parameters. Parameters: check' value' minValue' maxValue' lastValue' timeout' cancellationToken
Long Parameter List,System.Diagnostics.Contracts.Internal,ContractHelper,C:\repos\theraot_Theraot\Core\System\Diagnostics\Contracts\Internal\ContractHelper.net35.cs,TriggerFailure,The method has 5 parameters. Parameters: kind' displayMessage' userMessage' conditionText' innerException
Long Identifier,System.Runtime.CompilerServices,AsyncVoidMethodBuilder,C:\repos\theraot_Theraot\Core\System\Runtime\CompilerServices\AsyncVoidMethodBuilder.net40.cs,,The length of the parameter _preventUnobservedTaskExceptionsInvoked is 39.
Long Identifier,System.Runtime.CompilerServices,TaskAwaiter,C:\repos\theraot_Theraot\Core\System\Runtime\CompilerServices\TaskAwaiter.net40.cs,,The length of the parameter continueOnCapturedContextDefaultValue is 37.
Long Identifier,System.Runtime.CompilerServices,TaskAwaiter,C:\repos\theraot_Theraot\Core\System\Runtime\CompilerServices\TaskAwaiter.net40.cs,,The length of the parameter _invalidOperationExceptionTaskNotCompleted is 42.
Long Identifier,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,,The length of the parameter _isExceptionObservedByParentPredicate is 37.
Long Identifier,System.Threading.Tasks,TaskExceptionHolder,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\TaskExceptionHolder.net35.cs,,The length of the parameter _failFastOnUnobservedException is 30.
Long Identifier,System.Threading.Tasks,TaskScheduler,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\TaskScheduler.microsoft.net35.cs,,The length of the parameter _unobservedTaskExceptionLockObject is 34.
Long Identifier,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,IsGenericImplementationOf,The length of the parameter interfaceGenericTypeDefinition is 30.
Long Identifier,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,IsGenericImplementationOf,The length of the parameter interfaceGenericTypeDefinitions is 31.
Long Identifier,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,IsGenericImplementationOf,The length of the parameter interfaceGenericTypeDefinition is 30.
Long Identifier,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,IsGenericImplementationOf,The length of the parameter interfaceGenericTypeDefinitions is 31.
Long Statement,System.Collections.ObjectModel,ObservableCollection<T>,C:\repos\theraot_Theraot\Core\System\Collections\ObjectModel\ObservableCollection.net20.cs,MoveItem,The length of the statement  "            InvokeCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Move' item' newIndex' oldIndex)); " is 124.
Long Statement,System.Collections.ObjectModel,ObservableCollection<T>,C:\repos\theraot_Theraot\Core\System\Collections\ObjectModel\ObservableCollection.net20.cs,SetItem,The length of the statement  "            InvokeCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Replace' item' oldItem' index)); " is 123.
Long Statement,System.Diagnostics.Contracts,Contract,C:\repos\theraot_Theraot\Core\System\Diagnostics\Contracts\Contract.bcl.net35 .cs,AssertMustUseRewriter,The length of the statement  "            ContractHelper.TriggerFailure(kind' string.Format("The code has not been rewriten. ContractKind: {0} - Source: {1}"' contractKind' simpleName)' null' null' null); " is 162.
Long Statement,System.Dynamic.Utils,ExpressionUtils,C:\repos\theraot_Theraot\Core\System\Dynamic\Utils\ExpressionUtils.cs,ValidateArgumentTypes,The length of the statement  "            Debug.Assert(nodeKind == ExpressionType.Invoke || nodeKind == ExpressionType.Call || nodeKind == ExpressionType.Dynamic || nodeKind == ExpressionType.New); " is 155.
Long Statement,System.Runtime.CompilerServices,AsyncTaskMethodBuilder,C:\repos\theraot_Theraot\Core\System\Runtime\CompilerServices\AsyncTaskMethodBuilder.net40.cs,SetException,The length of the statement  "            var setException = (exception is OperationCanceledException ? completionSource.TrySetCanceled() : completionSource.TrySetException(exception)); " is 143.
Long Statement,System.Runtime.CompilerServices,ContractHelperEx,C:\repos\theraot_Theraot\Core\System\Runtime\CompilerServices\ContractHelperEx.cs,GetFailureMessage,The length of the statement  "                    result = withCondition ? string.Format("Postcondition failed after throwing an exception: {0}"' conditionText) : "Postcondition failed after throwing an exception."; " is 165.
Long Statement,System.Runtime.CompilerServices,YieldAwaiter,C:\repos\theraot_Theraot\Core\System\Runtime\CompilerServices\YieldAwaitable.net40.cs,OnCompleted,The length of the statement  "                    Task.Factory.StartNew(continuation' default(CancellationToken)' TaskCreationOptions.PreferFairness' TaskScheduler.Current); " is 123.
Long Statement,System.Runtime.CompilerServices,YieldAwaiter,C:\repos\theraot_Theraot\Core\System\Runtime\CompilerServices\YieldAwaitable.net40.cs,UnsafeOnCompleted,The length of the statement  "                    Task.Factory.StartNew(continuation' default(CancellationToken)' TaskCreationOptions.PreferFairness' TaskScheduler.Current); " is 123.
Long Statement,System.Runtime.CompilerServices,ContractHelper,C:\repos\theraot_Theraot\Core\System\Runtime\CompilerServices\ContractHelper.net40.cs,RaiseContractFailedEvent,The length of the statement  "            RaiseContractFailedEventImplementation(failureKind' userMessage' conditionText' innerException' ref resultFailureMessage); " is 122.
Long Statement,System.Linq,Enumerable,C:\repos\theraot_Theraot\Core\System\Linq\Enumerable.join.net30.cs,GroupBy,The length of the statement  "            return new GroupedEnumerable<TSource' TKey' TSource>(source' keySelector' FuncHelper.GetIdentityFunc<TSource>()' comparer); " is 123.
Long Statement,System.Linq,Enumerable,C:\repos\theraot_Theraot\Core\System\Linq\Enumerable.join.net30.cs,GroupBy,The length of the statement  "            return new GroupedEnumerable<TSource' TKey' TSource' TResult>(source' keySelector' FuncHelper.GetIdentityFunc<TSource>()' resultSelector' comparer); " is 148.
Long Statement,System.Linq,Enumerable,C:\repos\theraot_Theraot\Core\System\Linq\Enumerable.join.net30.cs,CreateGroupByIterator,The length of the statement  "            return new GroupedEnumerable<TSource' TKey' TElement>(source' keySelector' elementSelector' comparer)/* as IEnumerable<IGrouping<TKey' TElement>>*/; " is 148.
Long Statement,System.Linq,Enumerable,C:\repos\theraot_Theraot\Core\System\Linq\Enumerable.join.net30.cs,CreateGroupByIterator,The length of the statement  "            return new GroupedEnumerable<TSource' TKey' TElement' TResult>(source' keySelector' elementSelector' resultSelector' comparer)/* as IEnumerable<TResult>*/; " is 155.
Long Statement,System.Linq,Queryable,C:\repos\theraot_Theraot\Core\System\Linq\Queryable.net30.cs,Cast,The length of the statement  "            return (IQueryable<TResult>)source.Provider.CreateQuery(StaticCall(MakeGeneric(MethodBase.GetCurrentMethod()' typeof(TResult))' source.Expression)); " is 148.
Long Statement,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,ValidateVariables,The length of the statement  "                    throw new ArgumentNullException(string.Format(Globalization.CultureInfo.CurrentCulture' "{0}[{1}]"' collectionName' set.Count)); " is 128.
Long Statement,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,FindProperty,The length of the statement  "            var props = type.GetProperties(flags).Where(x => x.Name.Equals(propertyName' StringComparison.CurrentCultureIgnoreCase)); " is 121.
Long Statement,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,New,The length of the statement  "                var constructorInfo = type.GetConstructors(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic).SingleOrDefault(c => c.GetParameters().Length == 0); " is 165.
Long Statement,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,AndAlso,The length of the statement  "                    returnType = (left.Type.IsNullableType() && method.ReturnType == left.Type.GetNonNullableType()) ? left.Type : method.ReturnType; " is 129.
Long Statement,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,AndAlso,The length of the statement  "            returnType = (left.Type.IsNullableType() && method.ReturnType == left.Type.GetNonNullableType()) ? left.Type : method.ReturnType; " is 129.
Long Statement,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,OrElse,The length of the statement  "                    returnType = (left.Type.IsNullableType() && method.ReturnType == left.Type.GetNonNullableType()) ? left.Type : method.ReturnType; " is 129.
Long Statement,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,OrElse,The length of the statement  "            returnType = (left.Type.IsNullableType() && method.ReturnType == left.Type.GetNonNullableType()) ? left.Type : method.ReturnType; " is 129.
Long Statement,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,AddAssignChecked,The length of the statement  "                return GetUserDefinedAssignOperatorOrThrow(ExpressionType.AddAssignChecked' "op_Addition"' left' right' conversion' true); " is 122.
Long Statement,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,SubtractAssign,The length of the statement  "                return GetUserDefinedAssignOperatorOrThrow(ExpressionType.SubtractAssign' "op_Subtraction"' left' right' conversion' true); " is 123.
Long Statement,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,SubtractAssignChecked,The length of the statement  "                return GetUserDefinedAssignOperatorOrThrow(ExpressionType.SubtractAssignChecked' "op_Subtraction"' left' right' conversion' true); " is 130.
Long Statement,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,MultiplyAssign,The length of the statement  "                return GetUserDefinedAssignOperatorOrThrow(ExpressionType.MultiplyAssign' "op_Multiply"' left' right' conversion' true); " is 120.
Long Statement,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,MultiplyAssignChecked,The length of the statement  "                return GetUserDefinedAssignOperatorOrThrow(ExpressionType.MultiplyAssignChecked' "op_Multiply"' left' right' conversion' true); " is 127.
Long Statement,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,LeftShiftAssign,The length of the statement  "                return GetUserDefinedAssignOperatorOrThrow(ExpressionType.LeftShiftAssign' "op_LeftShift"' left' right' conversion' true); " is 122.
Long Statement,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,RightShiftAssign,The length of the statement  "                return GetUserDefinedAssignOperatorOrThrow(ExpressionType.RightShiftAssign' "op_RightShift"' left' right' conversion' true); " is 124.
Long Statement,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,ExclusiveOrAssign,The length of the statement  "                return GetUserDefinedAssignOperatorOrThrow(ExpressionType.ExclusiveOrAssign' "op_ExclusiveOr"' left' right' conversion' true); " is 126.
Long Statement,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,CreateLambda,The length of the statement  "                _lambdaFactories = factories = new CacheDict<Type' Func<Expression' string' bool' ReadOnlyCollection<ParameterExpression>' LambdaExpression>>(50); " is 146.
Long Statement,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,CreateLambda,The length of the statement  "                create = typeof(Expression<>).MakeGenericType(delegateType).GetMethod("Create"' BindingFlags.Static | BindingFlags.NonPublic); " is 126.
Long Statement,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,CreateLambda,The length of the statement  "                create = typeof(ExpressionCreator<>).MakeGenericType(delegateType).GetMethod("CreateExpressionFunc"' BindingFlags.Static | BindingFlags.Public); " is 144.
Long Statement,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,CreateLambda,The length of the statement  "                    factories[delegateType] = fastPath = (Func<Expression' string' bool' ReadOnlyCollection<ParameterExpression>' LambdaExpression>)create.CreateDelegate(typeof(Func<Expression' string' bool' ReadOnlyCollection<ParameterExpression>' LambdaExpression>)); " is 249.
Long Statement,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,ListInit,The length of the statement  "                addMethod = FindMethod(newExpression.Type' "Add"' null' new Expression[] { initializer }' BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic); " is 160.
Long Statement,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Property,The length of the statement  "            var pi = expression.Type.GetProperty(propertyName' BindingFlags.Instance | BindingFlags.Public | BindingFlags.IgnoreCase | BindingFlags.FlattenHierarchy); " is 154.
Long Statement,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Property,The length of the statement  "                pi = expression.Type.GetProperty(propertyName' BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.IgnoreCase | BindingFlags.FlattenHierarchy); " is 153.
Long Statement,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Property,The length of the statement  "            var pi = type.GetProperty(propertyName' BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.IgnoreCase | BindingFlags.FlattenHierarchy); " is 165.
Long Statement,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Property,The length of the statement  "                pi = type.GetProperty(propertyName' BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.IgnoreCase | BindingFlags.FlattenHierarchy); " is 164.
Long Statement,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Call,The length of the statement  "            const System.Reflection.BindingFlags flags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy; " is 146.
Long Statement,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Call,The length of the statement  "            const System.Reflection.BindingFlags flags = BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy; " is 144.
Long Statement,System.Linq.Expressions,ExpressionTransformer,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\ExpressionTransformer.cs,VisitBinary,The length of the statement  "                return b.NodeType == ExpressionType.Coalesce && b.Conversion != null ? Expression.Coalesce(left' right' conversion as LambdaExpression) : Expression.MakeBinary(b.NodeType' left' right' b.IsLiftedToNull' b.Method); " is 213.
Long Statement,System.Linq.Expressions,ExpressionTransformer,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\ExpressionTransformer.cs,VisitNewArray,The length of the statement  "                return na.NodeType == ExpressionType.NewArrayInit ? Expression.NewArrayInit(na.Type.GetElementType()' exprs) : Expression.NewArrayBounds(na.Type.GetElementType()' exprs); " is 170.
Long Statement,System.Linq.Expressions.Compiler,AssemblyGen,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\AssemblyGen.cs,DefineType,The length of the statement  "            sb.Replace('+'' '_').Replace('['' '_').Replace(']'' '_').Replace('*'' '_').Replace('&'' '_').Replace('''' '_').Replace('\\'' '_'); " is 130.
Long Statement,System.Linq.Expressions.Compiler,AssemblyGen,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\AssemblyGen.cs,DefineDelegateType,The length of the statement  "                TypeAttributes.Class | TypeAttributes.Public | TypeAttributes.Sealed | TypeAttributes.AnsiClass | TypeAttributes.AutoClass " is 122.
Long Statement,System.Linq.Expressions.Compiler,CompilerScope,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\CompilerScope.net30.cs,EmitVariableAccess,The length of the statement  "                    lc.IL.Emit(OpCodes.Call' typeof(RuntimeOps).GetMethod("CreateRuntimeVariables"' new[] { typeof(object[])' typeof(long[]) })); " is 125.
Long Statement,System.Linq.Expressions.Compiler,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\DelegateHelpers.Generated.cs,MakeNewCustomDelegate,The length of the statement  "            builder.DefineConstructor(_ctorAttributes' CallingConventions.Standard' _delegateCtorSignature).SetImplementationFlags(_implAttributes); " is 136.
Long Statement,System.Linq.Expressions.Compiler,ILGen,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitConstant,The length of the statement  "                    il.Emit(OpCodes.Call' typeof(MethodBase).GetMethod("GetMethodFromHandle"' new Type[] { typeof(RuntimeMethodHandle)' typeof(RuntimeTypeHandle) })); " is 146.
Long Statement,System.Linq.Expressions.Compiler,ILGen,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitDecimalBits,The length of the statement  "            il.EmitNew(typeof(decimal).GetConstructor(new Type[] { typeof(int)' typeof(int)' typeof(int)' typeof(bool)' typeof(byte) })); " is 125.
Long Statement,System.Linq.Expressions.Compiler,LambdaCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.net30.cs,EmitBinaryExpression,The length of the statement  "            Debug.Assert(b.NodeType != ExpressionType.AndAlso && b.NodeType != ExpressionType.OrElse && b.NodeType != ExpressionType.Coalesce); " is 131.
Long Statement,System.Linq.Expressions.Compiler,LambdaCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.net30.cs,EmitLiftedBinaryArithmetic,The length of the statement  "            EmitBinaryOperator(op' leftType.GetNonNullableType()' rightType.GetNonNullableType()' resultType.GetNonNullableType()' false); " is 126.
Long Statement,System.Linq.Expressions.Compiler,LambdaCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.net30.cs,UpdateEmitAsTailCallFlag,The length of the statement  "            Debug.Assert(newValue == CompilationFlags.EmitAsTail || newValue == CompilationFlags.EmitAsMiddle || newValue == CompilationFlags.EmitAsNoTail); " is 144.
Long Statement,System.Linq.Expressions.Compiler,LambdaCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.net30.cs,CreateStaticField,The length of the statement  "            return _typeBuilder.DefineField("<ExpressionCompilerImplementationDetails>{" + Interlocked.Increment(ref _counter) + "}" + name' type' FieldAttributes.Static | FieldAttributes.Private); " is 185.
Long Statement,System.Linq.Expressions.Compiler,StackSpiller,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\StackSpiller.Bindings.net30.cs,VerifyRewrite,The length of the statement  "            Debug.Assert((result.Action == RewriteAction.None) ^ (node != result.Node)' "rewrite action does not match node object identity"); " is 130.
Long Statement,System.Linq.Expressions.Interpreter,BranchLabel,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\BranchLabel.net30.cs,Mark,The length of the statement  "            //ContractUtils.Requires(_targetIndex == UnknownIndex && _stackDepth == UnknownDepth && _continuationStackDepth == UnknownDepth); " is 129.
Long Statement,System.Linq.Expressions.Interpreter,EnterTryCatchFinallyInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\ControlFlowInstructions.net30.cs,Run,The length of the statement  "                    Debug.Assert(instructions[index] is GotoInstruction' "should be the 'Goto' instruction that jumpes out the try/catch/finally"); " is 127.
Long Statement,System.Linq.Expressions.Interpreter,EnterTryCatchFinallyInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\ControlFlowInstructions.net30.cs,Run,The length of the statement  "                        Debug.Assert(instructions[index] is GotoInstruction' "should be the 'Goto' instruction that jumpes out the try/catch/finally"); " is 127.
Long Statement,System.Linq.Expressions.Interpreter,EnterTryCatchFinallyInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\ControlFlowInstructions.net30.cs,Run,The length of the statement  "                    // In the first path' the continuation mechanism works and frame.InstructionIndex will be updated to point to the first instruction of the finally block " is 152.
Long Statement,System.Linq.Expressions.Interpreter,EnterTryCatchFinallyInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\ControlFlowInstructions.net30.cs,Run,The length of the statement  "                    Debug.Assert(!isFromJump || (isFromJump && _tryHandler.FinallyStartIndex == frame.InstructionIndex)' "we should already jump to the first instruction of the finally"); " is 167.
Long Statement,System.Linq.Expressions.Interpreter,EqualSingle,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\EqualInstruction.net30.cs,Run,The length of the statement  "                    frame.Push(ScriptingRuntimeHelpers.BooleanToObject(((float)left) == ((float)right))); // No' don't try to be clever about float comparison " is 138.
Long Statement,System.Linq.Expressions.Interpreter,EqualDouble,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\EqualInstruction.net30.cs,Run,The length of the statement  "                    frame.Push(ScriptingRuntimeHelpers.BooleanToObject(((double)left) == ((double)right))); // No' don't try to be clever about double comparison " is 141.
Long Statement,System.Linq.Expressions.Interpreter,EqualSingleLiftedToNull,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\EqualInstruction.net30.cs,Run,The length of the statement  "                    frame.Push(ScriptingRuntimeHelpers.BooleanToObject(((float)left) == ((float)right))); // No' don't try to be clever about float comparison " is 138.
Long Statement,System.Linq.Expressions.Interpreter,EqualDoubleLiftedToNull,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\EqualInstruction.net30.cs,Run,The length of the statement  "                    frame.Push(ScriptingRuntimeHelpers.BooleanToObject(((double)left) == ((double)right))); // No' don't try to be clever about double comparison " is 141.
Long Statement,System.Linq.Expressions.Interpreter,InstructionList,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\InstructionList.net30.cs,EmitLoadLocalFromClosureBoxed,The length of the statement  "                Emit(_loadLocalFromClosureBoxed[index] ?? (_loadLocalFromClosureBoxed[index] = new LoadLocalFromClosureBoxedInstruction(index))); " is 129.
Long Statement,System.Linq.Expressions.Interpreter,InstructionList,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\InstructionList.net30.cs,EmitByRefCall,The length of the statement  "            Emit(new ByRefMethodInfoCallInstruction(method' method.IsStatic ? parameters.Length : parameters.Length + 1' byrefArgs)); " is 121.
Long Statement,System.Linq.Expressions.Interpreter,LabelInfo,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\LabelInfo.net30.cs,Define,The length of the statement  "                    throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "Label target already defined: {0}"' _node.Name)); " is 130.
Long Statement,System.Linq.Expressions.Interpreter,ExceptionHandler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\LightCompiler.net30.cs,IsBetterThan,The length of the statement  "            Debug.Assert(StartIndex == other.StartIndex && EndIndex == other.EndIndex' "we only need to compare handlers for the same try block"); " is 134.
Long Statement,System.Linq.Expressions.Interpreter,LightCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\LightCompiler.net30.cs,CompileConvertUnaryExpression,The length of the statement  "                CompileConvertToType(node.Operand.Type' node.Type' node.NodeType == ExpressionType.ConvertChecked' node.IsLiftedToNull); " is 120.
Long Statement,System.Linq.Expressions.Interpreter,LightCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\LightCompiler.net30.cs,CompileMultiDimArrayAccess,The length of the statement  "            return new IndexMethodByRefUpdater(objTmp' indexLocals.ToArray()' array.Type.GetMethod("Set"' BindingFlags.Public | BindingFlags.Instance)' index); " is 147.
Long Statement,System.Linq.Expressions.Interpreter,LightCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\LightCompiler.net30.cs,CompileNoLabelPush,The length of the statement  "                string.Format("{0} vs {1} for {2}"' _instructions.CurrentStackDepth' startingStackDepth + (expr.Type == typeof(void) ? 0 : 1)' expr.NodeType)); " is 143.
Long Statement,System.Linq.Expressions.Interpreter,LocalVariable,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\LocalVariables.net30.cs,ToString,The length of the statement  "            return string.Format(CultureInfo.InvariantCulture' "{0}: {1} {2}"' Index' IsBoxed ? "boxed" : null' InClosure ? "in closure" : null); " is 133.
Long Statement,System.Linq.Expressions.Interpreter,NotEqualSingle,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\NotEqualInstruction.net30.cs,Run,The length of the statement  "                    frame.Push(ScriptingRuntimeHelpers.BooleanToObject(((float)left) != ((float)right))); // No' don't try to be clever about float comparison " is 138.
Long Statement,System.Linq.Expressions.Interpreter,NotEqualDouble,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\NotEqualInstruction.net30.cs,Run,The length of the statement  "                    frame.Push(ScriptingRuntimeHelpers.BooleanToObject(((double)left) != ((double)right))); // No' don't try to be clever about double comparison " is 141.
Long Statement,System.Linq.Expressions.Interpreter,NotEqualSingleLiftedToNull,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\NotEqualInstruction.net30.cs,Run,The length of the statement  "                    frame.Push(ScriptingRuntimeHelpers.BooleanToObject(((float)left) != ((float)right))); // No' don't try to be clever about float comparison " is 138.
Long Statement,System.Linq.Expressions.Interpreter,NotEqualDoubleLiftedToNull,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\NotEqualInstruction.net30.cs,Run,The length of the statement  "                    frame.Push(ScriptingRuntimeHelpers.BooleanToObject(((double)left) != ((double)right))); // No' don't try to be clever about double comparison " is 141.
Long Statement,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,CompareTo,The length of the statement  "            return ((length != 2 ? InternalBits[0] : NumericsHelpers.MakeUlong(InternalBits[1]' InternalBits[0]))).CompareTo(other); " is 120.
Long Statement,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,FormatBigInteger,The length of the statement  "                        append = StringWithGroups(length' new ExtendedEnumerable<char>(new[] { '0'' '0' }' builder)' groupingSizes' groupingSeparator); " is 127.
Long Statement,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,ParseNumber,The length of the statement  "                if (!isCurrency && allowCurrencySymbol && reader.Read(currencySymbol)) // If the currency symbol is after the negative sign " is 123.
Long Statement,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,ParseNumber,The length of the statement  "                if (!isCurrency && allowCurrencySymbol && reader.Read(currencySymbol)) // If the currency symbol is after the negative sign " is 123.
Long Statement,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,TryValidateParseStyleInteger,The length of the statement  "            if ((style & NumberStyles.AllowHexSpecifier) == NumberStyles.None || (style & (NumberStyles.AllowLeadingSign | NumberStyles.AllowTrailingSign | NumberStyles.AllowParentheses | NumberStyles.AllowDecimalPoint | NumberStyles.AllowThousands | NumberStyles.AllowExponent | NumberStyles.AllowCurrencySymbol)) == NumberStyles.None) " is 324.
Long Statement,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,TryValidateParseStyleInteger,The length of the statement  "            e = new ArgumentException("With the AllowHexSpecifier bit set in the enum bit field' the only other valid bits that can be combined into the enum value must be a subset of those in HexNumber."); " is 194.
Long Statement,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,ToValueTuple,The length of the statement  "                        ValueTuple.Create(value.Rest.Item1' value.Rest.Item2' value.Rest.Item3' value.Rest.Item4' value.Rest.Item5' value.Rest.Item6)); " is 127.
Long Statement,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,ToValueTuple,The length of the statement  "                        ValueTuple.Create(value.Rest.Item1' value.Rest.Item2' value.Rest.Item3' value.Rest.Item4' value.Rest.Item5' value.Rest.Item6' value.Rest.Item7)); " is 145.
Long Statement,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,ToValueTuple,The length of the statement  "                        CreateLong(value.Rest.Item1' value.Rest.Item2' value.Rest.Item3' value.Rest.Item4' value.Rest.Item5' value.Rest.Item6' value.Rest.Item7' " is 136.
Long Statement,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,ToValueTuple,The length of the statement  "                        CreateLong(value.Rest.Item1' value.Rest.Item2' value.Rest.Item3' value.Rest.Item4' value.Rest.Item5' value.Rest.Item6' value.Rest.Item7' " is 136.
Long Statement,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,ToValueTuple,The length of the statement  "                        CreateLong(value.Rest.Item1' value.Rest.Item2' value.Rest.Item3' value.Rest.Item4' value.Rest.Item5' value.Rest.Item6' value.Rest.Item7' " is 136.
Long Statement,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,ToValueTuple,The length of the statement  "                        CreateLong(value.Rest.Item1' value.Rest.Item2' value.Rest.Item3' value.Rest.Item4' value.Rest.Item5' value.Rest.Item6' value.Rest.Item7' " is 136.
Long Statement,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,ToValueTuple,The length of the statement  "                        CreateLong(value.Rest.Item1' value.Rest.Item2' value.Rest.Item3' value.Rest.Item4' value.Rest.Item5' value.Rest.Item6' value.Rest.Item7' " is 136.
Long Statement,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,ToValueTuple,The length of the statement  "                            ValueTuple.Create(value.Rest.Rest.Item1' value.Rest.Rest.Item2' value.Rest.Rest.Item3' value.Rest.Rest.Item4' value.Rest.Rest.Item5))); " is 135.
Long Statement,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,ToValueTuple,The length of the statement  "                        CreateLong(value.Rest.Item1' value.Rest.Item2' value.Rest.Item3' value.Rest.Item4' value.Rest.Item5' value.Rest.Item6' value.Rest.Item7' " is 136.
Long Statement,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,ToValueTuple,The length of the statement  "                            ValueTuple.Create(value.Rest.Rest.Item1' value.Rest.Rest.Item2' value.Rest.Rest.Item3' value.Rest.Rest.Item4' value.Rest.Rest.Item5' value.Rest.Rest.Item6))); " is 158.
Long Statement,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,ToValueTuple,The length of the statement  "                        CreateLong(value.Rest.Item1' value.Rest.Item2' value.Rest.Item3' value.Rest.Item4' value.Rest.Item5' value.Rest.Item6' value.Rest.Item7' " is 136.
Long Statement,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,ToValueTuple,The length of the statement  "                            ValueTuple.Create(value.Rest.Rest.Item1' value.Rest.Rest.Item2' value.Rest.Rest.Item3' value.Rest.Rest.Item4' value.Rest.Rest.Item5' value.Rest.Rest.Item6' value.Rest.Rest.Item7))); " is 181.
Long Statement,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,ToTuple,The length of the statement  "                        Tuple.Create(value.Rest.Item1' value.Rest.Item2' value.Rest.Item3' value.Rest.Item4' value.Rest.Item5' value.Rest.Item6)); " is 122.
Long Statement,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,ToTuple,The length of the statement  "                        Tuple.Create(value.Rest.Item1' value.Rest.Item2' value.Rest.Item3' value.Rest.Item4' value.Rest.Item5' value.Rest.Item6' value.Rest.Item7)); " is 140.
Long Statement,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,ToTuple,The length of the statement  "                        CreateLongRef(value.Rest.Item1' value.Rest.Item2' value.Rest.Item3' value.Rest.Item4' value.Rest.Item5' value.Rest.Item6' value.Rest.Item7' " is 139.
Long Statement,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,ToTuple,The length of the statement  "                        CreateLongRef(value.Rest.Item1' value.Rest.Item2' value.Rest.Item3' value.Rest.Item4' value.Rest.Item5' value.Rest.Item6' value.Rest.Item7' " is 139.
Long Statement,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,ToTuple,The length of the statement  "                        CreateLongRef(value.Rest.Item1' value.Rest.Item2' value.Rest.Item3' value.Rest.Item4' value.Rest.Item5' value.Rest.Item6' value.Rest.Item7' " is 139.
Long Statement,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,ToTuple,The length of the statement  "                        CreateLongRef(value.Rest.Item1' value.Rest.Item2' value.Rest.Item3' value.Rest.Item4' value.Rest.Item5' value.Rest.Item6' value.Rest.Item7' " is 139.
Long Statement,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,ToTuple,The length of the statement  "                        CreateLongRef(value.Rest.Item1' value.Rest.Item2' value.Rest.Item3' value.Rest.Item4' value.Rest.Item5' value.Rest.Item6' value.Rest.Item7' " is 139.
Long Statement,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,ToTuple,The length of the statement  "                            Tuple.Create(value.Rest.Rest.Item1' value.Rest.Rest.Item2' value.Rest.Rest.Item3' value.Rest.Rest.Item4' value.Rest.Rest.Item5))); " is 130.
Long Statement,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,ToTuple,The length of the statement  "                        CreateLongRef(value.Rest.Item1' value.Rest.Item2' value.Rest.Item3' value.Rest.Item4' value.Rest.Item5' value.Rest.Item6' value.Rest.Item7' " is 139.
Long Statement,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,ToTuple,The length of the statement  "                            Tuple.Create(value.Rest.Rest.Item1' value.Rest.Rest.Item2' value.Rest.Rest.Item3' value.Rest.Rest.Item4' value.Rest.Rest.Item5' value.Rest.Rest.Item6))); " is 153.
Long Statement,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,ToTuple,The length of the statement  "                        CreateLongRef(value.Rest.Item1' value.Rest.Item2' value.Rest.Item3' value.Rest.Item4' value.Rest.Item5' value.Rest.Item6' value.Rest.Item7' " is 139.
Long Statement,System,TupleExtensions,C:\repos\theraot_Theraot\Core\System\ValueTuple.net40.cs,ToTuple,The length of the statement  "                            Tuple.Create(value.Rest.Rest.Item1' value.Rest.Rest.Item2' value.Rest.Rest.Item3' value.Rest.Rest.Item4' value.Rest.Rest.Item5' value.Rest.Rest.Item6' value.Rest.Rest.Item7))); " is 176.
Long Statement,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,Create,The length of the statement  "            return new ValueTuple<T1' T2' T3' T4' T5' T6' T7' ValueTuple<T8>>(item1' item2' item3' item4' item5' item6' item7' Create(item8)); " is 130.
Long Statement,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,ToString,The length of the statement  "            return "(" + (ReferenceEquals(Item1' null) ? "" : Item1.ToString()) + "' " + (ReferenceEquals(Item2' null) ? "" : Item2.ToString()) + ")"; " is 138.
Long Statement,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,ToStringEnd,The length of the statement  "            return (ReferenceEquals(Item1' null) ? "" : Item1.ToString()) + "' " + (ReferenceEquals(Item2' null) ? "" : Item2.ToString()) + ")"; " is 132.
Long Statement,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,ToString,The length of the statement  "            return "(" + (ReferenceEquals(Item1' null) ? "" : Item1.ToString()) + "' " + (ReferenceEquals(Item2' null) ? "" : Item2.ToString()) + "' " + (ReferenceEquals(Item3' null) ? "" : Item3.ToString()) + ")"; " is 202.
Long Statement,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,ToStringEnd,The length of the statement  "            return (ReferenceEquals(Item1' null) ? "" : Item1.ToString()) + "' " + (ReferenceEquals(Item2' null) ? "" : Item2.ToString()) + "' " + (ReferenceEquals(Item3' null) ? "" : Item3.ToString()) + ")"; " is 196.
Long Statement,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,ToString,The length of the statement  "            return "(" + (ReferenceEquals(Item1' null) ? "" : Item1.ToString()) + "' " + (ReferenceEquals(Item2' null) ? "" : Item2.ToString()) + "' " + (ReferenceEquals(Item3' null) ? "" : Item3.ToString()) + "' " + (ReferenceEquals(Item4' null) ? "" : Item4.ToString()) + ")"; " is 266.
Long Statement,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,ToStringEnd,The length of the statement  "            return (ReferenceEquals(Item1' null) ? "" : Item1.ToString()) + "' " + (ReferenceEquals(Item2' null) ? "" : Item2.ToString()) + "' " + (ReferenceEquals(Item3' null) ? "" : Item3.ToString()) + "' " + (ReferenceEquals(Item4' null) ? "" : Item4.ToString()) + ")"; " is 260.
Long Statement,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,ToString,The length of the statement  "            return "(" + (ReferenceEquals(Item1' null) ? "" : Item1.ToString()) + "' " + (ReferenceEquals(Item2' null) ? "" : Item2.ToString()) + "' " + (ReferenceEquals(Item3' null) ? "" : Item3.ToString()) + "' " + (ReferenceEquals(Item4' null) ? "" : Item4.ToString()) + "' " + (ReferenceEquals(Item5' null) ? "" : Item5.ToString()) + ")"; " is 330.
Long Statement,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,ToStringEnd,The length of the statement  "            return (ReferenceEquals(Item1' null) ? "" : Item1.ToString()) + "' " + (ReferenceEquals(Item2' null) ? "" : Item2.ToString()) + "' " + (ReferenceEquals(Item3' null) ? "" : Item3.ToString()) + "' " + (ReferenceEquals(Item4' null) ? "" : Item4.ToString()) + "' " + (ReferenceEquals(Item5' null) ? "" : Item5.ToString()) + ")"; " is 324.
Long Statement,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,ToString,The length of the statement  "            return "(" + (ReferenceEquals(Item1' null) ? "" : Item1.ToString()) + "' " + (ReferenceEquals(Item2' null) ? "" : Item2.ToString()) + "' " + (ReferenceEquals(Item3' null) ? "" : Item3.ToString()) + "' " + (ReferenceEquals(Item4' null) ? "" : Item4.ToString()) + "' " + (ReferenceEquals(Item5' null) ? "" : Item5.ToString()) + "' " + (ReferenceEquals(Item6' null) ? "" : Item6.ToString()) + ")"; " is 394.
Long Statement,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,ToStringEnd,The length of the statement  "            return (ReferenceEquals(Item1' null) ? "" : Item1.ToString()) + "' " + (ReferenceEquals(Item2' null) ? "" : Item2.ToString()) + "' " + (ReferenceEquals(Item3' null) ? "" : Item3.ToString()) + "' " + (ReferenceEquals(Item4' null) ? "" : Item4.ToString()) + "' " + (ReferenceEquals(Item5' null) ? "" : Item5.ToString()) + "' " + (ReferenceEquals(Item6' null) ? "" : Item6.ToString()) + ")"; " is 388.
Long Statement,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,ToString,The length of the statement  "            return "(" + (ReferenceEquals(Item1' null) ? "" : Item1.ToString()) + "' " + (ReferenceEquals(Item2' null) ? "" : Item2.ToString()) + "' " + (ReferenceEquals(Item3' null) ? "" : Item3.ToString()) + "' " + (ReferenceEquals(Item4' null) ? "" : Item4.ToString()) + "' " + (ReferenceEquals(Item5' null) ? "" : Item5.ToString()) + "' " + (ReferenceEquals(Item6' null) ? "" : Item6.ToString()) + "' " + (ReferenceEquals(Item7' null) ? "" : Item7.ToString()) + ")"; " is 458.
Long Statement,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,ToStringEnd,The length of the statement  "            return (ReferenceEquals(Item1' null) ? "" : Item1.ToString()) + "' " + (ReferenceEquals(Item2' null) ? "" : Item2.ToString()) + "' " + (ReferenceEquals(Item3' null) ? "" : Item3.ToString()) + "' " + (ReferenceEquals(Item4' null) ? "" : Item4.ToString()) + "' " + (ReferenceEquals(Item5' null) ? "" : Item5.ToString()) + "' " + (ReferenceEquals(Item6' null) ? "" : Item6.ToString()) + "' " + (ReferenceEquals(Item7' null) ? "" : Item7.ToString()) + ")"; " is 452.
Long Statement,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,Equals,The length of the statement  "            return obj is ValueTuple<T1' T2' T3' T4' T5' T6' T7' TRest> && Equals((ValueTuple<T1' T2' T3' T4' T5' T6' T7' TRest>)obj); " is 122.
Long Statement,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,GetHashCode,The length of the statement  "            // In this case' the rest member has less than 8 elements so we need to combine some our elements with the elements in rest " is 123.
Long Statement,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,GetHashCodeCore,The length of the statement  "                return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item1)' comparer.GetHashCode(Item2)' comparer.GetHashCode(Item3)' " is 121.
Long Statement,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,GetHashCodeCore,The length of the statement  "            // In this case' the rest member has less than 8 elements so we need to combine some our elements with the elements in rest " is 123.
Long Statement,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,GetHashCodeCore,The length of the statement  "                    return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)' rest.GetHashCode(comparer)); " is 121.
Long Statement,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,GetHashCodeCore,The length of the statement  "                    return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)' " is 121.
Long Statement,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,GetHashCodeCore,The length of the statement  "                    return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)' " is 121.
Long Statement,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,GetHashCodeCore,The length of the statement  "                    return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item3)' comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)' " is 121.
Long Statement,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,GetHashCodeCore,The length of the statement  "                    return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item2)' comparer.GetHashCode(Item3)' comparer.GetHashCode(Item4)' " is 121.
Long Statement,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,GetHashCodeCore,The length of the statement  "                    return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item1)' comparer.GetHashCode(Item2)' comparer.GetHashCode(Item3)' " is 121.
Long Statement,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,ToString,The length of the statement  "            return rest == null ? "(" + (ReferenceEquals(Item1' null) ? "" : Item1.ToString()) + "' " + (ReferenceEquals(Item2' null) ? "" : Item2.ToString()) + "' " + (ReferenceEquals(Item3' null) ? "" : Item3.ToString()) + "' " + (ReferenceEquals(Item4' null) ? "" : Item4.ToString()) + "' " + (ReferenceEquals(Item5' null) ? "" : Item5.ToString()) + "' " + (ReferenceEquals(Item6' null) ? "" : Item6.ToString()) + "' " + (ReferenceEquals(Item7' null) ? "" : Item7.ToString()) + "' " + Rest.ToString() + ")" : "(" + (ReferenceEquals(Item1' null) ? "" : Item1.ToString()) + "' " + (ReferenceEquals(Item2' null) ? "" : Item2.ToString()) + "' " + (ReferenceEquals(Item3' null) ? "" : Item3.ToString()) + "' " + (ReferenceEquals(Item4' null) ? "" : Item4.ToString()) + "' " + (ReferenceEquals(Item5' null) ? "" : Item5.ToString()) + "' " + (ReferenceEquals(Item6' null) ? "" : Item6.ToString()) + "' " + (ReferenceEquals(Item7' null) ? "" : Item7.ToString()) + "' " + rest.ToStringEnd(); " is 973.
Long Statement,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,ToStringEnd,The length of the statement  "            return rest == null ? (ReferenceEquals(Item1' null) ? "" : Item1.ToString()) + "' " + (ReferenceEquals(Item2' null) ? "" : Item2.ToString()) + "' " + (ReferenceEquals(Item3' null) ? "" : Item3.ToString()) + "' " + (ReferenceEquals(Item4' null) ? "" : Item4.ToString()) + "' " + (ReferenceEquals(Item5' null) ? "" : Item5.ToString()) + "' " + (ReferenceEquals(Item6' null) ? "" : Item6.ToString()) + "' " + (ReferenceEquals(Item7' null) ? "" : Item7.ToString()) + "' " + Rest.ToString() + ")" : (ReferenceEquals(Item1' null) ? "" : Item1.ToString()) + "' " + (ReferenceEquals(Item2' null) ? "" : Item2.ToString()) + "' " + (ReferenceEquals(Item3' null) ? "" : Item3.ToString()) + "' " + (ReferenceEquals(Item4' null) ? "" : Item4.ToString()) + "' " + (ReferenceEquals(Item5' null) ? "" : Item5.ToString()) + "' " + (ReferenceEquals(Item6' null) ? "" : Item6.ToString()) + "' " + (ReferenceEquals(Item7' null) ? "" : Item7.ToString()) + "' " + rest.ToStringEnd(); " is 961.
Long Statement,System,Tuple<T1;T2;T3;T4;T5;T6;T7;TRest>,C:\repos\theraot_Theraot\Core\System\Tuple8.net35.cs,ToString,The length of the statement  "            return string.Format(CultureInfo.InvariantCulture' "({0}' {1}' {2}' {3}' {4}' {5}' {6}' {7})"' _item1' _item2' _item3' _item4' _item5' _item6' _item7' restString.Substring(1' restString.Length - 2)); " is 199.
Long Statement,System,Tuple<T1;T2;T3;T4;T5;T6;T7>,C:\repos\theraot_Theraot\Core\System\Tuple7.net35.cs,ToString,The length of the statement  "            return string.Format(CultureInfo.InvariantCulture' "({0}' {1}' {2}' {3}' {4}' {5}' {6})"' _item1' _item2' _item3' _item4' _item5' _item6' _item7); " is 146.
Long Statement,System,Tuple<T1;T2;T3;T4;T5;T6>,C:\repos\theraot_Theraot\Core\System\Tuple6.net35.cs,ToString,The length of the statement  "            return string.Format(CultureInfo.InvariantCulture' "({0}' {1}' {2}' {3}' {4}' {5})"' _item1' _item2' _item3' _item4' _item5' _item6); " is 133.
Long Statement,System,Tuple<T1;T2;T3;T4;T5>,C:\repos\theraot_Theraot\Core\System\Tuple5.net35.cs,ToString,The length of the statement  "            return string.Format(CultureInfo.InvariantCulture' "({0}' {1}' {2}' {3}' {4})"' _item1' _item2' _item3' _item4' _item5); " is 120.
Long Statement,System,Tuple,C:\repos\theraot_Theraot\Core\System\Tuple.net35.cs,Create,The length of the statement  "            return new Tuple<T1' T2' T3' T4' T5' T6' T7' Tuple<T8>>(item1' item2' item3' item4' item5' item6' item7' new Tuple<T8>(item8)); " is 127.
Long Statement,System.Threading,Barrier,C:\repos\theraot_Theraot\Core\System\Threading\Barrier.net35.cs,AddParticipant,The length of the statement  "                throw new InvalidOperationException("Adding participantCount participants would result in the number of participants exceeding the maximum number allowed."); " is 157.
Long Statement,System.Threading,Barrier,C:\repos\theraot_Theraot\Core\System\Threading\Barrier.net35.cs,AddParticipants,The length of the statement  "                        "Adding participantCount participants would result in the number of participants exceeding the maximum number allowed."); " is 121.
Long Statement,System.Threading,Barrier,C:\repos\theraot_Theraot\Core\System\Threading\Barrier.net35.cs,AddParticipants,The length of the statement  "                        "Adding participantCount participants would result in the number of participants exceeding the maximum number allowed."); " is 121.
Long Statement,System.Threading,Barrier,C:\repos\theraot_Theraot\Core\System\Threading\Barrier.net35.cs,AddParticipants,The length of the statement  "                    // Calculating the first phase for that participant' if the current phase already finished return the next phase else return the current phase " is 142.
Long Statement,System.Threading,Barrier,C:\repos\theraot_Theraot\Core\System\Threading\Barrier.net35.cs,AddParticipants,The length of the statement  "                    // phase odd even' so that means it didn't yet change the phase count' so currentPhase +1 is returned' otherwise currentPhase is returned " is 137.
Long Statement,System.Threading,Barrier,C:\repos\theraot_Theraot\Core\System\Threading\Barrier.net35.cs,AddParticipants,The length of the statement  "                    // If this participant is going to join the next phase' which means the postPhaseAction is being running' this participants must wait until this done " is 149.
Long Statement,System.Threading,Barrier,C:\repos\theraot_Theraot\Core\System\Threading\Barrier.net35.cs,AddParticipants,The length of the statement  "                    // Without that' if the postPhaseAction takes long time' this means the event that the current participant is going to wait on is still set " is 139.
Long Statement,System.Threading,Barrier,C:\repos\theraot_Theraot\Core\System\Threading\Barrier.net35.cs,AddParticipants,The length of the statement  "                    //This else to fix the racing where the current phase has been finished' m_currentPhase has been updated but the events have not been set/reset yet " is 147.
Long Statement,System.Threading,Barrier,C:\repos\theraot_Theraot\Core\System\Threading\Barrier.net35.cs,AddParticipants,The length of the statement  "                    // otherwise when this participant calls SignalAndWait it will wait on a set event however all other participants have not arrived yet. " is 135.
Long Statement,System.Threading,Barrier,C:\repos\theraot_Theraot\Core\System\Threading\Barrier.net35.cs,RemoveParticipants,The length of the statement  "                    throw new InvalidOperationException("The participantCount argument is greater than the number of participants that haven't yet arrived at the barrier in this phase."); " is 167.
Long Statement,System.Threading,Barrier,C:\repos\theraot_Theraot\Core\System\Threading\Barrier.net35.cs,SignalAndWait,The length of the statement  "                // This can be detected if the current is zero which means all participants for that phase has arrived and the phase number is not changed yet " is 142.
Long Statement,System.Threading,Barrier,C:\repos\theraot_Theraot\Core\System\Threading\Barrier.net35.cs,SignalAndWait,The length of the statement  "                    throw new InvalidOperationException("The number of threads using the barrier exceeded the total number of registered participants."); " is 133.
Long Statement,System.Threading,Barrier,C:\repos\theraot_Theraot\Core\System\Threading\Barrier.net35.cs,SignalAndWait,The length of the statement  "            catch (ObjectDisposedException)// in case a race happen where one of the thread returned from SignalAndWait and the current thread calls Wait on a disposed event " is 161.
Long Statement,System.Threading,Barrier,C:\repos\theraot_Theraot\Core\System\Threading\Barrier.net35.cs,SignalAndWait,The length of the statement  "                    // If the timeout expired and the phase has just finished' return true and this is considered as succeeded SignalAndWait " is 120.
Long Statement,System.Threading,Barrier,C:\repos\theraot_Theraot\Core\System\Threading\Barrier.net35.cs,SignalAndWait,The length of the statement  "                        // The current phase has been finished' but we shouldn't return before the events are set/reset otherwise this thread could start " is 129.
Long Statement,System.Threading,Barrier,C:\repos\theraot_Theraot\Core\System\Threading\Barrier.net35.cs,SignalAndWait,The length of the statement  "                        // next phase and the appropriate event has not reset yet which could make it return immediately from the next phase SignalAndWait " is 130.
Long Statement,System.Threading,Barrier,C:\repos\theraot_Theraot\Core\System\Threading\Barrier.net35.cs,SetResetEvents,The length of the statement  "            // Increment the phase count using Volatile class because m_currentPhase is 64 bit long type' that could cause torn write on 32 bit machines " is 140.
Long Statement,System.Threading,Barrier,C:\repos\theraot_Theraot\Core\System\Threading\Barrier.net35.cs,DiscontinuousWait,The length of the statement  "                //if the maxwait exceeded 10 seconds then we will stop increasing the maxWait time and keep it 10 seconds' otherwise keep doubling it " is 133.
Long Statement,System.Threading,CancellationTokenSource,C:\repos\theraot_Theraot\Core\System\Threading\CancellationTokenSource.net35.cs,Register,The length of the statement  "                // Check if the source was just canceled and if so' it may be that it executed the callbacks except the one just added... " is 121.
Long Statement,System.Threading,CancellationTokenSource,C:\repos\theraot_Theraot\Core\System\Threading\CancellationTokenSource.net35.cs,CancelExtracted,The length of the statement  "                    // Whatever was added after the cancellation process started' it should run inline in Register... if they don't' handle then here. " is 130.
Long Statement,System.Threading,ReaderWriterLockSlim,C:\repos\theraot_Theraot\Core\System\Threading\ReaderWriterLockSlim.net35.cs,CheckState,The length of the statement  "            if (ctstate != LockState.None && _noRecursion && (!ctstate.Has(LockState.Upgradable) || validState == LockState.Upgradable)) " is 124.
Long Statement,System.Threading,SemaphoreSlim,C:\repos\theraot_Theraot\Core\System\Threading\SemaphoreSlim.net35.cs,TryEnter,The length of the statement  "                    // It is possible that another thread has just released more slots and called _event.Set() and we have just undone it... " is 120.
Long Statement,System.Threading,SpinLock,C:\repos\theraot_Theraot\Core\System\Threading\SpinLock.net35.cs,Enter,The length of the statement  "                        if (Interlocked.CompareExchange(ref _isHeld' 1' 0) == 0 && ReferenceEquals(Interlocked.CompareExchange(ref _ownerThread' Thread.CurrentThread' null)' null)) " is 156.
Long Statement,System.Threading,SpinLock,C:\repos\theraot_Theraot\Core\System\Threading\SpinLock.net35.cs,TryEnter,The length of the statement  "                    lockTaken |= (ThreadingHelper.SpinWaitSet(ref _isHeld' 1' 0' millisecondsTimeout) && ReferenceEquals(Interlocked.CompareExchange(ref _ownerThread' Thread.CurrentThread' null)' null)); " is 183.
Long Statement,System.Threading,ThreadLocal<T>,C:\repos\theraot_Theraot\Core\System\Threading\ThreadLocal.net35.cs,ToString,The length of the statement  "            return string.Format(Globalization.CultureInfo.InvariantCulture' "[ThreadLocal: IsValueCreated={0}' Value={1}]"' IsValueCreated' Value); " is 136.
Long Statement,System.Threading.Tasks,AwaitTaskContinuation,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\AwaitTaskContinuation.cs,Run,The length of the statement  "                RunCallback(GetInvokeActionCallback()' Action' ref Task.InternalCurrent); // any exceptions from Action will be handled by s_callbackRunAction " is 142.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,Delay,The length of the statement  "                throw new ArgumentOutOfRangeException("delay"' "The value needs to translate in milliseconds to - 1(signifying an infinite timeout)' 0 or a positive integer less than or equal to Int32.MaxValue"); " is 196.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,Delay,The length of the statement  "                throw new ArgumentOutOfRangeException("millisecondsDelay"' "The value needs to be either -1 (signifying an infinite timeout)' 0 or a positive integer."); " is 153.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,WhenAny,The length of the statement  "            return intermediate.ContinueWith(Task<TResult>.ContinuationConvertion' default(CancellationToken)' TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.DenyChildAttach' TaskScheduler.Default); " is 210.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,WhenAny,The length of the statement  "            return intermediate.ContinueWith(Task<TResult>.ContinuationConvertion' default(CancellationToken)' TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.DenyChildAttach' TaskScheduler.Default); " is 210.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,SetNotificationForWaitCompletion,The length of the statement  "            Contract.Assert(IsPromiseTask' "Should only be used for promise-style tasks"); // hasn't been vetted on other kinds as there hasn't been a need " is 143.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,WaitAll,The length of the statement  "            // We make sure that the exception behavior of Task.Wait() is replicated the same for tasks handled in either of these codepaths " is 128.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,WaitAll,The length of the statement  "                        taskIsCompleted = task.TryStart(task.ExecutingTaskScheduler' true) && task.IsCompleted; // A successful TryRunInline doesn't guarantee completion " is 145.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,TrySetCanceledPromise,The length of the statement  "            Contract.Assert(IsPromiseTask' "Task.RecordInternalCancellationRequest(CancellationToken) only valid for promise-style task"); " is 126.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,DisregardChild,The length of the statement  "            Contract.Assert(Thread.VolatileRead(ref _completionCountdown) >= 2' "Task.DisregardChild(): Expected parent count to be >= 2"); " is 127.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,Finish,The length of the statement  "                    // Apparently some children still remain. It will be up to the last one to process the completion of this task on their own thread. " is 131.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,Finish,The length of the statement  "                // Now is the time to prune exceptional children. We'll walk the list and removes the ones whose exceptions we might have observed after they threw. " is 148.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,Finish,The length of the statement  "                // we use a local variable for exceptional children here because some other thread may be nulling out _exceptionalChildren " is 122.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,Finish,The length of the statement  "                        exceptionalChildren.RemoveAll(_isExceptionObservedByParentPredicate); // RemoveAll has better performance than doing it ourselves " is 129.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,FinishStageThree,The length of the statement  "            if (_parent != null && ((_parent._creationOptions & TaskCreationOptions.DenyChildAttach) == 0) && (_creationOptions & TaskCreationOptions.AttachedToParent) != 0) " is 161.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,ProcessChildCompletion,The length of the statement  "                // This call came from the final child to complete' and apparently we have previously given up this task's right to complete itself. " is 132.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,UpdateExceptionObservedStatus,The length of the statement  "            if ((_parent != null) && ((_creationOptions & TaskCreationOptions.AttachedToParent) != 0) && ((_parent._creationOptions & TaskCreationOptions.DenyChildAttach) == 0) && InternalCurrent == _parent) " is 195.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,AddNewChild,The length of the statement  "            Contract.Assert(InternalCurrent == this || IsSelfReplicatingRoot' "Task.AddNewChild(): Called from an external context"); " is 121.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,AssignCancellationToken,The length of the statement  "                // We exclude Promise tasks from this' because TaskCompletionSource needs to fully control the inner tasks's lifetime (i.e. not allow external cancellations) " is 157.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,AssignCancellationToken,The length of the statement  "                if ((_internalOptions & (InternalTaskOptions.QueuedByRuntime | InternalTaskOptions.PromiseTask | InternalTaskOptions.LazyCancellation)) == 0) " is 141.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,AssignCancellationToken,The length of the statement  "                            registration = cancellationToken.Register(_taskCancelCallback' new Tuple<Task' Task' TaskContinuation>(this' antecedent' continuation)); " is 136.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,ContinueWith,The length of the statement  "            return ContinueWith(continuationAction' TaskScheduler.Current' default(CancellationToken)' TaskContinuationOptions.None); " is 121.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,ContinueWith,The length of the statement  "            return ContinueWith(continuationAction' state' TaskScheduler.Current' default(CancellationToken)' TaskContinuationOptions.None); " is 128.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,ContinueWith,The length of the statement  "            return ContinueWith(continuationFunction' TaskScheduler.Current' default(CancellationToken)' TaskContinuationOptions.None); " is 123.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,ContinueWith,The length of the statement  "            return ContinueWith(continuationFunction' state' TaskScheduler.Current' default(CancellationToken)' TaskContinuationOptions.None); " is 130.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,ContinueWith,The length of the statement  "            return ContinueWith(continuationFunction' state' TaskScheduler.Current' cancellationToken' TaskContinuationOptions.None); " is 121.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,ContinueWith,The length of the statement  "            return ContinueWith(continuationFunction' state' TaskScheduler.Current' default(CancellationToken)' continuationOptions); " is 121.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,CreationOptionsFromContinuationOptions,The length of the statement  "            const TaskContinuationOptions NotOnAnything = TaskContinuationOptions.NotOnCanceled | TaskContinuationOptions.NotOnFaulted | TaskContinuationOptions.NotOnRanToCompletion; " is 170.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,CreationOptionsFromContinuationOptions,The length of the statement  "            const TaskContinuationOptions CreationOptionsMask = TaskContinuationOptions.PreferFairness | TaskContinuationOptions.LongRunning | TaskContinuationOptions.DenyChildAttach | TaskContinuationOptions.HideScheduler | TaskContinuationOptions.AttachedToParent | TaskContinuationOptions.RunContinuationsAsynchronously; " is 311.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,CreationOptionsFromContinuationOptions,The length of the statement  "            const TaskContinuationOptions IllegalMask = TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.LongRunning; " is 127.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,CreationOptionsFromContinuationOptions,The length of the statement  "                throw new ArgumentOutOfRangeException("continuationOptions"' "The specified TaskContinuationOptions combined LongRunning and ExecuteSynchronously.  Synchronous continuations should not be long running."); " is 204.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,CreationOptionsFromContinuationOptions,The length of the statement  "            if ((continuationOptions & ~(CreationOptionsMask | NotOnAnything | TaskContinuationOptions.LazyCancellation | TaskContinuationOptions.ExecuteSynchronously)) != 0) " is 162.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,CreationOptionsFromContinuationOptions,The length of the statement  "                throw new ArgumentOutOfRangeException("continuationOptions"' "The specified TaskContinuationOptions excluded all continuation kinds."); " is 135.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,FinishContinuations,The length of the statement  "            if (Interlocked.CompareExchange(ref _continuationsStatus' _takingContinuations' _continuationsNotInitialized) == _continuationsNotInitialized) " is 142.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,FinishContinuations,The length of the statement  "            if (Interlocked.CompareExchange(ref _continuationsStatus' _takingContinuations' _continuationsInitialization) == _continuationsInitialization) " is 142.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,FinishContinuations,The length of the statement  "                            Contract.Assert(currentContinuation is ITaskCompletionAction' "Expected continuation element to be Action' TaskContinuation' or ITaskContinuationAction"); " is 154.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,RetrieveContinuations,The length of the statement  "                    if (Interlocked.CompareExchange(ref _continuationsStatus' _continuationsInitialization' _continuationsNotInitialized) == _continuationsNotInitialized) " is 150.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,RetrieveContinuations,The length of the statement  "                    while (Thread.VolatileRead(ref _continuationsStatus) == _continuationsInitialization && (continuations = Interlocked.CompareExchange(ref _continuations' null' null)) == null) " is 174.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,InternalCancel,The length of the statement  "            Contract.Requires((_internalOptions & InternalTaskOptions.PromiseTask) == 0' "Task.InternalCancel() did not expect promise-style task"); " is 136.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,InternalCancel,The length of the statement  "                // Note: status may advance to TaskStatus.Running or even TaskStatus.RanToCompletion during the execution of this method " is 120.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,InternalCancel,The length of the statement  "                // We are going to pretend that the cancel call came after the task finished running' but we may still set to cancel on TaskStatus.WaitingForChildrenToComplete " is 159.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,InternalCancel,The length of the statement  "                status = Interlocked.CompareExchange(ref _status' (int)TaskStatus.Canceled' (int)TaskStatus.WaitingForChildrenToComplete); " is 122.
Long Statement,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,PrivateRunSynchronously,The length of the statement  "                throw new InvalidOperationException("RunSynchronously may not be called on a task not bound to a delegate' such as the task returned from an asynchronous method."); " is 164.
Long Statement,System.Threading.Tasks,SynchronizationContextAwaitTaskContinuation,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\SynchronizationContextAwaitTaskContinuation.cs,PostAction,The length of the statement  "            c._syncContext.Post(_postCallback' c.Action); // s_postCallback is manually cached' as the compiler won't in a SecurityCritical method " is 134.
Long Statement,System.Threading.Tasks,Task<TResult>,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\Task.await.net35.cs,ContinueWith,The length of the statement  "            return ContinueWith(continuationAction' TaskScheduler.Current' default(CancellationToken)' TaskContinuationOptions.None); " is 121.
Long Statement,System.Threading.Tasks,Task<TResult>,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\Task.await.net35.cs,ContinueWith,The length of the statement  "            return ContinueWith(continuationAction' state' TaskScheduler.Current' default(CancellationToken)' TaskContinuationOptions.None); " is 128.
Long Statement,System.Threading.Tasks,Task<TResult>,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\Task.await.net35.cs,ContinueWith,The length of the statement  "            return ContinueWith(continuationFunction' TaskScheduler.Current' default(CancellationToken)' TaskContinuationOptions.None); " is 123.
Long Statement,System.Threading.Tasks,Task<TResult>,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\Task.await.net35.cs,ContinueWith,The length of the statement  "            return ContinueWith(continuationFunction' state' TaskScheduler.Current' default(CancellationToken)' TaskContinuationOptions.None); " is 130.
Long Statement,System.Threading.Tasks,Task<TResult>,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\Task.await.net35.cs,ContinueWith,The length of the statement  "            return ContinueWith(continuationFunction' state' TaskScheduler.Current' cancellationToken' TaskContinuationOptions.None); " is 121.
Long Statement,System.Threading.Tasks,Task<TResult>,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\Task.await.net35.cs,ContinueWith,The length of the statement  "            return ContinueWith(continuationFunction' state' TaskScheduler.Current' default(CancellationToken)' continuationOptions); " is 121.
Long Statement,System.Threading.Tasks,TaskCompletionSource<TResult>,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\TaskCompletionSource.net35.cs,SetException,The length of the statement  "                throw new InvalidOperationException("An attempt was made to transition a task to a final state when it had already completed."); " is 128.
Long Statement,System.Threading.Tasks,TaskCompletionSource<TResult>,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\TaskCompletionSource.net35.cs,SetException,The length of the statement  "                throw new InvalidOperationException("An attempt was made to transition a task to a final state when it had already completed."); " is 128.
Long Statement,System.Threading.Tasks,TaskCompletionSource<TResult>,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\TaskCompletionSource.net35.cs,SetResult,The length of the statement  "                throw new InvalidOperationException("An attempt was made to transition a task to a final state when it had already completed."); " is 128.
Long Statement,System.Threading.Tasks,TaskCompletionSource<TResult>,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\TaskCompletionSource.net35.cs,SetCanceled,The length of the statement  "                throw new InvalidOperationException("An attempt was made to transition a task to a final state when it had already completed."); " is 128.
Long Statement,System.Threading.Tasks,TaskExceptionHolder,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\TaskExceptionHolder.net35.cs,Add,The length of the statement  "                "TaskExceptionHolder.Add(): Expected Exception' IEnumerable<Exception>' ExceptionDispatchInfo' or IEnumerable<ExceptionDispatchInfo>"); " is 135.
Long Statement,System.Threading.Tasks,TaskExceptionHolder,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\TaskExceptionHolder.net35.cs,CreateAggregateException,The length of the statement  "                "A Task's exception(s) were not observed either by Waiting on the Task or accessing its Exception property. As a result' the unobserved exception was rethrown by the finalizer thread."' " is 185.
Long Statement,System.Threading.Tasks,TaskExtensions,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\TaskExtensions.net35.cs,TransferAsynchronously,The length of the statement  "            // allocations.  Thus' this whole Unwrap operation generally results in four allocations: one for the TaskCompletionSource' " is 123.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\TaskFactory.net35.cs,StartNew,The length of the statement  "            var result = new Task(action' null' CancellationToken.None' TaskCreationOptions.None' InternalTaskOptions.None' _scheduler); " is 124.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\TaskFactory.net35.cs,StartNew,The length of the statement  "            var result = new Task(action' Task.InternalCurrentIfAttached(creationOptions)' CancellationToken.None' creationOptions' InternalTaskOptions.None' _scheduler); " is 158.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\TaskFactory.net35.cs,StartNew,The length of the statement  "            var result = new Task(action' Task.InternalCurrentIfAttached(creationOptions)' cancellationToken' creationOptions' InternalTaskOptions.None' scheduler); " is 152.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\TaskFactory.net35.cs,StartNew,The length of the statement  "            var result = new Task(action' state' null' CancellationToken.None' TaskCreationOptions.None' InternalTaskOptions.None' _scheduler); " is 131.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\TaskFactory.net35.cs,StartNew,The length of the statement  "            var result = new Task(action' state' null' cancellationToken' TaskCreationOptions.None' InternalTaskOptions.None' _scheduler); " is 126.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\TaskFactory.net35.cs,StartNew,The length of the statement  "            var result = new Task(action' state' Task.InternalCurrentIfAttached(creationOptions)' CancellationToken.None' creationOptions' InternalTaskOptions.None' _scheduler); " is 165.
Long Statement,System.Threading.Tasks,TaskFactory,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\TaskFactory.net35.cs,StartNew,The length of the statement  "            var result = new Task(action' state' Task.InternalCurrentIfAttached(creationOptions)' cancellationToken' creationOptions' InternalTaskOptions.None' scheduler); " is 159.
Long Statement,System.Threading.Tasks,TaskSchedulerAwaitTaskContinuation,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\TaskSchedulerAwaitTaskContinuation.net35.cs,Run,The length of the statement  "                var inlineIfPossible = canInlineContinuationTask && (TaskScheduler.Current == _scheduler || Thread.CurrentThread.IsThreadPoolThread); " is 133.
Long Statement,Theraot.Core,ActionHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\ActionHelper.cs,GetThrowAction,The length of the statement  "            return (T1 arg1' T2 arg2' T3 arg3' T4 arg4' T5 arg5' T6 arg6' T7 arg7' T8 arg8' T9 arg9' T10 arg10' T11 arg11' T12 arg12) => " is 124.
Long Statement,Theraot.Core,ActionHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\ActionHelper.cs,GetThrowAction,The length of the statement  "            return (T1 arg1' T2 arg2' T3 arg3' T4 arg4' T5 arg5' T6 arg6' T7 arg7' T8 arg8' T9 arg9' T10 arg10' T11 arg11' T12 arg12' T13 arg13) => " is 135.
Long Statement,Theraot.Core,ActionHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\ActionHelper.cs,GetThrowAction,The length of the statement  "            return (T1 arg1' T2 arg2' T3 arg3' T4 arg4' T5 arg5' T6 arg6' T7 arg7' T8 arg8' T9 arg9' T10 arg10' T11 arg11' T12 arg12' T13 arg13' T14 arg14) => " is 146.
Long Statement,Theraot.Core,ActionHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\ActionHelper.cs,GetThrowAction,The length of the statement  "            return (T1 arg1' T2 arg2' T3 arg3' T4 arg4' T5 arg5' T6 arg6' T7 arg7' T8 arg8' T9 arg9' T10 arg10' T11 arg11' T12 arg12' T13 arg13' T14 arg14' T15 arg15) => " is 157.
Long Statement,Theraot.Core,ActionHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\ActionHelper.cs,GetThrowAction,The length of the statement  "            return (T1 arg1' T2 arg2' T3 arg3' T4 arg4' T5 arg5' T6 arg6' T7 arg7' T8 arg8' T9 arg9' T10 arg10' T11 arg11' T12 arg12' T13 arg13' T14 arg14' T15 arg15' T16 arg16) => " is 168.
Long Statement,Theraot.Core,AggregateExceptionHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\AggregateExceptionHelper.cs,AddException,The length of the statement  "            target = ReferenceEquals(target' null) ? new AggregateException(source) : (new AggregateException(source' target)).Flatten(); " is 125.
Long Statement,Theraot.Core,AggregateExceptionHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\AggregateExceptionHelper.cs,AddException,The length of the statement  "            target = ReferenceEquals(target' null) ? new AggregateException(source) : (new AggregateException(source' target)).Flatten(); " is 125.
Long Statement,Theraot.Core,PathHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\PathHelper.cs,Combine,The length of the statement  "            if (HasInvalidPathChars(path1) || HasInvalidPathChars(path2) || HasInvalidPathChars(path3) || HasInvalidPathChars(path4)) " is 121.
Long Statement,Theraot.Core,ValueActionClosure<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;T15>,C:\repos\theraot_Theraot\Core\Theraot\Core\ValueActionClosure.cs,Invoke,The length of the statement  "            _target.Invoke(_arg1' _arg2' _arg3' _arg4' _arg5' _arg6' _arg7' _arg8' _arg9' _arg10' _arg11' _arg12' _arg13' _arg14' _arg15); " is 126.
Long Statement,Theraot.Core,ValueActionClosure<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;T15;T16>,C:\repos\theraot_Theraot\Core\Theraot\Core\ValueActionClosure.cs,Invoke,The length of the statement  "            _target.Invoke(_arg1' _arg2' _arg3' _arg4' _arg5' _arg6' _arg7' _arg8' _arg9' _arg10' _arg11' _arg12' _arg13' _arg14' _arg15' _arg16); " is 134.
Long Statement,Theraot.Core,ValueFuncClosure<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\ValueFuncClosure.cs,Invoke,The length of the statement  "            _result = _target.Invoke(_arg1' _arg2' _arg3' _arg4' _arg5' _arg6' _arg7' _arg8' _arg9' _arg10' _arg11' _arg12' _arg13); " is 120.
Long Statement,Theraot.Core,ValueFuncClosure<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\ValueFuncClosure.cs,Invoke,The length of the statement  "            _result = _target.Invoke(_arg1' _arg2' _arg3' _arg4' _arg5' _arg6' _arg7' _arg8' _arg9' _arg10' _arg11' _arg12' _arg13' _arg14); " is 128.
Long Statement,Theraot.Core,ValueFuncClosure<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\ValueFuncClosure.cs,InvokeReturn,The length of the statement  "            return _target.Invoke(_arg1' _arg2' _arg3' _arg4' _arg5' _arg6' _arg7' _arg8' _arg9' _arg10' _arg11' _arg12' _arg13' _arg14); " is 125.
Long Statement,Theraot.Core,ValueFuncClosure<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;T15;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\ValueFuncClosure.cs,Invoke,The length of the statement  "            _result = _target.Invoke(_arg1' _arg2' _arg3' _arg4' _arg5' _arg6' _arg7' _arg8' _arg9' _arg10' _arg11' _arg12' _arg13' _arg14' _arg15); " is 136.
Long Statement,Theraot.Core,ValueFuncClosure<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;T15;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\ValueFuncClosure.cs,InvokeReturn,The length of the statement  "            return _target.Invoke(_arg1' _arg2' _arg3' _arg4' _arg5' _arg6' _arg7' _arg8' _arg9' _arg10' _arg11' _arg12' _arg13' _arg14' _arg15); " is 133.
Long Statement,Theraot.Core,ValueFuncClosure<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;T15;T16;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\ValueFuncClosure.cs,Invoke,The length of the statement  "            _result = _target.Invoke(_arg1' _arg2' _arg3' _arg4' _arg5' _arg6' _arg7' _arg8' _arg9' _arg10' _arg11' _arg12' _arg13' _arg14' _arg15' _arg16); " is 144.
Long Statement,Theraot.Core,ValueFuncClosure<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;T15;T16;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\ValueFuncClosure.cs,InvokeReturn,The length of the statement  "            return _target.Invoke(_arg1' _arg2' _arg3' _arg4' _arg5' _arg6' _arg7' _arg8' _arg9' _arg10' _arg11' _arg12' _arg13' _arg14' _arg15' _arg16); " is 141.
Long Statement,Theraot.Core,CancellationTokenHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\CancellationTokenHelper.cs,ThrowIfSourceDisposed,The length of the statement  "            //CancellationToken.WaitHandle is documented to throw ObjectDispodesException if the source of the CancellationToken is disposed. " is 129.
Long Statement,Theraot.Core,FuncHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,GetReturnFunc,The length of the statement  "            return (T1 arg1' T2 arg2' T3 arg3' T4 arg4' T5 arg5' T6 arg6' T7 arg7' T8 arg8' T9 arg9' T10 arg10' T11 arg11' T12 arg12) => " is 124.
Long Statement,Theraot.Core,FuncHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,GetReturnFunc,The length of the statement  "            return (T1 arg1' T2 arg2' T3 arg3' T4 arg4' T5 arg5' T6 arg6' T7 arg7' T8 arg8' T9 arg9' T10 arg10' T11 arg11' T12 arg12' T13 arg13) => " is 135.
Long Statement,Theraot.Core,FuncHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,GetReturnFunc,The length of the statement  "            return (T1 arg1' T2 arg2' T3 arg3' T4 arg4' T5 arg5' T6 arg6' T7 arg7' T8 arg8' T9 arg9' T10 arg10' T11 arg11' T12 arg12' T13 arg13' T14 arg14) => " is 146.
Long Statement,Theraot.Core,FuncHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,GetReturnFunc,The length of the statement  "            return (T1 arg1' T2 arg2' T3 arg3' T4 arg4' T5 arg5' T6 arg6' T7 arg7' T8 arg8' T9 arg9' T10 arg10' T11 arg11' T12 arg12' T13 arg13' T14 arg14' T15 arg15) => " is 157.
Long Statement,Theraot.Core,FuncHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,GetReturnFunc,The length of the statement  "            return (T1 arg1' T2 arg2' T3 arg3' T4 arg4' T5 arg5' T6 arg6' T7 arg7' T8 arg8' T9 arg9' T10 arg10' T11 arg11' T12 arg12' T13 arg13' T14 arg14' T15 arg15' T16 arg16) => " is 168.
Long Statement,Theraot.Core,FuncHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,GetThrowFunc,The length of the statement  "            return (T1 arg1' T2 arg2' T3 arg3' T4 arg4' T5 arg5' T6 arg6' T7 arg7' T8 arg8' T9 arg9' T10 arg10' T11 arg11' T12 arg12) => " is 124.
Long Statement,Theraot.Core,FuncHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,GetThrowFunc,The length of the statement  "            return (T1 arg1' T2 arg2' T3 arg3' T4 arg4' T5 arg5' T6 arg6' T7 arg7' T8 arg8' T9 arg9' T10 arg10' T11 arg11' T12 arg12' T13 arg13) => " is 135.
Long Statement,Theraot.Core,FuncHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,GetThrowFunc,The length of the statement  "            return (T1 arg1' T2 arg2' T3 arg3' T4 arg4' T5 arg5' T6 arg6' T7 arg7' T8 arg8' T9 arg9' T10 arg10' T11 arg11' T12 arg12' T13 arg13' T14 arg14) => " is 146.
Long Statement,Theraot.Core,FuncHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,GetThrowFunc,The length of the statement  "            return (T1 arg1' T2 arg2' T3 arg3' T4 arg4' T5 arg5' T6 arg6' T7 arg7' T8 arg8' T9 arg9' T10 arg10' T11 arg11' T12 arg12' T13 arg13' T14 arg14' T15 arg15) => " is 157.
Long Statement,Theraot.Core,FuncHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\FuncHelper.cs,GetThrowFunc,The length of the statement  "            return (T1 arg1' T2 arg2' T3 arg3' T4 arg4' T5 arg5' T6 arg6' T7 arg7' T8 arg8' T9 arg9' T10 arg10' T11 arg11' T12 arg12' T13 arg13' T14 arg14' T15 arg15' T16 arg16) => " is 168.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with no type arguments."' typeof(TReturn))); " is 157.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,GetCreate,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with no type arguments."' typeof(TReturn))); " is 157.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type argument {1}"' typeof(TReturn)' typeof(T).Name)); " is 176.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,GetCreate,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type argument {1}"' typeof(TReturn)' typeof(T).Name)); " is 176.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name)); " is 200.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,GetCreate,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name)); " is 200.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name)); " is 222.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,GetCreate,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name)); " is 222.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name)); " is 244.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,GetCreate,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name)); " is 244.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}' {5}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name' typeof(T5).Name)); " is 266.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,GetCreate,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}' {5}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name' typeof(T5).Name)); " is 266.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}' {5}' {6}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name' typeof(T5).Name' typeof(T6).Name)); " is 288.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,GetCreate,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}' {5}' {6}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name' typeof(T5).Name' typeof(T6).Name)); " is 288.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The length of the statement  "                return ConstructorHelper<T1' T2' T3' T4' T5' T6' T7' TReturn>.InvokeConstructor(arg1' arg2' arg3' arg4' arg5' arg6' arg7); " is 122.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}' {5}' {6}' {7}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name' typeof(T5).Name' typeof(T6).Name' typeof(T7).Name)); " is 310.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrDefault,The length of the statement  "            return ConstructorHelper<T1' T2' T3' T4' T5' T6' T7' TReturn>.CreateOrDefault( arg1'  arg2'  arg3'  arg4'  arg5'  arg6'  arg7); " is 127.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrFail,The length of the statement  "            return ConstructorHelper<T1' T2' T3' T4' T5' T6' T7' TReturn>.CreateOrFail( arg1'  arg2'  arg3'  arg4'  arg5'  arg6'  arg7); " is 124.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,GetCreate,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}' {5}' {6}' {7}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name' typeof(T5).Name' typeof(T6).Name' typeof(T7).Name)); " is 310.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The length of the statement  "                return ConstructorHelper<T1' T2' T3' T4' T5' T6' T7' T8' TReturn>.InvokeConstructor(arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8); " is 132.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}' {5}' {6}' {7}' {8}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name' typeof(T5).Name' typeof(T6).Name' typeof(T7).Name' typeof(T8).Name)); " is 332.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrDefault,The length of the statement  "            return ConstructorHelper<T1' T2' T3' T4' T5' T6' T7' T8' TReturn>.CreateOrDefault( arg1'  arg2'  arg3'  arg4'  arg5'  arg6'  arg7'  arg8); " is 138.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrFail,The length of the statement  "            return ConstructorHelper<T1' T2' T3' T4' T5' T6' T7' T8' TReturn>.CreateOrFail( arg1'  arg2'  arg3'  arg4'  arg5'  arg6'  arg7'  arg8); " is 135.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,GetCreate,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}' {5}' {6}' {7}' {8}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name' typeof(T5).Name' typeof(T6).Name' typeof(T7).Name' typeof(T8).Name)); " is 332.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The length of the statement  "                return ConstructorHelper<T1' T2' T3' T4' T5' T6' T7' T8' T9' TReturn>.InvokeConstructor(arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9); " is 142.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}' {5}' {6}' {7}' {8}' {9}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name' typeof(T5).Name' typeof(T6).Name' typeof(T7).Name' typeof(T8).Name' typeof(T9).Name)); " is 354.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrDefault,The length of the statement  "            return ConstructorHelper<T1' T2' T3' T4' T5' T6' T7' T8' T9' TReturn>.CreateOrDefault( arg1'  arg2'  arg3'  arg4'  arg5'  arg6'  arg7'  arg8'  arg9); " is 149.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrFail,The length of the statement  "            return ConstructorHelper<T1' T2' T3' T4' T5' T6' T7' T8' T9' TReturn>.CreateOrFail( arg1'  arg2'  arg3'  arg4'  arg5'  arg6'  arg7'  arg8'  arg9); " is 146.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,GetCreate,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}' {5}' {6}' {7}' {8}' {9}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name' typeof(T5).Name' typeof(T6).Name' typeof(T7).Name' typeof(T8).Name' typeof(T9).Name)); " is 354.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The length of the statement  "                return ConstructorHelper<T1' T2' T3' T4' T5' T6' T7' T8' T9' T10' TReturn>.InvokeConstructor(arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10); " is 154.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}' {5}' {6}' {7}' {8}' {9}' {10}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name' typeof(T5).Name' typeof(T6).Name' typeof(T7).Name' typeof(T8).Name' typeof(T9).Name' typeof(T10).Name)); " is 378.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrDefault,The length of the statement  "            return ConstructorHelper<T1' T2' T3' T4' T5' T6' T7' T8' T9' T10' TReturn>.CreateOrDefault( arg1'  arg2'  arg3'  arg4'  arg5'  arg6'  arg7'  arg8'  arg9'  arg10); " is 162.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrFail,The length of the statement  "            return ConstructorHelper<T1' T2' T3' T4' T5' T6' T7' T8' T9' T10' TReturn>.CreateOrFail( arg1'  arg2'  arg3'  arg4'  arg5'  arg6'  arg7'  arg8'  arg9'  arg10); " is 159.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,GetCreate,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}' {5}' {6}' {7}' {8}' {9}' {10}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name' typeof(T5).Name' typeof(T6).Name' typeof(T7).Name' typeof(T8).Name' typeof(T9).Name' typeof(T10).Name)); " is 378.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The length of the statement  "                return ConstructorHelper<T1' T2' T3' T4' T5' T6' T7' T8' T9' T10' T11' TReturn>.InvokeConstructor(arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11); " is 166.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}' {5}' {6}' {7}' {8}' {9}' {10}' {11}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name' typeof(T5).Name' typeof(T6).Name' typeof(T7).Name' typeof(T8).Name' typeof(T9).Name' typeof(T10).Name' typeof(T11).Name)); " is 402.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrDefault,The length of the statement  "            return ConstructorHelper<T1' T2' T3' T4' T5' T6' T7' T8' T9' T10' T11' TReturn>.CreateOrDefault( arg1'  arg2'  arg3'  arg4'  arg5'  arg6'  arg7'  arg8'  arg9'  arg10'  arg11); " is 175.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrFail,The length of the statement  "            return ConstructorHelper<T1' T2' T3' T4' T5' T6' T7' T8' T9' T10' T11' TReturn>.CreateOrFail( arg1'  arg2'  arg3'  arg4'  arg5'  arg6'  arg7'  arg8'  arg9'  arg10'  arg11); " is 172.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,GetCreate,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}' {5}' {6}' {7}' {8}' {9}' {10}' {11}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name' typeof(T5).Name' typeof(T6).Name' typeof(T7).Name' typeof(T8).Name' typeof(T9).Name' typeof(T10).Name' typeof(T11).Name)); " is 402.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The length of the statement  "                return ConstructorHelper<T1' T2' T3' T4' T5' T6' T7' T8' T9' T10' T11' T12' TReturn>.InvokeConstructor(arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12); " is 178.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}' {5}' {6}' {7}' {8}' {9}' {10}' {11}' {12}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name' typeof(T5).Name' typeof(T6).Name' typeof(T7).Name' typeof(T8).Name' typeof(T9).Name' typeof(T10).Name' typeof(T11).Name' typeof(T12).Name)); " is 426.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrDefault,The length of the statement  "            return ConstructorHelper<T1' T2' T3' T4' T5' T6' T7' T8' T9' T10' T11' T12' TReturn>.CreateOrDefault( arg1'  arg2'  arg3'  arg4'  arg5'  arg6'  arg7'  arg8'  arg9'  arg10'  arg11'  arg12); " is 188.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrFail,The length of the statement  "            return ConstructorHelper<T1' T2' T3' T4' T5' T6' T7' T8' T9' T10' T11' T12' TReturn>.CreateOrFail( arg1'  arg2'  arg3'  arg4'  arg5'  arg6'  arg7'  arg8'  arg9'  arg10'  arg11'  arg12); " is 185.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,GetCreate,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}' {5}' {6}' {7}' {8}' {9}' {10}' {11}' {12}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name' typeof(T5).Name' typeof(T6).Name' typeof(T7).Name' typeof(T8).Name' typeof(T9).Name' typeof(T10).Name' typeof(T11).Name' typeof(T12).Name)); " is 426.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The length of the statement  "                return ConstructorHelper<T1' T2' T3' T4' T5' T6' T7' T8' T9' T10' T11' T12' T13' TReturn>.InvokeConstructor(arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13); " is 190.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}' {5}' {6}' {7}' {8}' {9}' {10}' {11}' {12}' {13}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name' typeof(T5).Name' typeof(T6).Name' typeof(T7).Name' typeof(T8).Name' typeof(T9).Name' typeof(T10).Name' typeof(T11).Name' typeof(T12).Name' typeof(T13).Name)); " is 450.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrDefault,The length of the statement  "            return ConstructorHelper<T1' T2' T3' T4' T5' T6' T7' T8' T9' T10' T11' T12' T13' TReturn>.CreateOrDefault( arg1'  arg2'  arg3'  arg4'  arg5'  arg6'  arg7'  arg8'  arg9'  arg10'  arg11'  arg12'  arg13); " is 201.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrFail,The length of the statement  "            return ConstructorHelper<T1' T2' T3' T4' T5' T6' T7' T8' T9' T10' T11' T12' T13' TReturn>.CreateOrFail( arg1'  arg2'  arg3'  arg4'  arg5'  arg6'  arg7'  arg8'  arg9'  arg10'  arg11'  arg12'  arg13); " is 198.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,GetCreate,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}' {5}' {6}' {7}' {8}' {9}' {10}' {11}' {12}' {13}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name' typeof(T5).Name' typeof(T6).Name' typeof(T7).Name' typeof(T8).Name' typeof(T9).Name' typeof(T10).Name' typeof(T11).Name' typeof(T12).Name' typeof(T13).Name)); " is 450.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The length of the statement  "                return ConstructorHelper<T1' T2' T3' T4' T5' T6' T7' T8' T9' T10' T11' T12' T13' T14' TReturn>.InvokeConstructor(arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14); " is 202.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}' {5}' {6}' {7}' {8}' {9}' {10}' {11}' {12}' {13}' {14}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name' typeof(T5).Name' typeof(T6).Name' typeof(T7).Name' typeof(T8).Name' typeof(T9).Name' typeof(T10).Name' typeof(T11).Name' typeof(T12).Name' typeof(T13).Name' typeof(T14).Name)); " is 474.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrDefault,The length of the statement  "            return ConstructorHelper<T1' T2' T3' T4' T5' T6' T7' T8' T9' T10' T11' T12' T13' T14' TReturn>.CreateOrDefault( arg1'  arg2'  arg3'  arg4'  arg5'  arg6'  arg7'  arg8'  arg9'  arg10'  arg11'  arg12'  arg13'  arg14); " is 214.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrFail,The length of the statement  "            return ConstructorHelper<T1' T2' T3' T4' T5' T6' T7' T8' T9' T10' T11' T12' T13' T14' TReturn>.CreateOrFail( arg1'  arg2'  arg3'  arg4'  arg5'  arg6'  arg7'  arg8'  arg9'  arg10'  arg11'  arg12'  arg13'  arg14); " is 211.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,GetCreate,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}' {5}' {6}' {7}' {8}' {9}' {10}' {11}' {12}' {13}' {14}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name' typeof(T5).Name' typeof(T6).Name' typeof(T7).Name' typeof(T8).Name' typeof(T9).Name' typeof(T10).Name' typeof(T11).Name' typeof(T12).Name' typeof(T13).Name' typeof(T14).Name)); " is 474.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The length of the statement  "                return ConstructorHelper<T1' T2' T3' T4' T5' T6' T7' T8' T9' T10' T11' T12' T13' T14' T15' TReturn>.InvokeConstructor(arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14' arg15); " is 214.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}' {5}' {6}' {7}' {8}' {9}' {10}' {11}' {12}' {13}' {14}' {15}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name' typeof(T5).Name' typeof(T6).Name' typeof(T7).Name' typeof(T8).Name' typeof(T9).Name' typeof(T10).Name' typeof(T11).Name' typeof(T12).Name' typeof(T13).Name' typeof(T14).Name' typeof(T15).Name)); " is 498.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrDefault,The length of the statement  "            return ConstructorHelper<T1' T2' T3' T4' T5' T6' T7' T8' T9' T10' T11' T12' T13' T14' T15' TReturn>.CreateOrDefault( arg1'  arg2'  arg3'  arg4'  arg5'  arg6'  arg7'  arg8'  arg9'  arg10'  arg11'  arg12'  arg13'  arg14'  arg15); " is 227.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrFail,The length of the statement  "            return ConstructorHelper<T1' T2' T3' T4' T5' T6' T7' T8' T9' T10' T11' T12' T13' T14' T15' TReturn>.CreateOrFail( arg1'  arg2'  arg3'  arg4'  arg5'  arg6'  arg7'  arg8'  arg9'  arg10'  arg11'  arg12'  arg13'  arg14'  arg15); " is 224.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,GetCreate,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}' {5}' {6}' {7}' {8}' {9}' {10}' {11}' {12}' {13}' {14}' {15}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name' typeof(T5).Name' typeof(T6).Name' typeof(T7).Name' typeof(T8).Name' typeof(T9).Name' typeof(T10).Name' typeof(T11).Name' typeof(T12).Name' typeof(T13).Name' typeof(T14).Name' typeof(T15).Name)); " is 498.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The length of the statement  "                return ConstructorHelper<T1' T2' T3' T4' T5' T6' T7' T8' T9' T10' T11' T12' T13' T14' T15' T16' TReturn>.InvokeConstructor(arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14' arg15' arg16); " is 226.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,Create,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}' {5}' {6}' {7}' {8}' {9}' {10}' {11}' {12}' {13}' {14}' {15}' {16}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name' typeof(T5).Name' typeof(T6).Name' typeof(T7).Name' typeof(T8).Name' typeof(T9).Name' typeof(T10).Name' typeof(T11).Name' typeof(T12).Name' typeof(T13).Name' typeof(T14).Name' typeof(T15).Name' typeof(T16).Name)); " is 522.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrDefault,The length of the statement  "            return ConstructorHelper<T1' T2' T3' T4' T5' T6' T7' T8' T9' T10' T11' T12' T13' T14' T15' T16' TReturn>.CreateOrDefault( arg1'  arg2'  arg3'  arg4'  arg5'  arg6'  arg7'  arg8'  arg9'  arg10'  arg11'  arg12'  arg13'  arg14'  arg15'  arg16); " is 240.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,CreateOrFail,The length of the statement  "            return ConstructorHelper<T1' T2' T3' T4' T5' T6' T7' T8' T9' T10' T11' T12' T13' T14' T15' T16' TReturn>.CreateOrFail( arg1'  arg2'  arg3'  arg4'  arg5'  arg6'  arg7'  arg8'  arg9'  arg10'  arg11'  arg12'  arg13'  arg14'  arg15'  arg16); " is 237.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,GetCreate,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}' {5}' {6}' {7}' {8}' {9}' {10}' {11}' {12}' {13}' {14}' {15}' {16}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name' typeof(T5).Name' typeof(T6).Name' typeof(T7).Name' typeof(T8).Name' typeof(T9).Name' typeof(T10).Name' typeof(T11).Name' typeof(T12).Name' typeof(T13).Name' typeof(T14).Name' typeof(T15).Name' typeof(T16).Name)); " is 522.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,GetCreateOrDefault,The length of the statement  "            return ConstructorHelper<T1' T2' T3' T4' T5' T6' T7' T8' T9' T10' T11' T12' T13' T14' T15' T16' TReturn>.CreateOrDefault; " is 121.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,HasConstructor,The length of the statement  "            return ConstructorHelper<T1' T2' T3' T4' T5' T6' T7' T8' T9' T10' T11' T12' T13' T14' T15' T16' TReturn>.HasConstructor; " is 120.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,IsBinaryPortableExtracted,The length of the statement  "                var property = typeof(BinaryPortableInfo<>).MakeGenericType(type).GetProperty("Result"' BindingFlags.Public | BindingFlags.Static); " is 131.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,IsBlittableExtracted,The length of the statement  "                var property = typeof(BlittableInfo<>).MakeGenericType(type).GetProperty("Result"' BindingFlags.Public | BindingFlags.Static); " is 126.
Long Statement,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,IsValueTypeRecursiveExtracted,The length of the statement  "                var property = typeof(ValueTypeRecursiveInfo<>).MakeGenericType(type).GetProperty("Result"' BindingFlags.Public | BindingFlags.Static); " is 135.
Long Statement,Theraot.Core,ConstructorHelper<TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.ConstructorHelper.cs,InvokeConstructor,The length of the statement  "                    throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with no type arguments."' typeof(TReturn))); " is 157.
Long Statement,Theraot.Core,ConstructorHelper<T;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.ConstructorHelper.cs,InvokeConstructor,The length of the statement  "                    throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type argument {1}"' typeof(TReturn)' typeof(T).Name)); " is 176.
Long Statement,Theraot.Core,ConstructorHelper<T1;T2;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.ConstructorHelper.cs,InvokeConstructor,The length of the statement  "                    throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name)); " is 200.
Long Statement,Theraot.Core,ConstructorHelper<T1;T2;T3;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.ConstructorHelper.cs,InvokeConstructor,The length of the statement  "                    throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name)); " is 222.
Long Statement,Theraot.Core,ConstructorHelper<T1;T2;T3;T4;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.ConstructorHelper.cs,InvokeConstructor,The length of the statement  "                    throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name)); " is 244.
Long Statement,Theraot.Core,ConstructorHelper<T1;T2;T3;T4;T5;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.ConstructorHelper.cs,InvokeConstructor,The length of the statement  "                    throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}' {5}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name' typeof(T5).Name)); " is 266.
Long Statement,Theraot.Core,ConstructorHelper<T1;T2;T3;T4;T5;T6;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.ConstructorHelper.cs,InvokeConstructor,The length of the statement  "                    throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}' {5}' {6}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name' typeof(T5).Name' typeof(T6).Name)); " is 288.
Long Statement,Theraot.Core,ConstructorHelper<T1;T2;T3;T4;T5;T6;T7;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.ConstructorHelper.cs,InvokeConstructor,The length of the statement  "                    throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}' {5}' {6}' {7}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name' typeof(T5).Name' typeof(T6).Name' typeof(T7).Name)); " is 310.
Long Statement,Theraot.Core,ConstructorHelper<T1;T2;T3;T4;T5;T6;T7;T8;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.ConstructorHelper.cs,InvokeConstructor,The length of the statement  "                    throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}' {5}' {6}' {7}' {8}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name' typeof(T5).Name' typeof(T6).Name' typeof(T7).Name' typeof(T8).Name)); " is 332.
Long Statement,Theraot.Core,ConstructorHelper<T1;T2;T3;T4;T5;T6;T7;T8;T9;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.ConstructorHelper.cs,InvokeConstructor,The length of the statement  "                    throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}' {5}' {6}' {7}' {8}' {9}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name' typeof(T5).Name' typeof(T6).Name' typeof(T7).Name' typeof(T8).Name' typeof(T9).Name)); " is 354.
Long Statement,Theraot.Core,ConstructorHelper<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.ConstructorHelper.cs,InvokeConstructor,The length of the statement  "                    throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}' {5}' {6}' {7}' {8}' {9}' {10}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name' typeof(T5).Name' typeof(T6).Name' typeof(T7).Name' typeof(T8).Name' typeof(T9).Name' typeof(T10).Name)); " is 378.
Long Statement,Theraot.Core,ConstructorHelper<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.ConstructorHelper.cs,InvokeConstructor,The length of the statement  "                    throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}' {5}' {6}' {7}' {8}' {9}' {10}' {11}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name' typeof(T5).Name' typeof(T6).Name' typeof(T7).Name' typeof(T8).Name' typeof(T9).Name' typeof(T10).Name' typeof(T11).Name)); " is 402.
Long Statement,Theraot.Core,ConstructorHelper<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.ConstructorHelper.cs,InvokeConstructor,The length of the statement  "                    return (TReturn)_constructorInfo.Invoke(new object[]{arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11}); " is 122.
Long Statement,Theraot.Core,ConstructorHelper<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.ConstructorHelper.cs,InvokeConstructor,The length of the statement  "                    throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}' {5}' {6}' {7}' {8}' {9}' {10}' {11}' {12}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name' typeof(T5).Name' typeof(T6).Name' typeof(T7).Name' typeof(T8).Name' typeof(T9).Name' typeof(T10).Name' typeof(T11).Name' typeof(T12).Name)); " is 426.
Long Statement,Theraot.Core,ConstructorHelper<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.ConstructorHelper.cs,InvokeConstructor,The length of the statement  "                    return (TReturn)_constructorInfo.Invoke(new object[]{arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12}); " is 129.
Long Statement,Theraot.Core,ConstructorHelper<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.ConstructorHelper.cs,InvokeConstructor,The length of the statement  "                    throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}' {5}' {6}' {7}' {8}' {9}' {10}' {11}' {12}' {13}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name' typeof(T5).Name' typeof(T6).Name' typeof(T7).Name' typeof(T8).Name' typeof(T9).Name' typeof(T10).Name' typeof(T11).Name' typeof(T12).Name' typeof(T13).Name)); " is 450.
Long Statement,Theraot.Core,ConstructorHelper<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.ConstructorHelper.cs,InvokeConstructor,The length of the statement  "                    return (TReturn)_constructorInfo.Invoke(new object[]{arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13}); " is 136.
Long Statement,Theraot.Core,ConstructorHelper<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.ConstructorHelper.cs,InvokeConstructor,The length of the statement  "                    throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}' {5}' {6}' {7}' {8}' {9}' {10}' {11}' {12}' {13}' {14}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name' typeof(T5).Name' typeof(T6).Name' typeof(T7).Name' typeof(T8).Name' typeof(T9).Name' typeof(T10).Name' typeof(T11).Name' typeof(T12).Name' typeof(T13).Name' typeof(T14).Name)); " is 474.
Long Statement,Theraot.Core,ConstructorHelper<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.ConstructorHelper.cs,InvokeConstructor,The length of the statement  "                    return (TReturn)_constructorInfo.Invoke(new object[]{arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14}); " is 143.
Long Statement,Theraot.Core,ConstructorHelper<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;T15;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.ConstructorHelper.cs,InvokeConstructor,The length of the statement  "                    throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}' {5}' {6}' {7}' {8}' {9}' {10}' {11}' {12}' {13}' {14}' {15}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name' typeof(T5).Name' typeof(T6).Name' typeof(T7).Name' typeof(T8).Name' typeof(T9).Name' typeof(T10).Name' typeof(T11).Name' typeof(T12).Name' typeof(T13).Name' typeof(T14).Name' typeof(T15).Name)); " is 498.
Long Statement,Theraot.Core,ConstructorHelper<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;T15;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.ConstructorHelper.cs,InvokeConstructor,The length of the statement  "                    return (TReturn)_constructorInfo.Invoke(new object[]{arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14' arg15}); " is 150.
Long Statement,Theraot.Core,ConstructorHelper<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;T15;T16;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.ConstructorHelper.cs,InvokeConstructor,The length of the statement  "                    throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "There is no constructor for {0} with the type arguments {1}' {2}' {3}' {4}' {5}' {6}' {7}' {8}' {9}' {10}' {11}' {12}' {13}' {14}' {15}' {16}"' typeof(TReturn)' typeof(T1).Name' typeof(T2).Name' typeof(T3).Name' typeof(T4).Name' typeof(T5).Name' typeof(T6).Name' typeof(T7).Name' typeof(T8).Name' typeof(T9).Name' typeof(T10).Name' typeof(T11).Name' typeof(T12).Name' typeof(T13).Name' typeof(T14).Name' typeof(T15).Name' typeof(T16).Name)); " is 522.
Long Statement,Theraot.Core,ConstructorHelper<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;T15;T16;TReturn>,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.ConstructorHelper.cs,InvokeConstructor,The length of the statement  "                    return (TReturn)_constructorInfo.Invoke(new object[]{arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14' arg15' arg16}); " is 157.
Long Statement,Theraot.Collections,Extensions,C:\repos\theraot_Theraot\Core\Theraot\Collections\Extensions.partition.cs,SkipItems,The length of the statement  "            return predicateCount == null ? SkipItemsExtracted(source' skipCount) : SkipItemsExtracted(source' predicateCount' skipCount); " is 126.
Long Statement,Theraot.Collections,Extensions,C:\repos\theraot_Theraot\Core\Theraot\Collections\Extensions.partition.cs,TakeItems,The length of the statement  "            return predicateCount == null ? TakeItemsExtracted(source' takeCount) : TakeItemsExtracted(source' predicateCount' takeCount); " is 126.
Long Statement,Theraot.Collections.ThreadSafe,SafeDictionary<TKey;TValue>,C:\repos\theraot_Theraot\Core\Theraot\Collections\ThreadSafe\SafeDictionary.cs,GetOrAdd,The length of the statement  "                if (_bucket.TryGetOrInsert(hashCode + attempts' () => new KeyValuePair<TKey' TValue>(key' valueFactory(key))' out storedPair)) " is 126.
Long Statement,Theraot.Collections.ThreadSafe,SafeDictionary<TKey;TValue>,C:\repos\theraot_Theraot\Core\Theraot\Collections\ThreadSafe\SafeDictionary.cs,TryGetOrAdd,The length of the statement  "                if (_bucket.TryGetOrInsert(hashCode + attempts' () => new KeyValuePair<TKey' TValue>(key' valueFactory(key))' out storedPair)) " is 126.
Long Statement,Theraot.Collections.ThreadSafe,SafeDictionary<TKey;TValue>,C:\repos\theraot_Theraot\Core\Theraot\Collections\ThreadSafe\SafeDictionary.cs,Set,The length of the statement  "                Predicate<KeyValuePair<TKey' TValue>> check = found => _keyComparer.Equals(found.Key' key) || keyOverwriteCheck(found.Key); " is 123.
Long Statement,Theraot.Collections.ThreadSafe,SafeDictionary<TKey;TValue>,C:\repos\theraot_Theraot\Core\Theraot\Collections\ThreadSafe\SafeDictionary.cs,Set,The length of the statement  "                Predicate<KeyValuePair<TKey' TValue>> check = found => _keyComparer.Equals(found.Key' key) || keyOverwriteCheck(found.Key); " is 123.
Long Statement,Theraot.Collections.ThreadSafe,WeakDictionary<TKey;TValue>,C:\repos\theraot_Theraot\Core\Theraot\Collections\ThreadSafe\WeakDictionary.cs,GetOrAdd,The length of the statement  "            Func<WeakNeedle<TKey>' TValue' TValue> factory = (pairKey' foundValue) => result = valueFactory(PrivateTryGetValue(pairKey' out foundKey) ? foundKey : key); " is 156.
Long Statement,Theraot.Collections.ThreadSafe,WeakDictionary<TKey;TValue>,C:\repos\theraot_Theraot\Core\Theraot\Collections\ThreadSafe\WeakDictionary.cs,TryGetOrAdd,The length of the statement  "            Func<WeakNeedle<TKey>' TValue' TValue> factory = (pairKey' foundValue) => valueFactory(PrivateTryGetValue(pairKey' out foundKey) ? foundKey : key); " is 147.
Long Statement,Theraot.Threading,NoTrackingThreadLocal<T>,C:\repos\theraot_Theraot\Core\Theraot\Threading\NoTrackingThreadLocal.cs,ToString,The length of the statement  "            return string.Format(System.Globalization.CultureInfo.InvariantCulture' "[ThreadLocal: IsValueCreated={0}' Value={1}]"' IsValueCreated' Value); " is 143.
Long Statement,Theraot.Threading,TrackingThreadLocal<T>,C:\repos\theraot_Theraot\Core\Theraot\Threading\TrackingThreadLocal.cs,ToString,The length of the statement  "            return string.Format(System.Globalization.CultureInfo.InvariantCulture' "[ThreadLocal: IsValueCreated={0}' Value={1}]"' IsValueCreated' Value); " is 143.
Long Statement,System.Diagnostics.Contracts.Internal,ContractHelper,C:\repos\theraot_Theraot\Core\System\Diagnostics\Contracts\Internal\ContractHelper.net35.cs,RaiseContractFailedEvent,The length of the statement  "            return Runtime.CompilerServices.ContractHelper.RaiseContractFailedEvent(failureKind' userMessage' conditionText' innerException); " is 129.
Long Statement,System.Diagnostics.Contracts.Internal,ContractHelper,C:\repos\theraot_Theraot\Core\System\Diagnostics\Contracts\Internal\ContractHelper.net35.cs,TriggerFailure,The length of the statement  "            Runtime.CompilerServices.ContractHelper.TriggerFailure(kind' displayMessage' userMessage' conditionText' innerException); " is 121.
Complex Conditional,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,DebugInfo,The conditional expression  "startLine == 0xfeefee && startColumn == 0 && endLine == 0xfeefee && endColumn == 0"  is complex.
Complex Conditional,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,GetMethodBasedUnaryOperator,The conditional expression  "operand.Type.IsNullableType() &&                  ParameterIsAssignable(pms[0]' operand.Type.GetNonNullableType()) &&                  method.ReturnType.IsValueType && !method.ReturnType.IsNullableType()"  is complex.
Complex Conditional,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,GetMethodBasedCoercionOperator,The conditional expression  "(operand.Type.IsNullableType() || convertToType.IsNullableType()) &&                  ParameterIsAssignable(pms[0]' operand.Type.GetNonNullableType()) &&                  method.ReturnType == convertToType.GetNonNullableType()"  is complex.
Complex Conditional,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,GetMethodBasedBinaryOperator,The conditional expression  "left.Type.IsNullableType() && right.Type.IsNullableType() &&                  ParameterIsAssignable(pms[0]' left.Type.GetNonNullableType()) &&                  ParameterIsAssignable(pms[1]' right.Type.GetNonNullableType()) &&                  method.ReturnType.IsValueType && !method.ReturnType.IsNullableType()"  is complex.
Complex Conditional,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,ValidateUserDefinedConditionalLogicOperator,The conditional expression  "opTrue == null || opTrue.ReturnType != typeof(bool) ||                  opFalse == null || opFalse.ReturnType != typeof(bool)"  is complex.
Complex Conditional,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,GetEqualityComparisonOperator,The conditional expression  "left.Type == right.Type && (left.Type.IsNumeric() ||                  left.Type == typeof(object) ||                  left.Type.IsBool() ||                  left.Type.GetNonNullableType().IsEnum)"  is complex.
Complex Conditional,System.Linq.Expressions,ConstantExpression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\ConstantExpression.net30.cs,Make,The conditional expression  "(value == null && type == typeof(object)) || (value != null && value.GetType() == type)"  is complex.
Complex Conditional,System.Linq.Expressions,DebugViewWriter,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\DebugViewWriter.net30.cs,VisitConstant,The conditional expression  "(value is int) && node.Type == typeof(int)                || (value is bool) && node.Type == typeof(bool)"  is complex.
Complex Conditional,System.Linq.Expressions,DebugViewWriter,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\DebugViewWriter.net30.cs,NeedsParentheses,The conditional expression  "child != null && child.NodeType == ExpressionType.Constant &&                  (parent.NodeType == ExpressionType.Negate || parent.NodeType == ExpressionType.NegateChecked)"  is complex.
Complex Conditional,System.Linq.Expressions,TryExpression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\TryExpression.net30.cs,Update,The conditional expression  "body == Body && handlers == Handlers && @finally == Finally && fault == Fault"  is complex.
Complex Conditional,System.Linq.Expressions.Compiler,ILGen,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitConvertToType,The conditional expression  "typeFrom.IsInterface || // interface cast                 typeTo.IsInterface ||                 typeFrom == typeof(object) || // boxing cast                 typeTo == typeof(object) ||                 typeFrom == typeof(Enum) ||                 typeFrom == typeof(ValueType) ||                 TypeHelper.IsLegalExplicitVariantDelegateConversion(typeFrom' typeTo)"  is complex.
Complex Conditional,System.Linq.Expressions.Compiler,ILGen,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitConvertToType,The conditional expression  "!(TypeHelper.IsConvertible(typeFrom) && TypeHelper.IsConvertible(typeTo)) // primitive runtime conversion                       &&                       (nnExprType.IsAssignableFrom(nnType) || // down cast                       nnType.IsAssignableFrom(nnExprType))"  is complex.
Complex Conditional,System.Linq.Expressions.Compiler,LambdaCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.net30.cs,EmitBinaryExpression,The conditional expression  "(b.NodeType == ExpressionType.Equal || b.NodeType == ExpressionType.NotEqual) &&                  (b.Type == typeof(bool) || b.Type == typeof(bool?))"  is complex.
Complex Conditional,System.Linq.Expressions.Compiler,LambdaCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.net30.cs,Emit,The conditional expression  "g != null && (g.Value == null || !Significant(g.Value)) && ReferenceLabel(g.Target).CanReturn"  is complex.
Complex Conditional,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Create,The conditional expression  "info.DeclaringType != null && info.DeclaringType.IsArray && (info.Name == "Get" || info.Name == "Set")"  is complex.
Complex Conditional,System.Linq.Expressions.Interpreter,LightCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\LightCompiler.net30.cs,CompileConvertToType,The conditional expression  "(nonNullableFrom.IsNumeric() || nonNullableFrom.IsEnum)                   && (nonNullableTo.IsNumeric() || nonNullableTo.IsEnum)"  is complex.
Complex Conditional,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,FormatBigInteger,The conditional expression  "fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R'"  is complex.
Complex Conditional,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,ParseFormatSpecifier,The conditional expression  "chr >= 'A' && chr <= 'Z' || chr >= 'a' && chr <= 'z'"  is complex.
Complex Conditional,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,Gcd,The conditional expression  "(reg1._iuLast <= 0 || reg1._bits[0] != 0) && (reg2._iuLast <= 0 || reg2._bits[0] != 0)"  is complex.
Complex Conditional,System,Tuple<T1;T2;T3;T4;T5;T6;T7;TRest>,C:\repos\theraot_Theraot\Core\System\Tuple8.net35.cs,CheckType,The conditional expression  "type == typeof(Tuple<>) ||                          type == typeof(Tuple<'>) ||                          type == typeof(Tuple<''>) ||                          type == typeof(Tuple<'''>) ||                          type == typeof(Tuple<''''>) ||                          type == typeof(Tuple<'''''>) ||                          type == typeof(Tuple<''''''>) ||                          type == typeof(Tuple<'''''''>)"  is complex.
Complex Conditional,System.Threading,ReaderWriterLockSlim,C:\repos\theraot_Theraot\Core\System\Threading\ReaderWriterLockSlim.net35.cs,CheckState,The conditional expression  "ctstate != LockState.None && _noRecursion && (!ctstate.Has(LockState.Upgradable) || validState == LockState.Upgradable)"  is complex.
Complex Conditional,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,UpdateExceptionObservedStatus,The conditional expression  "(_parent != null) && ((_creationOptions & TaskCreationOptions.AttachedToParent) != 0) && ((_parent._creationOptions & TaskCreationOptions.DenyChildAttach) == 0) && InternalCurrent == _parent"  is complex.
Complex Conditional,Theraot.Core,PathHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\PathHelper.cs,Combine,The conditional expression  "HasInvalidPathChars(path1) || HasInvalidPathChars(path2) || HasInvalidPathChars(path3) || HasInvalidPathChars(path4)"  is complex.
Complex Conditional,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,IsArithmetic,The conditional expression  "type == typeof(short)                      || type == typeof(int)                      || type == typeof(long)                      || type == typeof(double)                      || type == typeof(float)                      || type == typeof(ushort)                      || type == typeof(uint)                      || type == typeof(ulong)"  is complex.
Complex Conditional,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,IsConvertible,The conditional expression  "type == typeof(bool)                      || type == typeof(byte)                      || type == typeof(sbyte)                      || type == typeof(short)                      || type == typeof(int)                      || type == typeof(long)                      || type == typeof(ushort)                      || type == typeof(uint)                      || type == typeof(ulong)                      || type == typeof(float)                      || type == typeof(double)                      || type == typeof(char)"  is complex.
Complex Conditional,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,IsImplicitNumericConversion,The conditional expression  "target == typeof(short)                      || target == typeof(int)                      || target == typeof(long)                      || target == typeof(float)                      || target == typeof(double)                      || target == typeof(decimal)"  is complex.
Complex Conditional,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,IsImplicitNumericConversion,The conditional expression  "target == typeof(short)                      || target == typeof(ushort)                      || target == typeof(int)                      || target == typeof(uint)                      || target == typeof(long)                      || target == typeof(ulong)                      || target == typeof(float)                      || target == typeof(double)                      || target == typeof(decimal)"  is complex.
Complex Conditional,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,IsImplicitNumericConversion,The conditional expression  "target == typeof(int)                      || target == typeof(long)                      || target == typeof(float)                      || target == typeof(double)                      || target == typeof(decimal)"  is complex.
Complex Conditional,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,IsImplicitNumericConversion,The conditional expression  "target == typeof(int)                      || target == typeof(uint)                      || target == typeof(long)                      || target == typeof(ulong)                      || target == typeof(float)                      || target == typeof(double)                      || target == typeof(decimal)"  is complex.
Complex Conditional,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,IsImplicitNumericConversion,The conditional expression  "target == typeof(long)                      || target == typeof(float)                      || target == typeof(double)                      || target == typeof(decimal)"  is complex.
Complex Conditional,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,IsImplicitNumericConversion,The conditional expression  "target == typeof(ulong)                      || target == typeof(float)                      || target == typeof(double)                      || target == typeof(decimal)"  is complex.
Complex Conditional,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,IsImplicitNumericConversion,The conditional expression  "target == typeof(ushort)                      || target == typeof(int)                      || target == typeof(uint)                      || target == typeof(long)                      || target == typeof(ulong)                      || target == typeof(float)                      || target == typeof(double)                      || target == typeof(decimal)"  is complex.
Complex Conditional,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,IsIntegerOrBool,The conditional expression  "type == typeof(bool)                      || type == typeof(sbyte)                      || type == typeof(byte)                      || type == typeof(short)                      || type == typeof(int)                      || type == typeof(long)                      || type == typeof(ushort)                      || type == typeof(uint)                      || type == typeof(ulong)"  is complex.
Complex Conditional,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,IsLegalExplicitVariantDelegateConversion,The conditional expression  "!PrivateIsDelegate(source) || !PrivateIsDelegate(target) || !sourceInfo.IsGenericType || !targetInfo.IsGenericType"  is complex.
Complex Conditional,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,IsNumeric,The conditional expression  "type == typeof(char)                      || type == typeof(sbyte)                      || type == typeof(byte)                      || type == typeof(short)                      || type == typeof(int)                      || type == typeof(long)                      || type == typeof(double)                      || type == typeof(float)                      || type == typeof(ushort)                      || type == typeof(uint)                      || type == typeof(ulong)"  is complex.
Complex Conditional,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,IsUnsigned,The conditional expression  "type == typeof(byte)                      || type == typeof(char)                      || type == typeof(ushort)                      || type == typeof(uint)                      || type == typeof(ulong)"  is complex.
Complex Conditional,Theraot.Core,TypeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\TypeHelper.util.cs,IsPrimitiveInteger,The conditional expression  "type == typeof(sbyte)                      || type == typeof(byte)                      || type == typeof(short)                      || type == typeof(int)                      || type == typeof(long)                      || type == typeof(ushort)                      || type == typeof(uint)                      || type == typeof(ulong)"  is complex.
Complex Conditional,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeSetBounded,The conditional expression  "(lastValue < minValue || lastValue > maxValue) || (lastValue + value < minValue || lastValue > maxValue - value)"  is complex.
Complex Conditional,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeSetBounded,The conditional expression  "(lastValue < minValue || lastValue > maxValue) || (lastValue + value < minValue || lastValue > maxValue - value)"  is complex.
Complex Conditional,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeSetBounded,The conditional expression  "(lastValue < minValue || lastValue > maxValue) || (lastValue + value < minValue || lastValue > maxValue - value)"  is complex.
Complex Conditional,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeSetBounded,The conditional expression  "(lastValue < minValue || lastValue > maxValue) || (lastValue + value < minValue || lastValue > maxValue - value)"  is complex.
Complex Conditional,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeSetBounded,The conditional expression  "(lastValue < minValue || lastValue > maxValue) || (lastValue + value < minValue || lastValue > maxValue - value)"  is complex.
Complex Conditional,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeSetBounded,The conditional expression  "(lastValue < minValue || lastValue > maxValue) || (lastValue + value < minValue || lastValue > maxValue - value)"  is complex.
Complex Conditional,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeSetBounded,The conditional expression  "(lastValue < minValue || lastValue > maxValue) || (lastValue + value < minValue || lastValue > maxValue - value)"  is complex.
Complex Conditional,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeSetBounded,The conditional expression  "(lastValue < minValue || lastValue > maxValue) || (lastValue + value < minValue || lastValue > maxValue - value)"  is complex.
Complex Conditional,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeExchangeBounded,The conditional expression  "(lastValue < minValue || lastValue > maxValue) || (lastValue + value < minValue || lastValue > maxValue - value)"  is complex.
Complex Conditional,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeExchangeBounded,The conditional expression  "(lastValue < minValue || lastValue > maxValue) || (lastValue + value < minValue || lastValue > maxValue - value)"  is complex.
Complex Conditional,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeExchangeBounded,The conditional expression  "(lastValue < minValue || lastValue > maxValue) || (lastValue + value < minValue || lastValue > maxValue - value)"  is complex.
Complex Conditional,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeExchangeBounded,The conditional expression  "(lastValue < minValue || lastValue > maxValue) || (lastValue + value < minValue || lastValue > maxValue - value)"  is complex.
Complex Conditional,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeExchangeBounded,The conditional expression  "(lastValue < minValue || lastValue > maxValue) || (lastValue + value < minValue || lastValue > maxValue - value)"  is complex.
Complex Conditional,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeExchangeBounded,The conditional expression  "(lastValue < minValue || lastValue > maxValue) || (lastValue + value < minValue || lastValue > maxValue - value)"  is complex.
Complex Conditional,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeExchangeBounded,The conditional expression  "(lastValue < minValue || lastValue > maxValue) || (lastValue + value < minValue || lastValue > maxValue - value)"  is complex.
Complex Conditional,Theraot.Threading,ThreadingHelper,C:\repos\theraot_Theraot\Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeExchangeBounded,The conditional expression  "(lastValue < minValue || lastValue > maxValue) || (lastValue + value < minValue || lastValue > maxValue - value)"  is complex.
Empty Catch Block,Theraot.Core,FolderEnumeration,C:\repos\theraot_Theraot\Core\Theraot\Core\FolderEnumeration.cs,GetFiles,The method has an empty catch block.
Empty Catch Block,Theraot.Core,FolderEnumeration,C:\repos\theraot_Theraot\Core\Theraot\Core\FolderEnumeration.cs,GetFiles,The method has an empty catch block.
Empty Catch Block,Theraot.Collections.ThreadSafe,WeakDelegateCollection,C:\repos\theraot_Theraot\Core\Theraot\Collections\ThreadSafe\WeakDelegateCollection.cs,InvokeExtracted,The method has an empty catch block.
Empty Catch Block,Theraot.Threading.Needles,Needle<T>,C:\repos\theraot_Theraot\Core\Theraot\Threading\Needles\Needle.cs,SetTargetValue,The method has an empty catch block.
Empty Catch Block,Theraot.Threading.Needles,WeakNeedle<T>,C:\repos\theraot_Theraot\Core\Theraot\Threading\Needles\WeakNeedle.cs,ReleaseExtracted,The method has an empty catch block.
Empty Catch Block,Theraot.Threading.Needles,WeakNeedle<T>,C:\repos\theraot_Theraot\Core\Theraot\Threading\Needles\WeakNeedle.cs,WriteTarget,The method has an empty catch block.
Magic Number,System.Runtime.CompilerServices,RuntimeVariableList,C:\repos\theraot_Theraot\Core\System\Dynamic\Utils\RuntimeOps.RuntimeVariableList.cs,GetStrongBox,The following statement contains a magic number: for (int parents = (int)(closureKey >> 32); parents > 0; parents--)                  {                      result = HoistedLocals.GetParent(result);                  }
Magic Number,System.Runtime.CompilerServices,AsyncMethodInt32TaskCache,C:\repos\theraot_Theraot\Core\System\Runtime\CompilerServices\AsyncMethodTaskCache.cs,CreateInt32Tasks,The following statement contains a magic number: var completionSourceArray = new TaskCompletionSource<int>[10];
Magic Number,System.Linq,QuickSort<TElement>,C:\repos\theraot_Theraot\Core\System\Linq\QuickSort.cs,MedianOfThree,The following statement contains a magic number: var center = (left + right) / 2;
Magic Number,System.Linq,QuickSort<TElement>,C:\repos\theraot_Theraot\Core\System\Linq\QuickSort.cs,Sort,The following statement contains a magic number: if (left + 3 <= right)              {                  var l = left;                  var r = right - 1;                  var pivot = MedianOfThree(left' right);                  while (true)                  {                      while (CompareItems(_indexes[++l]' pivot) < 0)                      {                      }                      while (CompareItems(_indexes[--r]' pivot) > 0)                      {                      }                      if (l < r)                      {                          Swap(l' r);                      }                      else                      {                          break;                      }                  }                  // Restore pivot                  Swap(l' right - 1);                  // Partition and sort                  Sort(left' l - 1);                  Sort(l + 1' right);              }              else              {                  // If there are three items in the subarray' insertion sort is better                  InsertionSort(left' right);              }
Magic Number,System.Linq.Expressions,Block2,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Rewrite,The following statement contains a magic number: Debug.Assert(args.Length == 2);
Magic Number,System.Linq.Expressions,Block3,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,GetExpression,The following statement contains a magic number: switch (index)              {                  case 0:                      return ReturnObject<Expression>(_arg0);                    case 1:                      return _arg1;                    case 2:                      return _arg2;                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions,Block3,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Rewrite,The following statement contains a magic number: Debug.Assert(args.Length == 3);
Magic Number,System.Linq.Expressions,Block3,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Rewrite,The following statement contains a magic number: return new Block3(args[0]' args[1]' args[2]);
Magic Number,System.Linq.Expressions,Block4,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,GetExpression,The following statement contains a magic number: switch (index)              {                  case 0:                      return ReturnObject<Expression>(_arg0);                    case 1:                      return _arg1;                    case 2:                      return _arg2;                    case 3:                      return _arg3;                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions,Block4,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,GetExpression,The following statement contains a magic number: switch (index)              {                  case 0:                      return ReturnObject<Expression>(_arg0);                    case 1:                      return _arg1;                    case 2:                      return _arg2;                    case 3:                      return _arg3;                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions,Block4,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Rewrite,The following statement contains a magic number: Debug.Assert(args.Length == 4);
Magic Number,System.Linq.Expressions,Block4,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Rewrite,The following statement contains a magic number: return new Block4(args[0]' args[1]' args[2]' args[3]);
Magic Number,System.Linq.Expressions,Block4,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Rewrite,The following statement contains a magic number: return new Block4(args[0]' args[1]' args[2]' args[3]);
Magic Number,System.Linq.Expressions,Block5,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,GetExpression,The following statement contains a magic number: switch (index)              {                  case 0:                      return ReturnObject<Expression>(_arg0);                    case 1:                      return _arg1;                    case 2:                      return _arg2;                    case 3:                      return _arg3;                    case 4:                      return _arg4;                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions,Block5,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,GetExpression,The following statement contains a magic number: switch (index)              {                  case 0:                      return ReturnObject<Expression>(_arg0);                    case 1:                      return _arg1;                    case 2:                      return _arg2;                    case 3:                      return _arg3;                    case 4:                      return _arg4;                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions,Block5,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,GetExpression,The following statement contains a magic number: switch (index)              {                  case 0:                      return ReturnObject<Expression>(_arg0);                    case 1:                      return _arg1;                    case 2:                      return _arg2;                    case 3:                      return _arg3;                    case 4:                      return _arg4;                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions,Block5,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Rewrite,The following statement contains a magic number: Debug.Assert(args.Length == 5);
Magic Number,System.Linq.Expressions,Block5,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Rewrite,The following statement contains a magic number: return new Block5(args[0]' args[1]' args[2]' args[3]' args[4]);
Magic Number,System.Linq.Expressions,Block5,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Rewrite,The following statement contains a magic number: return new Block5(args[0]' args[1]' args[2]' args[3]' args[4]);
Magic Number,System.Linq.Expressions,Block5,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Rewrite,The following statement contains a magic number: return new Block5(args[0]' args[1]' args[2]' args[3]' args[4]);
Magic Number,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Block,The following statement contains a magic number: switch (expressions.Length)              {                  case 2:                      return Block(expressions[0]' expressions[1]);                    case 3:                      return Block(expressions[0]' expressions[1]' expressions[2]);                    case 4:                      return Block(expressions[0]' expressions[1]' expressions[2]' expressions[3]);                    case 5:                      return Block(expressions[0]' expressions[1]' expressions[2]' expressions[3]' expressions[4]);                    default:                      ContractUtils.RequiresNotEmpty(expressions' "expressions");                      RequiresCanRead(expressions' "expressions");                      return new BlockN(expressions.Copy());              }
Magic Number,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Block,The following statement contains a magic number: switch (expressions.Length)              {                  case 2:                      return Block(expressions[0]' expressions[1]);                    case 3:                      return Block(expressions[0]' expressions[1]' expressions[2]);                    case 4:                      return Block(expressions[0]' expressions[1]' expressions[2]' expressions[3]);                    case 5:                      return Block(expressions[0]' expressions[1]' expressions[2]' expressions[3]' expressions[4]);                    default:                      ContractUtils.RequiresNotEmpty(expressions' "expressions");                      RequiresCanRead(expressions' "expressions");                      return new BlockN(expressions.Copy());              }
Magic Number,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Block,The following statement contains a magic number: switch (expressions.Length)              {                  case 2:                      return Block(expressions[0]' expressions[1]);                    case 3:                      return Block(expressions[0]' expressions[1]' expressions[2]);                    case 4:                      return Block(expressions[0]' expressions[1]' expressions[2]' expressions[3]);                    case 5:                      return Block(expressions[0]' expressions[1]' expressions[2]' expressions[3]' expressions[4]);                    default:                      ContractUtils.RequiresNotEmpty(expressions' "expressions");                      RequiresCanRead(expressions' "expressions");                      return new BlockN(expressions.Copy());              }
Magic Number,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Block,The following statement contains a magic number: switch (expressions.Length)              {                  case 2:                      return Block(expressions[0]' expressions[1]);                    case 3:                      return Block(expressions[0]' expressions[1]' expressions[2]);                    case 4:                      return Block(expressions[0]' expressions[1]' expressions[2]' expressions[3]);                    case 5:                      return Block(expressions[0]' expressions[1]' expressions[2]' expressions[3]' expressions[4]);                    default:                      ContractUtils.RequiresNotEmpty(expressions' "expressions");                      RequiresCanRead(expressions' "expressions");                      return new BlockN(expressions.Copy());              }
Magic Number,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Block,The following statement contains a magic number: switch (expressions.Length)              {                  case 2:                      return Block(expressions[0]' expressions[1]);                    case 3:                      return Block(expressions[0]' expressions[1]' expressions[2]);                    case 4:                      return Block(expressions[0]' expressions[1]' expressions[2]' expressions[3]);                    case 5:                      return Block(expressions[0]' expressions[1]' expressions[2]' expressions[3]' expressions[4]);                    default:                      ContractUtils.RequiresNotEmpty(expressions' "expressions");                      RequiresCanRead(expressions' "expressions");                      return new BlockN(expressions.Copy());              }
Magic Number,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Block,The following statement contains a magic number: switch (expressions.Length)              {                  case 2:                      return Block(expressions[0]' expressions[1]);                    case 3:                      return Block(expressions[0]' expressions[1]' expressions[2]);                    case 4:                      return Block(expressions[0]' expressions[1]' expressions[2]' expressions[3]);                    case 5:                      return Block(expressions[0]' expressions[1]' expressions[2]' expressions[3]' expressions[4]);                    default:                      ContractUtils.RequiresNotEmpty(expressions' "expressions");                      RequiresCanRead(expressions' "expressions");                      return new BlockN(expressions.Copy());              }
Magic Number,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Block,The following statement contains a magic number: switch (expressions.Length)              {                  case 2:                      return Block(expressions[0]' expressions[1]);                    case 3:                      return Block(expressions[0]' expressions[1]' expressions[2]);                    case 4:                      return Block(expressions[0]' expressions[1]' expressions[2]' expressions[3]);                    case 5:                      return Block(expressions[0]' expressions[1]' expressions[2]' expressions[3]' expressions[4]);                    default:                      ContractUtils.RequiresNotEmpty(expressions' "expressions");                      RequiresCanRead(expressions' "expressions");                      return new BlockN(expressions.Copy());              }
Magic Number,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Block,The following statement contains a magic number: switch (expressions.Length)              {                  case 2:                      return Block(expressions[0]' expressions[1]);                    case 3:                      return Block(expressions[0]' expressions[1]' expressions[2]);                    case 4:                      return Block(expressions[0]' expressions[1]' expressions[2]' expressions[3]);                    case 5:                      return Block(expressions[0]' expressions[1]' expressions[2]' expressions[3]' expressions[4]);                    default:                      ContractUtils.RequiresNotEmpty(expressions' "expressions");                      RequiresCanRead(expressions' "expressions");                      return new BlockN(expressions.Copy());              }
Magic Number,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Block,The following statement contains a magic number: switch (expressions.Length)              {                  case 2:                      return Block(expressions[0]' expressions[1]);                    case 3:                      return Block(expressions[0]' expressions[1]' expressions[2]);                    case 4:                      return Block(expressions[0]' expressions[1]' expressions[2]' expressions[3]);                    case 5:                      return Block(expressions[0]' expressions[1]' expressions[2]' expressions[3]' expressions[4]);                    default:                      ContractUtils.RequiresNotEmpty(expressions' "expressions");                      RequiresCanRead(expressions' "expressions");                      return new BlockN(expressions.Copy());              }
Magic Number,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Block,The following statement contains a magic number: switch (expressions.Length)              {                  case 2:                      return Block(expressions[0]' expressions[1]);                    case 3:                      return Block(expressions[0]' expressions[1]' expressions[2]);                    case 4:                      return Block(expressions[0]' expressions[1]' expressions[2]' expressions[3]);                    case 5:                      return Block(expressions[0]' expressions[1]' expressions[2]' expressions[3]' expressions[4]);                    default:                      ContractUtils.RequiresNotEmpty(expressions' "expressions");                      RequiresCanRead(expressions' "expressions");                      return new BlockN(expressions.Copy());              }
Magic Number,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Switch,The following statement contains a magic number: if (comparison != null)              {                  var pms = comparison.GetParameters();                  if (pms.Length != 2)                  {                      throw Error.IncorrectNumberOfMethodCallArguments(comparison);                  }                  // Validate that the switch value's type matches the comparison method's                  // left hand side parameter type.                  var leftParam = pms[0];                  var liftedCall = false;                  if (!ParameterIsAssignable(leftParam' switchValue.Type))                  {                      liftedCall = ParameterIsAssignable(leftParam' switchValue.Type.GetNonNullableType());                      if (!liftedCall)                      {                          throw Error.SwitchValueTypeDoesNotMatchComparisonMethodParameter(switchValue.Type' leftParam.ParameterType);                      }                  }                    var rightParam = pms[1];                  foreach (var c in caseList)                  {                      ContractUtils.RequiresNotNull(c' "cases");                      ValidateSwitchCaseType(c.Body' customType' resultType' "cases");                      for (var i = 0; i < c.TestValues.Count; i++)                      {                          // When a comparison method is provided' test values can have different type but have to                          // be reference assignable to the right hand side parameter of the method.                          var rightOperandType = c.TestValues[i].Type;                          if (liftedCall)                          {                              if (!rightOperandType.IsNullableType())                              {                                  throw Error.TestValueTypeDoesNotMatchComparisonMethodParameter(rightOperandType' rightParam.ParameterType);                              }                              rightOperandType = rightOperandType.GetNonNullableType();                          }                          if (!ParameterIsAssignable(rightParam' rightOperandType))                          {                              throw Error.TestValueTypeDoesNotMatchComparisonMethodParameter(rightOperandType' rightParam.ParameterType);                          }                      }                  }              }              else              {                  // When comparison method is not present' all the test values must have                  // the same type. Use the first test value's type as the baseline.                  var firstTestValue = caseList[0].TestValues[0];                  foreach (var c in caseList)                  {                      ContractUtils.RequiresNotNull(c' "cases");                      ValidateSwitchCaseType(c.Body' customType' resultType' "cases");                      // When no comparison method is provided' require all test values to have the same type.                      for (var i = 0; i < c.TestValues.Count; i++)                      {                          if (firstTestValue.Type != c.TestValues[i].Type)                          {                              throw new ArgumentException(Strings.AllTestValuesMustHaveSameType' "cases");                          }                      }                  }                    // Now we need to validate that switchValue.Type and testValueType                  // make sense in an Equal node. Fortunately' Equal throws a                  // reasonable error' so just call it.                  var equal = Equal(switchValue' firstTestValue' false' null);                    // Get the comparison function from equals node.                  comparison = equal.Method;              }
Magic Number,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,GetMethodBasedBinaryOperator,The following statement contains a magic number: if (pms.Length != 2)              {                  throw Error.IncorrectNumberOfMethodCallArguments(method);              }
Magic Number,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,ValidateUserDefinedConditionalLogicOperator,The following statement contains a magic number: if (pms.Length != 2)              {                  throw Error.IncorrectNumberOfMethodCallArguments(method);              }
Magic Number,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,CreateLambda,The following statement contains a magic number: if (factories == null)              {                  _lambdaFactories = factories = new CacheDict<Type' Func<Expression' string' bool' ReadOnlyCollection<ParameterExpression>' LambdaExpression>>(50);              }
Magic Number,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Call,The following statement contains a magic number: ValidateArgumentCount(method' ExpressionType.Call' 2' pis);
Magic Number,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Call,The following statement contains a magic number: ValidateArgumentCount(method' ExpressionType.Call' 3' pis);
Magic Number,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Call,The following statement contains a magic number: arg2 = ValidateOneArgument(method' ExpressionType.Call' arg2' pis[2]);
Magic Number,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Call,The following statement contains a magic number: ValidateArgumentCount(method' ExpressionType.Call' 4' pis);
Magic Number,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Call,The following statement contains a magic number: arg2 = ValidateOneArgument(method' ExpressionType.Call' arg2' pis[2]);
Magic Number,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Call,The following statement contains a magic number: arg3 = ValidateOneArgument(method' ExpressionType.Call' arg3' pis[3]);
Magic Number,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Call,The following statement contains a magic number: ValidateArgumentCount(method' ExpressionType.Call' 5' pis);
Magic Number,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Call,The following statement contains a magic number: arg2 = ValidateOneArgument(method' ExpressionType.Call' arg2' pis[2]);
Magic Number,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Call,The following statement contains a magic number: arg3 = ValidateOneArgument(method' ExpressionType.Call' arg3' pis[3]);
Magic Number,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Call,The following statement contains a magic number: arg4 = ValidateOneArgument(method' ExpressionType.Call' arg4' pis[4]);
Magic Number,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Call,The following statement contains a magic number: ValidateArgumentCount(method' ExpressionType.Call' 2' pis);
Magic Number,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Call,The following statement contains a magic number: ValidateArgumentCount(method' ExpressionType.Call' 3' pis);
Magic Number,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,Call,The following statement contains a magic number: arg2 = ValidateOneArgument(method' ExpressionType.Call' arg2' pis[2]);
Magic Number,System.Linq.Expressions,DebugViewWriter,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\DebugViewWriter.net30.cs,GetOperatorPrecedence,The following statement contains a magic number: switch (node.NodeType)              {                  // Assignment                  case ExpressionType.Assign:                  case ExpressionType.ExclusiveOrAssign:                  case ExpressionType.AddAssign:                  case ExpressionType.AddAssignChecked:                  case ExpressionType.SubtractAssign:                  case ExpressionType.SubtractAssignChecked:                  case ExpressionType.DivideAssign:                  case ExpressionType.ModuloAssign:                  case ExpressionType.MultiplyAssign:                  case ExpressionType.MultiplyAssignChecked:                  case ExpressionType.LeftShiftAssign:                  case ExpressionType.RightShiftAssign:                  case ExpressionType.AndAssign:                  case ExpressionType.OrAssign:                  case ExpressionType.PowerAssign:                  case ExpressionType.Coalesce:                      return 1;                    // Conditional (?:) would go here                    // Conditional OR                  case ExpressionType.OrElse:                      return 2;                    // Conditional AND                  case ExpressionType.AndAlso:                      return 3;                    // Logical OR                  case ExpressionType.Or:                      return 4;                    // Logical XOR                  case ExpressionType.ExclusiveOr:                      return 5;                    // Logical AND                  case ExpressionType.And:                      return 6;                    // Equality                  case ExpressionType.Equal:                  case ExpressionType.NotEqual:                      return 7;                    // Relational' type testing                  case ExpressionType.GreaterThan:                  case ExpressionType.LessThan:                  case ExpressionType.GreaterThanOrEqual:                  case ExpressionType.LessThanOrEqual:                  case ExpressionType.TypeAs:                  case ExpressionType.TypeIs:                  case ExpressionType.TypeEqual:                      return 8;                    // Shift                  case ExpressionType.LeftShift:                  case ExpressionType.RightShift:                      return 9;                    // Additive                  case ExpressionType.Add:                  case ExpressionType.AddChecked:                  case ExpressionType.Subtract:                  case ExpressionType.SubtractChecked:                      return 10;                    // Multiplicative                  case ExpressionType.Divide:                  case ExpressionType.Modulo:                  case ExpressionType.Multiply:                  case ExpressionType.MultiplyChecked:                      return 11;                    // Unary                  case ExpressionType.Negate:                  case ExpressionType.NegateChecked:                  case ExpressionType.UnaryPlus:                  case ExpressionType.Not:                  case ExpressionType.Convert:                  case ExpressionType.ConvertChecked:                  case ExpressionType.PreIncrementAssign:                  case ExpressionType.PreDecrementAssign:                  case ExpressionType.OnesComplement:                  case ExpressionType.Increment:                  case ExpressionType.Decrement:                  case ExpressionType.IsTrue:                  case ExpressionType.IsFalse:                  case ExpressionType.Unbox:                  case ExpressionType.Throw:                      return 12;                    // Power' which is not in C#                  // But VB/Python/Ruby put it here' above unary.                  case ExpressionType.Power:                      return 13;                    // Primary' which includes all other node types:                  //   member access' calls' indexing' new.                  /*case ExpressionType.PostIncrementAssign:                  case ExpressionType.PostDecrementAssign:*/                  default:                      return 14;                    // These aren't expressions' so never need parentheses:                  //   constants' variables                  case ExpressionType.Constant:                  case ExpressionType.Parameter:                      return 15;              }
Magic Number,System.Linq.Expressions,DebugViewWriter,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\DebugViewWriter.net30.cs,GetOperatorPrecedence,The following statement contains a magic number: switch (node.NodeType)              {                  // Assignment                  case ExpressionType.Assign:                  case ExpressionType.ExclusiveOrAssign:                  case ExpressionType.AddAssign:                  case ExpressionType.AddAssignChecked:                  case ExpressionType.SubtractAssign:                  case ExpressionType.SubtractAssignChecked:                  case ExpressionType.DivideAssign:                  case ExpressionType.ModuloAssign:                  case ExpressionType.MultiplyAssign:                  case ExpressionType.MultiplyAssignChecked:                  case ExpressionType.LeftShiftAssign:                  case ExpressionType.RightShiftAssign:                  case ExpressionType.AndAssign:                  case ExpressionType.OrAssign:                  case ExpressionType.PowerAssign:                  case ExpressionType.Coalesce:                      return 1;                    // Conditional (?:) would go here                    // Conditional OR                  case ExpressionType.OrElse:                      return 2;                    // Conditional AND                  case ExpressionType.AndAlso:                      return 3;                    // Logical OR                  case ExpressionType.Or:                      return 4;                    // Logical XOR                  case ExpressionType.ExclusiveOr:                      return 5;                    // Logical AND                  case ExpressionType.And:                      return 6;                    // Equality                  case ExpressionType.Equal:                  case ExpressionType.NotEqual:                      return 7;                    // Relational' type testing                  case ExpressionType.GreaterThan:                  case ExpressionType.LessThan:                  case ExpressionType.GreaterThanOrEqual:                  case ExpressionType.LessThanOrEqual:                  case ExpressionType.TypeAs:                  case ExpressionType.TypeIs:                  case ExpressionType.TypeEqual:                      return 8;                    // Shift                  case ExpressionType.LeftShift:                  case ExpressionType.RightShift:                      return 9;                    // Additive                  case ExpressionType.Add:                  case ExpressionType.AddChecked:                  case ExpressionType.Subtract:                  case ExpressionType.SubtractChecked:                      return 10;                    // Multiplicative                  case ExpressionType.Divide:                  case ExpressionType.Modulo:                  case ExpressionType.Multiply:                  case ExpressionType.MultiplyChecked:                      return 11;                    // Unary                  case ExpressionType.Negate:                  case ExpressionType.NegateChecked:                  case ExpressionType.UnaryPlus:                  case ExpressionType.Not:                  case ExpressionType.Convert:                  case ExpressionType.ConvertChecked:                  case ExpressionType.PreIncrementAssign:                  case ExpressionType.PreDecrementAssign:                  case ExpressionType.OnesComplement:                  case ExpressionType.Increment:                  case ExpressionType.Decrement:                  case ExpressionType.IsTrue:                  case ExpressionType.IsFalse:                  case ExpressionType.Unbox:                  case ExpressionType.Throw:                      return 12;                    // Power' which is not in C#                  // But VB/Python/Ruby put it here' above unary.                  case ExpressionType.Power:                      return 13;                    // Primary' which includes all other node types:                  //   member access' calls' indexing' new.                  /*case ExpressionType.PostIncrementAssign:                  case ExpressionType.PostDecrementAssign:*/                  default:                      return 14;                    // These aren't expressions' so never need parentheses:                  //   constants' variables                  case ExpressionType.Constant:                  case ExpressionType.Parameter:                      return 15;              }
Magic Number,System.Linq.Expressions,DebugViewWriter,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\DebugViewWriter.net30.cs,GetOperatorPrecedence,The following statement contains a magic number: switch (node.NodeType)              {                  // Assignment                  case ExpressionType.Assign:                  case ExpressionType.ExclusiveOrAssign:                  case ExpressionType.AddAssign:                  case ExpressionType.AddAssignChecked:                  case ExpressionType.SubtractAssign:                  case ExpressionType.SubtractAssignChecked:                  case ExpressionType.DivideAssign:                  case ExpressionType.ModuloAssign:                  case ExpressionType.MultiplyAssign:                  case ExpressionType.MultiplyAssignChecked:                  case ExpressionType.LeftShiftAssign:                  case ExpressionType.RightShiftAssign:                  case ExpressionType.AndAssign:                  case ExpressionType.OrAssign:                  case ExpressionType.PowerAssign:                  case ExpressionType.Coalesce:                      return 1;                    // Conditional (?:) would go here                    // Conditional OR                  case ExpressionType.OrElse:                      return 2;                    // Conditional AND                  case ExpressionType.AndAlso:                      return 3;                    // Logical OR                  case ExpressionType.Or:                      return 4;                    // Logical XOR                  case ExpressionType.ExclusiveOr:                      return 5;                    // Logical AND                  case ExpressionType.And:                      return 6;                    // Equality                  case ExpressionType.Equal:                  case ExpressionType.NotEqual:                      return 7;                    // Relational' type testing                  case ExpressionType.GreaterThan:                  case ExpressionType.LessThan:                  case ExpressionType.GreaterThanOrEqual:                  case ExpressionType.LessThanOrEqual:                  case ExpressionType.TypeAs:                  case ExpressionType.TypeIs:                  case ExpressionType.TypeEqual:                      return 8;                    // Shift                  case ExpressionType.LeftShift:                  case ExpressionType.RightShift:                      return 9;                    // Additive                  case ExpressionType.Add:                  case ExpressionType.AddChecked:                  case ExpressionType.Subtract:                  case ExpressionType.SubtractChecked:                      return 10;                    // Multiplicative                  case ExpressionType.Divide:                  case ExpressionType.Modulo:                  case ExpressionType.Multiply:                  case ExpressionType.MultiplyChecked:                      return 11;                    // Unary                  case ExpressionType.Negate:                  case ExpressionType.NegateChecked:                  case ExpressionType.UnaryPlus:                  case ExpressionType.Not:                  case ExpressionType.Convert:                  case ExpressionType.ConvertChecked:                  case ExpressionType.PreIncrementAssign:                  case ExpressionType.PreDecrementAssign:                  case ExpressionType.OnesComplement:                  case ExpressionType.Increment:                  case ExpressionType.Decrement:                  case ExpressionType.IsTrue:                  case ExpressionType.IsFalse:                  case ExpressionType.Unbox:                  case ExpressionType.Throw:                      return 12;                    // Power' which is not in C#                  // But VB/Python/Ruby put it here' above unary.                  case ExpressionType.Power:                      return 13;                    // Primary' which includes all other node types:                  //   member access' calls' indexing' new.                  /*case ExpressionType.PostIncrementAssign:                  case ExpressionType.PostDecrementAssign:*/                  default:                      return 14;                    // These aren't expressions' so never need parentheses:                  //   constants' variables                  case ExpressionType.Constant:                  case ExpressionType.Parameter:                      return 15;              }
Magic Number,System.Linq.Expressions,DebugViewWriter,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\DebugViewWriter.net30.cs,GetOperatorPrecedence,The following statement contains a magic number: switch (node.NodeType)              {                  // Assignment                  case ExpressionType.Assign:                  case ExpressionType.ExclusiveOrAssign:                  case ExpressionType.AddAssign:                  case ExpressionType.AddAssignChecked:                  case ExpressionType.SubtractAssign:                  case ExpressionType.SubtractAssignChecked:                  case ExpressionType.DivideAssign:                  case ExpressionType.ModuloAssign:                  case ExpressionType.MultiplyAssign:                  case ExpressionType.MultiplyAssignChecked:                  case ExpressionType.LeftShiftAssign:                  case ExpressionType.RightShiftAssign:                  case ExpressionType.AndAssign:                  case ExpressionType.OrAssign:                  case ExpressionType.PowerAssign:                  case ExpressionType.Coalesce:                      return 1;                    // Conditional (?:) would go here                    // Conditional OR                  case ExpressionType.OrElse:                      return 2;                    // Conditional AND                  case ExpressionType.AndAlso:                      return 3;                    // Logical OR                  case ExpressionType.Or:                      return 4;                    // Logical XOR                  case ExpressionType.ExclusiveOr:                      return 5;                    // Logical AND                  case ExpressionType.And:                      return 6;                    // Equality                  case ExpressionType.Equal:                  case ExpressionType.NotEqual:                      return 7;                    // Relational' type testing                  case ExpressionType.GreaterThan:                  case ExpressionType.LessThan:                  case ExpressionType.GreaterThanOrEqual:                  case ExpressionType.LessThanOrEqual:                  case ExpressionType.TypeAs:                  case ExpressionType.TypeIs:                  case ExpressionType.TypeEqual:                      return 8;                    // Shift                  case ExpressionType.LeftShift:                  case ExpressionType.RightShift:                      return 9;                    // Additive                  case ExpressionType.Add:                  case ExpressionType.AddChecked:                  case ExpressionType.Subtract:                  case ExpressionType.SubtractChecked:                      return 10;                    // Multiplicative                  case ExpressionType.Divide:                  case ExpressionType.Modulo:                  case ExpressionType.Multiply:                  case ExpressionType.MultiplyChecked:                      return 11;                    // Unary                  case ExpressionType.Negate:                  case ExpressionType.NegateChecked:                  case ExpressionType.UnaryPlus:                  case ExpressionType.Not:                  case ExpressionType.Convert:                  case ExpressionType.ConvertChecked:                  case ExpressionType.PreIncrementAssign:                  case ExpressionType.PreDecrementAssign:                  case ExpressionType.OnesComplement:                  case ExpressionType.Increment:                  case ExpressionType.Decrement:                  case ExpressionType.IsTrue:                  case ExpressionType.IsFalse:                  case ExpressionType.Unbox:                  case ExpressionType.Throw:                      return 12;                    // Power' which is not in C#                  // But VB/Python/Ruby put it here' above unary.                  case ExpressionType.Power:                      return 13;                    // Primary' which includes all other node types:                  //   member access' calls' indexing' new.                  /*case ExpressionType.PostIncrementAssign:                  case ExpressionType.PostDecrementAssign:*/                  default:                      return 14;                    // These aren't expressions' so never need parentheses:                  //   constants' variables                  case ExpressionType.Constant:                  case ExpressionType.Parameter:                      return 15;              }
Magic Number,System.Linq.Expressions,DebugViewWriter,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\DebugViewWriter.net30.cs,GetOperatorPrecedence,The following statement contains a magic number: switch (node.NodeType)              {                  // Assignment                  case ExpressionType.Assign:                  case ExpressionType.ExclusiveOrAssign:                  case ExpressionType.AddAssign:                  case ExpressionType.AddAssignChecked:                  case ExpressionType.SubtractAssign:                  case ExpressionType.SubtractAssignChecked:                  case ExpressionType.DivideAssign:                  case ExpressionType.ModuloAssign:                  case ExpressionType.MultiplyAssign:                  case ExpressionType.MultiplyAssignChecked:                  case ExpressionType.LeftShiftAssign:                  case ExpressionType.RightShiftAssign:                  case ExpressionType.AndAssign:                  case ExpressionType.OrAssign:                  case ExpressionType.PowerAssign:                  case ExpressionType.Coalesce:                      return 1;                    // Conditional (?:) would go here                    // Conditional OR                  case ExpressionType.OrElse:                      return 2;                    // Conditional AND                  case ExpressionType.AndAlso:                      return 3;                    // Logical OR                  case ExpressionType.Or:                      return 4;                    // Logical XOR                  case ExpressionType.ExclusiveOr:                      return 5;                    // Logical AND                  case ExpressionType.And:                      return 6;                    // Equality                  case ExpressionType.Equal:                  case ExpressionType.NotEqual:                      return 7;                    // Relational' type testing                  case ExpressionType.GreaterThan:                  case ExpressionType.LessThan:                  case ExpressionType.GreaterThanOrEqual:                  case ExpressionType.LessThanOrEqual:                  case ExpressionType.TypeAs:                  case ExpressionType.TypeIs:                  case ExpressionType.TypeEqual:                      return 8;                    // Shift                  case ExpressionType.LeftShift:                  case ExpressionType.RightShift:                      return 9;                    // Additive                  case ExpressionType.Add:                  case ExpressionType.AddChecked:                  case ExpressionType.Subtract:                  case ExpressionType.SubtractChecked:                      return 10;                    // Multiplicative                  case ExpressionType.Divide:                  case ExpressionType.Modulo:                  case ExpressionType.Multiply:                  case ExpressionType.MultiplyChecked:                      return 11;                    // Unary                  case ExpressionType.Negate:                  case ExpressionType.NegateChecked:                  case ExpressionType.UnaryPlus:                  case ExpressionType.Not:                  case ExpressionType.Convert:                  case ExpressionType.ConvertChecked:                  case ExpressionType.PreIncrementAssign:                  case ExpressionType.PreDecrementAssign:                  case ExpressionType.OnesComplement:                  case ExpressionType.Increment:                  case ExpressionType.Decrement:                  case ExpressionType.IsTrue:                  case ExpressionType.IsFalse:                  case ExpressionType.Unbox:                  case ExpressionType.Throw:                      return 12;                    // Power' which is not in C#                  // But VB/Python/Ruby put it here' above unary.                  case ExpressionType.Power:                      return 13;                    // Primary' which includes all other node types:                  //   member access' calls' indexing' new.                  /*case ExpressionType.PostIncrementAssign:                  case ExpressionType.PostDecrementAssign:*/                  default:                      return 14;                    // These aren't expressions' so never need parentheses:                  //   constants' variables                  case ExpressionType.Constant:                  case ExpressionType.Parameter:                      return 15;              }
Magic Number,System.Linq.Expressions,DebugViewWriter,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\DebugViewWriter.net30.cs,GetOperatorPrecedence,The following statement contains a magic number: switch (node.NodeType)              {                  // Assignment                  case ExpressionType.Assign:                  case ExpressionType.ExclusiveOrAssign:                  case ExpressionType.AddAssign:                  case ExpressionType.AddAssignChecked:                  case ExpressionType.SubtractAssign:                  case ExpressionType.SubtractAssignChecked:                  case ExpressionType.DivideAssign:                  case ExpressionType.ModuloAssign:                  case ExpressionType.MultiplyAssign:                  case ExpressionType.MultiplyAssignChecked:                  case ExpressionType.LeftShiftAssign:                  case ExpressionType.RightShiftAssign:                  case ExpressionType.AndAssign:                  case ExpressionType.OrAssign:                  case ExpressionType.PowerAssign:                  case ExpressionType.Coalesce:                      return 1;                    // Conditional (?:) would go here                    // Conditional OR                  case ExpressionType.OrElse:                      return 2;                    // Conditional AND                  case ExpressionType.AndAlso:                      return 3;                    // Logical OR                  case ExpressionType.Or:                      return 4;                    // Logical XOR                  case ExpressionType.ExclusiveOr:                      return 5;                    // Logical AND                  case ExpressionType.And:                      return 6;                    // Equality                  case ExpressionType.Equal:                  case ExpressionType.NotEqual:                      return 7;                    // Relational' type testing                  case ExpressionType.GreaterThan:                  case ExpressionType.LessThan:                  case ExpressionType.GreaterThanOrEqual:                  case ExpressionType.LessThanOrEqual:                  case ExpressionType.TypeAs:                  case ExpressionType.TypeIs:                  case ExpressionType.TypeEqual:                      return 8;                    // Shift                  case ExpressionType.LeftShift:                  case ExpressionType.RightShift:                      return 9;                    // Additive                  case ExpressionType.Add:                  case ExpressionType.AddChecked:                  case ExpressionType.Subtract:                  case ExpressionType.SubtractChecked:                      return 10;                    // Multiplicative                  case ExpressionType.Divide:                  case ExpressionType.Modulo:                  case ExpressionType.Multiply:                  case ExpressionType.MultiplyChecked:                      return 11;                    // Unary                  case ExpressionType.Negate:                  case ExpressionType.NegateChecked:                  case ExpressionType.UnaryPlus:                  case ExpressionType.Not:                  case ExpressionType.Convert:                  case ExpressionType.ConvertChecked:                  case ExpressionType.PreIncrementAssign:                  case ExpressionType.PreDecrementAssign:                  case ExpressionType.OnesComplement:                  case ExpressionType.Increment:                  case ExpressionType.Decrement:                  case ExpressionType.IsTrue:                  case ExpressionType.IsFalse:                  case ExpressionType.Unbox:                  case ExpressionType.Throw:                      return 12;                    // Power' which is not in C#                  // But VB/Python/Ruby put it here' above unary.                  case ExpressionType.Power:                      return 13;                    // Primary' which includes all other node types:                  //   member access' calls' indexing' new.                  /*case ExpressionType.PostIncrementAssign:                  case ExpressionType.PostDecrementAssign:*/                  default:                      return 14;                    // These aren't expressions' so never need parentheses:                  //   constants' variables                  case ExpressionType.Constant:                  case ExpressionType.Parameter:                      return 15;              }
Magic Number,System.Linq.Expressions,DebugViewWriter,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\DebugViewWriter.net30.cs,GetOperatorPrecedence,The following statement contains a magic number: switch (node.NodeType)              {                  // Assignment                  case ExpressionType.Assign:                  case ExpressionType.ExclusiveOrAssign:                  case ExpressionType.AddAssign:                  case ExpressionType.AddAssignChecked:                  case ExpressionType.SubtractAssign:                  case ExpressionType.SubtractAssignChecked:                  case ExpressionType.DivideAssign:                  case ExpressionType.ModuloAssign:                  case ExpressionType.MultiplyAssign:                  case ExpressionType.MultiplyAssignChecked:                  case ExpressionType.LeftShiftAssign:                  case ExpressionType.RightShiftAssign:                  case ExpressionType.AndAssign:                  case ExpressionType.OrAssign:                  case ExpressionType.PowerAssign:                  case ExpressionType.Coalesce:                      return 1;                    // Conditional (?:) would go here                    // Conditional OR                  case ExpressionType.OrElse:                      return 2;                    // Conditional AND                  case ExpressionType.AndAlso:                      return 3;                    // Logical OR                  case ExpressionType.Or:                      return 4;                    // Logical XOR                  case ExpressionType.ExclusiveOr:                      return 5;                    // Logical AND                  case ExpressionType.And:                      return 6;                    // Equality                  case ExpressionType.Equal:                  case ExpressionType.NotEqual:                      return 7;                    // Relational' type testing                  case ExpressionType.GreaterThan:                  case ExpressionType.LessThan:                  case ExpressionType.GreaterThanOrEqual:                  case ExpressionType.LessThanOrEqual:                  case ExpressionType.TypeAs:                  case ExpressionType.TypeIs:                  case ExpressionType.TypeEqual:                      return 8;                    // Shift                  case ExpressionType.LeftShift:                  case ExpressionType.RightShift:                      return 9;                    // Additive                  case ExpressionType.Add:                  case ExpressionType.AddChecked:                  case ExpressionType.Subtract:                  case ExpressionType.SubtractChecked:                      return 10;                    // Multiplicative                  case ExpressionType.Divide:                  case ExpressionType.Modulo:                  case ExpressionType.Multiply:                  case ExpressionType.MultiplyChecked:                      return 11;                    // Unary                  case ExpressionType.Negate:                  case ExpressionType.NegateChecked:                  case ExpressionType.UnaryPlus:                  case ExpressionType.Not:                  case ExpressionType.Convert:                  case ExpressionType.ConvertChecked:                  case ExpressionType.PreIncrementAssign:                  case ExpressionType.PreDecrementAssign:                  case ExpressionType.OnesComplement:                  case ExpressionType.Increment:                  case ExpressionType.Decrement:                  case ExpressionType.IsTrue:                  case ExpressionType.IsFalse:                  case ExpressionType.Unbox:                  case ExpressionType.Throw:                      return 12;                    // Power' which is not in C#                  // But VB/Python/Ruby put it here' above unary.                  case ExpressionType.Power:                      return 13;                    // Primary' which includes all other node types:                  //   member access' calls' indexing' new.                  /*case ExpressionType.PostIncrementAssign:                  case ExpressionType.PostDecrementAssign:*/                  default:                      return 14;                    // These aren't expressions' so never need parentheses:                  //   constants' variables                  case ExpressionType.Constant:                  case ExpressionType.Parameter:                      return 15;              }
Magic Number,System.Linq.Expressions,DebugViewWriter,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\DebugViewWriter.net30.cs,GetOperatorPrecedence,The following statement contains a magic number: switch (node.NodeType)              {                  // Assignment                  case ExpressionType.Assign:                  case ExpressionType.ExclusiveOrAssign:                  case ExpressionType.AddAssign:                  case ExpressionType.AddAssignChecked:                  case ExpressionType.SubtractAssign:                  case ExpressionType.SubtractAssignChecked:                  case ExpressionType.DivideAssign:                  case ExpressionType.ModuloAssign:                  case ExpressionType.MultiplyAssign:                  case ExpressionType.MultiplyAssignChecked:                  case ExpressionType.LeftShiftAssign:                  case ExpressionType.RightShiftAssign:                  case ExpressionType.AndAssign:                  case ExpressionType.OrAssign:                  case ExpressionType.PowerAssign:                  case ExpressionType.Coalesce:                      return 1;                    // Conditional (?:) would go here                    // Conditional OR                  case ExpressionType.OrElse:                      return 2;                    // Conditional AND                  case ExpressionType.AndAlso:                      return 3;                    // Logical OR                  case ExpressionType.Or:                      return 4;                    // Logical XOR                  case ExpressionType.ExclusiveOr:                      return 5;                    // Logical AND                  case ExpressionType.And:                      return 6;                    // Equality                  case ExpressionType.Equal:                  case ExpressionType.NotEqual:                      return 7;                    // Relational' type testing                  case ExpressionType.GreaterThan:                  case ExpressionType.LessThan:                  case ExpressionType.GreaterThanOrEqual:                  case ExpressionType.LessThanOrEqual:                  case ExpressionType.TypeAs:                  case ExpressionType.TypeIs:                  case ExpressionType.TypeEqual:                      return 8;                    // Shift                  case ExpressionType.LeftShift:                  case ExpressionType.RightShift:                      return 9;                    // Additive                  case ExpressionType.Add:                  case ExpressionType.AddChecked:                  case ExpressionType.Subtract:                  case ExpressionType.SubtractChecked:                      return 10;                    // Multiplicative                  case ExpressionType.Divide:                  case ExpressionType.Modulo:                  case ExpressionType.Multiply:                  case ExpressionType.MultiplyChecked:                      return 11;                    // Unary                  case ExpressionType.Negate:                  case ExpressionType.NegateChecked:                  case ExpressionType.UnaryPlus:                  case ExpressionType.Not:                  case ExpressionType.Convert:                  case ExpressionType.ConvertChecked:                  case ExpressionType.PreIncrementAssign:                  case ExpressionType.PreDecrementAssign:                  case ExpressionType.OnesComplement:                  case ExpressionType.Increment:                  case ExpressionType.Decrement:                  case ExpressionType.IsTrue:                  case ExpressionType.IsFalse:                  case ExpressionType.Unbox:                  case ExpressionType.Throw:                      return 12;                    // Power' which is not in C#                  // But VB/Python/Ruby put it here' above unary.                  case ExpressionType.Power:                      return 13;                    // Primary' which includes all other node types:                  //   member access' calls' indexing' new.                  /*case ExpressionType.PostIncrementAssign:                  case ExpressionType.PostDecrementAssign:*/                  default:                      return 14;                    // These aren't expressions' so never need parentheses:                  //   constants' variables                  case ExpressionType.Constant:                  case ExpressionType.Parameter:                      return 15;              }
Magic Number,System.Linq.Expressions,DebugViewWriter,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\DebugViewWriter.net30.cs,GetOperatorPrecedence,The following statement contains a magic number: switch (node.NodeType)              {                  // Assignment                  case ExpressionType.Assign:                  case ExpressionType.ExclusiveOrAssign:                  case ExpressionType.AddAssign:                  case ExpressionType.AddAssignChecked:                  case ExpressionType.SubtractAssign:                  case ExpressionType.SubtractAssignChecked:                  case ExpressionType.DivideAssign:                  case ExpressionType.ModuloAssign:                  case ExpressionType.MultiplyAssign:                  case ExpressionType.MultiplyAssignChecked:                  case ExpressionType.LeftShiftAssign:                  case ExpressionType.RightShiftAssign:                  case ExpressionType.AndAssign:                  case ExpressionType.OrAssign:                  case ExpressionType.PowerAssign:                  case ExpressionType.Coalesce:                      return 1;                    // Conditional (?:) would go here                    // Conditional OR                  case ExpressionType.OrElse:                      return 2;                    // Conditional AND                  case ExpressionType.AndAlso:                      return 3;                    // Logical OR                  case ExpressionType.Or:                      return 4;                    // Logical XOR                  case ExpressionType.ExclusiveOr:                      return 5;                    // Logical AND                  case ExpressionType.And:                      return 6;                    // Equality                  case ExpressionType.Equal:                  case ExpressionType.NotEqual:                      return 7;                    // Relational' type testing                  case ExpressionType.GreaterThan:                  case ExpressionType.LessThan:                  case ExpressionType.GreaterThanOrEqual:                  case ExpressionType.LessThanOrEqual:                  case ExpressionType.TypeAs:                  case ExpressionType.TypeIs:                  case ExpressionType.TypeEqual:                      return 8;                    // Shift                  case ExpressionType.LeftShift:                  case ExpressionType.RightShift:                      return 9;                    // Additive                  case ExpressionType.Add:                  case ExpressionType.AddChecked:                  case ExpressionType.Subtract:                  case ExpressionType.SubtractChecked:                      return 10;                    // Multiplicative                  case ExpressionType.Divide:                  case ExpressionType.Modulo:                  case ExpressionType.Multiply:                  case ExpressionType.MultiplyChecked:                      return 11;                    // Unary                  case ExpressionType.Negate:                  case ExpressionType.NegateChecked:                  case ExpressionType.UnaryPlus:                  case ExpressionType.Not:                  case ExpressionType.Convert:                  case ExpressionType.ConvertChecked:                  case ExpressionType.PreIncrementAssign:                  case ExpressionType.PreDecrementAssign:                  case ExpressionType.OnesComplement:                  case ExpressionType.Increment:                  case ExpressionType.Decrement:                  case ExpressionType.IsTrue:                  case ExpressionType.IsFalse:                  case ExpressionType.Unbox:                  case ExpressionType.Throw:                      return 12;                    // Power' which is not in C#                  // But VB/Python/Ruby put it here' above unary.                  case ExpressionType.Power:                      return 13;                    // Primary' which includes all other node types:                  //   member access' calls' indexing' new.                  /*case ExpressionType.PostIncrementAssign:                  case ExpressionType.PostDecrementAssign:*/                  default:                      return 14;                    // These aren't expressions' so never need parentheses:                  //   constants' variables                  case ExpressionType.Constant:                  case ExpressionType.Parameter:                      return 15;              }
Magic Number,System.Linq.Expressions,DebugViewWriter,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\DebugViewWriter.net30.cs,GetOperatorPrecedence,The following statement contains a magic number: switch (node.NodeType)              {                  // Assignment                  case ExpressionType.Assign:                  case ExpressionType.ExclusiveOrAssign:                  case ExpressionType.AddAssign:                  case ExpressionType.AddAssignChecked:                  case ExpressionType.SubtractAssign:                  case ExpressionType.SubtractAssignChecked:                  case ExpressionType.DivideAssign:                  case ExpressionType.ModuloAssign:                  case ExpressionType.MultiplyAssign:                  case ExpressionType.MultiplyAssignChecked:                  case ExpressionType.LeftShiftAssign:                  case ExpressionType.RightShiftAssign:                  case ExpressionType.AndAssign:                  case ExpressionType.OrAssign:                  case ExpressionType.PowerAssign:                  case ExpressionType.Coalesce:                      return 1;                    // Conditional (?:) would go here                    // Conditional OR                  case ExpressionType.OrElse:                      return 2;                    // Conditional AND                  case ExpressionType.AndAlso:                      return 3;                    // Logical OR                  case ExpressionType.Or:                      return 4;                    // Logical XOR                  case ExpressionType.ExclusiveOr:                      return 5;                    // Logical AND                  case ExpressionType.And:                      return 6;                    // Equality                  case ExpressionType.Equal:                  case ExpressionType.NotEqual:                      return 7;                    // Relational' type testing                  case ExpressionType.GreaterThan:                  case ExpressionType.LessThan:                  case ExpressionType.GreaterThanOrEqual:                  case ExpressionType.LessThanOrEqual:                  case ExpressionType.TypeAs:                  case ExpressionType.TypeIs:                  case ExpressionType.TypeEqual:                      return 8;                    // Shift                  case ExpressionType.LeftShift:                  case ExpressionType.RightShift:                      return 9;                    // Additive                  case ExpressionType.Add:                  case ExpressionType.AddChecked:                  case ExpressionType.Subtract:                  case ExpressionType.SubtractChecked:                      return 10;                    // Multiplicative                  case ExpressionType.Divide:                  case ExpressionType.Modulo:                  case ExpressionType.Multiply:                  case ExpressionType.MultiplyChecked:                      return 11;                    // Unary                  case ExpressionType.Negate:                  case ExpressionType.NegateChecked:                  case ExpressionType.UnaryPlus:                  case ExpressionType.Not:                  case ExpressionType.Convert:                  case ExpressionType.ConvertChecked:                  case ExpressionType.PreIncrementAssign:                  case ExpressionType.PreDecrementAssign:                  case ExpressionType.OnesComplement:                  case ExpressionType.Increment:                  case ExpressionType.Decrement:                  case ExpressionType.IsTrue:                  case ExpressionType.IsFalse:                  case ExpressionType.Unbox:                  case ExpressionType.Throw:                      return 12;                    // Power' which is not in C#                  // But VB/Python/Ruby put it here' above unary.                  case ExpressionType.Power:                      return 13;                    // Primary' which includes all other node types:                  //   member access' calls' indexing' new.                  /*case ExpressionType.PostIncrementAssign:                  case ExpressionType.PostDecrementAssign:*/                  default:                      return 14;                    // These aren't expressions' so never need parentheses:                  //   constants' variables                  case ExpressionType.Constant:                  case ExpressionType.Parameter:                      return 15;              }
Magic Number,System.Linq.Expressions,DebugViewWriter,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\DebugViewWriter.net30.cs,GetOperatorPrecedence,The following statement contains a magic number: switch (node.NodeType)              {                  // Assignment                  case ExpressionType.Assign:                  case ExpressionType.ExclusiveOrAssign:                  case ExpressionType.AddAssign:                  case ExpressionType.AddAssignChecked:                  case ExpressionType.SubtractAssign:                  case ExpressionType.SubtractAssignChecked:                  case ExpressionType.DivideAssign:                  case ExpressionType.ModuloAssign:                  case ExpressionType.MultiplyAssign:                  case ExpressionType.MultiplyAssignChecked:                  case ExpressionType.LeftShiftAssign:                  case ExpressionType.RightShiftAssign:                  case ExpressionType.AndAssign:                  case ExpressionType.OrAssign:                  case ExpressionType.PowerAssign:                  case ExpressionType.Coalesce:                      return 1;                    // Conditional (?:) would go here                    // Conditional OR                  case ExpressionType.OrElse:                      return 2;                    // Conditional AND                  case ExpressionType.AndAlso:                      return 3;                    // Logical OR                  case ExpressionType.Or:                      return 4;                    // Logical XOR                  case ExpressionType.ExclusiveOr:                      return 5;                    // Logical AND                  case ExpressionType.And:                      return 6;                    // Equality                  case ExpressionType.Equal:                  case ExpressionType.NotEqual:                      return 7;                    // Relational' type testing                  case ExpressionType.GreaterThan:                  case ExpressionType.LessThan:                  case ExpressionType.GreaterThanOrEqual:                  case ExpressionType.LessThanOrEqual:                  case ExpressionType.TypeAs:                  case ExpressionType.TypeIs:                  case ExpressionType.TypeEqual:                      return 8;                    // Shift                  case ExpressionType.LeftShift:                  case ExpressionType.RightShift:                      return 9;                    // Additive                  case ExpressionType.Add:                  case ExpressionType.AddChecked:                  case ExpressionType.Subtract:                  case ExpressionType.SubtractChecked:                      return 10;                    // Multiplicative                  case ExpressionType.Divide:                  case ExpressionType.Modulo:                  case ExpressionType.Multiply:                  case ExpressionType.MultiplyChecked:                      return 11;                    // Unary                  case ExpressionType.Negate:                  case ExpressionType.NegateChecked:                  case ExpressionType.UnaryPlus:                  case ExpressionType.Not:                  case ExpressionType.Convert:                  case ExpressionType.ConvertChecked:                  case ExpressionType.PreIncrementAssign:                  case ExpressionType.PreDecrementAssign:                  case ExpressionType.OnesComplement:                  case ExpressionType.Increment:                  case ExpressionType.Decrement:                  case ExpressionType.IsTrue:                  case ExpressionType.IsFalse:                  case ExpressionType.Unbox:                  case ExpressionType.Throw:                      return 12;                    // Power' which is not in C#                  // But VB/Python/Ruby put it here' above unary.                  case ExpressionType.Power:                      return 13;                    // Primary' which includes all other node types:                  //   member access' calls' indexing' new.                  /*case ExpressionType.PostIncrementAssign:                  case ExpressionType.PostDecrementAssign:*/                  default:                      return 14;                    // These aren't expressions' so never need parentheses:                  //   constants' variables                  case ExpressionType.Constant:                  case ExpressionType.Parameter:                      return 15;              }
Magic Number,System.Linq.Expressions,DebugViewWriter,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\DebugViewWriter.net30.cs,GetOperatorPrecedence,The following statement contains a magic number: switch (node.NodeType)              {                  // Assignment                  case ExpressionType.Assign:                  case ExpressionType.ExclusiveOrAssign:                  case ExpressionType.AddAssign:                  case ExpressionType.AddAssignChecked:                  case ExpressionType.SubtractAssign:                  case ExpressionType.SubtractAssignChecked:                  case ExpressionType.DivideAssign:                  case ExpressionType.ModuloAssign:                  case ExpressionType.MultiplyAssign:                  case ExpressionType.MultiplyAssignChecked:                  case ExpressionType.LeftShiftAssign:                  case ExpressionType.RightShiftAssign:                  case ExpressionType.AndAssign:                  case ExpressionType.OrAssign:                  case ExpressionType.PowerAssign:                  case ExpressionType.Coalesce:                      return 1;                    // Conditional (?:) would go here                    // Conditional OR                  case ExpressionType.OrElse:                      return 2;                    // Conditional AND                  case ExpressionType.AndAlso:                      return 3;                    // Logical OR                  case ExpressionType.Or:                      return 4;                    // Logical XOR                  case ExpressionType.ExclusiveOr:                      return 5;                    // Logical AND                  case ExpressionType.And:                      return 6;                    // Equality                  case ExpressionType.Equal:                  case ExpressionType.NotEqual:                      return 7;                    // Relational' type testing                  case ExpressionType.GreaterThan:                  case ExpressionType.LessThan:                  case ExpressionType.GreaterThanOrEqual:                  case ExpressionType.LessThanOrEqual:                  case ExpressionType.TypeAs:                  case ExpressionType.TypeIs:                  case ExpressionType.TypeEqual:                      return 8;                    // Shift                  case ExpressionType.LeftShift:                  case ExpressionType.RightShift:                      return 9;                    // Additive                  case ExpressionType.Add:                  case ExpressionType.AddChecked:                  case ExpressionType.Subtract:                  case ExpressionType.SubtractChecked:                      return 10;                    // Multiplicative                  case ExpressionType.Divide:                  case ExpressionType.Modulo:                  case ExpressionType.Multiply:                  case ExpressionType.MultiplyChecked:                      return 11;                    // Unary                  case ExpressionType.Negate:                  case ExpressionType.NegateChecked:                  case ExpressionType.UnaryPlus:                  case ExpressionType.Not:                  case ExpressionType.Convert:                  case ExpressionType.ConvertChecked:                  case ExpressionType.PreIncrementAssign:                  case ExpressionType.PreDecrementAssign:                  case ExpressionType.OnesComplement:                  case ExpressionType.Increment:                  case ExpressionType.Decrement:                  case ExpressionType.IsTrue:                  case ExpressionType.IsFalse:                  case ExpressionType.Unbox:                  case ExpressionType.Throw:                      return 12;                    // Power' which is not in C#                  // But VB/Python/Ruby put it here' above unary.                  case ExpressionType.Power:                      return 13;                    // Primary' which includes all other node types:                  //   member access' calls' indexing' new.                  /*case ExpressionType.PostIncrementAssign:                  case ExpressionType.PostDecrementAssign:*/                  default:                      return 14;                    // These aren't expressions' so never need parentheses:                  //   constants' variables                  case ExpressionType.Constant:                  case ExpressionType.Parameter:                      return 15;              }
Magic Number,System.Linq.Expressions,DebugViewWriter,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\DebugViewWriter.net30.cs,GetOperatorPrecedence,The following statement contains a magic number: switch (node.NodeType)              {                  // Assignment                  case ExpressionType.Assign:                  case ExpressionType.ExclusiveOrAssign:                  case ExpressionType.AddAssign:                  case ExpressionType.AddAssignChecked:                  case ExpressionType.SubtractAssign:                  case ExpressionType.SubtractAssignChecked:                  case ExpressionType.DivideAssign:                  case ExpressionType.ModuloAssign:                  case ExpressionType.MultiplyAssign:                  case ExpressionType.MultiplyAssignChecked:                  case ExpressionType.LeftShiftAssign:                  case ExpressionType.RightShiftAssign:                  case ExpressionType.AndAssign:                  case ExpressionType.OrAssign:                  case ExpressionType.PowerAssign:                  case ExpressionType.Coalesce:                      return 1;                    // Conditional (?:) would go here                    // Conditional OR                  case ExpressionType.OrElse:                      return 2;                    // Conditional AND                  case ExpressionType.AndAlso:                      return 3;                    // Logical OR                  case ExpressionType.Or:                      return 4;                    // Logical XOR                  case ExpressionType.ExclusiveOr:                      return 5;                    // Logical AND                  case ExpressionType.And:                      return 6;                    // Equality                  case ExpressionType.Equal:                  case ExpressionType.NotEqual:                      return 7;                    // Relational' type testing                  case ExpressionType.GreaterThan:                  case ExpressionType.LessThan:                  case ExpressionType.GreaterThanOrEqual:                  case ExpressionType.LessThanOrEqual:                  case ExpressionType.TypeAs:                  case ExpressionType.TypeIs:                  case ExpressionType.TypeEqual:                      return 8;                    // Shift                  case ExpressionType.LeftShift:                  case ExpressionType.RightShift:                      return 9;                    // Additive                  case ExpressionType.Add:                  case ExpressionType.AddChecked:                  case ExpressionType.Subtract:                  case ExpressionType.SubtractChecked:                      return 10;                    // Multiplicative                  case ExpressionType.Divide:                  case ExpressionType.Modulo:                  case ExpressionType.Multiply:                  case ExpressionType.MultiplyChecked:                      return 11;                    // Unary                  case ExpressionType.Negate:                  case ExpressionType.NegateChecked:                  case ExpressionType.UnaryPlus:                  case ExpressionType.Not:                  case ExpressionType.Convert:                  case ExpressionType.ConvertChecked:                  case ExpressionType.PreIncrementAssign:                  case ExpressionType.PreDecrementAssign:                  case ExpressionType.OnesComplement:                  case ExpressionType.Increment:                  case ExpressionType.Decrement:                  case ExpressionType.IsTrue:                  case ExpressionType.IsFalse:                  case ExpressionType.Unbox:                  case ExpressionType.Throw:                      return 12;                    // Power' which is not in C#                  // But VB/Python/Ruby put it here' above unary.                  case ExpressionType.Power:                      return 13;                    // Primary' which includes all other node types:                  //   member access' calls' indexing' new.                  /*case ExpressionType.PostIncrementAssign:                  case ExpressionType.PostDecrementAssign:*/                  default:                      return 14;                    // These aren't expressions' so never need parentheses:                  //   constants' variables                  case ExpressionType.Constant:                  case ExpressionType.Parameter:                      return 15;              }
Magic Number,System.Linq.Expressions,DebugViewWriter,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\DebugViewWriter.net30.cs,GetOperatorPrecedence,The following statement contains a magic number: switch (node.NodeType)              {                  // Assignment                  case ExpressionType.Assign:                  case ExpressionType.ExclusiveOrAssign:                  case ExpressionType.AddAssign:                  case ExpressionType.AddAssignChecked:                  case ExpressionType.SubtractAssign:                  case ExpressionType.SubtractAssignChecked:                  case ExpressionType.DivideAssign:                  case ExpressionType.ModuloAssign:                  case ExpressionType.MultiplyAssign:                  case ExpressionType.MultiplyAssignChecked:                  case ExpressionType.LeftShiftAssign:                  case ExpressionType.RightShiftAssign:                  case ExpressionType.AndAssign:                  case ExpressionType.OrAssign:                  case ExpressionType.PowerAssign:                  case ExpressionType.Coalesce:                      return 1;                    // Conditional (?:) would go here                    // Conditional OR                  case ExpressionType.OrElse:                      return 2;                    // Conditional AND                  case ExpressionType.AndAlso:                      return 3;                    // Logical OR                  case ExpressionType.Or:                      return 4;                    // Logical XOR                  case ExpressionType.ExclusiveOr:                      return 5;                    // Logical AND                  case ExpressionType.And:                      return 6;                    // Equality                  case ExpressionType.Equal:                  case ExpressionType.NotEqual:                      return 7;                    // Relational' type testing                  case ExpressionType.GreaterThan:                  case ExpressionType.LessThan:                  case ExpressionType.GreaterThanOrEqual:                  case ExpressionType.LessThanOrEqual:                  case ExpressionType.TypeAs:                  case ExpressionType.TypeIs:                  case ExpressionType.TypeEqual:                      return 8;                    // Shift                  case ExpressionType.LeftShift:                  case ExpressionType.RightShift:                      return 9;                    // Additive                  case ExpressionType.Add:                  case ExpressionType.AddChecked:                  case ExpressionType.Subtract:                  case ExpressionType.SubtractChecked:                      return 10;                    // Multiplicative                  case ExpressionType.Divide:                  case ExpressionType.Modulo:                  case ExpressionType.Multiply:                  case ExpressionType.MultiplyChecked:                      return 11;                    // Unary                  case ExpressionType.Negate:                  case ExpressionType.NegateChecked:                  case ExpressionType.UnaryPlus:                  case ExpressionType.Not:                  case ExpressionType.Convert:                  case ExpressionType.ConvertChecked:                  case ExpressionType.PreIncrementAssign:                  case ExpressionType.PreDecrementAssign:                  case ExpressionType.OnesComplement:                  case ExpressionType.Increment:                  case ExpressionType.Decrement:                  case ExpressionType.IsTrue:                  case ExpressionType.IsFalse:                  case ExpressionType.Unbox:                  case ExpressionType.Throw:                      return 12;                    // Power' which is not in C#                  // But VB/Python/Ruby put it here' above unary.                  case ExpressionType.Power:                      return 13;                    // Primary' which includes all other node types:                  //   member access' calls' indexing' new.                  /*case ExpressionType.PostIncrementAssign:                  case ExpressionType.PostDecrementAssign:*/                  default:                      return 14;                    // These aren't expressions' so never need parentheses:                  //   constants' variables                  case ExpressionType.Constant:                  case ExpressionType.Parameter:                      return 15;              }
Magic Number,System.Linq.Expressions,UnaryExpression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\UnaryExpression.net30.cs,ReduceIndex,The following statement contains a magic number: var block = new Expression[count + (prefix ? 2 : 4)];
Magic Number,System.Linq.Expressions,UnaryExpression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\UnaryExpression.net30.cs,ReduceIndex,The following statement contains a magic number: var block = new Expression[count + (prefix ? 2 : 4)];
Magic Number,System.Linq.Expressions,UnaryExpression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\UnaryExpression.net30.cs,ReduceIndex,The following statement contains a magic number: var temps = new ParameterExpression[count + (prefix ? 1 : 2)];
Magic Number,System.Linq.Expressions,BinaryExpression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BinaryExpression.net30.cs,ReduceIndex,The following statement contains a magic number: var vars = new List<ParameterExpression>(index.Arguments.Count + 2);
Magic Number,System.Linq.Expressions,BinaryExpression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BinaryExpression.net30.cs,ReduceIndex,The following statement contains a magic number: var exprs = new List<Expression>(index.Arguments.Count + 3);
Magic Number,System.Linq.Expressions,MemberInitExpression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\MemberInitExpression.net30.cs,ReduceMemberInit,The following statement contains a magic number: var block = new Expression[count + 2];
Magic Number,System.Linq.Expressions,MemberInitExpression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\MemberInitExpression.net30.cs,ReduceListInit,The following statement contains a magic number: var block = new Expression[count + 2];
Magic Number,System.Linq.Expressions,MethodCallExpression2,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\MethodCallExpression.net30.cs,Rewrite,The following statement contains a magic number: Debug.Assert(args == null || args.Count == 2);
Magic Number,System.Linq.Expressions,MethodCallExpression3,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\MethodCallExpression.net30.cs,GetArgument,The following statement contains a magic number: switch (index)              {                  case 0:                      return ReturnObject<Expression>(_arg0);                    case 1:                      return _arg1;                    case 2:                      return _arg2;                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions,MethodCallExpression3,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\MethodCallExpression.net30.cs,Rewrite,The following statement contains a magic number: Debug.Assert(args == null || args.Count == 3);
Magic Number,System.Linq.Expressions,MethodCallExpression3,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\MethodCallExpression.net30.cs,Rewrite,The following statement contains a magic number: if (args != null)              {                  return Call(Method' args[0]' args[1]' args[2]);              }
Magic Number,System.Linq.Expressions,MethodCallExpression4,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\MethodCallExpression.net30.cs,GetArgument,The following statement contains a magic number: switch (index)              {                  case 0:                      return ReturnObject<Expression>(_arg0);                    case 1:                      return _arg1;                    case 2:                      return _arg2;                    case 3:                      return _arg3;                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions,MethodCallExpression4,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\MethodCallExpression.net30.cs,GetArgument,The following statement contains a magic number: switch (index)              {                  case 0:                      return ReturnObject<Expression>(_arg0);                    case 1:                      return _arg1;                    case 2:                      return _arg2;                    case 3:                      return _arg3;                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions,MethodCallExpression4,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\MethodCallExpression.net30.cs,Rewrite,The following statement contains a magic number: Debug.Assert(args == null || args.Count == 4);
Magic Number,System.Linq.Expressions,MethodCallExpression4,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\MethodCallExpression.net30.cs,Rewrite,The following statement contains a magic number: if (args != null)              {                  return Call(Method' args[0]' args[1]' args[2]' args[3]);              }
Magic Number,System.Linq.Expressions,MethodCallExpression4,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\MethodCallExpression.net30.cs,Rewrite,The following statement contains a magic number: if (args != null)              {                  return Call(Method' args[0]' args[1]' args[2]' args[3]);              }
Magic Number,System.Linq.Expressions,MethodCallExpression5,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\MethodCallExpression.net30.cs,GetArgument,The following statement contains a magic number: switch (index)              {                  case 0:                      return ReturnObject<Expression>(_arg0);                    case 1:                      return _arg1;                    case 2:                      return _arg2;                    case 3:                      return _arg3;                    case 4:                      return _arg4;                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions,MethodCallExpression5,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\MethodCallExpression.net30.cs,GetArgument,The following statement contains a magic number: switch (index)              {                  case 0:                      return ReturnObject<Expression>(_arg0);                    case 1:                      return _arg1;                    case 2:                      return _arg2;                    case 3:                      return _arg3;                    case 4:                      return _arg4;                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions,MethodCallExpression5,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\MethodCallExpression.net30.cs,GetArgument,The following statement contains a magic number: switch (index)              {                  case 0:                      return ReturnObject<Expression>(_arg0);                    case 1:                      return _arg1;                    case 2:                      return _arg2;                    case 3:                      return _arg3;                    case 4:                      return _arg4;                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions,MethodCallExpression5,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\MethodCallExpression.net30.cs,Rewrite,The following statement contains a magic number: Debug.Assert(args == null || args.Count == 5);
Magic Number,System.Linq.Expressions,MethodCallExpression5,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\MethodCallExpression.net30.cs,Rewrite,The following statement contains a magic number: if (args != null)              {                  return Call(Method' args[0]' args[1]' args[2]' args[3]' args[4]);              }
Magic Number,System.Linq.Expressions,MethodCallExpression5,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\MethodCallExpression.net30.cs,Rewrite,The following statement contains a magic number: if (args != null)              {                  return Call(Method' args[0]' args[1]' args[2]' args[3]' args[4]);              }
Magic Number,System.Linq.Expressions,MethodCallExpression5,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\MethodCallExpression.net30.cs,Rewrite,The following statement contains a magic number: if (args != null)              {                  return Call(Method' args[0]' args[1]' args[2]' args[3]' args[4]);              }
Magic Number,System.Linq.Expressions,InstanceMethodCallExpression2,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\MethodCallExpression.net30.cs,Rewrite,The following statement contains a magic number: Debug.Assert(args == null || args.Count == 2);
Magic Number,System.Linq.Expressions,InstanceMethodCallExpression3,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\MethodCallExpression.net30.cs,GetArgument,The following statement contains a magic number: switch (index)              {                  case 0:                      return ReturnObject<Expression>(_arg0);                    case 1:                      return _arg1;                    case 2:                      return _arg2;                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions,InstanceMethodCallExpression3,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\MethodCallExpression.net30.cs,Rewrite,The following statement contains a magic number: Debug.Assert(args == null || args.Count == 3);
Magic Number,System.Linq.Expressions,InstanceMethodCallExpression3,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\MethodCallExpression.net30.cs,Rewrite,The following statement contains a magic number: if (args != null)              {                  return Call(instance' Method' args[0]' args[1]' args[2]);              }
Magic Number,System.Linq.Expressions.Compiler,BoundConstants,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\BoundConstants.net30.cs,ShouldCache,The following statement contains a magic number: return refCount > 2;
Magic Number,System.Linq.Expressions.Compiler,CompilerScope,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\CompilerScope.net30.cs,EmitVariableAccess,The following statement contains a magic number: if (NearestHoistedLocals != null)              {                  // Find what array each variable is on & its index                  var indexes = new List<long>(vars.Count);                    foreach (var variable in vars)                  {                      // For each variable' find what array it's defined on                      ulong parents = 0;                      var locals = NearestHoistedLocals;                      while (!locals.Indexes.ContainsKey(variable))                      {                          parents++;                          locals = locals.Parent;                          Debug.Assert(locals != null);                      }                        // combine the number of parents we walked' with the                      // real index of variable to get the index to emit.                      var index = (parents << 32) | (uint)locals.Indexes[variable];                        indexes.Add((long)index);                  }                    if (indexes.Count > 0)                  {                      EmitGet(NearestHoistedLocals.SelfVariable);                      lc.EmitConstantArray(indexes.ToArray());                      lc.IL.Emit(OpCodes.Call' typeof(RuntimeOps).GetMethod("CreateRuntimeVariables"' new[] { typeof(object[])' typeof(long[]) }));                      return;                  }              }
Magic Number,System.Linq.Expressions.Compiler,CompilerScope,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\CompilerScope.net30.cs,ShouldCache,The following statement contains a magic number: return refCount > 2 && !_locals.ContainsKey(v);
Magic Number,System.Linq.Expressions.Compiler,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\DelegateHelpers.Generated.cs,GetFuncType,The following statement contains a magic number: switch (types.Length)              {                  case 1:                      return typeof(Func<>).MakeGenericType(types);                    case 2:                      return typeof(Func<'>).MakeGenericType(types);                    case 3:                      return typeof(Func<''>).MakeGenericType(types);                    case 4:                      return typeof(Func<'''>).MakeGenericType(types);                    case 5:                      return typeof(Func<''''>).MakeGenericType(types);                    case 6:                      return typeof(Func<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Func<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Func<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Func<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Func<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Func<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Func<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Func<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Func<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Func<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Func<'''''''''''''''>).MakeGenericType(types);                    case 17:                      return typeof(Func<''''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,System.Linq.Expressions.Compiler,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\DelegateHelpers.Generated.cs,GetFuncType,The following statement contains a magic number: switch (types.Length)              {                  case 1:                      return typeof(Func<>).MakeGenericType(types);                    case 2:                      return typeof(Func<'>).MakeGenericType(types);                    case 3:                      return typeof(Func<''>).MakeGenericType(types);                    case 4:                      return typeof(Func<'''>).MakeGenericType(types);                    case 5:                      return typeof(Func<''''>).MakeGenericType(types);                    case 6:                      return typeof(Func<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Func<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Func<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Func<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Func<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Func<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Func<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Func<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Func<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Func<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Func<'''''''''''''''>).MakeGenericType(types);                    case 17:                      return typeof(Func<''''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,System.Linq.Expressions.Compiler,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\DelegateHelpers.Generated.cs,GetFuncType,The following statement contains a magic number: switch (types.Length)              {                  case 1:                      return typeof(Func<>).MakeGenericType(types);                    case 2:                      return typeof(Func<'>).MakeGenericType(types);                    case 3:                      return typeof(Func<''>).MakeGenericType(types);                    case 4:                      return typeof(Func<'''>).MakeGenericType(types);                    case 5:                      return typeof(Func<''''>).MakeGenericType(types);                    case 6:                      return typeof(Func<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Func<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Func<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Func<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Func<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Func<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Func<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Func<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Func<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Func<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Func<'''''''''''''''>).MakeGenericType(types);                    case 17:                      return typeof(Func<''''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,System.Linq.Expressions.Compiler,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\DelegateHelpers.Generated.cs,GetFuncType,The following statement contains a magic number: switch (types.Length)              {                  case 1:                      return typeof(Func<>).MakeGenericType(types);                    case 2:                      return typeof(Func<'>).MakeGenericType(types);                    case 3:                      return typeof(Func<''>).MakeGenericType(types);                    case 4:                      return typeof(Func<'''>).MakeGenericType(types);                    case 5:                      return typeof(Func<''''>).MakeGenericType(types);                    case 6:                      return typeof(Func<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Func<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Func<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Func<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Func<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Func<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Func<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Func<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Func<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Func<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Func<'''''''''''''''>).MakeGenericType(types);                    case 17:                      return typeof(Func<''''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,System.Linq.Expressions.Compiler,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\DelegateHelpers.Generated.cs,GetFuncType,The following statement contains a magic number: switch (types.Length)              {                  case 1:                      return typeof(Func<>).MakeGenericType(types);                    case 2:                      return typeof(Func<'>).MakeGenericType(types);                    case 3:                      return typeof(Func<''>).MakeGenericType(types);                    case 4:                      return typeof(Func<'''>).MakeGenericType(types);                    case 5:                      return typeof(Func<''''>).MakeGenericType(types);                    case 6:                      return typeof(Func<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Func<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Func<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Func<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Func<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Func<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Func<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Func<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Func<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Func<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Func<'''''''''''''''>).MakeGenericType(types);                    case 17:                      return typeof(Func<''''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,System.Linq.Expressions.Compiler,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\DelegateHelpers.Generated.cs,GetFuncType,The following statement contains a magic number: switch (types.Length)              {                  case 1:                      return typeof(Func<>).MakeGenericType(types);                    case 2:                      return typeof(Func<'>).MakeGenericType(types);                    case 3:                      return typeof(Func<''>).MakeGenericType(types);                    case 4:                      return typeof(Func<'''>).MakeGenericType(types);                    case 5:                      return typeof(Func<''''>).MakeGenericType(types);                    case 6:                      return typeof(Func<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Func<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Func<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Func<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Func<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Func<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Func<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Func<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Func<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Func<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Func<'''''''''''''''>).MakeGenericType(types);                    case 17:                      return typeof(Func<''''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,System.Linq.Expressions.Compiler,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\DelegateHelpers.Generated.cs,GetFuncType,The following statement contains a magic number: switch (types.Length)              {                  case 1:                      return typeof(Func<>).MakeGenericType(types);                    case 2:                      return typeof(Func<'>).MakeGenericType(types);                    case 3:                      return typeof(Func<''>).MakeGenericType(types);                    case 4:                      return typeof(Func<'''>).MakeGenericType(types);                    case 5:                      return typeof(Func<''''>).MakeGenericType(types);                    case 6:                      return typeof(Func<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Func<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Func<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Func<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Func<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Func<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Func<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Func<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Func<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Func<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Func<'''''''''''''''>).MakeGenericType(types);                    case 17:                      return typeof(Func<''''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,System.Linq.Expressions.Compiler,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\DelegateHelpers.Generated.cs,GetFuncType,The following statement contains a magic number: switch (types.Length)              {                  case 1:                      return typeof(Func<>).MakeGenericType(types);                    case 2:                      return typeof(Func<'>).MakeGenericType(types);                    case 3:                      return typeof(Func<''>).MakeGenericType(types);                    case 4:                      return typeof(Func<'''>).MakeGenericType(types);                    case 5:                      return typeof(Func<''''>).MakeGenericType(types);                    case 6:                      return typeof(Func<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Func<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Func<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Func<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Func<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Func<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Func<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Func<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Func<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Func<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Func<'''''''''''''''>).MakeGenericType(types);                    case 17:                      return typeof(Func<''''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,System.Linq.Expressions.Compiler,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\DelegateHelpers.Generated.cs,GetFuncType,The following statement contains a magic number: switch (types.Length)              {                  case 1:                      return typeof(Func<>).MakeGenericType(types);                    case 2:                      return typeof(Func<'>).MakeGenericType(types);                    case 3:                      return typeof(Func<''>).MakeGenericType(types);                    case 4:                      return typeof(Func<'''>).MakeGenericType(types);                    case 5:                      return typeof(Func<''''>).MakeGenericType(types);                    case 6:                      return typeof(Func<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Func<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Func<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Func<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Func<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Func<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Func<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Func<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Func<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Func<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Func<'''''''''''''''>).MakeGenericType(types);                    case 17:                      return typeof(Func<''''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,System.Linq.Expressions.Compiler,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\DelegateHelpers.Generated.cs,GetFuncType,The following statement contains a magic number: switch (types.Length)              {                  case 1:                      return typeof(Func<>).MakeGenericType(types);                    case 2:                      return typeof(Func<'>).MakeGenericType(types);                    case 3:                      return typeof(Func<''>).MakeGenericType(types);                    case 4:                      return typeof(Func<'''>).MakeGenericType(types);                    case 5:                      return typeof(Func<''''>).MakeGenericType(types);                    case 6:                      return typeof(Func<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Func<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Func<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Func<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Func<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Func<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Func<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Func<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Func<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Func<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Func<'''''''''''''''>).MakeGenericType(types);                    case 17:                      return typeof(Func<''''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,System.Linq.Expressions.Compiler,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\DelegateHelpers.Generated.cs,GetFuncType,The following statement contains a magic number: switch (types.Length)              {                  case 1:                      return typeof(Func<>).MakeGenericType(types);                    case 2:                      return typeof(Func<'>).MakeGenericType(types);                    case 3:                      return typeof(Func<''>).MakeGenericType(types);                    case 4:                      return typeof(Func<'''>).MakeGenericType(types);                    case 5:                      return typeof(Func<''''>).MakeGenericType(types);                    case 6:                      return typeof(Func<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Func<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Func<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Func<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Func<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Func<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Func<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Func<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Func<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Func<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Func<'''''''''''''''>).MakeGenericType(types);                    case 17:                      return typeof(Func<''''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,System.Linq.Expressions.Compiler,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\DelegateHelpers.Generated.cs,GetFuncType,The following statement contains a magic number: switch (types.Length)              {                  case 1:                      return typeof(Func<>).MakeGenericType(types);                    case 2:                      return typeof(Func<'>).MakeGenericType(types);                    case 3:                      return typeof(Func<''>).MakeGenericType(types);                    case 4:                      return typeof(Func<'''>).MakeGenericType(types);                    case 5:                      return typeof(Func<''''>).MakeGenericType(types);                    case 6:                      return typeof(Func<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Func<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Func<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Func<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Func<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Func<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Func<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Func<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Func<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Func<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Func<'''''''''''''''>).MakeGenericType(types);                    case 17:                      return typeof(Func<''''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,System.Linq.Expressions.Compiler,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\DelegateHelpers.Generated.cs,GetFuncType,The following statement contains a magic number: switch (types.Length)              {                  case 1:                      return typeof(Func<>).MakeGenericType(types);                    case 2:                      return typeof(Func<'>).MakeGenericType(types);                    case 3:                      return typeof(Func<''>).MakeGenericType(types);                    case 4:                      return typeof(Func<'''>).MakeGenericType(types);                    case 5:                      return typeof(Func<''''>).MakeGenericType(types);                    case 6:                      return typeof(Func<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Func<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Func<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Func<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Func<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Func<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Func<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Func<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Func<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Func<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Func<'''''''''''''''>).MakeGenericType(types);                    case 17:                      return typeof(Func<''''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,System.Linq.Expressions.Compiler,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\DelegateHelpers.Generated.cs,GetFuncType,The following statement contains a magic number: switch (types.Length)              {                  case 1:                      return typeof(Func<>).MakeGenericType(types);                    case 2:                      return typeof(Func<'>).MakeGenericType(types);                    case 3:                      return typeof(Func<''>).MakeGenericType(types);                    case 4:                      return typeof(Func<'''>).MakeGenericType(types);                    case 5:                      return typeof(Func<''''>).MakeGenericType(types);                    case 6:                      return typeof(Func<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Func<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Func<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Func<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Func<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Func<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Func<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Func<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Func<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Func<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Func<'''''''''''''''>).MakeGenericType(types);                    case 17:                      return typeof(Func<''''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,System.Linq.Expressions.Compiler,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\DelegateHelpers.Generated.cs,GetFuncType,The following statement contains a magic number: switch (types.Length)              {                  case 1:                      return typeof(Func<>).MakeGenericType(types);                    case 2:                      return typeof(Func<'>).MakeGenericType(types);                    case 3:                      return typeof(Func<''>).MakeGenericType(types);                    case 4:                      return typeof(Func<'''>).MakeGenericType(types);                    case 5:                      return typeof(Func<''''>).MakeGenericType(types);                    case 6:                      return typeof(Func<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Func<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Func<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Func<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Func<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Func<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Func<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Func<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Func<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Func<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Func<'''''''''''''''>).MakeGenericType(types);                    case 17:                      return typeof(Func<''''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,System.Linq.Expressions.Compiler,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\DelegateHelpers.Generated.cs,GetFuncType,The following statement contains a magic number: switch (types.Length)              {                  case 1:                      return typeof(Func<>).MakeGenericType(types);                    case 2:                      return typeof(Func<'>).MakeGenericType(types);                    case 3:                      return typeof(Func<''>).MakeGenericType(types);                    case 4:                      return typeof(Func<'''>).MakeGenericType(types);                    case 5:                      return typeof(Func<''''>).MakeGenericType(types);                    case 6:                      return typeof(Func<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Func<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Func<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Func<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Func<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Func<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Func<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Func<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Func<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Func<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Func<'''''''''''''''>).MakeGenericType(types);                    case 17:                      return typeof(Func<''''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,System.Linq.Expressions.Compiler,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\DelegateHelpers.Generated.cs,GetActionType,The following statement contains a magic number: switch (types.Length)              {                  case 0:                      return typeof(Action);                    case 1:                      return typeof(Action<>).MakeGenericType(types);                    case 2:                      return typeof(Action<'>).MakeGenericType(types);                    case 3:                      return typeof(Action<''>).MakeGenericType(types);                    case 4:                      return typeof(Action<'''>).MakeGenericType(types);                    case 5:                      return typeof(Action<''''>).MakeGenericType(types);                    case 6:                      return typeof(Action<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Action<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Action<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Action<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Action<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Action<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Action<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Action<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Action<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Action<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Action<'''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,System.Linq.Expressions.Compiler,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\DelegateHelpers.Generated.cs,GetActionType,The following statement contains a magic number: switch (types.Length)              {                  case 0:                      return typeof(Action);                    case 1:                      return typeof(Action<>).MakeGenericType(types);                    case 2:                      return typeof(Action<'>).MakeGenericType(types);                    case 3:                      return typeof(Action<''>).MakeGenericType(types);                    case 4:                      return typeof(Action<'''>).MakeGenericType(types);                    case 5:                      return typeof(Action<''''>).MakeGenericType(types);                    case 6:                      return typeof(Action<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Action<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Action<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Action<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Action<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Action<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Action<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Action<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Action<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Action<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Action<'''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,System.Linq.Expressions.Compiler,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\DelegateHelpers.Generated.cs,GetActionType,The following statement contains a magic number: switch (types.Length)              {                  case 0:                      return typeof(Action);                    case 1:                      return typeof(Action<>).MakeGenericType(types);                    case 2:                      return typeof(Action<'>).MakeGenericType(types);                    case 3:                      return typeof(Action<''>).MakeGenericType(types);                    case 4:                      return typeof(Action<'''>).MakeGenericType(types);                    case 5:                      return typeof(Action<''''>).MakeGenericType(types);                    case 6:                      return typeof(Action<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Action<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Action<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Action<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Action<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Action<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Action<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Action<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Action<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Action<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Action<'''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,System.Linq.Expressions.Compiler,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\DelegateHelpers.Generated.cs,GetActionType,The following statement contains a magic number: switch (types.Length)              {                  case 0:                      return typeof(Action);                    case 1:                      return typeof(Action<>).MakeGenericType(types);                    case 2:                      return typeof(Action<'>).MakeGenericType(types);                    case 3:                      return typeof(Action<''>).MakeGenericType(types);                    case 4:                      return typeof(Action<'''>).MakeGenericType(types);                    case 5:                      return typeof(Action<''''>).MakeGenericType(types);                    case 6:                      return typeof(Action<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Action<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Action<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Action<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Action<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Action<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Action<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Action<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Action<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Action<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Action<'''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,System.Linq.Expressions.Compiler,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\DelegateHelpers.Generated.cs,GetActionType,The following statement contains a magic number: switch (types.Length)              {                  case 0:                      return typeof(Action);                    case 1:                      return typeof(Action<>).MakeGenericType(types);                    case 2:                      return typeof(Action<'>).MakeGenericType(types);                    case 3:                      return typeof(Action<''>).MakeGenericType(types);                    case 4:                      return typeof(Action<'''>).MakeGenericType(types);                    case 5:                      return typeof(Action<''''>).MakeGenericType(types);                    case 6:                      return typeof(Action<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Action<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Action<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Action<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Action<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Action<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Action<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Action<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Action<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Action<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Action<'''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,System.Linq.Expressions.Compiler,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\DelegateHelpers.Generated.cs,GetActionType,The following statement contains a magic number: switch (types.Length)              {                  case 0:                      return typeof(Action);                    case 1:                      return typeof(Action<>).MakeGenericType(types);                    case 2:                      return typeof(Action<'>).MakeGenericType(types);                    case 3:                      return typeof(Action<''>).MakeGenericType(types);                    case 4:                      return typeof(Action<'''>).MakeGenericType(types);                    case 5:                      return typeof(Action<''''>).MakeGenericType(types);                    case 6:                      return typeof(Action<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Action<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Action<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Action<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Action<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Action<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Action<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Action<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Action<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Action<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Action<'''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,System.Linq.Expressions.Compiler,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\DelegateHelpers.Generated.cs,GetActionType,The following statement contains a magic number: switch (types.Length)              {                  case 0:                      return typeof(Action);                    case 1:                      return typeof(Action<>).MakeGenericType(types);                    case 2:                      return typeof(Action<'>).MakeGenericType(types);                    case 3:                      return typeof(Action<''>).MakeGenericType(types);                    case 4:                      return typeof(Action<'''>).MakeGenericType(types);                    case 5:                      return typeof(Action<''''>).MakeGenericType(types);                    case 6:                      return typeof(Action<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Action<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Action<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Action<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Action<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Action<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Action<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Action<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Action<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Action<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Action<'''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,System.Linq.Expressions.Compiler,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\DelegateHelpers.Generated.cs,GetActionType,The following statement contains a magic number: switch (types.Length)              {                  case 0:                      return typeof(Action);                    case 1:                      return typeof(Action<>).MakeGenericType(types);                    case 2:                      return typeof(Action<'>).MakeGenericType(types);                    case 3:                      return typeof(Action<''>).MakeGenericType(types);                    case 4:                      return typeof(Action<'''>).MakeGenericType(types);                    case 5:                      return typeof(Action<''''>).MakeGenericType(types);                    case 6:                      return typeof(Action<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Action<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Action<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Action<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Action<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Action<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Action<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Action<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Action<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Action<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Action<'''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,System.Linq.Expressions.Compiler,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\DelegateHelpers.Generated.cs,GetActionType,The following statement contains a magic number: switch (types.Length)              {                  case 0:                      return typeof(Action);                    case 1:                      return typeof(Action<>).MakeGenericType(types);                    case 2:                      return typeof(Action<'>).MakeGenericType(types);                    case 3:                      return typeof(Action<''>).MakeGenericType(types);                    case 4:                      return typeof(Action<'''>).MakeGenericType(types);                    case 5:                      return typeof(Action<''''>).MakeGenericType(types);                    case 6:                      return typeof(Action<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Action<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Action<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Action<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Action<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Action<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Action<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Action<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Action<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Action<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Action<'''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,System.Linq.Expressions.Compiler,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\DelegateHelpers.Generated.cs,GetActionType,The following statement contains a magic number: switch (types.Length)              {                  case 0:                      return typeof(Action);                    case 1:                      return typeof(Action<>).MakeGenericType(types);                    case 2:                      return typeof(Action<'>).MakeGenericType(types);                    case 3:                      return typeof(Action<''>).MakeGenericType(types);                    case 4:                      return typeof(Action<'''>).MakeGenericType(types);                    case 5:                      return typeof(Action<''''>).MakeGenericType(types);                    case 6:                      return typeof(Action<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Action<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Action<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Action<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Action<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Action<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Action<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Action<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Action<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Action<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Action<'''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,System.Linq.Expressions.Compiler,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\DelegateHelpers.Generated.cs,GetActionType,The following statement contains a magic number: switch (types.Length)              {                  case 0:                      return typeof(Action);                    case 1:                      return typeof(Action<>).MakeGenericType(types);                    case 2:                      return typeof(Action<'>).MakeGenericType(types);                    case 3:                      return typeof(Action<''>).MakeGenericType(types);                    case 4:                      return typeof(Action<'''>).MakeGenericType(types);                    case 5:                      return typeof(Action<''''>).MakeGenericType(types);                    case 6:                      return typeof(Action<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Action<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Action<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Action<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Action<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Action<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Action<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Action<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Action<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Action<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Action<'''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,System.Linq.Expressions.Compiler,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\DelegateHelpers.Generated.cs,GetActionType,The following statement contains a magic number: switch (types.Length)              {                  case 0:                      return typeof(Action);                    case 1:                      return typeof(Action<>).MakeGenericType(types);                    case 2:                      return typeof(Action<'>).MakeGenericType(types);                    case 3:                      return typeof(Action<''>).MakeGenericType(types);                    case 4:                      return typeof(Action<'''>).MakeGenericType(types);                    case 5:                      return typeof(Action<''''>).MakeGenericType(types);                    case 6:                      return typeof(Action<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Action<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Action<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Action<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Action<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Action<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Action<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Action<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Action<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Action<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Action<'''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,System.Linq.Expressions.Compiler,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\DelegateHelpers.Generated.cs,GetActionType,The following statement contains a magic number: switch (types.Length)              {                  case 0:                      return typeof(Action);                    case 1:                      return typeof(Action<>).MakeGenericType(types);                    case 2:                      return typeof(Action<'>).MakeGenericType(types);                    case 3:                      return typeof(Action<''>).MakeGenericType(types);                    case 4:                      return typeof(Action<'''>).MakeGenericType(types);                    case 5:                      return typeof(Action<''''>).MakeGenericType(types);                    case 6:                      return typeof(Action<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Action<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Action<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Action<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Action<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Action<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Action<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Action<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Action<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Action<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Action<'''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,System.Linq.Expressions.Compiler,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\DelegateHelpers.Generated.cs,GetActionType,The following statement contains a magic number: switch (types.Length)              {                  case 0:                      return typeof(Action);                    case 1:                      return typeof(Action<>).MakeGenericType(types);                    case 2:                      return typeof(Action<'>).MakeGenericType(types);                    case 3:                      return typeof(Action<''>).MakeGenericType(types);                    case 4:                      return typeof(Action<'''>).MakeGenericType(types);                    case 5:                      return typeof(Action<''''>).MakeGenericType(types);                    case 6:                      return typeof(Action<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Action<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Action<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Action<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Action<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Action<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Action<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Action<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Action<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Action<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Action<'''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,System.Linq.Expressions.Compiler,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\DelegateHelpers.Generated.cs,GetActionType,The following statement contains a magic number: switch (types.Length)              {                  case 0:                      return typeof(Action);                    case 1:                      return typeof(Action<>).MakeGenericType(types);                    case 2:                      return typeof(Action<'>).MakeGenericType(types);                    case 3:                      return typeof(Action<''>).MakeGenericType(types);                    case 4:                      return typeof(Action<'''>).MakeGenericType(types);                    case 5:                      return typeof(Action<''''>).MakeGenericType(types);                    case 6:                      return typeof(Action<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Action<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Action<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Action<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Action<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Action<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Action<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Action<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Action<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Action<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Action<'''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,System.Linq.Expressions.Compiler,ILGen,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitLoadArg,The following statement contains a magic number: switch (index)              {                  case 0:                      il.Emit(OpCodes.Ldarg_0);                      break;                    case 1:                      il.Emit(OpCodes.Ldarg_1);                      break;                    case 2:                      il.Emit(OpCodes.Ldarg_2);                      break;                    case 3:                      il.Emit(OpCodes.Ldarg_3);                      break;                    default:                      if (index <= byte.MaxValue)                      {                          il.Emit(OpCodes.Ldarg_S' (byte)index);                      }                      else                      {                          il.Emit(OpCodes.Ldarg' index);                      }                      break;              }
Magic Number,System.Linq.Expressions.Compiler,ILGen,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitLoadArg,The following statement contains a magic number: switch (index)              {                  case 0:                      il.Emit(OpCodes.Ldarg_0);                      break;                    case 1:                      il.Emit(OpCodes.Ldarg_1);                      break;                    case 2:                      il.Emit(OpCodes.Ldarg_2);                      break;                    case 3:                      il.Emit(OpCodes.Ldarg_3);                      break;                    default:                      if (index <= byte.MaxValue)                      {                          il.Emit(OpCodes.Ldarg_S' (byte)index);                      }                      else                      {                          il.Emit(OpCodes.Ldarg' index);                      }                      break;              }
Magic Number,System.Linq.Expressions.Compiler,ILGen,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitInt,The following statement contains a magic number: switch (value)              {                  case -1:                      c = OpCodes.Ldc_I4_M1;                      break;                    case 0:                      c = OpCodes.Ldc_I4_0;                      break;                    case 1:                      c = OpCodes.Ldc_I4_1;                      break;                    case 2:                      c = OpCodes.Ldc_I4_2;                      break;                    case 3:                      c = OpCodes.Ldc_I4_3;                      break;                    case 4:                      c = OpCodes.Ldc_I4_4;                      break;                    case 5:                      c = OpCodes.Ldc_I4_5;                      break;                    case 6:                      c = OpCodes.Ldc_I4_6;                      break;                    case 7:                      c = OpCodes.Ldc_I4_7;                      break;                    case 8:                      c = OpCodes.Ldc_I4_8;                      break;                    default:                      if (value >= -128 && value <= 127)                      {                          il.Emit(OpCodes.Ldc_I4_S' (sbyte)value);                      }                      else                      {                          il.Emit(OpCodes.Ldc_I4' value);                      }                      return;              }
Magic Number,System.Linq.Expressions.Compiler,ILGen,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitInt,The following statement contains a magic number: switch (value)              {                  case -1:                      c = OpCodes.Ldc_I4_M1;                      break;                    case 0:                      c = OpCodes.Ldc_I4_0;                      break;                    case 1:                      c = OpCodes.Ldc_I4_1;                      break;                    case 2:                      c = OpCodes.Ldc_I4_2;                      break;                    case 3:                      c = OpCodes.Ldc_I4_3;                      break;                    case 4:                      c = OpCodes.Ldc_I4_4;                      break;                    case 5:                      c = OpCodes.Ldc_I4_5;                      break;                    case 6:                      c = OpCodes.Ldc_I4_6;                      break;                    case 7:                      c = OpCodes.Ldc_I4_7;                      break;                    case 8:                      c = OpCodes.Ldc_I4_8;                      break;                    default:                      if (value >= -128 && value <= 127)                      {                          il.Emit(OpCodes.Ldc_I4_S' (sbyte)value);                      }                      else                      {                          il.Emit(OpCodes.Ldc_I4' value);                      }                      return;              }
Magic Number,System.Linq.Expressions.Compiler,ILGen,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitInt,The following statement contains a magic number: switch (value)              {                  case -1:                      c = OpCodes.Ldc_I4_M1;                      break;                    case 0:                      c = OpCodes.Ldc_I4_0;                      break;                    case 1:                      c = OpCodes.Ldc_I4_1;                      break;                    case 2:                      c = OpCodes.Ldc_I4_2;                      break;                    case 3:                      c = OpCodes.Ldc_I4_3;                      break;                    case 4:                      c = OpCodes.Ldc_I4_4;                      break;                    case 5:                      c = OpCodes.Ldc_I4_5;                      break;                    case 6:                      c = OpCodes.Ldc_I4_6;                      break;                    case 7:                      c = OpCodes.Ldc_I4_7;                      break;                    case 8:                      c = OpCodes.Ldc_I4_8;                      break;                    default:                      if (value >= -128 && value <= 127)                      {                          il.Emit(OpCodes.Ldc_I4_S' (sbyte)value);                      }                      else                      {                          il.Emit(OpCodes.Ldc_I4' value);                      }                      return;              }
Magic Number,System.Linq.Expressions.Compiler,ILGen,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitInt,The following statement contains a magic number: switch (value)              {                  case -1:                      c = OpCodes.Ldc_I4_M1;                      break;                    case 0:                      c = OpCodes.Ldc_I4_0;                      break;                    case 1:                      c = OpCodes.Ldc_I4_1;                      break;                    case 2:                      c = OpCodes.Ldc_I4_2;                      break;                    case 3:                      c = OpCodes.Ldc_I4_3;                      break;                    case 4:                      c = OpCodes.Ldc_I4_4;                      break;                    case 5:                      c = OpCodes.Ldc_I4_5;                      break;                    case 6:                      c = OpCodes.Ldc_I4_6;                      break;                    case 7:                      c = OpCodes.Ldc_I4_7;                      break;                    case 8:                      c = OpCodes.Ldc_I4_8;                      break;                    default:                      if (value >= -128 && value <= 127)                      {                          il.Emit(OpCodes.Ldc_I4_S' (sbyte)value);                      }                      else                      {                          il.Emit(OpCodes.Ldc_I4' value);                      }                      return;              }
Magic Number,System.Linq.Expressions.Compiler,ILGen,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitInt,The following statement contains a magic number: switch (value)              {                  case -1:                      c = OpCodes.Ldc_I4_M1;                      break;                    case 0:                      c = OpCodes.Ldc_I4_0;                      break;                    case 1:                      c = OpCodes.Ldc_I4_1;                      break;                    case 2:                      c = OpCodes.Ldc_I4_2;                      break;                    case 3:                      c = OpCodes.Ldc_I4_3;                      break;                    case 4:                      c = OpCodes.Ldc_I4_4;                      break;                    case 5:                      c = OpCodes.Ldc_I4_5;                      break;                    case 6:                      c = OpCodes.Ldc_I4_6;                      break;                    case 7:                      c = OpCodes.Ldc_I4_7;                      break;                    case 8:                      c = OpCodes.Ldc_I4_8;                      break;                    default:                      if (value >= -128 && value <= 127)                      {                          il.Emit(OpCodes.Ldc_I4_S' (sbyte)value);                      }                      else                      {                          il.Emit(OpCodes.Ldc_I4' value);                      }                      return;              }
Magic Number,System.Linq.Expressions.Compiler,ILGen,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitInt,The following statement contains a magic number: switch (value)              {                  case -1:                      c = OpCodes.Ldc_I4_M1;                      break;                    case 0:                      c = OpCodes.Ldc_I4_0;                      break;                    case 1:                      c = OpCodes.Ldc_I4_1;                      break;                    case 2:                      c = OpCodes.Ldc_I4_2;                      break;                    case 3:                      c = OpCodes.Ldc_I4_3;                      break;                    case 4:                      c = OpCodes.Ldc_I4_4;                      break;                    case 5:                      c = OpCodes.Ldc_I4_5;                      break;                    case 6:                      c = OpCodes.Ldc_I4_6;                      break;                    case 7:                      c = OpCodes.Ldc_I4_7;                      break;                    case 8:                      c = OpCodes.Ldc_I4_8;                      break;                    default:                      if (value >= -128 && value <= 127)                      {                          il.Emit(OpCodes.Ldc_I4_S' (sbyte)value);                      }                      else                      {                          il.Emit(OpCodes.Ldc_I4' value);                      }                      return;              }
Magic Number,System.Linq.Expressions.Compiler,ILGen,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitInt,The following statement contains a magic number: switch (value)              {                  case -1:                      c = OpCodes.Ldc_I4_M1;                      break;                    case 0:                      c = OpCodes.Ldc_I4_0;                      break;                    case 1:                      c = OpCodes.Ldc_I4_1;                      break;                    case 2:                      c = OpCodes.Ldc_I4_2;                      break;                    case 3:                      c = OpCodes.Ldc_I4_3;                      break;                    case 4:                      c = OpCodes.Ldc_I4_4;                      break;                    case 5:                      c = OpCodes.Ldc_I4_5;                      break;                    case 6:                      c = OpCodes.Ldc_I4_6;                      break;                    case 7:                      c = OpCodes.Ldc_I4_7;                      break;                    case 8:                      c = OpCodes.Ldc_I4_8;                      break;                    default:                      if (value >= -128 && value <= 127)                      {                          il.Emit(OpCodes.Ldc_I4_S' (sbyte)value);                      }                      else                      {                          il.Emit(OpCodes.Ldc_I4' value);                      }                      return;              }
Magic Number,System.Linq.Expressions.Compiler,ILGen,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitInt,The following statement contains a magic number: switch (value)              {                  case -1:                      c = OpCodes.Ldc_I4_M1;                      break;                    case 0:                      c = OpCodes.Ldc_I4_0;                      break;                    case 1:                      c = OpCodes.Ldc_I4_1;                      break;                    case 2:                      c = OpCodes.Ldc_I4_2;                      break;                    case 3:                      c = OpCodes.Ldc_I4_3;                      break;                    case 4:                      c = OpCodes.Ldc_I4_4;                      break;                    case 5:                      c = OpCodes.Ldc_I4_5;                      break;                    case 6:                      c = OpCodes.Ldc_I4_6;                      break;                    case 7:                      c = OpCodes.Ldc_I4_7;                      break;                    case 8:                      c = OpCodes.Ldc_I4_8;                      break;                    default:                      if (value >= -128 && value <= 127)                      {                          il.Emit(OpCodes.Ldc_I4_S' (sbyte)value);                      }                      else                      {                          il.Emit(OpCodes.Ldc_I4' value);                      }                      return;              }
Magic Number,System.Linq.Expressions.Compiler,ILGen,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitInt,The following statement contains a magic number: switch (value)              {                  case -1:                      c = OpCodes.Ldc_I4_M1;                      break;                    case 0:                      c = OpCodes.Ldc_I4_0;                      break;                    case 1:                      c = OpCodes.Ldc_I4_1;                      break;                    case 2:                      c = OpCodes.Ldc_I4_2;                      break;                    case 3:                      c = OpCodes.Ldc_I4_3;                      break;                    case 4:                      c = OpCodes.Ldc_I4_4;                      break;                    case 5:                      c = OpCodes.Ldc_I4_5;                      break;                    case 6:                      c = OpCodes.Ldc_I4_6;                      break;                    case 7:                      c = OpCodes.Ldc_I4_7;                      break;                    case 8:                      c = OpCodes.Ldc_I4_8;                      break;                    default:                      if (value >= -128 && value <= 127)                      {                          il.Emit(OpCodes.Ldc_I4_S' (sbyte)value);                      }                      else                      {                          il.Emit(OpCodes.Ldc_I4' value);                      }                      return;              }
Magic Number,System.Linq.Expressions.Compiler,ILGen,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitDecimalBits,The following statement contains a magic number: il.EmitInt(bits[2]);
Magic Number,System.Linq.Expressions.Compiler,ILGen,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitDecimalBits,The following statement contains a magic number: il.EmitBoolean((bits[3] & 0x80000000) != 0);
Magic Number,System.Linq.Expressions.Compiler,ILGen,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitDecimalBits,The following statement contains a magic number: il.EmitByte((byte)(bits[3] >> 16));
Magic Number,System.Linq.Expressions.Compiler,ILGen,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitDecimalBits,The following statement contains a magic number: il.EmitByte((byte)(bits[3] >> 16));
Magic Number,System.Linq.Expressions.Compiler,LambdaCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.net30.cs,LambdaCompiler,The following statement contains a magic number: var startIndex = _hasClosureArgument ? 2 : 1;
Magic Number,System.Linq.Expressions.Compiler,LambdaCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.net30.cs,FitsInBucket,The following statement contains a magic number: return (buckets.Count + count) * 2 > jumpTableSlots;
Magic Number,System.Linq.Expressions.Compiler,LambdaCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.net30.cs,MergeBuckets,The following statement contains a magic number: while (buckets.Count > 1)              {                  var first = buckets[buckets.Count - 2];                  var second = buckets[buckets.Count - 1];                    if (!FitsInBucket(first' second[second.Count - 1].Key' second.Count))                  {                      return;                  }                    // Merge them                  first.AddRange(second);                  buckets.RemoveAt(buckets.Count - 1);              }
Magic Number,System.Linq.Expressions.Compiler,LambdaCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.net30.cs,EmitSwitchBuckets,The following statement contains a magic number: var mid = (int)(((long)first + last + 1) / 2);
Magic Number,System.Linq.Expressions.Compiler,LambdaCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.net30.cs,TryEmitHashtableSwitch,The following statement contains a magic number: if (tests < 7)              {                  return false;              }
Magic Number,System.Linq.Expressions.Compiler,StackSpiller,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\StackSpiller.Bindings.net30.cs,RewriteIndexAssignment,The following statement contains a magic number: var cr = new ChildRewriter(this' stack' 2 + index.Arguments.Count);
Magic Number,System.Linq.Expressions.Compiler,StackSpiller,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\StackSpiller.Bindings.net30.cs,RewriteIndexAssignment,The following statement contains a magic number: if (cr.Rewrite)              {                  node = new AssignBinaryExpression(                      new IndexExpression(                          cr[0]'                              // Object                          index.Indexer'                          cr[1' -2]                           // arguments                      )'                      cr[-1]                                  // value                  );              }
Magic Number,System.Linq.Expressions.Compiler,StackSpiller,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\StackSpiller.Bindings.net30.cs,RewriteBinaryExpression,The following statement contains a magic number: var cr = new ChildRewriter(this' stack' 3);
Magic Number,System.Linq.Expressions.Compiler,StackSpiller,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\StackSpiller.Bindings.net30.cs,RewriteBinaryExpression,The following statement contains a magic number: return cr.Finish(cr.Rewrite ?                                      BinaryExpression.Create(                                              node.NodeType'                                              cr[0]'                                              cr[1]'                                              node.Type'                                              node.Method'                                              (LambdaExpression)cr[2]) :                                      expr);
Magic Number,System.Linq.Expressions.Compiler,StackSpiller,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\StackSpiller.Bindings.net30.cs,RewriteMemberAssignment,The following statement contains a magic number: var cr = new ChildRewriter(this' stack' 2);
Magic Number,System.Linq.Expressions.Compiler,StackSpiller,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\StackSpiller.Bindings.net30.cs,RewriteListInitExpression,The following statement contains a magic number: switch (action)              {                  case RewriteAction.None:                      break;                    case RewriteAction.Copy:                      var newInits = new ElementInit[inits.Count];                      for (var i = 0; i < inits.Count; i++)                      {                          var cr = cloneCrs[i];                          if (cr.Action == RewriteAction.None)                          {                              newInits[i] = inits[i];                          }                          else                          {                              newInits[i] = Expression.ElementInit(inits[i].AddMethod' cr[0' -1]);                          }                      }                      expr = Expression.ListInit((NewExpression)rewrittenNew' new TrueReadOnlyCollection<ElementInit>(newInits));                      break;                    case RewriteAction.SpillStack:                      RequireNotRefInstance(node.NewExpression);                        var tempNew = MakeTemp(rewrittenNew.Type);                      var comma = new Expression[inits.Count + 2];                      comma[0] = Expression.Assign(tempNew' rewrittenNew);                        for (var i = 0; i < inits.Count; i++)                      {                          var cr = cloneCrs[i];                          var add = cr.Finish(Expression.Call(tempNew' inits[i].AddMethod' cr[0' -1]));                          comma[i + 1] = add.Node;                      }                      comma[inits.Count + 1] = tempNew;                      expr = MakeBlock(comma);                      break;                    default:                      throw ContractUtils.Unreachable;              }
Magic Number,System.Linq.Expressions.Compiler,StackSpiller,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\StackSpiller.Bindings.net30.cs,RewriteMemberInitExpression,The following statement contains a magic number: switch (action)              {                  case RewriteAction.None:                      break;                    case RewriteAction.Copy:                      var newBindings = new MemberBinding[bindings.Count];                      for (var i = 0; i < bindings.Count; i++)                      {                          newBindings[i] = bindingRewriters[i].AsBinding();                      }                      expr = Expression.MemberInit((NewExpression)rewrittenNew' new TrueReadOnlyCollection<MemberBinding>(newBindings));                      break;                    case RewriteAction.SpillStack:                      RequireNotRefInstance(node.NewExpression);                        var tempNew = MakeTemp(rewrittenNew.Type);                      var comma = new Expression[bindings.Count + 2];                      comma[0] = Expression.Assign(tempNew' rewrittenNew);                      for (var i = 0; i < bindings.Count; i++)                      {                          var cr = bindingRewriters[i];                          var initExpr = cr.AsExpression(tempNew);                          comma[i + 1] = initExpr;                      }                      comma[bindings.Count + 1] = tempNew;                      expr = MakeBlock(comma);                      break;                    default:                      throw ContractUtils.Unreachable;              }
Magic Number,System.Linq.Expressions.Compiler,MemberMemberBindingRewriter,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\StackSpiller.Bindings.net30.cs,AsExpression,The following statement contains a magic number: var block = new Expression[_bindings.Count + 2];
Magic Number,System.Linq.Expressions.Compiler,ListBindingRewriter,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\StackSpiller.Bindings.net30.cs,AsExpression,The following statement contains a magic number: var block = new Expression[_inits.Count + 2];
Magic Number,System.Linq.Expressions.Interpreter,AddInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,AddInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = ScriptingRuntimeHelpers.Int32ToObject(unchecked((int)l + (int)r));                  }
Magic Number,System.Linq.Expressions.Interpreter,AddInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = ScriptingRuntimeHelpers.Int32ToObject(unchecked((int)l + (int)r));                  }
Magic Number,System.Linq.Expressions.Interpreter,AddInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,AddInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (short)unchecked((short)l + (short)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,AddInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (short)unchecked((short)l + (short)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,AddInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,AddInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = unchecked((long)l + (long)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,AddInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = unchecked((long)l + (long)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,AddUInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,AddUInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (ushort)unchecked((ushort)l + (ushort)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,AddUInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (ushort)unchecked((ushort)l + (ushort)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,AddUInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,AddUInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = unchecked((uint)l + (uint)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,AddUInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = unchecked((uint)l + (uint)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,AddUInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,AddUInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = unchecked((ulong)l + (ulong)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,AddUInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = unchecked((ulong)l + (ulong)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,AddSingle,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,AddSingle,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (float)l + (float)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,AddSingle,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (float)l + (float)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,AddDouble,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,AddDouble,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (double)l + (double)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,AddDouble,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (double)l + (double)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,AddOvfInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,AddOvfInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = ScriptingRuntimeHelpers.Int32ToObject(checked((int)l + (int)r));                  }
Magic Number,System.Linq.Expressions.Interpreter,AddOvfInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = ScriptingRuntimeHelpers.Int32ToObject(checked((int)l + (int)r));                  }
Magic Number,System.Linq.Expressions.Interpreter,AddOvfInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,AddOvfInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (short)checked((short)l + (short)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,AddOvfInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (short)checked((short)l + (short)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,AddOvfInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,AddOvfInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = checked((long)l + (long)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,AddOvfInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = checked((long)l + (long)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,AddOvfUInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,AddOvfUInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (ushort)checked((ushort)l + (ushort)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,AddOvfUInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (ushort)checked((ushort)l + (ushort)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,AddOvfUInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,AddOvfUInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = checked((uint)l + (uint)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,AddOvfUInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = checked((uint)l + (uint)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,AddOvfUInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,AddOvfUInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (ulong)checked((short)l + (short)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,AddOvfUInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (ulong)checked((short)l + (short)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,AddOvfSingle,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,AddOvfSingle,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (float)l + (float)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,AddOvfSingle,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (float)l + (float)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,AddOvfDouble,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,AddOvfDouble,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (double)l + (double)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,AddOvfDouble,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\AddInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (double)l + (double)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,InvokeInstance,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke(instance);                    case 1:                      return Invoke(instance' args[0]);                    case 2:                      return Invoke(instance' args[0]' args[1]);                    case 3:                      return Invoke(instance' args[0]' args[1]' args[2]);                    case 4:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,InvokeInstance,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke(instance);                    case 1:                      return Invoke(instance' args[0]);                    case 2:                      return Invoke(instance' args[0]' args[1]);                    case 3:                      return Invoke(instance' args[0]' args[1]' args[2]);                    case 4:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,InvokeInstance,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke(instance);                    case 1:                      return Invoke(instance' args[0]);                    case 2:                      return Invoke(instance' args[0]' args[1]);                    case 3:                      return Invoke(instance' args[0]' args[1]' args[2]);                    case 4:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,InvokeInstance,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke(instance);                    case 1:                      return Invoke(instance' args[0]);                    case 2:                      return Invoke(instance' args[0]' args[1]);                    case 3:                      return Invoke(instance' args[0]' args[1]' args[2]);                    case 4:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,InvokeInstance,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke(instance);                    case 1:                      return Invoke(instance' args[0]);                    case 2:                      return Invoke(instance' args[0]' args[1]);                    case 3:                      return Invoke(instance' args[0]' args[1]' args[2]);                    case 4:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,InvokeInstance,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke(instance);                    case 1:                      return Invoke(instance' args[0]);                    case 2:                      return Invoke(instance' args[0]' args[1]);                    case 3:                      return Invoke(instance' args[0]' args[1]' args[2]);                    case 4:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,InvokeInstance,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke(instance);                    case 1:                      return Invoke(instance' args[0]);                    case 2:                      return Invoke(instance' args[0]' args[1]);                    case 3:                      return Invoke(instance' args[0]' args[1]' args[2]);                    case 4:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,InvokeInstance,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke(instance);                    case 1:                      return Invoke(instance' args[0]);                    case 2:                      return Invoke(instance' args[0]' args[1]);                    case 3:                      return Invoke(instance' args[0]' args[1]' args[2]);                    case 4:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,InvokeInstance,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke(instance);                    case 1:                      return Invoke(instance' args[0]);                    case 2:                      return Invoke(instance' args[0]' args[1]);                    case 3:                      return Invoke(instance' args[0]' args[1]' args[2]);                    case 4:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,InvokeInstance,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke(instance);                    case 1:                      return Invoke(instance' args[0]);                    case 2:                      return Invoke(instance' args[0]' args[1]);                    case 3:                      return Invoke(instance' args[0]' args[1]' args[2]);                    case 4:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,InvokeInstance,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke(instance);                    case 1:                      return Invoke(instance' args[0]);                    case 2:                      return Invoke(instance' args[0]' args[1]);                    case 3:                      return Invoke(instance' args[0]' args[1]' args[2]);                    case 4:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,InvokeInstance,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke(instance);                    case 1:                      return Invoke(instance' args[0]);                    case 2:                      return Invoke(instance' args[0]' args[1]);                    case 3:                      return Invoke(instance' args[0]' args[1]' args[2]);                    case 4:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,InvokeInstance,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke(instance);                    case 1:                      return Invoke(instance' args[0]);                    case 2:                      return Invoke(instance' args[0]' args[1]);                    case 3:                      return Invoke(instance' args[0]' args[1]' args[2]);                    case 4:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,InvokeInstance,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke(instance);                    case 1:                      return Invoke(instance' args[0]);                    case 2:                      return Invoke(instance' args[0]' args[1]);                    case 3:                      return Invoke(instance' args[0]' args[1]' args[2]);                    case 4:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,InvokeInstance,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke(instance);                    case 1:                      return Invoke(instance' args[0]);                    case 2:                      return Invoke(instance' args[0]' args[1]);                    case 3:                      return Invoke(instance' args[0]' args[1]' args[2]);                    case 4:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,InvokeInstance,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke(instance);                    case 1:                      return Invoke(instance' args[0]);                    case 2:                      return Invoke(instance' args[0]' args[1]);                    case 3:                      return Invoke(instance' args[0]' args[1]' args[2]);                    case 4:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,InvokeInstance,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke(instance);                    case 1:                      return Invoke(instance' args[0]);                    case 2:                      return Invoke(instance' args[0]' args[1]);                    case 3:                      return Invoke(instance' args[0]' args[1]' args[2]);                    case 4:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,InvokeInstance,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke(instance);                    case 1:                      return Invoke(instance' args[0]);                    case 2:                      return Invoke(instance' args[0]' args[1]);                    case 3:                      return Invoke(instance' args[0]' args[1]' args[2]);                    case 4:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,InvokeInstance,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke(instance);                    case 1:                      return Invoke(instance' args[0]);                    case 2:                      return Invoke(instance' args[0]' args[1]);                    case 3:                      return Invoke(instance' args[0]' args[1]' args[2]);                    case 4:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,InvokeInstance,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke(instance);                    case 1:                      return Invoke(instance' args[0]);                    case 2:                      return Invoke(instance' args[0]' args[1]);                    case 3:                      return Invoke(instance' args[0]' args[1]' args[2]);                    case 4:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,InvokeInstance,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke(instance);                    case 1:                      return Invoke(instance' args[0]);                    case 2:                      return Invoke(instance' args[0]' args[1]);                    case 3:                      return Invoke(instance' args[0]' args[1]' args[2]);                    case 4:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,InvokeInstance,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke(instance);                    case 1:                      return Invoke(instance' args[0]);                    case 2:                      return Invoke(instance' args[0]' args[1]);                    case 3:                      return Invoke(instance' args[0]' args[1]' args[2]);                    case 4:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,InvokeInstance,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke(instance);                    case 1:                      return Invoke(instance' args[0]);                    case 2:                      return Invoke(instance' args[0]' args[1]);                    case 3:                      return Invoke(instance' args[0]' args[1]' args[2]);                    case 4:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,InvokeInstance,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke(instance);                    case 1:                      return Invoke(instance' args[0]);                    case 2:                      return Invoke(instance' args[0]' args[1]);                    case 3:                      return Invoke(instance' args[0]' args[1]' args[2]);                    case 4:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,InvokeInstance,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke(instance);                    case 1:                      return Invoke(instance' args[0]);                    case 2:                      return Invoke(instance' args[0]' args[1]);                    case 3:                      return Invoke(instance' args[0]' args[1]' args[2]);                    case 4:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,InvokeInstance,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke(instance);                    case 1:                      return Invoke(instance' args[0]);                    case 2:                      return Invoke(instance' args[0]' args[1]);                    case 3:                      return Invoke(instance' args[0]' args[1]' args[2]);                    case 4:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,InvokeInstance,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke(instance);                    case 1:                      return Invoke(instance' args[0]);                    case 2:                      return Invoke(instance' args[0]' args[1]);                    case 3:                      return Invoke(instance' args[0]' args[1]' args[2]);                    case 4:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,InvokeInstance,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke(instance);                    case 1:                      return Invoke(instance' args[0]);                    case 2:                      return Invoke(instance' args[0]' args[1]);                    case 3:                      return Invoke(instance' args[0]' args[1]' args[2]);                    case 4:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(instance' args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke();                    case 1:                      return Invoke(args[0]);                    case 2:                      return Invoke(args[0]' args[1]);                    case 3:                      return Invoke(args[0]' args[1]' args[2]);                    case 4:                      return Invoke(args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    case 9:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]' args[8]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke();                    case 1:                      return Invoke(args[0]);                    case 2:                      return Invoke(args[0]' args[1]);                    case 3:                      return Invoke(args[0]' args[1]' args[2]);                    case 4:                      return Invoke(args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    case 9:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]' args[8]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke();                    case 1:                      return Invoke(args[0]);                    case 2:                      return Invoke(args[0]' args[1]);                    case 3:                      return Invoke(args[0]' args[1]' args[2]);                    case 4:                      return Invoke(args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    case 9:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]' args[8]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke();                    case 1:                      return Invoke(args[0]);                    case 2:                      return Invoke(args[0]' args[1]);                    case 3:                      return Invoke(args[0]' args[1]' args[2]);                    case 4:                      return Invoke(args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    case 9:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]' args[8]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke();                    case 1:                      return Invoke(args[0]);                    case 2:                      return Invoke(args[0]' args[1]);                    case 3:                      return Invoke(args[0]' args[1]' args[2]);                    case 4:                      return Invoke(args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    case 9:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]' args[8]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke();                    case 1:                      return Invoke(args[0]);                    case 2:                      return Invoke(args[0]' args[1]);                    case 3:                      return Invoke(args[0]' args[1]' args[2]);                    case 4:                      return Invoke(args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    case 9:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]' args[8]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke();                    case 1:                      return Invoke(args[0]);                    case 2:                      return Invoke(args[0]' args[1]);                    case 3:                      return Invoke(args[0]' args[1]' args[2]);                    case 4:                      return Invoke(args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    case 9:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]' args[8]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke();                    case 1:                      return Invoke(args[0]);                    case 2:                      return Invoke(args[0]' args[1]);                    case 3:                      return Invoke(args[0]' args[1]' args[2]);                    case 4:                      return Invoke(args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    case 9:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]' args[8]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke();                    case 1:                      return Invoke(args[0]);                    case 2:                      return Invoke(args[0]' args[1]);                    case 3:                      return Invoke(args[0]' args[1]' args[2]);                    case 4:                      return Invoke(args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    case 9:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]' args[8]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke();                    case 1:                      return Invoke(args[0]);                    case 2:                      return Invoke(args[0]' args[1]);                    case 3:                      return Invoke(args[0]' args[1]' args[2]);                    case 4:                      return Invoke(args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    case 9:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]' args[8]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke();                    case 1:                      return Invoke(args[0]);                    case 2:                      return Invoke(args[0]' args[1]);                    case 3:                      return Invoke(args[0]' args[1]' args[2]);                    case 4:                      return Invoke(args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    case 9:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]' args[8]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke();                    case 1:                      return Invoke(args[0]);                    case 2:                      return Invoke(args[0]' args[1]);                    case 3:                      return Invoke(args[0]' args[1]' args[2]);                    case 4:                      return Invoke(args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    case 9:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]' args[8]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke();                    case 1:                      return Invoke(args[0]);                    case 2:                      return Invoke(args[0]' args[1]);                    case 3:                      return Invoke(args[0]' args[1]' args[2]);                    case 4:                      return Invoke(args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    case 9:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]' args[8]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke();                    case 1:                      return Invoke(args[0]);                    case 2:                      return Invoke(args[0]' args[1]);                    case 3:                      return Invoke(args[0]' args[1]' args[2]);                    case 4:                      return Invoke(args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    case 9:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]' args[8]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke();                    case 1:                      return Invoke(args[0]);                    case 2:                      return Invoke(args[0]' args[1]);                    case 3:                      return Invoke(args[0]' args[1]' args[2]);                    case 4:                      return Invoke(args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    case 9:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]' args[8]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke();                    case 1:                      return Invoke(args[0]);                    case 2:                      return Invoke(args[0]' args[1]);                    case 3:                      return Invoke(args[0]' args[1]' args[2]);                    case 4:                      return Invoke(args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    case 9:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]' args[8]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke();                    case 1:                      return Invoke(args[0]);                    case 2:                      return Invoke(args[0]' args[1]);                    case 3:                      return Invoke(args[0]' args[1]' args[2]);                    case 4:                      return Invoke(args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    case 9:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]' args[8]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke();                    case 1:                      return Invoke(args[0]);                    case 2:                      return Invoke(args[0]' args[1]);                    case 3:                      return Invoke(args[0]' args[1]' args[2]);                    case 4:                      return Invoke(args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    case 9:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]' args[8]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke();                    case 1:                      return Invoke(args[0]);                    case 2:                      return Invoke(args[0]' args[1]);                    case 3:                      return Invoke(args[0]' args[1]' args[2]);                    case 4:                      return Invoke(args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    case 9:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]' args[8]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke();                    case 1:                      return Invoke(args[0]);                    case 2:                      return Invoke(args[0]' args[1]);                    case 3:                      return Invoke(args[0]' args[1]' args[2]);                    case 4:                      return Invoke(args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    case 9:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]' args[8]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke();                    case 1:                      return Invoke(args[0]);                    case 2:                      return Invoke(args[0]' args[1]);                    case 3:                      return Invoke(args[0]' args[1]' args[2]);                    case 4:                      return Invoke(args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    case 9:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]' args[8]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke();                    case 1:                      return Invoke(args[0]);                    case 2:                      return Invoke(args[0]' args[1]);                    case 3:                      return Invoke(args[0]' args[1]' args[2]);                    case 4:                      return Invoke(args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    case 9:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]' args[8]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke();                    case 1:                      return Invoke(args[0]);                    case 2:                      return Invoke(args[0]' args[1]);                    case 3:                      return Invoke(args[0]' args[1]' args[2]);                    case 4:                      return Invoke(args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    case 9:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]' args[8]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke();                    case 1:                      return Invoke(args[0]);                    case 2:                      return Invoke(args[0]' args[1]);                    case 3:                      return Invoke(args[0]' args[1]' args[2]);                    case 4:                      return Invoke(args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    case 9:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]' args[8]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke();                    case 1:                      return Invoke(args[0]);                    case 2:                      return Invoke(args[0]' args[1]);                    case 3:                      return Invoke(args[0]' args[1]' args[2]);                    case 4:                      return Invoke(args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    case 9:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]' args[8]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke();                    case 1:                      return Invoke(args[0]);                    case 2:                      return Invoke(args[0]' args[1]);                    case 3:                      return Invoke(args[0]' args[1]' args[2]);                    case 4:                      return Invoke(args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    case 9:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]' args[8]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke();                    case 1:                      return Invoke(args[0]);                    case 2:                      return Invoke(args[0]' args[1]);                    case 3:                      return Invoke(args[0]' args[1]' args[2]);                    case 4:                      return Invoke(args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    case 9:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]' args[8]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke();                    case 1:                      return Invoke(args[0]);                    case 2:                      return Invoke(args[0]' args[1]);                    case 3:                      return Invoke(args[0]' args[1]' args[2]);                    case 4:                      return Invoke(args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    case 9:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]' args[8]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke();                    case 1:                      return Invoke(args[0]);                    case 2:                      return Invoke(args[0]' args[1]);                    case 3:                      return Invoke(args[0]' args[1]' args[2]);                    case 4:                      return Invoke(args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    case 9:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]' args[8]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke();                    case 1:                      return Invoke(args[0]);                    case 2:                      return Invoke(args[0]' args[1]);                    case 3:                      return Invoke(args[0]' args[1]' args[2]);                    case 4:                      return Invoke(args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    case 9:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]' args[8]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke();                    case 1:                      return Invoke(args[0]);                    case 2:                      return Invoke(args[0]' args[1]);                    case 3:                      return Invoke(args[0]' args[1]' args[2]);                    case 4:                      return Invoke(args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    case 9:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]' args[8]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke();                    case 1:                      return Invoke(args[0]);                    case 2:                      return Invoke(args[0]' args[1]);                    case 3:                      return Invoke(args[0]' args[1]' args[2]);                    case 4:                      return Invoke(args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    case 9:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]' args[8]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke();                    case 1:                      return Invoke(args[0]);                    case 2:                      return Invoke(args[0]' args[1]);                    case 3:                      return Invoke(args[0]' args[1]' args[2]);                    case 4:                      return Invoke(args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    case 9:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]' args[8]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke();                    case 1:                      return Invoke(args[0]);                    case 2:                      return Invoke(args[0]' args[1]);                    case 3:                      return Invoke(args[0]' args[1]' args[2]);                    case 4:                      return Invoke(args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    case 9:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]' args[8]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke();                    case 1:                      return Invoke(args[0]);                    case 2:                      return Invoke(args[0]' args[1]);                    case 3:                      return Invoke(args[0]' args[1]' args[2]);                    case 4:                      return Invoke(args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    case 9:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]' args[8]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Invoke,The following statement contains a magic number: switch (args.Length)              {                  case 0:                      return Invoke();                    case 1:                      return Invoke(args[0]);                    case 2:                      return Invoke(args[0]' args[1]);                    case 3:                      return Invoke(args[0]' args[1]' args[2]);                    case 4:                      return Invoke(args[0]' args[1]' args[2]' args[3]);                    case 5:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]);                    case 6:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]);                    case 7:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]);                    case 8:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]);                    case 9:                      return Invoke(args[0]' args[1]' args[2]' args[3]' args[4]' args[5]' args[6]' args[7]' args[8]);                    default:                      throw new InvalidOperationException();              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,GetHelperType,The following statement contains a magic number: if (info.ReturnType == typeof(void))              {                  switch (arrTypes.Length)                  {                      case 0:                          t = typeof(ActionCallInstruction);                          break;                        case 1:                          t = typeof(ActionCallInstruction<>).MakeGenericType(arrTypes);                          break;                        case 2:                          t = typeof(ActionCallInstruction<'>).MakeGenericType(arrTypes);                          break;                        default:                          throw new InvalidOperationException();                  }              }              else              {                  switch (arrTypes.Length)                  {                      case 1:                          t = typeof(FuncCallInstruction<>).MakeGenericType(arrTypes);                          break;                        case 2:                          t = typeof(FuncCallInstruction<'>).MakeGenericType(arrTypes);                          break;                        case 3:                          t = typeof(FuncCallInstruction<''>).MakeGenericType(arrTypes);                          break;                        default:                          throw new InvalidOperationException();                  }              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,GetHelperType,The following statement contains a magic number: if (info.ReturnType == typeof(void))              {                  switch (arrTypes.Length)                  {                      case 0:                          t = typeof(ActionCallInstruction);                          break;                        case 1:                          t = typeof(ActionCallInstruction<>).MakeGenericType(arrTypes);                          break;                        case 2:                          t = typeof(ActionCallInstruction<'>).MakeGenericType(arrTypes);                          break;                        default:                          throw new InvalidOperationException();                  }              }              else              {                  switch (arrTypes.Length)                  {                      case 1:                          t = typeof(FuncCallInstruction<>).MakeGenericType(arrTypes);                          break;                        case 2:                          t = typeof(FuncCallInstruction<'>).MakeGenericType(arrTypes);                          break;                        case 3:                          t = typeof(FuncCallInstruction<''>).MakeGenericType(arrTypes);                          break;                        default:                          throw new InvalidOperationException();                  }              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,GetHelperType,The following statement contains a magic number: if (info.ReturnType == typeof(void))              {                  switch (arrTypes.Length)                  {                      case 0:                          t = typeof(ActionCallInstruction);                          break;                        case 1:                          t = typeof(ActionCallInstruction<>).MakeGenericType(arrTypes);                          break;                        case 2:                          t = typeof(ActionCallInstruction<'>).MakeGenericType(arrTypes);                          break;                        default:                          throw new InvalidOperationException();                  }              }              else              {                  switch (arrTypes.Length)                  {                      case 1:                          t = typeof(FuncCallInstruction<>).MakeGenericType(arrTypes);                          break;                        case 2:                          t = typeof(FuncCallInstruction<'>).MakeGenericType(arrTypes);                          break;                        case 3:                          t = typeof(FuncCallInstruction<''>).MakeGenericType(arrTypes);                          break;                        default:                          throw new InvalidOperationException();                  }              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,GetArrayAccessor,The following statement contains a magic number: switch (arrayType.GetArrayRank())              {                  case 1:                      alternativeMethod = isGetter ?                          arrayType.GetMethod("GetValue"' new[] { typeof(int) }) :                          typeof(CallInstruction).GetMethod("ArrayItemSetter1");                      break;                    case 2:                      alternativeMethod = isGetter ?                          arrayType.GetMethod("GetValue"' new[] { typeof(int)' typeof(int) }) :                          typeof(CallInstruction).GetMethod("ArrayItemSetter2");                      break;                    case 3:                      alternativeMethod = isGetter ?                          arrayType.GetMethod("GetValue"' new[] { typeof(int)' typeof(int)' typeof(int) }) :                          typeof(CallInstruction).GetMethod("ArrayItemSetter3");                      break;              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,GetArrayAccessor,The following statement contains a magic number: switch (arrayType.GetArrayRank())              {                  case 1:                      alternativeMethod = isGetter ?                          arrayType.GetMethod("GetValue"' new[] { typeof(int) }) :                          typeof(CallInstruction).GetMethod("ArrayItemSetter1");                      break;                    case 2:                      alternativeMethod = isGetter ?                          arrayType.GetMethod("GetValue"' new[] { typeof(int)' typeof(int) }) :                          typeof(CallInstruction).GetMethod("ArrayItemSetter2");                      break;                    case 3:                      alternativeMethod = isGetter ?                          arrayType.GetMethod("GetValue"' new[] { typeof(int)' typeof(int)' typeof(int) }) :                          typeof(CallInstruction).GetMethod("ArrayItemSetter3");                      break;              }
Magic Number,System.Linq.Expressions.Interpreter,ActionCallInstruction<T0;T1>,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Run,The following statement contains a magic number: _target((T0)frame.Data[frame.StackIndex - 2]' (T1)frame.Data[frame.StackIndex - 1]);
Magic Number,System.Linq.Expressions.Interpreter,ActionCallInstruction<T0;T1>,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Run,The following statement contains a magic number: frame.StackIndex -= 2;
Magic Number,System.Linq.Expressions.Interpreter,FuncCallInstruction<T0;T1;TRet>,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Run,The following statement contains a magic number: frame.Data[frame.StackIndex - 2] = _target((T0)frame.Data[frame.StackIndex - 2]' (T1)frame.Data[frame.StackIndex - 1]);
Magic Number,System.Linq.Expressions.Interpreter,FuncCallInstruction<T0;T1;TRet>,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,Run,The following statement contains a magic number: frame.Data[frame.StackIndex - 2] = _target((T0)frame.Data[frame.StackIndex - 2]' (T1)frame.Data[frame.StackIndex - 1]);
Magic Number,System.Linq.Expressions.Interpreter,GotoInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\ControlFlowInstructions.net30.cs,Create,The following statement contains a magic number: if (labelIndex < CacheSize)              {                  var index = _variants * labelIndex | (labelTargetGetsValue ? 4 : 0) | (hasResult ? 2 : 0) | (hasValue ? 1 : 0);                  return _cache[index] ?? (_cache[index] = new GotoInstruction(labelIndex' hasResult' hasValue' labelTargetGetsValue));              }
Magic Number,System.Linq.Expressions.Interpreter,GotoInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\ControlFlowInstructions.net30.cs,Create,The following statement contains a magic number: if (labelIndex < CacheSize)              {                  var index = _variants * labelIndex | (labelTargetGetsValue ? 4 : 0) | (hasResult ? 2 : 0) | (hasValue ? 1 : 0);                  return _cache[index] ?? (_cache[index] = new GotoInstruction(labelIndex' hasResult' hasValue' labelTargetGetsValue));              }
Magic Number,System.Linq.Expressions.Interpreter,LeaveExceptionHandlerInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\ControlFlowInstructions.net30.cs,Create,The following statement contains a magic number: if (labelIndex < CacheSize)              {                  var index = (2 * labelIndex) | (hasValue ? 1 : 0);                  return _cache[index] ?? (_cache[index] = new LeaveExceptionHandlerInstruction(labelIndex' hasValue));              }
Magic Number,System.Linq.Expressions.Interpreter,DivInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,DivInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = ScriptingRuntimeHelpers.Int32ToObject((int)l / (int)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,DivInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = ScriptingRuntimeHelpers.Int32ToObject((int)l / (int)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,DivInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,DivInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (short)((short)l / (short)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,DivInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (short)((short)l / (short)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,DivInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,DivInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (long)l / (long)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,DivInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (long)l / (long)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,DivUInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,DivUInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (ushort)((ushort)l / (ushort)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,DivUInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (ushort)((ushort)l / (ushort)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,DivUInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,DivUInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (uint)l / (uint)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,DivUInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (uint)l / (uint)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,DivUInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,DivUInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (ulong)l / (ulong)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,DivUInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (ulong)l / (ulong)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,DivSingle,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,DivSingle,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (float)l / (float)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,DivSingle,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (float)l / (float)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,DivDouble,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,DivDouble,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (double)l / (double)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,DivDouble,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (double)l / (double)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,ModuloInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,ModuloInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = ScriptingRuntimeHelpers.Int32ToObject((int)l % (int)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,ModuloInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = ScriptingRuntimeHelpers.Int32ToObject((int)l % (int)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,ModuloInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,ModuloInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (short)((short)l % (short)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,ModuloInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (short)((short)l % (short)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,ModuloInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,ModuloInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (long)l % (long)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,ModuloInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (long)l % (long)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,ModuloUInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,ModuloUInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (ushort)((ushort)l % (ushort)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,ModuloUInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (ushort)((ushort)l % (ushort)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,ModuloUInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,ModuloUInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (uint)l % (uint)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,ModuloUInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (uint)l % (uint)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,ModuloUInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,ModuloUInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (ulong)l % (ulong)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,ModuloUInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (ulong)l % (ulong)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,ModuloSingle,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,ModuloSingle,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (float)l % (float)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,ModuloSingle,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (float)l % (float)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,ModuloDouble,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,ModuloDouble,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (double)l % (double)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,ModuloDouble,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\DivInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (double)l % (double)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,MulInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,MulInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = ScriptingRuntimeHelpers.Int32ToObject(unchecked((int)l * (int)r));                  }
Magic Number,System.Linq.Expressions.Interpreter,MulInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = ScriptingRuntimeHelpers.Int32ToObject(unchecked((int)l * (int)r));                  }
Magic Number,System.Linq.Expressions.Interpreter,MulInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,MulInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (short)unchecked((short)l * (short)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,MulInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (short)unchecked((short)l * (short)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,MulInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,MulInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = unchecked((long)l * (long)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,MulInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = unchecked((long)l * (long)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,MulUInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,MulUInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (ushort)unchecked((ushort)l * (ushort)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,MulUInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (ushort)unchecked((ushort)l * (ushort)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,MulUInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,MulUInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = unchecked((uint)l * (uint)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,MulUInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = unchecked((uint)l * (uint)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,MulUInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,MulUInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = unchecked((ulong)l * (ulong)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,MulUInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = unchecked((ulong)l * (ulong)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,MulSingle,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,MulSingle,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (float)l * (float)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,MulSingle,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (float)l * (float)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,MulDouble,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,MulDouble,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (double)l * (double)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,MulDouble,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (double)l * (double)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,MulOvfInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,MulOvfInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = ScriptingRuntimeHelpers.Int32ToObject(checked((int)l * (int)r));                  }
Magic Number,System.Linq.Expressions.Interpreter,MulOvfInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = ScriptingRuntimeHelpers.Int32ToObject(checked((int)l * (int)r));                  }
Magic Number,System.Linq.Expressions.Interpreter,MulOvfInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,MulOvfInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (short)checked((short)l * (short)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,MulOvfInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (short)checked((short)l * (short)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,MulOvfInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,MulOvfInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = checked((long)l * (long)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,MulOvfInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = checked((long)l * (long)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,MulOvfUInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,MulOvfUInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (ushort)checked((ushort)l * (ushort)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,MulOvfUInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (ushort)checked((ushort)l * (ushort)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,MulOvfUInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,MulOvfUInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = checked((uint)l * (uint)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,MulOvfUInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = checked((uint)l * (uint)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,MulOvfUInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,MulOvfUInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = checked((ulong)l * (ulong)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,MulOvfUInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = checked((ulong)l * (ulong)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,MulOvfSingle,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,MulOvfSingle,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (float)l * (float)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,MulOvfSingle,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (float)l * (float)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,MulOvfDouble,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,MulOvfDouble,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (double)l * (double)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,MulOvfDouble,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\MulInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (double)l * (double)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,SubInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,SubInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = ScriptingRuntimeHelpers.Int32ToObject(unchecked((int)l - (int)r));                  }
Magic Number,System.Linq.Expressions.Interpreter,SubInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = ScriptingRuntimeHelpers.Int32ToObject(unchecked((int)l - (int)r));                  }
Magic Number,System.Linq.Expressions.Interpreter,SubInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,SubInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (short)unchecked((short)l - (short)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,SubInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (short)unchecked((short)l - (short)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,SubInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,SubInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = unchecked((long)l - (long)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,SubInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = unchecked((long)l - (long)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,SubUInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,SubUInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (ushort)unchecked((ushort)l - (ushort)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,SubUInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (ushort)unchecked((ushort)l - (ushort)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,SubUInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,SubUInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = unchecked((uint)l - (uint)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,SubUInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = unchecked((uint)l - (uint)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,SubUInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,SubUInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = unchecked((ulong)l - (ulong)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,SubUInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = unchecked((ulong)l - (ulong)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,SubSingle,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,SubSingle,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (float)l - (float)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,SubSingle,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (float)l - (float)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,SubDouble,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,SubDouble,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (double)l - (double)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,SubDouble,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (double)l - (double)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,SubOvfInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,SubOvfInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = ScriptingRuntimeHelpers.Int32ToObject(checked((int)l - (int)r));                  }
Magic Number,System.Linq.Expressions.Interpreter,SubOvfInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = ScriptingRuntimeHelpers.Int32ToObject(checked((int)l - (int)r));                  }
Magic Number,System.Linq.Expressions.Interpreter,SubOvfInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,SubOvfInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (short)checked((short)l - (short)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,SubOvfInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (short)checked((short)l - (short)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,SubOvfInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,SubOvfInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = checked((long)l - (long)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,SubOvfInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = checked((long)l - (long)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,SubOvfUInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,SubOvfUInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (ushort)checked((ushort)l - (ushort)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,SubOvfUInt16,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (ushort)checked((ushort)l - (ushort)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,SubOvfUInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,SubOvfUInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = checked((uint)l - (uint)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,SubOvfUInt32,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = checked((uint)l - (uint)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,SubOvfUInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,SubOvfUInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (ulong)checked((short)l - (short)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,SubOvfUInt64,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (ulong)checked((short)l - (short)r);                  }
Magic Number,System.Linq.Expressions.Interpreter,SubOvfSingle,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,SubOvfSingle,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (float)l - (float)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,SubOvfSingle,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (float)l - (float)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,SubOvfDouble,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: var l = frame.Data[frame.StackIndex - 2];
Magic Number,System.Linq.Expressions.Interpreter,SubOvfDouble,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (double)l - (double)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,SubOvfDouble,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\SubInstruction.net30.cs,Run,The following statement contains a magic number: if (l == null || r == null)                  {                      frame.Data[frame.StackIndex - 2] = null;                  }                  else                  {                      frame.Data[frame.StackIndex - 2] = (double)l - (double)r;                  }
Magic Number,System.Linq.Expressions.Interpreter,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\Utilities.net30.cs,MakeDelegate,The following statement contains a magic number: if (returnType == typeof(void))              {                  Array.Resize(ref types' types.Length - 1);                  switch (types.Length)                  {                      case 0:                          return typeof(Action);                        case 1:                          return typeof(Action<>).MakeGenericType(types);                        case 2:                          return typeof(Action<'>).MakeGenericType(types);                        case 3:                          return typeof(Action<''>).MakeGenericType(types);                        case 4:                          return typeof(Action<'''>).MakeGenericType(types);                        case 5:                          return typeof(Action<''''>).MakeGenericType(types);                        case 6:                          return typeof(Action<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Action<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Action<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Action<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Action<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Action<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Action<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Action<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Action<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Action<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Action<'''''''''''''''>).MakeGenericType(types);                  }              }              else              {                  switch (types.Length)                  {                      case 1:                          return typeof(Func<>).MakeGenericType(types);                        case 2:                          return typeof(Func<'>).MakeGenericType(types);                        case 3:                          return typeof(Func<''>).MakeGenericType(types);                        case 4:                          return typeof(Func<'''>).MakeGenericType(types);                        case 5:                          return typeof(Func<''''>).MakeGenericType(types);                        case 6:                          return typeof(Func<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Func<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Func<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Func<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Func<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Func<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Func<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Func<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Func<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Func<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Func<'''''''''''''''>).MakeGenericType(types);                        case 17:                          return typeof(Func<''''''''''''''''>).MakeGenericType(types);                  }              }
Magic Number,System.Linq.Expressions.Interpreter,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\Utilities.net30.cs,MakeDelegate,The following statement contains a magic number: if (returnType == typeof(void))              {                  Array.Resize(ref types' types.Length - 1);                  switch (types.Length)                  {                      case 0:                          return typeof(Action);                        case 1:                          return typeof(Action<>).MakeGenericType(types);                        case 2:                          return typeof(Action<'>).MakeGenericType(types);                        case 3:                          return typeof(Action<''>).MakeGenericType(types);                        case 4:                          return typeof(Action<'''>).MakeGenericType(types);                        case 5:                          return typeof(Action<''''>).MakeGenericType(types);                        case 6:                          return typeof(Action<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Action<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Action<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Action<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Action<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Action<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Action<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Action<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Action<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Action<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Action<'''''''''''''''>).MakeGenericType(types);                  }              }              else              {                  switch (types.Length)                  {                      case 1:                          return typeof(Func<>).MakeGenericType(types);                        case 2:                          return typeof(Func<'>).MakeGenericType(types);                        case 3:                          return typeof(Func<''>).MakeGenericType(types);                        case 4:                          return typeof(Func<'''>).MakeGenericType(types);                        case 5:                          return typeof(Func<''''>).MakeGenericType(types);                        case 6:                          return typeof(Func<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Func<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Func<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Func<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Func<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Func<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Func<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Func<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Func<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Func<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Func<'''''''''''''''>).MakeGenericType(types);                        case 17:                          return typeof(Func<''''''''''''''''>).MakeGenericType(types);                  }              }
Magic Number,System.Linq.Expressions.Interpreter,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\Utilities.net30.cs,MakeDelegate,The following statement contains a magic number: if (returnType == typeof(void))              {                  Array.Resize(ref types' types.Length - 1);                  switch (types.Length)                  {                      case 0:                          return typeof(Action);                        case 1:                          return typeof(Action<>).MakeGenericType(types);                        case 2:                          return typeof(Action<'>).MakeGenericType(types);                        case 3:                          return typeof(Action<''>).MakeGenericType(types);                        case 4:                          return typeof(Action<'''>).MakeGenericType(types);                        case 5:                          return typeof(Action<''''>).MakeGenericType(types);                        case 6:                          return typeof(Action<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Action<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Action<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Action<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Action<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Action<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Action<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Action<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Action<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Action<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Action<'''''''''''''''>).MakeGenericType(types);                  }              }              else              {                  switch (types.Length)                  {                      case 1:                          return typeof(Func<>).MakeGenericType(types);                        case 2:                          return typeof(Func<'>).MakeGenericType(types);                        case 3:                          return typeof(Func<''>).MakeGenericType(types);                        case 4:                          return typeof(Func<'''>).MakeGenericType(types);                        case 5:                          return typeof(Func<''''>).MakeGenericType(types);                        case 6:                          return typeof(Func<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Func<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Func<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Func<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Func<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Func<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Func<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Func<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Func<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Func<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Func<'''''''''''''''>).MakeGenericType(types);                        case 17:                          return typeof(Func<''''''''''''''''>).MakeGenericType(types);                  }              }
Magic Number,System.Linq.Expressions.Interpreter,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\Utilities.net30.cs,MakeDelegate,The following statement contains a magic number: if (returnType == typeof(void))              {                  Array.Resize(ref types' types.Length - 1);                  switch (types.Length)                  {                      case 0:                          return typeof(Action);                        case 1:                          return typeof(Action<>).MakeGenericType(types);                        case 2:                          return typeof(Action<'>).MakeGenericType(types);                        case 3:                          return typeof(Action<''>).MakeGenericType(types);                        case 4:                          return typeof(Action<'''>).MakeGenericType(types);                        case 5:                          return typeof(Action<''''>).MakeGenericType(types);                        case 6:                          return typeof(Action<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Action<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Action<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Action<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Action<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Action<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Action<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Action<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Action<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Action<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Action<'''''''''''''''>).MakeGenericType(types);                  }              }              else              {                  switch (types.Length)                  {                      case 1:                          return typeof(Func<>).MakeGenericType(types);                        case 2:                          return typeof(Func<'>).MakeGenericType(types);                        case 3:                          return typeof(Func<''>).MakeGenericType(types);                        case 4:                          return typeof(Func<'''>).MakeGenericType(types);                        case 5:                          return typeof(Func<''''>).MakeGenericType(types);                        case 6:                          return typeof(Func<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Func<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Func<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Func<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Func<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Func<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Func<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Func<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Func<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Func<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Func<'''''''''''''''>).MakeGenericType(types);                        case 17:                          return typeof(Func<''''''''''''''''>).MakeGenericType(types);                  }              }
Magic Number,System.Linq.Expressions.Interpreter,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\Utilities.net30.cs,MakeDelegate,The following statement contains a magic number: if (returnType == typeof(void))              {                  Array.Resize(ref types' types.Length - 1);                  switch (types.Length)                  {                      case 0:                          return typeof(Action);                        case 1:                          return typeof(Action<>).MakeGenericType(types);                        case 2:                          return typeof(Action<'>).MakeGenericType(types);                        case 3:                          return typeof(Action<''>).MakeGenericType(types);                        case 4:                          return typeof(Action<'''>).MakeGenericType(types);                        case 5:                          return typeof(Action<''''>).MakeGenericType(types);                        case 6:                          return typeof(Action<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Action<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Action<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Action<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Action<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Action<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Action<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Action<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Action<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Action<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Action<'''''''''''''''>).MakeGenericType(types);                  }              }              else              {                  switch (types.Length)                  {                      case 1:                          return typeof(Func<>).MakeGenericType(types);                        case 2:                          return typeof(Func<'>).MakeGenericType(types);                        case 3:                          return typeof(Func<''>).MakeGenericType(types);                        case 4:                          return typeof(Func<'''>).MakeGenericType(types);                        case 5:                          return typeof(Func<''''>).MakeGenericType(types);                        case 6:                          return typeof(Func<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Func<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Func<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Func<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Func<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Func<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Func<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Func<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Func<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Func<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Func<'''''''''''''''>).MakeGenericType(types);                        case 17:                          return typeof(Func<''''''''''''''''>).MakeGenericType(types);                  }              }
Magic Number,System.Linq.Expressions.Interpreter,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\Utilities.net30.cs,MakeDelegate,The following statement contains a magic number: if (returnType == typeof(void))              {                  Array.Resize(ref types' types.Length - 1);                  switch (types.Length)                  {                      case 0:                          return typeof(Action);                        case 1:                          return typeof(Action<>).MakeGenericType(types);                        case 2:                          return typeof(Action<'>).MakeGenericType(types);                        case 3:                          return typeof(Action<''>).MakeGenericType(types);                        case 4:                          return typeof(Action<'''>).MakeGenericType(types);                        case 5:                          return typeof(Action<''''>).MakeGenericType(types);                        case 6:                          return typeof(Action<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Action<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Action<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Action<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Action<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Action<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Action<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Action<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Action<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Action<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Action<'''''''''''''''>).MakeGenericType(types);                  }              }              else              {                  switch (types.Length)                  {                      case 1:                          return typeof(Func<>).MakeGenericType(types);                        case 2:                          return typeof(Func<'>).MakeGenericType(types);                        case 3:                          return typeof(Func<''>).MakeGenericType(types);                        case 4:                          return typeof(Func<'''>).MakeGenericType(types);                        case 5:                          return typeof(Func<''''>).MakeGenericType(types);                        case 6:                          return typeof(Func<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Func<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Func<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Func<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Func<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Func<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Func<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Func<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Func<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Func<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Func<'''''''''''''''>).MakeGenericType(types);                        case 17:                          return typeof(Func<''''''''''''''''>).MakeGenericType(types);                  }              }
Magic Number,System.Linq.Expressions.Interpreter,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\Utilities.net30.cs,MakeDelegate,The following statement contains a magic number: if (returnType == typeof(void))              {                  Array.Resize(ref types' types.Length - 1);                  switch (types.Length)                  {                      case 0:                          return typeof(Action);                        case 1:                          return typeof(Action<>).MakeGenericType(types);                        case 2:                          return typeof(Action<'>).MakeGenericType(types);                        case 3:                          return typeof(Action<''>).MakeGenericType(types);                        case 4:                          return typeof(Action<'''>).MakeGenericType(types);                        case 5:                          return typeof(Action<''''>).MakeGenericType(types);                        case 6:                          return typeof(Action<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Action<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Action<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Action<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Action<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Action<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Action<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Action<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Action<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Action<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Action<'''''''''''''''>).MakeGenericType(types);                  }              }              else              {                  switch (types.Length)                  {                      case 1:                          return typeof(Func<>).MakeGenericType(types);                        case 2:                          return typeof(Func<'>).MakeGenericType(types);                        case 3:                          return typeof(Func<''>).MakeGenericType(types);                        case 4:                          return typeof(Func<'''>).MakeGenericType(types);                        case 5:                          return typeof(Func<''''>).MakeGenericType(types);                        case 6:                          return typeof(Func<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Func<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Func<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Func<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Func<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Func<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Func<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Func<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Func<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Func<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Func<'''''''''''''''>).MakeGenericType(types);                        case 17:                          return typeof(Func<''''''''''''''''>).MakeGenericType(types);                  }              }
Magic Number,System.Linq.Expressions.Interpreter,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\Utilities.net30.cs,MakeDelegate,The following statement contains a magic number: if (returnType == typeof(void))              {                  Array.Resize(ref types' types.Length - 1);                  switch (types.Length)                  {                      case 0:                          return typeof(Action);                        case 1:                          return typeof(Action<>).MakeGenericType(types);                        case 2:                          return typeof(Action<'>).MakeGenericType(types);                        case 3:                          return typeof(Action<''>).MakeGenericType(types);                        case 4:                          return typeof(Action<'''>).MakeGenericType(types);                        case 5:                          return typeof(Action<''''>).MakeGenericType(types);                        case 6:                          return typeof(Action<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Action<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Action<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Action<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Action<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Action<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Action<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Action<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Action<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Action<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Action<'''''''''''''''>).MakeGenericType(types);                  }              }              else              {                  switch (types.Length)                  {                      case 1:                          return typeof(Func<>).MakeGenericType(types);                        case 2:                          return typeof(Func<'>).MakeGenericType(types);                        case 3:                          return typeof(Func<''>).MakeGenericType(types);                        case 4:                          return typeof(Func<'''>).MakeGenericType(types);                        case 5:                          return typeof(Func<''''>).MakeGenericType(types);                        case 6:                          return typeof(Func<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Func<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Func<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Func<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Func<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Func<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Func<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Func<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Func<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Func<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Func<'''''''''''''''>).MakeGenericType(types);                        case 17:                          return typeof(Func<''''''''''''''''>).MakeGenericType(types);                  }              }
Magic Number,System.Linq.Expressions.Interpreter,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\Utilities.net30.cs,MakeDelegate,The following statement contains a magic number: if (returnType == typeof(void))              {                  Array.Resize(ref types' types.Length - 1);                  switch (types.Length)                  {                      case 0:                          return typeof(Action);                        case 1:                          return typeof(Action<>).MakeGenericType(types);                        case 2:                          return typeof(Action<'>).MakeGenericType(types);                        case 3:                          return typeof(Action<''>).MakeGenericType(types);                        case 4:                          return typeof(Action<'''>).MakeGenericType(types);                        case 5:                          return typeof(Action<''''>).MakeGenericType(types);                        case 6:                          return typeof(Action<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Action<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Action<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Action<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Action<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Action<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Action<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Action<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Action<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Action<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Action<'''''''''''''''>).MakeGenericType(types);                  }              }              else              {                  switch (types.Length)                  {                      case 1:                          return typeof(Func<>).MakeGenericType(types);                        case 2:                          return typeof(Func<'>).MakeGenericType(types);                        case 3:                          return typeof(Func<''>).MakeGenericType(types);                        case 4:                          return typeof(Func<'''>).MakeGenericType(types);                        case 5:                          return typeof(Func<''''>).MakeGenericType(types);                        case 6:                          return typeof(Func<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Func<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Func<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Func<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Func<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Func<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Func<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Func<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Func<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Func<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Func<'''''''''''''''>).MakeGenericType(types);                        case 17:                          return typeof(Func<''''''''''''''''>).MakeGenericType(types);                  }              }
Magic Number,System.Linq.Expressions.Interpreter,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\Utilities.net30.cs,MakeDelegate,The following statement contains a magic number: if (returnType == typeof(void))              {                  Array.Resize(ref types' types.Length - 1);                  switch (types.Length)                  {                      case 0:                          return typeof(Action);                        case 1:                          return typeof(Action<>).MakeGenericType(types);                        case 2:                          return typeof(Action<'>).MakeGenericType(types);                        case 3:                          return typeof(Action<''>).MakeGenericType(types);                        case 4:                          return typeof(Action<'''>).MakeGenericType(types);                        case 5:                          return typeof(Action<''''>).MakeGenericType(types);                        case 6:                          return typeof(Action<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Action<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Action<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Action<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Action<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Action<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Action<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Action<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Action<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Action<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Action<'''''''''''''''>).MakeGenericType(types);                  }              }              else              {                  switch (types.Length)                  {                      case 1:                          return typeof(Func<>).MakeGenericType(types);                        case 2:                          return typeof(Func<'>).MakeGenericType(types);                        case 3:                          return typeof(Func<''>).MakeGenericType(types);                        case 4:                          return typeof(Func<'''>).MakeGenericType(types);                        case 5:                          return typeof(Func<''''>).MakeGenericType(types);                        case 6:                          return typeof(Func<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Func<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Func<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Func<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Func<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Func<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Func<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Func<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Func<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Func<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Func<'''''''''''''''>).MakeGenericType(types);                        case 17:                          return typeof(Func<''''''''''''''''>).MakeGenericType(types);                  }              }
Magic Number,System.Linq.Expressions.Interpreter,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\Utilities.net30.cs,MakeDelegate,The following statement contains a magic number: if (returnType == typeof(void))              {                  Array.Resize(ref types' types.Length - 1);                  switch (types.Length)                  {                      case 0:                          return typeof(Action);                        case 1:                          return typeof(Action<>).MakeGenericType(types);                        case 2:                          return typeof(Action<'>).MakeGenericType(types);                        case 3:                          return typeof(Action<''>).MakeGenericType(types);                        case 4:                          return typeof(Action<'''>).MakeGenericType(types);                        case 5:                          return typeof(Action<''''>).MakeGenericType(types);                        case 6:                          return typeof(Action<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Action<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Action<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Action<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Action<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Action<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Action<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Action<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Action<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Action<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Action<'''''''''''''''>).MakeGenericType(types);                  }              }              else              {                  switch (types.Length)                  {                      case 1:                          return typeof(Func<>).MakeGenericType(types);                        case 2:                          return typeof(Func<'>).MakeGenericType(types);                        case 3:                          return typeof(Func<''>).MakeGenericType(types);                        case 4:                          return typeof(Func<'''>).MakeGenericType(types);                        case 5:                          return typeof(Func<''''>).MakeGenericType(types);                        case 6:                          return typeof(Func<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Func<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Func<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Func<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Func<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Func<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Func<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Func<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Func<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Func<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Func<'''''''''''''''>).MakeGenericType(types);                        case 17:                          return typeof(Func<''''''''''''''''>).MakeGenericType(types);                  }              }
Magic Number,System.Linq.Expressions.Interpreter,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\Utilities.net30.cs,MakeDelegate,The following statement contains a magic number: if (returnType == typeof(void))              {                  Array.Resize(ref types' types.Length - 1);                  switch (types.Length)                  {                      case 0:                          return typeof(Action);                        case 1:                          return typeof(Action<>).MakeGenericType(types);                        case 2:                          return typeof(Action<'>).MakeGenericType(types);                        case 3:                          return typeof(Action<''>).MakeGenericType(types);                        case 4:                          return typeof(Action<'''>).MakeGenericType(types);                        case 5:                          return typeof(Action<''''>).MakeGenericType(types);                        case 6:                          return typeof(Action<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Action<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Action<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Action<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Action<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Action<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Action<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Action<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Action<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Action<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Action<'''''''''''''''>).MakeGenericType(types);                  }              }              else              {                  switch (types.Length)                  {                      case 1:                          return typeof(Func<>).MakeGenericType(types);                        case 2:                          return typeof(Func<'>).MakeGenericType(types);                        case 3:                          return typeof(Func<''>).MakeGenericType(types);                        case 4:                          return typeof(Func<'''>).MakeGenericType(types);                        case 5:                          return typeof(Func<''''>).MakeGenericType(types);                        case 6:                          return typeof(Func<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Func<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Func<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Func<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Func<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Func<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Func<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Func<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Func<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Func<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Func<'''''''''''''''>).MakeGenericType(types);                        case 17:                          return typeof(Func<''''''''''''''''>).MakeGenericType(types);                  }              }
Magic Number,System.Linq.Expressions.Interpreter,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\Utilities.net30.cs,MakeDelegate,The following statement contains a magic number: if (returnType == typeof(void))              {                  Array.Resize(ref types' types.Length - 1);                  switch (types.Length)                  {                      case 0:                          return typeof(Action);                        case 1:                          return typeof(Action<>).MakeGenericType(types);                        case 2:                          return typeof(Action<'>).MakeGenericType(types);                        case 3:                          return typeof(Action<''>).MakeGenericType(types);                        case 4:                          return typeof(Action<'''>).MakeGenericType(types);                        case 5:                          return typeof(Action<''''>).MakeGenericType(types);                        case 6:                          return typeof(Action<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Action<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Action<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Action<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Action<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Action<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Action<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Action<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Action<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Action<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Action<'''''''''''''''>).MakeGenericType(types);                  }              }              else              {                  switch (types.Length)                  {                      case 1:                          return typeof(Func<>).MakeGenericType(types);                        case 2:                          return typeof(Func<'>).MakeGenericType(types);                        case 3:                          return typeof(Func<''>).MakeGenericType(types);                        case 4:                          return typeof(Func<'''>).MakeGenericType(types);                        case 5:                          return typeof(Func<''''>).MakeGenericType(types);                        case 6:                          return typeof(Func<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Func<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Func<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Func<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Func<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Func<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Func<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Func<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Func<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Func<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Func<'''''''''''''''>).MakeGenericType(types);                        case 17:                          return typeof(Func<''''''''''''''''>).MakeGenericType(types);                  }              }
Magic Number,System.Linq.Expressions.Interpreter,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\Utilities.net30.cs,MakeDelegate,The following statement contains a magic number: if (returnType == typeof(void))              {                  Array.Resize(ref types' types.Length - 1);                  switch (types.Length)                  {                      case 0:                          return typeof(Action);                        case 1:                          return typeof(Action<>).MakeGenericType(types);                        case 2:                          return typeof(Action<'>).MakeGenericType(types);                        case 3:                          return typeof(Action<''>).MakeGenericType(types);                        case 4:                          return typeof(Action<'''>).MakeGenericType(types);                        case 5:                          return typeof(Action<''''>).MakeGenericType(types);                        case 6:                          return typeof(Action<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Action<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Action<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Action<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Action<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Action<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Action<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Action<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Action<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Action<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Action<'''''''''''''''>).MakeGenericType(types);                  }              }              else              {                  switch (types.Length)                  {                      case 1:                          return typeof(Func<>).MakeGenericType(types);                        case 2:                          return typeof(Func<'>).MakeGenericType(types);                        case 3:                          return typeof(Func<''>).MakeGenericType(types);                        case 4:                          return typeof(Func<'''>).MakeGenericType(types);                        case 5:                          return typeof(Func<''''>).MakeGenericType(types);                        case 6:                          return typeof(Func<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Func<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Func<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Func<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Func<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Func<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Func<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Func<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Func<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Func<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Func<'''''''''''''''>).MakeGenericType(types);                        case 17:                          return typeof(Func<''''''''''''''''>).MakeGenericType(types);                  }              }
Magic Number,System.Linq.Expressions.Interpreter,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\Utilities.net30.cs,MakeDelegate,The following statement contains a magic number: if (returnType == typeof(void))              {                  Array.Resize(ref types' types.Length - 1);                  switch (types.Length)                  {                      case 0:                          return typeof(Action);                        case 1:                          return typeof(Action<>).MakeGenericType(types);                        case 2:                          return typeof(Action<'>).MakeGenericType(types);                        case 3:                          return typeof(Action<''>).MakeGenericType(types);                        case 4:                          return typeof(Action<'''>).MakeGenericType(types);                        case 5:                          return typeof(Action<''''>).MakeGenericType(types);                        case 6:                          return typeof(Action<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Action<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Action<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Action<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Action<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Action<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Action<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Action<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Action<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Action<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Action<'''''''''''''''>).MakeGenericType(types);                  }              }              else              {                  switch (types.Length)                  {                      case 1:                          return typeof(Func<>).MakeGenericType(types);                        case 2:                          return typeof(Func<'>).MakeGenericType(types);                        case 3:                          return typeof(Func<''>).MakeGenericType(types);                        case 4:                          return typeof(Func<'''>).MakeGenericType(types);                        case 5:                          return typeof(Func<''''>).MakeGenericType(types);                        case 6:                          return typeof(Func<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Func<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Func<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Func<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Func<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Func<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Func<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Func<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Func<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Func<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Func<'''''''''''''''>).MakeGenericType(types);                        case 17:                          return typeof(Func<''''''''''''''''>).MakeGenericType(types);                  }              }
Magic Number,System.Linq.Expressions.Interpreter,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\Utilities.net30.cs,MakeDelegate,The following statement contains a magic number: if (returnType == typeof(void))              {                  Array.Resize(ref types' types.Length - 1);                  switch (types.Length)                  {                      case 0:                          return typeof(Action);                        case 1:                          return typeof(Action<>).MakeGenericType(types);                        case 2:                          return typeof(Action<'>).MakeGenericType(types);                        case 3:                          return typeof(Action<''>).MakeGenericType(types);                        case 4:                          return typeof(Action<'''>).MakeGenericType(types);                        case 5:                          return typeof(Action<''''>).MakeGenericType(types);                        case 6:                          return typeof(Action<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Action<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Action<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Action<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Action<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Action<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Action<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Action<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Action<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Action<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Action<'''''''''''''''>).MakeGenericType(types);                  }              }              else              {                  switch (types.Length)                  {                      case 1:                          return typeof(Func<>).MakeGenericType(types);                        case 2:                          return typeof(Func<'>).MakeGenericType(types);                        case 3:                          return typeof(Func<''>).MakeGenericType(types);                        case 4:                          return typeof(Func<'''>).MakeGenericType(types);                        case 5:                          return typeof(Func<''''>).MakeGenericType(types);                        case 6:                          return typeof(Func<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Func<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Func<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Func<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Func<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Func<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Func<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Func<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Func<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Func<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Func<'''''''''''''''>).MakeGenericType(types);                        case 17:                          return typeof(Func<''''''''''''''''>).MakeGenericType(types);                  }              }
Magic Number,System.Linq.Expressions.Interpreter,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\Utilities.net30.cs,MakeDelegate,The following statement contains a magic number: if (returnType == typeof(void))              {                  Array.Resize(ref types' types.Length - 1);                  switch (types.Length)                  {                      case 0:                          return typeof(Action);                        case 1:                          return typeof(Action<>).MakeGenericType(types);                        case 2:                          return typeof(Action<'>).MakeGenericType(types);                        case 3:                          return typeof(Action<''>).MakeGenericType(types);                        case 4:                          return typeof(Action<'''>).MakeGenericType(types);                        case 5:                          return typeof(Action<''''>).MakeGenericType(types);                        case 6:                          return typeof(Action<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Action<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Action<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Action<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Action<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Action<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Action<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Action<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Action<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Action<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Action<'''''''''''''''>).MakeGenericType(types);                  }              }              else              {                  switch (types.Length)                  {                      case 1:                          return typeof(Func<>).MakeGenericType(types);                        case 2:                          return typeof(Func<'>).MakeGenericType(types);                        case 3:                          return typeof(Func<''>).MakeGenericType(types);                        case 4:                          return typeof(Func<'''>).MakeGenericType(types);                        case 5:                          return typeof(Func<''''>).MakeGenericType(types);                        case 6:                          return typeof(Func<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Func<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Func<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Func<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Func<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Func<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Func<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Func<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Func<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Func<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Func<'''''''''''''''>).MakeGenericType(types);                        case 17:                          return typeof(Func<''''''''''''''''>).MakeGenericType(types);                  }              }
Magic Number,System.Linq.Expressions.Interpreter,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\Utilities.net30.cs,MakeDelegate,The following statement contains a magic number: if (returnType == typeof(void))              {                  Array.Resize(ref types' types.Length - 1);                  switch (types.Length)                  {                      case 0:                          return typeof(Action);                        case 1:                          return typeof(Action<>).MakeGenericType(types);                        case 2:                          return typeof(Action<'>).MakeGenericType(types);                        case 3:                          return typeof(Action<''>).MakeGenericType(types);                        case 4:                          return typeof(Action<'''>).MakeGenericType(types);                        case 5:                          return typeof(Action<''''>).MakeGenericType(types);                        case 6:                          return typeof(Action<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Action<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Action<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Action<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Action<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Action<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Action<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Action<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Action<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Action<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Action<'''''''''''''''>).MakeGenericType(types);                  }              }              else              {                  switch (types.Length)                  {                      case 1:                          return typeof(Func<>).MakeGenericType(types);                        case 2:                          return typeof(Func<'>).MakeGenericType(types);                        case 3:                          return typeof(Func<''>).MakeGenericType(types);                        case 4:                          return typeof(Func<'''>).MakeGenericType(types);                        case 5:                          return typeof(Func<''''>).MakeGenericType(types);                        case 6:                          return typeof(Func<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Func<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Func<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Func<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Func<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Func<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Func<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Func<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Func<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Func<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Func<'''''''''''''''>).MakeGenericType(types);                        case 17:                          return typeof(Func<''''''''''''''''>).MakeGenericType(types);                  }              }
Magic Number,System.Linq.Expressions.Interpreter,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\Utilities.net30.cs,MakeDelegate,The following statement contains a magic number: if (returnType == typeof(void))              {                  Array.Resize(ref types' types.Length - 1);                  switch (types.Length)                  {                      case 0:                          return typeof(Action);                        case 1:                          return typeof(Action<>).MakeGenericType(types);                        case 2:                          return typeof(Action<'>).MakeGenericType(types);                        case 3:                          return typeof(Action<''>).MakeGenericType(types);                        case 4:                          return typeof(Action<'''>).MakeGenericType(types);                        case 5:                          return typeof(Action<''''>).MakeGenericType(types);                        case 6:                          return typeof(Action<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Action<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Action<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Action<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Action<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Action<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Action<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Action<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Action<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Action<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Action<'''''''''''''''>).MakeGenericType(types);                  }              }              else              {                  switch (types.Length)                  {                      case 1:                          return typeof(Func<>).MakeGenericType(types);                        case 2:                          return typeof(Func<'>).MakeGenericType(types);                        case 3:                          return typeof(Func<''>).MakeGenericType(types);                        case 4:                          return typeof(Func<'''>).MakeGenericType(types);                        case 5:                          return typeof(Func<''''>).MakeGenericType(types);                        case 6:                          return typeof(Func<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Func<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Func<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Func<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Func<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Func<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Func<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Func<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Func<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Func<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Func<'''''''''''''''>).MakeGenericType(types);                        case 17:                          return typeof(Func<''''''''''''''''>).MakeGenericType(types);                  }              }
Magic Number,System.Linq.Expressions.Interpreter,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\Utilities.net30.cs,MakeDelegate,The following statement contains a magic number: if (returnType == typeof(void))              {                  Array.Resize(ref types' types.Length - 1);                  switch (types.Length)                  {                      case 0:                          return typeof(Action);                        case 1:                          return typeof(Action<>).MakeGenericType(types);                        case 2:                          return typeof(Action<'>).MakeGenericType(types);                        case 3:                          return typeof(Action<''>).MakeGenericType(types);                        case 4:                          return typeof(Action<'''>).MakeGenericType(types);                        case 5:                          return typeof(Action<''''>).MakeGenericType(types);                        case 6:                          return typeof(Action<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Action<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Action<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Action<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Action<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Action<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Action<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Action<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Action<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Action<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Action<'''''''''''''''>).MakeGenericType(types);                  }              }              else              {                  switch (types.Length)                  {                      case 1:                          return typeof(Func<>).MakeGenericType(types);                        case 2:                          return typeof(Func<'>).MakeGenericType(types);                        case 3:                          return typeof(Func<''>).MakeGenericType(types);                        case 4:                          return typeof(Func<'''>).MakeGenericType(types);                        case 5:                          return typeof(Func<''''>).MakeGenericType(types);                        case 6:                          return typeof(Func<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Func<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Func<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Func<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Func<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Func<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Func<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Func<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Func<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Func<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Func<'''''''''''''''>).MakeGenericType(types);                        case 17:                          return typeof(Func<''''''''''''''''>).MakeGenericType(types);                  }              }
Magic Number,System.Linq.Expressions.Interpreter,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\Utilities.net30.cs,MakeDelegate,The following statement contains a magic number: if (returnType == typeof(void))              {                  Array.Resize(ref types' types.Length - 1);                  switch (types.Length)                  {                      case 0:                          return typeof(Action);                        case 1:                          return typeof(Action<>).MakeGenericType(types);                        case 2:                          return typeof(Action<'>).MakeGenericType(types);                        case 3:                          return typeof(Action<''>).MakeGenericType(types);                        case 4:                          return typeof(Action<'''>).MakeGenericType(types);                        case 5:                          return typeof(Action<''''>).MakeGenericType(types);                        case 6:                          return typeof(Action<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Action<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Action<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Action<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Action<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Action<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Action<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Action<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Action<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Action<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Action<'''''''''''''''>).MakeGenericType(types);                  }              }              else              {                  switch (types.Length)                  {                      case 1:                          return typeof(Func<>).MakeGenericType(types);                        case 2:                          return typeof(Func<'>).MakeGenericType(types);                        case 3:                          return typeof(Func<''>).MakeGenericType(types);                        case 4:                          return typeof(Func<'''>).MakeGenericType(types);                        case 5:                          return typeof(Func<''''>).MakeGenericType(types);                        case 6:                          return typeof(Func<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Func<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Func<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Func<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Func<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Func<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Func<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Func<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Func<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Func<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Func<'''''''''''''''>).MakeGenericType(types);                        case 17:                          return typeof(Func<''''''''''''''''>).MakeGenericType(types);                  }              }
Magic Number,System.Linq.Expressions.Interpreter,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\Utilities.net30.cs,MakeDelegate,The following statement contains a magic number: if (returnType == typeof(void))              {                  Array.Resize(ref types' types.Length - 1);                  switch (types.Length)                  {                      case 0:                          return typeof(Action);                        case 1:                          return typeof(Action<>).MakeGenericType(types);                        case 2:                          return typeof(Action<'>).MakeGenericType(types);                        case 3:                          return typeof(Action<''>).MakeGenericType(types);                        case 4:                          return typeof(Action<'''>).MakeGenericType(types);                        case 5:                          return typeof(Action<''''>).MakeGenericType(types);                        case 6:                          return typeof(Action<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Action<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Action<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Action<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Action<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Action<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Action<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Action<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Action<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Action<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Action<'''''''''''''''>).MakeGenericType(types);                  }              }              else              {                  switch (types.Length)                  {                      case 1:                          return typeof(Func<>).MakeGenericType(types);                        case 2:                          return typeof(Func<'>).MakeGenericType(types);                        case 3:                          return typeof(Func<''>).MakeGenericType(types);                        case 4:                          return typeof(Func<'''>).MakeGenericType(types);                        case 5:                          return typeof(Func<''''>).MakeGenericType(types);                        case 6:                          return typeof(Func<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Func<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Func<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Func<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Func<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Func<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Func<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Func<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Func<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Func<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Func<'''''''''''''''>).MakeGenericType(types);                        case 17:                          return typeof(Func<''''''''''''''''>).MakeGenericType(types);                  }              }
Magic Number,System.Linq.Expressions.Interpreter,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\Utilities.net30.cs,MakeDelegate,The following statement contains a magic number: if (returnType == typeof(void))              {                  Array.Resize(ref types' types.Length - 1);                  switch (types.Length)                  {                      case 0:                          return typeof(Action);                        case 1:                          return typeof(Action<>).MakeGenericType(types);                        case 2:                          return typeof(Action<'>).MakeGenericType(types);                        case 3:                          return typeof(Action<''>).MakeGenericType(types);                        case 4:                          return typeof(Action<'''>).MakeGenericType(types);                        case 5:                          return typeof(Action<''''>).MakeGenericType(types);                        case 6:                          return typeof(Action<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Action<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Action<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Action<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Action<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Action<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Action<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Action<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Action<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Action<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Action<'''''''''''''''>).MakeGenericType(types);                  }              }              else              {                  switch (types.Length)                  {                      case 1:                          return typeof(Func<>).MakeGenericType(types);                        case 2:                          return typeof(Func<'>).MakeGenericType(types);                        case 3:                          return typeof(Func<''>).MakeGenericType(types);                        case 4:                          return typeof(Func<'''>).MakeGenericType(types);                        case 5:                          return typeof(Func<''''>).MakeGenericType(types);                        case 6:                          return typeof(Func<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Func<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Func<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Func<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Func<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Func<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Func<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Func<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Func<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Func<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Func<'''''''''''''''>).MakeGenericType(types);                        case 17:                          return typeof(Func<''''''''''''''''>).MakeGenericType(types);                  }              }
Magic Number,System.Linq.Expressions.Interpreter,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\Utilities.net30.cs,MakeDelegate,The following statement contains a magic number: if (returnType == typeof(void))              {                  Array.Resize(ref types' types.Length - 1);                  switch (types.Length)                  {                      case 0:                          return typeof(Action);                        case 1:                          return typeof(Action<>).MakeGenericType(types);                        case 2:                          return typeof(Action<'>).MakeGenericType(types);                        case 3:                          return typeof(Action<''>).MakeGenericType(types);                        case 4:                          return typeof(Action<'''>).MakeGenericType(types);                        case 5:                          return typeof(Action<''''>).MakeGenericType(types);                        case 6:                          return typeof(Action<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Action<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Action<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Action<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Action<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Action<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Action<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Action<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Action<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Action<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Action<'''''''''''''''>).MakeGenericType(types);                  }              }              else              {                  switch (types.Length)                  {                      case 1:                          return typeof(Func<>).MakeGenericType(types);                        case 2:                          return typeof(Func<'>).MakeGenericType(types);                        case 3:                          return typeof(Func<''>).MakeGenericType(types);                        case 4:                          return typeof(Func<'''>).MakeGenericType(types);                        case 5:                          return typeof(Func<''''>).MakeGenericType(types);                        case 6:                          return typeof(Func<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Func<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Func<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Func<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Func<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Func<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Func<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Func<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Func<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Func<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Func<'''''''''''''''>).MakeGenericType(types);                        case 17:                          return typeof(Func<''''''''''''''''>).MakeGenericType(types);                  }              }
Magic Number,System.Linq.Expressions.Interpreter,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\Utilities.net30.cs,MakeDelegate,The following statement contains a magic number: if (returnType == typeof(void))              {                  Array.Resize(ref types' types.Length - 1);                  switch (types.Length)                  {                      case 0:                          return typeof(Action);                        case 1:                          return typeof(Action<>).MakeGenericType(types);                        case 2:                          return typeof(Action<'>).MakeGenericType(types);                        case 3:                          return typeof(Action<''>).MakeGenericType(types);                        case 4:                          return typeof(Action<'''>).MakeGenericType(types);                        case 5:                          return typeof(Action<''''>).MakeGenericType(types);                        case 6:                          return typeof(Action<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Action<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Action<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Action<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Action<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Action<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Action<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Action<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Action<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Action<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Action<'''''''''''''''>).MakeGenericType(types);                  }              }              else              {                  switch (types.Length)                  {                      case 1:                          return typeof(Func<>).MakeGenericType(types);                        case 2:                          return typeof(Func<'>).MakeGenericType(types);                        case 3:                          return typeof(Func<''>).MakeGenericType(types);                        case 4:                          return typeof(Func<'''>).MakeGenericType(types);                        case 5:                          return typeof(Func<''''>).MakeGenericType(types);                        case 6:                          return typeof(Func<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Func<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Func<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Func<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Func<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Func<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Func<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Func<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Func<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Func<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Func<'''''''''''''''>).MakeGenericType(types);                        case 17:                          return typeof(Func<''''''''''''''''>).MakeGenericType(types);                  }              }
Magic Number,System.Linq.Expressions.Interpreter,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\Utilities.net30.cs,MakeDelegate,The following statement contains a magic number: if (returnType == typeof(void))              {                  Array.Resize(ref types' types.Length - 1);                  switch (types.Length)                  {                      case 0:                          return typeof(Action);                        case 1:                          return typeof(Action<>).MakeGenericType(types);                        case 2:                          return typeof(Action<'>).MakeGenericType(types);                        case 3:                          return typeof(Action<''>).MakeGenericType(types);                        case 4:                          return typeof(Action<'''>).MakeGenericType(types);                        case 5:                          return typeof(Action<''''>).MakeGenericType(types);                        case 6:                          return typeof(Action<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Action<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Action<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Action<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Action<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Action<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Action<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Action<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Action<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Action<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Action<'''''''''''''''>).MakeGenericType(types);                  }              }              else              {                  switch (types.Length)                  {                      case 1:                          return typeof(Func<>).MakeGenericType(types);                        case 2:                          return typeof(Func<'>).MakeGenericType(types);                        case 3:                          return typeof(Func<''>).MakeGenericType(types);                        case 4:                          return typeof(Func<'''>).MakeGenericType(types);                        case 5:                          return typeof(Func<''''>).MakeGenericType(types);                        case 6:                          return typeof(Func<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Func<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Func<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Func<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Func<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Func<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Func<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Func<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Func<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Func<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Func<'''''''''''''''>).MakeGenericType(types);                        case 17:                          return typeof(Func<''''''''''''''''>).MakeGenericType(types);                  }              }
Magic Number,System.Linq.Expressions.Interpreter,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\Utilities.net30.cs,MakeDelegate,The following statement contains a magic number: if (returnType == typeof(void))              {                  Array.Resize(ref types' types.Length - 1);                  switch (types.Length)                  {                      case 0:                          return typeof(Action);                        case 1:                          return typeof(Action<>).MakeGenericType(types);                        case 2:                          return typeof(Action<'>).MakeGenericType(types);                        case 3:                          return typeof(Action<''>).MakeGenericType(types);                        case 4:                          return typeof(Action<'''>).MakeGenericType(types);                        case 5:                          return typeof(Action<''''>).MakeGenericType(types);                        case 6:                          return typeof(Action<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Action<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Action<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Action<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Action<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Action<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Action<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Action<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Action<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Action<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Action<'''''''''''''''>).MakeGenericType(types);                  }              }              else              {                  switch (types.Length)                  {                      case 1:                          return typeof(Func<>).MakeGenericType(types);                        case 2:                          return typeof(Func<'>).MakeGenericType(types);                        case 3:                          return typeof(Func<''>).MakeGenericType(types);                        case 4:                          return typeof(Func<'''>).MakeGenericType(types);                        case 5:                          return typeof(Func<''''>).MakeGenericType(types);                        case 6:                          return typeof(Func<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Func<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Func<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Func<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Func<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Func<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Func<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Func<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Func<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Func<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Func<'''''''''''''''>).MakeGenericType(types);                        case 17:                          return typeof(Func<''''''''''''''''>).MakeGenericType(types);                  }              }
Magic Number,System.Linq.Expressions.Interpreter,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\Utilities.net30.cs,MakeDelegate,The following statement contains a magic number: if (returnType == typeof(void))              {                  Array.Resize(ref types' types.Length - 1);                  switch (types.Length)                  {                      case 0:                          return typeof(Action);                        case 1:                          return typeof(Action<>).MakeGenericType(types);                        case 2:                          return typeof(Action<'>).MakeGenericType(types);                        case 3:                          return typeof(Action<''>).MakeGenericType(types);                        case 4:                          return typeof(Action<'''>).MakeGenericType(types);                        case 5:                          return typeof(Action<''''>).MakeGenericType(types);                        case 6:                          return typeof(Action<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Action<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Action<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Action<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Action<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Action<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Action<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Action<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Action<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Action<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Action<'''''''''''''''>).MakeGenericType(types);                  }              }              else              {                  switch (types.Length)                  {                      case 1:                          return typeof(Func<>).MakeGenericType(types);                        case 2:                          return typeof(Func<'>).MakeGenericType(types);                        case 3:                          return typeof(Func<''>).MakeGenericType(types);                        case 4:                          return typeof(Func<'''>).MakeGenericType(types);                        case 5:                          return typeof(Func<''''>).MakeGenericType(types);                        case 6:                          return typeof(Func<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Func<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Func<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Func<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Func<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Func<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Func<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Func<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Func<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Func<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Func<'''''''''''''''>).MakeGenericType(types);                        case 17:                          return typeof(Func<''''''''''''''''>).MakeGenericType(types);                  }              }
Magic Number,System.Linq.Expressions.Interpreter,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\Utilities.net30.cs,MakeDelegate,The following statement contains a magic number: if (returnType == typeof(void))              {                  Array.Resize(ref types' types.Length - 1);                  switch (types.Length)                  {                      case 0:                          return typeof(Action);                        case 1:                          return typeof(Action<>).MakeGenericType(types);                        case 2:                          return typeof(Action<'>).MakeGenericType(types);                        case 3:                          return typeof(Action<''>).MakeGenericType(types);                        case 4:                          return typeof(Action<'''>).MakeGenericType(types);                        case 5:                          return typeof(Action<''''>).MakeGenericType(types);                        case 6:                          return typeof(Action<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Action<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Action<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Action<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Action<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Action<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Action<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Action<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Action<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Action<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Action<'''''''''''''''>).MakeGenericType(types);                  }              }              else              {                  switch (types.Length)                  {                      case 1:                          return typeof(Func<>).MakeGenericType(types);                        case 2:                          return typeof(Func<'>).MakeGenericType(types);                        case 3:                          return typeof(Func<''>).MakeGenericType(types);                        case 4:                          return typeof(Func<'''>).MakeGenericType(types);                        case 5:                          return typeof(Func<''''>).MakeGenericType(types);                        case 6:                          return typeof(Func<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Func<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Func<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Func<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Func<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Func<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Func<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Func<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Func<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Func<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Func<'''''''''''''''>).MakeGenericType(types);                        case 17:                          return typeof(Func<''''''''''''''''>).MakeGenericType(types);                  }              }
Magic Number,System.Linq.Expressions.Interpreter,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\Utilities.net30.cs,MakeDelegate,The following statement contains a magic number: if (returnType == typeof(void))              {                  Array.Resize(ref types' types.Length - 1);                  switch (types.Length)                  {                      case 0:                          return typeof(Action);                        case 1:                          return typeof(Action<>).MakeGenericType(types);                        case 2:                          return typeof(Action<'>).MakeGenericType(types);                        case 3:                          return typeof(Action<''>).MakeGenericType(types);                        case 4:                          return typeof(Action<'''>).MakeGenericType(types);                        case 5:                          return typeof(Action<''''>).MakeGenericType(types);                        case 6:                          return typeof(Action<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Action<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Action<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Action<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Action<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Action<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Action<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Action<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Action<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Action<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Action<'''''''''''''''>).MakeGenericType(types);                  }              }              else              {                  switch (types.Length)                  {                      case 1:                          return typeof(Func<>).MakeGenericType(types);                        case 2:                          return typeof(Func<'>).MakeGenericType(types);                        case 3:                          return typeof(Func<''>).MakeGenericType(types);                        case 4:                          return typeof(Func<'''>).MakeGenericType(types);                        case 5:                          return typeof(Func<''''>).MakeGenericType(types);                        case 6:                          return typeof(Func<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Func<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Func<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Func<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Func<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Func<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Func<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Func<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Func<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Func<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Func<'''''''''''''''>).MakeGenericType(types);                        case 17:                          return typeof(Func<''''''''''''''''>).MakeGenericType(types);                  }              }
Magic Number,System.Linq.Expressions.Interpreter,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\Utilities.net30.cs,MakeDelegate,The following statement contains a magic number: if (returnType == typeof(void))              {                  Array.Resize(ref types' types.Length - 1);                  switch (types.Length)                  {                      case 0:                          return typeof(Action);                        case 1:                          return typeof(Action<>).MakeGenericType(types);                        case 2:                          return typeof(Action<'>).MakeGenericType(types);                        case 3:                          return typeof(Action<''>).MakeGenericType(types);                        case 4:                          return typeof(Action<'''>).MakeGenericType(types);                        case 5:                          return typeof(Action<''''>).MakeGenericType(types);                        case 6:                          return typeof(Action<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Action<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Action<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Action<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Action<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Action<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Action<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Action<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Action<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Action<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Action<'''''''''''''''>).MakeGenericType(types);                  }              }              else              {                  switch (types.Length)                  {                      case 1:                          return typeof(Func<>).MakeGenericType(types);                        case 2:                          return typeof(Func<'>).MakeGenericType(types);                        case 3:                          return typeof(Func<''>).MakeGenericType(types);                        case 4:                          return typeof(Func<'''>).MakeGenericType(types);                        case 5:                          return typeof(Func<''''>).MakeGenericType(types);                        case 6:                          return typeof(Func<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Func<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Func<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Func<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Func<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Func<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Func<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Func<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Func<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Func<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Func<'''''''''''''''>).MakeGenericType(types);                        case 17:                          return typeof(Func<''''''''''''''''>).MakeGenericType(types);                  }              }
Magic Number,System.Linq.Expressions.Interpreter,ListEqualityComparer<T>,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\Utilities.net30.cs,ListHashCode,The following statement contains a magic number: var h = 6551;
Magic Number,System.Linq.Expressions.Interpreter,ListEqualityComparer<T>,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\Utilities.net30.cs,ListHashCode,The following statement contains a magic number: foreach (var t in list)              {                  h ^= (h << 5) ^ cmp.GetHashCode(t);              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,BigInteger,The following statement contains a magic number: InternalBits = new[] { (uint)num' (uint)(num >> 32) };
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,BigInteger,The following statement contains a magic number: if (value > int.MaxValue)              {                  InternalSign = 1;                  InternalBits = new[] { (uint)value' (uint)(value >> 32) };              }              else              {                  InternalSign = (int)value;                  InternalBits = null;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,BigInteger,The following statement contains a magic number: var size = 3;
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,BigInteger,The following statement contains a magic number: if (size == 0)              {                  this = _bigIntegerZeroInt;              }              else if (size != 1 || bits[0] <= 0)              {                  InternalBits = new uint[size];                  InternalBits[0] = (uint)bits[0];                  if (size > 1)                  {                      InternalBits[1] = (uint)bits[1];                  }                  if (size > 2)                  {                      InternalBits[2] = (uint)bits[2];                  }                  InternalSign = ((bits[3] & int.MinValue) == 0 ? 1 : -1);              }              else              {                  InternalSign = bits[0];                  InternalSign = InternalSign * ((bits[3] & int.MinValue) == 0 ? 1 : -1);                  InternalBits = null;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,BigInteger,The following statement contains a magic number: if (size == 0)              {                  this = _bigIntegerZeroInt;              }              else if (size != 1 || bits[0] <= 0)              {                  InternalBits = new uint[size];                  InternalBits[0] = (uint)bits[0];                  if (size > 1)                  {                      InternalBits[1] = (uint)bits[1];                  }                  if (size > 2)                  {                      InternalBits[2] = (uint)bits[2];                  }                  InternalSign = ((bits[3] & int.MinValue) == 0 ? 1 : -1);              }              else              {                  InternalSign = bits[0];                  InternalSign = InternalSign * ((bits[3] & int.MinValue) == 0 ? 1 : -1);                  InternalBits = null;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,BigInteger,The following statement contains a magic number: if (size == 0)              {                  this = _bigIntegerZeroInt;              }              else if (size != 1 || bits[0] <= 0)              {                  InternalBits = new uint[size];                  InternalBits[0] = (uint)bits[0];                  if (size > 1)                  {                      InternalBits[1] = (uint)bits[1];                  }                  if (size > 2)                  {                      InternalBits[2] = (uint)bits[2];                  }                  InternalSign = ((bits[3] & int.MinValue) == 0 ? 1 : -1);              }              else              {                  InternalSign = bits[0];                  InternalSign = InternalSign * ((bits[3] & int.MinValue) == 0 ? 1 : -1);                  InternalBits = null;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,BigInteger,The following statement contains a magic number: if (size == 0)              {                  this = _bigIntegerZeroInt;              }              else if (size != 1 || bits[0] <= 0)              {                  InternalBits = new uint[size];                  InternalBits[0] = (uint)bits[0];                  if (size > 1)                  {                      InternalBits[1] = (uint)bits[1];                  }                  if (size > 2)                  {                      InternalBits[2] = (uint)bits[2];                  }                  InternalSign = ((bits[3] & int.MinValue) == 0 ? 1 : -1);              }              else              {                  InternalSign = bits[0];                  InternalSign = InternalSign * ((bits[3] & int.MinValue) == 0 ? 1 : -1);                  InternalBits = null;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,BigInteger,The following statement contains a magic number: if (size == 0)              {                  this = _bigIntegerZeroInt;              }              else if (size != 1 || bits[0] <= 0)              {                  InternalBits = new uint[size];                  InternalBits[0] = (uint)bits[0];                  if (size > 1)                  {                      InternalBits[1] = (uint)bits[1];                  }                  if (size > 2)                  {                      InternalBits[2] = (uint)bits[2];                  }                  InternalSign = ((bits[3] & int.MinValue) == 0 ? 1 : -1);              }              else              {                  InternalSign = bits[0];                  InternalSign = InternalSign * ((bits[3] & int.MinValue) == 0 ? 1 : -1);                  InternalBits = null;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,BigInteger,The following statement contains a magic number: var isNegative = (valueLength > 0 && (value[valueLength - 1] & 128) == 128);
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,BigInteger,The following statement contains a magic number: var isNegative = (valueLength > 0 && (value[valueLength - 1] & 128) == 128);
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,BigInteger,The following statement contains a magic number: if (valueLength > 4)              {                  var unalignedBytes = valueLength % 4;                  var dwordCount = valueLength / 4 + (unalignedBytes == 0 ? 0 : 1);                  var isZero = true;                  var internalBits = new uint[dwordCount];                  var byteIndex = 3;                  var dwordIndex = 0;                  for (; dwordIndex < dwordCount - (unalignedBytes == 0 ? 0 : 1); dwordIndex++)                  {                      for (var byteInDword = 0; byteInDword < 4; byteInDword++)                      {                          isZero &= value[byteIndex] == 0;                          internalBits[dwordIndex] <<= 8;                          internalBits[dwordIndex] |= value[byteIndex];                          byteIndex--;                      }                      byteIndex += 8;                  }                  if (unalignedBytes != 0)                  {                      if (isNegative)                      {                          internalBits[dwordCount - 1] = 0xffffffff;                      }                      for (byteIndex = valueLength - 1; byteIndex >= valueLength - unalignedBytes; byteIndex--)                      {                          isZero &= value[byteIndex] == 0;                          internalBits[dwordIndex] <<= 8;                          internalBits[dwordIndex] |= value[byteIndex];                      }                  }                  if (isZero)                  {                      this = _bigIntegerZeroInt;                  }                  else if (isNegative)                  {                      NumericsHelpers.DangerousMakeTwosComplement(internalBits);                      dwordCount = internalBits.Length;                      while (dwordCount > 0 && internalBits[dwordCount - 1] == 0)                      {                          dwordCount--;                      }                      if (dwordCount == 1 && internalBits[0] > 0)                      {                          switch (internalBits[0])                          {                              case 1:                                  this = _bigIntegerMinusOneInt;                                  break;                                case unchecked((uint)int.MinValue):                                  this = _bigIntegerMinInt;                                  break;                                default:                                  InternalSign = -1;                                  InternalBits = internalBits;                                  break;                          }                      }                      else                      {                          if (dwordCount == internalBits.Length)                          {                              InternalSign = -1;                              InternalBits = internalBits;                          }                          else                          {                              InternalSign = -1;                              InternalBits = new uint[dwordCount];                              Array.Copy(internalBits' InternalBits' dwordCount);                          }                      }                  }                  else                  {                      InternalSign = 1;                      InternalBits = internalBits;                  }              }              else              {                  if (isNegative)                  {                      InternalSign = -1;                  }                  else                  {                      InternalSign = 0;                  }                  for (var index = valueLength - 1; index >= 0; index--)                  {                      InternalSign <<= 8;                      InternalSign |= value[index];                  }                  InternalBits = null;                  if (InternalSign < 0 && !isNegative)                  {                      InternalBits = new uint[1];                      InternalBits[0] = (uint)InternalSign;                      InternalSign = 1;                  }                  if (InternalSign == int.MinValue)                  {                      this = _bigIntegerMinInt;                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,BigInteger,The following statement contains a magic number: if (valueLength > 4)              {                  var unalignedBytes = valueLength % 4;                  var dwordCount = valueLength / 4 + (unalignedBytes == 0 ? 0 : 1);                  var isZero = true;                  var internalBits = new uint[dwordCount];                  var byteIndex = 3;                  var dwordIndex = 0;                  for (; dwordIndex < dwordCount - (unalignedBytes == 0 ? 0 : 1); dwordIndex++)                  {                      for (var byteInDword = 0; byteInDword < 4; byteInDword++)                      {                          isZero &= value[byteIndex] == 0;                          internalBits[dwordIndex] <<= 8;                          internalBits[dwordIndex] |= value[byteIndex];                          byteIndex--;                      }                      byteIndex += 8;                  }                  if (unalignedBytes != 0)                  {                      if (isNegative)                      {                          internalBits[dwordCount - 1] = 0xffffffff;                      }                      for (byteIndex = valueLength - 1; byteIndex >= valueLength - unalignedBytes; byteIndex--)                      {                          isZero &= value[byteIndex] == 0;                          internalBits[dwordIndex] <<= 8;                          internalBits[dwordIndex] |= value[byteIndex];                      }                  }                  if (isZero)                  {                      this = _bigIntegerZeroInt;                  }                  else if (isNegative)                  {                      NumericsHelpers.DangerousMakeTwosComplement(internalBits);                      dwordCount = internalBits.Length;                      while (dwordCount > 0 && internalBits[dwordCount - 1] == 0)                      {                          dwordCount--;                      }                      if (dwordCount == 1 && internalBits[0] > 0)                      {                          switch (internalBits[0])                          {                              case 1:                                  this = _bigIntegerMinusOneInt;                                  break;                                case unchecked((uint)int.MinValue):                                  this = _bigIntegerMinInt;                                  break;                                default:                                  InternalSign = -1;                                  InternalBits = internalBits;                                  break;                          }                      }                      else                      {                          if (dwordCount == internalBits.Length)                          {                              InternalSign = -1;                              InternalBits = internalBits;                          }                          else                          {                              InternalSign = -1;                              InternalBits = new uint[dwordCount];                              Array.Copy(internalBits' InternalBits' dwordCount);                          }                      }                  }                  else                  {                      InternalSign = 1;                      InternalBits = internalBits;                  }              }              else              {                  if (isNegative)                  {                      InternalSign = -1;                  }                  else                  {                      InternalSign = 0;                  }                  for (var index = valueLength - 1; index >= 0; index--)                  {                      InternalSign <<= 8;                      InternalSign |= value[index];                  }                  InternalBits = null;                  if (InternalSign < 0 && !isNegative)                  {                      InternalBits = new uint[1];                      InternalBits[0] = (uint)InternalSign;                      InternalSign = 1;                  }                  if (InternalSign == int.MinValue)                  {                      this = _bigIntegerMinInt;                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,BigInteger,The following statement contains a magic number: if (valueLength > 4)              {                  var unalignedBytes = valueLength % 4;                  var dwordCount = valueLength / 4 + (unalignedBytes == 0 ? 0 : 1);                  var isZero = true;                  var internalBits = new uint[dwordCount];                  var byteIndex = 3;                  var dwordIndex = 0;                  for (; dwordIndex < dwordCount - (unalignedBytes == 0 ? 0 : 1); dwordIndex++)                  {                      for (var byteInDword = 0; byteInDword < 4; byteInDword++)                      {                          isZero &= value[byteIndex] == 0;                          internalBits[dwordIndex] <<= 8;                          internalBits[dwordIndex] |= value[byteIndex];                          byteIndex--;                      }                      byteIndex += 8;                  }                  if (unalignedBytes != 0)                  {                      if (isNegative)                      {                          internalBits[dwordCount - 1] = 0xffffffff;                      }                      for (byteIndex = valueLength - 1; byteIndex >= valueLength - unalignedBytes; byteIndex--)                      {                          isZero &= value[byteIndex] == 0;                          internalBits[dwordIndex] <<= 8;                          internalBits[dwordIndex] |= value[byteIndex];                      }                  }                  if (isZero)                  {                      this = _bigIntegerZeroInt;                  }                  else if (isNegative)                  {                      NumericsHelpers.DangerousMakeTwosComplement(internalBits);                      dwordCount = internalBits.Length;                      while (dwordCount > 0 && internalBits[dwordCount - 1] == 0)                      {                          dwordCount--;                      }                      if (dwordCount == 1 && internalBits[0] > 0)                      {                          switch (internalBits[0])                          {                              case 1:                                  this = _bigIntegerMinusOneInt;                                  break;                                case unchecked((uint)int.MinValue):                                  this = _bigIntegerMinInt;                                  break;                                default:                                  InternalSign = -1;                                  InternalBits = internalBits;                                  break;                          }                      }                      else                      {                          if (dwordCount == internalBits.Length)                          {                              InternalSign = -1;                              InternalBits = internalBits;                          }                          else                          {                              InternalSign = -1;                              InternalBits = new uint[dwordCount];                              Array.Copy(internalBits' InternalBits' dwordCount);                          }                      }                  }                  else                  {                      InternalSign = 1;                      InternalBits = internalBits;                  }              }              else              {                  if (isNegative)                  {                      InternalSign = -1;                  }                  else                  {                      InternalSign = 0;                  }                  for (var index = valueLength - 1; index >= 0; index--)                  {                      InternalSign <<= 8;                      InternalSign |= value[index];                  }                  InternalBits = null;                  if (InternalSign < 0 && !isNegative)                  {                      InternalBits = new uint[1];                      InternalBits[0] = (uint)InternalSign;                      InternalSign = 1;                  }                  if (InternalSign == int.MinValue)                  {                      this = _bigIntegerMinInt;                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,BigInteger,The following statement contains a magic number: if (valueLength > 4)              {                  var unalignedBytes = valueLength % 4;                  var dwordCount = valueLength / 4 + (unalignedBytes == 0 ? 0 : 1);                  var isZero = true;                  var internalBits = new uint[dwordCount];                  var byteIndex = 3;                  var dwordIndex = 0;                  for (; dwordIndex < dwordCount - (unalignedBytes == 0 ? 0 : 1); dwordIndex++)                  {                      for (var byteInDword = 0; byteInDword < 4; byteInDword++)                      {                          isZero &= value[byteIndex] == 0;                          internalBits[dwordIndex] <<= 8;                          internalBits[dwordIndex] |= value[byteIndex];                          byteIndex--;                      }                      byteIndex += 8;                  }                  if (unalignedBytes != 0)                  {                      if (isNegative)                      {                          internalBits[dwordCount - 1] = 0xffffffff;                      }                      for (byteIndex = valueLength - 1; byteIndex >= valueLength - unalignedBytes; byteIndex--)                      {                          isZero &= value[byteIndex] == 0;                          internalBits[dwordIndex] <<= 8;                          internalBits[dwordIndex] |= value[byteIndex];                      }                  }                  if (isZero)                  {                      this = _bigIntegerZeroInt;                  }                  else if (isNegative)                  {                      NumericsHelpers.DangerousMakeTwosComplement(internalBits);                      dwordCount = internalBits.Length;                      while (dwordCount > 0 && internalBits[dwordCount - 1] == 0)                      {                          dwordCount--;                      }                      if (dwordCount == 1 && internalBits[0] > 0)                      {                          switch (internalBits[0])                          {                              case 1:                                  this = _bigIntegerMinusOneInt;                                  break;                                case unchecked((uint)int.MinValue):                                  this = _bigIntegerMinInt;                                  break;                                default:                                  InternalSign = -1;                                  InternalBits = internalBits;                                  break;                          }                      }                      else                      {                          if (dwordCount == internalBits.Length)                          {                              InternalSign = -1;                              InternalBits = internalBits;                          }                          else                          {                              InternalSign = -1;                              InternalBits = new uint[dwordCount];                              Array.Copy(internalBits' InternalBits' dwordCount);                          }                      }                  }                  else                  {                      InternalSign = 1;                      InternalBits = internalBits;                  }              }              else              {                  if (isNegative)                  {                      InternalSign = -1;                  }                  else                  {                      InternalSign = 0;                  }                  for (var index = valueLength - 1; index >= 0; index--)                  {                      InternalSign <<= 8;                      InternalSign |= value[index];                  }                  InternalBits = null;                  if (InternalSign < 0 && !isNegative)                  {                      InternalBits = new uint[1];                      InternalBits[0] = (uint)InternalSign;                      InternalSign = 1;                  }                  if (InternalSign == int.MinValue)                  {                      this = _bigIntegerMinInt;                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,BigInteger,The following statement contains a magic number: if (valueLength > 4)              {                  var unalignedBytes = valueLength % 4;                  var dwordCount = valueLength / 4 + (unalignedBytes == 0 ? 0 : 1);                  var isZero = true;                  var internalBits = new uint[dwordCount];                  var byteIndex = 3;                  var dwordIndex = 0;                  for (; dwordIndex < dwordCount - (unalignedBytes == 0 ? 0 : 1); dwordIndex++)                  {                      for (var byteInDword = 0; byteInDword < 4; byteInDword++)                      {                          isZero &= value[byteIndex] == 0;                          internalBits[dwordIndex] <<= 8;                          internalBits[dwordIndex] |= value[byteIndex];                          byteIndex--;                      }                      byteIndex += 8;                  }                  if (unalignedBytes != 0)                  {                      if (isNegative)                      {                          internalBits[dwordCount - 1] = 0xffffffff;                      }                      for (byteIndex = valueLength - 1; byteIndex >= valueLength - unalignedBytes; byteIndex--)                      {                          isZero &= value[byteIndex] == 0;                          internalBits[dwordIndex] <<= 8;                          internalBits[dwordIndex] |= value[byteIndex];                      }                  }                  if (isZero)                  {                      this = _bigIntegerZeroInt;                  }                  else if (isNegative)                  {                      NumericsHelpers.DangerousMakeTwosComplement(internalBits);                      dwordCount = internalBits.Length;                      while (dwordCount > 0 && internalBits[dwordCount - 1] == 0)                      {                          dwordCount--;                      }                      if (dwordCount == 1 && internalBits[0] > 0)                      {                          switch (internalBits[0])                          {                              case 1:                                  this = _bigIntegerMinusOneInt;                                  break;                                case unchecked((uint)int.MinValue):                                  this = _bigIntegerMinInt;                                  break;                                default:                                  InternalSign = -1;                                  InternalBits = internalBits;                                  break;                          }                      }                      else                      {                          if (dwordCount == internalBits.Length)                          {                              InternalSign = -1;                              InternalBits = internalBits;                          }                          else                          {                              InternalSign = -1;                              InternalBits = new uint[dwordCount];                              Array.Copy(internalBits' InternalBits' dwordCount);                          }                      }                  }                  else                  {                      InternalSign = 1;                      InternalBits = internalBits;                  }              }              else              {                  if (isNegative)                  {                      InternalSign = -1;                  }                  else                  {                      InternalSign = 0;                  }                  for (var index = valueLength - 1; index >= 0; index--)                  {                      InternalSign <<= 8;                      InternalSign |= value[index];                  }                  InternalBits = null;                  if (InternalSign < 0 && !isNegative)                  {                      InternalBits = new uint[1];                      InternalBits[0] = (uint)InternalSign;                      InternalSign = 1;                  }                  if (InternalSign == int.MinValue)                  {                      this = _bigIntegerMinInt;                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,BigInteger,The following statement contains a magic number: if (valueLength > 4)              {                  var unalignedBytes = valueLength % 4;                  var dwordCount = valueLength / 4 + (unalignedBytes == 0 ? 0 : 1);                  var isZero = true;                  var internalBits = new uint[dwordCount];                  var byteIndex = 3;                  var dwordIndex = 0;                  for (; dwordIndex < dwordCount - (unalignedBytes == 0 ? 0 : 1); dwordIndex++)                  {                      for (var byteInDword = 0; byteInDword < 4; byteInDword++)                      {                          isZero &= value[byteIndex] == 0;                          internalBits[dwordIndex] <<= 8;                          internalBits[dwordIndex] |= value[byteIndex];                          byteIndex--;                      }                      byteIndex += 8;                  }                  if (unalignedBytes != 0)                  {                      if (isNegative)                      {                          internalBits[dwordCount - 1] = 0xffffffff;                      }                      for (byteIndex = valueLength - 1; byteIndex >= valueLength - unalignedBytes; byteIndex--)                      {                          isZero &= value[byteIndex] == 0;                          internalBits[dwordIndex] <<= 8;                          internalBits[dwordIndex] |= value[byteIndex];                      }                  }                  if (isZero)                  {                      this = _bigIntegerZeroInt;                  }                  else if (isNegative)                  {                      NumericsHelpers.DangerousMakeTwosComplement(internalBits);                      dwordCount = internalBits.Length;                      while (dwordCount > 0 && internalBits[dwordCount - 1] == 0)                      {                          dwordCount--;                      }                      if (dwordCount == 1 && internalBits[0] > 0)                      {                          switch (internalBits[0])                          {                              case 1:                                  this = _bigIntegerMinusOneInt;                                  break;                                case unchecked((uint)int.MinValue):                                  this = _bigIntegerMinInt;                                  break;                                default:                                  InternalSign = -1;                                  InternalBits = internalBits;                                  break;                          }                      }                      else                      {                          if (dwordCount == internalBits.Length)                          {                              InternalSign = -1;                              InternalBits = internalBits;                          }                          else                          {                              InternalSign = -1;                              InternalBits = new uint[dwordCount];                              Array.Copy(internalBits' InternalBits' dwordCount);                          }                      }                  }                  else                  {                      InternalSign = 1;                      InternalBits = internalBits;                  }              }              else              {                  if (isNegative)                  {                      InternalSign = -1;                  }                  else                  {                      InternalSign = 0;                  }                  for (var index = valueLength - 1; index >= 0; index--)                  {                      InternalSign <<= 8;                      InternalSign |= value[index];                  }                  InternalBits = null;                  if (InternalSign < 0 && !isNegative)                  {                      InternalBits = new uint[1];                      InternalBits[0] = (uint)InternalSign;                      InternalSign = 1;                  }                  if (InternalSign == int.MinValue)                  {                      this = _bigIntegerMinInt;                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,BigInteger,The following statement contains a magic number: if (valueLength > 4)              {                  var unalignedBytes = valueLength % 4;                  var dwordCount = valueLength / 4 + (unalignedBytes == 0 ? 0 : 1);                  var isZero = true;                  var internalBits = new uint[dwordCount];                  var byteIndex = 3;                  var dwordIndex = 0;                  for (; dwordIndex < dwordCount - (unalignedBytes == 0 ? 0 : 1); dwordIndex++)                  {                      for (var byteInDword = 0; byteInDword < 4; byteInDword++)                      {                          isZero &= value[byteIndex] == 0;                          internalBits[dwordIndex] <<= 8;                          internalBits[dwordIndex] |= value[byteIndex];                          byteIndex--;                      }                      byteIndex += 8;                  }                  if (unalignedBytes != 0)                  {                      if (isNegative)                      {                          internalBits[dwordCount - 1] = 0xffffffff;                      }                      for (byteIndex = valueLength - 1; byteIndex >= valueLength - unalignedBytes; byteIndex--)                      {                          isZero &= value[byteIndex] == 0;                          internalBits[dwordIndex] <<= 8;                          internalBits[dwordIndex] |= value[byteIndex];                      }                  }                  if (isZero)                  {                      this = _bigIntegerZeroInt;                  }                  else if (isNegative)                  {                      NumericsHelpers.DangerousMakeTwosComplement(internalBits);                      dwordCount = internalBits.Length;                      while (dwordCount > 0 && internalBits[dwordCount - 1] == 0)                      {                          dwordCount--;                      }                      if (dwordCount == 1 && internalBits[0] > 0)                      {                          switch (internalBits[0])                          {                              case 1:                                  this = _bigIntegerMinusOneInt;                                  break;                                case unchecked((uint)int.MinValue):                                  this = _bigIntegerMinInt;                                  break;                                default:                                  InternalSign = -1;                                  InternalBits = internalBits;                                  break;                          }                      }                      else                      {                          if (dwordCount == internalBits.Length)                          {                              InternalSign = -1;                              InternalBits = internalBits;                          }                          else                          {                              InternalSign = -1;                              InternalBits = new uint[dwordCount];                              Array.Copy(internalBits' InternalBits' dwordCount);                          }                      }                  }                  else                  {                      InternalSign = 1;                      InternalBits = internalBits;                  }              }              else              {                  if (isNegative)                  {                      InternalSign = -1;                  }                  else                  {                      InternalSign = 0;                  }                  for (var index = valueLength - 1; index >= 0; index--)                  {                      InternalSign <<= 8;                      InternalSign |= value[index];                  }                  InternalBits = null;                  if (InternalSign < 0 && !isNegative)                  {                      InternalBits = new uint[1];                      InternalBits[0] = (uint)InternalSign;                      InternalSign = 1;                  }                  if (InternalSign == int.MinValue)                  {                      this = _bigIntegerMinInt;                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,BigInteger,The following statement contains a magic number: if (valueLength > 4)              {                  var unalignedBytes = valueLength % 4;                  var dwordCount = valueLength / 4 + (unalignedBytes == 0 ? 0 : 1);                  var isZero = true;                  var internalBits = new uint[dwordCount];                  var byteIndex = 3;                  var dwordIndex = 0;                  for (; dwordIndex < dwordCount - (unalignedBytes == 0 ? 0 : 1); dwordIndex++)                  {                      for (var byteInDword = 0; byteInDword < 4; byteInDword++)                      {                          isZero &= value[byteIndex] == 0;                          internalBits[dwordIndex] <<= 8;                          internalBits[dwordIndex] |= value[byteIndex];                          byteIndex--;                      }                      byteIndex += 8;                  }                  if (unalignedBytes != 0)                  {                      if (isNegative)                      {                          internalBits[dwordCount - 1] = 0xffffffff;                      }                      for (byteIndex = valueLength - 1; byteIndex >= valueLength - unalignedBytes; byteIndex--)                      {                          isZero &= value[byteIndex] == 0;                          internalBits[dwordIndex] <<= 8;                          internalBits[dwordIndex] |= value[byteIndex];                      }                  }                  if (isZero)                  {                      this = _bigIntegerZeroInt;                  }                  else if (isNegative)                  {                      NumericsHelpers.DangerousMakeTwosComplement(internalBits);                      dwordCount = internalBits.Length;                      while (dwordCount > 0 && internalBits[dwordCount - 1] == 0)                      {                          dwordCount--;                      }                      if (dwordCount == 1 && internalBits[0] > 0)                      {                          switch (internalBits[0])                          {                              case 1:                                  this = _bigIntegerMinusOneInt;                                  break;                                case unchecked((uint)int.MinValue):                                  this = _bigIntegerMinInt;                                  break;                                default:                                  InternalSign = -1;                                  InternalBits = internalBits;                                  break;                          }                      }                      else                      {                          if (dwordCount == internalBits.Length)                          {                              InternalSign = -1;                              InternalBits = internalBits;                          }                          else                          {                              InternalSign = -1;                              InternalBits = new uint[dwordCount];                              Array.Copy(internalBits' InternalBits' dwordCount);                          }                      }                  }                  else                  {                      InternalSign = 1;                      InternalBits = internalBits;                  }              }              else              {                  if (isNegative)                  {                      InternalSign = -1;                  }                  else                  {                      InternalSign = 0;                  }                  for (var index = valueLength - 1; index >= 0; index--)                  {                      InternalSign <<= 8;                      InternalSign |= value[index];                  }                  InternalBits = null;                  if (InternalSign < 0 && !isNegative)                  {                      InternalBits = new uint[1];                      InternalBits[0] = (uint)InternalSign;                      InternalSign = 1;                  }                  if (InternalSign == int.MinValue)                  {                      this = _bigIntegerMinInt;                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,BigInteger,The following statement contains a magic number: if (valueLength > 4)              {                  var unalignedBytes = valueLength % 4;                  var dwordCount = valueLength / 4 + (unalignedBytes == 0 ? 0 : 1);                  var isZero = true;                  var internalBits = new uint[dwordCount];                  var byteIndex = 3;                  var dwordIndex = 0;                  for (; dwordIndex < dwordCount - (unalignedBytes == 0 ? 0 : 1); dwordIndex++)                  {                      for (var byteInDword = 0; byteInDword < 4; byteInDword++)                      {                          isZero &= value[byteIndex] == 0;                          internalBits[dwordIndex] <<= 8;                          internalBits[dwordIndex] |= value[byteIndex];                          byteIndex--;                      }                      byteIndex += 8;                  }                  if (unalignedBytes != 0)                  {                      if (isNegative)                      {                          internalBits[dwordCount - 1] = 0xffffffff;                      }                      for (byteIndex = valueLength - 1; byteIndex >= valueLength - unalignedBytes; byteIndex--)                      {                          isZero &= value[byteIndex] == 0;                          internalBits[dwordIndex] <<= 8;                          internalBits[dwordIndex] |= value[byteIndex];                      }                  }                  if (isZero)                  {                      this = _bigIntegerZeroInt;                  }                  else if (isNegative)                  {                      NumericsHelpers.DangerousMakeTwosComplement(internalBits);                      dwordCount = internalBits.Length;                      while (dwordCount > 0 && internalBits[dwordCount - 1] == 0)                      {                          dwordCount--;                      }                      if (dwordCount == 1 && internalBits[0] > 0)                      {                          switch (internalBits[0])                          {                              case 1:                                  this = _bigIntegerMinusOneInt;                                  break;                                case unchecked((uint)int.MinValue):                                  this = _bigIntegerMinInt;                                  break;                                default:                                  InternalSign = -1;                                  InternalBits = internalBits;                                  break;                          }                      }                      else                      {                          if (dwordCount == internalBits.Length)                          {                              InternalSign = -1;                              InternalBits = internalBits;                          }                          else                          {                              InternalSign = -1;                              InternalBits = new uint[dwordCount];                              Array.Copy(internalBits' InternalBits' dwordCount);                          }                      }                  }                  else                  {                      InternalSign = 1;                      InternalBits = internalBits;                  }              }              else              {                  if (isNegative)                  {                      InternalSign = -1;                  }                  else                  {                      InternalSign = 0;                  }                  for (var index = valueLength - 1; index >= 0; index--)                  {                      InternalSign <<= 8;                      InternalSign |= value[index];                  }                  InternalBits = null;                  if (InternalSign < 0 && !isNegative)                  {                      InternalBits = new uint[1];                      InternalBits[0] = (uint)InternalSign;                      InternalSign = 1;                  }                  if (InternalSign == int.MinValue)                  {                      this = _bigIntegerMinInt;                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,CompareTo,The following statement contains a magic number: if ((InternalSign ^ other) >= 0)              {                  var length = Length(InternalBits);                  if (length <= 2)                  {                      var magnitude = (other >= 0 ? (ulong)other : (ulong)(-other));                      var unsigned = (length != 2 ? InternalBits[0] : NumericsHelpers.MakeUlong(InternalBits[1]' InternalBits[0]));                      return InternalSign * unsigned.CompareTo(magnitude);                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,CompareTo,The following statement contains a magic number: if ((InternalSign ^ other) >= 0)              {                  var length = Length(InternalBits);                  if (length <= 2)                  {                      var magnitude = (other >= 0 ? (ulong)other : (ulong)(-other));                      var unsigned = (length != 2 ? InternalBits[0] : NumericsHelpers.MakeUlong(InternalBits[1]' InternalBits[0]));                      return InternalSign * unsigned.CompareTo(magnitude);                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,CompareTo,The following statement contains a magic number: if (length > 2)              {                  return 1;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,CompareTo,The following statement contains a magic number: return ((length != 2 ? InternalBits[0] : NumericsHelpers.MakeUlong(InternalBits[1]' InternalBits[0]))).CompareTo(other);
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,Equals,The following statement contains a magic number: if ((InternalSign ^ other) >= 0)              {                  var length = Length(InternalBits);                  if (length <= 2)                  {                      var magnitude = (other >= 0 ? (ulong)other : (ulong)(-other));                      if (length == 1)                      {                          return InternalBits[0] == magnitude;                      }                      return NumericsHelpers.MakeUlong(InternalBits[1]' InternalBits[0]) == magnitude;                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,Equals,The following statement contains a magic number: if (length > 2)              {                  return false;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,Log,The following statement contains a magic number: var d = 0.5;
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,Log,The following statement contains a magic number: var bitlen = (length - 1) * 32 + topbits;
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,Log,The following statement contains a magic number: var indbit = (uint)(1 << (topbits - 1 & 31));
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,Log,The following statement contains a magic number: for (var index = length - 1; index >= 0; index--)              {                  while (indbit != 0)                  {                      if ((value.InternalBits[index] & indbit) != 0)                      {                          c = c + d;                      }                      d = d * 0.5;                      indbit = indbit >> 1;                  }                  indbit = unchecked((uint)int.MinValue);              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,Log10,The following statement contains a magic number: return Log(value' 10);
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,ModPowInner32,The following statement contains a magic number: for (var index = 0; index < 32; index++)              {                  if ((exp & 1) == 1)                  {                      ModPowUpdateResult(ref regRes' ref regVal' ref regMod' ref regTmp);                  }                  ModPowSquareModValue(ref regVal' ref regMod' ref regTmp);                  exp = exp >> 1;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetBitsFromDouble,The following statement contains a magic number: if (valueExp <= 0)              {                  if (valueExp <= -64)                  {                      return;                  }                  var tmp = valueMan >> (-valueExp & 63);                  if (tmp > int.MaxValue)                  {                      sign = 1;                      bits = new[] { (uint)tmp' (uint)(tmp >> 32) };                  }                  else                  {                      sign = (int)tmp;                  }                  if (valueSign < 0)                  {                      sign = -sign;                  }              }              else if (valueExp > 11)              {                  valueMan = valueMan << 11;                  valueExp = valueExp - 11;                  var significantDword = (valueExp - 1) / 32 + 1;                  var extraDword = significantDword * 32 - valueExp;                  bits = new uint[significantDword + 2];                  bits[significantDword + 1] = (uint)(valueMan >> (extraDword + 32 & 63));                  bits[significantDword] = (uint)(valueMan >> (extraDword & 63));                  if (extraDword > 0)                  {                      bits[significantDword - 1] = (uint)valueMan << (32 - extraDword & 31);                  }                  sign = valueSign;              }              else              {                  var tmp = valueMan << (valueExp & 63);                  if (tmp > int.MaxValue)                  {                      sign = 1;                      bits = new[] { (uint)tmp' (uint)(tmp >> 32) };                  }                  else                  {                      sign = (int)tmp;                  }                  if (valueSign < 0)                  {                      sign = -sign;                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetBitsFromDouble,The following statement contains a magic number: if (valueExp <= 0)              {                  if (valueExp <= -64)                  {                      return;                  }                  var tmp = valueMan >> (-valueExp & 63);                  if (tmp > int.MaxValue)                  {                      sign = 1;                      bits = new[] { (uint)tmp' (uint)(tmp >> 32) };                  }                  else                  {                      sign = (int)tmp;                  }                  if (valueSign < 0)                  {                      sign = -sign;                  }              }              else if (valueExp > 11)              {                  valueMan = valueMan << 11;                  valueExp = valueExp - 11;                  var significantDword = (valueExp - 1) / 32 + 1;                  var extraDword = significantDword * 32 - valueExp;                  bits = new uint[significantDword + 2];                  bits[significantDword + 1] = (uint)(valueMan >> (extraDword + 32 & 63));                  bits[significantDword] = (uint)(valueMan >> (extraDword & 63));                  if (extraDword > 0)                  {                      bits[significantDword - 1] = (uint)valueMan << (32 - extraDword & 31);                  }                  sign = valueSign;              }              else              {                  var tmp = valueMan << (valueExp & 63);                  if (tmp > int.MaxValue)                  {                      sign = 1;                      bits = new[] { (uint)tmp' (uint)(tmp >> 32) };                  }                  else                  {                      sign = (int)tmp;                  }                  if (valueSign < 0)                  {                      sign = -sign;                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetBitsFromDouble,The following statement contains a magic number: if (valueExp <= 0)              {                  if (valueExp <= -64)                  {                      return;                  }                  var tmp = valueMan >> (-valueExp & 63);                  if (tmp > int.MaxValue)                  {                      sign = 1;                      bits = new[] { (uint)tmp' (uint)(tmp >> 32) };                  }                  else                  {                      sign = (int)tmp;                  }                  if (valueSign < 0)                  {                      sign = -sign;                  }              }              else if (valueExp > 11)              {                  valueMan = valueMan << 11;                  valueExp = valueExp - 11;                  var significantDword = (valueExp - 1) / 32 + 1;                  var extraDword = significantDword * 32 - valueExp;                  bits = new uint[significantDword + 2];                  bits[significantDword + 1] = (uint)(valueMan >> (extraDword + 32 & 63));                  bits[significantDword] = (uint)(valueMan >> (extraDword & 63));                  if (extraDword > 0)                  {                      bits[significantDword - 1] = (uint)valueMan << (32 - extraDword & 31);                  }                  sign = valueSign;              }              else              {                  var tmp = valueMan << (valueExp & 63);                  if (tmp > int.MaxValue)                  {                      sign = 1;                      bits = new[] { (uint)tmp' (uint)(tmp >> 32) };                  }                  else                  {                      sign = (int)tmp;                  }                  if (valueSign < 0)                  {                      sign = -sign;                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetBitsFromDouble,The following statement contains a magic number: if (valueExp <= 0)              {                  if (valueExp <= -64)                  {                      return;                  }                  var tmp = valueMan >> (-valueExp & 63);                  if (tmp > int.MaxValue)                  {                      sign = 1;                      bits = new[] { (uint)tmp' (uint)(tmp >> 32) };                  }                  else                  {                      sign = (int)tmp;                  }                  if (valueSign < 0)                  {                      sign = -sign;                  }              }              else if (valueExp > 11)              {                  valueMan = valueMan << 11;                  valueExp = valueExp - 11;                  var significantDword = (valueExp - 1) / 32 + 1;                  var extraDword = significantDword * 32 - valueExp;                  bits = new uint[significantDword + 2];                  bits[significantDword + 1] = (uint)(valueMan >> (extraDword + 32 & 63));                  bits[significantDword] = (uint)(valueMan >> (extraDword & 63));                  if (extraDword > 0)                  {                      bits[significantDword - 1] = (uint)valueMan << (32 - extraDword & 31);                  }                  sign = valueSign;              }              else              {                  var tmp = valueMan << (valueExp & 63);                  if (tmp > int.MaxValue)                  {                      sign = 1;                      bits = new[] { (uint)tmp' (uint)(tmp >> 32) };                  }                  else                  {                      sign = (int)tmp;                  }                  if (valueSign < 0)                  {                      sign = -sign;                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetBitsFromDouble,The following statement contains a magic number: if (valueExp <= 0)              {                  if (valueExp <= -64)                  {                      return;                  }                  var tmp = valueMan >> (-valueExp & 63);                  if (tmp > int.MaxValue)                  {                      sign = 1;                      bits = new[] { (uint)tmp' (uint)(tmp >> 32) };                  }                  else                  {                      sign = (int)tmp;                  }                  if (valueSign < 0)                  {                      sign = -sign;                  }              }              else if (valueExp > 11)              {                  valueMan = valueMan << 11;                  valueExp = valueExp - 11;                  var significantDword = (valueExp - 1) / 32 + 1;                  var extraDword = significantDword * 32 - valueExp;                  bits = new uint[significantDword + 2];                  bits[significantDword + 1] = (uint)(valueMan >> (extraDword + 32 & 63));                  bits[significantDword] = (uint)(valueMan >> (extraDword & 63));                  if (extraDword > 0)                  {                      bits[significantDword - 1] = (uint)valueMan << (32 - extraDword & 31);                  }                  sign = valueSign;              }              else              {                  var tmp = valueMan << (valueExp & 63);                  if (tmp > int.MaxValue)                  {                      sign = 1;                      bits = new[] { (uint)tmp' (uint)(tmp >> 32) };                  }                  else                  {                      sign = (int)tmp;                  }                  if (valueSign < 0)                  {                      sign = -sign;                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetBitsFromDouble,The following statement contains a magic number: if (valueExp <= 0)              {                  if (valueExp <= -64)                  {                      return;                  }                  var tmp = valueMan >> (-valueExp & 63);                  if (tmp > int.MaxValue)                  {                      sign = 1;                      bits = new[] { (uint)tmp' (uint)(tmp >> 32) };                  }                  else                  {                      sign = (int)tmp;                  }                  if (valueSign < 0)                  {                      sign = -sign;                  }              }              else if (valueExp > 11)              {                  valueMan = valueMan << 11;                  valueExp = valueExp - 11;                  var significantDword = (valueExp - 1) / 32 + 1;                  var extraDword = significantDword * 32 - valueExp;                  bits = new uint[significantDword + 2];                  bits[significantDword + 1] = (uint)(valueMan >> (extraDword + 32 & 63));                  bits[significantDword] = (uint)(valueMan >> (extraDword & 63));                  if (extraDword > 0)                  {                      bits[significantDword - 1] = (uint)valueMan << (32 - extraDword & 31);                  }                  sign = valueSign;              }              else              {                  var tmp = valueMan << (valueExp & 63);                  if (tmp > int.MaxValue)                  {                      sign = 1;                      bits = new[] { (uint)tmp' (uint)(tmp >> 32) };                  }                  else                  {                      sign = (int)tmp;                  }                  if (valueSign < 0)                  {                      sign = -sign;                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetBitsFromDouble,The following statement contains a magic number: if (valueExp <= 0)              {                  if (valueExp <= -64)                  {                      return;                  }                  var tmp = valueMan >> (-valueExp & 63);                  if (tmp > int.MaxValue)                  {                      sign = 1;                      bits = new[] { (uint)tmp' (uint)(tmp >> 32) };                  }                  else                  {                      sign = (int)tmp;                  }                  if (valueSign < 0)                  {                      sign = -sign;                  }              }              else if (valueExp > 11)              {                  valueMan = valueMan << 11;                  valueExp = valueExp - 11;                  var significantDword = (valueExp - 1) / 32 + 1;                  var extraDword = significantDword * 32 - valueExp;                  bits = new uint[significantDword + 2];                  bits[significantDword + 1] = (uint)(valueMan >> (extraDword + 32 & 63));                  bits[significantDword] = (uint)(valueMan >> (extraDword & 63));                  if (extraDword > 0)                  {                      bits[significantDword - 1] = (uint)valueMan << (32 - extraDword & 31);                  }                  sign = valueSign;              }              else              {                  var tmp = valueMan << (valueExp & 63);                  if (tmp > int.MaxValue)                  {                      sign = 1;                      bits = new[] { (uint)tmp' (uint)(tmp >> 32) };                  }                  else                  {                      sign = (int)tmp;                  }                  if (valueSign < 0)                  {                      sign = -sign;                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetBitsFromDouble,The following statement contains a magic number: if (valueExp <= 0)              {                  if (valueExp <= -64)                  {                      return;                  }                  var tmp = valueMan >> (-valueExp & 63);                  if (tmp > int.MaxValue)                  {                      sign = 1;                      bits = new[] { (uint)tmp' (uint)(tmp >> 32) };                  }                  else                  {                      sign = (int)tmp;                  }                  if (valueSign < 0)                  {                      sign = -sign;                  }              }              else if (valueExp > 11)              {                  valueMan = valueMan << 11;                  valueExp = valueExp - 11;                  var significantDword = (valueExp - 1) / 32 + 1;                  var extraDword = significantDword * 32 - valueExp;                  bits = new uint[significantDword + 2];                  bits[significantDword + 1] = (uint)(valueMan >> (extraDword + 32 & 63));                  bits[significantDword] = (uint)(valueMan >> (extraDword & 63));                  if (extraDword > 0)                  {                      bits[significantDword - 1] = (uint)valueMan << (32 - extraDword & 31);                  }                  sign = valueSign;              }              else              {                  var tmp = valueMan << (valueExp & 63);                  if (tmp > int.MaxValue)                  {                      sign = 1;                      bits = new[] { (uint)tmp' (uint)(tmp >> 32) };                  }                  else                  {                      sign = (int)tmp;                  }                  if (valueSign < 0)                  {                      sign = -sign;                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetBitsFromDouble,The following statement contains a magic number: if (valueExp <= 0)              {                  if (valueExp <= -64)                  {                      return;                  }                  var tmp = valueMan >> (-valueExp & 63);                  if (tmp > int.MaxValue)                  {                      sign = 1;                      bits = new[] { (uint)tmp' (uint)(tmp >> 32) };                  }                  else                  {                      sign = (int)tmp;                  }                  if (valueSign < 0)                  {                      sign = -sign;                  }              }              else if (valueExp > 11)              {                  valueMan = valueMan << 11;                  valueExp = valueExp - 11;                  var significantDword = (valueExp - 1) / 32 + 1;                  var extraDword = significantDword * 32 - valueExp;                  bits = new uint[significantDword + 2];                  bits[significantDword + 1] = (uint)(valueMan >> (extraDword + 32 & 63));                  bits[significantDword] = (uint)(valueMan >> (extraDword & 63));                  if (extraDword > 0)                  {                      bits[significantDword - 1] = (uint)valueMan << (32 - extraDword & 31);                  }                  sign = valueSign;              }              else              {                  var tmp = valueMan << (valueExp & 63);                  if (tmp > int.MaxValue)                  {                      sign = 1;                      bits = new[] { (uint)tmp' (uint)(tmp >> 32) };                  }                  else                  {                      sign = (int)tmp;                  }                  if (valueSign < 0)                  {                      sign = -sign;                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetBitsFromDouble,The following statement contains a magic number: if (valueExp <= 0)              {                  if (valueExp <= -64)                  {                      return;                  }                  var tmp = valueMan >> (-valueExp & 63);                  if (tmp > int.MaxValue)                  {                      sign = 1;                      bits = new[] { (uint)tmp' (uint)(tmp >> 32) };                  }                  else                  {                      sign = (int)tmp;                  }                  if (valueSign < 0)                  {                      sign = -sign;                  }              }              else if (valueExp > 11)              {                  valueMan = valueMan << 11;                  valueExp = valueExp - 11;                  var significantDword = (valueExp - 1) / 32 + 1;                  var extraDword = significantDword * 32 - valueExp;                  bits = new uint[significantDword + 2];                  bits[significantDword + 1] = (uint)(valueMan >> (extraDword + 32 & 63));                  bits[significantDword] = (uint)(valueMan >> (extraDword & 63));                  if (extraDword > 0)                  {                      bits[significantDword - 1] = (uint)valueMan << (32 - extraDword & 31);                  }                  sign = valueSign;              }              else              {                  var tmp = valueMan << (valueExp & 63);                  if (tmp > int.MaxValue)                  {                      sign = 1;                      bits = new[] { (uint)tmp' (uint)(tmp >> 32) };                  }                  else                  {                      sign = (int)tmp;                  }                  if (valueSign < 0)                  {                      sign = -sign;                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetBitsFromDouble,The following statement contains a magic number: if (valueExp <= 0)              {                  if (valueExp <= -64)                  {                      return;                  }                  var tmp = valueMan >> (-valueExp & 63);                  if (tmp > int.MaxValue)                  {                      sign = 1;                      bits = new[] { (uint)tmp' (uint)(tmp >> 32) };                  }                  else                  {                      sign = (int)tmp;                  }                  if (valueSign < 0)                  {                      sign = -sign;                  }              }              else if (valueExp > 11)              {                  valueMan = valueMan << 11;                  valueExp = valueExp - 11;                  var significantDword = (valueExp - 1) / 32 + 1;                  var extraDword = significantDword * 32 - valueExp;                  bits = new uint[significantDword + 2];                  bits[significantDword + 1] = (uint)(valueMan >> (extraDword + 32 & 63));                  bits[significantDword] = (uint)(valueMan >> (extraDword & 63));                  if (extraDword > 0)                  {                      bits[significantDword - 1] = (uint)valueMan << (32 - extraDword & 31);                  }                  sign = valueSign;              }              else              {                  var tmp = valueMan << (valueExp & 63);                  if (tmp > int.MaxValue)                  {                      sign = 1;                      bits = new[] { (uint)tmp' (uint)(tmp >> 32) };                  }                  else                  {                      sign = (int)tmp;                  }                  if (valueSign < 0)                  {                      sign = -sign;                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetBitsFromDouble,The following statement contains a magic number: if (valueExp <= 0)              {                  if (valueExp <= -64)                  {                      return;                  }                  var tmp = valueMan >> (-valueExp & 63);                  if (tmp > int.MaxValue)                  {                      sign = 1;                      bits = new[] { (uint)tmp' (uint)(tmp >> 32) };                  }                  else                  {                      sign = (int)tmp;                  }                  if (valueSign < 0)                  {                      sign = -sign;                  }              }              else if (valueExp > 11)              {                  valueMan = valueMan << 11;                  valueExp = valueExp - 11;                  var significantDword = (valueExp - 1) / 32 + 1;                  var extraDword = significantDword * 32 - valueExp;                  bits = new uint[significantDword + 2];                  bits[significantDword + 1] = (uint)(valueMan >> (extraDword + 32 & 63));                  bits[significantDword] = (uint)(valueMan >> (extraDword & 63));                  if (extraDword > 0)                  {                      bits[significantDword - 1] = (uint)valueMan << (32 - extraDword & 31);                  }                  sign = valueSign;              }              else              {                  var tmp = valueMan << (valueExp & 63);                  if (tmp > int.MaxValue)                  {                      sign = 1;                      bits = new[] { (uint)tmp' (uint)(tmp >> 32) };                  }                  else                  {                      sign = (int)tmp;                  }                  if (valueSign < 0)                  {                      sign = -sign;                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetBitsFromDouble,The following statement contains a magic number: if (valueExp <= 0)              {                  if (valueExp <= -64)                  {                      return;                  }                  var tmp = valueMan >> (-valueExp & 63);                  if (tmp > int.MaxValue)                  {                      sign = 1;                      bits = new[] { (uint)tmp' (uint)(tmp >> 32) };                  }                  else                  {                      sign = (int)tmp;                  }                  if (valueSign < 0)                  {                      sign = -sign;                  }              }              else if (valueExp > 11)              {                  valueMan = valueMan << 11;                  valueExp = valueExp - 11;                  var significantDword = (valueExp - 1) / 32 + 1;                  var extraDword = significantDword * 32 - valueExp;                  bits = new uint[significantDword + 2];                  bits[significantDword + 1] = (uint)(valueMan >> (extraDword + 32 & 63));                  bits[significantDword] = (uint)(valueMan >> (extraDword & 63));                  if (extraDword > 0)                  {                      bits[significantDword - 1] = (uint)valueMan << (32 - extraDword & 31);                  }                  sign = valueSign;              }              else              {                  var tmp = valueMan << (valueExp & 63);                  if (tmp > int.MaxValue)                  {                      sign = 1;                      bits = new[] { (uint)tmp' (uint)(tmp >> 32) };                  }                  else                  {                      sign = (int)tmp;                  }                  if (valueSign < 0)                  {                      sign = -sign;                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetBitsFromDouble,The following statement contains a magic number: if (valueExp <= 0)              {                  if (valueExp <= -64)                  {                      return;                  }                  var tmp = valueMan >> (-valueExp & 63);                  if (tmp > int.MaxValue)                  {                      sign = 1;                      bits = new[] { (uint)tmp' (uint)(tmp >> 32) };                  }                  else                  {                      sign = (int)tmp;                  }                  if (valueSign < 0)                  {                      sign = -sign;                  }              }              else if (valueExp > 11)              {                  valueMan = valueMan << 11;                  valueExp = valueExp - 11;                  var significantDword = (valueExp - 1) / 32 + 1;                  var extraDword = significantDword * 32 - valueExp;                  bits = new uint[significantDword + 2];                  bits[significantDword + 1] = (uint)(valueMan >> (extraDword + 32 & 63));                  bits[significantDword] = (uint)(valueMan >> (extraDword & 63));                  if (extraDword > 0)                  {                      bits[significantDword - 1] = (uint)valueMan << (32 - extraDword & 31);                  }                  sign = valueSign;              }              else              {                  var tmp = valueMan << (valueExp & 63);                  if (tmp > int.MaxValue)                  {                      sign = 1;                      bits = new[] { (uint)tmp' (uint)(tmp >> 32) };                  }                  else                  {                      sign = (int)tmp;                  }                  if (valueSign < 0)                  {                      sign = -sign;                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetBitsFromDouble,The following statement contains a magic number: if (valueExp <= 0)              {                  if (valueExp <= -64)                  {                      return;                  }                  var tmp = valueMan >> (-valueExp & 63);                  if (tmp > int.MaxValue)                  {                      sign = 1;                      bits = new[] { (uint)tmp' (uint)(tmp >> 32) };                  }                  else                  {                      sign = (int)tmp;                  }                  if (valueSign < 0)                  {                      sign = -sign;                  }              }              else if (valueExp > 11)              {                  valueMan = valueMan << 11;                  valueExp = valueExp - 11;                  var significantDword = (valueExp - 1) / 32 + 1;                  var extraDword = significantDword * 32 - valueExp;                  bits = new uint[significantDword + 2];                  bits[significantDword + 1] = (uint)(valueMan >> (extraDword + 32 & 63));                  bits[significantDword] = (uint)(valueMan >> (extraDword & 63));                  if (extraDword > 0)                  {                      bits[significantDword - 1] = (uint)valueMan << (32 - extraDword & 31);                  }                  sign = valueSign;              }              else              {                  var tmp = valueMan << (valueExp & 63);                  if (tmp > int.MaxValue)                  {                      sign = 1;                      bits = new[] { (uint)tmp' (uint)(tmp >> 32) };                  }                  else                  {                      sign = (int)tmp;                  }                  if (valueSign < 0)                  {                      sign = -sign;                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetBitsFromDouble,The following statement contains a magic number: if (valueExp <= 0)              {                  if (valueExp <= -64)                  {                      return;                  }                  var tmp = valueMan >> (-valueExp & 63);                  if (tmp > int.MaxValue)                  {                      sign = 1;                      bits = new[] { (uint)tmp' (uint)(tmp >> 32) };                  }                  else                  {                      sign = (int)tmp;                  }                  if (valueSign < 0)                  {                      sign = -sign;                  }              }              else if (valueExp > 11)              {                  valueMan = valueMan << 11;                  valueExp = valueExp - 11;                  var significantDword = (valueExp - 1) / 32 + 1;                  var extraDword = significantDword * 32 - valueExp;                  bits = new uint[significantDword + 2];                  bits[significantDword + 1] = (uint)(valueMan >> (extraDword + 32 & 63));                  bits[significantDword] = (uint)(valueMan >> (extraDword & 63));                  if (extraDword > 0)                  {                      bits[significantDword - 1] = (uint)valueMan << (32 - extraDword & 31);                  }                  sign = valueSign;              }              else              {                  var tmp = valueMan << (valueExp & 63);                  if (tmp > int.MaxValue)                  {                      sign = 1;                      bits = new[] { (uint)tmp' (uint)(tmp >> 32) };                  }                  else                  {                      sign = (int)tmp;                  }                  if (valueSign < 0)                  {                      sign = -sign;                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,ToByteArray,The following statement contains a magic number: if (InternalBits == null)              {                  internalBits = new[] { unchecked((uint)InternalSign) };                  highByte = InternalSign < 0 ? (byte)0xff : (byte)0x00;              }              else if (InternalSign != -1)              {                  internalBits = InternalBits;                  highByte = 0;              }              else              {                  internalBits = (uint[])InternalBits.Clone();                  NumericsHelpers.DangerousMakeTwosComplement(internalBits);                  highByte = 255;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,ToByteArray,The following statement contains a magic number: var bytes = new byte[checked(4 * internalBits.Length)];
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,ToByteArray,The following statement contains a magic number: foreach (var value in internalBits)              {                  var current = value;                  for (var j = 0; j < 4; j++)                  {                      bytes[index] = (byte)(current & 255);                      current >>= 8;                      index++;                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,ToByteArray,The following statement contains a magic number: foreach (var value in internalBits)              {                  var current = value;                  for (var j = 0; j < 4; j++)                  {                      bytes[index] = (byte)(current & 255);                      current >>= 8;                      index++;                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,ToByteArray,The following statement contains a magic number: foreach (var value in internalBits)              {                  var current = value;                  for (var j = 0; j < 4; j++)                  {                      bytes[index] = (byte)(current & 255);                      current >>= 8;                      index++;                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,ToByteArray,The following statement contains a magic number: var extra = (bytes[length] & 128) != (highByte & 128);
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,ToByteArray,The following statement contains a magic number: var extra = (bytes[length] & 128) != (highByte & 128);
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,FormatBigInteger,The following statement contains a magic number: if (fmt == 'e' || fmt == 'E')              {                  var precision = digits != -1 ? digits : 6;                    if (value.InternalBits == null)                  {                      return value.InternalSign.ToString(format' info);                  }                    var scale = (int)Math.Floor(Log10(value));                  // ---                  if (scale > precision + 10)                  {                      do                      {                          value /= 1000000000;                      } while (Log10(value) > precision + 10);                  }                  while (Log10(value) > precision + 2)                  {                      value /= 10;                  }                  if ((Log10(value) > precision + 1))                  {                      var round = value % 10 >= 5;                      value = (value / 10) + (round ? One : Zero);                  }                    ReverseStringBuilder builder;                    if (value.InternalBits == null)                  {                      builder = new ReverseStringBuilder(10);                      builder.Prepend(value.InternalSign.ToString("D"));                  }                  else                  {                      builder = CreateBuilder(value' info' false' 0);                  }                    // ---                  var decimalSeparator = info.NumberDecimalSeparator;                    var result = new StringBuilder(builder.Length + 6);                    var extra = 0;                    if (precision >= builder.Length)                  {                      extra = precision - (builder.Length - 1);                      precision = builder.Length - 1;                  }                  result.Append(builder.ToString(builder.Length' 1));                  result.Append(decimalSeparator);                  result.Append(builder.ToString(builder.Length - 1' precision));                  result.Append(new string('0'' extra));                  result.Append(fmt);                  result.Append(info.PositiveSign);                  if (scale < 10)                  {                      result.Append("00");                  }                  else if (scale < 100)                  {                      result.Append('0');                  }                  result.Append(scale);                    return result.ToString();              }              else              {                  var decimalFmt = (fmt == 'g' || fmt == 'G' || fmt == 'd' || fmt == 'D' || fmt == 'r' || fmt == 'R');                  if (value.InternalBits == null)                  {                      if (fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R')                      {                          if (digits > 0)                          {                              format = "D" + digits.ToString(CultureInfo.InvariantCulture);                          }                          else                          {                              format = "D";                          }                      }                      return value.InternalSign.ToString(format' info);                  }                  var builder = CreateBuilder(value' info' decimalFmt' digits);                  if (decimalFmt)                  {                      // Format Round-trip decimal                      // This format is supported for integral types only. The number is converted to a string of                      // decimal digits (0-9)' prefixed by a minus sign if the number is negative. The precision                      // specifier indicates the minimum number of digits desired in the resulting string. If required'                      // the number is padded with zeros to its left to produce the number of digits given by the                      // precision specifier.                      while (digits > 0 && digits >= builder.Length)                      {                          builder.Prepend('0');                          digits--;                      }                      if (value.InternalSign < 0)                      {                          builder.Prepend(info.NegativeSign);                      }                      return builder.ToString();                  }                  // 'c'' 'C'' 'e'' 'E'' 'f'' 'F'' 'n'' 'N'' 'p'' 'P'' custom                  var precision = -1;                  var groupingSizes = new[] { 3 };                  var groupingSeparator = info.NumberGroupSeparator;                  var decimalSeparator = info.NumberDecimalSeparator;                  var groups = false;                  var type = 0;                  if (fmt == '\0')                  {                      // parse custom                  }                  else                  {                      if (fmt == 'c' || fmt == 'C')                      {                          decimalSeparator = info.CurrencyDecimalSeparator;                          precision = digits != -1 ? digits : info.CurrencyDecimalDigits;                          groupingSeparator = info.CurrencyGroupSeparator;                          groupingSizes = info.CurrencyGroupSizes;                          groups = true;                          type = 1;                      }                      else if (fmt == 'f' || fmt == 'F')                      {                          precision = digits != -1 ? digits : info.NumberDecimalDigits;                      }                      else if (fmt == 'n' || fmt == 'N')                      {                          precision = digits != -1 ? digits : info.NumberDecimalDigits;                          groups = true;                      }                      else if (fmt == 'p' || fmt == 'P')                      {                          decimalSeparator = info.PercentDecimalSeparator;                          precision = digits != -1 ? digits : info.PercentDecimalDigits;                          groups = true;                          type = 2;                      }                      else                      {                          throw new NotImplementedException();                      }                  }                  var result = new StringBuilder(builder.Length + 20);                  var close = SetWrap(value' info' type' result);                  var append = builder;                  if (groups)                  {                      var extra = groupingSizes.Length - 1;                      if (groupingSizes[groupingSizes.Length - 1] != 0)                      {                          var totalDigits = builder.Length;                          extra += (int)Math.Ceiling(totalDigits * 1.0 / groupingSizes[groupingSizes.Length - 1]);                      }                      var length = extra + builder.Length;                      if (type == 2)                      {                          length += 2;                          append = StringWithGroups(length' new ExtendedEnumerable<char>(new[] { '0'' '0' }' builder)' groupingSizes' groupingSeparator);                      }                      else                      {                          append = StringWithGroups(extra + builder.Length' builder' groupingSizes' groupingSeparator);                      }                  }                  result.Append(append);                  if (precision > 0)                  {                      result.Append(decimalSeparator);                      result.Append(new string('0'' precision));                  }                  result.Append(close);                  return result.ToString();              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,FormatBigInteger,The following statement contains a magic number: if (fmt == 'e' || fmt == 'E')              {                  var precision = digits != -1 ? digits : 6;                    if (value.InternalBits == null)                  {                      return value.InternalSign.ToString(format' info);                  }                    var scale = (int)Math.Floor(Log10(value));                  // ---                  if (scale > precision + 10)                  {                      do                      {                          value /= 1000000000;                      } while (Log10(value) > precision + 10);                  }                  while (Log10(value) > precision + 2)                  {                      value /= 10;                  }                  if ((Log10(value) > precision + 1))                  {                      var round = value % 10 >= 5;                      value = (value / 10) + (round ? One : Zero);                  }                    ReverseStringBuilder builder;                    if (value.InternalBits == null)                  {                      builder = new ReverseStringBuilder(10);                      builder.Prepend(value.InternalSign.ToString("D"));                  }                  else                  {                      builder = CreateBuilder(value' info' false' 0);                  }                    // ---                  var decimalSeparator = info.NumberDecimalSeparator;                    var result = new StringBuilder(builder.Length + 6);                    var extra = 0;                    if (precision >= builder.Length)                  {                      extra = precision - (builder.Length - 1);                      precision = builder.Length - 1;                  }                  result.Append(builder.ToString(builder.Length' 1));                  result.Append(decimalSeparator);                  result.Append(builder.ToString(builder.Length - 1' precision));                  result.Append(new string('0'' extra));                  result.Append(fmt);                  result.Append(info.PositiveSign);                  if (scale < 10)                  {                      result.Append("00");                  }                  else if (scale < 100)                  {                      result.Append('0');                  }                  result.Append(scale);                    return result.ToString();              }              else              {                  var decimalFmt = (fmt == 'g' || fmt == 'G' || fmt == 'd' || fmt == 'D' || fmt == 'r' || fmt == 'R');                  if (value.InternalBits == null)                  {                      if (fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R')                      {                          if (digits > 0)                          {                              format = "D" + digits.ToString(CultureInfo.InvariantCulture);                          }                          else                          {                              format = "D";                          }                      }                      return value.InternalSign.ToString(format' info);                  }                  var builder = CreateBuilder(value' info' decimalFmt' digits);                  if (decimalFmt)                  {                      // Format Round-trip decimal                      // This format is supported for integral types only. The number is converted to a string of                      // decimal digits (0-9)' prefixed by a minus sign if the number is negative. The precision                      // specifier indicates the minimum number of digits desired in the resulting string. If required'                      // the number is padded with zeros to its left to produce the number of digits given by the                      // precision specifier.                      while (digits > 0 && digits >= builder.Length)                      {                          builder.Prepend('0');                          digits--;                      }                      if (value.InternalSign < 0)                      {                          builder.Prepend(info.NegativeSign);                      }                      return builder.ToString();                  }                  // 'c'' 'C'' 'e'' 'E'' 'f'' 'F'' 'n'' 'N'' 'p'' 'P'' custom                  var precision = -1;                  var groupingSizes = new[] { 3 };                  var groupingSeparator = info.NumberGroupSeparator;                  var decimalSeparator = info.NumberDecimalSeparator;                  var groups = false;                  var type = 0;                  if (fmt == '\0')                  {                      // parse custom                  }                  else                  {                      if (fmt == 'c' || fmt == 'C')                      {                          decimalSeparator = info.CurrencyDecimalSeparator;                          precision = digits != -1 ? digits : info.CurrencyDecimalDigits;                          groupingSeparator = info.CurrencyGroupSeparator;                          groupingSizes = info.CurrencyGroupSizes;                          groups = true;                          type = 1;                      }                      else if (fmt == 'f' || fmt == 'F')                      {                          precision = digits != -1 ? digits : info.NumberDecimalDigits;                      }                      else if (fmt == 'n' || fmt == 'N')                      {                          precision = digits != -1 ? digits : info.NumberDecimalDigits;                          groups = true;                      }                      else if (fmt == 'p' || fmt == 'P')                      {                          decimalSeparator = info.PercentDecimalSeparator;                          precision = digits != -1 ? digits : info.PercentDecimalDigits;                          groups = true;                          type = 2;                      }                      else                      {                          throw new NotImplementedException();                      }                  }                  var result = new StringBuilder(builder.Length + 20);                  var close = SetWrap(value' info' type' result);                  var append = builder;                  if (groups)                  {                      var extra = groupingSizes.Length - 1;                      if (groupingSizes[groupingSizes.Length - 1] != 0)                      {                          var totalDigits = builder.Length;                          extra += (int)Math.Ceiling(totalDigits * 1.0 / groupingSizes[groupingSizes.Length - 1]);                      }                      var length = extra + builder.Length;                      if (type == 2)                      {                          length += 2;                          append = StringWithGroups(length' new ExtendedEnumerable<char>(new[] { '0'' '0' }' builder)' groupingSizes' groupingSeparator);                      }                      else                      {                          append = StringWithGroups(extra + builder.Length' builder' groupingSizes' groupingSeparator);                      }                  }                  result.Append(append);                  if (precision > 0)                  {                      result.Append(decimalSeparator);                      result.Append(new string('0'' precision));                  }                  result.Append(close);                  return result.ToString();              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,FormatBigInteger,The following statement contains a magic number: if (fmt == 'e' || fmt == 'E')              {                  var precision = digits != -1 ? digits : 6;                    if (value.InternalBits == null)                  {                      return value.InternalSign.ToString(format' info);                  }                    var scale = (int)Math.Floor(Log10(value));                  // ---                  if (scale > precision + 10)                  {                      do                      {                          value /= 1000000000;                      } while (Log10(value) > precision + 10);                  }                  while (Log10(value) > precision + 2)                  {                      value /= 10;                  }                  if ((Log10(value) > precision + 1))                  {                      var round = value % 10 >= 5;                      value = (value / 10) + (round ? One : Zero);                  }                    ReverseStringBuilder builder;                    if (value.InternalBits == null)                  {                      builder = new ReverseStringBuilder(10);                      builder.Prepend(value.InternalSign.ToString("D"));                  }                  else                  {                      builder = CreateBuilder(value' info' false' 0);                  }                    // ---                  var decimalSeparator = info.NumberDecimalSeparator;                    var result = new StringBuilder(builder.Length + 6);                    var extra = 0;                    if (precision >= builder.Length)                  {                      extra = precision - (builder.Length - 1);                      precision = builder.Length - 1;                  }                  result.Append(builder.ToString(builder.Length' 1));                  result.Append(decimalSeparator);                  result.Append(builder.ToString(builder.Length - 1' precision));                  result.Append(new string('0'' extra));                  result.Append(fmt);                  result.Append(info.PositiveSign);                  if (scale < 10)                  {                      result.Append("00");                  }                  else if (scale < 100)                  {                      result.Append('0');                  }                  result.Append(scale);                    return result.ToString();              }              else              {                  var decimalFmt = (fmt == 'g' || fmt == 'G' || fmt == 'd' || fmt == 'D' || fmt == 'r' || fmt == 'R');                  if (value.InternalBits == null)                  {                      if (fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R')                      {                          if (digits > 0)                          {                              format = "D" + digits.ToString(CultureInfo.InvariantCulture);                          }                          else                          {                              format = "D";                          }                      }                      return value.InternalSign.ToString(format' info);                  }                  var builder = CreateBuilder(value' info' decimalFmt' digits);                  if (decimalFmt)                  {                      // Format Round-trip decimal                      // This format is supported for integral types only. The number is converted to a string of                      // decimal digits (0-9)' prefixed by a minus sign if the number is negative. The precision                      // specifier indicates the minimum number of digits desired in the resulting string. If required'                      // the number is padded with zeros to its left to produce the number of digits given by the                      // precision specifier.                      while (digits > 0 && digits >= builder.Length)                      {                          builder.Prepend('0');                          digits--;                      }                      if (value.InternalSign < 0)                      {                          builder.Prepend(info.NegativeSign);                      }                      return builder.ToString();                  }                  // 'c'' 'C'' 'e'' 'E'' 'f'' 'F'' 'n'' 'N'' 'p'' 'P'' custom                  var precision = -1;                  var groupingSizes = new[] { 3 };                  var groupingSeparator = info.NumberGroupSeparator;                  var decimalSeparator = info.NumberDecimalSeparator;                  var groups = false;                  var type = 0;                  if (fmt == '\0')                  {                      // parse custom                  }                  else                  {                      if (fmt == 'c' || fmt == 'C')                      {                          decimalSeparator = info.CurrencyDecimalSeparator;                          precision = digits != -1 ? digits : info.CurrencyDecimalDigits;                          groupingSeparator = info.CurrencyGroupSeparator;                          groupingSizes = info.CurrencyGroupSizes;                          groups = true;                          type = 1;                      }                      else if (fmt == 'f' || fmt == 'F')                      {                          precision = digits != -1 ? digits : info.NumberDecimalDigits;                      }                      else if (fmt == 'n' || fmt == 'N')                      {                          precision = digits != -1 ? digits : info.NumberDecimalDigits;                          groups = true;                      }                      else if (fmt == 'p' || fmt == 'P')                      {                          decimalSeparator = info.PercentDecimalSeparator;                          precision = digits != -1 ? digits : info.PercentDecimalDigits;                          groups = true;                          type = 2;                      }                      else                      {                          throw new NotImplementedException();                      }                  }                  var result = new StringBuilder(builder.Length + 20);                  var close = SetWrap(value' info' type' result);                  var append = builder;                  if (groups)                  {                      var extra = groupingSizes.Length - 1;                      if (groupingSizes[groupingSizes.Length - 1] != 0)                      {                          var totalDigits = builder.Length;                          extra += (int)Math.Ceiling(totalDigits * 1.0 / groupingSizes[groupingSizes.Length - 1]);                      }                      var length = extra + builder.Length;                      if (type == 2)                      {                          length += 2;                          append = StringWithGroups(length' new ExtendedEnumerable<char>(new[] { '0'' '0' }' builder)' groupingSizes' groupingSeparator);                      }                      else                      {                          append = StringWithGroups(extra + builder.Length' builder' groupingSizes' groupingSeparator);                      }                  }                  result.Append(append);                  if (precision > 0)                  {                      result.Append(decimalSeparator);                      result.Append(new string('0'' precision));                  }                  result.Append(close);                  return result.ToString();              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,FormatBigInteger,The following statement contains a magic number: if (fmt == 'e' || fmt == 'E')              {                  var precision = digits != -1 ? digits : 6;                    if (value.InternalBits == null)                  {                      return value.InternalSign.ToString(format' info);                  }                    var scale = (int)Math.Floor(Log10(value));                  // ---                  if (scale > precision + 10)                  {                      do                      {                          value /= 1000000000;                      } while (Log10(value) > precision + 10);                  }                  while (Log10(value) > precision + 2)                  {                      value /= 10;                  }                  if ((Log10(value) > precision + 1))                  {                      var round = value % 10 >= 5;                      value = (value / 10) + (round ? One : Zero);                  }                    ReverseStringBuilder builder;                    if (value.InternalBits == null)                  {                      builder = new ReverseStringBuilder(10);                      builder.Prepend(value.InternalSign.ToString("D"));                  }                  else                  {                      builder = CreateBuilder(value' info' false' 0);                  }                    // ---                  var decimalSeparator = info.NumberDecimalSeparator;                    var result = new StringBuilder(builder.Length + 6);                    var extra = 0;                    if (precision >= builder.Length)                  {                      extra = precision - (builder.Length - 1);                      precision = builder.Length - 1;                  }                  result.Append(builder.ToString(builder.Length' 1));                  result.Append(decimalSeparator);                  result.Append(builder.ToString(builder.Length - 1' precision));                  result.Append(new string('0'' extra));                  result.Append(fmt);                  result.Append(info.PositiveSign);                  if (scale < 10)                  {                      result.Append("00");                  }                  else if (scale < 100)                  {                      result.Append('0');                  }                  result.Append(scale);                    return result.ToString();              }              else              {                  var decimalFmt = (fmt == 'g' || fmt == 'G' || fmt == 'd' || fmt == 'D' || fmt == 'r' || fmt == 'R');                  if (value.InternalBits == null)                  {                      if (fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R')                      {                          if (digits > 0)                          {                              format = "D" + digits.ToString(CultureInfo.InvariantCulture);                          }                          else                          {                              format = "D";                          }                      }                      return value.InternalSign.ToString(format' info);                  }                  var builder = CreateBuilder(value' info' decimalFmt' digits);                  if (decimalFmt)                  {                      // Format Round-trip decimal                      // This format is supported for integral types only. The number is converted to a string of                      // decimal digits (0-9)' prefixed by a minus sign if the number is negative. The precision                      // specifier indicates the minimum number of digits desired in the resulting string. If required'                      // the number is padded with zeros to its left to produce the number of digits given by the                      // precision specifier.                      while (digits > 0 && digits >= builder.Length)                      {                          builder.Prepend('0');                          digits--;                      }                      if (value.InternalSign < 0)                      {                          builder.Prepend(info.NegativeSign);                      }                      return builder.ToString();                  }                  // 'c'' 'C'' 'e'' 'E'' 'f'' 'F'' 'n'' 'N'' 'p'' 'P'' custom                  var precision = -1;                  var groupingSizes = new[] { 3 };                  var groupingSeparator = info.NumberGroupSeparator;                  var decimalSeparator = info.NumberDecimalSeparator;                  var groups = false;                  var type = 0;                  if (fmt == '\0')                  {                      // parse custom                  }                  else                  {                      if (fmt == 'c' || fmt == 'C')                      {                          decimalSeparator = info.CurrencyDecimalSeparator;                          precision = digits != -1 ? digits : info.CurrencyDecimalDigits;                          groupingSeparator = info.CurrencyGroupSeparator;                          groupingSizes = info.CurrencyGroupSizes;                          groups = true;                          type = 1;                      }                      else if (fmt == 'f' || fmt == 'F')                      {                          precision = digits != -1 ? digits : info.NumberDecimalDigits;                      }                      else if (fmt == 'n' || fmt == 'N')                      {                          precision = digits != -1 ? digits : info.NumberDecimalDigits;                          groups = true;                      }                      else if (fmt == 'p' || fmt == 'P')                      {                          decimalSeparator = info.PercentDecimalSeparator;                          precision = digits != -1 ? digits : info.PercentDecimalDigits;                          groups = true;                          type = 2;                      }                      else                      {                          throw new NotImplementedException();                      }                  }                  var result = new StringBuilder(builder.Length + 20);                  var close = SetWrap(value' info' type' result);                  var append = builder;                  if (groups)                  {                      var extra = groupingSizes.Length - 1;                      if (groupingSizes[groupingSizes.Length - 1] != 0)                      {                          var totalDigits = builder.Length;                          extra += (int)Math.Ceiling(totalDigits * 1.0 / groupingSizes[groupingSizes.Length - 1]);                      }                      var length = extra + builder.Length;                      if (type == 2)                      {                          length += 2;                          append = StringWithGroups(length' new ExtendedEnumerable<char>(new[] { '0'' '0' }' builder)' groupingSizes' groupingSeparator);                      }                      else                      {                          append = StringWithGroups(extra + builder.Length' builder' groupingSizes' groupingSeparator);                      }                  }                  result.Append(append);                  if (precision > 0)                  {                      result.Append(decimalSeparator);                      result.Append(new string('0'' precision));                  }                  result.Append(close);                  return result.ToString();              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,FormatBigInteger,The following statement contains a magic number: if (fmt == 'e' || fmt == 'E')              {                  var precision = digits != -1 ? digits : 6;                    if (value.InternalBits == null)                  {                      return value.InternalSign.ToString(format' info);                  }                    var scale = (int)Math.Floor(Log10(value));                  // ---                  if (scale > precision + 10)                  {                      do                      {                          value /= 1000000000;                      } while (Log10(value) > precision + 10);                  }                  while (Log10(value) > precision + 2)                  {                      value /= 10;                  }                  if ((Log10(value) > precision + 1))                  {                      var round = value % 10 >= 5;                      value = (value / 10) + (round ? One : Zero);                  }                    ReverseStringBuilder builder;                    if (value.InternalBits == null)                  {                      builder = new ReverseStringBuilder(10);                      builder.Prepend(value.InternalSign.ToString("D"));                  }                  else                  {                      builder = CreateBuilder(value' info' false' 0);                  }                    // ---                  var decimalSeparator = info.NumberDecimalSeparator;                    var result = new StringBuilder(builder.Length + 6);                    var extra = 0;                    if (precision >= builder.Length)                  {                      extra = precision - (builder.Length - 1);                      precision = builder.Length - 1;                  }                  result.Append(builder.ToString(builder.Length' 1));                  result.Append(decimalSeparator);                  result.Append(builder.ToString(builder.Length - 1' precision));                  result.Append(new string('0'' extra));                  result.Append(fmt);                  result.Append(info.PositiveSign);                  if (scale < 10)                  {                      result.Append("00");                  }                  else if (scale < 100)                  {                      result.Append('0');                  }                  result.Append(scale);                    return result.ToString();              }              else              {                  var decimalFmt = (fmt == 'g' || fmt == 'G' || fmt == 'd' || fmt == 'D' || fmt == 'r' || fmt == 'R');                  if (value.InternalBits == null)                  {                      if (fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R')                      {                          if (digits > 0)                          {                              format = "D" + digits.ToString(CultureInfo.InvariantCulture);                          }                          else                          {                              format = "D";                          }                      }                      return value.InternalSign.ToString(format' info);                  }                  var builder = CreateBuilder(value' info' decimalFmt' digits);                  if (decimalFmt)                  {                      // Format Round-trip decimal                      // This format is supported for integral types only. The number is converted to a string of                      // decimal digits (0-9)' prefixed by a minus sign if the number is negative. The precision                      // specifier indicates the minimum number of digits desired in the resulting string. If required'                      // the number is padded with zeros to its left to produce the number of digits given by the                      // precision specifier.                      while (digits > 0 && digits >= builder.Length)                      {                          builder.Prepend('0');                          digits--;                      }                      if (value.InternalSign < 0)                      {                          builder.Prepend(info.NegativeSign);                      }                      return builder.ToString();                  }                  // 'c'' 'C'' 'e'' 'E'' 'f'' 'F'' 'n'' 'N'' 'p'' 'P'' custom                  var precision = -1;                  var groupingSizes = new[] { 3 };                  var groupingSeparator = info.NumberGroupSeparator;                  var decimalSeparator = info.NumberDecimalSeparator;                  var groups = false;                  var type = 0;                  if (fmt == '\0')                  {                      // parse custom                  }                  else                  {                      if (fmt == 'c' || fmt == 'C')                      {                          decimalSeparator = info.CurrencyDecimalSeparator;                          precision = digits != -1 ? digits : info.CurrencyDecimalDigits;                          groupingSeparator = info.CurrencyGroupSeparator;                          groupingSizes = info.CurrencyGroupSizes;                          groups = true;                          type = 1;                      }                      else if (fmt == 'f' || fmt == 'F')                      {                          precision = digits != -1 ? digits : info.NumberDecimalDigits;                      }                      else if (fmt == 'n' || fmt == 'N')                      {                          precision = digits != -1 ? digits : info.NumberDecimalDigits;                          groups = true;                      }                      else if (fmt == 'p' || fmt == 'P')                      {                          decimalSeparator = info.PercentDecimalSeparator;                          precision = digits != -1 ? digits : info.PercentDecimalDigits;                          groups = true;                          type = 2;                      }                      else                      {                          throw new NotImplementedException();                      }                  }                  var result = new StringBuilder(builder.Length + 20);                  var close = SetWrap(value' info' type' result);                  var append = builder;                  if (groups)                  {                      var extra = groupingSizes.Length - 1;                      if (groupingSizes[groupingSizes.Length - 1] != 0)                      {                          var totalDigits = builder.Length;                          extra += (int)Math.Ceiling(totalDigits * 1.0 / groupingSizes[groupingSizes.Length - 1]);                      }                      var length = extra + builder.Length;                      if (type == 2)                      {                          length += 2;                          append = StringWithGroups(length' new ExtendedEnumerable<char>(new[] { '0'' '0' }' builder)' groupingSizes' groupingSeparator);                      }                      else                      {                          append = StringWithGroups(extra + builder.Length' builder' groupingSizes' groupingSeparator);                      }                  }                  result.Append(append);                  if (precision > 0)                  {                      result.Append(decimalSeparator);                      result.Append(new string('0'' precision));                  }                  result.Append(close);                  return result.ToString();              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,FormatBigInteger,The following statement contains a magic number: if (fmt == 'e' || fmt == 'E')              {                  var precision = digits != -1 ? digits : 6;                    if (value.InternalBits == null)                  {                      return value.InternalSign.ToString(format' info);                  }                    var scale = (int)Math.Floor(Log10(value));                  // ---                  if (scale > precision + 10)                  {                      do                      {                          value /= 1000000000;                      } while (Log10(value) > precision + 10);                  }                  while (Log10(value) > precision + 2)                  {                      value /= 10;                  }                  if ((Log10(value) > precision + 1))                  {                      var round = value % 10 >= 5;                      value = (value / 10) + (round ? One : Zero);                  }                    ReverseStringBuilder builder;                    if (value.InternalBits == null)                  {                      builder = new ReverseStringBuilder(10);                      builder.Prepend(value.InternalSign.ToString("D"));                  }                  else                  {                      builder = CreateBuilder(value' info' false' 0);                  }                    // ---                  var decimalSeparator = info.NumberDecimalSeparator;                    var result = new StringBuilder(builder.Length + 6);                    var extra = 0;                    if (precision >= builder.Length)                  {                      extra = precision - (builder.Length - 1);                      precision = builder.Length - 1;                  }                  result.Append(builder.ToString(builder.Length' 1));                  result.Append(decimalSeparator);                  result.Append(builder.ToString(builder.Length - 1' precision));                  result.Append(new string('0'' extra));                  result.Append(fmt);                  result.Append(info.PositiveSign);                  if (scale < 10)                  {                      result.Append("00");                  }                  else if (scale < 100)                  {                      result.Append('0');                  }                  result.Append(scale);                    return result.ToString();              }              else              {                  var decimalFmt = (fmt == 'g' || fmt == 'G' || fmt == 'd' || fmt == 'D' || fmt == 'r' || fmt == 'R');                  if (value.InternalBits == null)                  {                      if (fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R')                      {                          if (digits > 0)                          {                              format = "D" + digits.ToString(CultureInfo.InvariantCulture);                          }                          else                          {                              format = "D";                          }                      }                      return value.InternalSign.ToString(format' info);                  }                  var builder = CreateBuilder(value' info' decimalFmt' digits);                  if (decimalFmt)                  {                      // Format Round-trip decimal                      // This format is supported for integral types only. The number is converted to a string of                      // decimal digits (0-9)' prefixed by a minus sign if the number is negative. The precision                      // specifier indicates the minimum number of digits desired in the resulting string. If required'                      // the number is padded with zeros to its left to produce the number of digits given by the                      // precision specifier.                      while (digits > 0 && digits >= builder.Length)                      {                          builder.Prepend('0');                          digits--;                      }                      if (value.InternalSign < 0)                      {                          builder.Prepend(info.NegativeSign);                      }                      return builder.ToString();                  }                  // 'c'' 'C'' 'e'' 'E'' 'f'' 'F'' 'n'' 'N'' 'p'' 'P'' custom                  var precision = -1;                  var groupingSizes = new[] { 3 };                  var groupingSeparator = info.NumberGroupSeparator;                  var decimalSeparator = info.NumberDecimalSeparator;                  var groups = false;                  var type = 0;                  if (fmt == '\0')                  {                      // parse custom                  }                  else                  {                      if (fmt == 'c' || fmt == 'C')                      {                          decimalSeparator = info.CurrencyDecimalSeparator;                          precision = digits != -1 ? digits : info.CurrencyDecimalDigits;                          groupingSeparator = info.CurrencyGroupSeparator;                          groupingSizes = info.CurrencyGroupSizes;                          groups = true;                          type = 1;                      }                      else if (fmt == 'f' || fmt == 'F')                      {                          precision = digits != -1 ? digits : info.NumberDecimalDigits;                      }                      else if (fmt == 'n' || fmt == 'N')                      {                          precision = digits != -1 ? digits : info.NumberDecimalDigits;                          groups = true;                      }                      else if (fmt == 'p' || fmt == 'P')                      {                          decimalSeparator = info.PercentDecimalSeparator;                          precision = digits != -1 ? digits : info.PercentDecimalDigits;                          groups = true;                          type = 2;                      }                      else                      {                          throw new NotImplementedException();                      }                  }                  var result = new StringBuilder(builder.Length + 20);                  var close = SetWrap(value' info' type' result);                  var append = builder;                  if (groups)                  {                      var extra = groupingSizes.Length - 1;                      if (groupingSizes[groupingSizes.Length - 1] != 0)                      {                          var totalDigits = builder.Length;                          extra += (int)Math.Ceiling(totalDigits * 1.0 / groupingSizes[groupingSizes.Length - 1]);                      }                      var length = extra + builder.Length;                      if (type == 2)                      {                          length += 2;                          append = StringWithGroups(length' new ExtendedEnumerable<char>(new[] { '0'' '0' }' builder)' groupingSizes' groupingSeparator);                      }                      else                      {                          append = StringWithGroups(extra + builder.Length' builder' groupingSizes' groupingSeparator);                      }                  }                  result.Append(append);                  if (precision > 0)                  {                      result.Append(decimalSeparator);                      result.Append(new string('0'' precision));                  }                  result.Append(close);                  return result.ToString();              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,FormatBigInteger,The following statement contains a magic number: if (fmt == 'e' || fmt == 'E')              {                  var precision = digits != -1 ? digits : 6;                    if (value.InternalBits == null)                  {                      return value.InternalSign.ToString(format' info);                  }                    var scale = (int)Math.Floor(Log10(value));                  // ---                  if (scale > precision + 10)                  {                      do                      {                          value /= 1000000000;                      } while (Log10(value) > precision + 10);                  }                  while (Log10(value) > precision + 2)                  {                      value /= 10;                  }                  if ((Log10(value) > precision + 1))                  {                      var round = value % 10 >= 5;                      value = (value / 10) + (round ? One : Zero);                  }                    ReverseStringBuilder builder;                    if (value.InternalBits == null)                  {                      builder = new ReverseStringBuilder(10);                      builder.Prepend(value.InternalSign.ToString("D"));                  }                  else                  {                      builder = CreateBuilder(value' info' false' 0);                  }                    // ---                  var decimalSeparator = info.NumberDecimalSeparator;                    var result = new StringBuilder(builder.Length + 6);                    var extra = 0;                    if (precision >= builder.Length)                  {                      extra = precision - (builder.Length - 1);                      precision = builder.Length - 1;                  }                  result.Append(builder.ToString(builder.Length' 1));                  result.Append(decimalSeparator);                  result.Append(builder.ToString(builder.Length - 1' precision));                  result.Append(new string('0'' extra));                  result.Append(fmt);                  result.Append(info.PositiveSign);                  if (scale < 10)                  {                      result.Append("00");                  }                  else if (scale < 100)                  {                      result.Append('0');                  }                  result.Append(scale);                    return result.ToString();              }              else              {                  var decimalFmt = (fmt == 'g' || fmt == 'G' || fmt == 'd' || fmt == 'D' || fmt == 'r' || fmt == 'R');                  if (value.InternalBits == null)                  {                      if (fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R')                      {                          if (digits > 0)                          {                              format = "D" + digits.ToString(CultureInfo.InvariantCulture);                          }                          else                          {                              format = "D";                          }                      }                      return value.InternalSign.ToString(format' info);                  }                  var builder = CreateBuilder(value' info' decimalFmt' digits);                  if (decimalFmt)                  {                      // Format Round-trip decimal                      // This format is supported for integral types only. The number is converted to a string of                      // decimal digits (0-9)' prefixed by a minus sign if the number is negative. The precision                      // specifier indicates the minimum number of digits desired in the resulting string. If required'                      // the number is padded with zeros to its left to produce the number of digits given by the                      // precision specifier.                      while (digits > 0 && digits >= builder.Length)                      {                          builder.Prepend('0');                          digits--;                      }                      if (value.InternalSign < 0)                      {                          builder.Prepend(info.NegativeSign);                      }                      return builder.ToString();                  }                  // 'c'' 'C'' 'e'' 'E'' 'f'' 'F'' 'n'' 'N'' 'p'' 'P'' custom                  var precision = -1;                  var groupingSizes = new[] { 3 };                  var groupingSeparator = info.NumberGroupSeparator;                  var decimalSeparator = info.NumberDecimalSeparator;                  var groups = false;                  var type = 0;                  if (fmt == '\0')                  {                      // parse custom                  }                  else                  {                      if (fmt == 'c' || fmt == 'C')                      {                          decimalSeparator = info.CurrencyDecimalSeparator;                          precision = digits != -1 ? digits : info.CurrencyDecimalDigits;                          groupingSeparator = info.CurrencyGroupSeparator;                          groupingSizes = info.CurrencyGroupSizes;                          groups = true;                          type = 1;                      }                      else if (fmt == 'f' || fmt == 'F')                      {                          precision = digits != -1 ? digits : info.NumberDecimalDigits;                      }                      else if (fmt == 'n' || fmt == 'N')                      {                          precision = digits != -1 ? digits : info.NumberDecimalDigits;                          groups = true;                      }                      else if (fmt == 'p' || fmt == 'P')                      {                          decimalSeparator = info.PercentDecimalSeparator;                          precision = digits != -1 ? digits : info.PercentDecimalDigits;                          groups = true;                          type = 2;                      }                      else                      {                          throw new NotImplementedException();                      }                  }                  var result = new StringBuilder(builder.Length + 20);                  var close = SetWrap(value' info' type' result);                  var append = builder;                  if (groups)                  {                      var extra = groupingSizes.Length - 1;                      if (groupingSizes[groupingSizes.Length - 1] != 0)                      {                          var totalDigits = builder.Length;                          extra += (int)Math.Ceiling(totalDigits * 1.0 / groupingSizes[groupingSizes.Length - 1]);                      }                      var length = extra + builder.Length;                      if (type == 2)                      {                          length += 2;                          append = StringWithGroups(length' new ExtendedEnumerable<char>(new[] { '0'' '0' }' builder)' groupingSizes' groupingSeparator);                      }                      else                      {                          append = StringWithGroups(extra + builder.Length' builder' groupingSizes' groupingSeparator);                      }                  }                  result.Append(append);                  if (precision > 0)                  {                      result.Append(decimalSeparator);                      result.Append(new string('0'' precision));                  }                  result.Append(close);                  return result.ToString();              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,FormatBigInteger,The following statement contains a magic number: if (fmt == 'e' || fmt == 'E')              {                  var precision = digits != -1 ? digits : 6;                    if (value.InternalBits == null)                  {                      return value.InternalSign.ToString(format' info);                  }                    var scale = (int)Math.Floor(Log10(value));                  // ---                  if (scale > precision + 10)                  {                      do                      {                          value /= 1000000000;                      } while (Log10(value) > precision + 10);                  }                  while (Log10(value) > precision + 2)                  {                      value /= 10;                  }                  if ((Log10(value) > precision + 1))                  {                      var round = value % 10 >= 5;                      value = (value / 10) + (round ? One : Zero);                  }                    ReverseStringBuilder builder;                    if (value.InternalBits == null)                  {                      builder = new ReverseStringBuilder(10);                      builder.Prepend(value.InternalSign.ToString("D"));                  }                  else                  {                      builder = CreateBuilder(value' info' false' 0);                  }                    // ---                  var decimalSeparator = info.NumberDecimalSeparator;                    var result = new StringBuilder(builder.Length + 6);                    var extra = 0;                    if (precision >= builder.Length)                  {                      extra = precision - (builder.Length - 1);                      precision = builder.Length - 1;                  }                  result.Append(builder.ToString(builder.Length' 1));                  result.Append(decimalSeparator);                  result.Append(builder.ToString(builder.Length - 1' precision));                  result.Append(new string('0'' extra));                  result.Append(fmt);                  result.Append(info.PositiveSign);                  if (scale < 10)                  {                      result.Append("00");                  }                  else if (scale < 100)                  {                      result.Append('0');                  }                  result.Append(scale);                    return result.ToString();              }              else              {                  var decimalFmt = (fmt == 'g' || fmt == 'G' || fmt == 'd' || fmt == 'D' || fmt == 'r' || fmt == 'R');                  if (value.InternalBits == null)                  {                      if (fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R')                      {                          if (digits > 0)                          {                              format = "D" + digits.ToString(CultureInfo.InvariantCulture);                          }                          else                          {                              format = "D";                          }                      }                      return value.InternalSign.ToString(format' info);                  }                  var builder = CreateBuilder(value' info' decimalFmt' digits);                  if (decimalFmt)                  {                      // Format Round-trip decimal                      // This format is supported for integral types only. The number is converted to a string of                      // decimal digits (0-9)' prefixed by a minus sign if the number is negative. The precision                      // specifier indicates the minimum number of digits desired in the resulting string. If required'                      // the number is padded with zeros to its left to produce the number of digits given by the                      // precision specifier.                      while (digits > 0 && digits >= builder.Length)                      {                          builder.Prepend('0');                          digits--;                      }                      if (value.InternalSign < 0)                      {                          builder.Prepend(info.NegativeSign);                      }                      return builder.ToString();                  }                  // 'c'' 'C'' 'e'' 'E'' 'f'' 'F'' 'n'' 'N'' 'p'' 'P'' custom                  var precision = -1;                  var groupingSizes = new[] { 3 };                  var groupingSeparator = info.NumberGroupSeparator;                  var decimalSeparator = info.NumberDecimalSeparator;                  var groups = false;                  var type = 0;                  if (fmt == '\0')                  {                      // parse custom                  }                  else                  {                      if (fmt == 'c' || fmt == 'C')                      {                          decimalSeparator = info.CurrencyDecimalSeparator;                          precision = digits != -1 ? digits : info.CurrencyDecimalDigits;                          groupingSeparator = info.CurrencyGroupSeparator;                          groupingSizes = info.CurrencyGroupSizes;                          groups = true;                          type = 1;                      }                      else if (fmt == 'f' || fmt == 'F')                      {                          precision = digits != -1 ? digits : info.NumberDecimalDigits;                      }                      else if (fmt == 'n' || fmt == 'N')                      {                          precision = digits != -1 ? digits : info.NumberDecimalDigits;                          groups = true;                      }                      else if (fmt == 'p' || fmt == 'P')                      {                          decimalSeparator = info.PercentDecimalSeparator;                          precision = digits != -1 ? digits : info.PercentDecimalDigits;                          groups = true;                          type = 2;                      }                      else                      {                          throw new NotImplementedException();                      }                  }                  var result = new StringBuilder(builder.Length + 20);                  var close = SetWrap(value' info' type' result);                  var append = builder;                  if (groups)                  {                      var extra = groupingSizes.Length - 1;                      if (groupingSizes[groupingSizes.Length - 1] != 0)                      {                          var totalDigits = builder.Length;                          extra += (int)Math.Ceiling(totalDigits * 1.0 / groupingSizes[groupingSizes.Length - 1]);                      }                      var length = extra + builder.Length;                      if (type == 2)                      {                          length += 2;                          append = StringWithGroups(length' new ExtendedEnumerable<char>(new[] { '0'' '0' }' builder)' groupingSizes' groupingSeparator);                      }                      else                      {                          append = StringWithGroups(extra + builder.Length' builder' groupingSizes' groupingSeparator);                      }                  }                  result.Append(append);                  if (precision > 0)                  {                      result.Append(decimalSeparator);                      result.Append(new string('0'' precision));                  }                  result.Append(close);                  return result.ToString();              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,FormatBigInteger,The following statement contains a magic number: if (fmt == 'e' || fmt == 'E')              {                  var precision = digits != -1 ? digits : 6;                    if (value.InternalBits == null)                  {                      return value.InternalSign.ToString(format' info);                  }                    var scale = (int)Math.Floor(Log10(value));                  // ---                  if (scale > precision + 10)                  {                      do                      {                          value /= 1000000000;                      } while (Log10(value) > precision + 10);                  }                  while (Log10(value) > precision + 2)                  {                      value /= 10;                  }                  if ((Log10(value) > precision + 1))                  {                      var round = value % 10 >= 5;                      value = (value / 10) + (round ? One : Zero);                  }                    ReverseStringBuilder builder;                    if (value.InternalBits == null)                  {                      builder = new ReverseStringBuilder(10);                      builder.Prepend(value.InternalSign.ToString("D"));                  }                  else                  {                      builder = CreateBuilder(value' info' false' 0);                  }                    // ---                  var decimalSeparator = info.NumberDecimalSeparator;                    var result = new StringBuilder(builder.Length + 6);                    var extra = 0;                    if (precision >= builder.Length)                  {                      extra = precision - (builder.Length - 1);                      precision = builder.Length - 1;                  }                  result.Append(builder.ToString(builder.Length' 1));                  result.Append(decimalSeparator);                  result.Append(builder.ToString(builder.Length - 1' precision));                  result.Append(new string('0'' extra));                  result.Append(fmt);                  result.Append(info.PositiveSign);                  if (scale < 10)                  {                      result.Append("00");                  }                  else if (scale < 100)                  {                      result.Append('0');                  }                  result.Append(scale);                    return result.ToString();              }              else              {                  var decimalFmt = (fmt == 'g' || fmt == 'G' || fmt == 'd' || fmt == 'D' || fmt == 'r' || fmt == 'R');                  if (value.InternalBits == null)                  {                      if (fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R')                      {                          if (digits > 0)                          {                              format = "D" + digits.ToString(CultureInfo.InvariantCulture);                          }                          else                          {                              format = "D";                          }                      }                      return value.InternalSign.ToString(format' info);                  }                  var builder = CreateBuilder(value' info' decimalFmt' digits);                  if (decimalFmt)                  {                      // Format Round-trip decimal                      // This format is supported for integral types only. The number is converted to a string of                      // decimal digits (0-9)' prefixed by a minus sign if the number is negative. The precision                      // specifier indicates the minimum number of digits desired in the resulting string. If required'                      // the number is padded with zeros to its left to produce the number of digits given by the                      // precision specifier.                      while (digits > 0 && digits >= builder.Length)                      {                          builder.Prepend('0');                          digits--;                      }                      if (value.InternalSign < 0)                      {                          builder.Prepend(info.NegativeSign);                      }                      return builder.ToString();                  }                  // 'c'' 'C'' 'e'' 'E'' 'f'' 'F'' 'n'' 'N'' 'p'' 'P'' custom                  var precision = -1;                  var groupingSizes = new[] { 3 };                  var groupingSeparator = info.NumberGroupSeparator;                  var decimalSeparator = info.NumberDecimalSeparator;                  var groups = false;                  var type = 0;                  if (fmt == '\0')                  {                      // parse custom                  }                  else                  {                      if (fmt == 'c' || fmt == 'C')                      {                          decimalSeparator = info.CurrencyDecimalSeparator;                          precision = digits != -1 ? digits : info.CurrencyDecimalDigits;                          groupingSeparator = info.CurrencyGroupSeparator;                          groupingSizes = info.CurrencyGroupSizes;                          groups = true;                          type = 1;                      }                      else if (fmt == 'f' || fmt == 'F')                      {                          precision = digits != -1 ? digits : info.NumberDecimalDigits;                      }                      else if (fmt == 'n' || fmt == 'N')                      {                          precision = digits != -1 ? digits : info.NumberDecimalDigits;                          groups = true;                      }                      else if (fmt == 'p' || fmt == 'P')                      {                          decimalSeparator = info.PercentDecimalSeparator;                          precision = digits != -1 ? digits : info.PercentDecimalDigits;                          groups = true;                          type = 2;                      }                      else                      {                          throw new NotImplementedException();                      }                  }                  var result = new StringBuilder(builder.Length + 20);                  var close = SetWrap(value' info' type' result);                  var append = builder;                  if (groups)                  {                      var extra = groupingSizes.Length - 1;                      if (groupingSizes[groupingSizes.Length - 1] != 0)                      {                          var totalDigits = builder.Length;                          extra += (int)Math.Ceiling(totalDigits * 1.0 / groupingSizes[groupingSizes.Length - 1]);                      }                      var length = extra + builder.Length;                      if (type == 2)                      {                          length += 2;                          append = StringWithGroups(length' new ExtendedEnumerable<char>(new[] { '0'' '0' }' builder)' groupingSizes' groupingSeparator);                      }                      else                      {                          append = StringWithGroups(extra + builder.Length' builder' groupingSizes' groupingSeparator);                      }                  }                  result.Append(append);                  if (precision > 0)                  {                      result.Append(decimalSeparator);                      result.Append(new string('0'' precision));                  }                  result.Append(close);                  return result.ToString();              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,FormatBigInteger,The following statement contains a magic number: if (fmt == 'e' || fmt == 'E')              {                  var precision = digits != -1 ? digits : 6;                    if (value.InternalBits == null)                  {                      return value.InternalSign.ToString(format' info);                  }                    var scale = (int)Math.Floor(Log10(value));                  // ---                  if (scale > precision + 10)                  {                      do                      {                          value /= 1000000000;                      } while (Log10(value) > precision + 10);                  }                  while (Log10(value) > precision + 2)                  {                      value /= 10;                  }                  if ((Log10(value) > precision + 1))                  {                      var round = value % 10 >= 5;                      value = (value / 10) + (round ? One : Zero);                  }                    ReverseStringBuilder builder;                    if (value.InternalBits == null)                  {                      builder = new ReverseStringBuilder(10);                      builder.Prepend(value.InternalSign.ToString("D"));                  }                  else                  {                      builder = CreateBuilder(value' info' false' 0);                  }                    // ---                  var decimalSeparator = info.NumberDecimalSeparator;                    var result = new StringBuilder(builder.Length + 6);                    var extra = 0;                    if (precision >= builder.Length)                  {                      extra = precision - (builder.Length - 1);                      precision = builder.Length - 1;                  }                  result.Append(builder.ToString(builder.Length' 1));                  result.Append(decimalSeparator);                  result.Append(builder.ToString(builder.Length - 1' precision));                  result.Append(new string('0'' extra));                  result.Append(fmt);                  result.Append(info.PositiveSign);                  if (scale < 10)                  {                      result.Append("00");                  }                  else if (scale < 100)                  {                      result.Append('0');                  }                  result.Append(scale);                    return result.ToString();              }              else              {                  var decimalFmt = (fmt == 'g' || fmt == 'G' || fmt == 'd' || fmt == 'D' || fmt == 'r' || fmt == 'R');                  if (value.InternalBits == null)                  {                      if (fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R')                      {                          if (digits > 0)                          {                              format = "D" + digits.ToString(CultureInfo.InvariantCulture);                          }                          else                          {                              format = "D";                          }                      }                      return value.InternalSign.ToString(format' info);                  }                  var builder = CreateBuilder(value' info' decimalFmt' digits);                  if (decimalFmt)                  {                      // Format Round-trip decimal                      // This format is supported for integral types only. The number is converted to a string of                      // decimal digits (0-9)' prefixed by a minus sign if the number is negative. The precision                      // specifier indicates the minimum number of digits desired in the resulting string. If required'                      // the number is padded with zeros to its left to produce the number of digits given by the                      // precision specifier.                      while (digits > 0 && digits >= builder.Length)                      {                          builder.Prepend('0');                          digits--;                      }                      if (value.InternalSign < 0)                      {                          builder.Prepend(info.NegativeSign);                      }                      return builder.ToString();                  }                  // 'c'' 'C'' 'e'' 'E'' 'f'' 'F'' 'n'' 'N'' 'p'' 'P'' custom                  var precision = -1;                  var groupingSizes = new[] { 3 };                  var groupingSeparator = info.NumberGroupSeparator;                  var decimalSeparator = info.NumberDecimalSeparator;                  var groups = false;                  var type = 0;                  if (fmt == '\0')                  {                      // parse custom                  }                  else                  {                      if (fmt == 'c' || fmt == 'C')                      {                          decimalSeparator = info.CurrencyDecimalSeparator;                          precision = digits != -1 ? digits : info.CurrencyDecimalDigits;                          groupingSeparator = info.CurrencyGroupSeparator;                          groupingSizes = info.CurrencyGroupSizes;                          groups = true;                          type = 1;                      }                      else if (fmt == 'f' || fmt == 'F')                      {                          precision = digits != -1 ? digits : info.NumberDecimalDigits;                      }                      else if (fmt == 'n' || fmt == 'N')                      {                          precision = digits != -1 ? digits : info.NumberDecimalDigits;                          groups = true;                      }                      else if (fmt == 'p' || fmt == 'P')                      {                          decimalSeparator = info.PercentDecimalSeparator;                          precision = digits != -1 ? digits : info.PercentDecimalDigits;                          groups = true;                          type = 2;                      }                      else                      {                          throw new NotImplementedException();                      }                  }                  var result = new StringBuilder(builder.Length + 20);                  var close = SetWrap(value' info' type' result);                  var append = builder;                  if (groups)                  {                      var extra = groupingSizes.Length - 1;                      if (groupingSizes[groupingSizes.Length - 1] != 0)                      {                          var totalDigits = builder.Length;                          extra += (int)Math.Ceiling(totalDigits * 1.0 / groupingSizes[groupingSizes.Length - 1]);                      }                      var length = extra + builder.Length;                      if (type == 2)                      {                          length += 2;                          append = StringWithGroups(length' new ExtendedEnumerable<char>(new[] { '0'' '0' }' builder)' groupingSizes' groupingSeparator);                      }                      else                      {                          append = StringWithGroups(extra + builder.Length' builder' groupingSizes' groupingSeparator);                      }                  }                  result.Append(append);                  if (precision > 0)                  {                      result.Append(decimalSeparator);                      result.Append(new string('0'' precision));                  }                  result.Append(close);                  return result.ToString();              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,FormatBigInteger,The following statement contains a magic number: if (fmt == 'e' || fmt == 'E')              {                  var precision = digits != -1 ? digits : 6;                    if (value.InternalBits == null)                  {                      return value.InternalSign.ToString(format' info);                  }                    var scale = (int)Math.Floor(Log10(value));                  // ---                  if (scale > precision + 10)                  {                      do                      {                          value /= 1000000000;                      } while (Log10(value) > precision + 10);                  }                  while (Log10(value) > precision + 2)                  {                      value /= 10;                  }                  if ((Log10(value) > precision + 1))                  {                      var round = value % 10 >= 5;                      value = (value / 10) + (round ? One : Zero);                  }                    ReverseStringBuilder builder;                    if (value.InternalBits == null)                  {                      builder = new ReverseStringBuilder(10);                      builder.Prepend(value.InternalSign.ToString("D"));                  }                  else                  {                      builder = CreateBuilder(value' info' false' 0);                  }                    // ---                  var decimalSeparator = info.NumberDecimalSeparator;                    var result = new StringBuilder(builder.Length + 6);                    var extra = 0;                    if (precision >= builder.Length)                  {                      extra = precision - (builder.Length - 1);                      precision = builder.Length - 1;                  }                  result.Append(builder.ToString(builder.Length' 1));                  result.Append(decimalSeparator);                  result.Append(builder.ToString(builder.Length - 1' precision));                  result.Append(new string('0'' extra));                  result.Append(fmt);                  result.Append(info.PositiveSign);                  if (scale < 10)                  {                      result.Append("00");                  }                  else if (scale < 100)                  {                      result.Append('0');                  }                  result.Append(scale);                    return result.ToString();              }              else              {                  var decimalFmt = (fmt == 'g' || fmt == 'G' || fmt == 'd' || fmt == 'D' || fmt == 'r' || fmt == 'R');                  if (value.InternalBits == null)                  {                      if (fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R')                      {                          if (digits > 0)                          {                              format = "D" + digits.ToString(CultureInfo.InvariantCulture);                          }                          else                          {                              format = "D";                          }                      }                      return value.InternalSign.ToString(format' info);                  }                  var builder = CreateBuilder(value' info' decimalFmt' digits);                  if (decimalFmt)                  {                      // Format Round-trip decimal                      // This format is supported for integral types only. The number is converted to a string of                      // decimal digits (0-9)' prefixed by a minus sign if the number is negative. The precision                      // specifier indicates the minimum number of digits desired in the resulting string. If required'                      // the number is padded with zeros to its left to produce the number of digits given by the                      // precision specifier.                      while (digits > 0 && digits >= builder.Length)                      {                          builder.Prepend('0');                          digits--;                      }                      if (value.InternalSign < 0)                      {                          builder.Prepend(info.NegativeSign);                      }                      return builder.ToString();                  }                  // 'c'' 'C'' 'e'' 'E'' 'f'' 'F'' 'n'' 'N'' 'p'' 'P'' custom                  var precision = -1;                  var groupingSizes = new[] { 3 };                  var groupingSeparator = info.NumberGroupSeparator;                  var decimalSeparator = info.NumberDecimalSeparator;                  var groups = false;                  var type = 0;                  if (fmt == '\0')                  {                      // parse custom                  }                  else                  {                      if (fmt == 'c' || fmt == 'C')                      {                          decimalSeparator = info.CurrencyDecimalSeparator;                          precision = digits != -1 ? digits : info.CurrencyDecimalDigits;                          groupingSeparator = info.CurrencyGroupSeparator;                          groupingSizes = info.CurrencyGroupSizes;                          groups = true;                          type = 1;                      }                      else if (fmt == 'f' || fmt == 'F')                      {                          precision = digits != -1 ? digits : info.NumberDecimalDigits;                      }                      else if (fmt == 'n' || fmt == 'N')                      {                          precision = digits != -1 ? digits : info.NumberDecimalDigits;                          groups = true;                      }                      else if (fmt == 'p' || fmt == 'P')                      {                          decimalSeparator = info.PercentDecimalSeparator;                          precision = digits != -1 ? digits : info.PercentDecimalDigits;                          groups = true;                          type = 2;                      }                      else                      {                          throw new NotImplementedException();                      }                  }                  var result = new StringBuilder(builder.Length + 20);                  var close = SetWrap(value' info' type' result);                  var append = builder;                  if (groups)                  {                      var extra = groupingSizes.Length - 1;                      if (groupingSizes[groupingSizes.Length - 1] != 0)                      {                          var totalDigits = builder.Length;                          extra += (int)Math.Ceiling(totalDigits * 1.0 / groupingSizes[groupingSizes.Length - 1]);                      }                      var length = extra + builder.Length;                      if (type == 2)                      {                          length += 2;                          append = StringWithGroups(length' new ExtendedEnumerable<char>(new[] { '0'' '0' }' builder)' groupingSizes' groupingSeparator);                      }                      else                      {                          append = StringWithGroups(extra + builder.Length' builder' groupingSizes' groupingSeparator);                      }                  }                  result.Append(append);                  if (precision > 0)                  {                      result.Append(decimalSeparator);                      result.Append(new string('0'' precision));                  }                  result.Append(close);                  return result.ToString();              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,FormatBigInteger,The following statement contains a magic number: if (fmt == 'e' || fmt == 'E')              {                  var precision = digits != -1 ? digits : 6;                    if (value.InternalBits == null)                  {                      return value.InternalSign.ToString(format' info);                  }                    var scale = (int)Math.Floor(Log10(value));                  // ---                  if (scale > precision + 10)                  {                      do                      {                          value /= 1000000000;                      } while (Log10(value) > precision + 10);                  }                  while (Log10(value) > precision + 2)                  {                      value /= 10;                  }                  if ((Log10(value) > precision + 1))                  {                      var round = value % 10 >= 5;                      value = (value / 10) + (round ? One : Zero);                  }                    ReverseStringBuilder builder;                    if (value.InternalBits == null)                  {                      builder = new ReverseStringBuilder(10);                      builder.Prepend(value.InternalSign.ToString("D"));                  }                  else                  {                      builder = CreateBuilder(value' info' false' 0);                  }                    // ---                  var decimalSeparator = info.NumberDecimalSeparator;                    var result = new StringBuilder(builder.Length + 6);                    var extra = 0;                    if (precision >= builder.Length)                  {                      extra = precision - (builder.Length - 1);                      precision = builder.Length - 1;                  }                  result.Append(builder.ToString(builder.Length' 1));                  result.Append(decimalSeparator);                  result.Append(builder.ToString(builder.Length - 1' precision));                  result.Append(new string('0'' extra));                  result.Append(fmt);                  result.Append(info.PositiveSign);                  if (scale < 10)                  {                      result.Append("00");                  }                  else if (scale < 100)                  {                      result.Append('0');                  }                  result.Append(scale);                    return result.ToString();              }              else              {                  var decimalFmt = (fmt == 'g' || fmt == 'G' || fmt == 'd' || fmt == 'D' || fmt == 'r' || fmt == 'R');                  if (value.InternalBits == null)                  {                      if (fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R')                      {                          if (digits > 0)                          {                              format = "D" + digits.ToString(CultureInfo.InvariantCulture);                          }                          else                          {                              format = "D";                          }                      }                      return value.InternalSign.ToString(format' info);                  }                  var builder = CreateBuilder(value' info' decimalFmt' digits);                  if (decimalFmt)                  {                      // Format Round-trip decimal                      // This format is supported for integral types only. The number is converted to a string of                      // decimal digits (0-9)' prefixed by a minus sign if the number is negative. The precision                      // specifier indicates the minimum number of digits desired in the resulting string. If required'                      // the number is padded with zeros to its left to produce the number of digits given by the                      // precision specifier.                      while (digits > 0 && digits >= builder.Length)                      {                          builder.Prepend('0');                          digits--;                      }                      if (value.InternalSign < 0)                      {                          builder.Prepend(info.NegativeSign);                      }                      return builder.ToString();                  }                  // 'c'' 'C'' 'e'' 'E'' 'f'' 'F'' 'n'' 'N'' 'p'' 'P'' custom                  var precision = -1;                  var groupingSizes = new[] { 3 };                  var groupingSeparator = info.NumberGroupSeparator;                  var decimalSeparator = info.NumberDecimalSeparator;                  var groups = false;                  var type = 0;                  if (fmt == '\0')                  {                      // parse custom                  }                  else                  {                      if (fmt == 'c' || fmt == 'C')                      {                          decimalSeparator = info.CurrencyDecimalSeparator;                          precision = digits != -1 ? digits : info.CurrencyDecimalDigits;                          groupingSeparator = info.CurrencyGroupSeparator;                          groupingSizes = info.CurrencyGroupSizes;                          groups = true;                          type = 1;                      }                      else if (fmt == 'f' || fmt == 'F')                      {                          precision = digits != -1 ? digits : info.NumberDecimalDigits;                      }                      else if (fmt == 'n' || fmt == 'N')                      {                          precision = digits != -1 ? digits : info.NumberDecimalDigits;                          groups = true;                      }                      else if (fmt == 'p' || fmt == 'P')                      {                          decimalSeparator = info.PercentDecimalSeparator;                          precision = digits != -1 ? digits : info.PercentDecimalDigits;                          groups = true;                          type = 2;                      }                      else                      {                          throw new NotImplementedException();                      }                  }                  var result = new StringBuilder(builder.Length + 20);                  var close = SetWrap(value' info' type' result);                  var append = builder;                  if (groups)                  {                      var extra = groupingSizes.Length - 1;                      if (groupingSizes[groupingSizes.Length - 1] != 0)                      {                          var totalDigits = builder.Length;                          extra += (int)Math.Ceiling(totalDigits * 1.0 / groupingSizes[groupingSizes.Length - 1]);                      }                      var length = extra + builder.Length;                      if (type == 2)                      {                          length += 2;                          append = StringWithGroups(length' new ExtendedEnumerable<char>(new[] { '0'' '0' }' builder)' groupingSizes' groupingSeparator);                      }                      else                      {                          append = StringWithGroups(extra + builder.Length' builder' groupingSizes' groupingSeparator);                      }                  }                  result.Append(append);                  if (precision > 0)                  {                      result.Append(decimalSeparator);                      result.Append(new string('0'' precision));                  }                  result.Append(close);                  return result.ToString();              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,FormatBigInteger,The following statement contains a magic number: if (fmt == 'e' || fmt == 'E')              {                  var precision = digits != -1 ? digits : 6;                    if (value.InternalBits == null)                  {                      return value.InternalSign.ToString(format' info);                  }                    var scale = (int)Math.Floor(Log10(value));                  // ---                  if (scale > precision + 10)                  {                      do                      {                          value /= 1000000000;                      } while (Log10(value) > precision + 10);                  }                  while (Log10(value) > precision + 2)                  {                      value /= 10;                  }                  if ((Log10(value) > precision + 1))                  {                      var round = value % 10 >= 5;                      value = (value / 10) + (round ? One : Zero);                  }                    ReverseStringBuilder builder;                    if (value.InternalBits == null)                  {                      builder = new ReverseStringBuilder(10);                      builder.Prepend(value.InternalSign.ToString("D"));                  }                  else                  {                      builder = CreateBuilder(value' info' false' 0);                  }                    // ---                  var decimalSeparator = info.NumberDecimalSeparator;                    var result = new StringBuilder(builder.Length + 6);                    var extra = 0;                    if (precision >= builder.Length)                  {                      extra = precision - (builder.Length - 1);                      precision = builder.Length - 1;                  }                  result.Append(builder.ToString(builder.Length' 1));                  result.Append(decimalSeparator);                  result.Append(builder.ToString(builder.Length - 1' precision));                  result.Append(new string('0'' extra));                  result.Append(fmt);                  result.Append(info.PositiveSign);                  if (scale < 10)                  {                      result.Append("00");                  }                  else if (scale < 100)                  {                      result.Append('0');                  }                  result.Append(scale);                    return result.ToString();              }              else              {                  var decimalFmt = (fmt == 'g' || fmt == 'G' || fmt == 'd' || fmt == 'D' || fmt == 'r' || fmt == 'R');                  if (value.InternalBits == null)                  {                      if (fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R')                      {                          if (digits > 0)                          {                              format = "D" + digits.ToString(CultureInfo.InvariantCulture);                          }                          else                          {                              format = "D";                          }                      }                      return value.InternalSign.ToString(format' info);                  }                  var builder = CreateBuilder(value' info' decimalFmt' digits);                  if (decimalFmt)                  {                      // Format Round-trip decimal                      // This format is supported for integral types only. The number is converted to a string of                      // decimal digits (0-9)' prefixed by a minus sign if the number is negative. The precision                      // specifier indicates the minimum number of digits desired in the resulting string. If required'                      // the number is padded with zeros to its left to produce the number of digits given by the                      // precision specifier.                      while (digits > 0 && digits >= builder.Length)                      {                          builder.Prepend('0');                          digits--;                      }                      if (value.InternalSign < 0)                      {                          builder.Prepend(info.NegativeSign);                      }                      return builder.ToString();                  }                  // 'c'' 'C'' 'e'' 'E'' 'f'' 'F'' 'n'' 'N'' 'p'' 'P'' custom                  var precision = -1;                  var groupingSizes = new[] { 3 };                  var groupingSeparator = info.NumberGroupSeparator;                  var decimalSeparator = info.NumberDecimalSeparator;                  var groups = false;                  var type = 0;                  if (fmt == '\0')                  {                      // parse custom                  }                  else                  {                      if (fmt == 'c' || fmt == 'C')                      {                          decimalSeparator = info.CurrencyDecimalSeparator;                          precision = digits != -1 ? digits : info.CurrencyDecimalDigits;                          groupingSeparator = info.CurrencyGroupSeparator;                          groupingSizes = info.CurrencyGroupSizes;                          groups = true;                          type = 1;                      }                      else if (fmt == 'f' || fmt == 'F')                      {                          precision = digits != -1 ? digits : info.NumberDecimalDigits;                      }                      else if (fmt == 'n' || fmt == 'N')                      {                          precision = digits != -1 ? digits : info.NumberDecimalDigits;                          groups = true;                      }                      else if (fmt == 'p' || fmt == 'P')                      {                          decimalSeparator = info.PercentDecimalSeparator;                          precision = digits != -1 ? digits : info.PercentDecimalDigits;                          groups = true;                          type = 2;                      }                      else                      {                          throw new NotImplementedException();                      }                  }                  var result = new StringBuilder(builder.Length + 20);                  var close = SetWrap(value' info' type' result);                  var append = builder;                  if (groups)                  {                      var extra = groupingSizes.Length - 1;                      if (groupingSizes[groupingSizes.Length - 1] != 0)                      {                          var totalDigits = builder.Length;                          extra += (int)Math.Ceiling(totalDigits * 1.0 / groupingSizes[groupingSizes.Length - 1]);                      }                      var length = extra + builder.Length;                      if (type == 2)                      {                          length += 2;                          append = StringWithGroups(length' new ExtendedEnumerable<char>(new[] { '0'' '0' }' builder)' groupingSizes' groupingSeparator);                      }                      else                      {                          append = StringWithGroups(extra + builder.Length' builder' groupingSizes' groupingSeparator);                      }                  }                  result.Append(append);                  if (precision > 0)                  {                      result.Append(decimalSeparator);                      result.Append(new string('0'' precision));                  }                  result.Append(close);                  return result.ToString();              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,FormatBigInteger,The following statement contains a magic number: if (fmt == 'e' || fmt == 'E')              {                  var precision = digits != -1 ? digits : 6;                    if (value.InternalBits == null)                  {                      return value.InternalSign.ToString(format' info);                  }                    var scale = (int)Math.Floor(Log10(value));                  // ---                  if (scale > precision + 10)                  {                      do                      {                          value /= 1000000000;                      } while (Log10(value) > precision + 10);                  }                  while (Log10(value) > precision + 2)                  {                      value /= 10;                  }                  if ((Log10(value) > precision + 1))                  {                      var round = value % 10 >= 5;                      value = (value / 10) + (round ? One : Zero);                  }                    ReverseStringBuilder builder;                    if (value.InternalBits == null)                  {                      builder = new ReverseStringBuilder(10);                      builder.Prepend(value.InternalSign.ToString("D"));                  }                  else                  {                      builder = CreateBuilder(value' info' false' 0);                  }                    // ---                  var decimalSeparator = info.NumberDecimalSeparator;                    var result = new StringBuilder(builder.Length + 6);                    var extra = 0;                    if (precision >= builder.Length)                  {                      extra = precision - (builder.Length - 1);                      precision = builder.Length - 1;                  }                  result.Append(builder.ToString(builder.Length' 1));                  result.Append(decimalSeparator);                  result.Append(builder.ToString(builder.Length - 1' precision));                  result.Append(new string('0'' extra));                  result.Append(fmt);                  result.Append(info.PositiveSign);                  if (scale < 10)                  {                      result.Append("00");                  }                  else if (scale < 100)                  {                      result.Append('0');                  }                  result.Append(scale);                    return result.ToString();              }              else              {                  var decimalFmt = (fmt == 'g' || fmt == 'G' || fmt == 'd' || fmt == 'D' || fmt == 'r' || fmt == 'R');                  if (value.InternalBits == null)                  {                      if (fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R')                      {                          if (digits > 0)                          {                              format = "D" + digits.ToString(CultureInfo.InvariantCulture);                          }                          else                          {                              format = "D";                          }                      }                      return value.InternalSign.ToString(format' info);                  }                  var builder = CreateBuilder(value' info' decimalFmt' digits);                  if (decimalFmt)                  {                      // Format Round-trip decimal                      // This format is supported for integral types only. The number is converted to a string of                      // decimal digits (0-9)' prefixed by a minus sign if the number is negative. The precision                      // specifier indicates the minimum number of digits desired in the resulting string. If required'                      // the number is padded with zeros to its left to produce the number of digits given by the                      // precision specifier.                      while (digits > 0 && digits >= builder.Length)                      {                          builder.Prepend('0');                          digits--;                      }                      if (value.InternalSign < 0)                      {                          builder.Prepend(info.NegativeSign);                      }                      return builder.ToString();                  }                  // 'c'' 'C'' 'e'' 'E'' 'f'' 'F'' 'n'' 'N'' 'p'' 'P'' custom                  var precision = -1;                  var groupingSizes = new[] { 3 };                  var groupingSeparator = info.NumberGroupSeparator;                  var decimalSeparator = info.NumberDecimalSeparator;                  var groups = false;                  var type = 0;                  if (fmt == '\0')                  {                      // parse custom                  }                  else                  {                      if (fmt == 'c' || fmt == 'C')                      {                          decimalSeparator = info.CurrencyDecimalSeparator;                          precision = digits != -1 ? digits : info.CurrencyDecimalDigits;                          groupingSeparator = info.CurrencyGroupSeparator;                          groupingSizes = info.CurrencyGroupSizes;                          groups = true;                          type = 1;                      }                      else if (fmt == 'f' || fmt == 'F')                      {                          precision = digits != -1 ? digits : info.NumberDecimalDigits;                      }                      else if (fmt == 'n' || fmt == 'N')                      {                          precision = digits != -1 ? digits : info.NumberDecimalDigits;                          groups = true;                      }                      else if (fmt == 'p' || fmt == 'P')                      {                          decimalSeparator = info.PercentDecimalSeparator;                          precision = digits != -1 ? digits : info.PercentDecimalDigits;                          groups = true;                          type = 2;                      }                      else                      {                          throw new NotImplementedException();                      }                  }                  var result = new StringBuilder(builder.Length + 20);                  var close = SetWrap(value' info' type' result);                  var append = builder;                  if (groups)                  {                      var extra = groupingSizes.Length - 1;                      if (groupingSizes[groupingSizes.Length - 1] != 0)                      {                          var totalDigits = builder.Length;                          extra += (int)Math.Ceiling(totalDigits * 1.0 / groupingSizes[groupingSizes.Length - 1]);                      }                      var length = extra + builder.Length;                      if (type == 2)                      {                          length += 2;                          append = StringWithGroups(length' new ExtendedEnumerable<char>(new[] { '0'' '0' }' builder)' groupingSizes' groupingSeparator);                      }                      else                      {                          append = StringWithGroups(extra + builder.Length' builder' groupingSizes' groupingSeparator);                      }                  }                  result.Append(append);                  if (precision > 0)                  {                      result.Append(decimalSeparator);                      result.Append(new string('0'' precision));                  }                  result.Append(close);                  return result.ToString();              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,FormatBigInteger,The following statement contains a magic number: if (fmt == 'e' || fmt == 'E')              {                  var precision = digits != -1 ? digits : 6;                    if (value.InternalBits == null)                  {                      return value.InternalSign.ToString(format' info);                  }                    var scale = (int)Math.Floor(Log10(value));                  // ---                  if (scale > precision + 10)                  {                      do                      {                          value /= 1000000000;                      } while (Log10(value) > precision + 10);                  }                  while (Log10(value) > precision + 2)                  {                      value /= 10;                  }                  if ((Log10(value) > precision + 1))                  {                      var round = value % 10 >= 5;                      value = (value / 10) + (round ? One : Zero);                  }                    ReverseStringBuilder builder;                    if (value.InternalBits == null)                  {                      builder = new ReverseStringBuilder(10);                      builder.Prepend(value.InternalSign.ToString("D"));                  }                  else                  {                      builder = CreateBuilder(value' info' false' 0);                  }                    // ---                  var decimalSeparator = info.NumberDecimalSeparator;                    var result = new StringBuilder(builder.Length + 6);                    var extra = 0;                    if (precision >= builder.Length)                  {                      extra = precision - (builder.Length - 1);                      precision = builder.Length - 1;                  }                  result.Append(builder.ToString(builder.Length' 1));                  result.Append(decimalSeparator);                  result.Append(builder.ToString(builder.Length - 1' precision));                  result.Append(new string('0'' extra));                  result.Append(fmt);                  result.Append(info.PositiveSign);                  if (scale < 10)                  {                      result.Append("00");                  }                  else if (scale < 100)                  {                      result.Append('0');                  }                  result.Append(scale);                    return result.ToString();              }              else              {                  var decimalFmt = (fmt == 'g' || fmt == 'G' || fmt == 'd' || fmt == 'D' || fmt == 'r' || fmt == 'R');                  if (value.InternalBits == null)                  {                      if (fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R')                      {                          if (digits > 0)                          {                              format = "D" + digits.ToString(CultureInfo.InvariantCulture);                          }                          else                          {                              format = "D";                          }                      }                      return value.InternalSign.ToString(format' info);                  }                  var builder = CreateBuilder(value' info' decimalFmt' digits);                  if (decimalFmt)                  {                      // Format Round-trip decimal                      // This format is supported for integral types only. The number is converted to a string of                      // decimal digits (0-9)' prefixed by a minus sign if the number is negative. The precision                      // specifier indicates the minimum number of digits desired in the resulting string. If required'                      // the number is padded with zeros to its left to produce the number of digits given by the                      // precision specifier.                      while (digits > 0 && digits >= builder.Length)                      {                          builder.Prepend('0');                          digits--;                      }                      if (value.InternalSign < 0)                      {                          builder.Prepend(info.NegativeSign);                      }                      return builder.ToString();                  }                  // 'c'' 'C'' 'e'' 'E'' 'f'' 'F'' 'n'' 'N'' 'p'' 'P'' custom                  var precision = -1;                  var groupingSizes = new[] { 3 };                  var groupingSeparator = info.NumberGroupSeparator;                  var decimalSeparator = info.NumberDecimalSeparator;                  var groups = false;                  var type = 0;                  if (fmt == '\0')                  {                      // parse custom                  }                  else                  {                      if (fmt == 'c' || fmt == 'C')                      {                          decimalSeparator = info.CurrencyDecimalSeparator;                          precision = digits != -1 ? digits : info.CurrencyDecimalDigits;                          groupingSeparator = info.CurrencyGroupSeparator;                          groupingSizes = info.CurrencyGroupSizes;                          groups = true;                          type = 1;                      }                      else if (fmt == 'f' || fmt == 'F')                      {                          precision = digits != -1 ? digits : info.NumberDecimalDigits;                      }                      else if (fmt == 'n' || fmt == 'N')                      {                          precision = digits != -1 ? digits : info.NumberDecimalDigits;                          groups = true;                      }                      else if (fmt == 'p' || fmt == 'P')                      {                          decimalSeparator = info.PercentDecimalSeparator;                          precision = digits != -1 ? digits : info.PercentDecimalDigits;                          groups = true;                          type = 2;                      }                      else                      {                          throw new NotImplementedException();                      }                  }                  var result = new StringBuilder(builder.Length + 20);                  var close = SetWrap(value' info' type' result);                  var append = builder;                  if (groups)                  {                      var extra = groupingSizes.Length - 1;                      if (groupingSizes[groupingSizes.Length - 1] != 0)                      {                          var totalDigits = builder.Length;                          extra += (int)Math.Ceiling(totalDigits * 1.0 / groupingSizes[groupingSizes.Length - 1]);                      }                      var length = extra + builder.Length;                      if (type == 2)                      {                          length += 2;                          append = StringWithGroups(length' new ExtendedEnumerable<char>(new[] { '0'' '0' }' builder)' groupingSizes' groupingSeparator);                      }                      else                      {                          append = StringWithGroups(extra + builder.Length' builder' groupingSizes' groupingSeparator);                      }                  }                  result.Append(append);                  if (precision > 0)                  {                      result.Append(decimalSeparator);                      result.Append(new string('0'' precision));                  }                  result.Append(close);                  return result.ToString();              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,FormatBigInteger,The following statement contains a magic number: if (fmt == 'e' || fmt == 'E')              {                  var precision = digits != -1 ? digits : 6;                    if (value.InternalBits == null)                  {                      return value.InternalSign.ToString(format' info);                  }                    var scale = (int)Math.Floor(Log10(value));                  // ---                  if (scale > precision + 10)                  {                      do                      {                          value /= 1000000000;                      } while (Log10(value) > precision + 10);                  }                  while (Log10(value) > precision + 2)                  {                      value /= 10;                  }                  if ((Log10(value) > precision + 1))                  {                      var round = value % 10 >= 5;                      value = (value / 10) + (round ? One : Zero);                  }                    ReverseStringBuilder builder;                    if (value.InternalBits == null)                  {                      builder = new ReverseStringBuilder(10);                      builder.Prepend(value.InternalSign.ToString("D"));                  }                  else                  {                      builder = CreateBuilder(value' info' false' 0);                  }                    // ---                  var decimalSeparator = info.NumberDecimalSeparator;                    var result = new StringBuilder(builder.Length + 6);                    var extra = 0;                    if (precision >= builder.Length)                  {                      extra = precision - (builder.Length - 1);                      precision = builder.Length - 1;                  }                  result.Append(builder.ToString(builder.Length' 1));                  result.Append(decimalSeparator);                  result.Append(builder.ToString(builder.Length - 1' precision));                  result.Append(new string('0'' extra));                  result.Append(fmt);                  result.Append(info.PositiveSign);                  if (scale < 10)                  {                      result.Append("00");                  }                  else if (scale < 100)                  {                      result.Append('0');                  }                  result.Append(scale);                    return result.ToString();              }              else              {                  var decimalFmt = (fmt == 'g' || fmt == 'G' || fmt == 'd' || fmt == 'D' || fmt == 'r' || fmt == 'R');                  if (value.InternalBits == null)                  {                      if (fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R')                      {                          if (digits > 0)                          {                              format = "D" + digits.ToString(CultureInfo.InvariantCulture);                          }                          else                          {                              format = "D";                          }                      }                      return value.InternalSign.ToString(format' info);                  }                  var builder = CreateBuilder(value' info' decimalFmt' digits);                  if (decimalFmt)                  {                      // Format Round-trip decimal                      // This format is supported for integral types only. The number is converted to a string of                      // decimal digits (0-9)' prefixed by a minus sign if the number is negative. The precision                      // specifier indicates the minimum number of digits desired in the resulting string. If required'                      // the number is padded with zeros to its left to produce the number of digits given by the                      // precision specifier.                      while (digits > 0 && digits >= builder.Length)                      {                          builder.Prepend('0');                          digits--;                      }                      if (value.InternalSign < 0)                      {                          builder.Prepend(info.NegativeSign);                      }                      return builder.ToString();                  }                  // 'c'' 'C'' 'e'' 'E'' 'f'' 'F'' 'n'' 'N'' 'p'' 'P'' custom                  var precision = -1;                  var groupingSizes = new[] { 3 };                  var groupingSeparator = info.NumberGroupSeparator;                  var decimalSeparator = info.NumberDecimalSeparator;                  var groups = false;                  var type = 0;                  if (fmt == '\0')                  {                      // parse custom                  }                  else                  {                      if (fmt == 'c' || fmt == 'C')                      {                          decimalSeparator = info.CurrencyDecimalSeparator;                          precision = digits != -1 ? digits : info.CurrencyDecimalDigits;                          groupingSeparator = info.CurrencyGroupSeparator;                          groupingSizes = info.CurrencyGroupSizes;                          groups = true;                          type = 1;                      }                      else if (fmt == 'f' || fmt == 'F')                      {                          precision = digits != -1 ? digits : info.NumberDecimalDigits;                      }                      else if (fmt == 'n' || fmt == 'N')                      {                          precision = digits != -1 ? digits : info.NumberDecimalDigits;                          groups = true;                      }                      else if (fmt == 'p' || fmt == 'P')                      {                          decimalSeparator = info.PercentDecimalSeparator;                          precision = digits != -1 ? digits : info.PercentDecimalDigits;                          groups = true;                          type = 2;                      }                      else                      {                          throw new NotImplementedException();                      }                  }                  var result = new StringBuilder(builder.Length + 20);                  var close = SetWrap(value' info' type' result);                  var append = builder;                  if (groups)                  {                      var extra = groupingSizes.Length - 1;                      if (groupingSizes[groupingSizes.Length - 1] != 0)                      {                          var totalDigits = builder.Length;                          extra += (int)Math.Ceiling(totalDigits * 1.0 / groupingSizes[groupingSizes.Length - 1]);                      }                      var length = extra + builder.Length;                      if (type == 2)                      {                          length += 2;                          append = StringWithGroups(length' new ExtendedEnumerable<char>(new[] { '0'' '0' }' builder)' groupingSizes' groupingSeparator);                      }                      else                      {                          append = StringWithGroups(extra + builder.Length' builder' groupingSizes' groupingSeparator);                      }                  }                  result.Append(append);                  if (precision > 0)                  {                      result.Append(decimalSeparator);                      result.Append(new string('0'' precision));                  }                  result.Append(close);                  return result.ToString();              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,FormatBigInteger,The following statement contains a magic number: if (fmt == 'e' || fmt == 'E')              {                  var precision = digits != -1 ? digits : 6;                    if (value.InternalBits == null)                  {                      return value.InternalSign.ToString(format' info);                  }                    var scale = (int)Math.Floor(Log10(value));                  // ---                  if (scale > precision + 10)                  {                      do                      {                          value /= 1000000000;                      } while (Log10(value) > precision + 10);                  }                  while (Log10(value) > precision + 2)                  {                      value /= 10;                  }                  if ((Log10(value) > precision + 1))                  {                      var round = value % 10 >= 5;                      value = (value / 10) + (round ? One : Zero);                  }                    ReverseStringBuilder builder;                    if (value.InternalBits == null)                  {                      builder = new ReverseStringBuilder(10);                      builder.Prepend(value.InternalSign.ToString("D"));                  }                  else                  {                      builder = CreateBuilder(value' info' false' 0);                  }                    // ---                  var decimalSeparator = info.NumberDecimalSeparator;                    var result = new StringBuilder(builder.Length + 6);                    var extra = 0;                    if (precision >= builder.Length)                  {                      extra = precision - (builder.Length - 1);                      precision = builder.Length - 1;                  }                  result.Append(builder.ToString(builder.Length' 1));                  result.Append(decimalSeparator);                  result.Append(builder.ToString(builder.Length - 1' precision));                  result.Append(new string('0'' extra));                  result.Append(fmt);                  result.Append(info.PositiveSign);                  if (scale < 10)                  {                      result.Append("00");                  }                  else if (scale < 100)                  {                      result.Append('0');                  }                  result.Append(scale);                    return result.ToString();              }              else              {                  var decimalFmt = (fmt == 'g' || fmt == 'G' || fmt == 'd' || fmt == 'D' || fmt == 'r' || fmt == 'R');                  if (value.InternalBits == null)                  {                      if (fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R')                      {                          if (digits > 0)                          {                              format = "D" + digits.ToString(CultureInfo.InvariantCulture);                          }                          else                          {                              format = "D";                          }                      }                      return value.InternalSign.ToString(format' info);                  }                  var builder = CreateBuilder(value' info' decimalFmt' digits);                  if (decimalFmt)                  {                      // Format Round-trip decimal                      // This format is supported for integral types only. The number is converted to a string of                      // decimal digits (0-9)' prefixed by a minus sign if the number is negative. The precision                      // specifier indicates the minimum number of digits desired in the resulting string. If required'                      // the number is padded with zeros to its left to produce the number of digits given by the                      // precision specifier.                      while (digits > 0 && digits >= builder.Length)                      {                          builder.Prepend('0');                          digits--;                      }                      if (value.InternalSign < 0)                      {                          builder.Prepend(info.NegativeSign);                      }                      return builder.ToString();                  }                  // 'c'' 'C'' 'e'' 'E'' 'f'' 'F'' 'n'' 'N'' 'p'' 'P'' custom                  var precision = -1;                  var groupingSizes = new[] { 3 };                  var groupingSeparator = info.NumberGroupSeparator;                  var decimalSeparator = info.NumberDecimalSeparator;                  var groups = false;                  var type = 0;                  if (fmt == '\0')                  {                      // parse custom                  }                  else                  {                      if (fmt == 'c' || fmt == 'C')                      {                          decimalSeparator = info.CurrencyDecimalSeparator;                          precision = digits != -1 ? digits : info.CurrencyDecimalDigits;                          groupingSeparator = info.CurrencyGroupSeparator;                          groupingSizes = info.CurrencyGroupSizes;                          groups = true;                          type = 1;                      }                      else if (fmt == 'f' || fmt == 'F')                      {                          precision = digits != -1 ? digits : info.NumberDecimalDigits;                      }                      else if (fmt == 'n' || fmt == 'N')                      {                          precision = digits != -1 ? digits : info.NumberDecimalDigits;                          groups = true;                      }                      else if (fmt == 'p' || fmt == 'P')                      {                          decimalSeparator = info.PercentDecimalSeparator;                          precision = digits != -1 ? digits : info.PercentDecimalDigits;                          groups = true;                          type = 2;                      }                      else                      {                          throw new NotImplementedException();                      }                  }                  var result = new StringBuilder(builder.Length + 20);                  var close = SetWrap(value' info' type' result);                  var append = builder;                  if (groups)                  {                      var extra = groupingSizes.Length - 1;                      if (groupingSizes[groupingSizes.Length - 1] != 0)                      {                          var totalDigits = builder.Length;                          extra += (int)Math.Ceiling(totalDigits * 1.0 / groupingSizes[groupingSizes.Length - 1]);                      }                      var length = extra + builder.Length;                      if (type == 2)                      {                          length += 2;                          append = StringWithGroups(length' new ExtendedEnumerable<char>(new[] { '0'' '0' }' builder)' groupingSizes' groupingSeparator);                      }                      else                      {                          append = StringWithGroups(extra + builder.Length' builder' groupingSizes' groupingSeparator);                      }                  }                  result.Append(append);                  if (precision > 0)                  {                      result.Append(decimalSeparator);                      result.Append(new string('0'' precision));                  }                  result.Append(close);                  return result.ToString();              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,FormatBigInteger,The following statement contains a magic number: if (fmt == 'e' || fmt == 'E')              {                  var precision = digits != -1 ? digits : 6;                    if (value.InternalBits == null)                  {                      return value.InternalSign.ToString(format' info);                  }                    var scale = (int)Math.Floor(Log10(value));                  // ---                  if (scale > precision + 10)                  {                      do                      {                          value /= 1000000000;                      } while (Log10(value) > precision + 10);                  }                  while (Log10(value) > precision + 2)                  {                      value /= 10;                  }                  if ((Log10(value) > precision + 1))                  {                      var round = value % 10 >= 5;                      value = (value / 10) + (round ? One : Zero);                  }                    ReverseStringBuilder builder;                    if (value.InternalBits == null)                  {                      builder = new ReverseStringBuilder(10);                      builder.Prepend(value.InternalSign.ToString("D"));                  }                  else                  {                      builder = CreateBuilder(value' info' false' 0);                  }                    // ---                  var decimalSeparator = info.NumberDecimalSeparator;                    var result = new StringBuilder(builder.Length + 6);                    var extra = 0;                    if (precision >= builder.Length)                  {                      extra = precision - (builder.Length - 1);                      precision = builder.Length - 1;                  }                  result.Append(builder.ToString(builder.Length' 1));                  result.Append(decimalSeparator);                  result.Append(builder.ToString(builder.Length - 1' precision));                  result.Append(new string('0'' extra));                  result.Append(fmt);                  result.Append(info.PositiveSign);                  if (scale < 10)                  {                      result.Append("00");                  }                  else if (scale < 100)                  {                      result.Append('0');                  }                  result.Append(scale);                    return result.ToString();              }              else              {                  var decimalFmt = (fmt == 'g' || fmt == 'G' || fmt == 'd' || fmt == 'D' || fmt == 'r' || fmt == 'R');                  if (value.InternalBits == null)                  {                      if (fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R')                      {                          if (digits > 0)                          {                              format = "D" + digits.ToString(CultureInfo.InvariantCulture);                          }                          else                          {                              format = "D";                          }                      }                      return value.InternalSign.ToString(format' info);                  }                  var builder = CreateBuilder(value' info' decimalFmt' digits);                  if (decimalFmt)                  {                      // Format Round-trip decimal                      // This format is supported for integral types only. The number is converted to a string of                      // decimal digits (0-9)' prefixed by a minus sign if the number is negative. The precision                      // specifier indicates the minimum number of digits desired in the resulting string. If required'                      // the number is padded with zeros to its left to produce the number of digits given by the                      // precision specifier.                      while (digits > 0 && digits >= builder.Length)                      {                          builder.Prepend('0');                          digits--;                      }                      if (value.InternalSign < 0)                      {                          builder.Prepend(info.NegativeSign);                      }                      return builder.ToString();                  }                  // 'c'' 'C'' 'e'' 'E'' 'f'' 'F'' 'n'' 'N'' 'p'' 'P'' custom                  var precision = -1;                  var groupingSizes = new[] { 3 };                  var groupingSeparator = info.NumberGroupSeparator;                  var decimalSeparator = info.NumberDecimalSeparator;                  var groups = false;                  var type = 0;                  if (fmt == '\0')                  {                      // parse custom                  }                  else                  {                      if (fmt == 'c' || fmt == 'C')                      {                          decimalSeparator = info.CurrencyDecimalSeparator;                          precision = digits != -1 ? digits : info.CurrencyDecimalDigits;                          groupingSeparator = info.CurrencyGroupSeparator;                          groupingSizes = info.CurrencyGroupSizes;                          groups = true;                          type = 1;                      }                      else if (fmt == 'f' || fmt == 'F')                      {                          precision = digits != -1 ? digits : info.NumberDecimalDigits;                      }                      else if (fmt == 'n' || fmt == 'N')                      {                          precision = digits != -1 ? digits : info.NumberDecimalDigits;                          groups = true;                      }                      else if (fmt == 'p' || fmt == 'P')                      {                          decimalSeparator = info.PercentDecimalSeparator;                          precision = digits != -1 ? digits : info.PercentDecimalDigits;                          groups = true;                          type = 2;                      }                      else                      {                          throw new NotImplementedException();                      }                  }                  var result = new StringBuilder(builder.Length + 20);                  var close = SetWrap(value' info' type' result);                  var append = builder;                  if (groups)                  {                      var extra = groupingSizes.Length - 1;                      if (groupingSizes[groupingSizes.Length - 1] != 0)                      {                          var totalDigits = builder.Length;                          extra += (int)Math.Ceiling(totalDigits * 1.0 / groupingSizes[groupingSizes.Length - 1]);                      }                      var length = extra + builder.Length;                      if (type == 2)                      {                          length += 2;                          append = StringWithGroups(length' new ExtendedEnumerable<char>(new[] { '0'' '0' }' builder)' groupingSizes' groupingSeparator);                      }                      else                      {                          append = StringWithGroups(extra + builder.Length' builder' groupingSizes' groupingSeparator);                      }                  }                  result.Append(append);                  if (precision > 0)                  {                      result.Append(decimalSeparator);                      result.Append(new string('0'' precision));                  }                  result.Append(close);                  return result.ToString();              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,ParseFormatSpecifier,The following statement contains a magic number: if (chr >= 'A' && chr <= 'Z' || chr >= 'a' && chr <= 'z')              {                  index++;                  if (index < format.Length)                  {                      var tmp = format[index];                      if (tmp >= '0' && tmp <= '9')                      {                          index++;                          digits = tmp - '0';                          do                          {                              if (index >= format.Length || format[index] < '0' || format[index] > '9')                              {                                  break;                              }                              digits = digits * 10 + (format[index] - '0');                              index++;                          } while (digits < 10);                      }                  }                  if (index >= format.Length || format[index] == 0)                  {                      return chr;                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,ParseFormatSpecifier,The following statement contains a magic number: if (chr >= 'A' && chr <= 'Z' || chr >= 'a' && chr <= 'z')              {                  index++;                  if (index < format.Length)                  {                      var tmp = format[index];                      if (tmp >= '0' && tmp <= '9')                      {                          index++;                          digits = tmp - '0';                          do                          {                              if (index >= format.Length || format[index] < '0' || format[index] > '9')                              {                                  break;                              }                              digits = digits * 10 + (format[index] - '0');                              index++;                          } while (digits < 10);                      }                  }                  if (index >= format.Length || format[index] == 0)                  {                      return chr;                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,ParseNumber,The following statement contains a magic number: if ((options & NumberStyles.AllowHexSpecifier) != NumberStyles.None)              {                  var allowLeadingWhite = (options & NumberStyles.AllowLeadingWhite) != NumberStyles.None;                  var allowTrailingWhite = (options & NumberStyles.AllowTrailingWhite) != NumberStyles.None;                  /*                  // Assume validated                  if (                      (options & NumberStyles.AllowCurrencySymbol) != NumberStyles.None                      || (options & NumberStyles.AllowLeadingSign) != NumberStyles.None                      || (options & NumberStyles.AllowParentheses) != NumberStyles.None                      || (options & NumberStyles.AllowThousands) != NumberStyles.None                      || (options & NumberStyles.AllowExponent) != NumberStyles.None                      || (options & NumberStyles.AllowTrailingSign) != NumberStyles.None                      )                  {                      return false;                  }*/                  number.Negative = false;                  if (allowLeadingWhite)                  {                      reader.SkipWhile(CharHelper.IsClassicWhitespace);                  }                  while (true)                  {                      var input =                          reader.ReadWhile(new[]                          {                              '0'' '1'' '2'' '3'' '4'' '5'' '6'' '7'' '8'' '9'' 'a'' 'b'' 'c'' 'd'' 'e'' 'f'' 'A'' 'B'' 'C''                              'D'' 'E'' 'F'                          });                      if (input == string.Empty)                      {                          break;                      }                      number.Scale += input.Length;                      number.Digits.Append(input.ToUpperInvariant());                  }                  if (allowTrailingWhite)                  {                      reader.SkipWhile(CharHelper.IsClassicWhitespace);                  }                  return reader.EndOfString;              }              else              {                  var allowCurrencySymbol = (options & NumberStyles.AllowCurrencySymbol) != NumberStyles.None;                  var allowLeadingWhite = (options & NumberStyles.AllowLeadingWhite) != NumberStyles.None;                  var allowLeadingSign = (options & NumberStyles.AllowLeadingSign) != NumberStyles.None;                  var allowParentheses = (options & NumberStyles.AllowParentheses) != NumberStyles.None;                  var allowThousands = (options & NumberStyles.AllowThousands) != NumberStyles.None;                  var allowExponent = (options & NumberStyles.AllowExponent) != NumberStyles.None;                  var allowTrailingWhite = (options & NumberStyles.AllowTrailingWhite) != NumberStyles.None;                  var allowTrailingSign = (options & NumberStyles.AllowTrailingSign) != NumberStyles.None;                  var allowDecimalPoint = (options & NumberStyles.AllowDecimalPoint) != NumberStyles.None;                    var isCurrency = false;                  number.Negative = false;                  var waitingParentheses = false;                  var positive = false;                  // [ws][$][sign][digits']digits[E[sign]exponential_digits][ws]                  if (allowLeadingWhite)                  {                      reader.SkipWhile(CharHelper.IsClassicWhitespace);                  }                  // [$][sign][digits']digits[E[sign]exponential_digits][ws]                  if (allowCurrencySymbol && reader.Read(currencySymbol))                  {                      isCurrency = true;                      reader.SkipWhile(CharHelper.IsClassicWhitespace);                  }                  // [sign][digits']digits[E[sign]exponential_digits][ws                  if (allowLeadingSign)                  {                      number.Negative |= reader.Read(negativeSign);                      positive |= reader.Read(positiveSign);                  }                  if (!number.Negative && allowParentheses && reader.Read('('))                  {                      // Testing on .NET show that $(n) is allowed' even tho there is no CurrencyNegativePattern for it                      number.Negative = true;                      waitingParentheses = true;                  }                  // ---                  if (!isCurrency && allowCurrencySymbol && reader.Read(currencySymbol)) // If the currency symbol is after the negative sign                  {                      isCurrency = true;                      reader.SkipWhile(CharHelper.IsClassicWhitespace);                  }                  // [digits']digits[E[sign]exponential_digits][ws]                  var failure = true;                  var digits = new[] { '0'' '1'' '2'' '3'' '4'' '5'' '6'' '7'' '8'' '9' };                  var decimalFound = false;                  while (true)                  {                      var input = reader.ReadWhile(digits);                      if (input == string.Empty)                      {                          if (allowDecimalPoint && !decimalFound)                          {                              if (reader.Read(info.CurrencyDecimalSeparator))                              {                                  decimalFound = true;                                  continue;                              }                              if (reader.Read(info.NumberDecimalSeparator))                              {                                  if (isCurrency)                                  {                                      return false;                                  }                                  decimalFound = true;                                  continue;                              }                          }                          break;                      }                      failure = false;                      if (!decimalFound)                      {                          number.Scale += input.Length;                      }                      number.Digits.Append(input);                      if (allowThousands)                      {                          // Testing on .NET show that combining currency and number group separators is allowed                          // But not if the currency symbol has already appeared                          reader.SkipWhile(currencyGroupSeparator);                          if (!isCurrency)                          {                              reader.SkipWhile(numberGroupSeparator);                          }                      }                  }                  if (failure)                  {                      return false;                  }                  // [E[sign]exponential_digits][ws]                  if (allowExponent && (reader.Read('E') || reader.Read('e')))                  {                      // [sign]exponential_digits                      // Testing on .NET show that no pattern is used here' also no parentheses nor group separators supported                      // The exponent can be big - but anything beyond 9999 is ignored                      var exponentNegative = reader.Read(negativeSign);                      if (!exponentNegative)                      {                          reader.Read(positiveSign);                      }                      var input = reader.ReadWhile(digits);                      var exponentMagnitude = int.Parse(input' CultureInfo.InvariantCulture);                      number.Scale += (exponentNegative ? -1 : 1) * (input.Length > 4 ? 9999 : exponentMagnitude);                      if (number.Scale < 0)                      {                          return false;                      }                  }                  // ---                  if (allowTrailingWhite)                  {                      reader.SkipWhile(CharHelper.IsClassicWhitespace);                  }                  if (!isCurrency && allowCurrencySymbol && reader.Read(currencySymbol))                  {                      isCurrency = true;                  }                  // ---                  if (!number.Negative && !positive && allowTrailingSign)                  {                      number.Negative |= reader.Read(negativeSign);                      positive |= reader.Read(positiveSign);                  }                  if (waitingParentheses && !reader.Read(')'))                  {                      return false;                  }                  // ---                  if (!isCurrency && allowCurrencySymbol && reader.Read(currencySymbol)) // If the currency symbol is after the negative sign                  {                      isCurrency = true; // For completeness sake                  }                  // [ws]                  if (allowTrailingWhite)                  {                      reader.SkipWhile(CharHelper.IsClassicWhitespace);                  }                  return reader.EndOfString;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,ParseNumber,The following statement contains a magic number: if ((options & NumberStyles.AllowHexSpecifier) != NumberStyles.None)              {                  var allowLeadingWhite = (options & NumberStyles.AllowLeadingWhite) != NumberStyles.None;                  var allowTrailingWhite = (options & NumberStyles.AllowTrailingWhite) != NumberStyles.None;                  /*                  // Assume validated                  if (                      (options & NumberStyles.AllowCurrencySymbol) != NumberStyles.None                      || (options & NumberStyles.AllowLeadingSign) != NumberStyles.None                      || (options & NumberStyles.AllowParentheses) != NumberStyles.None                      || (options & NumberStyles.AllowThousands) != NumberStyles.None                      || (options & NumberStyles.AllowExponent) != NumberStyles.None                      || (options & NumberStyles.AllowTrailingSign) != NumberStyles.None                      )                  {                      return false;                  }*/                  number.Negative = false;                  if (allowLeadingWhite)                  {                      reader.SkipWhile(CharHelper.IsClassicWhitespace);                  }                  while (true)                  {                      var input =                          reader.ReadWhile(new[]                          {                              '0'' '1'' '2'' '3'' '4'' '5'' '6'' '7'' '8'' '9'' 'a'' 'b'' 'c'' 'd'' 'e'' 'f'' 'A'' 'B'' 'C''                              'D'' 'E'' 'F'                          });                      if (input == string.Empty)                      {                          break;                      }                      number.Scale += input.Length;                      number.Digits.Append(input.ToUpperInvariant());                  }                  if (allowTrailingWhite)                  {                      reader.SkipWhile(CharHelper.IsClassicWhitespace);                  }                  return reader.EndOfString;              }              else              {                  var allowCurrencySymbol = (options & NumberStyles.AllowCurrencySymbol) != NumberStyles.None;                  var allowLeadingWhite = (options & NumberStyles.AllowLeadingWhite) != NumberStyles.None;                  var allowLeadingSign = (options & NumberStyles.AllowLeadingSign) != NumberStyles.None;                  var allowParentheses = (options & NumberStyles.AllowParentheses) != NumberStyles.None;                  var allowThousands = (options & NumberStyles.AllowThousands) != NumberStyles.None;                  var allowExponent = (options & NumberStyles.AllowExponent) != NumberStyles.None;                  var allowTrailingWhite = (options & NumberStyles.AllowTrailingWhite) != NumberStyles.None;                  var allowTrailingSign = (options & NumberStyles.AllowTrailingSign) != NumberStyles.None;                  var allowDecimalPoint = (options & NumberStyles.AllowDecimalPoint) != NumberStyles.None;                    var isCurrency = false;                  number.Negative = false;                  var waitingParentheses = false;                  var positive = false;                  // [ws][$][sign][digits']digits[E[sign]exponential_digits][ws]                  if (allowLeadingWhite)                  {                      reader.SkipWhile(CharHelper.IsClassicWhitespace);                  }                  // [$][sign][digits']digits[E[sign]exponential_digits][ws]                  if (allowCurrencySymbol && reader.Read(currencySymbol))                  {                      isCurrency = true;                      reader.SkipWhile(CharHelper.IsClassicWhitespace);                  }                  // [sign][digits']digits[E[sign]exponential_digits][ws                  if (allowLeadingSign)                  {                      number.Negative |= reader.Read(negativeSign);                      positive |= reader.Read(positiveSign);                  }                  if (!number.Negative && allowParentheses && reader.Read('('))                  {                      // Testing on .NET show that $(n) is allowed' even tho there is no CurrencyNegativePattern for it                      number.Negative = true;                      waitingParentheses = true;                  }                  // ---                  if (!isCurrency && allowCurrencySymbol && reader.Read(currencySymbol)) // If the currency symbol is after the negative sign                  {                      isCurrency = true;                      reader.SkipWhile(CharHelper.IsClassicWhitespace);                  }                  // [digits']digits[E[sign]exponential_digits][ws]                  var failure = true;                  var digits = new[] { '0'' '1'' '2'' '3'' '4'' '5'' '6'' '7'' '8'' '9' };                  var decimalFound = false;                  while (true)                  {                      var input = reader.ReadWhile(digits);                      if (input == string.Empty)                      {                          if (allowDecimalPoint && !decimalFound)                          {                              if (reader.Read(info.CurrencyDecimalSeparator))                              {                                  decimalFound = true;                                  continue;                              }                              if (reader.Read(info.NumberDecimalSeparator))                              {                                  if (isCurrency)                                  {                                      return false;                                  }                                  decimalFound = true;                                  continue;                              }                          }                          break;                      }                      failure = false;                      if (!decimalFound)                      {                          number.Scale += input.Length;                      }                      number.Digits.Append(input);                      if (allowThousands)                      {                          // Testing on .NET show that combining currency and number group separators is allowed                          // But not if the currency symbol has already appeared                          reader.SkipWhile(currencyGroupSeparator);                          if (!isCurrency)                          {                              reader.SkipWhile(numberGroupSeparator);                          }                      }                  }                  if (failure)                  {                      return false;                  }                  // [E[sign]exponential_digits][ws]                  if (allowExponent && (reader.Read('E') || reader.Read('e')))                  {                      // [sign]exponential_digits                      // Testing on .NET show that no pattern is used here' also no parentheses nor group separators supported                      // The exponent can be big - but anything beyond 9999 is ignored                      var exponentNegative = reader.Read(negativeSign);                      if (!exponentNegative)                      {                          reader.Read(positiveSign);                      }                      var input = reader.ReadWhile(digits);                      var exponentMagnitude = int.Parse(input' CultureInfo.InvariantCulture);                      number.Scale += (exponentNegative ? -1 : 1) * (input.Length > 4 ? 9999 : exponentMagnitude);                      if (number.Scale < 0)                      {                          return false;                      }                  }                  // ---                  if (allowTrailingWhite)                  {                      reader.SkipWhile(CharHelper.IsClassicWhitespace);                  }                  if (!isCurrency && allowCurrencySymbol && reader.Read(currencySymbol))                  {                      isCurrency = true;                  }                  // ---                  if (!number.Negative && !positive && allowTrailingSign)                  {                      number.Negative |= reader.Read(negativeSign);                      positive |= reader.Read(positiveSign);                  }                  if (waitingParentheses && !reader.Read(')'))                  {                      return false;                  }                  // ---                  if (!isCurrency && allowCurrencySymbol && reader.Read(currencySymbol)) // If the currency symbol is after the negative sign                  {                      isCurrency = true; // For completeness sake                  }                  // [ws]                  if (allowTrailingWhite)                  {                      reader.SkipWhile(CharHelper.IsClassicWhitespace);                  }                  return reader.EndOfString;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,TryValidateParseStyleInteger,The following statement contains a magic number: if (((int)style & -1024) != (int)NumberStyles.None)              {                  e = new ArgumentException("An undefined NumberStyles value is being used."' "style");                  return false;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,CreateBuilder,The following statement contains a magic number: const uint NumericBase = 1000000000;
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,CreateBuilder,The following statement contains a magic number: const int NumericBaseLog10 = 9;
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,CreateBuilder,The following statement contains a magic number: try              {                  maxConvertedLength = checked(sourceLength * 10 / 9 + 2);              }              catch (OverflowException e)              {                  throw new FormatException("The value is too large to be represented by this format specifier."' e);              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,CreateBuilder,The following statement contains a magic number: try              {                  maxConvertedLength = checked(sourceLength * 10 / 9 + 2);              }              catch (OverflowException e)              {                  throw new FormatException("The value is too large to be represented by this format specifier."' e);              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,CreateBuilder,The following statement contains a magic number: try              {                  maxConvertedLength = checked(sourceLength * 10 / 9 + 2);              }              catch (OverflowException e)              {                  throw new FormatException("The value is too large to be represented by this format specifier."' e);              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,CreateBuilder,The following statement contains a magic number: for (var stringIndex = 0; stringIndex < convertedLength - 1; stringIndex++)              {                  var cipherBlock = converted[stringIndex];                  for (var cch = NumericBaseLog10; --cch >= 0;)                  {                      result.Prepend((char)('0' + cipherBlock % 10));                      cipherBlock /= 10;                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,CreateBuilder,The following statement contains a magic number: for (var stringIndex = 0; stringIndex < convertedLength - 1; stringIndex++)              {                  var cipherBlock = converted[stringIndex];                  for (var cch = NumericBaseLog10; --cch >= 0;)                  {                      result.Prepend((char)('0' + cipherBlock % 10));                      cipherBlock /= 10;                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,CreateBuilder,The following statement contains a magic number: for (var cipherBlock = converted[convertedLength - 1]; cipherBlock != 0;)              {                  result.Prepend((char)('0' + cipherBlock % 10));                  cipherBlock /= 10;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,CreateBuilder,The following statement contains a magic number: for (var cipherBlock = converted[convertedLength - 1]; cipherBlock != 0;)              {                  result.Prepend((char)('0' + cipherBlock % 10));                  cipherBlock /= 10;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,FormatBigIntegerToHexString,The following statement contains a magic number: if (length > -1)              {                  var flag = false;                  var num = byteArray[length];                  if (num > 247)                  {                      num = (byte)(num - 240);                      flag = true;                  }                  if (num < 8 || flag)                  {                      str1 = string.Format(CultureInfo.InvariantCulture' "{0}1"' format);                      stringBuilder.Append(num.ToString(str1' info));                      length--;                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,FormatBigIntegerToHexString,The following statement contains a magic number: if (length > -1)              {                  var flag = false;                  var num = byteArray[length];                  if (num > 247)                  {                      num = (byte)(num - 240);                      flag = true;                  }                  if (num < 8 || flag)                  {                      str1 = string.Format(CultureInfo.InvariantCulture' "{0}1"' format);                      stringBuilder.Append(num.ToString(str1' info));                      length--;                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,FormatBigIntegerToHexString,The following statement contains a magic number: if (length > -1)              {                  var flag = false;                  var num = byteArray[length];                  if (num > 247)                  {                      num = (byte)(num - 240);                      flag = true;                  }                  if (num < 8 || flag)                  {                      str1 = string.Format(CultureInfo.InvariantCulture' "{0}1"' format);                      stringBuilder.Append(num.ToString(str1' info));                      length--;                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,HexNumberToBigInteger,The following statement contains a magic number: var bits = new byte[(len / 2) + (len % 2)];
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,HexNumberToBigInteger,The following statement contains a magic number: var bits = new byte[(len / 2) + (len % 2)];
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,HexNumberToBigInteger,The following statement contains a magic number: for (var i = len - 1; i > -1; i--)              {                  var c = number.Digits[i];                    byte b;                  if (c >= '0' && c <= '9')                  {                      b = (byte)(c - '0');                  }                  else if (c >= 'A' && c <= 'F')                  {                      b = (byte)((c - 'A') + 10);                  }                  else                  {                      Contract.Assert(c >= 'a' && c <= 'f');                      b = (byte)((c - 'a') + 10);                  }                  isNegative |= (i == 0 && (b & 0x08) == 0x08);                    if (shift)                  {                      bits[bitIndex] = (byte)(bits[bitIndex] | (b << 4));                      bitIndex++;                  }                  else                  {                      bits[bitIndex] = isNegative ? (byte)(b | 0xF0) : (b);                  }                  shift = !shift;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,HexNumberToBigInteger,The following statement contains a magic number: for (var i = len - 1; i > -1; i--)              {                  var c = number.Digits[i];                    byte b;                  if (c >= '0' && c <= '9')                  {                      b = (byte)(c - '0');                  }                  else if (c >= 'A' && c <= 'F')                  {                      b = (byte)((c - 'A') + 10);                  }                  else                  {                      Contract.Assert(c >= 'a' && c <= 'f');                      b = (byte)((c - 'a') + 10);                  }                  isNegative |= (i == 0 && (b & 0x08) == 0x08);                    if (shift)                  {                      bits[bitIndex] = (byte)(bits[bitIndex] | (b << 4));                      bitIndex++;                  }                  else                  {                      bits[bitIndex] = isNegative ? (byte)(b | 0xF0) : (b);                  }                  shift = !shift;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,HexNumberToBigInteger,The following statement contains a magic number: for (var i = len - 1; i > -1; i--)              {                  var c = number.Digits[i];                    byte b;                  if (c >= '0' && c <= '9')                  {                      b = (byte)(c - '0');                  }                  else if (c >= 'A' && c <= 'F')                  {                      b = (byte)((c - 'A') + 10);                  }                  else                  {                      Contract.Assert(c >= 'a' && c <= 'f');                      b = (byte)((c - 'a') + 10);                  }                  isNegative |= (i == 0 && (b & 0x08) == 0x08);                    if (shift)                  {                      bits[bitIndex] = (byte)(bits[bitIndex] | (b << 4));                      bitIndex++;                  }                  else                  {                      bits[bitIndex] = isNegative ? (byte)(b | 0xF0) : (b);                  }                  shift = !shift;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,NumberToBigInteger,The following statement contains a magic number: if (number.Scale > number.Digits.Length)              {                  var i = number.Digits.Length;                  value = 0;                  while (--i >= 0)                  {                      value *= 10;                      value += (number.Digits[cur++] - '0');                  }                  var adjust = number.Scale - number.Digits.Length;                  while (adjust > 9)                  {                      value *= 1000000000;                      adjust -= 9;                  }                  while (adjust > 0)                  {                      value *= 10;                      adjust--;                  }              }              else              {                  var i = number.Scale;                  value = 0;                  while (--i >= 0)                  {                      value *= 10;                      value += (number.Digits[cur++] - '0');                  }                  for (; cur < number.Digits.Length - 1; cur++)                  {                      if (number.Digits[cur++] != '0')                      {                          return false;                      }                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,NumberToBigInteger,The following statement contains a magic number: if (number.Scale > number.Digits.Length)              {                  var i = number.Digits.Length;                  value = 0;                  while (--i >= 0)                  {                      value *= 10;                      value += (number.Digits[cur++] - '0');                  }                  var adjust = number.Scale - number.Digits.Length;                  while (adjust > 9)                  {                      value *= 1000000000;                      adjust -= 9;                  }                  while (adjust > 0)                  {                      value *= 10;                      adjust--;                  }              }              else              {                  var i = number.Scale;                  value = 0;                  while (--i >= 0)                  {                      value *= 10;                      value += (number.Digits[cur++] - '0');                  }                  for (; cur < number.Digits.Length - 1; cur++)                  {                      if (number.Digits[cur++] != '0')                      {                          return false;                      }                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,NumberToBigInteger,The following statement contains a magic number: if (number.Scale > number.Digits.Length)              {                  var i = number.Digits.Length;                  value = 0;                  while (--i >= 0)                  {                      value *= 10;                      value += (number.Digits[cur++] - '0');                  }                  var adjust = number.Scale - number.Digits.Length;                  while (adjust > 9)                  {                      value *= 1000000000;                      adjust -= 9;                  }                  while (adjust > 0)                  {                      value *= 10;                      adjust--;                  }              }              else              {                  var i = number.Scale;                  value = 0;                  while (--i >= 0)                  {                      value *= 10;                      value += (number.Digits[cur++] - '0');                  }                  for (; cur < number.Digits.Length - 1; cur++)                  {                      if (number.Digits[cur++] != '0')                      {                          return false;                      }                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,NumberToBigInteger,The following statement contains a magic number: if (number.Scale > number.Digits.Length)              {                  var i = number.Digits.Length;                  value = 0;                  while (--i >= 0)                  {                      value *= 10;                      value += (number.Digits[cur++] - '0');                  }                  var adjust = number.Scale - number.Digits.Length;                  while (adjust > 9)                  {                      value *= 1000000000;                      adjust -= 9;                  }                  while (adjust > 0)                  {                      value *= 10;                      adjust--;                  }              }              else              {                  var i = number.Scale;                  value = 0;                  while (--i >= 0)                  {                      value *= 10;                      value += (number.Digits[cur++] - '0');                  }                  for (; cur < number.Digits.Length - 1; cur++)                  {                      if (number.Digits[cur++] != '0')                      {                          return false;                      }                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,NumberToBigInteger,The following statement contains a magic number: if (number.Scale > number.Digits.Length)              {                  var i = number.Digits.Length;                  value = 0;                  while (--i >= 0)                  {                      value *= 10;                      value += (number.Digits[cur++] - '0');                  }                  var adjust = number.Scale - number.Digits.Length;                  while (adjust > 9)                  {                      value *= 1000000000;                      adjust -= 9;                  }                  while (adjust > 0)                  {                      value *= 10;                      adjust--;                  }              }              else              {                  var i = number.Scale;                  value = 0;                  while (--i >= 0)                  {                      value *= 10;                      value += (number.Digits[cur++] - '0');                  }                  for (; cur < number.Digits.Length - 1; cur++)                  {                      if (number.Digits[cur++] != '0')                      {                          return false;                      }                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,NumberToBigInteger,The following statement contains a magic number: if (number.Scale > number.Digits.Length)              {                  var i = number.Digits.Length;                  value = 0;                  while (--i >= 0)                  {                      value *= 10;                      value += (number.Digits[cur++] - '0');                  }                  var adjust = number.Scale - number.Digits.Length;                  while (adjust > 9)                  {                      value *= 1000000000;                      adjust -= 9;                  }                  while (adjust > 0)                  {                      value *= 10;                      adjust--;                  }              }              else              {                  var i = number.Scale;                  value = 0;                  while (--i >= 0)                  {                      value *= 10;                      value += (number.Digits[cur++] - '0');                  }                  for (; cur < number.Digits.Length - 1; cur++)                  {                      if (number.Digits[cur++] != '0')                      {                          return false;                      }                  }              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(" ");                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                          }                      }                      break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                          }                      }                      break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                      break;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(" ");                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                          }                      }                      break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                          }                      }                      break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                      break;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(" ");                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                          }                      }                      break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                          }                      }                      break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                      break;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(" ");                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                          }                      }                      break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                          }                      }                      break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                      break;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(" ");                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                          }                      }                      break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                          }                      }                      break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                      break;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(" ");                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                          }                      }                      break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                          }                      }                      break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                      break;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(" ");                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                          }                      }                      break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                          }                      }                      break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                      break;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(" ");                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                          }                      }                      break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                          }                      }                      break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                      break;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(" ");                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                          }                      }                      break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                          }                      }                      break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                      break;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(" ");                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                          }                      }                      break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                          }                      }                      break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                      break;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(" ");                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                          }                      }                      break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                          }                      }                      break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                      break;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(" ");                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                          }                      }                      break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                          }                      }                      break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                      break;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(" ");                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                          }                      }                      break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                          }                      }                      break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                      break;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(" ");                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                          }                      }                      break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                          }                      }                      break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                      break;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(" ");                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                          }                      }                      break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                          }                      }                      break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                      break;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(" ");                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                          }                      }                      break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                          }                      }                      break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                      break;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(" ");                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                          }                      }                      break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                          }                      }                      break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                      break;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(" ");                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                          }                      }                      break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                          }                      }                      break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                      break;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(" ");                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                          }                      }                      break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                          }                      }                      break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                      break;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(" ");                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                          }                      }                      break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                          }                      }                      break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                      break;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(" ");                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                          }                      }                      break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                          }                      }                      break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                      break;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(" ");                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                          }                      }                      break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                          }                      }                      break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                      break;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(" ");                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                          }                      }                      break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                          }                      }                      break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                      break;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(" ");                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                          }                      }                      break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                          }                      }                      break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                      break;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(" ");                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                          }                      }                      break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                          }                      }                      break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                      break;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(" ");                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                          }                      }                      break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                          }                      }                      break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                      break;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(" ");                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                          }                      }                      break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                          }                      }                      break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                      break;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(" ");                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                          }                      }                      break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                          }                      }                      break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                      break;              }
Magic Number,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(" ");                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                          }                      }                      break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                          }                      }                      break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                      break;              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,BigIntegerBuilder,The following statement contains a magic number: var num1 = num >> 31;
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,Add,The following statement contains a magic number: if (_iuLast == 0)              {                  _uSmall = _uSmall + u;                  if (_uSmall >= u)                  {                      return;                  }                  SetSizeLazy(2);                  _bits[0] = _uSmall;                  _bits[1] = 1;                  return;              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,AddCarry,The following statement contains a magic number: return (uint)(num >> 32);
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,AddMulCarry,The following statement contains a magic number: return (uint)(num >> 32);
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,ApplyCarry,The following statement contains a magic number: while (true)              {                  if (iu <= _iuLast)                  {                      var num = _bits[iu] + 1;                      var num1 = num;                      _bits[iu] = num;                      if (num1 <= 0)                      {                          iu++;                      }                      else                      {                          break;                      }                  }                  else                  {                      if (_iuLast + 1 == _bits.Length)                      {                          Array.Resize(ref _bits' _iuLast + 2);                      }                      _iuLast = _iuLast + 1;                      _bits[_iuLast] = 1;                      break;                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,CbitLowZero,The following statement contains a magic number: return num1 + num * 32;
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,GetApproxParts,The following statement contains a magic number: exp = num * 32;
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,GetApproxParts,The following statement contains a magic number: if (num > 0)              {                  var num1 = NumericsHelpers.CbitHighZero(_bits[num + 1]);                  if (num1 > 0)                  {                      man = (man << num1) | (_bits[num - 1] >> (32 - num1));                      exp = exp - num1;                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,GetHigh2,The following statement contains a magic number: if (cu - 1 <= _iuLast)              {                  return NumericsHelpers.MakeUlong(_bits[cu - 1]' _bits[cu - 2]);              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,GetHigh2,The following statement contains a magic number: if (cu - 2 != _iuLast)              {                  return 0;              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,GetHigh2,The following statement contains a magic number: return _bits[cu - 2];
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,GetIntegerParts,The following statement contains a magic number: if (_iuLast == 0)              {                  if (_uSmall <= 2147483647)                  {                      sign = (int)(signSrc * _uSmall);                      bits = null;                      return;                  }                  if (_bits == null)                  {                      _bits = new[] { _uSmall };                  }                  else if (_fWritable)                  {                      _bits[0] = _uSmall;                  }                  else if (_bits[0] != _uSmall)                  {                      _bits = new[] { _uSmall };                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,LehmerGcd,The following statement contains a magic number: while (true)              {                  var num1 = reg1._iuLast + 1;                  var num2 = reg2._iuLast + 1;                  if (num1 < num2)                  {                      NumericHelper.Swap(ref reg1' ref reg2);                      NumericHelper.Swap(ref num1' ref num2);                  }                  if (num2 == 1)                  {                      if (num1 == 1)                      {                          reg1._uSmall = NumericHelper.GCD(reg1._uSmall' reg2._uSmall);                      }                      else if (reg2._uSmall != 0)                      {                          reg1.Set(NumericHelper.GCD(Mod(ref reg1' reg2._uSmall)' reg2._uSmall));                      }                      return;                  }                  if (num1 == 2)                  {                      break;                  }                  if (num2 > num1 - 2)                  {                      var high2 = reg1.GetHigh2(num1);                      var high21 = reg2.GetHigh2(num1);                      var num3 = NumericsHelpers.CbitHighZero(high2 | high21);                      if (num3 > 0)                      {                          high2 = high2 << (num3 & 63) | reg1._bits[num1 - 3] >> (32 - num3 & 31);                          high21 = high21 << (num3 & 63) | reg2._bits[num1 - 3] >> (32 - num3 & 31);                      }                      if (high2 < high21)                      {                          NumericHelper.Swap(ref high2' ref high21);                          NumericHelper.Swap(ref reg1' ref reg2);                      }                      if (high2 == ulong.MaxValue || high21 == ulong.MaxValue)                      {                          high2 = high2 >> 1;                          high21 = high21 >> 1;                      }                      if (high2 == high21)                      {                          reg1.Sub(ref num' ref reg2);                      }                      else if (NumericHelper.GetHi(high21) != 0)                      {                          uint num4 = 1;                          uint num5 = 0;                          uint num6 = 0;                          uint num7 = 1;                          while (true)                          {                              uint num8 = 1;                              var num9 = high2 - high21;                              while (num9 >= high21 && num8 < 32)                              {                                  num9 = num9 - high21;                                  num8++;                              }                              if (num9 >= high21)                              {                                  var num10 = high2 / high21;                                  if (num10 <= uint.MaxValue)                                  {                                      num8 = (uint)num10;                                      num9 = high2 - num8 * high21;                                  }                                  else                                  {                                      break;                                  }                              }                              var num11 = num4 + num8 * (ulong)num6;                              var num12 = num5 + num8 * (ulong)num7;                              if (num11 > 2147483647 || num12 > 2147483647)                              {                                  break;                              }                              else if (num9 < num12 || num9 + num11 > high21 - num6)                              {                                  break;                              }                              else                              {                                  num4 = (uint)num11;                                  num5 = (uint)num12;                                  high2 = num9;                                  if (high2 > num5)                                  {                                      num8 = 1;                                      num9 = high21 - high2;                                      while (num9 >= high2 && num8 < 32)                                      {                                          num9 = num9 - high2;                                          num8++;                                      }                                      if (num9 >= high2)                                      {                                          var num13 = high21 / high2;                                          if (num13 <= uint.MaxValue)                                          {                                              num8 = (uint)num13;                                              num9 = high21 - num8 * high2;                                          }                                          else                                          {                                              break;                                          }                                      }                                      num11 = num7 + num8 * (ulong)num5;                                      num12 = num6 + num8 * (ulong)num4;                                      if (num11 > 2147483647 || num12 > 2147483647)                                      {                                          break;                                      }                                      if (num9 < num12 || num9 + num11 > high2 - num5)                                      {                                          break;                                      }                                      num7 = (uint)num11;                                      num6 = (uint)num12;                                      high21 = num9;                                      if (high21 <= num6)                                      {                                          break;                                      }                                  }                                  else                                  {                                      break;                                  }                              }                          }                          if (num5 != 0)                          {                              reg1.SetSizeKeep(num2' 0);                              reg2.SetSizeKeep(num2' 0);                              var num14 = 0;                              var num15 = 0;                              for (var i = 0; i < num2; i++)                              {                                  var num16 = reg1._bits[i];                                  var num17 = reg2._bits[i];                                  var num18 = (long)num16 * num4 - (long)num17 * num5 + num14;                                  var num19 = (long)num17 * num7 - (long)num16 * num6 + num15;                                  num14 = (int)(num18 >> 32);                                  num15 = (int)(num19 >> 32);                                  reg1._bits[i] = (uint)num18;                                  reg2._bits[i] = (uint)num19;                              }                              reg1.Trim();                              reg2.Trim();                          }                          else if (high2 / 2 < high21)                          {                              reg1.Sub(ref num' ref reg2);                          }                          else                          {                              reg1.Mod(ref reg2);                          }                      }                      else                      {                          reg1.Mod(ref reg2);                      }                  }                  else                  {                      reg1.Mod(ref reg2);                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,LehmerGcd,The following statement contains a magic number: while (true)              {                  var num1 = reg1._iuLast + 1;                  var num2 = reg2._iuLast + 1;                  if (num1 < num2)                  {                      NumericHelper.Swap(ref reg1' ref reg2);                      NumericHelper.Swap(ref num1' ref num2);                  }                  if (num2 == 1)                  {                      if (num1 == 1)                      {                          reg1._uSmall = NumericHelper.GCD(reg1._uSmall' reg2._uSmall);                      }                      else if (reg2._uSmall != 0)                      {                          reg1.Set(NumericHelper.GCD(Mod(ref reg1' reg2._uSmall)' reg2._uSmall));                      }                      return;                  }                  if (num1 == 2)                  {                      break;                  }                  if (num2 > num1 - 2)                  {                      var high2 = reg1.GetHigh2(num1);                      var high21 = reg2.GetHigh2(num1);                      var num3 = NumericsHelpers.CbitHighZero(high2 | high21);                      if (num3 > 0)                      {                          high2 = high2 << (num3 & 63) | reg1._bits[num1 - 3] >> (32 - num3 & 31);                          high21 = high21 << (num3 & 63) | reg2._bits[num1 - 3] >> (32 - num3 & 31);                      }                      if (high2 < high21)                      {                          NumericHelper.Swap(ref high2' ref high21);                          NumericHelper.Swap(ref reg1' ref reg2);                      }                      if (high2 == ulong.MaxValue || high21 == ulong.MaxValue)                      {                          high2 = high2 >> 1;                          high21 = high21 >> 1;                      }                      if (high2 == high21)                      {                          reg1.Sub(ref num' ref reg2);                      }                      else if (NumericHelper.GetHi(high21) != 0)                      {                          uint num4 = 1;                          uint num5 = 0;                          uint num6 = 0;                          uint num7 = 1;                          while (true)                          {                              uint num8 = 1;                              var num9 = high2 - high21;                              while (num9 >= high21 && num8 < 32)                              {                                  num9 = num9 - high21;                                  num8++;                              }                              if (num9 >= high21)                              {                                  var num10 = high2 / high21;                                  if (num10 <= uint.MaxValue)                                  {                                      num8 = (uint)num10;                                      num9 = high2 - num8 * high21;                                  }                                  else                                  {                                      break;                                  }                              }                              var num11 = num4 + num8 * (ulong)num6;                              var num12 = num5 + num8 * (ulong)num7;                              if (num11 > 2147483647 || num12 > 2147483647)                              {                                  break;                              }                              else if (num9 < num12 || num9 + num11 > high21 - num6)                              {                                  break;                              }                              else                              {                                  num4 = (uint)num11;                                  num5 = (uint)num12;                                  high2 = num9;                                  if (high2 > num5)                                  {                                      num8 = 1;                                      num9 = high21 - high2;                                      while (num9 >= high2 && num8 < 32)                                      {                                          num9 = num9 - high2;                                          num8++;                                      }                                      if (num9 >= high2)                                      {                                          var num13 = high21 / high2;                                          if (num13 <= uint.MaxValue)                                          {                                              num8 = (uint)num13;                                              num9 = high21 - num8 * high2;                                          }                                          else                                          {                                              break;                                          }                                      }                                      num11 = num7 + num8 * (ulong)num5;                                      num12 = num6 + num8 * (ulong)num4;                                      if (num11 > 2147483647 || num12 > 2147483647)                                      {                                          break;                                      }                                      if (num9 < num12 || num9 + num11 > high2 - num5)                                      {                                          break;                                      }                                      num7 = (uint)num11;                                      num6 = (uint)num12;                                      high21 = num9;                                      if (high21 <= num6)                                      {                                          break;                                      }                                  }                                  else                                  {                                      break;                                  }                              }                          }                          if (num5 != 0)                          {                              reg1.SetSizeKeep(num2' 0);                              reg2.SetSizeKeep(num2' 0);                              var num14 = 0;                              var num15 = 0;                              for (var i = 0; i < num2; i++)                              {                                  var num16 = reg1._bits[i];                                  var num17 = reg2._bits[i];                                  var num18 = (long)num16 * num4 - (long)num17 * num5 + num14;                                  var num19 = (long)num17 * num7 - (long)num16 * num6 + num15;                                  num14 = (int)(num18 >> 32);                                  num15 = (int)(num19 >> 32);                                  reg1._bits[i] = (uint)num18;                                  reg2._bits[i] = (uint)num19;                              }                              reg1.Trim();                              reg2.Trim();                          }                          else if (high2 / 2 < high21)                          {                              reg1.Sub(ref num' ref reg2);                          }                          else                          {                              reg1.Mod(ref reg2);                          }                      }                      else                      {                          reg1.Mod(ref reg2);                      }                  }                  else                  {                      reg1.Mod(ref reg2);                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,LehmerGcd,The following statement contains a magic number: while (true)              {                  var num1 = reg1._iuLast + 1;                  var num2 = reg2._iuLast + 1;                  if (num1 < num2)                  {                      NumericHelper.Swap(ref reg1' ref reg2);                      NumericHelper.Swap(ref num1' ref num2);                  }                  if (num2 == 1)                  {                      if (num1 == 1)                      {                          reg1._uSmall = NumericHelper.GCD(reg1._uSmall' reg2._uSmall);                      }                      else if (reg2._uSmall != 0)                      {                          reg1.Set(NumericHelper.GCD(Mod(ref reg1' reg2._uSmall)' reg2._uSmall));                      }                      return;                  }                  if (num1 == 2)                  {                      break;                  }                  if (num2 > num1 - 2)                  {                      var high2 = reg1.GetHigh2(num1);                      var high21 = reg2.GetHigh2(num1);                      var num3 = NumericsHelpers.CbitHighZero(high2 | high21);                      if (num3 > 0)                      {                          high2 = high2 << (num3 & 63) | reg1._bits[num1 - 3] >> (32 - num3 & 31);                          high21 = high21 << (num3 & 63) | reg2._bits[num1 - 3] >> (32 - num3 & 31);                      }                      if (high2 < high21)                      {                          NumericHelper.Swap(ref high2' ref high21);                          NumericHelper.Swap(ref reg1' ref reg2);                      }                      if (high2 == ulong.MaxValue || high21 == ulong.MaxValue)                      {                          high2 = high2 >> 1;                          high21 = high21 >> 1;                      }                      if (high2 == high21)                      {                          reg1.Sub(ref num' ref reg2);                      }                      else if (NumericHelper.GetHi(high21) != 0)                      {                          uint num4 = 1;                          uint num5 = 0;                          uint num6 = 0;                          uint num7 = 1;                          while (true)                          {                              uint num8 = 1;                              var num9 = high2 - high21;                              while (num9 >= high21 && num8 < 32)                              {                                  num9 = num9 - high21;                                  num8++;                              }                              if (num9 >= high21)                              {                                  var num10 = high2 / high21;                                  if (num10 <= uint.MaxValue)                                  {                                      num8 = (uint)num10;                                      num9 = high2 - num8 * high21;                                  }                                  else                                  {                                      break;                                  }                              }                              var num11 = num4 + num8 * (ulong)num6;                              var num12 = num5 + num8 * (ulong)num7;                              if (num11 > 2147483647 || num12 > 2147483647)                              {                                  break;                              }                              else if (num9 < num12 || num9 + num11 > high21 - num6)                              {                                  break;                              }                              else                              {                                  num4 = (uint)num11;                                  num5 = (uint)num12;                                  high2 = num9;                                  if (high2 > num5)                                  {                                      num8 = 1;                                      num9 = high21 - high2;                                      while (num9 >= high2 && num8 < 32)                                      {                                          num9 = num9 - high2;                                          num8++;                                      }                                      if (num9 >= high2)                                      {                                          var num13 = high21 / high2;                                          if (num13 <= uint.MaxValue)                                          {                                              num8 = (uint)num13;                                              num9 = high21 - num8 * high2;                                          }                                          else                                          {                                              break;                                          }                                      }                                      num11 = num7 + num8 * (ulong)num5;                                      num12 = num6 + num8 * (ulong)num4;                                      if (num11 > 2147483647 || num12 > 2147483647)                                      {                                          break;                                      }                                      if (num9 < num12 || num9 + num11 > high2 - num5)                                      {                                          break;                                      }                                      num7 = (uint)num11;                                      num6 = (uint)num12;                                      high21 = num9;                                      if (high21 <= num6)                                      {                                          break;                                      }                                  }                                  else                                  {                                      break;                                  }                              }                          }                          if (num5 != 0)                          {                              reg1.SetSizeKeep(num2' 0);                              reg2.SetSizeKeep(num2' 0);                              var num14 = 0;                              var num15 = 0;                              for (var i = 0; i < num2; i++)                              {                                  var num16 = reg1._bits[i];                                  var num17 = reg2._bits[i];                                  var num18 = (long)num16 * num4 - (long)num17 * num5 + num14;                                  var num19 = (long)num17 * num7 - (long)num16 * num6 + num15;                                  num14 = (int)(num18 >> 32);                                  num15 = (int)(num19 >> 32);                                  reg1._bits[i] = (uint)num18;                                  reg2._bits[i] = (uint)num19;                              }                              reg1.Trim();                              reg2.Trim();                          }                          else if (high2 / 2 < high21)                          {                              reg1.Sub(ref num' ref reg2);                          }                          else                          {                              reg1.Mod(ref reg2);                          }                      }                      else                      {                          reg1.Mod(ref reg2);                      }                  }                  else                  {                      reg1.Mod(ref reg2);                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,LehmerGcd,The following statement contains a magic number: while (true)              {                  var num1 = reg1._iuLast + 1;                  var num2 = reg2._iuLast + 1;                  if (num1 < num2)                  {                      NumericHelper.Swap(ref reg1' ref reg2);                      NumericHelper.Swap(ref num1' ref num2);                  }                  if (num2 == 1)                  {                      if (num1 == 1)                      {                          reg1._uSmall = NumericHelper.GCD(reg1._uSmall' reg2._uSmall);                      }                      else if (reg2._uSmall != 0)                      {                          reg1.Set(NumericHelper.GCD(Mod(ref reg1' reg2._uSmall)' reg2._uSmall));                      }                      return;                  }                  if (num1 == 2)                  {                      break;                  }                  if (num2 > num1 - 2)                  {                      var high2 = reg1.GetHigh2(num1);                      var high21 = reg2.GetHigh2(num1);                      var num3 = NumericsHelpers.CbitHighZero(high2 | high21);                      if (num3 > 0)                      {                          high2 = high2 << (num3 & 63) | reg1._bits[num1 - 3] >> (32 - num3 & 31);                          high21 = high21 << (num3 & 63) | reg2._bits[num1 - 3] >> (32 - num3 & 31);                      }                      if (high2 < high21)                      {                          NumericHelper.Swap(ref high2' ref high21);                          NumericHelper.Swap(ref reg1' ref reg2);                      }                      if (high2 == ulong.MaxValue || high21 == ulong.MaxValue)                      {                          high2 = high2 >> 1;                          high21 = high21 >> 1;                      }                      if (high2 == high21)                      {                          reg1.Sub(ref num' ref reg2);                      }                      else if (NumericHelper.GetHi(high21) != 0)                      {                          uint num4 = 1;                          uint num5 = 0;                          uint num6 = 0;                          uint num7 = 1;                          while (true)                          {                              uint num8 = 1;                              var num9 = high2 - high21;                              while (num9 >= high21 && num8 < 32)                              {                                  num9 = num9 - high21;                                  num8++;                              }                              if (num9 >= high21)                              {                                  var num10 = high2 / high21;                                  if (num10 <= uint.MaxValue)                                  {                                      num8 = (uint)num10;                                      num9 = high2 - num8 * high21;                                  }                                  else                                  {                                      break;                                  }                              }                              var num11 = num4 + num8 * (ulong)num6;                              var num12 = num5 + num8 * (ulong)num7;                              if (num11 > 2147483647 || num12 > 2147483647)                              {                                  break;                              }                              else if (num9 < num12 || num9 + num11 > high21 - num6)                              {                                  break;                              }                              else                              {                                  num4 = (uint)num11;                                  num5 = (uint)num12;                                  high2 = num9;                                  if (high2 > num5)                                  {                                      num8 = 1;                                      num9 = high21 - high2;                                      while (num9 >= high2 && num8 < 32)                                      {                                          num9 = num9 - high2;                                          num8++;                                      }                                      if (num9 >= high2)                                      {                                          var num13 = high21 / high2;                                          if (num13 <= uint.MaxValue)                                          {                                              num8 = (uint)num13;                                              num9 = high21 - num8 * high2;                                          }                                          else                                          {                                              break;                                          }                                      }                                      num11 = num7 + num8 * (ulong)num5;                                      num12 = num6 + num8 * (ulong)num4;                                      if (num11 > 2147483647 || num12 > 2147483647)                                      {                                          break;                                      }                                      if (num9 < num12 || num9 + num11 > high2 - num5)                                      {                                          break;                                      }                                      num7 = (uint)num11;                                      num6 = (uint)num12;                                      high21 = num9;                                      if (high21 <= num6)                                      {                                          break;                                      }                                  }                                  else                                  {                                      break;                                  }                              }                          }                          if (num5 != 0)                          {                              reg1.SetSizeKeep(num2' 0);                              reg2.SetSizeKeep(num2' 0);                              var num14 = 0;                              var num15 = 0;                              for (var i = 0; i < num2; i++)                              {                                  var num16 = reg1._bits[i];                                  var num17 = reg2._bits[i];                                  var num18 = (long)num16 * num4 - (long)num17 * num5 + num14;                                  var num19 = (long)num17 * num7 - (long)num16 * num6 + num15;                                  num14 = (int)(num18 >> 32);                                  num15 = (int)(num19 >> 32);                                  reg1._bits[i] = (uint)num18;                                  reg2._bits[i] = (uint)num19;                              }                              reg1.Trim();                              reg2.Trim();                          }                          else if (high2 / 2 < high21)                          {                              reg1.Sub(ref num' ref reg2);                          }                          else                          {                              reg1.Mod(ref reg2);                          }                      }                      else                      {                          reg1.Mod(ref reg2);                      }                  }                  else                  {                      reg1.Mod(ref reg2);                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,LehmerGcd,The following statement contains a magic number: while (true)              {                  var num1 = reg1._iuLast + 1;                  var num2 = reg2._iuLast + 1;                  if (num1 < num2)                  {                      NumericHelper.Swap(ref reg1' ref reg2);                      NumericHelper.Swap(ref num1' ref num2);                  }                  if (num2 == 1)                  {                      if (num1 == 1)                      {                          reg1._uSmall = NumericHelper.GCD(reg1._uSmall' reg2._uSmall);                      }                      else if (reg2._uSmall != 0)                      {                          reg1.Set(NumericHelper.GCD(Mod(ref reg1' reg2._uSmall)' reg2._uSmall));                      }                      return;                  }                  if (num1 == 2)                  {                      break;                  }                  if (num2 > num1 - 2)                  {                      var high2 = reg1.GetHigh2(num1);                      var high21 = reg2.GetHigh2(num1);                      var num3 = NumericsHelpers.CbitHighZero(high2 | high21);                      if (num3 > 0)                      {                          high2 = high2 << (num3 & 63) | reg1._bits[num1 - 3] >> (32 - num3 & 31);                          high21 = high21 << (num3 & 63) | reg2._bits[num1 - 3] >> (32 - num3 & 31);                      }                      if (high2 < high21)                      {                          NumericHelper.Swap(ref high2' ref high21);                          NumericHelper.Swap(ref reg1' ref reg2);                      }                      if (high2 == ulong.MaxValue || high21 == ulong.MaxValue)                      {                          high2 = high2 >> 1;                          high21 = high21 >> 1;                      }                      if (high2 == high21)                      {                          reg1.Sub(ref num' ref reg2);                      }                      else if (NumericHelper.GetHi(high21) != 0)                      {                          uint num4 = 1;                          uint num5 = 0;                          uint num6 = 0;                          uint num7 = 1;                          while (true)                          {                              uint num8 = 1;                              var num9 = high2 - high21;                              while (num9 >= high21 && num8 < 32)                              {                                  num9 = num9 - high21;                                  num8++;                              }                              if (num9 >= high21)                              {                                  var num10 = high2 / high21;                                  if (num10 <= uint.MaxValue)                                  {                                      num8 = (uint)num10;                                      num9 = high2 - num8 * high21;                                  }                                  else                                  {                                      break;                                  }                              }                              var num11 = num4 + num8 * (ulong)num6;                              var num12 = num5 + num8 * (ulong)num7;                              if (num11 > 2147483647 || num12 > 2147483647)                              {                                  break;                              }                              else if (num9 < num12 || num9 + num11 > high21 - num6)                              {                                  break;                              }                              else                              {                                  num4 = (uint)num11;                                  num5 = (uint)num12;                                  high2 = num9;                                  if (high2 > num5)                                  {                                      num8 = 1;                                      num9 = high21 - high2;                                      while (num9 >= high2 && num8 < 32)                                      {                                          num9 = num9 - high2;                                          num8++;                                      }                                      if (num9 >= high2)                                      {                                          var num13 = high21 / high2;                                          if (num13 <= uint.MaxValue)                                          {                                              num8 = (uint)num13;                                              num9 = high21 - num8 * high2;                                          }                                          else                                          {                                              break;                                          }                                      }                                      num11 = num7 + num8 * (ulong)num5;                                      num12 = num6 + num8 * (ulong)num4;                                      if (num11 > 2147483647 || num12 > 2147483647)                                      {                                          break;                                      }                                      if (num9 < num12 || num9 + num11 > high2 - num5)                                      {                                          break;                                      }                                      num7 = (uint)num11;                                      num6 = (uint)num12;                                      high21 = num9;                                      if (high21 <= num6)                                      {                                          break;                                      }                                  }                                  else                                  {                                      break;                                  }                              }                          }                          if (num5 != 0)                          {                              reg1.SetSizeKeep(num2' 0);                              reg2.SetSizeKeep(num2' 0);                              var num14 = 0;                              var num15 = 0;                              for (var i = 0; i < num2; i++)                              {                                  var num16 = reg1._bits[i];                                  var num17 = reg2._bits[i];                                  var num18 = (long)num16 * num4 - (long)num17 * num5 + num14;                                  var num19 = (long)num17 * num7 - (long)num16 * num6 + num15;                                  num14 = (int)(num18 >> 32);                                  num15 = (int)(num19 >> 32);                                  reg1._bits[i] = (uint)num18;                                  reg2._bits[i] = (uint)num19;                              }                              reg1.Trim();                              reg2.Trim();                          }                          else if (high2 / 2 < high21)                          {                              reg1.Sub(ref num' ref reg2);                          }                          else                          {                              reg1.Mod(ref reg2);                          }                      }                      else                      {                          reg1.Mod(ref reg2);                      }                  }                  else                  {                      reg1.Mod(ref reg2);                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,LehmerGcd,The following statement contains a magic number: while (true)              {                  var num1 = reg1._iuLast + 1;                  var num2 = reg2._iuLast + 1;                  if (num1 < num2)                  {                      NumericHelper.Swap(ref reg1' ref reg2);                      NumericHelper.Swap(ref num1' ref num2);                  }                  if (num2 == 1)                  {                      if (num1 == 1)                      {                          reg1._uSmall = NumericHelper.GCD(reg1._uSmall' reg2._uSmall);                      }                      else if (reg2._uSmall != 0)                      {                          reg1.Set(NumericHelper.GCD(Mod(ref reg1' reg2._uSmall)' reg2._uSmall));                      }                      return;                  }                  if (num1 == 2)                  {                      break;                  }                  if (num2 > num1 - 2)                  {                      var high2 = reg1.GetHigh2(num1);                      var high21 = reg2.GetHigh2(num1);                      var num3 = NumericsHelpers.CbitHighZero(high2 | high21);                      if (num3 > 0)                      {                          high2 = high2 << (num3 & 63) | reg1._bits[num1 - 3] >> (32 - num3 & 31);                          high21 = high21 << (num3 & 63) | reg2._bits[num1 - 3] >> (32 - num3 & 31);                      }                      if (high2 < high21)                      {                          NumericHelper.Swap(ref high2' ref high21);                          NumericHelper.Swap(ref reg1' ref reg2);                      }                      if (high2 == ulong.MaxValue || high21 == ulong.MaxValue)                      {                          high2 = high2 >> 1;                          high21 = high21 >> 1;                      }                      if (high2 == high21)                      {                          reg1.Sub(ref num' ref reg2);                      }                      else if (NumericHelper.GetHi(high21) != 0)                      {                          uint num4 = 1;                          uint num5 = 0;                          uint num6 = 0;                          uint num7 = 1;                          while (true)                          {                              uint num8 = 1;                              var num9 = high2 - high21;                              while (num9 >= high21 && num8 < 32)                              {                                  num9 = num9 - high21;                                  num8++;                              }                              if (num9 >= high21)                              {                                  var num10 = high2 / high21;                                  if (num10 <= uint.MaxValue)                                  {                                      num8 = (uint)num10;                                      num9 = high2 - num8 * high21;                                  }                                  else                                  {                                      break;                                  }                              }                              var num11 = num4 + num8 * (ulong)num6;                              var num12 = num5 + num8 * (ulong)num7;                              if (num11 > 2147483647 || num12 > 2147483647)                              {                                  break;                              }                              else if (num9 < num12 || num9 + num11 > high21 - num6)                              {                                  break;                              }                              else                              {                                  num4 = (uint)num11;                                  num5 = (uint)num12;                                  high2 = num9;                                  if (high2 > num5)                                  {                                      num8 = 1;                                      num9 = high21 - high2;                                      while (num9 >= high2 && num8 < 32)                                      {                                          num9 = num9 - high2;                                          num8++;                                      }                                      if (num9 >= high2)                                      {                                          var num13 = high21 / high2;                                          if (num13 <= uint.MaxValue)                                          {                                              num8 = (uint)num13;                                              num9 = high21 - num8 * high2;                                          }                                          else                                          {                                              break;                                          }                                      }                                      num11 = num7 + num8 * (ulong)num5;                                      num12 = num6 + num8 * (ulong)num4;                                      if (num11 > 2147483647 || num12 > 2147483647)                                      {                                          break;                                      }                                      if (num9 < num12 || num9 + num11 > high2 - num5)                                      {                                          break;                                      }                                      num7 = (uint)num11;                                      num6 = (uint)num12;                                      high21 = num9;                                      if (high21 <= num6)                                      {                                          break;                                      }                                  }                                  else                                  {                                      break;                                  }                              }                          }                          if (num5 != 0)                          {                              reg1.SetSizeKeep(num2' 0);                              reg2.SetSizeKeep(num2' 0);                              var num14 = 0;                              var num15 = 0;                              for (var i = 0; i < num2; i++)                              {                                  var num16 = reg1._bits[i];                                  var num17 = reg2._bits[i];                                  var num18 = (long)num16 * num4 - (long)num17 * num5 + num14;                                  var num19 = (long)num17 * num7 - (long)num16 * num6 + num15;                                  num14 = (int)(num18 >> 32);                                  num15 = (int)(num19 >> 32);                                  reg1._bits[i] = (uint)num18;                                  reg2._bits[i] = (uint)num19;                              }                              reg1.Trim();                              reg2.Trim();                          }                          else if (high2 / 2 < high21)                          {                              reg1.Sub(ref num' ref reg2);                          }                          else                          {                              reg1.Mod(ref reg2);                          }                      }                      else                      {                          reg1.Mod(ref reg2);                      }                  }                  else                  {                      reg1.Mod(ref reg2);                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,LehmerGcd,The following statement contains a magic number: while (true)              {                  var num1 = reg1._iuLast + 1;                  var num2 = reg2._iuLast + 1;                  if (num1 < num2)                  {                      NumericHelper.Swap(ref reg1' ref reg2);                      NumericHelper.Swap(ref num1' ref num2);                  }                  if (num2 == 1)                  {                      if (num1 == 1)                      {                          reg1._uSmall = NumericHelper.GCD(reg1._uSmall' reg2._uSmall);                      }                      else if (reg2._uSmall != 0)                      {                          reg1.Set(NumericHelper.GCD(Mod(ref reg1' reg2._uSmall)' reg2._uSmall));                      }                      return;                  }                  if (num1 == 2)                  {                      break;                  }                  if (num2 > num1 - 2)                  {                      var high2 = reg1.GetHigh2(num1);                      var high21 = reg2.GetHigh2(num1);                      var num3 = NumericsHelpers.CbitHighZero(high2 | high21);                      if (num3 > 0)                      {                          high2 = high2 << (num3 & 63) | reg1._bits[num1 - 3] >> (32 - num3 & 31);                          high21 = high21 << (num3 & 63) | reg2._bits[num1 - 3] >> (32 - num3 & 31);                      }                      if (high2 < high21)                      {                          NumericHelper.Swap(ref high2' ref high21);                          NumericHelper.Swap(ref reg1' ref reg2);                      }                      if (high2 == ulong.MaxValue || high21 == ulong.MaxValue)                      {                          high2 = high2 >> 1;                          high21 = high21 >> 1;                      }                      if (high2 == high21)                      {                          reg1.Sub(ref num' ref reg2);                      }                      else if (NumericHelper.GetHi(high21) != 0)                      {                          uint num4 = 1;                          uint num5 = 0;                          uint num6 = 0;                          uint num7 = 1;                          while (true)                          {                              uint num8 = 1;                              var num9 = high2 - high21;                              while (num9 >= high21 && num8 < 32)                              {                                  num9 = num9 - high21;                                  num8++;                              }                              if (num9 >= high21)                              {                                  var num10 = high2 / high21;                                  if (num10 <= uint.MaxValue)                                  {                                      num8 = (uint)num10;                                      num9 = high2 - num8 * high21;                                  }                                  else                                  {                                      break;                                  }                              }                              var num11 = num4 + num8 * (ulong)num6;                              var num12 = num5 + num8 * (ulong)num7;                              if (num11 > 2147483647 || num12 > 2147483647)                              {                                  break;                              }                              else if (num9 < num12 || num9 + num11 > high21 - num6)                              {                                  break;                              }                              else                              {                                  num4 = (uint)num11;                                  num5 = (uint)num12;                                  high2 = num9;                                  if (high2 > num5)                                  {                                      num8 = 1;                                      num9 = high21 - high2;                                      while (num9 >= high2 && num8 < 32)                                      {                                          num9 = num9 - high2;                                          num8++;                                      }                                      if (num9 >= high2)                                      {                                          var num13 = high21 / high2;                                          if (num13 <= uint.MaxValue)                                          {                                              num8 = (uint)num13;                                              num9 = high21 - num8 * high2;                                          }                                          else                                          {                                              break;                                          }                                      }                                      num11 = num7 + num8 * (ulong)num5;                                      num12 = num6 + num8 * (ulong)num4;                                      if (num11 > 2147483647 || num12 > 2147483647)                                      {                                          break;                                      }                                      if (num9 < num12 || num9 + num11 > high2 - num5)                                      {                                          break;                                      }                                      num7 = (uint)num11;                                      num6 = (uint)num12;                                      high21 = num9;                                      if (high21 <= num6)                                      {                                          break;                                      }                                  }                                  else                                  {                                      break;                                  }                              }                          }                          if (num5 != 0)                          {                              reg1.SetSizeKeep(num2' 0);                              reg2.SetSizeKeep(num2' 0);                              var num14 = 0;                              var num15 = 0;                              for (var i = 0; i < num2; i++)                              {                                  var num16 = reg1._bits[i];                                  var num17 = reg2._bits[i];                                  var num18 = (long)num16 * num4 - (long)num17 * num5 + num14;                                  var num19 = (long)num17 * num7 - (long)num16 * num6 + num15;                                  num14 = (int)(num18 >> 32);                                  num15 = (int)(num19 >> 32);                                  reg1._bits[i] = (uint)num18;                                  reg2._bits[i] = (uint)num19;                              }                              reg1.Trim();                              reg2.Trim();                          }                          else if (high2 / 2 < high21)                          {                              reg1.Sub(ref num' ref reg2);                          }                          else                          {                              reg1.Mod(ref reg2);                          }                      }                      else                      {                          reg1.Mod(ref reg2);                      }                  }                  else                  {                      reg1.Mod(ref reg2);                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,LehmerGcd,The following statement contains a magic number: while (true)              {                  var num1 = reg1._iuLast + 1;                  var num2 = reg2._iuLast + 1;                  if (num1 < num2)                  {                      NumericHelper.Swap(ref reg1' ref reg2);                      NumericHelper.Swap(ref num1' ref num2);                  }                  if (num2 == 1)                  {                      if (num1 == 1)                      {                          reg1._uSmall = NumericHelper.GCD(reg1._uSmall' reg2._uSmall);                      }                      else if (reg2._uSmall != 0)                      {                          reg1.Set(NumericHelper.GCD(Mod(ref reg1' reg2._uSmall)' reg2._uSmall));                      }                      return;                  }                  if (num1 == 2)                  {                      break;                  }                  if (num2 > num1 - 2)                  {                      var high2 = reg1.GetHigh2(num1);                      var high21 = reg2.GetHigh2(num1);                      var num3 = NumericsHelpers.CbitHighZero(high2 | high21);                      if (num3 > 0)                      {                          high2 = high2 << (num3 & 63) | reg1._bits[num1 - 3] >> (32 - num3 & 31);                          high21 = high21 << (num3 & 63) | reg2._bits[num1 - 3] >> (32 - num3 & 31);                      }                      if (high2 < high21)                      {                          NumericHelper.Swap(ref high2' ref high21);                          NumericHelper.Swap(ref reg1' ref reg2);                      }                      if (high2 == ulong.MaxValue || high21 == ulong.MaxValue)                      {                          high2 = high2 >> 1;                          high21 = high21 >> 1;                      }                      if (high2 == high21)                      {                          reg1.Sub(ref num' ref reg2);                      }                      else if (NumericHelper.GetHi(high21) != 0)                      {                          uint num4 = 1;                          uint num5 = 0;                          uint num6 = 0;                          uint num7 = 1;                          while (true)                          {                              uint num8 = 1;                              var num9 = high2 - high21;                              while (num9 >= high21 && num8 < 32)                              {                                  num9 = num9 - high21;                                  num8++;                              }                              if (num9 >= high21)                              {                                  var num10 = high2 / high21;                                  if (num10 <= uint.MaxValue)                                  {                                      num8 = (uint)num10;                                      num9 = high2 - num8 * high21;                                  }                                  else                                  {                                      break;                                  }                              }                              var num11 = num4 + num8 * (ulong)num6;                              var num12 = num5 + num8 * (ulong)num7;                              if (num11 > 2147483647 || num12 > 2147483647)                              {                                  break;                              }                              else if (num9 < num12 || num9 + num11 > high21 - num6)                              {                                  break;                              }                              else                              {                                  num4 = (uint)num11;                                  num5 = (uint)num12;                                  high2 = num9;                                  if (high2 > num5)                                  {                                      num8 = 1;                                      num9 = high21 - high2;                                      while (num9 >= high2 && num8 < 32)                                      {                                          num9 = num9 - high2;                                          num8++;                                      }                                      if (num9 >= high2)                                      {                                          var num13 = high21 / high2;                                          if (num13 <= uint.MaxValue)                                          {                                              num8 = (uint)num13;                                              num9 = high21 - num8 * high2;                                          }                                          else                                          {                                              break;                                          }                                      }                                      num11 = num7 + num8 * (ulong)num5;                                      num12 = num6 + num8 * (ulong)num4;                                      if (num11 > 2147483647 || num12 > 2147483647)                                      {                                          break;                                      }                                      if (num9 < num12 || num9 + num11 > high2 - num5)                                      {                                          break;                                      }                                      num7 = (uint)num11;                                      num6 = (uint)num12;                                      high21 = num9;                                      if (high21 <= num6)                                      {                                          break;                                      }                                  }                                  else                                  {                                      break;                                  }                              }                          }                          if (num5 != 0)                          {                              reg1.SetSizeKeep(num2' 0);                              reg2.SetSizeKeep(num2' 0);                              var num14 = 0;                              var num15 = 0;                              for (var i = 0; i < num2; i++)                              {                                  var num16 = reg1._bits[i];                                  var num17 = reg2._bits[i];                                  var num18 = (long)num16 * num4 - (long)num17 * num5 + num14;                                  var num19 = (long)num17 * num7 - (long)num16 * num6 + num15;                                  num14 = (int)(num18 >> 32);                                  num15 = (int)(num19 >> 32);                                  reg1._bits[i] = (uint)num18;                                  reg2._bits[i] = (uint)num19;                              }                              reg1.Trim();                              reg2.Trim();                          }                          else if (high2 / 2 < high21)                          {                              reg1.Sub(ref num' ref reg2);                          }                          else                          {                              reg1.Mod(ref reg2);                          }                      }                      else                      {                          reg1.Mod(ref reg2);                      }                  }                  else                  {                      reg1.Mod(ref reg2);                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,LehmerGcd,The following statement contains a magic number: while (true)              {                  var num1 = reg1._iuLast + 1;                  var num2 = reg2._iuLast + 1;                  if (num1 < num2)                  {                      NumericHelper.Swap(ref reg1' ref reg2);                      NumericHelper.Swap(ref num1' ref num2);                  }                  if (num2 == 1)                  {                      if (num1 == 1)                      {                          reg1._uSmall = NumericHelper.GCD(reg1._uSmall' reg2._uSmall);                      }                      else if (reg2._uSmall != 0)                      {                          reg1.Set(NumericHelper.GCD(Mod(ref reg1' reg2._uSmall)' reg2._uSmall));                      }                      return;                  }                  if (num1 == 2)                  {                      break;                  }                  if (num2 > num1 - 2)                  {                      var high2 = reg1.GetHigh2(num1);                      var high21 = reg2.GetHigh2(num1);                      var num3 = NumericsHelpers.CbitHighZero(high2 | high21);                      if (num3 > 0)                      {                          high2 = high2 << (num3 & 63) | reg1._bits[num1 - 3] >> (32 - num3 & 31);                          high21 = high21 << (num3 & 63) | reg2._bits[num1 - 3] >> (32 - num3 & 31);                      }                      if (high2 < high21)                      {                          NumericHelper.Swap(ref high2' ref high21);                          NumericHelper.Swap(ref reg1' ref reg2);                      }                      if (high2 == ulong.MaxValue || high21 == ulong.MaxValue)                      {                          high2 = high2 >> 1;                          high21 = high21 >> 1;                      }                      if (high2 == high21)                      {                          reg1.Sub(ref num' ref reg2);                      }                      else if (NumericHelper.GetHi(high21) != 0)                      {                          uint num4 = 1;                          uint num5 = 0;                          uint num6 = 0;                          uint num7 = 1;                          while (true)                          {                              uint num8 = 1;                              var num9 = high2 - high21;                              while (num9 >= high21 && num8 < 32)                              {                                  num9 = num9 - high21;                                  num8++;                              }                              if (num9 >= high21)                              {                                  var num10 = high2 / high21;                                  if (num10 <= uint.MaxValue)                                  {                                      num8 = (uint)num10;                                      num9 = high2 - num8 * high21;                                  }                                  else                                  {                                      break;                                  }                              }                              var num11 = num4 + num8 * (ulong)num6;                              var num12 = num5 + num8 * (ulong)num7;                              if (num11 > 2147483647 || num12 > 2147483647)                              {                                  break;                              }                              else if (num9 < num12 || num9 + num11 > high21 - num6)                              {                                  break;                              }                              else                              {                                  num4 = (uint)num11;                                  num5 = (uint)num12;                                  high2 = num9;                                  if (high2 > num5)                                  {                                      num8 = 1;                                      num9 = high21 - high2;                                      while (num9 >= high2 && num8 < 32)                                      {                                          num9 = num9 - high2;                                          num8++;                                      }                                      if (num9 >= high2)                                      {                                          var num13 = high21 / high2;                                          if (num13 <= uint.MaxValue)                                          {                                              num8 = (uint)num13;                                              num9 = high21 - num8 * high2;                                          }                                          else                                          {                                              break;                                          }                                      }                                      num11 = num7 + num8 * (ulong)num5;                                      num12 = num6 + num8 * (ulong)num4;                                      if (num11 > 2147483647 || num12 > 2147483647)                                      {                                          break;                                      }                                      if (num9 < num12 || num9 + num11 > high2 - num5)                                      {                                          break;                                      }                                      num7 = (uint)num11;                                      num6 = (uint)num12;                                      high21 = num9;                                      if (high21 <= num6)                                      {                                          break;                                      }                                  }                                  else                                  {                                      break;                                  }                              }                          }                          if (num5 != 0)                          {                              reg1.SetSizeKeep(num2' 0);                              reg2.SetSizeKeep(num2' 0);                              var num14 = 0;                              var num15 = 0;                              for (var i = 0; i < num2; i++)                              {                                  var num16 = reg1._bits[i];                                  var num17 = reg2._bits[i];                                  var num18 = (long)num16 * num4 - (long)num17 * num5 + num14;                                  var num19 = (long)num17 * num7 - (long)num16 * num6 + num15;                                  num14 = (int)(num18 >> 32);                                  num15 = (int)(num19 >> 32);                                  reg1._bits[i] = (uint)num18;                                  reg2._bits[i] = (uint)num19;                              }                              reg1.Trim();                              reg2.Trim();                          }                          else if (high2 / 2 < high21)                          {                              reg1.Sub(ref num' ref reg2);                          }                          else                          {                              reg1.Mod(ref reg2);                          }                      }                      else                      {                          reg1.Mod(ref reg2);                      }                  }                  else                  {                      reg1.Mod(ref reg2);                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,LehmerGcd,The following statement contains a magic number: while (true)              {                  var num1 = reg1._iuLast + 1;                  var num2 = reg2._iuLast + 1;                  if (num1 < num2)                  {                      NumericHelper.Swap(ref reg1' ref reg2);                      NumericHelper.Swap(ref num1' ref num2);                  }                  if (num2 == 1)                  {                      if (num1 == 1)                      {                          reg1._uSmall = NumericHelper.GCD(reg1._uSmall' reg2._uSmall);                      }                      else if (reg2._uSmall != 0)                      {                          reg1.Set(NumericHelper.GCD(Mod(ref reg1' reg2._uSmall)' reg2._uSmall));                      }                      return;                  }                  if (num1 == 2)                  {                      break;                  }                  if (num2 > num1 - 2)                  {                      var high2 = reg1.GetHigh2(num1);                      var high21 = reg2.GetHigh2(num1);                      var num3 = NumericsHelpers.CbitHighZero(high2 | high21);                      if (num3 > 0)                      {                          high2 = high2 << (num3 & 63) | reg1._bits[num1 - 3] >> (32 - num3 & 31);                          high21 = high21 << (num3 & 63) | reg2._bits[num1 - 3] >> (32 - num3 & 31);                      }                      if (high2 < high21)                      {                          NumericHelper.Swap(ref high2' ref high21);                          NumericHelper.Swap(ref reg1' ref reg2);                      }                      if (high2 == ulong.MaxValue || high21 == ulong.MaxValue)                      {                          high2 = high2 >> 1;                          high21 = high21 >> 1;                      }                      if (high2 == high21)                      {                          reg1.Sub(ref num' ref reg2);                      }                      else if (NumericHelper.GetHi(high21) != 0)                      {                          uint num4 = 1;                          uint num5 = 0;                          uint num6 = 0;                          uint num7 = 1;                          while (true)                          {                              uint num8 = 1;                              var num9 = high2 - high21;                              while (num9 >= high21 && num8 < 32)                              {                                  num9 = num9 - high21;                                  num8++;                              }                              if (num9 >= high21)                              {                                  var num10 = high2 / high21;                                  if (num10 <= uint.MaxValue)                                  {                                      num8 = (uint)num10;                                      num9 = high2 - num8 * high21;                                  }                                  else                                  {                                      break;                                  }                              }                              var num11 = num4 + num8 * (ulong)num6;                              var num12 = num5 + num8 * (ulong)num7;                              if (num11 > 2147483647 || num12 > 2147483647)                              {                                  break;                              }                              else if (num9 < num12 || num9 + num11 > high21 - num6)                              {                                  break;                              }                              else                              {                                  num4 = (uint)num11;                                  num5 = (uint)num12;                                  high2 = num9;                                  if (high2 > num5)                                  {                                      num8 = 1;                                      num9 = high21 - high2;                                      while (num9 >= high2 && num8 < 32)                                      {                                          num9 = num9 - high2;                                          num8++;                                      }                                      if (num9 >= high2)                                      {                                          var num13 = high21 / high2;                                          if (num13 <= uint.MaxValue)                                          {                                              num8 = (uint)num13;                                              num9 = high21 - num8 * high2;                                          }                                          else                                          {                                              break;                                          }                                      }                                      num11 = num7 + num8 * (ulong)num5;                                      num12 = num6 + num8 * (ulong)num4;                                      if (num11 > 2147483647 || num12 > 2147483647)                                      {                                          break;                                      }                                      if (num9 < num12 || num9 + num11 > high2 - num5)                                      {                                          break;                                      }                                      num7 = (uint)num11;                                      num6 = (uint)num12;                                      high21 = num9;                                      if (high21 <= num6)                                      {                                          break;                                      }                                  }                                  else                                  {                                      break;                                  }                              }                          }                          if (num5 != 0)                          {                              reg1.SetSizeKeep(num2' 0);                              reg2.SetSizeKeep(num2' 0);                              var num14 = 0;                              var num15 = 0;                              for (var i = 0; i < num2; i++)                              {                                  var num16 = reg1._bits[i];                                  var num17 = reg2._bits[i];                                  var num18 = (long)num16 * num4 - (long)num17 * num5 + num14;                                  var num19 = (long)num17 * num7 - (long)num16 * num6 + num15;                                  num14 = (int)(num18 >> 32);                                  num15 = (int)(num19 >> 32);                                  reg1._bits[i] = (uint)num18;                                  reg2._bits[i] = (uint)num19;                              }                              reg1.Trim();                              reg2.Trim();                          }                          else if (high2 / 2 < high21)                          {                              reg1.Sub(ref num' ref reg2);                          }                          else                          {                              reg1.Mod(ref reg2);                          }                      }                      else                      {                          reg1.Mod(ref reg2);                      }                  }                  else                  {                      reg1.Mod(ref reg2);                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,LehmerGcd,The following statement contains a magic number: while (true)              {                  var num1 = reg1._iuLast + 1;                  var num2 = reg2._iuLast + 1;                  if (num1 < num2)                  {                      NumericHelper.Swap(ref reg1' ref reg2);                      NumericHelper.Swap(ref num1' ref num2);                  }                  if (num2 == 1)                  {                      if (num1 == 1)                      {                          reg1._uSmall = NumericHelper.GCD(reg1._uSmall' reg2._uSmall);                      }                      else if (reg2._uSmall != 0)                      {                          reg1.Set(NumericHelper.GCD(Mod(ref reg1' reg2._uSmall)' reg2._uSmall));                      }                      return;                  }                  if (num1 == 2)                  {                      break;                  }                  if (num2 > num1 - 2)                  {                      var high2 = reg1.GetHigh2(num1);                      var high21 = reg2.GetHigh2(num1);                      var num3 = NumericsHelpers.CbitHighZero(high2 | high21);                      if (num3 > 0)                      {                          high2 = high2 << (num3 & 63) | reg1._bits[num1 - 3] >> (32 - num3 & 31);                          high21 = high21 << (num3 & 63) | reg2._bits[num1 - 3] >> (32 - num3 & 31);                      }                      if (high2 < high21)                      {                          NumericHelper.Swap(ref high2' ref high21);                          NumericHelper.Swap(ref reg1' ref reg2);                      }                      if (high2 == ulong.MaxValue || high21 == ulong.MaxValue)                      {                          high2 = high2 >> 1;                          high21 = high21 >> 1;                      }                      if (high2 == high21)                      {                          reg1.Sub(ref num' ref reg2);                      }                      else if (NumericHelper.GetHi(high21) != 0)                      {                          uint num4 = 1;                          uint num5 = 0;                          uint num6 = 0;                          uint num7 = 1;                          while (true)                          {                              uint num8 = 1;                              var num9 = high2 - high21;                              while (num9 >= high21 && num8 < 32)                              {                                  num9 = num9 - high21;                                  num8++;                              }                              if (num9 >= high21)                              {                                  var num10 = high2 / high21;                                  if (num10 <= uint.MaxValue)                                  {                                      num8 = (uint)num10;                                      num9 = high2 - num8 * high21;                                  }                                  else                                  {                                      break;                                  }                              }                              var num11 = num4 + num8 * (ulong)num6;                              var num12 = num5 + num8 * (ulong)num7;                              if (num11 > 2147483647 || num12 > 2147483647)                              {                                  break;                              }                              else if (num9 < num12 || num9 + num11 > high21 - num6)                              {                                  break;                              }                              else                              {                                  num4 = (uint)num11;                                  num5 = (uint)num12;                                  high2 = num9;                                  if (high2 > num5)                                  {                                      num8 = 1;                                      num9 = high21 - high2;                                      while (num9 >= high2 && num8 < 32)                                      {                                          num9 = num9 - high2;                                          num8++;                                      }                                      if (num9 >= high2)                                      {                                          var num13 = high21 / high2;                                          if (num13 <= uint.MaxValue)                                          {                                              num8 = (uint)num13;                                              num9 = high21 - num8 * high2;                                          }                                          else                                          {                                              break;                                          }                                      }                                      num11 = num7 + num8 * (ulong)num5;                                      num12 = num6 + num8 * (ulong)num4;                                      if (num11 > 2147483647 || num12 > 2147483647)                                      {                                          break;                                      }                                      if (num9 < num12 || num9 + num11 > high2 - num5)                                      {                                          break;                                      }                                      num7 = (uint)num11;                                      num6 = (uint)num12;                                      high21 = num9;                                      if (high21 <= num6)                                      {                                          break;                                      }                                  }                                  else                                  {                                      break;                                  }                              }                          }                          if (num5 != 0)                          {                              reg1.SetSizeKeep(num2' 0);                              reg2.SetSizeKeep(num2' 0);                              var num14 = 0;                              var num15 = 0;                              for (var i = 0; i < num2; i++)                              {                                  var num16 = reg1._bits[i];                                  var num17 = reg2._bits[i];                                  var num18 = (long)num16 * num4 - (long)num17 * num5 + num14;                                  var num19 = (long)num17 * num7 - (long)num16 * num6 + num15;                                  num14 = (int)(num18 >> 32);                                  num15 = (int)(num19 >> 32);                                  reg1._bits[i] = (uint)num18;                                  reg2._bits[i] = (uint)num19;                              }                              reg1.Trim();                              reg2.Trim();                          }                          else if (high2 / 2 < high21)                          {                              reg1.Sub(ref num' ref reg2);                          }                          else                          {                              reg1.Mod(ref reg2);                          }                      }                      else                      {                          reg1.Mod(ref reg2);                      }                  }                  else                  {                      reg1.Mod(ref reg2);                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,LehmerGcd,The following statement contains a magic number: while (true)              {                  var num1 = reg1._iuLast + 1;                  var num2 = reg2._iuLast + 1;                  if (num1 < num2)                  {                      NumericHelper.Swap(ref reg1' ref reg2);                      NumericHelper.Swap(ref num1' ref num2);                  }                  if (num2 == 1)                  {                      if (num1 == 1)                      {                          reg1._uSmall = NumericHelper.GCD(reg1._uSmall' reg2._uSmall);                      }                      else if (reg2._uSmall != 0)                      {                          reg1.Set(NumericHelper.GCD(Mod(ref reg1' reg2._uSmall)' reg2._uSmall));                      }                      return;                  }                  if (num1 == 2)                  {                      break;                  }                  if (num2 > num1 - 2)                  {                      var high2 = reg1.GetHigh2(num1);                      var high21 = reg2.GetHigh2(num1);                      var num3 = NumericsHelpers.CbitHighZero(high2 | high21);                      if (num3 > 0)                      {                          high2 = high2 << (num3 & 63) | reg1._bits[num1 - 3] >> (32 - num3 & 31);                          high21 = high21 << (num3 & 63) | reg2._bits[num1 - 3] >> (32 - num3 & 31);                      }                      if (high2 < high21)                      {                          NumericHelper.Swap(ref high2' ref high21);                          NumericHelper.Swap(ref reg1' ref reg2);                      }                      if (high2 == ulong.MaxValue || high21 == ulong.MaxValue)                      {                          high2 = high2 >> 1;                          high21 = high21 >> 1;                      }                      if (high2 == high21)                      {                          reg1.Sub(ref num' ref reg2);                      }                      else if (NumericHelper.GetHi(high21) != 0)                      {                          uint num4 = 1;                          uint num5 = 0;                          uint num6 = 0;                          uint num7 = 1;                          while (true)                          {                              uint num8 = 1;                              var num9 = high2 - high21;                              while (num9 >= high21 && num8 < 32)                              {                                  num9 = num9 - high21;                                  num8++;                              }                              if (num9 >= high21)                              {                                  var num10 = high2 / high21;                                  if (num10 <= uint.MaxValue)                                  {                                      num8 = (uint)num10;                                      num9 = high2 - num8 * high21;                                  }                                  else                                  {                                      break;                                  }                              }                              var num11 = num4 + num8 * (ulong)num6;                              var num12 = num5 + num8 * (ulong)num7;                              if (num11 > 2147483647 || num12 > 2147483647)                              {                                  break;                              }                              else if (num9 < num12 || num9 + num11 > high21 - num6)                              {                                  break;                              }                              else                              {                                  num4 = (uint)num11;                                  num5 = (uint)num12;                                  high2 = num9;                                  if (high2 > num5)                                  {                                      num8 = 1;                                      num9 = high21 - high2;                                      while (num9 >= high2 && num8 < 32)                                      {                                          num9 = num9 - high2;                                          num8++;                                      }                                      if (num9 >= high2)                                      {                                          var num13 = high21 / high2;                                          if (num13 <= uint.MaxValue)                                          {                                              num8 = (uint)num13;                                              num9 = high21 - num8 * high2;                                          }                                          else                                          {                                              break;                                          }                                      }                                      num11 = num7 + num8 * (ulong)num5;                                      num12 = num6 + num8 * (ulong)num4;                                      if (num11 > 2147483647 || num12 > 2147483647)                                      {                                          break;                                      }                                      if (num9 < num12 || num9 + num11 > high2 - num5)                                      {                                          break;                                      }                                      num7 = (uint)num11;                                      num6 = (uint)num12;                                      high21 = num9;                                      if (high21 <= num6)                                      {                                          break;                                      }                                  }                                  else                                  {                                      break;                                  }                              }                          }                          if (num5 != 0)                          {                              reg1.SetSizeKeep(num2' 0);                              reg2.SetSizeKeep(num2' 0);                              var num14 = 0;                              var num15 = 0;                              for (var i = 0; i < num2; i++)                              {                                  var num16 = reg1._bits[i];                                  var num17 = reg2._bits[i];                                  var num18 = (long)num16 * num4 - (long)num17 * num5 + num14;                                  var num19 = (long)num17 * num7 - (long)num16 * num6 + num15;                                  num14 = (int)(num18 >> 32);                                  num15 = (int)(num19 >> 32);                                  reg1._bits[i] = (uint)num18;                                  reg2._bits[i] = (uint)num19;                              }                              reg1.Trim();                              reg2.Trim();                          }                          else if (high2 / 2 < high21)                          {                              reg1.Sub(ref num' ref reg2);                          }                          else                          {                              reg1.Mod(ref reg2);                          }                      }                      else                      {                          reg1.Mod(ref reg2);                      }                  }                  else                  {                      reg1.Mod(ref reg2);                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,LehmerGcd,The following statement contains a magic number: while (true)              {                  var num1 = reg1._iuLast + 1;                  var num2 = reg2._iuLast + 1;                  if (num1 < num2)                  {                      NumericHelper.Swap(ref reg1' ref reg2);                      NumericHelper.Swap(ref num1' ref num2);                  }                  if (num2 == 1)                  {                      if (num1 == 1)                      {                          reg1._uSmall = NumericHelper.GCD(reg1._uSmall' reg2._uSmall);                      }                      else if (reg2._uSmall != 0)                      {                          reg1.Set(NumericHelper.GCD(Mod(ref reg1' reg2._uSmall)' reg2._uSmall));                      }                      return;                  }                  if (num1 == 2)                  {                      break;                  }                  if (num2 > num1 - 2)                  {                      var high2 = reg1.GetHigh2(num1);                      var high21 = reg2.GetHigh2(num1);                      var num3 = NumericsHelpers.CbitHighZero(high2 | high21);                      if (num3 > 0)                      {                          high2 = high2 << (num3 & 63) | reg1._bits[num1 - 3] >> (32 - num3 & 31);                          high21 = high21 << (num3 & 63) | reg2._bits[num1 - 3] >> (32 - num3 & 31);                      }                      if (high2 < high21)                      {                          NumericHelper.Swap(ref high2' ref high21);                          NumericHelper.Swap(ref reg1' ref reg2);                      }                      if (high2 == ulong.MaxValue || high21 == ulong.MaxValue)                      {                          high2 = high2 >> 1;                          high21 = high21 >> 1;                      }                      if (high2 == high21)                      {                          reg1.Sub(ref num' ref reg2);                      }                      else if (NumericHelper.GetHi(high21) != 0)                      {                          uint num4 = 1;                          uint num5 = 0;                          uint num6 = 0;                          uint num7 = 1;                          while (true)                          {                              uint num8 = 1;                              var num9 = high2 - high21;                              while (num9 >= high21 && num8 < 32)                              {                                  num9 = num9 - high21;                                  num8++;                              }                              if (num9 >= high21)                              {                                  var num10 = high2 / high21;                                  if (num10 <= uint.MaxValue)                                  {                                      num8 = (uint)num10;                                      num9 = high2 - num8 * high21;                                  }                                  else                                  {                                      break;                                  }                              }                              var num11 = num4 + num8 * (ulong)num6;                              var num12 = num5 + num8 * (ulong)num7;                              if (num11 > 2147483647 || num12 > 2147483647)                              {                                  break;                              }                              else if (num9 < num12 || num9 + num11 > high21 - num6)                              {                                  break;                              }                              else                              {                                  num4 = (uint)num11;                                  num5 = (uint)num12;                                  high2 = num9;                                  if (high2 > num5)                                  {                                      num8 = 1;                                      num9 = high21 - high2;                                      while (num9 >= high2 && num8 < 32)                                      {                                          num9 = num9 - high2;                                          num8++;                                      }                                      if (num9 >= high2)                                      {                                          var num13 = high21 / high2;                                          if (num13 <= uint.MaxValue)                                          {                                              num8 = (uint)num13;                                              num9 = high21 - num8 * high2;                                          }                                          else                                          {                                              break;                                          }                                      }                                      num11 = num7 + num8 * (ulong)num5;                                      num12 = num6 + num8 * (ulong)num4;                                      if (num11 > 2147483647 || num12 > 2147483647)                                      {                                          break;                                      }                                      if (num9 < num12 || num9 + num11 > high2 - num5)                                      {                                          break;                                      }                                      num7 = (uint)num11;                                      num6 = (uint)num12;                                      high21 = num9;                                      if (high21 <= num6)                                      {                                          break;                                      }                                  }                                  else                                  {                                      break;                                  }                              }                          }                          if (num5 != 0)                          {                              reg1.SetSizeKeep(num2' 0);                              reg2.SetSizeKeep(num2' 0);                              var num14 = 0;                              var num15 = 0;                              for (var i = 0; i < num2; i++)                              {                                  var num16 = reg1._bits[i];                                  var num17 = reg2._bits[i];                                  var num18 = (long)num16 * num4 - (long)num17 * num5 + num14;                                  var num19 = (long)num17 * num7 - (long)num16 * num6 + num15;                                  num14 = (int)(num18 >> 32);                                  num15 = (int)(num19 >> 32);                                  reg1._bits[i] = (uint)num18;                                  reg2._bits[i] = (uint)num19;                              }                              reg1.Trim();                              reg2.Trim();                          }                          else if (high2 / 2 < high21)                          {                              reg1.Sub(ref num' ref reg2);                          }                          else                          {                              reg1.Mod(ref reg2);                          }                      }                      else                      {                          reg1.Mod(ref reg2);                      }                  }                  else                  {                      reg1.Mod(ref reg2);                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,LehmerGcd,The following statement contains a magic number: while (true)              {                  var num1 = reg1._iuLast + 1;                  var num2 = reg2._iuLast + 1;                  if (num1 < num2)                  {                      NumericHelper.Swap(ref reg1' ref reg2);                      NumericHelper.Swap(ref num1' ref num2);                  }                  if (num2 == 1)                  {                      if (num1 == 1)                      {                          reg1._uSmall = NumericHelper.GCD(reg1._uSmall' reg2._uSmall);                      }                      else if (reg2._uSmall != 0)                      {                          reg1.Set(NumericHelper.GCD(Mod(ref reg1' reg2._uSmall)' reg2._uSmall));                      }                      return;                  }                  if (num1 == 2)                  {                      break;                  }                  if (num2 > num1 - 2)                  {                      var high2 = reg1.GetHigh2(num1);                      var high21 = reg2.GetHigh2(num1);                      var num3 = NumericsHelpers.CbitHighZero(high2 | high21);                      if (num3 > 0)                      {                          high2 = high2 << (num3 & 63) | reg1._bits[num1 - 3] >> (32 - num3 & 31);                          high21 = high21 << (num3 & 63) | reg2._bits[num1 - 3] >> (32 - num3 & 31);                      }                      if (high2 < high21)                      {                          NumericHelper.Swap(ref high2' ref high21);                          NumericHelper.Swap(ref reg1' ref reg2);                      }                      if (high2 == ulong.MaxValue || high21 == ulong.MaxValue)                      {                          high2 = high2 >> 1;                          high21 = high21 >> 1;                      }                      if (high2 == high21)                      {                          reg1.Sub(ref num' ref reg2);                      }                      else if (NumericHelper.GetHi(high21) != 0)                      {                          uint num4 = 1;                          uint num5 = 0;                          uint num6 = 0;                          uint num7 = 1;                          while (true)                          {                              uint num8 = 1;                              var num9 = high2 - high21;                              while (num9 >= high21 && num8 < 32)                              {                                  num9 = num9 - high21;                                  num8++;                              }                              if (num9 >= high21)                              {                                  var num10 = high2 / high21;                                  if (num10 <= uint.MaxValue)                                  {                                      num8 = (uint)num10;                                      num9 = high2 - num8 * high21;                                  }                                  else                                  {                                      break;                                  }                              }                              var num11 = num4 + num8 * (ulong)num6;                              var num12 = num5 + num8 * (ulong)num7;                              if (num11 > 2147483647 || num12 > 2147483647)                              {                                  break;                              }                              else if (num9 < num12 || num9 + num11 > high21 - num6)                              {                                  break;                              }                              else                              {                                  num4 = (uint)num11;                                  num5 = (uint)num12;                                  high2 = num9;                                  if (high2 > num5)                                  {                                      num8 = 1;                                      num9 = high21 - high2;                                      while (num9 >= high2 && num8 < 32)                                      {                                          num9 = num9 - high2;                                          num8++;                                      }                                      if (num9 >= high2)                                      {                                          var num13 = high21 / high2;                                          if (num13 <= uint.MaxValue)                                          {                                              num8 = (uint)num13;                                              num9 = high21 - num8 * high2;                                          }                                          else                                          {                                              break;                                          }                                      }                                      num11 = num7 + num8 * (ulong)num5;                                      num12 = num6 + num8 * (ulong)num4;                                      if (num11 > 2147483647 || num12 > 2147483647)                                      {                                          break;                                      }                                      if (num9 < num12 || num9 + num11 > high2 - num5)                                      {                                          break;                                      }                                      num7 = (uint)num11;                                      num6 = (uint)num12;                                      high21 = num9;                                      if (high21 <= num6)                                      {                                          break;                                      }                                  }                                  else                                  {                                      break;                                  }                              }                          }                          if (num5 != 0)                          {                              reg1.SetSizeKeep(num2' 0);                              reg2.SetSizeKeep(num2' 0);                              var num14 = 0;                              var num15 = 0;                              for (var i = 0; i < num2; i++)                              {                                  var num16 = reg1._bits[i];                                  var num17 = reg2._bits[i];                                  var num18 = (long)num16 * num4 - (long)num17 * num5 + num14;                                  var num19 = (long)num17 * num7 - (long)num16 * num6 + num15;                                  num14 = (int)(num18 >> 32);                                  num15 = (int)(num19 >> 32);                                  reg1._bits[i] = (uint)num18;                                  reg2._bits[i] = (uint)num19;                              }                              reg1.Trim();                              reg2.Trim();                          }                          else if (high2 / 2 < high21)                          {                              reg1.Sub(ref num' ref reg2);                          }                          else                          {                              reg1.Mod(ref reg2);                          }                      }                      else                      {                          reg1.Mod(ref reg2);                      }                  }                  else                  {                      reg1.Mod(ref reg2);                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,LehmerGcd,The following statement contains a magic number: while (true)              {                  var num1 = reg1._iuLast + 1;                  var num2 = reg2._iuLast + 1;                  if (num1 < num2)                  {                      NumericHelper.Swap(ref reg1' ref reg2);                      NumericHelper.Swap(ref num1' ref num2);                  }                  if (num2 == 1)                  {                      if (num1 == 1)                      {                          reg1._uSmall = NumericHelper.GCD(reg1._uSmall' reg2._uSmall);                      }                      else if (reg2._uSmall != 0)                      {                          reg1.Set(NumericHelper.GCD(Mod(ref reg1' reg2._uSmall)' reg2._uSmall));                      }                      return;                  }                  if (num1 == 2)                  {                      break;                  }                  if (num2 > num1 - 2)                  {                      var high2 = reg1.GetHigh2(num1);                      var high21 = reg2.GetHigh2(num1);                      var num3 = NumericsHelpers.CbitHighZero(high2 | high21);                      if (num3 > 0)                      {                          high2 = high2 << (num3 & 63) | reg1._bits[num1 - 3] >> (32 - num3 & 31);                          high21 = high21 << (num3 & 63) | reg2._bits[num1 - 3] >> (32 - num3 & 31);                      }                      if (high2 < high21)                      {                          NumericHelper.Swap(ref high2' ref high21);                          NumericHelper.Swap(ref reg1' ref reg2);                      }                      if (high2 == ulong.MaxValue || high21 == ulong.MaxValue)                      {                          high2 = high2 >> 1;                          high21 = high21 >> 1;                      }                      if (high2 == high21)                      {                          reg1.Sub(ref num' ref reg2);                      }                      else if (NumericHelper.GetHi(high21) != 0)                      {                          uint num4 = 1;                          uint num5 = 0;                          uint num6 = 0;                          uint num7 = 1;                          while (true)                          {                              uint num8 = 1;                              var num9 = high2 - high21;                              while (num9 >= high21 && num8 < 32)                              {                                  num9 = num9 - high21;                                  num8++;                              }                              if (num9 >= high21)                              {                                  var num10 = high2 / high21;                                  if (num10 <= uint.MaxValue)                                  {                                      num8 = (uint)num10;                                      num9 = high2 - num8 * high21;                                  }                                  else                                  {                                      break;                                  }                              }                              var num11 = num4 + num8 * (ulong)num6;                              var num12 = num5 + num8 * (ulong)num7;                              if (num11 > 2147483647 || num12 > 2147483647)                              {                                  break;                              }                              else if (num9 < num12 || num9 + num11 > high21 - num6)                              {                                  break;                              }                              else                              {                                  num4 = (uint)num11;                                  num5 = (uint)num12;                                  high2 = num9;                                  if (high2 > num5)                                  {                                      num8 = 1;                                      num9 = high21 - high2;                                      while (num9 >= high2 && num8 < 32)                                      {                                          num9 = num9 - high2;                                          num8++;                                      }                                      if (num9 >= high2)                                      {                                          var num13 = high21 / high2;                                          if (num13 <= uint.MaxValue)                                          {                                              num8 = (uint)num13;                                              num9 = high21 - num8 * high2;                                          }                                          else                                          {                                              break;                                          }                                      }                                      num11 = num7 + num8 * (ulong)num5;                                      num12 = num6 + num8 * (ulong)num4;                                      if (num11 > 2147483647 || num12 > 2147483647)                                      {                                          break;                                      }                                      if (num9 < num12 || num9 + num11 > high2 - num5)                                      {                                          break;                                      }                                      num7 = (uint)num11;                                      num6 = (uint)num12;                                      high21 = num9;                                      if (high21 <= num6)                                      {                                          break;                                      }                                  }                                  else                                  {                                      break;                                  }                              }                          }                          if (num5 != 0)                          {                              reg1.SetSizeKeep(num2' 0);                              reg2.SetSizeKeep(num2' 0);                              var num14 = 0;                              var num15 = 0;                              for (var i = 0; i < num2; i++)                              {                                  var num16 = reg1._bits[i];                                  var num17 = reg2._bits[i];                                  var num18 = (long)num16 * num4 - (long)num17 * num5 + num14;                                  var num19 = (long)num17 * num7 - (long)num16 * num6 + num15;                                  num14 = (int)(num18 >> 32);                                  num15 = (int)(num19 >> 32);                                  reg1._bits[i] = (uint)num18;                                  reg2._bits[i] = (uint)num19;                              }                              reg1.Trim();                              reg2.Trim();                          }                          else if (high2 / 2 < high21)                          {                              reg1.Sub(ref num' ref reg2);                          }                          else                          {                              reg1.Mod(ref reg2);                          }                      }                      else                      {                          reg1.Mod(ref reg2);                      }                  }                  else                  {                      reg1.Mod(ref reg2);                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,LehmerGcd,The following statement contains a magic number: while (true)              {                  var num1 = reg1._iuLast + 1;                  var num2 = reg2._iuLast + 1;                  if (num1 < num2)                  {                      NumericHelper.Swap(ref reg1' ref reg2);                      NumericHelper.Swap(ref num1' ref num2);                  }                  if (num2 == 1)                  {                      if (num1 == 1)                      {                          reg1._uSmall = NumericHelper.GCD(reg1._uSmall' reg2._uSmall);                      }                      else if (reg2._uSmall != 0)                      {                          reg1.Set(NumericHelper.GCD(Mod(ref reg1' reg2._uSmall)' reg2._uSmall));                      }                      return;                  }                  if (num1 == 2)                  {                      break;                  }                  if (num2 > num1 - 2)                  {                      var high2 = reg1.GetHigh2(num1);                      var high21 = reg2.GetHigh2(num1);                      var num3 = NumericsHelpers.CbitHighZero(high2 | high21);                      if (num3 > 0)                      {                          high2 = high2 << (num3 & 63) | reg1._bits[num1 - 3] >> (32 - num3 & 31);                          high21 = high21 << (num3 & 63) | reg2._bits[num1 - 3] >> (32 - num3 & 31);                      }                      if (high2 < high21)                      {                          NumericHelper.Swap(ref high2' ref high21);                          NumericHelper.Swap(ref reg1' ref reg2);                      }                      if (high2 == ulong.MaxValue || high21 == ulong.MaxValue)                      {                          high2 = high2 >> 1;                          high21 = high21 >> 1;                      }                      if (high2 == high21)                      {                          reg1.Sub(ref num' ref reg2);                      }                      else if (NumericHelper.GetHi(high21) != 0)                      {                          uint num4 = 1;                          uint num5 = 0;                          uint num6 = 0;                          uint num7 = 1;                          while (true)                          {                              uint num8 = 1;                              var num9 = high2 - high21;                              while (num9 >= high21 && num8 < 32)                              {                                  num9 = num9 - high21;                                  num8++;                              }                              if (num9 >= high21)                              {                                  var num10 = high2 / high21;                                  if (num10 <= uint.MaxValue)                                  {                                      num8 = (uint)num10;                                      num9 = high2 - num8 * high21;                                  }                                  else                                  {                                      break;                                  }                              }                              var num11 = num4 + num8 * (ulong)num6;                              var num12 = num5 + num8 * (ulong)num7;                              if (num11 > 2147483647 || num12 > 2147483647)                              {                                  break;                              }                              else if (num9 < num12 || num9 + num11 > high21 - num6)                              {                                  break;                              }                              else                              {                                  num4 = (uint)num11;                                  num5 = (uint)num12;                                  high2 = num9;                                  if (high2 > num5)                                  {                                      num8 = 1;                                      num9 = high21 - high2;                                      while (num9 >= high2 && num8 < 32)                                      {                                          num9 = num9 - high2;                                          num8++;                                      }                                      if (num9 >= high2)                                      {                                          var num13 = high21 / high2;                                          if (num13 <= uint.MaxValue)                                          {                                              num8 = (uint)num13;                                              num9 = high21 - num8 * high2;                                          }                                          else                                          {                                              break;                                          }                                      }                                      num11 = num7 + num8 * (ulong)num5;                                      num12 = num6 + num8 * (ulong)num4;                                      if (num11 > 2147483647 || num12 > 2147483647)                                      {                                          break;                                      }                                      if (num9 < num12 || num9 + num11 > high2 - num5)                                      {                                          break;                                      }                                      num7 = (uint)num11;                                      num6 = (uint)num12;                                      high21 = num9;                                      if (high21 <= num6)                                      {                                          break;                                      }                                  }                                  else                                  {                                      break;                                  }                              }                          }                          if (num5 != 0)                          {                              reg1.SetSizeKeep(num2' 0);                              reg2.SetSizeKeep(num2' 0);                              var num14 = 0;                              var num15 = 0;                              for (var i = 0; i < num2; i++)                              {                                  var num16 = reg1._bits[i];                                  var num17 = reg2._bits[i];                                  var num18 = (long)num16 * num4 - (long)num17 * num5 + num14;                                  var num19 = (long)num17 * num7 - (long)num16 * num6 + num15;                                  num14 = (int)(num18 >> 32);                                  num15 = (int)(num19 >> 32);                                  reg1._bits[i] = (uint)num18;                                  reg2._bits[i] = (uint)num19;                              }                              reg1.Trim();                              reg2.Trim();                          }                          else if (high2 / 2 < high21)                          {                              reg1.Sub(ref num' ref reg2);                          }                          else                          {                              reg1.Mod(ref reg2);                          }                      }                      else                      {                          reg1.Mod(ref reg2);                      }                  }                  else                  {                      reg1.Mod(ref reg2);                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,LehmerGcd,The following statement contains a magic number: while (true)              {                  var num1 = reg1._iuLast + 1;                  var num2 = reg2._iuLast + 1;                  if (num1 < num2)                  {                      NumericHelper.Swap(ref reg1' ref reg2);                      NumericHelper.Swap(ref num1' ref num2);                  }                  if (num2 == 1)                  {                      if (num1 == 1)                      {                          reg1._uSmall = NumericHelper.GCD(reg1._uSmall' reg2._uSmall);                      }                      else if (reg2._uSmall != 0)                      {                          reg1.Set(NumericHelper.GCD(Mod(ref reg1' reg2._uSmall)' reg2._uSmall));                      }                      return;                  }                  if (num1 == 2)                  {                      break;                  }                  if (num2 > num1 - 2)                  {                      var high2 = reg1.GetHigh2(num1);                      var high21 = reg2.GetHigh2(num1);                      var num3 = NumericsHelpers.CbitHighZero(high2 | high21);                      if (num3 > 0)                      {                          high2 = high2 << (num3 & 63) | reg1._bits[num1 - 3] >> (32 - num3 & 31);                          high21 = high21 << (num3 & 63) | reg2._bits[num1 - 3] >> (32 - num3 & 31);                      }                      if (high2 < high21)                      {                          NumericHelper.Swap(ref high2' ref high21);                          NumericHelper.Swap(ref reg1' ref reg2);                      }                      if (high2 == ulong.MaxValue || high21 == ulong.MaxValue)                      {                          high2 = high2 >> 1;                          high21 = high21 >> 1;                      }                      if (high2 == high21)                      {                          reg1.Sub(ref num' ref reg2);                      }                      else if (NumericHelper.GetHi(high21) != 0)                      {                          uint num4 = 1;                          uint num5 = 0;                          uint num6 = 0;                          uint num7 = 1;                          while (true)                          {                              uint num8 = 1;                              var num9 = high2 - high21;                              while (num9 >= high21 && num8 < 32)                              {                                  num9 = num9 - high21;                                  num8++;                              }                              if (num9 >= high21)                              {                                  var num10 = high2 / high21;                                  if (num10 <= uint.MaxValue)                                  {                                      num8 = (uint)num10;                                      num9 = high2 - num8 * high21;                                  }                                  else                                  {                                      break;                                  }                              }                              var num11 = num4 + num8 * (ulong)num6;                              var num12 = num5 + num8 * (ulong)num7;                              if (num11 > 2147483647 || num12 > 2147483647)                              {                                  break;                              }                              else if (num9 < num12 || num9 + num11 > high21 - num6)                              {                                  break;                              }                              else                              {                                  num4 = (uint)num11;                                  num5 = (uint)num12;                                  high2 = num9;                                  if (high2 > num5)                                  {                                      num8 = 1;                                      num9 = high21 - high2;                                      while (num9 >= high2 && num8 < 32)                                      {                                          num9 = num9 - high2;                                          num8++;                                      }                                      if (num9 >= high2)                                      {                                          var num13 = high21 / high2;                                          if (num13 <= uint.MaxValue)                                          {                                              num8 = (uint)num13;                                              num9 = high21 - num8 * high2;                                          }                                          else                                          {                                              break;                                          }                                      }                                      num11 = num7 + num8 * (ulong)num5;                                      num12 = num6 + num8 * (ulong)num4;                                      if (num11 > 2147483647 || num12 > 2147483647)                                      {                                          break;                                      }                                      if (num9 < num12 || num9 + num11 > high2 - num5)                                      {                                          break;                                      }                                      num7 = (uint)num11;                                      num6 = (uint)num12;                                      high21 = num9;                                      if (high21 <= num6)                                      {                                          break;                                      }                                  }                                  else                                  {                                      break;                                  }                              }                          }                          if (num5 != 0)                          {                              reg1.SetSizeKeep(num2' 0);                              reg2.SetSizeKeep(num2' 0);                              var num14 = 0;                              var num15 = 0;                              for (var i = 0; i < num2; i++)                              {                                  var num16 = reg1._bits[i];                                  var num17 = reg2._bits[i];                                  var num18 = (long)num16 * num4 - (long)num17 * num5 + num14;                                  var num19 = (long)num17 * num7 - (long)num16 * num6 + num15;                                  num14 = (int)(num18 >> 32);                                  num15 = (int)(num19 >> 32);                                  reg1._bits[i] = (uint)num18;                                  reg2._bits[i] = (uint)num19;                              }                              reg1.Trim();                              reg2.Trim();                          }                          else if (high2 / 2 < high21)                          {                              reg1.Sub(ref num' ref reg2);                          }                          else                          {                              reg1.Mod(ref reg2);                          }                      }                      else                      {                          reg1.Mod(ref reg2);                      }                  }                  else                  {                      reg1.Mod(ref reg2);                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,LehmerGcd,The following statement contains a magic number: while (true)              {                  var num1 = reg1._iuLast + 1;                  var num2 = reg2._iuLast + 1;                  if (num1 < num2)                  {                      NumericHelper.Swap(ref reg1' ref reg2);                      NumericHelper.Swap(ref num1' ref num2);                  }                  if (num2 == 1)                  {                      if (num1 == 1)                      {                          reg1._uSmall = NumericHelper.GCD(reg1._uSmall' reg2._uSmall);                      }                      else if (reg2._uSmall != 0)                      {                          reg1.Set(NumericHelper.GCD(Mod(ref reg1' reg2._uSmall)' reg2._uSmall));                      }                      return;                  }                  if (num1 == 2)                  {                      break;                  }                  if (num2 > num1 - 2)                  {                      var high2 = reg1.GetHigh2(num1);                      var high21 = reg2.GetHigh2(num1);                      var num3 = NumericsHelpers.CbitHighZero(high2 | high21);                      if (num3 > 0)                      {                          high2 = high2 << (num3 & 63) | reg1._bits[num1 - 3] >> (32 - num3 & 31);                          high21 = high21 << (num3 & 63) | reg2._bits[num1 - 3] >> (32 - num3 & 31);                      }                      if (high2 < high21)                      {                          NumericHelper.Swap(ref high2' ref high21);                          NumericHelper.Swap(ref reg1' ref reg2);                      }                      if (high2 == ulong.MaxValue || high21 == ulong.MaxValue)                      {                          high2 = high2 >> 1;                          high21 = high21 >> 1;                      }                      if (high2 == high21)                      {                          reg1.Sub(ref num' ref reg2);                      }                      else if (NumericHelper.GetHi(high21) != 0)                      {                          uint num4 = 1;                          uint num5 = 0;                          uint num6 = 0;                          uint num7 = 1;                          while (true)                          {                              uint num8 = 1;                              var num9 = high2 - high21;                              while (num9 >= high21 && num8 < 32)                              {                                  num9 = num9 - high21;                                  num8++;                              }                              if (num9 >= high21)                              {                                  var num10 = high2 / high21;                                  if (num10 <= uint.MaxValue)                                  {                                      num8 = (uint)num10;                                      num9 = high2 - num8 * high21;                                  }                                  else                                  {                                      break;                                  }                              }                              var num11 = num4 + num8 * (ulong)num6;                              var num12 = num5 + num8 * (ulong)num7;                              if (num11 > 2147483647 || num12 > 2147483647)                              {                                  break;                              }                              else if (num9 < num12 || num9 + num11 > high21 - num6)                              {                                  break;                              }                              else                              {                                  num4 = (uint)num11;                                  num5 = (uint)num12;                                  high2 = num9;                                  if (high2 > num5)                                  {                                      num8 = 1;                                      num9 = high21 - high2;                                      while (num9 >= high2 && num8 < 32)                                      {                                          num9 = num9 - high2;                                          num8++;                                      }                                      if (num9 >= high2)                                      {                                          var num13 = high21 / high2;                                          if (num13 <= uint.MaxValue)                                          {                                              num8 = (uint)num13;                                              num9 = high21 - num8 * high2;                                          }                                          else                                          {                                              break;                                          }                                      }                                      num11 = num7 + num8 * (ulong)num5;                                      num12 = num6 + num8 * (ulong)num4;                                      if (num11 > 2147483647 || num12 > 2147483647)                                      {                                          break;                                      }                                      if (num9 < num12 || num9 + num11 > high2 - num5)                                      {                                          break;                                      }                                      num7 = (uint)num11;                                      num6 = (uint)num12;                                      high21 = num9;                                      if (high21 <= num6)                                      {                                          break;                                      }                                  }                                  else                                  {                                      break;                                  }                              }                          }                          if (num5 != 0)                          {                              reg1.SetSizeKeep(num2' 0);                              reg2.SetSizeKeep(num2' 0);                              var num14 = 0;                              var num15 = 0;                              for (var i = 0; i < num2; i++)                              {                                  var num16 = reg1._bits[i];                                  var num17 = reg2._bits[i];                                  var num18 = (long)num16 * num4 - (long)num17 * num5 + num14;                                  var num19 = (long)num17 * num7 - (long)num16 * num6 + num15;                                  num14 = (int)(num18 >> 32);                                  num15 = (int)(num19 >> 32);                                  reg1._bits[i] = (uint)num18;                                  reg2._bits[i] = (uint)num19;                              }                              reg1.Trim();                              reg2.Trim();                          }                          else if (high2 / 2 < high21)                          {                              reg1.Sub(ref num' ref reg2);                          }                          else                          {                              reg1.Mod(ref reg2);                          }                      }                      else                      {                          reg1.Mod(ref reg2);                      }                  }                  else                  {                      reg1.Mod(ref reg2);                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,LehmerGcd,The following statement contains a magic number: while (true)              {                  var num1 = reg1._iuLast + 1;                  var num2 = reg2._iuLast + 1;                  if (num1 < num2)                  {                      NumericHelper.Swap(ref reg1' ref reg2);                      NumericHelper.Swap(ref num1' ref num2);                  }                  if (num2 == 1)                  {                      if (num1 == 1)                      {                          reg1._uSmall = NumericHelper.GCD(reg1._uSmall' reg2._uSmall);                      }                      else if (reg2._uSmall != 0)                      {                          reg1.Set(NumericHelper.GCD(Mod(ref reg1' reg2._uSmall)' reg2._uSmall));                      }                      return;                  }                  if (num1 == 2)                  {                      break;                  }                  if (num2 > num1 - 2)                  {                      var high2 = reg1.GetHigh2(num1);                      var high21 = reg2.GetHigh2(num1);                      var num3 = NumericsHelpers.CbitHighZero(high2 | high21);                      if (num3 > 0)                      {                          high2 = high2 << (num3 & 63) | reg1._bits[num1 - 3] >> (32 - num3 & 31);                          high21 = high21 << (num3 & 63) | reg2._bits[num1 - 3] >> (32 - num3 & 31);                      }                      if (high2 < high21)                      {                          NumericHelper.Swap(ref high2' ref high21);                          NumericHelper.Swap(ref reg1' ref reg2);                      }                      if (high2 == ulong.MaxValue || high21 == ulong.MaxValue)                      {                          high2 = high2 >> 1;                          high21 = high21 >> 1;                      }                      if (high2 == high21)                      {                          reg1.Sub(ref num' ref reg2);                      }                      else if (NumericHelper.GetHi(high21) != 0)                      {                          uint num4 = 1;                          uint num5 = 0;                          uint num6 = 0;                          uint num7 = 1;                          while (true)                          {                              uint num8 = 1;                              var num9 = high2 - high21;                              while (num9 >= high21 && num8 < 32)                              {                                  num9 = num9 - high21;                                  num8++;                              }                              if (num9 >= high21)                              {                                  var num10 = high2 / high21;                                  if (num10 <= uint.MaxValue)                                  {                                      num8 = (uint)num10;                                      num9 = high2 - num8 * high21;                                  }                                  else                                  {                                      break;                                  }                              }                              var num11 = num4 + num8 * (ulong)num6;                              var num12 = num5 + num8 * (ulong)num7;                              if (num11 > 2147483647 || num12 > 2147483647)                              {                                  break;                              }                              else if (num9 < num12 || num9 + num11 > high21 - num6)                              {                                  break;                              }                              else                              {                                  num4 = (uint)num11;                                  num5 = (uint)num12;                                  high2 = num9;                                  if (high2 > num5)                                  {                                      num8 = 1;                                      num9 = high21 - high2;                                      while (num9 >= high2 && num8 < 32)                                      {                                          num9 = num9 - high2;                                          num8++;                                      }                                      if (num9 >= high2)                                      {                                          var num13 = high21 / high2;                                          if (num13 <= uint.MaxValue)                                          {                                              num8 = (uint)num13;                                              num9 = high21 - num8 * high2;                                          }                                          else                                          {                                              break;                                          }                                      }                                      num11 = num7 + num8 * (ulong)num5;                                      num12 = num6 + num8 * (ulong)num4;                                      if (num11 > 2147483647 || num12 > 2147483647)                                      {                                          break;                                      }                                      if (num9 < num12 || num9 + num11 > high2 - num5)                                      {                                          break;                                      }                                      num7 = (uint)num11;                                      num6 = (uint)num12;                                      high21 = num9;                                      if (high21 <= num6)                                      {                                          break;                                      }                                  }                                  else                                  {                                      break;                                  }                              }                          }                          if (num5 != 0)                          {                              reg1.SetSizeKeep(num2' 0);                              reg2.SetSizeKeep(num2' 0);                              var num14 = 0;                              var num15 = 0;                              for (var i = 0; i < num2; i++)                              {                                  var num16 = reg1._bits[i];                                  var num17 = reg2._bits[i];                                  var num18 = (long)num16 * num4 - (long)num17 * num5 + num14;                                  var num19 = (long)num17 * num7 - (long)num16 * num6 + num15;                                  num14 = (int)(num18 >> 32);                                  num15 = (int)(num19 >> 32);                                  reg1._bits[i] = (uint)num18;                                  reg2._bits[i] = (uint)num19;                              }                              reg1.Trim();                              reg2.Trim();                          }                          else if (high2 / 2 < high21)                          {                              reg1.Sub(ref num' ref reg2);                          }                          else                          {                              reg1.Mod(ref reg2);                          }                      }                      else                      {                          reg1.Mod(ref reg2);                      }                  }                  else                  {                      reg1.Mod(ref reg2);                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,LehmerGcd,The following statement contains a magic number: reg1.Set(NumericHelper.GCD(reg1.GetHigh2(2)' reg2.GetHigh2(2)));
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,LehmerGcd,The following statement contains a magic number: reg1.Set(NumericHelper.GCD(reg1.GetHigh2(2)' reg2.GetHigh2(2)));
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,ModDivCore,The following statement contains a magic number: var num6 = regDen._bits[num1 - 2];
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,ModDivCore,The following statement contains a magic number: var num8 = 32 - num7;
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,ModDivCore,The following statement contains a magic number: if (num7 > 0)              {                  num5 = num5 << (num7 & 31) | num6 >> (num8 & 31);                  num6 = num6 << (num7 & 31);                  if (num1 > 2)                  {                      num6 = num6 | regDen._bits[num1 - 3] >> (num8 & 31);                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,ModDivCore,The following statement contains a magic number: if (num7 > 0)              {                  num5 = num5 << (num7 & 31) | num6 >> (num8 & 31);                  num6 = num6 << (num7 & 31);                  if (num1 > 2)                  {                      num6 = num6 | regDen._bits[num1 - 3] >> (num8 & 31);                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,ModDivCore,The following statement contains a magic number: if (num7 > 0)              {                  num5 = num5 << (num7 & 31) | num6 >> (num8 & 31);                  num6 = num6 << (num7 & 31);                  if (num1 > 2)                  {                      num6 = num6 | regDen._bits[num1 - 3] >> (num8 & 31);                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,ModDivCore,The following statement contains a magic number: if (num7 > 0)              {                  num5 = num5 << (num7 & 31) | num6 >> (num8 & 31);                  num6 = num6 << (num7 & 31);                  if (num1 > 2)                  {                      num6 = num6 | regDen._bits[num1 - 3] >> (num8 & 31);                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,ModDivCore,The following statement contains a magic number: if (num7 > 0)              {                  num5 = num5 << (num7 & 31) | num6 >> (num8 & 31);                  num6 = num6 << (num7 & 31);                  if (num1 > 2)                  {                      num6 = num6 | regDen._bits[num1 - 3] >> (num8 & 31);                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,ModDivCore,The following statement contains a magic number: if (num7 > 0)              {                  num5 = num5 << (num7 & 31) | num6 >> (num8 & 31);                  num6 = num6 << (num7 & 31);                  if (num1 > 2)                  {                      num6 = num6 | regDen._bits[num1 - 3] >> (num8 & 31);                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,ModDivCore,The following statement contains a magic number: while (true)              {                  var num10 = num9 - 1;                  num9 = num10;                  if (num10 < 0)                  {                      break;                  }                  var num = num9 + num1 > regNum._iuLast ? 0 : regNum._bits[num9 + num1];                  var num11 = num;                  var num12 = NumericsHelpers.MakeUlong(num11' regNum._bits[num9 + num1 - 1]);                  var num13 = regNum._bits[num9 + num1 - 2];                  if (num7 > 0)                  {                      num12 = num12 << (num7 & 63) | num13 >> (num8 & 31);                      num13 = num13 << (num7 & 31);                      if (num9 + num1 >= 3)                      {                          num13 = num13 | regNum._bits[num9 + num1 - 3] >> (num8 & 31);                      }                  }                  var num14 = num12 / num5;                  var num15 = (ulong)((uint)(num12 % num5));                  if (num14 > uint.MaxValue)                  {                      num15 += num5 * (num14 - uint.MaxValue);                      num14 = uint.MaxValue;                  }                  while (num15 <= uint.MaxValue && num14 * num6 > NumericsHelpers.MakeUlong((uint)num15' num13))                  {                      num14--;                      num15 += num5;                  }                  if (num14 > 0)                  {                      var num16 = (ulong)0;                      for (var i = 0; i < num1; i++)                      {                          num16 = num16 + regDen._bits[i] * num14;                          var num17 = (uint)num16;                          num16 = num16 >> 32;                          if (regNum._bits[num9 + i] < num17)                          {                              num16 = num16 + 1;                          }                          regNum._bits[num9 + i] = regNum._bits[num9 + i] - num17;                      }                      if (num11 < num16)                      {                          uint num18 = 0;                          for (var j = 0; j < num1; j++)                          {                              num18 = AddCarry(ref regNum._bits[num9 + j]' regDen._bits[j]' num18);                          }                          num14 = num14 - 1;                      }                      regNum._iuLast = num9 + num1 - 1;                  }                  if (fQuo)                  {                      if (num3 != 1)                      {                          regQuo._bits[num9] = (uint)num14;                      }                      else                      {                          regQuo._uSmall = (uint)num14;                      }                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,ModDivCore,The following statement contains a magic number: while (true)              {                  var num10 = num9 - 1;                  num9 = num10;                  if (num10 < 0)                  {                      break;                  }                  var num = num9 + num1 > regNum._iuLast ? 0 : regNum._bits[num9 + num1];                  var num11 = num;                  var num12 = NumericsHelpers.MakeUlong(num11' regNum._bits[num9 + num1 - 1]);                  var num13 = regNum._bits[num9 + num1 - 2];                  if (num7 > 0)                  {                      num12 = num12 << (num7 & 63) | num13 >> (num8 & 31);                      num13 = num13 << (num7 & 31);                      if (num9 + num1 >= 3)                      {                          num13 = num13 | regNum._bits[num9 + num1 - 3] >> (num8 & 31);                      }                  }                  var num14 = num12 / num5;                  var num15 = (ulong)((uint)(num12 % num5));                  if (num14 > uint.MaxValue)                  {                      num15 += num5 * (num14 - uint.MaxValue);                      num14 = uint.MaxValue;                  }                  while (num15 <= uint.MaxValue && num14 * num6 > NumericsHelpers.MakeUlong((uint)num15' num13))                  {                      num14--;                      num15 += num5;                  }                  if (num14 > 0)                  {                      var num16 = (ulong)0;                      for (var i = 0; i < num1; i++)                      {                          num16 = num16 + regDen._bits[i] * num14;                          var num17 = (uint)num16;                          num16 = num16 >> 32;                          if (regNum._bits[num9 + i] < num17)                          {                              num16 = num16 + 1;                          }                          regNum._bits[num9 + i] = regNum._bits[num9 + i] - num17;                      }                      if (num11 < num16)                      {                          uint num18 = 0;                          for (var j = 0; j < num1; j++)                          {                              num18 = AddCarry(ref regNum._bits[num9 + j]' regDen._bits[j]' num18);                          }                          num14 = num14 - 1;                      }                      regNum._iuLast = num9 + num1 - 1;                  }                  if (fQuo)                  {                      if (num3 != 1)                      {                          regQuo._bits[num9] = (uint)num14;                      }                      else                      {                          regQuo._uSmall = (uint)num14;                      }                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,ModDivCore,The following statement contains a magic number: while (true)              {                  var num10 = num9 - 1;                  num9 = num10;                  if (num10 < 0)                  {                      break;                  }                  var num = num9 + num1 > regNum._iuLast ? 0 : regNum._bits[num9 + num1];                  var num11 = num;                  var num12 = NumericsHelpers.MakeUlong(num11' regNum._bits[num9 + num1 - 1]);                  var num13 = regNum._bits[num9 + num1 - 2];                  if (num7 > 0)                  {                      num12 = num12 << (num7 & 63) | num13 >> (num8 & 31);                      num13 = num13 << (num7 & 31);                      if (num9 + num1 >= 3)                      {                          num13 = num13 | regNum._bits[num9 + num1 - 3] >> (num8 & 31);                      }                  }                  var num14 = num12 / num5;                  var num15 = (ulong)((uint)(num12 % num5));                  if (num14 > uint.MaxValue)                  {                      num15 += num5 * (num14 - uint.MaxValue);                      num14 = uint.MaxValue;                  }                  while (num15 <= uint.MaxValue && num14 * num6 > NumericsHelpers.MakeUlong((uint)num15' num13))                  {                      num14--;                      num15 += num5;                  }                  if (num14 > 0)                  {                      var num16 = (ulong)0;                      for (var i = 0; i < num1; i++)                      {                          num16 = num16 + regDen._bits[i] * num14;                          var num17 = (uint)num16;                          num16 = num16 >> 32;                          if (regNum._bits[num9 + i] < num17)                          {                              num16 = num16 + 1;                          }                          regNum._bits[num9 + i] = regNum._bits[num9 + i] - num17;                      }                      if (num11 < num16)                      {                          uint num18 = 0;                          for (var j = 0; j < num1; j++)                          {                              num18 = AddCarry(ref regNum._bits[num9 + j]' regDen._bits[j]' num18);                          }                          num14 = num14 - 1;                      }                      regNum._iuLast = num9 + num1 - 1;                  }                  if (fQuo)                  {                      if (num3 != 1)                      {                          regQuo._bits[num9] = (uint)num14;                      }                      else                      {                          regQuo._uSmall = (uint)num14;                      }                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,ModDivCore,The following statement contains a magic number: while (true)              {                  var num10 = num9 - 1;                  num9 = num10;                  if (num10 < 0)                  {                      break;                  }                  var num = num9 + num1 > regNum._iuLast ? 0 : regNum._bits[num9 + num1];                  var num11 = num;                  var num12 = NumericsHelpers.MakeUlong(num11' regNum._bits[num9 + num1 - 1]);                  var num13 = regNum._bits[num9 + num1 - 2];                  if (num7 > 0)                  {                      num12 = num12 << (num7 & 63) | num13 >> (num8 & 31);                      num13 = num13 << (num7 & 31);                      if (num9 + num1 >= 3)                      {                          num13 = num13 | regNum._bits[num9 + num1 - 3] >> (num8 & 31);                      }                  }                  var num14 = num12 / num5;                  var num15 = (ulong)((uint)(num12 % num5));                  if (num14 > uint.MaxValue)                  {                      num15 += num5 * (num14 - uint.MaxValue);                      num14 = uint.MaxValue;                  }                  while (num15 <= uint.MaxValue && num14 * num6 > NumericsHelpers.MakeUlong((uint)num15' num13))                  {                      num14--;                      num15 += num5;                  }                  if (num14 > 0)                  {                      var num16 = (ulong)0;                      for (var i = 0; i < num1; i++)                      {                          num16 = num16 + regDen._bits[i] * num14;                          var num17 = (uint)num16;                          num16 = num16 >> 32;                          if (regNum._bits[num9 + i] < num17)                          {                              num16 = num16 + 1;                          }                          regNum._bits[num9 + i] = regNum._bits[num9 + i] - num17;                      }                      if (num11 < num16)                      {                          uint num18 = 0;                          for (var j = 0; j < num1; j++)                          {                              num18 = AddCarry(ref regNum._bits[num9 + j]' regDen._bits[j]' num18);                          }                          num14 = num14 - 1;                      }                      regNum._iuLast = num9 + num1 - 1;                  }                  if (fQuo)                  {                      if (num3 != 1)                      {                          regQuo._bits[num9] = (uint)num14;                      }                      else                      {                          regQuo._uSmall = (uint)num14;                      }                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,ModDivCore,The following statement contains a magic number: while (true)              {                  var num10 = num9 - 1;                  num9 = num10;                  if (num10 < 0)                  {                      break;                  }                  var num = num9 + num1 > regNum._iuLast ? 0 : regNum._bits[num9 + num1];                  var num11 = num;                  var num12 = NumericsHelpers.MakeUlong(num11' regNum._bits[num9 + num1 - 1]);                  var num13 = regNum._bits[num9 + num1 - 2];                  if (num7 > 0)                  {                      num12 = num12 << (num7 & 63) | num13 >> (num8 & 31);                      num13 = num13 << (num7 & 31);                      if (num9 + num1 >= 3)                      {                          num13 = num13 | regNum._bits[num9 + num1 - 3] >> (num8 & 31);                      }                  }                  var num14 = num12 / num5;                  var num15 = (ulong)((uint)(num12 % num5));                  if (num14 > uint.MaxValue)                  {                      num15 += num5 * (num14 - uint.MaxValue);                      num14 = uint.MaxValue;                  }                  while (num15 <= uint.MaxValue && num14 * num6 > NumericsHelpers.MakeUlong((uint)num15' num13))                  {                      num14--;                      num15 += num5;                  }                  if (num14 > 0)                  {                      var num16 = (ulong)0;                      for (var i = 0; i < num1; i++)                      {                          num16 = num16 + regDen._bits[i] * num14;                          var num17 = (uint)num16;                          num16 = num16 >> 32;                          if (regNum._bits[num9 + i] < num17)                          {                              num16 = num16 + 1;                          }                          regNum._bits[num9 + i] = regNum._bits[num9 + i] - num17;                      }                      if (num11 < num16)                      {                          uint num18 = 0;                          for (var j = 0; j < num1; j++)                          {                              num18 = AddCarry(ref regNum._bits[num9 + j]' regDen._bits[j]' num18);                          }                          num14 = num14 - 1;                      }                      regNum._iuLast = num9 + num1 - 1;                  }                  if (fQuo)                  {                      if (num3 != 1)                      {                          regQuo._bits[num9] = (uint)num14;                      }                      else                      {                          regQuo._uSmall = (uint)num14;                      }                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,ModDivCore,The following statement contains a magic number: while (true)              {                  var num10 = num9 - 1;                  num9 = num10;                  if (num10 < 0)                  {                      break;                  }                  var num = num9 + num1 > regNum._iuLast ? 0 : regNum._bits[num9 + num1];                  var num11 = num;                  var num12 = NumericsHelpers.MakeUlong(num11' regNum._bits[num9 + num1 - 1]);                  var num13 = regNum._bits[num9 + num1 - 2];                  if (num7 > 0)                  {                      num12 = num12 << (num7 & 63) | num13 >> (num8 & 31);                      num13 = num13 << (num7 & 31);                      if (num9 + num1 >= 3)                      {                          num13 = num13 | regNum._bits[num9 + num1 - 3] >> (num8 & 31);                      }                  }                  var num14 = num12 / num5;                  var num15 = (ulong)((uint)(num12 % num5));                  if (num14 > uint.MaxValue)                  {                      num15 += num5 * (num14 - uint.MaxValue);                      num14 = uint.MaxValue;                  }                  while (num15 <= uint.MaxValue && num14 * num6 > NumericsHelpers.MakeUlong((uint)num15' num13))                  {                      num14--;                      num15 += num5;                  }                  if (num14 > 0)                  {                      var num16 = (ulong)0;                      for (var i = 0; i < num1; i++)                      {                          num16 = num16 + regDen._bits[i] * num14;                          var num17 = (uint)num16;                          num16 = num16 >> 32;                          if (regNum._bits[num9 + i] < num17)                          {                              num16 = num16 + 1;                          }                          regNum._bits[num9 + i] = regNum._bits[num9 + i] - num17;                      }                      if (num11 < num16)                      {                          uint num18 = 0;                          for (var j = 0; j < num1; j++)                          {                              num18 = AddCarry(ref regNum._bits[num9 + j]' regDen._bits[j]' num18);                          }                          num14 = num14 - 1;                      }                      regNum._iuLast = num9 + num1 - 1;                  }                  if (fQuo)                  {                      if (num3 != 1)                      {                          regQuo._bits[num9] = (uint)num14;                      }                      else                      {                          regQuo._uSmall = (uint)num14;                      }                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,ModDivCore,The following statement contains a magic number: while (true)              {                  var num10 = num9 - 1;                  num9 = num10;                  if (num10 < 0)                  {                      break;                  }                  var num = num9 + num1 > regNum._iuLast ? 0 : regNum._bits[num9 + num1];                  var num11 = num;                  var num12 = NumericsHelpers.MakeUlong(num11' regNum._bits[num9 + num1 - 1]);                  var num13 = regNum._bits[num9 + num1 - 2];                  if (num7 > 0)                  {                      num12 = num12 << (num7 & 63) | num13 >> (num8 & 31);                      num13 = num13 << (num7 & 31);                      if (num9 + num1 >= 3)                      {                          num13 = num13 | regNum._bits[num9 + num1 - 3] >> (num8 & 31);                      }                  }                  var num14 = num12 / num5;                  var num15 = (ulong)((uint)(num12 % num5));                  if (num14 > uint.MaxValue)                  {                      num15 += num5 * (num14 - uint.MaxValue);                      num14 = uint.MaxValue;                  }                  while (num15 <= uint.MaxValue && num14 * num6 > NumericsHelpers.MakeUlong((uint)num15' num13))                  {                      num14--;                      num15 += num5;                  }                  if (num14 > 0)                  {                      var num16 = (ulong)0;                      for (var i = 0; i < num1; i++)                      {                          num16 = num16 + regDen._bits[i] * num14;                          var num17 = (uint)num16;                          num16 = num16 >> 32;                          if (regNum._bits[num9 + i] < num17)                          {                              num16 = num16 + 1;                          }                          regNum._bits[num9 + i] = regNum._bits[num9 + i] - num17;                      }                      if (num11 < num16)                      {                          uint num18 = 0;                          for (var j = 0; j < num1; j++)                          {                              num18 = AddCarry(ref regNum._bits[num9 + j]' regDen._bits[j]' num18);                          }                          num14 = num14 - 1;                      }                      regNum._iuLast = num9 + num1 - 1;                  }                  if (fQuo)                  {                      if (num3 != 1)                      {                          regQuo._bits[num9] = (uint)num14;                      }                      else                      {                          regQuo._uSmall = (uint)num14;                      }                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,ModDivCore,The following statement contains a magic number: while (true)              {                  var num10 = num9 - 1;                  num9 = num10;                  if (num10 < 0)                  {                      break;                  }                  var num = num9 + num1 > regNum._iuLast ? 0 : regNum._bits[num9 + num1];                  var num11 = num;                  var num12 = NumericsHelpers.MakeUlong(num11' regNum._bits[num9 + num1 - 1]);                  var num13 = regNum._bits[num9 + num1 - 2];                  if (num7 > 0)                  {                      num12 = num12 << (num7 & 63) | num13 >> (num8 & 31);                      num13 = num13 << (num7 & 31);                      if (num9 + num1 >= 3)                      {                          num13 = num13 | regNum._bits[num9 + num1 - 3] >> (num8 & 31);                      }                  }                  var num14 = num12 / num5;                  var num15 = (ulong)((uint)(num12 % num5));                  if (num14 > uint.MaxValue)                  {                      num15 += num5 * (num14 - uint.MaxValue);                      num14 = uint.MaxValue;                  }                  while (num15 <= uint.MaxValue && num14 * num6 > NumericsHelpers.MakeUlong((uint)num15' num13))                  {                      num14--;                      num15 += num5;                  }                  if (num14 > 0)                  {                      var num16 = (ulong)0;                      for (var i = 0; i < num1; i++)                      {                          num16 = num16 + regDen._bits[i] * num14;                          var num17 = (uint)num16;                          num16 = num16 >> 32;                          if (regNum._bits[num9 + i] < num17)                          {                              num16 = num16 + 1;                          }                          regNum._bits[num9 + i] = regNum._bits[num9 + i] - num17;                      }                      if (num11 < num16)                      {                          uint num18 = 0;                          for (var j = 0; j < num1; j++)                          {                              num18 = AddCarry(ref regNum._bits[num9 + j]' regDen._bits[j]' num18);                          }                          num14 = num14 - 1;                      }                      regNum._iuLast = num9 + num1 - 1;                  }                  if (fQuo)                  {                      if (num3 != 1)                      {                          regQuo._bits[num9] = (uint)num14;                      }                      else                      {                          regQuo._uSmall = (uint)num14;                      }                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,Mul,The following statement contains a magic number: if (num != 0)              {                  SetSizeKeep(_iuLast + 2' 0);                  _bits[_iuLast] = num;              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,Mul,The following statement contains a magic number: if (regMul._iuLast == 0)              {                  Mul(regMul._uSmall);              }              else if (_iuLast != 0)              {                  var num = _iuLast + 1;                  SetSizeKeep(num + regMul._iuLast' 1);                  var num1 = num;                  while (true)                  {                      var num2 = num1 - 1;                      num1 = num2;                      if (num2 < 0)                      {                          break;                      }                      var num3 = _bits[num1];                      _bits[num1] = 0;                      uint num4 = 0;                      for (var i = 0; i <= regMul._iuLast; i++)                      {                          num4 = AddMulCarry(ref _bits[num1 + i]' regMul._bits[i]' num3' num4);                      }                      if (num4 != 0)                      {                          for (var j = num1 + regMul._iuLast + 1; num4 != 0 && j <= _iuLast; j++)                          {                              num4 = AddCarry(ref _bits[j]' 0' num4);                          }                          if (num4 != 0)                          {                              SetSizeKeep(_iuLast + 2' 0);                              _bits[_iuLast] = num4;                          }                      }                  }              }              else              {                  var num5 = _uSmall;                  if (num5 == 1)                  {                      this = new BigIntegerBuilder(ref regMul);                  }                  else if (num5 != 0)                  {                      Load(ref regMul' 1);                      Mul(num5);                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,Mul,The following statement contains a magic number: if (reg1._iuLast == 0)              {                  if (reg2._iuLast != 0)                  {                      Load(ref reg2' 1);                      Mul(reg1._uSmall);                  }                  else                  {                      Set(reg1._uSmall * (ulong)reg2._uSmall);                  }              }              else if (reg2._iuLast != 0)              {                  SetSizeClear(reg1._iuLast + reg2._iuLast + 2);                  uint[] numArray;                  uint[] numArray1;                  int num;                  int num1;                  if (reg1.CuNonZero > reg2.CuNonZero)                  {                      numArray = reg2._bits;                      num = reg2._iuLast + 1;                      numArray1 = reg1._bits;                      num1 = reg1._iuLast + 1;                  }                  else                  {                      numArray = reg1._bits;                      num = reg1._iuLast + 1;                      numArray1 = reg2._bits;                      num1 = reg2._iuLast + 1;                  }                  for (var i = 0; i < num; i++)                  {                      var num2 = numArray[i];                      if (num2 != 0)                      {                          uint num3 = 0;                          var num4 = i;                          var num5 = 0;                          while (num5 < num1)                          {                              num3 = AddMulCarry(ref _bits[num4]' num2' numArray1[num5]' num3);                              num5++;                              num4++;                          }                          while (num3 != 0)                          {                              var num6 = num4;                              num4 = num6 + 1;                              num3 = AddCarry(ref _bits[num6]' 0' num3);                          }                      }                  }                  Trim();              }              else              {                  Load(ref reg1' 1);                  Mul(reg2._uSmall);              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,MulCarry,The following statement contains a magic number: return (uint)(num >> 32);
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,Set,The following statement contains a magic number: if (hi != 0)              {                  SetSizeLazy(2);                  _bits[0] = (uint)uu;                  _bits[1] = hi;              }              else              {                  _uSmall = NumericHelper.GetLo(uu);                  _iuLast = 0;              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,ShiftLeft,The following statement contains a magic number: ShiftLeft(cbit / 32' cbit % 32);
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,ShiftLeft,The following statement contains a magic number: ShiftLeft(cbit / 32' cbit % 32);
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,ShiftLeft,The following statement contains a magic number: if (cbitShift > 0)              {                  high = High >> (32 - cbitShift & 31);                  if (high != 0)                  {                      num++;                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,ShiftLeft,The following statement contains a magic number: if (cbitShift > 0)              {                  high = High >> (32 - cbitShift & 31);                  if (high != 0)                  {                      num++;                  }              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,ShiftLeft,The following statement contains a magic number: if (num == 0)              {                  _uSmall <<= (cbitShift & 31);                  return;              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,ShiftLeft,The following statement contains a magic number: if (_iuLast == 0)              {                  if (high != 0)                  {                      _bits[cuShift + 1] = high;                  }                  _bits[cuShift] = _uSmall << (cbitShift & 31);              }              else if (cbitShift != 0)              {                  var num1 = _iuLast;                  var num2 = _iuLast + cuShift;                  if (num2 < num)                  {                      _bits[num] = high;                  }                  while (num1 > 0)                  {                      _bits[num2] = numArray[num1] << (cbitShift & 31) | numArray[num1 - 1] >> (32 - cbitShift & 31);                      num1--;                      num2--;                  }                  _bits[cuShift] = numArray[0] << (cbitShift & 31);              }              else              {                  Array.Copy(numArray' 0' _bits' cuShift' _iuLast + 1);              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,ShiftLeft,The following statement contains a magic number: if (_iuLast == 0)              {                  if (high != 0)                  {                      _bits[cuShift + 1] = high;                  }                  _bits[cuShift] = _uSmall << (cbitShift & 31);              }              else if (cbitShift != 0)              {                  var num1 = _iuLast;                  var num2 = _iuLast + cuShift;                  if (num2 < num)                  {                      _bits[num] = high;                  }                  while (num1 > 0)                  {                      _bits[num2] = numArray[num1] << (cbitShift & 31) | numArray[num1 - 1] >> (32 - cbitShift & 31);                      num1--;                      num2--;                  }                  _bits[cuShift] = numArray[0] << (cbitShift & 31);              }              else              {                  Array.Copy(numArray' 0' _bits' cuShift' _iuLast + 1);              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,ShiftLeft,The following statement contains a magic number: if (_iuLast == 0)              {                  if (high != 0)                  {                      _bits[cuShift + 1] = high;                  }                  _bits[cuShift] = _uSmall << (cbitShift & 31);              }              else if (cbitShift != 0)              {                  var num1 = _iuLast;                  var num2 = _iuLast + cuShift;                  if (num2 < num)                  {                      _bits[num] = high;                  }                  while (num1 > 0)                  {                      _bits[num2] = numArray[num1] << (cbitShift & 31) | numArray[num1 - 1] >> (32 - cbitShift & 31);                      num1--;                      num2--;                  }                  _bits[cuShift] = numArray[0] << (cbitShift & 31);              }              else              {                  Array.Copy(numArray' 0' _bits' cuShift' _iuLast + 1);              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,ShiftLeft,The following statement contains a magic number: if (_iuLast == 0)              {                  if (high != 0)                  {                      _bits[cuShift + 1] = high;                  }                  _bits[cuShift] = _uSmall << (cbitShift & 31);              }              else if (cbitShift != 0)              {                  var num1 = _iuLast;                  var num2 = _iuLast + cuShift;                  if (num2 < num)                  {                      _bits[num] = high;                  }                  while (num1 > 0)                  {                      _bits[num2] = numArray[num1] << (cbitShift & 31) | numArray[num1 - 1] >> (32 - cbitShift & 31);                      num1--;                      num2--;                  }                  _bits[cuShift] = numArray[0] << (cbitShift & 31);              }              else              {                  Array.Copy(numArray' 0' _bits' cuShift' _iuLast + 1);              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,ShiftLeft,The following statement contains a magic number: if (_iuLast == 0)              {                  if (high != 0)                  {                      _bits[cuShift + 1] = high;                  }                  _bits[cuShift] = _uSmall << (cbitShift & 31);              }              else if (cbitShift != 0)              {                  var num1 = _iuLast;                  var num2 = _iuLast + cuShift;                  if (num2 < num)                  {                      _bits[num] = high;                  }                  while (num1 > 0)                  {                      _bits[num2] = numArray[num1] << (cbitShift & 31) | numArray[num1 - 1] >> (32 - cbitShift & 31);                      num1--;                      num2--;                  }                  _bits[cuShift] = numArray[0] << (cbitShift & 31);              }              else              {                  Array.Copy(numArray' 0' _bits' cuShift' _iuLast + 1);              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,ShiftRight,The following statement contains a magic number: ShiftRight(cbit / 32' cbit % 32);
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,ShiftRight,The following statement contains a magic number: ShiftRight(cbit / 32' cbit % 32);
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,ShiftRight,The following statement contains a magic number: if (_iuLast == 0)              {                  _uSmall >>= (cbitShift & 31);                  return;              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,ShiftRight,The following statement contains a magic number: if (_iuLast != 0)              {                  if (!_fWritable)                  {                      _bits = new uint[_iuLast + 1];                      _fWritable = true;                  }                  if (cbitShift <= 0)                  {                      Array.Copy(numArray' cuShift' _bits' 0' _iuLast + 1);                  }                  else                  {                      var num1 = cuShift + 1;                      var num2 = 0;                      while (num1 < num)                      {                          _bits[num2] = numArray[num1 - 1] >> (cbitShift & 31) | numArray[num1] << (32 - cbitShift & 31);                          num1++;                          num2++;                      }                      _bits[_iuLast] = numArray[num - 1] >> (cbitShift & 31);                      Trim();                  }              }              else              {                  _uSmall = numArray[cuShift] >> (cbitShift & 31);              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,ShiftRight,The following statement contains a magic number: if (_iuLast != 0)              {                  if (!_fWritable)                  {                      _bits = new uint[_iuLast + 1];                      _fWritable = true;                  }                  if (cbitShift <= 0)                  {                      Array.Copy(numArray' cuShift' _bits' 0' _iuLast + 1);                  }                  else                  {                      var num1 = cuShift + 1;                      var num2 = 0;                      while (num1 < num)                      {                          _bits[num2] = numArray[num1 - 1] >> (cbitShift & 31) | numArray[num1] << (32 - cbitShift & 31);                          num1++;                          num2++;                      }                      _bits[_iuLast] = numArray[num - 1] >> (cbitShift & 31);                      Trim();                  }              }              else              {                  _uSmall = numArray[cuShift] >> (cbitShift & 31);              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,ShiftRight,The following statement contains a magic number: if (_iuLast != 0)              {                  if (!_fWritable)                  {                      _bits = new uint[_iuLast + 1];                      _fWritable = true;                  }                  if (cbitShift <= 0)                  {                      Array.Copy(numArray' cuShift' _bits' 0' _iuLast + 1);                  }                  else                  {                      var num1 = cuShift + 1;                      var num2 = 0;                      while (num1 < num)                      {                          _bits[num2] = numArray[num1 - 1] >> (cbitShift & 31) | numArray[num1] << (32 - cbitShift & 31);                          num1++;                          num2++;                      }                      _bits[_iuLast] = numArray[num - 1] >> (cbitShift & 31);                      Trim();                  }              }              else              {                  _uSmall = numArray[cuShift] >> (cbitShift & 31);              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,ShiftRight,The following statement contains a magic number: if (_iuLast != 0)              {                  if (!_fWritable)                  {                      _bits = new uint[_iuLast + 1];                      _fWritable = true;                  }                  if (cbitShift <= 0)                  {                      Array.Copy(numArray' cuShift' _bits' 0' _iuLast + 1);                  }                  else                  {                      var num1 = cuShift + 1;                      var num2 = 0;                      while (num1 < num)                      {                          _bits[num2] = numArray[num1 - 1] >> (cbitShift & 31) | numArray[num1] << (32 - cbitShift & 31);                          num1++;                          num2++;                      }                      _bits[_iuLast] = numArray[num - 1] >> (cbitShift & 31);                      Trim();                  }              }              else              {                  _uSmall = numArray[cuShift] >> (cbitShift & 31);              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,ShiftRight,The following statement contains a magic number: if (_iuLast != 0)              {                  if (!_fWritable)                  {                      _bits = new uint[_iuLast + 1];                      _fWritable = true;                  }                  if (cbitShift <= 0)                  {                      Array.Copy(numArray' cuShift' _bits' 0' _iuLast + 1);                  }                  else                  {                      var num1 = cuShift + 1;                      var num2 = 0;                      while (num1 < num)                      {                          _bits[num2] = numArray[num1 - 1] >> (cbitShift & 31) | numArray[num1] << (32 - cbitShift & 31);                          num1++;                          num2++;                      }                      _bits[_iuLast] = numArray[num - 1] >> (cbitShift & 31);                      Trim();                  }              }              else              {                  _uSmall = numArray[cuShift] >> (cbitShift & 31);              }
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,SubBorrow,The following statement contains a magic number: return (uint)(-(int)(num >> 32));
Magic Number,System.Numerics,BigIntegerBuilder,C:\repos\theraot_Theraot\Core\System\Numerics\BigIntegerBuilder.cs,SubRevBorrow,The following statement contains a magic number: return (uint)(-(int)(num >> 32));
Magic Number,System.Numerics,NumericsHelpers,C:\repos\theraot_Theraot\Core\System\Numerics\NumericsHelpers.cs,GetDoubleParts,The following statement contains a magic number: sign = 1 - ((int)(du.Uu >> 62) & 2);
Magic Number,System.Numerics,NumericsHelpers,C:\repos\theraot_Theraot\Core\System\Numerics\NumericsHelpers.cs,GetDoubleParts,The following statement contains a magic number: sign = 1 - ((int)(du.Uu >> 62) & 2);
Magic Number,System.Numerics,NumericsHelpers,C:\repos\theraot_Theraot\Core\System\Numerics\NumericsHelpers.cs,GetDoubleParts,The following statement contains a magic number: exp = (int)(du.Uu >> 52) & 0x7FF;
Magic Number,System.Numerics,NumericsHelpers,C:\repos\theraot_Theraot\Core\System\Numerics\NumericsHelpers.cs,GetDoubleParts,The following statement contains a magic number: if (exp == 0)              {                  // Denormalized number.                  fFinite = true;                  if (man != 0)                  {                      exp = -1074;                  }              }              else if (exp == 0x7FF)              {                  // NaN or Inifite.                  fFinite = false;                  exp = int.MaxValue;              }              else              {                  fFinite = true;                  man |= 0x0010000000000000;                  exp -= 1075;              }
Magic Number,System.Numerics,NumericsHelpers,C:\repos\theraot_Theraot\Core\System\Numerics\NumericsHelpers.cs,GetDoubleParts,The following statement contains a magic number: if (exp == 0)              {                  // Denormalized number.                  fFinite = true;                  if (man != 0)                  {                      exp = -1074;                  }              }              else if (exp == 0x7FF)              {                  // NaN or Inifite.                  fFinite = false;                  exp = int.MaxValue;              }              else              {                  fFinite = true;                  man |= 0x0010000000000000;                  exp -= 1075;              }
Magic Number,System.Numerics,NumericsHelpers,C:\repos\theraot_Theraot\Core\System\Numerics\NumericsHelpers.cs,GetDoubleFromParts,The following statement contains a magic number: if (man == 0)              {                  du.Uu = 0;              }              else              {                  // Normalize so that 0x0010 0000 0000 0000 is the highest bit set.                  var cbitShift = CbitHighZero(man) - 11;                  if (cbitShift < 0)                  {                      man >>= -cbitShift;                  }                  else                  {                      man <<= cbitShift;                  }                    exp -= cbitShift;                  Debug.Assert((man & 0xFFF0000000000000) == 0x0010000000000000);                    // Move the point to just behind the leading 1: 0x001.0 0000 0000 0000                  // (52 bits) and skew the exponent (by 0x3FF == 1023).                  exp += 1075;                    if (exp >= 0x7FF)                  {                      // Infinity.                      du.Uu = 0x7FF0000000000000;                  }                  else if (exp <= 0)                  {                      // Denormalized.                      exp--;                      if (exp < -52)                      {                          // Underflow to zero.                          du.Uu = 0;                      }                      else                      {                          du.Uu = man >> -exp;                          Debug.Assert(du.Uu != 0);                      }                  }                  else                  {                      // Mask off the implicit high bit.                      du.Uu = (man & 0x000FFFFFFFFFFFFF) | ((ulong)exp << 52);                  }              }
Magic Number,System.Numerics,NumericsHelpers,C:\repos\theraot_Theraot\Core\System\Numerics\NumericsHelpers.cs,GetDoubleFromParts,The following statement contains a magic number: if (man == 0)              {                  du.Uu = 0;              }              else              {                  // Normalize so that 0x0010 0000 0000 0000 is the highest bit set.                  var cbitShift = CbitHighZero(man) - 11;                  if (cbitShift < 0)                  {                      man >>= -cbitShift;                  }                  else                  {                      man <<= cbitShift;                  }                    exp -= cbitShift;                  Debug.Assert((man & 0xFFF0000000000000) == 0x0010000000000000);                    // Move the point to just behind the leading 1: 0x001.0 0000 0000 0000                  // (52 bits) and skew the exponent (by 0x3FF == 1023).                  exp += 1075;                    if (exp >= 0x7FF)                  {                      // Infinity.                      du.Uu = 0x7FF0000000000000;                  }                  else if (exp <= 0)                  {                      // Denormalized.                      exp--;                      if (exp < -52)                      {                          // Underflow to zero.                          du.Uu = 0;                      }                      else                      {                          du.Uu = man >> -exp;                          Debug.Assert(du.Uu != 0);                      }                  }                  else                  {                      // Mask off the implicit high bit.                      du.Uu = (man & 0x000FFFFFFFFFFFFF) | ((ulong)exp << 52);                  }              }
Magic Number,System.Numerics,NumericsHelpers,C:\repos\theraot_Theraot\Core\System\Numerics\NumericsHelpers.cs,GetDoubleFromParts,The following statement contains a magic number: if (man == 0)              {                  du.Uu = 0;              }              else              {                  // Normalize so that 0x0010 0000 0000 0000 is the highest bit set.                  var cbitShift = CbitHighZero(man) - 11;                  if (cbitShift < 0)                  {                      man >>= -cbitShift;                  }                  else                  {                      man <<= cbitShift;                  }                    exp -= cbitShift;                  Debug.Assert((man & 0xFFF0000000000000) == 0x0010000000000000);                    // Move the point to just behind the leading 1: 0x001.0 0000 0000 0000                  // (52 bits) and skew the exponent (by 0x3FF == 1023).                  exp += 1075;                    if (exp >= 0x7FF)                  {                      // Infinity.                      du.Uu = 0x7FF0000000000000;                  }                  else if (exp <= 0)                  {                      // Denormalized.                      exp--;                      if (exp < -52)                      {                          // Underflow to zero.                          du.Uu = 0;                      }                      else                      {                          du.Uu = man >> -exp;                          Debug.Assert(du.Uu != 0);                      }                  }                  else                  {                      // Mask off the implicit high bit.                      du.Uu = (man & 0x000FFFFFFFFFFFFF) | ((ulong)exp << 52);                  }              }
Magic Number,System.Numerics,NumericsHelpers,C:\repos\theraot_Theraot\Core\System\Numerics\NumericsHelpers.cs,GetDoubleFromParts,The following statement contains a magic number: if (man == 0)              {                  du.Uu = 0;              }              else              {                  // Normalize so that 0x0010 0000 0000 0000 is the highest bit set.                  var cbitShift = CbitHighZero(man) - 11;                  if (cbitShift < 0)                  {                      man >>= -cbitShift;                  }                  else                  {                      man <<= cbitShift;                  }                    exp -= cbitShift;                  Debug.Assert((man & 0xFFF0000000000000) == 0x0010000000000000);                    // Move the point to just behind the leading 1: 0x001.0 0000 0000 0000                  // (52 bits) and skew the exponent (by 0x3FF == 1023).                  exp += 1075;                    if (exp >= 0x7FF)                  {                      // Infinity.                      du.Uu = 0x7FF0000000000000;                  }                  else if (exp <= 0)                  {                      // Denormalized.                      exp--;                      if (exp < -52)                      {                          // Underflow to zero.                          du.Uu = 0;                      }                      else                      {                          du.Uu = man >> -exp;                          Debug.Assert(du.Uu != 0);                      }                  }                  else                  {                      // Mask off the implicit high bit.                      du.Uu = (man & 0x000FFFFFFFFFFFFF) | ((ulong)exp << 52);                  }              }
Magic Number,System.Numerics,NumericsHelpers,C:\repos\theraot_Theraot\Core\System\Numerics\NumericsHelpers.cs,Abs,The following statement contains a magic number: var mask = (uint)(a >> 31);
Magic Number,System.Numerics,NumericsHelpers,C:\repos\theraot_Theraot\Core\System\Numerics\NumericsHelpers.cs,CombineHash,The following statement contains a magic number: return ((u1 << 7) | (u1 >> 25)) ^ u2;
Magic Number,System.Numerics,NumericsHelpers,C:\repos\theraot_Theraot\Core\System\Numerics\NumericsHelpers.cs,CombineHash,The following statement contains a magic number: return ((u1 << 7) | (u1 >> 25)) ^ u2;
Magic Number,System.Numerics,NumericsHelpers,C:\repos\theraot_Theraot\Core\System\Numerics\NumericsHelpers.cs,CbitHighZero,The following statement contains a magic number: if (u == 0)              {                  return 32;              }
Magic Number,System.Numerics,NumericsHelpers,C:\repos\theraot_Theraot\Core\System\Numerics\NumericsHelpers.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xFFFF0000) == 0)              {                  cbit += 16;                  u <<= 16;              }
Magic Number,System.Numerics,NumericsHelpers,C:\repos\theraot_Theraot\Core\System\Numerics\NumericsHelpers.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xFFFF0000) == 0)              {                  cbit += 16;                  u <<= 16;              }
Magic Number,System.Numerics,NumericsHelpers,C:\repos\theraot_Theraot\Core\System\Numerics\NumericsHelpers.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xFF000000) == 0)              {                  cbit += 8;                  u <<= 8;              }
Magic Number,System.Numerics,NumericsHelpers,C:\repos\theraot_Theraot\Core\System\Numerics\NumericsHelpers.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xFF000000) == 0)              {                  cbit += 8;                  u <<= 8;              }
Magic Number,System.Numerics,NumericsHelpers,C:\repos\theraot_Theraot\Core\System\Numerics\NumericsHelpers.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xF0000000) == 0)              {                  cbit += 4;                  u <<= 4;              }
Magic Number,System.Numerics,NumericsHelpers,C:\repos\theraot_Theraot\Core\System\Numerics\NumericsHelpers.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xF0000000) == 0)              {                  cbit += 4;                  u <<= 4;              }
Magic Number,System.Numerics,NumericsHelpers,C:\repos\theraot_Theraot\Core\System\Numerics\NumericsHelpers.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xC0000000) == 0)              {                  cbit += 2;                  u <<= 2;              }
Magic Number,System.Numerics,NumericsHelpers,C:\repos\theraot_Theraot\Core\System\Numerics\NumericsHelpers.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xC0000000) == 0)              {                  cbit += 2;                  u <<= 2;              }
Magic Number,System.Numerics,NumericsHelpers,C:\repos\theraot_Theraot\Core\System\Numerics\NumericsHelpers.cs,CbitHighZero,The following statement contains a magic number: if ((uu & 0xFFFFFFFF00000000) == 0)              {                  return 32 + CbitHighZero((uint)uu);              }
Magic Number,System.Numerics,NumericsHelpers,C:\repos\theraot_Theraot\Core\System\Numerics\NumericsHelpers.cs,CbitHighZero,The following statement contains a magic number: return CbitHighZero((uint)(uu >> 32));
Magic Number,System.Numerics,Complex,C:\repos\theraot_Theraot\Core\System\Numerics\Complex.net35.cs,Atan,The following statement contains a magic number: return (ImaginaryOne / new Complex(2' 0)) * (Log(One - (ImaginaryOne * value)) - Log(One + (ImaginaryOne * value)));
Magic Number,System.Numerics,Complex,C:\repos\theraot_Theraot\Core\System\Numerics\Complex.net35.cs,Log10,The following statement contains a magic number: return Log(value' 10);
Magic Number,System.Numerics,Complex,C:\repos\theraot_Theraot\Core\System\Numerics\Complex.net35.cs,Sqrt,The following statement contains a magic number: return FromPolarCoordinates(Math.Sqrt(value.Magnitude)' value.Phase / 2);
Magic Number,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,GetHashCode,The following statement contains a magic number: if (size >= 8)              {                  return rest.GetHashCode();              }
Magic Number,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,GetHashCode,The following statement contains a magic number: var k = 8 - size;
Magic Number,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,GetHashCode,The following statement contains a magic number: switch (k)              {                  case 1:                      return ValueTuple.CombineHashCodes(EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 2:                      return ValueTuple.CombineHashCodes(EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 3:                      return ValueTuple.CombineHashCodes(EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 4:                      return ValueTuple.CombineHashCodes(EqualityComparer<T4>.Default.GetHashCode(Item4)'                                                         EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 5:                      return ValueTuple.CombineHashCodes(EqualityComparer<T3>.Default.GetHashCode(Item3)'                                                         EqualityComparer<T4>.Default.GetHashCode(Item4)'                                                         EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 6:                      return ValueTuple.CombineHashCodes(EqualityComparer<T2>.Default.GetHashCode(Item2)'                                                         EqualityComparer<T3>.Default.GetHashCode(Item3)'                                                         EqualityComparer<T4>.Default.GetHashCode(Item4)'                                                         EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 7:                  case 8:                      return ValueTuple.CombineHashCodes(EqualityComparer<T1>.Default.GetHashCode(Item1)'                                                         EqualityComparer<T2>.Default.GetHashCode(Item2)'                                                         EqualityComparer<T3>.Default.GetHashCode(Item3)'                                                         EqualityComparer<T4>.Default.GetHashCode(Item4)'                                                         EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());              }
Magic Number,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,GetHashCode,The following statement contains a magic number: switch (k)              {                  case 1:                      return ValueTuple.CombineHashCodes(EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 2:                      return ValueTuple.CombineHashCodes(EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 3:                      return ValueTuple.CombineHashCodes(EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 4:                      return ValueTuple.CombineHashCodes(EqualityComparer<T4>.Default.GetHashCode(Item4)'                                                         EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 5:                      return ValueTuple.CombineHashCodes(EqualityComparer<T3>.Default.GetHashCode(Item3)'                                                         EqualityComparer<T4>.Default.GetHashCode(Item4)'                                                         EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 6:                      return ValueTuple.CombineHashCodes(EqualityComparer<T2>.Default.GetHashCode(Item2)'                                                         EqualityComparer<T3>.Default.GetHashCode(Item3)'                                                         EqualityComparer<T4>.Default.GetHashCode(Item4)'                                                         EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 7:                  case 8:                      return ValueTuple.CombineHashCodes(EqualityComparer<T1>.Default.GetHashCode(Item1)'                                                         EqualityComparer<T2>.Default.GetHashCode(Item2)'                                                         EqualityComparer<T3>.Default.GetHashCode(Item3)'                                                         EqualityComparer<T4>.Default.GetHashCode(Item4)'                                                         EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());              }
Magic Number,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,GetHashCode,The following statement contains a magic number: switch (k)              {                  case 1:                      return ValueTuple.CombineHashCodes(EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 2:                      return ValueTuple.CombineHashCodes(EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 3:                      return ValueTuple.CombineHashCodes(EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 4:                      return ValueTuple.CombineHashCodes(EqualityComparer<T4>.Default.GetHashCode(Item4)'                                                         EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 5:                      return ValueTuple.CombineHashCodes(EqualityComparer<T3>.Default.GetHashCode(Item3)'                                                         EqualityComparer<T4>.Default.GetHashCode(Item4)'                                                         EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 6:                      return ValueTuple.CombineHashCodes(EqualityComparer<T2>.Default.GetHashCode(Item2)'                                                         EqualityComparer<T3>.Default.GetHashCode(Item3)'                                                         EqualityComparer<T4>.Default.GetHashCode(Item4)'                                                         EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 7:                  case 8:                      return ValueTuple.CombineHashCodes(EqualityComparer<T1>.Default.GetHashCode(Item1)'                                                         EqualityComparer<T2>.Default.GetHashCode(Item2)'                                                         EqualityComparer<T3>.Default.GetHashCode(Item3)'                                                         EqualityComparer<T4>.Default.GetHashCode(Item4)'                                                         EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());              }
Magic Number,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,GetHashCode,The following statement contains a magic number: switch (k)              {                  case 1:                      return ValueTuple.CombineHashCodes(EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 2:                      return ValueTuple.CombineHashCodes(EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 3:                      return ValueTuple.CombineHashCodes(EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 4:                      return ValueTuple.CombineHashCodes(EqualityComparer<T4>.Default.GetHashCode(Item4)'                                                         EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 5:                      return ValueTuple.CombineHashCodes(EqualityComparer<T3>.Default.GetHashCode(Item3)'                                                         EqualityComparer<T4>.Default.GetHashCode(Item4)'                                                         EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 6:                      return ValueTuple.CombineHashCodes(EqualityComparer<T2>.Default.GetHashCode(Item2)'                                                         EqualityComparer<T3>.Default.GetHashCode(Item3)'                                                         EqualityComparer<T4>.Default.GetHashCode(Item4)'                                                         EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 7:                  case 8:                      return ValueTuple.CombineHashCodes(EqualityComparer<T1>.Default.GetHashCode(Item1)'                                                         EqualityComparer<T2>.Default.GetHashCode(Item2)'                                                         EqualityComparer<T3>.Default.GetHashCode(Item3)'                                                         EqualityComparer<T4>.Default.GetHashCode(Item4)'                                                         EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());              }
Magic Number,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,GetHashCode,The following statement contains a magic number: switch (k)              {                  case 1:                      return ValueTuple.CombineHashCodes(EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 2:                      return ValueTuple.CombineHashCodes(EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 3:                      return ValueTuple.CombineHashCodes(EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 4:                      return ValueTuple.CombineHashCodes(EqualityComparer<T4>.Default.GetHashCode(Item4)'                                                         EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 5:                      return ValueTuple.CombineHashCodes(EqualityComparer<T3>.Default.GetHashCode(Item3)'                                                         EqualityComparer<T4>.Default.GetHashCode(Item4)'                                                         EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 6:                      return ValueTuple.CombineHashCodes(EqualityComparer<T2>.Default.GetHashCode(Item2)'                                                         EqualityComparer<T3>.Default.GetHashCode(Item3)'                                                         EqualityComparer<T4>.Default.GetHashCode(Item4)'                                                         EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 7:                  case 8:                      return ValueTuple.CombineHashCodes(EqualityComparer<T1>.Default.GetHashCode(Item1)'                                                         EqualityComparer<T2>.Default.GetHashCode(Item2)'                                                         EqualityComparer<T3>.Default.GetHashCode(Item3)'                                                         EqualityComparer<T4>.Default.GetHashCode(Item4)'                                                         EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());              }
Magic Number,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,GetHashCode,The following statement contains a magic number: switch (k)              {                  case 1:                      return ValueTuple.CombineHashCodes(EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 2:                      return ValueTuple.CombineHashCodes(EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 3:                      return ValueTuple.CombineHashCodes(EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 4:                      return ValueTuple.CombineHashCodes(EqualityComparer<T4>.Default.GetHashCode(Item4)'                                                         EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 5:                      return ValueTuple.CombineHashCodes(EqualityComparer<T3>.Default.GetHashCode(Item3)'                                                         EqualityComparer<T4>.Default.GetHashCode(Item4)'                                                         EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 6:                      return ValueTuple.CombineHashCodes(EqualityComparer<T2>.Default.GetHashCode(Item2)'                                                         EqualityComparer<T3>.Default.GetHashCode(Item3)'                                                         EqualityComparer<T4>.Default.GetHashCode(Item4)'                                                         EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 7:                  case 8:                      return ValueTuple.CombineHashCodes(EqualityComparer<T1>.Default.GetHashCode(Item1)'                                                         EqualityComparer<T2>.Default.GetHashCode(Item2)'                                                         EqualityComparer<T3>.Default.GetHashCode(Item3)'                                                         EqualityComparer<T4>.Default.GetHashCode(Item4)'                                                         EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());              }
Magic Number,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,GetHashCode,The following statement contains a magic number: switch (k)              {                  case 1:                      return ValueTuple.CombineHashCodes(EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 2:                      return ValueTuple.CombineHashCodes(EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 3:                      return ValueTuple.CombineHashCodes(EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 4:                      return ValueTuple.CombineHashCodes(EqualityComparer<T4>.Default.GetHashCode(Item4)'                                                         EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 5:                      return ValueTuple.CombineHashCodes(EqualityComparer<T3>.Default.GetHashCode(Item3)'                                                         EqualityComparer<T4>.Default.GetHashCode(Item4)'                                                         EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 6:                      return ValueTuple.CombineHashCodes(EqualityComparer<T2>.Default.GetHashCode(Item2)'                                                         EqualityComparer<T3>.Default.GetHashCode(Item3)'                                                         EqualityComparer<T4>.Default.GetHashCode(Item4)'                                                         EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 7:                  case 8:                      return ValueTuple.CombineHashCodes(EqualityComparer<T1>.Default.GetHashCode(Item1)'                                                         EqualityComparer<T2>.Default.GetHashCode(Item2)'                                                         EqualityComparer<T3>.Default.GetHashCode(Item3)'                                                         EqualityComparer<T4>.Default.GetHashCode(Item4)'                                                         EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());              }
Magic Number,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,GetHashCodeCore,The following statement contains a magic number: if (size >= 8)              {                  return rest.GetHashCode(comparer);              }
Magic Number,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,GetHashCodeCore,The following statement contains a magic number: var k = 8 - size;
Magic Number,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,GetHashCodeCore,The following statement contains a magic number: switch (k)              {                  case 1:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 2:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 3:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)'                                                         rest.GetHashCode(comparer));                    case 4:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)'                                                         comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 5:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item3)' comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)'                                                         comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 6:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item2)' comparer.GetHashCode(Item3)' comparer.GetHashCode(Item4)'                                                         comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)'                                                         rest.GetHashCode(comparer));                    case 7:                  case 8:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item1)' comparer.GetHashCode(Item2)' comparer.GetHashCode(Item3)'                                                         comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)'                                                         comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));              }
Magic Number,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,GetHashCodeCore,The following statement contains a magic number: switch (k)              {                  case 1:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 2:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 3:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)'                                                         rest.GetHashCode(comparer));                    case 4:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)'                                                         comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 5:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item3)' comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)'                                                         comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 6:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item2)' comparer.GetHashCode(Item3)' comparer.GetHashCode(Item4)'                                                         comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)'                                                         rest.GetHashCode(comparer));                    case 7:                  case 8:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item1)' comparer.GetHashCode(Item2)' comparer.GetHashCode(Item3)'                                                         comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)'                                                         comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));              }
Magic Number,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,GetHashCodeCore,The following statement contains a magic number: switch (k)              {                  case 1:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 2:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 3:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)'                                                         rest.GetHashCode(comparer));                    case 4:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)'                                                         comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 5:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item3)' comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)'                                                         comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 6:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item2)' comparer.GetHashCode(Item3)' comparer.GetHashCode(Item4)'                                                         comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)'                                                         rest.GetHashCode(comparer));                    case 7:                  case 8:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item1)' comparer.GetHashCode(Item2)' comparer.GetHashCode(Item3)'                                                         comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)'                                                         comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));              }
Magic Number,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,GetHashCodeCore,The following statement contains a magic number: switch (k)              {                  case 1:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 2:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 3:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)'                                                         rest.GetHashCode(comparer));                    case 4:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)'                                                         comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 5:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item3)' comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)'                                                         comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 6:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item2)' comparer.GetHashCode(Item3)' comparer.GetHashCode(Item4)'                                                         comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)'                                                         rest.GetHashCode(comparer));                    case 7:                  case 8:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item1)' comparer.GetHashCode(Item2)' comparer.GetHashCode(Item3)'                                                         comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)'                                                         comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));              }
Magic Number,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,GetHashCodeCore,The following statement contains a magic number: switch (k)              {                  case 1:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 2:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 3:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)'                                                         rest.GetHashCode(comparer));                    case 4:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)'                                                         comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 5:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item3)' comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)'                                                         comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 6:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item2)' comparer.GetHashCode(Item3)' comparer.GetHashCode(Item4)'                                                         comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)'                                                         rest.GetHashCode(comparer));                    case 7:                  case 8:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item1)' comparer.GetHashCode(Item2)' comparer.GetHashCode(Item3)'                                                         comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)'                                                         comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));              }
Magic Number,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,GetHashCodeCore,The following statement contains a magic number: switch (k)              {                  case 1:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 2:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 3:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)'                                                         rest.GetHashCode(comparer));                    case 4:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)'                                                         comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 5:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item3)' comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)'                                                         comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 6:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item2)' comparer.GetHashCode(Item3)' comparer.GetHashCode(Item4)'                                                         comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)'                                                         rest.GetHashCode(comparer));                    case 7:                  case 8:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item1)' comparer.GetHashCode(Item2)' comparer.GetHashCode(Item3)'                                                         comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)'                                                         comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));              }
Magic Number,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,GetHashCodeCore,The following statement contains a magic number: switch (k)              {                  case 1:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 2:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 3:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)'                                                         rest.GetHashCode(comparer));                    case 4:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)'                                                         comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 5:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item3)' comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)'                                                         comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 6:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item2)' comparer.GetHashCode(Item3)' comparer.GetHashCode(Item4)'                                                         comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)'                                                         rest.GetHashCode(comparer));                    case 7:                  case 8:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item1)' comparer.GetHashCode(Item2)' comparer.GetHashCode(Item3)'                                                         comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)'                                                         comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));              }
Magic Number,System,Tuple<T1;T2;T3;T4;T5;T6;T7;TRest>,C:\repos\theraot_Theraot\Core\System\Tuple8.net35.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(_item2);
Magic Number,System,Tuple<T1;T2;T3;T4;T5;T6;T7;TRest>,C:\repos\theraot_Theraot\Core\System\Tuple8.net35.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(_item3);
Magic Number,System,Tuple<T1;T2;T3;T4;T5;T6;T7;TRest>,C:\repos\theraot_Theraot\Core\System\Tuple8.net35.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(_item4);
Magic Number,System,Tuple<T1;T2;T3;T4;T5;T6;T7;TRest>,C:\repos\theraot_Theraot\Core\System\Tuple8.net35.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(_item5);
Magic Number,System,Tuple<T1;T2;T3;T4;T5;T6;T7;TRest>,C:\repos\theraot_Theraot\Core\System\Tuple8.net35.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(_item6);
Magic Number,System,Tuple<T1;T2;T3;T4;T5;T6;T7;TRest>,C:\repos\theraot_Theraot\Core\System\Tuple8.net35.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(_item7);
Magic Number,System,Tuple<T1;T2;T3;T4;T5;T6;T7;TRest>,C:\repos\theraot_Theraot\Core\System\Tuple8.net35.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(_rest);
Magic Number,System,Tuple<T1;T2;T3;T4;T5;T6;T7;TRest>,C:\repos\theraot_Theraot\Core\System\Tuple8.net35.cs,ToString,The following statement contains a magic number: return string.Format(CultureInfo.InvariantCulture' "({0}' {1}' {2}' {3}' {4}' {5}' {6}' {7})"' _item1' _item2' _item3' _item4' _item5' _item6' _item7' restString.Substring(1' restString.Length - 2));
Magic Number,System,Tuple<T1;T2;T3;T4;T5;T6;T7>,C:\repos\theraot_Theraot\Core\System\Tuple7.net35.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(_item2);
Magic Number,System,Tuple<T1;T2;T3;T4;T5;T6;T7>,C:\repos\theraot_Theraot\Core\System\Tuple7.net35.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(_item3);
Magic Number,System,Tuple<T1;T2;T3;T4;T5;T6;T7>,C:\repos\theraot_Theraot\Core\System\Tuple7.net35.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(_item4);
Magic Number,System,Tuple<T1;T2;T3;T4;T5;T6;T7>,C:\repos\theraot_Theraot\Core\System\Tuple7.net35.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(_item5);
Magic Number,System,Tuple<T1;T2;T3;T4;T5;T6;T7>,C:\repos\theraot_Theraot\Core\System\Tuple7.net35.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(_item6);
Magic Number,System,Tuple<T1;T2;T3;T4;T5;T6;T7>,C:\repos\theraot_Theraot\Core\System\Tuple7.net35.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(_item7);
Magic Number,System,Tuple<T1;T2;T3;T4;T5;T6>,C:\repos\theraot_Theraot\Core\System\Tuple6.net35.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(_item2);
Magic Number,System,Tuple<T1;T2;T3;T4;T5;T6>,C:\repos\theraot_Theraot\Core\System\Tuple6.net35.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(_item3);
Magic Number,System,Tuple<T1;T2;T3;T4;T5;T6>,C:\repos\theraot_Theraot\Core\System\Tuple6.net35.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(_item4);
Magic Number,System,Tuple<T1;T2;T3;T4;T5;T6>,C:\repos\theraot_Theraot\Core\System\Tuple6.net35.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(_item5);
Magic Number,System,Tuple<T1;T2;T3;T4;T5;T6>,C:\repos\theraot_Theraot\Core\System\Tuple6.net35.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(_item6);
Magic Number,System,Tuple<T1;T2;T3;T4;T5>,C:\repos\theraot_Theraot\Core\System\Tuple5.net35.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(_item2);
Magic Number,System,Tuple<T1;T2;T3;T4;T5>,C:\repos\theraot_Theraot\Core\System\Tuple5.net35.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(_item3);
Magic Number,System,Tuple<T1;T2;T3;T4;T5>,C:\repos\theraot_Theraot\Core\System\Tuple5.net35.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(_item4);
Magic Number,System,Tuple<T1;T2;T3;T4;T5>,C:\repos\theraot_Theraot\Core\System\Tuple5.net35.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(_item5);
Magic Number,System,Tuple<T1;T2;T3>,C:\repos\theraot_Theraot\Core\System\Tuple3.net35.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(_item2);
Magic Number,System,Tuple<T1;T2;T3>,C:\repos\theraot_Theraot\Core\System\Tuple3.net35.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(_item3);
Magic Number,System,Tuple<T1;T2;T3;T4>,C:\repos\theraot_Theraot\Core\System\Tuple4.net35.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(_item2);
Magic Number,System,Tuple<T1;T2;T3;T4>,C:\repos\theraot_Theraot\Core\System\Tuple4.net35.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(_item3);
Magic Number,System,Tuple<T1;T2;T3;T4>,C:\repos\theraot_Theraot\Core\System\Tuple4.net35.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(_item4);
Magic Number,System,Tuple<T1;T2>,C:\repos\theraot_Theraot\Core\System\Tuple2.net35.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(_item2);
Magic Number,System.Threading,Barrier,C:\repos\theraot_Theraot\Core\System\Threading\Barrier.net35.cs,GetCurrentTotal,The following statement contains a magic number: current = (currentTotal & _currentMask) >> 16;
Magic Number,System.Threading,Barrier,C:\repos\theraot_Theraot\Core\System\Threading\Barrier.net35.cs,SetCurrentTotal,The following statement contains a magic number: var newCurrentTotal = (current << 16) | total;
Magic Number,System.Threading,Barrier,C:\repos\theraot_Theraot\Core\System\Threading\Barrier.net35.cs,AddParticipants,The following statement contains a magic number: while (true)              {                  var currentTotal = Volatile.Read(ref _currentTotalCount);                  int total;                  int current;                  bool sense;                  GetCurrentTotal(currentTotal' out current' out total' out sense);                  if (participantCount + total > _maxParticipants) //overflow                  {                      throw new ArgumentOutOfRangeException("participantCount"'                          "Adding participantCount participants would result in the number of participants exceeding the maximum number allowed.");                  }                    if (SetCurrentTotal(currentTotal' current' total + participantCount' sense))                  {                      // Calculating the first phase for that participant' if the current phase already finished return the next phase else return the current phase                      // To know that the current phase is  the sense doesn't match the                      // phase odd even' so that means it didn't yet change the phase count' so currentPhase +1 is returned' otherwise currentPhase is returned                      var currPhase = CurrentPhaseNumber;                      newPhase = (sense != (currPhase % 2 == 0)) ? currPhase + 1 : currPhase;                        // If this participant is going to join the next phase' which means the postPhaseAction is being running' this participants must wait until this done                      // and its event is reset.                      // Without that' if the postPhaseAction takes long time' this means the event that the current participant is going to wait on is still set                      // (FinishPhase didn't reset it yet) so it should wait until it reset                      if (newPhase != currPhase)                      {                          // Wait on the opposite event                          if (sense)                          {                              _oddEvent.Wait();                          }                          else                          {                              _evenEvent.Wait();                          }                      }                        //This else to fix the racing where the current phase has been finished' m_currentPhase has been updated but the events have not been set/reset yet                      // otherwise when this participant calls SignalAndWait it will wait on a set event however all other participants have not arrived yet.                      else                      {                          if (sense && _evenEvent.IsSet)                          {                              _evenEvent.Reset();                          }                          else if (!sense && _oddEvent.IsSet)                          {                              _oddEvent.Reset();                          }                      }                      break;                  }                  spinner.SpinOnce();              }
Magic Number,System.Threading,Barrier,C:\repos\theraot_Theraot\Core\System\Threading\Barrier.net35.cs,SignalAndWait,The following statement contains a magic number: while (true)              {                  currentTotal = Volatile.Read(ref _currentTotalCount);                  GetCurrentTotal(currentTotal' out current' out total' out sense);                  phase = CurrentPhaseNumber;                  // throw if zero participants                  if (total == 0)                  {                      throw new InvalidOperationException("The barrier has no registered participants.");                  }                  // Try to detect if the number of threads for this phase exceeded the total number of participants or not                  // This can be detected if the current is zero which means all participants for that phase has arrived and the phase number is not changed yet                  if (current == 0 && sense != (CurrentPhaseNumber % 2 == 0))                  {                      throw new InvalidOperationException("The number of threads using the barrier exceeded the total number of registered participants.");                  }                  //This is the last thread' finish the phase                  if (current + 1 == total)                  {                      if (SetCurrentTotal(currentTotal' 0' total' !sense))                      {                          FinishPhase(sense);                          return true;                      }                  }                  else if (SetCurrentTotal(currentTotal' current + 1' total' sense))                  {                      break;                  }                    spinner.SpinOnce();              }
Magic Number,System.Threading,Barrier,C:\repos\theraot_Theraot\Core\System\Threading\Barrier.net35.cs,DiscontinuousWait,The following statement contains a magic number: var maxWait = 100;
Magic Number,System.Threading,Barrier,C:\repos\theraot_Theraot\Core\System\Threading\Barrier.net35.cs,DiscontinuousWait,The following statement contains a magic number: const int waitTimeCeiling = 10000;
Magic Number,System.Threading,ManualResetEventSlim,C:\repos\theraot_Theraot\Core\System\Threading\ManualResetEventSlim.net35.cs,ManualResetEventSlim,The following statement contains a magic number: if (spinCount < 0 || spinCount > 2047)              {                  throw new ArgumentOutOfRangeException("spinCount");              }
Magic Number,System.Threading,ManualResetEventSlim,C:\repos\theraot_Theraot\Core\System\Threading\ManualResetEventSlim.net35.cs,GetWaitHandle,The following statement contains a magic number: switch (found)              {                  case -1:                      throw new ObjectDisposedException(GetType().FullName);                  case 0:                      return null;                    case 1:                      // Found 1' another thread is creating the wait handle                      ThreadingHelper.SpinWaitUntil(ref _requested' 2);                      goto default;                  default:                      // Found 2' the wait handle is already created                      // Check if dispose has been called                      return TryGetWaitHandleExtracted();              }
Magic Number,System.Threading,ManualResetEventSlim,C:\repos\theraot_Theraot\Core\System\Threading\ManualResetEventSlim.net35.cs,RetriveWaitHandle,The following statement contains a magic number: switch (found)              {                  case -1:                      throw new ObjectDisposedException(GetType().FullName);                  case 0:                      // Found 0' was set to 1' create the wait handle                      var isSet = Thread.VolatileRead(ref _state) != 0;                      // State may have been set here                      var created = new ManualResetEvent(isSet);                      if (Interlocked.CompareExchange(ref _handle' created' null) != null)                      {                          created.Close();                      }                      Thread.VolatileWrite(ref _requested' 2);                      goto default;                  case 1:                      // Found 1' another thread is creating the wait handle                      ThreadingHelper.SpinWaitUntil(ref _requested' 2);                      goto default;                  default:                      // Found 2' the wait handle is already created                      // Check if dispose has been called                      return TryGetWaitHandleExtracted();              }
Magic Number,System.Threading,ManualResetEventSlim,C:\repos\theraot_Theraot\Core\System\Threading\ManualResetEventSlim.net35.cs,RetriveWaitHandle,The following statement contains a magic number: switch (found)              {                  case -1:                      throw new ObjectDisposedException(GetType().FullName);                  case 0:                      // Found 0' was set to 1' create the wait handle                      var isSet = Thread.VolatileRead(ref _state) != 0;                      // State may have been set here                      var created = new ManualResetEvent(isSet);                      if (Interlocked.CompareExchange(ref _handle' created' null) != null)                      {                          created.Close();                      }                      Thread.VolatileWrite(ref _requested' 2);                      goto default;                  case 1:                      // Found 1' another thread is creating the wait handle                      ThreadingHelper.SpinWaitUntil(ref _requested' 2);                      goto default;                  default:                      // Found 2' the wait handle is already created                      // Check if dispose has been called                      return TryGetWaitHandleExtracted();              }
Magic Number,System.Threading,ManualResetEventSlim,C:\repos\theraot_Theraot\Core\System\Threading\ManualResetEventSlim.net35.cs,TryGetWaitHandleExtracted,The following statement contains a magic number: if (handle != null)              {                  if (Thread.VolatileRead(ref _requested) == 2)                  {                      return handle;                  }                  handle.Close();              }
Magic Number,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,SetCompleted,The following statement contains a magic number: while (true)              {                  var lastValue = Thread.VolatileRead(ref _status);                  if ((preventDoubleExecution && lastValue >= 3) || lastValue == 6)                  {                      return false;                  }                  var tmp = Interlocked.CompareExchange(ref _status' 5' lastValue);                  if (tmp == lastValue)                  {                      return true;                  }                  spinWait.SpinOnce();              }
Magic Number,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,SetCompleted,The following statement contains a magic number: while (true)              {                  var lastValue = Thread.VolatileRead(ref _status);                  if ((preventDoubleExecution && lastValue >= 3) || lastValue == 6)                  {                      return false;                  }                  var tmp = Interlocked.CompareExchange(ref _status' 5' lastValue);                  if (tmp == lastValue)                  {                      return true;                  }                  spinWait.SpinOnce();              }
Magic Number,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,SetCompleted,The following statement contains a magic number: while (true)              {                  var lastValue = Thread.VolatileRead(ref _status);                  if ((preventDoubleExecution && lastValue >= 3) || lastValue == 6)                  {                      return false;                  }                  var tmp = Interlocked.CompareExchange(ref _status' 5' lastValue);                  if (tmp == lastValue)                  {                      return true;                  }                  spinWait.SpinOnce();              }
Magic Number,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,DisregardChild,The following statement contains a magic number: Contract.Assert(Thread.VolatileRead(ref _completionCountdown) >= 2' "Task.DisregardChild(): Expected parent count to be >= 2");
Magic Number,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,SetRunning,The following statement contains a magic number: while (true)              {                  var lastValue = Thread.VolatileRead(ref _status);                  if ((preventDoubleExecution && lastValue >= 3) || lastValue == 6)                  {                      return false;                  }                  var tmp = Interlocked.CompareExchange(ref _status' 3' lastValue);                  if (tmp == lastValue)                  {                      return true;                  }                  spinWait.SpinOnce();              }
Magic Number,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,SetRunning,The following statement contains a magic number: while (true)              {                  var lastValue = Thread.VolatileRead(ref _status);                  if ((preventDoubleExecution && lastValue >= 3) || lastValue == 6)                  {                      return false;                  }                  var tmp = Interlocked.CompareExchange(ref _status' 3' lastValue);                  if (tmp == lastValue)                  {                      return true;                  }                  spinWait.SpinOnce();              }
Magic Number,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,SetRunning,The following statement contains a magic number: while (true)              {                  var lastValue = Thread.VolatileRead(ref _status);                  if ((preventDoubleExecution && lastValue >= 3) || lastValue == 6)                  {                      return false;                  }                  var tmp = Interlocked.CompareExchange(ref _status' 3' lastValue);                  if (tmp == lastValue)                  {                      return true;                  }                  spinWait.SpinOnce();              }
Magic Number,Theraot.Core,IntPtrHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\IntPtrHelper.cs,Add,The following statement contains a magic number: switch (IntPtr.Size)              {                  case 4:                      return new IntPtr(unchecked((int)pointer + offset));                    case 8:                      return new IntPtr(unchecked((long)pointer + offset));                    default:                      throw new NotSupportedException("Not supported platform");              }
Magic Number,Theraot.Core,IntPtrHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\IntPtrHelper.cs,Add,The following statement contains a magic number: switch (IntPtr.Size)              {                  case 4:                      return new IntPtr(unchecked((int)pointer + offset));                    case 8:                      return new IntPtr(unchecked((long)pointer + offset));                    default:                      throw new NotSupportedException("Not supported platform");              }
Magic Number,Theraot.Core,IntPtrHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\IntPtrHelper.cs,Subtract,The following statement contains a magic number: switch (IntPtr.Size)              {                  case 4:                      return new IntPtr(unchecked((int)pointer - offset));                    case 8:                      return new IntPtr(unchecked((long)pointer - offset));                    default:                      throw new NotSupportedException("Not supported platform");              }
Magic Number,Theraot.Core,IntPtrHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\IntPtrHelper.cs,Subtract,The following statement contains a magic number: switch (IntPtr.Size)              {                  case 4:                      return new IntPtr(unchecked((int)pointer - offset));                    case 8:                      return new IntPtr(unchecked((long)pointer - offset));                    default:                      throw new NotSupportedException("Not supported platform");              }
Magic Number,Theraot.Core,UIntPtrHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\IntPtrHelper.cs,Add,The following statement contains a magic number: switch (UIntPtr.Size)              {                  case 4:                      return new UIntPtr(unchecked((uint)((int)pointer + offset)));                    case 8:                      return new UIntPtr(unchecked((ulong)((long)pointer + offset)));                    default:                      throw new NotSupportedException("Not supported platform");              }
Magic Number,Theraot.Core,UIntPtrHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\IntPtrHelper.cs,Add,The following statement contains a magic number: switch (UIntPtr.Size)              {                  case 4:                      return new UIntPtr(unchecked((uint)((int)pointer + offset)));                    case 8:                      return new UIntPtr(unchecked((ulong)((long)pointer + offset)));                    default:                      throw new NotSupportedException("Not supported platform");              }
Magic Number,Theraot.Core,UIntPtrHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\IntPtrHelper.cs,Subtract,The following statement contains a magic number: switch (UIntPtr.Size)              {                  case 4:                      return new UIntPtr(unchecked((uint)((int)pointer - offset)));                    case 8:                      return new UIntPtr(unchecked((ulong)((long)pointer - offset)));                    default:                      throw new NotSupportedException("Not supported platform");              }
Magic Number,Theraot.Core,UIntPtrHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\IntPtrHelper.cs,Subtract,The following statement contains a magic number: switch (UIntPtr.Size)              {                  case 4:                      return new UIntPtr(unchecked((uint)((int)pointer - offset)));                    case 8:                      return new UIntPtr(unchecked((ulong)((long)pointer - offset)));                    default:                      throw new NotSupportedException("Not supported platform");              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BinaryReverse,The following statement contains a magic number: value = ((value & 0xcccccccc) >> 2) | ((value & 0x33333333) << 2);
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BinaryReverse,The following statement contains a magic number: value = ((value & 0xcccccccc) >> 2) | ((value & 0x33333333) << 2);
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BinaryReverse,The following statement contains a magic number: value = ((value & 0xf0f0f0f0) >> 4) | ((value & 0x0f0f0f0f) << 4);
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BinaryReverse,The following statement contains a magic number: value = ((value & 0xf0f0f0f0) >> 4) | ((value & 0x0f0f0f0f) << 4);
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BinaryReverse,The following statement contains a magic number: value = ((value & 0xff00ff00) >> 8) | ((value & 0x00ff00ff) << 8);
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BinaryReverse,The following statement contains a magic number: value = ((value & 0xff00ff00) >> 8) | ((value & 0x00ff00ff) << 8);
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BinaryReverse,The following statement contains a magic number: return (value >> 16) | (value << 16);
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BinaryReverse,The following statement contains a magic number: return (value >> 16) | (value << 16);
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,Bits,The following statement contains a magic number: unchecked              {                  byte check = 1 << 7;                  var log2 = 8;                  var tmp = (byte)value;                  do                  {                      if ((tmp & check) != 0)                      {                          yield return (sbyte)check;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,Bits,The following statement contains a magic number: unchecked              {                  byte check = 1 << 7;                  var log2 = 8;                  var tmp = (byte)value;                  do                  {                      if ((tmp & check) != 0)                      {                          yield return (sbyte)check;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,Bits,The following statement contains a magic number: unchecked              {                  ushort check = 1 << 15;                  var log2 = 16;                  var tmp = (ushort)value;                  do                  {                      if ((tmp & check) != 0)                      {                          yield return (short)check;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,Bits,The following statement contains a magic number: unchecked              {                  ushort check = 1 << 15;                  var log2 = 16;                  var tmp = (ushort)value;                  do                  {                      if ((tmp & check) != 0)                      {                          yield return (short)check;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,Bits,The following statement contains a magic number: unchecked              {                  var check = (uint)1 << 31;                  var log2 = 32;                  var tmp = (uint)value;                  do                  {                      if ((tmp & check) != 0)                      {                          yield return (int)check;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,Bits,The following statement contains a magic number: unchecked              {                  var check = (uint)1 << 31;                  var log2 = 32;                  var tmp = (uint)value;                  do                  {                      if ((tmp & check) != 0)                      {                          yield return (int)check;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,Bits,The following statement contains a magic number: unchecked              {                  var check = (ulong)1 << 63;                  var log2 = 64;                  var tmp = (ulong)value;                  do                  {                      if ((tmp & check) != 0)                      {                          yield return (long)check;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,Bits,The following statement contains a magic number: unchecked              {                  var check = (ulong)1 << 63;                  var log2 = 64;                  var tmp = (ulong)value;                  do                  {                      if ((tmp & check) != 0)                      {                          yield return (long)check;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,Bits,The following statement contains a magic number: unchecked              {                  byte check = 1 << 7;                  var log2 = 8;                  do                  {                      if ((value & check) != 0)                      {                          yield return check;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,Bits,The following statement contains a magic number: unchecked              {                  byte check = 1 << 7;                  var log2 = 8;                  do                  {                      if ((value & check) != 0)                      {                          yield return check;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,Bits,The following statement contains a magic number: unchecked              {                  ushort check = 1 << 15;                  var log2 = 16;                  do                  {                      if ((value & check) != 0)                      {                          yield return check;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,Bits,The following statement contains a magic number: unchecked              {                  ushort check = 1 << 15;                  var log2 = 16;                  do                  {                      if ((value & check) != 0)                      {                          yield return check;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,Bits,The following statement contains a magic number: unchecked              {                  var check = (uint)1 << 31;                  var log2 = 32;                  do                  {                      if ((value & check) != 0)                      {                          yield return check;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,Bits,The following statement contains a magic number: unchecked              {                  var check = (uint)1 << 31;                  var log2 = 32;                  do                  {                      if ((value & check) != 0)                      {                          yield return check;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,Bits,The following statement contains a magic number: unchecked              {                  var check = (ulong)1 << 63;                  var log2 = 64;                  do                  {                      if ((value & check) != 0)                      {                          yield return check;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,Bits,The following statement contains a magic number: unchecked              {                  var check = (ulong)1 << 63;                  var log2 = 64;                  do                  {                      if ((value & check) != 0)                      {                          yield return check;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BitsBinary,The following statement contains a magic number: unchecked              {                  byte check = 1 << 7;                  var log2 = 8;                  var tmp = (byte)value;                  do                  {                      if ((tmp & check) != 0)                      {                          yield return 1;                      }                      else                      {                          yield return 0;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BitsBinary,The following statement contains a magic number: unchecked              {                  byte check = 1 << 7;                  var log2 = 8;                  var tmp = (byte)value;                  do                  {                      if ((tmp & check) != 0)                      {                          yield return 1;                      }                      else                      {                          yield return 0;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BitsBinary,The following statement contains a magic number: unchecked              {                  ushort check = 1 << 15;                  var log2 = 16;                  var tmp = (ushort)value;                  do                  {                      if ((tmp & check) != 0)                      {                          yield return 1;                      }                      else                      {                          yield return 0;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BitsBinary,The following statement contains a magic number: unchecked              {                  ushort check = 1 << 15;                  var log2 = 16;                  var tmp = (ushort)value;                  do                  {                      if ((tmp & check) != 0)                      {                          yield return 1;                      }                      else                      {                          yield return 0;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BitsBinary,The following statement contains a magic number: unchecked              {                  var check = (uint)1 << 31;                  var log2 = 32;                  var tmp = (uint)value;                  do                  {                      if ((tmp & check) != 0)                      {                          yield return 1;                      }                      else                      {                          yield return 0;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BitsBinary,The following statement contains a magic number: unchecked              {                  var check = (uint)1 << 31;                  var log2 = 32;                  var tmp = (uint)value;                  do                  {                      if ((tmp & check) != 0)                      {                          yield return 1;                      }                      else                      {                          yield return 0;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BitsBinary,The following statement contains a magic number: unchecked              {                  var check = (ulong)1 << 63;                  var log2 = 64;                  var tmp = (ulong)value;                  do                  {                      if ((tmp & check) != 0)                      {                          yield return 1;                      }                      else                      {                          yield return 0;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BitsBinary,The following statement contains a magic number: unchecked              {                  var check = (ulong)1 << 63;                  var log2 = 64;                  var tmp = (ulong)value;                  do                  {                      if ((tmp & check) != 0)                      {                          yield return 1;                      }                      else                      {                          yield return 0;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BitsBinary,The following statement contains a magic number: unchecked              {                  byte check = 1 << 7;                  var log2 = 8;                  do                  {                      if ((value & check) != 0)                      {                          yield return 1;                      }                      else                      {                          yield return 0;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BitsBinary,The following statement contains a magic number: unchecked              {                  byte check = 1 << 7;                  var log2 = 8;                  do                  {                      if ((value & check) != 0)                      {                          yield return 1;                      }                      else                      {                          yield return 0;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BitsBinary,The following statement contains a magic number: unchecked              {                  ushort check = 1 << 15;                  var log2 = 16;                  do                  {                      if ((value & check) != 0)                      {                          yield return 1;                      }                      else                      {                          yield return 0;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BitsBinary,The following statement contains a magic number: unchecked              {                  ushort check = 1 << 15;                  var log2 = 16;                  do                  {                      if ((value & check) != 0)                      {                          yield return 1;                      }                      else                      {                          yield return 0;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BitsBinary,The following statement contains a magic number: unchecked              {                  var check = (uint)1 << 31;                  var log2 = 32;                  do                  {                      if ((value & check) != 0)                      {                          yield return 1;                      }                      else                      {                          yield return 0;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BitsBinary,The following statement contains a magic number: unchecked              {                  var check = (uint)1 << 31;                  var log2 = 32;                  do                  {                      if ((value & check) != 0)                      {                          yield return 1;                      }                      else                      {                          yield return 0;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BitsBinary,The following statement contains a magic number: unchecked              {                  var check = (ulong)1 << 63;                  var log2 = 64;                  do                  {                      if ((value & check) != 0)                      {                          yield return 1;                      }                      else                      {                          yield return 0;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BitsBinary,The following statement contains a magic number: unchecked              {                  var check = (ulong)1 << 63;                  var log2 = 64;                  do                  {                      if ((value & check) != 0)                      {                          yield return 1;                      }                      else                      {                          yield return 0;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BitsLog2,The following statement contains a magic number: unchecked              {                  byte check = 1 << 7;                  var log2 = 8;                  var tmp = (byte)value;                  do                  {                      if ((tmp & check) != 0)                      {                          yield return log2 - 1;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BitsLog2,The following statement contains a magic number: unchecked              {                  byte check = 1 << 7;                  var log2 = 8;                  var tmp = (byte)value;                  do                  {                      if ((tmp & check) != 0)                      {                          yield return log2 - 1;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BitsLog2,The following statement contains a magic number: unchecked              {                  ushort check = 1 << 15;                  var log2 = 16;                  var tmp = (ushort)value;                  do                  {                      if ((tmp & check) != 0)                      {                          yield return log2 - 1;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BitsLog2,The following statement contains a magic number: unchecked              {                  ushort check = 1 << 15;                  var log2 = 16;                  var tmp = (ushort)value;                  do                  {                      if ((tmp & check) != 0)                      {                          yield return log2 - 1;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BitsLog2,The following statement contains a magic number: unchecked              {                  var check = (uint)1 << 31;                  var log2 = 32;                  var tmp = (uint)value;                  do                  {                      if ((tmp & check) != 0)                      {                          yield return log2 - 1;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BitsLog2,The following statement contains a magic number: unchecked              {                  var check = (uint)1 << 31;                  var log2 = 32;                  var tmp = (uint)value;                  do                  {                      if ((tmp & check) != 0)                      {                          yield return log2 - 1;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BitsLog2,The following statement contains a magic number: unchecked              {                  var check = (ulong)1 << 63;                  var log2 = 64;                  var tmp = (ulong)value;                  do                  {                      if ((tmp & check) != 0)                      {                          yield return log2 - 1;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BitsLog2,The following statement contains a magic number: unchecked              {                  var check = (ulong)1 << 63;                  var log2 = 64;                  var tmp = (ulong)value;                  do                  {                      if ((tmp & check) != 0)                      {                          yield return log2 - 1;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BitsLog2,The following statement contains a magic number: unchecked              {                  byte check = 1 << 7;                  var log2 = 8;                  do                  {                      if ((value & check) != 0)                      {                          yield return log2 - 1;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BitsLog2,The following statement contains a magic number: unchecked              {                  byte check = 1 << 7;                  var log2 = 8;                  do                  {                      if ((value & check) != 0)                      {                          yield return log2 - 1;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BitsLog2,The following statement contains a magic number: unchecked              {                  ushort check = 1 << 15;                  var log2 = 16;                  do                  {                      if ((value & check) != 0)                      {                          yield return log2 - 1;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BitsLog2,The following statement contains a magic number: unchecked              {                  ushort check = 1 << 15;                  var log2 = 16;                  do                  {                      if ((value & check) != 0)                      {                          yield return log2 - 1;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BitsLog2,The following statement contains a magic number: unchecked              {                  var check = (uint)1 << 31;                  var log2 = 32;                  do                  {                      if ((value & check) != 0)                      {                          yield return log2 - 1;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BitsLog2,The following statement contains a magic number: unchecked              {                  var check = (uint)1 << 31;                  var log2 = 32;                  do                  {                      if ((value & check) != 0)                      {                          yield return log2 - 1;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BitsLog2,The following statement contains a magic number: unchecked              {                  var check = (ulong)1 << 63;                  var log2 = 64;                  do                  {                      if ((value & check) != 0)                      {                          yield return log2 - 1;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BitsLog2,The following statement contains a magic number: unchecked              {                  var check = (ulong)1 << 63;                  var log2 = 64;                  do                  {                      if ((value & check) != 0)                      {                          yield return log2 - 1;                      }                      check >>= 1;                      log2--;                  }                  while (log2 > 0);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,LeadingZeroCount,The following statement contains a magic number: value |= value >> 2;
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,LeadingZeroCount,The following statement contains a magic number: value |= value >> 4;
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,LeadingZeroCount,The following statement contains a magic number: value |= value >> 8;
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,LeadingZeroCount,The following statement contains a magic number: value |= value >> 16;
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,LeadingZeroCount,The following statement contains a magic number: return (sizeof(int) * 8) - PopulationCount(value);
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,LeadingZeroCount,The following statement contains a magic number: value |= value >> 2;
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,LeadingZeroCount,The following statement contains a magic number: value |= value >> 4;
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,LeadingZeroCount,The following statement contains a magic number: value |= value >> 8;
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,LeadingZeroCount,The following statement contains a magic number: value |= value >> 16;
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,LeadingZeroCount,The following statement contains a magic number: value |= value >> 32;
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,LeadingZeroCount,The following statement contains a magic number: return (sizeof(long) * 8) - PopulationCount(value);
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,PopulationCount,The following statement contains a magic number: value = (value & 0x33333333) + ((value >> 2) & 0x33333333);
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,PopulationCount,The following statement contains a magic number: value = (value + (value >> 4)) & 0x0F0F0F0F;
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,PopulationCount,The following statement contains a magic number: value += value >> 8;
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,PopulationCount,The following statement contains a magic number: value += value >> 16;
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,PopulationCount,The following statement contains a magic number: value = (value & 0x3333333333333333UL) + ((value >> 2) & 0x3333333333333333UL);
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,PopulationCount,The following statement contains a magic number: value = (value + (value >> 4)) & 0x0f0f0f0f0f0f0f0fUL;
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,PopulationCount,The following statement contains a magic number: return (int)((value * 0x0101010101010101UL) >> 56);
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BuildInt64,The following statement contains a magic number: return unchecked((long)((ulong)(uint)hi << 32 | (uint)lo));
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BuildInt64,The following statement contains a magic number: return unchecked((long)((ulong)hi << 32 | lo));
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,BuildUInt64,The following statement contains a magic number: return (ulong)hi << 32 | lo;
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,GetDoubleFromParts,The following statement contains a magic number: if (man == 0)              {                  du.Uu = 0;              }              else              {                  // Normalize so that 0x0010 0000 0000 0000 is the highest bit set.                  var cbitShift = CbitHighZero(man) - 11;                  if (cbitShift < 0)                  {                      man >>= -cbitShift;                  }                  else                  {                      man <<= cbitShift;                  }                    exp -= cbitShift;                    // Move the point to just behind the leading 1: 0x001.0 0000 0000 0000                  // (52 bits) and skew the exponent (by 0x3FF == 1023).                  exp += 1075;                    if (exp >= 0x7FF)                  {                      // Infinity.                      du.Uu = 0x7FF0000000000000;                  }                  else if (exp <= 0)                  {                      // Denormalized.                      exp--;                      if (exp < -52)                      {                          // Underflow to zero.                          du.Uu = 0;                      }                      else                      {                          du.Uu = man >> -exp;                      }                  }                  else                  {                      // Mask off the implicit high bit.                      du.Uu = (man & 0x000FFFFFFFFFFFFF) | ((ulong)exp << 52);                  }              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,GetDoubleFromParts,The following statement contains a magic number: if (man == 0)              {                  du.Uu = 0;              }              else              {                  // Normalize so that 0x0010 0000 0000 0000 is the highest bit set.                  var cbitShift = CbitHighZero(man) - 11;                  if (cbitShift < 0)                  {                      man >>= -cbitShift;                  }                  else                  {                      man <<= cbitShift;                  }                    exp -= cbitShift;                    // Move the point to just behind the leading 1: 0x001.0 0000 0000 0000                  // (52 bits) and skew the exponent (by 0x3FF == 1023).                  exp += 1075;                    if (exp >= 0x7FF)                  {                      // Infinity.                      du.Uu = 0x7FF0000000000000;                  }                  else if (exp <= 0)                  {                      // Denormalized.                      exp--;                      if (exp < -52)                      {                          // Underflow to zero.                          du.Uu = 0;                      }                      else                      {                          du.Uu = man >> -exp;                      }                  }                  else                  {                      // Mask off the implicit high bit.                      du.Uu = (man & 0x000FFFFFFFFFFFFF) | ((ulong)exp << 52);                  }              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,GetDoubleFromParts,The following statement contains a magic number: if (man == 0)              {                  du.Uu = 0;              }              else              {                  // Normalize so that 0x0010 0000 0000 0000 is the highest bit set.                  var cbitShift = CbitHighZero(man) - 11;                  if (cbitShift < 0)                  {                      man >>= -cbitShift;                  }                  else                  {                      man <<= cbitShift;                  }                    exp -= cbitShift;                    // Move the point to just behind the leading 1: 0x001.0 0000 0000 0000                  // (52 bits) and skew the exponent (by 0x3FF == 1023).                  exp += 1075;                    if (exp >= 0x7FF)                  {                      // Infinity.                      du.Uu = 0x7FF0000000000000;                  }                  else if (exp <= 0)                  {                      // Denormalized.                      exp--;                      if (exp < -52)                      {                          // Underflow to zero.                          du.Uu = 0;                      }                      else                      {                          du.Uu = man >> -exp;                      }                  }                  else                  {                      // Mask off the implicit high bit.                      du.Uu = (man & 0x000FFFFFFFFFFFFF) | ((ulong)exp << 52);                  }              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,GetDoubleFromParts,The following statement contains a magic number: if (man == 0)              {                  du.Uu = 0;              }              else              {                  // Normalize so that 0x0010 0000 0000 0000 is the highest bit set.                  var cbitShift = CbitHighZero(man) - 11;                  if (cbitShift < 0)                  {                      man >>= -cbitShift;                  }                  else                  {                      man <<= cbitShift;                  }                    exp -= cbitShift;                    // Move the point to just behind the leading 1: 0x001.0 0000 0000 0000                  // (52 bits) and skew the exponent (by 0x3FF == 1023).                  exp += 1075;                    if (exp >= 0x7FF)                  {                      // Infinity.                      du.Uu = 0x7FF0000000000000;                  }                  else if (exp <= 0)                  {                      // Denormalized.                      exp--;                      if (exp < -52)                      {                          // Underflow to zero.                          du.Uu = 0;                      }                      else                      {                          du.Uu = man >> -exp;                      }                  }                  else                  {                      // Mask off the implicit high bit.                      du.Uu = (man & 0x000FFFFFFFFFFFFF) | ((ulong)exp << 52);                  }              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,GetDoubleParts,The following statement contains a magic number: sign = 1 - ((int)(du.Uu >> 62) & 2);
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,GetDoubleParts,The following statement contains a magic number: sign = 1 - ((int)(du.Uu >> 62) & 2);
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,GetDoubleParts,The following statement contains a magic number: exp = (int)(du.Uu >> 52) & 0x7FF;
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,GetDoubleParts,The following statement contains a magic number: if (exp == 0)              {                  // Denormalized number.                  fFinite = true;                  if (man != 0)                  {                      exp = -1074;                  }              }              else if (exp == 0x7FF)              {                  // NaN or Inifite.                  fFinite = false;                  exp = int.MaxValue;              }              else              {                  fFinite = true;                  man |= 0x0010000000000000;                  exp -= 1075;              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,GetDoubleParts,The following statement contains a magic number: if (exp == 0)              {                  // Denormalized number.                  fFinite = true;                  if (man != 0)                  {                      exp = -1074;                  }              }              else if (exp == 0x7FF)              {                  // NaN or Inifite.                  fFinite = false;                  exp = int.MaxValue;              }              else              {                  fFinite = true;                  man |= 0x0010000000000000;                  exp -= 1075;              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,GetParts,The following statement contains a magic number: unchecked              {                  lo = (int)value;                  hi = (int)((ulong)value >> 32);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,GetParts,The following statement contains a magic number: unchecked              {                  lo = (short)value;                  hi = (short)(value >> 16);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,GetParts,The following statement contains a magic number: unchecked              {                  lo = (uint)value;                  hi = (uint)(value >> 32);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,GetParts,The following statement contains a magic number: unchecked              {                  lo = (ushort)value;                  hi = (ushort)(value >> 16);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,GetParts,The following statement contains a magic number: if (value.CompareTo(0.0f) == 0)              {                  sign = 0;                  mantissa = 0;                  exponent = 1;                  finite = true;              }              else              {                  var bits = SingleAsInt32(value);                  sign = (bits < 0) ? -1 : 1;                  exponent = (bits >> 23) & 0xff;                  if (exponent == 2047)                  {                      finite = false;                      mantissa = 0;                  }                  else                  {                      finite = true;                      mantissa = bits & 0xffffff;                      if (exponent == 0)                      {                          // Subnormal numbers; exponent is effectively one higher'                          // but there's no extra normalisation bit in the mantissa                          exponent = 1;                      }                      else                      {                          // Normal numbers; leave exponent as it is but add extra                          // bit to the front of the mantissa                          mantissa |= 1 << 23;                      }                      // Bias the exponent. It's actually biased by 127' but we're                      // treating the mantissa as m.0 rather than 0.m' so we need                      // to subtract another 23 from it.                      exponent -= 150;                      if (mantissa != 0)                      {                          while ((mantissa & 1) == 0)                          {                              mantissa >>= 1;                              exponent++;                          }                      }                  }              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,GetParts,The following statement contains a magic number: if (value.CompareTo(0.0f) == 0)              {                  sign = 0;                  mantissa = 0;                  exponent = 1;                  finite = true;              }              else              {                  var bits = SingleAsInt32(value);                  sign = (bits < 0) ? -1 : 1;                  exponent = (bits >> 23) & 0xff;                  if (exponent == 2047)                  {                      finite = false;                      mantissa = 0;                  }                  else                  {                      finite = true;                      mantissa = bits & 0xffffff;                      if (exponent == 0)                      {                          // Subnormal numbers; exponent is effectively one higher'                          // but there's no extra normalisation bit in the mantissa                          exponent = 1;                      }                      else                      {                          // Normal numbers; leave exponent as it is but add extra                          // bit to the front of the mantissa                          mantissa |= 1 << 23;                      }                      // Bias the exponent. It's actually biased by 127' but we're                      // treating the mantissa as m.0 rather than 0.m' so we need                      // to subtract another 23 from it.                      exponent -= 150;                      if (mantissa != 0)                      {                          while ((mantissa & 1) == 0)                          {                              mantissa >>= 1;                              exponent++;                          }                      }                  }              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,GetParts,The following statement contains a magic number: if (value.CompareTo(0.0f) == 0)              {                  sign = 0;                  mantissa = 0;                  exponent = 1;                  finite = true;              }              else              {                  var bits = SingleAsInt32(value);                  sign = (bits < 0) ? -1 : 1;                  exponent = (bits >> 23) & 0xff;                  if (exponent == 2047)                  {                      finite = false;                      mantissa = 0;                  }                  else                  {                      finite = true;                      mantissa = bits & 0xffffff;                      if (exponent == 0)                      {                          // Subnormal numbers; exponent is effectively one higher'                          // but there's no extra normalisation bit in the mantissa                          exponent = 1;                      }                      else                      {                          // Normal numbers; leave exponent as it is but add extra                          // bit to the front of the mantissa                          mantissa |= 1 << 23;                      }                      // Bias the exponent. It's actually biased by 127' but we're                      // treating the mantissa as m.0 rather than 0.m' so we need                      // to subtract another 23 from it.                      exponent -= 150;                      if (mantissa != 0)                      {                          while ((mantissa & 1) == 0)                          {                              mantissa >>= 1;                              exponent++;                          }                      }                  }              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,GetParts,The following statement contains a magic number: if (value.CompareTo(0.0f) == 0)              {                  sign = 0;                  mantissa = 0;                  exponent = 1;                  finite = true;              }              else              {                  var bits = SingleAsInt32(value);                  sign = (bits < 0) ? -1 : 1;                  exponent = (bits >> 23) & 0xff;                  if (exponent == 2047)                  {                      finite = false;                      mantissa = 0;                  }                  else                  {                      finite = true;                      mantissa = bits & 0xffffff;                      if (exponent == 0)                      {                          // Subnormal numbers; exponent is effectively one higher'                          // but there's no extra normalisation bit in the mantissa                          exponent = 1;                      }                      else                      {                          // Normal numbers; leave exponent as it is but add extra                          // bit to the front of the mantissa                          mantissa |= 1 << 23;                      }                      // Bias the exponent. It's actually biased by 127' but we're                      // treating the mantissa as m.0 rather than 0.m' so we need                      // to subtract another 23 from it.                      exponent -= 150;                      if (mantissa != 0)                      {                          while ((mantissa & 1) == 0)                          {                              mantissa >>= 1;                              exponent++;                          }                      }                  }              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,CbitHighZero,The following statement contains a magic number: if (u == 0)              {                  return 32;              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xFFFF0000) == 0)              {                  cbit += 16;                  u <<= 16;              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xFFFF0000) == 0)              {                  cbit += 16;                  u <<= 16;              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xFF000000) == 0)              {                  cbit += 8;                  u <<= 8;              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xFF000000) == 0)              {                  cbit += 8;                  u <<= 8;              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xF0000000) == 0)              {                  cbit += 4;                  u <<= 4;              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xF0000000) == 0)              {                  cbit += 4;                  u <<= 4;              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xC0000000) == 0)              {                  cbit += 2;                  u <<= 2;              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xC0000000) == 0)              {                  cbit += 2;                  u <<= 2;              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,CbitHighZero,The following statement contains a magic number: if ((uu & 0xFFFFFFFF00000000) == 0)              {                  return 32 + CbitHighZero((uint)uu);              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,CbitHighZero,The following statement contains a magic number: return CbitHighZero((uint)(uu >> 32));
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,CbitLowZero,The following statement contains a magic number: if (u == 0)              {                  return 32;              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,CbitLowZero,The following statement contains a magic number: if ((u & 0x0000FFFF) == 0)              {                  cbit += 16;                  u >>= 16;              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,CbitLowZero,The following statement contains a magic number: if ((u & 0x0000FFFF) == 0)              {                  cbit += 16;                  u >>= 16;              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,CbitLowZero,The following statement contains a magic number: if ((u & 0x000000FF) == 0)              {                  cbit += 8;                  u >>= 8;              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,CbitLowZero,The following statement contains a magic number: if ((u & 0x000000FF) == 0)              {                  cbit += 8;                  u >>= 8;              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,CbitLowZero,The following statement contains a magic number: if ((u & 0x0000000F) == 0)              {                  cbit += 4;                  u >>= 4;              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,CbitLowZero,The following statement contains a magic number: if ((u & 0x0000000F) == 0)              {                  cbit += 4;                  u >>= 4;              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,CbitLowZero,The following statement contains a magic number: if ((u & 0x00000003) == 0)              {                  cbit += 2;                  u >>= 2;              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,CbitLowZero,The following statement contains a magic number: if ((u & 0x00000003) == 0)              {                  cbit += 2;                  u >>= 2;              }
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,GCD,The following statement contains a magic number: const int CvMax = 32;
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,GCD,The following statement contains a magic number: const int CvMax = 32;
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,Log2,The following statement contains a magic number: number |= number >> 2;
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,Log2,The following statement contains a magic number: number |= number >> 4;
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,Log2,The following statement contains a magic number: number |= number >> 8;
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,Log2,The following statement contains a magic number: number |= number >> 16;
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,Log2,The following statement contains a magic number: number |= number >> 2;
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,Log2,The following statement contains a magic number: number |= number >> 4;
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,Log2,The following statement contains a magic number: number |= number >> 8;
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,Log2,The following statement contains a magic number: number |= number >> 16;
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,Log2,The following statement contains a magic number: number |= number >> 32;
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,NextPowerOf2,The following statement contains a magic number: number |= number >> 2;
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,NextPowerOf2,The following statement contains a magic number: number |= number >> 4;
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,NextPowerOf2,The following statement contains a magic number: number |= number >> 8;
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,NextPowerOf2,The following statement contains a magic number: number |= number >> 16;
Magic Number,Theraot.Core,NumericHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\NumericHelper.checks.cs,GetHi,The following statement contains a magic number: return (uint)(uu >> 32);
Magic Number,Theraot.Core,PrimeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\PrimeHelper.array.cs,IsPrime,The following statement contains a magic number: if (number < 0)              {                  return false;              }              else              {                  if (number < _smallPrimes[_smallPrimes.Length - 1])                  {                      return Array.BinarySearch(_smallPrimes' number) >= 0;                  }                  else                  {                      if (number == 2 || number == 3)                      {                          return true;                      }                      if ((number & 1) == 0 || number % 3 == 0)                      {                          return false;                      }                      var max = NumericHelper.Sqrt(number) + 1;                      var index = 2;                      for (; index < _smallPrimes.Length; index++)                      {                          if (number % _smallPrimes[index] == 0)                          {                              return false;                          }                          if (_smallPrimes[index] > max)                          {                              return true;                          }                      }                      var test = index - (index % 6) + 5;                      while (test < max)                      {                          if (number % test == 0 || number % (test += 2) == 0)                          {                              return false;                          }                          test += 4;                      }                      return true;                  }              }
Magic Number,Theraot.Core,PrimeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\PrimeHelper.array.cs,IsPrime,The following statement contains a magic number: if (number < 0)              {                  return false;              }              else              {                  if (number < _smallPrimes[_smallPrimes.Length - 1])                  {                      return Array.BinarySearch(_smallPrimes' number) >= 0;                  }                  else                  {                      if (number == 2 || number == 3)                      {                          return true;                      }                      if ((number & 1) == 0 || number % 3 == 0)                      {                          return false;                      }                      var max = NumericHelper.Sqrt(number) + 1;                      var index = 2;                      for (; index < _smallPrimes.Length; index++)                      {                          if (number % _smallPrimes[index] == 0)                          {                              return false;                          }                          if (_smallPrimes[index] > max)                          {                              return true;                          }                      }                      var test = index - (index % 6) + 5;                      while (test < max)                      {                          if (number % test == 0 || number % (test += 2) == 0)                          {                              return false;                          }                          test += 4;                      }                      return true;                  }              }
Magic Number,Theraot.Core,PrimeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\PrimeHelper.array.cs,IsPrime,The following statement contains a magic number: if (number < 0)              {                  return false;              }              else              {                  if (number < _smallPrimes[_smallPrimes.Length - 1])                  {                      return Array.BinarySearch(_smallPrimes' number) >= 0;                  }                  else                  {                      if (number == 2 || number == 3)                      {                          return true;                      }                      if ((number & 1) == 0 || number % 3 == 0)                      {                          return false;                      }                      var max = NumericHelper.Sqrt(number) + 1;                      var index = 2;                      for (; index < _smallPrimes.Length; index++)                      {                          if (number % _smallPrimes[index] == 0)                          {                              return false;                          }                          if (_smallPrimes[index] > max)                          {                              return true;                          }                      }                      var test = index - (index % 6) + 5;                      while (test < max)                      {                          if (number % test == 0 || number % (test += 2) == 0)                          {                              return false;                          }                          test += 4;                      }                      return true;                  }              }
Magic Number,Theraot.Core,PrimeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\PrimeHelper.array.cs,IsPrime,The following statement contains a magic number: if (number < 0)              {                  return false;              }              else              {                  if (number < _smallPrimes[_smallPrimes.Length - 1])                  {                      return Array.BinarySearch(_smallPrimes' number) >= 0;                  }                  else                  {                      if (number == 2 || number == 3)                      {                          return true;                      }                      if ((number & 1) == 0 || number % 3 == 0)                      {                          return false;                      }                      var max = NumericHelper.Sqrt(number) + 1;                      var index = 2;                      for (; index < _smallPrimes.Length; index++)                      {                          if (number % _smallPrimes[index] == 0)                          {                              return false;                          }                          if (_smallPrimes[index] > max)                          {                              return true;                          }                      }                      var test = index - (index % 6) + 5;                      while (test < max)                      {                          if (number % test == 0 || number % (test += 2) == 0)                          {                              return false;                          }                          test += 4;                      }                      return true;                  }              }
Magic Number,Theraot.Core,PrimeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\PrimeHelper.array.cs,IsPrime,The following statement contains a magic number: if (number < 0)              {                  return false;              }              else              {                  if (number < _smallPrimes[_smallPrimes.Length - 1])                  {                      return Array.BinarySearch(_smallPrimes' number) >= 0;                  }                  else                  {                      if (number == 2 || number == 3)                      {                          return true;                      }                      if ((number & 1) == 0 || number % 3 == 0)                      {                          return false;                      }                      var max = NumericHelper.Sqrt(number) + 1;                      var index = 2;                      for (; index < _smallPrimes.Length; index++)                      {                          if (number % _smallPrimes[index] == 0)                          {                              return false;                          }                          if (_smallPrimes[index] > max)                          {                              return true;                          }                      }                      var test = index - (index % 6) + 5;                      while (test < max)                      {                          if (number % test == 0 || number % (test += 2) == 0)                          {                              return false;                          }                          test += 4;                      }                      return true;                  }              }
Magic Number,Theraot.Core,PrimeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\PrimeHelper.array.cs,IsPrime,The following statement contains a magic number: if (number < 0)              {                  return false;              }              else              {                  if (number < _smallPrimes[_smallPrimes.Length - 1])                  {                      return Array.BinarySearch(_smallPrimes' number) >= 0;                  }                  else                  {                      if (number == 2 || number == 3)                      {                          return true;                      }                      if ((number & 1) == 0 || number % 3 == 0)                      {                          return false;                      }                      var max = NumericHelper.Sqrt(number) + 1;                      var index = 2;                      for (; index < _smallPrimes.Length; index++)                      {                          if (number % _smallPrimes[index] == 0)                          {                              return false;                          }                          if (_smallPrimes[index] > max)                          {                              return true;                          }                      }                      var test = index - (index % 6) + 5;                      while (test < max)                      {                          if (number % test == 0 || number % (test += 2) == 0)                          {                              return false;                          }                          test += 4;                      }                      return true;                  }              }
Magic Number,Theraot.Core,PrimeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\PrimeHelper.array.cs,IsPrime,The following statement contains a magic number: if (number < 0)              {                  return false;              }              else              {                  if (number < _smallPrimes[_smallPrimes.Length - 1])                  {                      return Array.BinarySearch(_smallPrimes' number) >= 0;                  }                  else                  {                      if (number == 2 || number == 3)                      {                          return true;                      }                      if ((number & 1) == 0 || number % 3 == 0)                      {                          return false;                      }                      var max = NumericHelper.Sqrt(number) + 1;                      var index = 2;                      for (; index < _smallPrimes.Length; index++)                      {                          if (number % _smallPrimes[index] == 0)                          {                              return false;                          }                          if (_smallPrimes[index] > max)                          {                              return true;                          }                      }                      var test = index - (index % 6) + 5;                      while (test < max)                      {                          if (number % test == 0 || number % (test += 2) == 0)                          {                              return false;                          }                          test += 4;                      }                      return true;                  }              }
Magic Number,Theraot.Core,PrimeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\PrimeHelper.array.cs,IsPrime,The following statement contains a magic number: if (number < 0)              {                  return false;              }              else              {                  if (number < _smallPrimes[_smallPrimes.Length - 1])                  {                      return Array.BinarySearch(_smallPrimes' number) >= 0;                  }                  else                  {                      if (number == 2 || number == 3)                      {                          return true;                      }                      if ((number & 1) == 0 || number % 3 == 0)                      {                          return false;                      }                      var max = NumericHelper.Sqrt(number) + 1;                      var index = 2;                      for (; index < _smallPrimes.Length; index++)                      {                          if (number % _smallPrimes[index] == 0)                          {                              return false;                          }                          if (_smallPrimes[index] > max)                          {                              return true;                          }                      }                      var test = index - (index % 6) + 5;                      while (test < max)                      {                          if (number % test == 0 || number % (test += 2) == 0)                          {                              return false;                          }                          test += 4;                      }                      return true;                  }              }
Magic Number,Theraot.Core,PrimeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\PrimeHelper.array.cs,NextPrime,The following statement contains a magic number: if (fromNumber < 2)              {                  return 2;              }
Magic Number,Theraot.Core,PrimeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\PrimeHelper.array.cs,NextPrime,The following statement contains a magic number: if (fromNumber < 2)              {                  return 2;              }
Magic Number,Theraot.Core,PrimeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\PrimeHelper.array.cs,NextPrime,The following statement contains a magic number: if (fromNumber >= 2147483629)              {                  throw new OverflowException("2147483629 is the last prime below int.MaxValue");              }              else              {                  fromNumber++;                  return ToPrimeInternal(fromNumber);              }
Magic Number,Theraot.Core,PrimeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\PrimeHelper.array.cs,ToPrime,The following statement contains a magic number: if (fromNumber <= 2)              {                  return 2;              }
Magic Number,Theraot.Core,PrimeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\PrimeHelper.array.cs,ToPrime,The following statement contains a magic number: if (fromNumber <= 2)              {                  return 2;              }
Magic Number,Theraot.Core,PrimeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\PrimeHelper.array.cs,ToPrime,The following statement contains a magic number: if (fromNumber >= 2147483629)              {                  return 2147483629;              }              else              {                  return ToPrimeInternal(fromNumber);              }
Magic Number,Theraot.Core,PrimeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\PrimeHelper.array.cs,ToPrime,The following statement contains a magic number: if (fromNumber >= 2147483629)              {                  return 2147483629;              }              else              {                  return ToPrimeInternal(fromNumber);              }
Magic Number,Theraot.Core,PrimeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\PrimeHelper.array.cs,ToPrimeInternal,The following statement contains a magic number: if (fromNumber < _smallPrimes[_smallPrimes.Length - 1])              {                  var index = Array.BinarySearch(_smallPrimes' fromNumber);                  if (index < 0)                  {                      return _smallPrimes[-index - 1];                  }                  else                  {                      return fromNumber;                  }              }              else              {                  if (fromNumber % 2 == 0)                  {                      fromNumber++;                  }                  for (var index = fromNumber; index < int.MaxValue; index += 2)                  {                      if (IsPrime(index))                      {                          return index;                      }                  }                  return fromNumber;              }
Magic Number,Theraot.Core,PrimeHelper,C:\repos\theraot_Theraot\Core\Theraot\Core\PrimeHelper.array.cs,ToPrimeInternal,The following statement contains a magic number: if (fromNumber < _smallPrimes[_smallPrimes.Length - 1])              {                  var index = Array.BinarySearch(_smallPrimes' fromNumber);                  if (index < 0)                  {                      return _smallPrimes[-index - 1];                  }                  else                  {                      return fromNumber;                  }              }              else              {                  if (fromNumber % 2 == 0)                  {                      fromNumber++;                  }                  for (var index = fromNumber; index < int.MaxValue; index += 2)                  {                      if (IsPrime(index))                      {                          return index;                      }                  }                  return fromNumber;              }
Magic Number,Theraot.Collections,Extensions,C:\repos\theraot_Theraot\Core\Theraot\Collections\Extensions.partition.cs,SortExtracted,The following statement contains a magic number: var pivot = list[low + ((high - low) / 2)];
Magic Number,Theraot.Collections,KeyValuePairEqualityComparer<TKey;TValue>,C:\repos\theraot_Theraot\Core\Theraot\Collections\KeyValuePairEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (_keyComparer.GetHashCode(obj.Key) * 13) + _valueComparer.GetHashCode(obj.Value);
Magic Number,Theraot.Collections,Progressor<T>,C:\repos\theraot_Theraot\Core\Theraot\Collections\Progressor.cs,Progressor,The following statement contains a magic number: _tryTake = (out T value) =>              {                  value = default(T);                  if (Volatile.Read(ref guard) == 0)                  {                      bool result;                      // We need a lock' there is no way around it. IEnumerator is just awful. Use another overload if possible.                      lock (enumerator)                      {                          result = enumerator.MoveNext();                          if (result)                          {                              value = enumerator.Current;                          }                      }                      if (result)                      {                          _proxy.OnNext(value);                          return true;                      }                      enumerator.Dispose();                      Interlocked.CompareExchange(ref guard' 1' 0);                  }                  if (Interlocked.CompareExchange(ref guard' 2' 1) == 1)                  {                      _tryTake = tryTakeReplacement;                      Volatile.Write(ref guard' 3);                  }                  else                  {                      ThreadingHelper.SpinWaitUntil(ref guard' 3);                  }                  var tryTake = _tryTake;                  return tryTake(out value);              };
Magic Number,Theraot.Collections,Progressor<T>,C:\repos\theraot_Theraot\Core\Theraot\Collections\Progressor.cs,Progressor,The following statement contains a magic number: _tryTake = (out T value) =>              {                  value = default(T);                  if (Volatile.Read(ref guard) == 0)                  {                      bool result;                      // We need a lock' there is no way around it. IEnumerator is just awful. Use another overload if possible.                      lock (enumerator)                      {                          result = enumerator.MoveNext();                          if (result)                          {                              value = enumerator.Current;                          }                      }                      if (result)                      {                          _proxy.OnNext(value);                          return true;                      }                      enumerator.Dispose();                      Interlocked.CompareExchange(ref guard' 1' 0);                  }                  if (Interlocked.CompareExchange(ref guard' 2' 1) == 1)                  {                      _tryTake = tryTakeReplacement;                      Volatile.Write(ref guard' 3);                  }                  else                  {                      ThreadingHelper.SpinWaitUntil(ref guard' 3);                  }                  var tryTake = _tryTake;                  return tryTake(out value);              };
Magic Number,Theraot.Collections,Progressor<T>,C:\repos\theraot_Theraot\Core\Theraot\Collections\Progressor.cs,Progressor,The following statement contains a magic number: _tryTake = (out T value) =>              {                  value = default(T);                  if (Volatile.Read(ref guard) == 0)                  {                      bool result;                      // We need a lock' there is no way around it. IEnumerator is just awful. Use another overload if possible.                      lock (enumerator)                      {                          result = enumerator.MoveNext();                          if (result)                          {                              value = enumerator.Current;                          }                      }                      if (result)                      {                          _proxy.OnNext(value);                          return true;                      }                      enumerator.Dispose();                      Interlocked.CompareExchange(ref guard' 1' 0);                  }                  if (Interlocked.CompareExchange(ref guard' 2' 1) == 1)                  {                      _tryTake = tryTakeReplacement;                      Volatile.Write(ref guard' 3);                  }                  else                  {                      ThreadingHelper.SpinWaitUntil(ref guard' 3);                  }                  var tryTake = _tryTake;                  return tryTake(out value);              };
Magic Number,Theraot.Collections,Progressor<T>,C:\repos\theraot_Theraot\Core\Theraot\Collections\Progressor.cs,Progressor,The following statement contains a magic number: _tryTake = (out T value) =>              {                  value = default(T);                  if (Volatile.Read(ref guard) == 0)                  {                      var currentIndex = Interlocked.Increment(ref index);                      if (currentIndex < wrapped.Length)                      {                          value = wrapped[currentIndex];                          _proxy.OnNext(value);                          return true;                      }                      Interlocked.CompareExchange(ref guard' 1' 0);                  }                  if (Interlocked.CompareExchange(ref guard' 2' 1) == 1)                  {                      _tryTake = tryTakeReplacement;                  }                  return false;              };
Magic Number,Theraot.Collections,Progressor<T>,C:\repos\theraot_Theraot\Core\Theraot\Collections\Progressor.cs,Progressor,The following statement contains a magic number: _tryTake = (out T value) =>              {                  if (Volatile.Read(ref guard) == 0)                  {                      var currentIndex = Interlocked.Increment(ref index);                      if (currentIndex < preface.Length)                      {                          value = preface[currentIndex];                          _proxy.OnNext(value);                          return true;                      }                      Interlocked.CompareExchange(ref guard' 1' 0);                  }                  if (Interlocked.CompareExchange(ref guard' 2' 1) == 1)                  {                      _tryTake = tryTakeReplacement;                      Volatile.Write(ref guard' 3);                  }                  else                  {                      ThreadingHelper.SpinWaitUntil(ref guard' 3);                  }                  var tryTake = _tryTake;                  return tryTake(out value);              };
Magic Number,Theraot.Collections,Progressor<T>,C:\repos\theraot_Theraot\Core\Theraot\Collections\Progressor.cs,Progressor,The following statement contains a magic number: _tryTake = (out T value) =>              {                  if (Volatile.Read(ref guard) == 0)                  {                      var currentIndex = Interlocked.Increment(ref index);                      if (currentIndex < preface.Length)                      {                          value = preface[currentIndex];                          _proxy.OnNext(value);                          return true;                      }                      Interlocked.CompareExchange(ref guard' 1' 0);                  }                  if (Interlocked.CompareExchange(ref guard' 2' 1) == 1)                  {                      _tryTake = tryTakeReplacement;                      Volatile.Write(ref guard' 3);                  }                  else                  {                      ThreadingHelper.SpinWaitUntil(ref guard' 3);                  }                  var tryTake = _tryTake;                  return tryTake(out value);              };
Magic Number,Theraot.Collections,Progressor<T>,C:\repos\theraot_Theraot\Core\Theraot\Collections\Progressor.cs,Progressor,The following statement contains a magic number: _tryTake = (out T value) =>              {                  if (Volatile.Read(ref guard) == 0)                  {                      var currentIndex = Interlocked.Increment(ref index);                      if (currentIndex < preface.Length)                      {                          value = preface[currentIndex];                          _proxy.OnNext(value);                          return true;                      }                      Interlocked.CompareExchange(ref guard' 1' 0);                  }                  if (Interlocked.CompareExchange(ref guard' 2' 1) == 1)                  {                      _tryTake = tryTakeReplacement;                      Volatile.Write(ref guard' 3);                  }                  else                  {                      ThreadingHelper.SpinWaitUntil(ref guard' 3);                  }                  var tryTake = _tryTake;                  return tryTake(out value);              };
Magic Number,Theraot.Collections,Progressor<T>,C:\repos\theraot_Theraot\Core\Theraot\Collections\Progressor.cs,Progressor,The following statement contains a magic number: _tryTake = (out T value) =>              {                  value = default(T);                  if (Volatile.Read(ref guard) == 0)                  {                      bool result;                      // We need a lock' there is no way around it. IEnumerator is just awful. Use another overload if possible.                      lock (enumerator)                      {                          result = enumerator.MoveNext();                          if (result)                          {                              value = enumerator.Current;                          }                      }                      if (result)                      {                          _proxy.OnNext(value);                          return true;                      }                      enumerator.Dispose();                      Interlocked.CompareExchange(ref guard' 1' 0);                  }                  if (Interlocked.CompareExchange(ref guard' 2' 1) == 1)                  {                      _tryTake = tryTakeReplacement;                  }                  return false;              };
Magic Number,Theraot.Collections.Specialized,AVLNode,C:\repos\theraot_Theraot\Core\Theraot\Collections\Specialized\AVLTree.AVLNode.cs,MakeBalanced,The following statement contains a magic number: do                  {                      current = node;                      Update(node);                      if (node._balance >= 2)                      {                          if (node._right._balance <= 1)                          {                              DoubleLeft(ref node);                          }                          else                          {                              RotateLeft(ref node);                          }                      }                      else if (node._balance <= -2)                      {                          if (node._left._balance >= 1)                          {                              DoubleRight(ref node);                          }                          else                          {                              RotateRight(ref node);                          }                      }                  } while (node != current);
Magic Number,Theraot.Collections.Specialized,AVLNode,C:\repos\theraot_Theraot\Core\Theraot\Collections\Specialized\AVLTree.AVLNode.cs,MakeBalanced,The following statement contains a magic number: do                  {                      current = node;                      Update(node);                      if (node._balance >= 2)                      {                          if (node._right._balance <= 1)                          {                              DoubleLeft(ref node);                          }                          else                          {                              RotateLeft(ref node);                          }                      }                      else if (node._balance <= -2)                      {                          if (node._left._balance >= 1)                          {                              DoubleRight(ref node);                          }                          else                          {                              RotateRight(ref node);                          }                      }                  } while (node != current);
Magic Number,Theraot.Collections.ThreadSafe,Bucket<T>,C:\repos\theraot_Theraot\Core\Theraot\Collections\ThreadSafe\Bucket.cs,Bucket,The following statement contains a magic number: _bucketCore = new BucketCore(7);
Magic Number,Theraot.Collections.ThreadSafe,Bucket<T>,C:\repos\theraot_Theraot\Core\Theraot\Collections\ThreadSafe\Bucket.cs,Bucket,The following statement contains a magic number: _bucketCore = new BucketCore(7);
Magic Number,Theraot.Collections.ThreadSafe,FixedSizeBucket<T>,C:\repos\theraot_Theraot\Core\Theraot\Collections\ThreadSafe\FixedSizeBucket.cs,FixedSizeBucket,The following statement contains a magic number: _entries = ArrayReservoir<object>.GetArray(collection == null ? 64 : collection.Count);
Magic Number,Theraot.Collections.ThreadSafe,NeedleReservoir<T;TNeedle>,C:\repos\theraot_Theraot\Core\Theraot\Collections\ThreadSafe\NeedleReservoir.cs,NeedleReservoir,The following statement contains a magic number: _pool = new Pool<TNeedle>(64' Recycle);
Magic Number,Theraot.Collections.ThreadSafe,Node,C:\repos\theraot_Theraot\Core\Theraot\Collections\ThreadSafe\SafeQueue.cs,Node,The following statement contains a magic number: Queue = new FixedSizeQueue<T>(64);
Magic Number,Theraot.Collections.ThreadSafe,BucketCore,C:\repos\theraot_Theraot\Core\Theraot\Collections\ThreadSafe\BucketCore.cs,BucketCore,The following statement contains a magic number: if (level < 0 || level > 7)              {                  throw new ArgumentOutOfRangeException("level"' "level < 0 || level > 7");              }
Magic Number,Theraot.Collections.ThreadSafe,BucketCore,C:\repos\theraot_Theraot\Core\Theraot\Collections\ThreadSafe\BucketCore.cs,SubIndex,The following statement contains a magic number: var result = (index >> (5 * (_level - 1))) & 0x1F;
Missing Default,System.Dynamic.Utils,ExpressionUtils,C:\repos\theraot_Theraot\Core\System\Dynamic\Utils\ExpressionUtils.cs,RequiresCanRead,The following switch statement is missing a default case: switch (expression.NodeType)              {  #if !NET35                  case ExpressionType.Index:                      var index = (IndexExpression)expression;                      if (index.Indexer != null && !index.Indexer.CanRead)                      {                          throw new ArgumentException(Strings.ExpressionMustBeReadable' paramName);                      }                      break;  #endif                  case ExpressionType.MemberAccess:                      var member = (MemberExpression)expression;                      var prop = member.Member as PropertyInfo;                      if (prop != null)                      {                          if (!prop.CanRead)                          {                              throw new ArgumentException(Strings.ExpressionMustBeReadable' paramName);                          }                      }                      break;              }
Missing Default,System.Linq.Expressions,Expression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BlockExpression.net30.cs,RequiresCanWrite,The following switch statement is missing a default case: switch (expression.NodeType)              {                  case ExpressionType.Index:                      var index = (IndexExpression)expression;                      if (index.Indexer != null)                      {                          canWrite = index.Indexer.CanWrite;                      }                      else                      {                          canWrite = true;                      }                      break;                    case ExpressionType.MemberAccess:                      var member = (MemberExpression)expression;                      var prop = member.Member as PropertyInfo;                      if (prop != null)                      {                          canWrite = prop.CanWrite;                      }                      else                      {                          var field = member.Member as FieldInfo;                          if (field != null)                          {                              canWrite = !(field.IsInitOnly || field.IsLiteral);                          }                      }                      break;                    case ExpressionType.Parameter:                      canWrite = true;                      break;              }
Missing Default,System.Linq.Expressions,DebugViewWriter,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\DebugViewWriter.net30.cs,Out,The following switch statement is missing a default case: switch (GetFlow(before))              {                  case Flow.None:                      break;                    case Flow.Space:                      Write(" ");                      break;                    case Flow.NewLine:                      WriteLine();                      Write(new string(' '' Depth));                      break;              }
Missing Default,System.Linq.Expressions,DebugViewWriter,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\DebugViewWriter.net30.cs,NeedsParentheses,The following switch statement is missing a default case: switch (parent.NodeType)              {                  case ExpressionType.Increment:                  case ExpressionType.Decrement:                  case ExpressionType.IsTrue:                  case ExpressionType.IsFalse:                  case ExpressionType.Unbox:                      return true;              }
Missing Default,System.Linq.Expressions,DebugViewWriter,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\DebugViewWriter.net30.cs,NeedsParentheses,The following switch statement is missing a default case: switch (parent.NodeType)                  {                      case ExpressionType.AndAlso:                      case ExpressionType.OrElse:                      case ExpressionType.And:                      case ExpressionType.Or:                      case ExpressionType.ExclusiveOr:                          // Since these ops are the only ones on their precedence'                          // the child op must be the same.                          Debug.Assert(child.NodeType == parent.NodeType);                          // We remove the parenthesis' e.g. x && y && z                          return false;                        case ExpressionType.Add:                      case ExpressionType.AddChecked:                      case ExpressionType.Multiply:                      case ExpressionType.MultiplyChecked:                          return false;                        case ExpressionType.Subtract:                      case ExpressionType.SubtractChecked:                      case ExpressionType.Divide:                      case ExpressionType.Modulo:                          var binary = parent as BinaryExpression;                          Debug.Assert(binary != null);                          // Need to have parenthesis for the right operand.                          return child == binary.Right;                  }
Missing Default,System.Linq.Expressions,DebugViewWriter,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\DebugViewWriter.net30.cs,VisitTypeBinary,The following switch statement is missing a default case: switch (node.NodeType)              {                  case ExpressionType.TypeIs:                      Out(Flow.Space' ".Is"' Flow.Space);                      break;                    case ExpressionType.TypeEqual:                      Out(Flow.Space' ".TypeEqual"' Flow.Space);                      break;              }
Missing Default,System.Linq.Expressions,DebugViewWriter,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\DebugViewWriter.net30.cs,VisitUnary,The following switch statement is missing a default case: switch (node.NodeType)              {                  case ExpressionType.Convert:                      Out("(" + node.Type + ")");                      break;                    case ExpressionType.ConvertChecked:                      Out("#(" + node.Type + ")");                      break;                    case ExpressionType.TypeAs:                      break;                    case ExpressionType.Not:                      Out(node.Type == typeof(bool) ? "!" : "~");                      break;                    case ExpressionType.OnesComplement:                      Out("~");                      break;                    case ExpressionType.Negate:                      Out("-");                      break;                    case ExpressionType.NegateChecked:                      Out("#-");                      break;                    case ExpressionType.UnaryPlus:                      Out("+");                      break;                    case ExpressionType.ArrayLength:                      break;                    case ExpressionType.Quote:                      Out("'");                      break;                    case ExpressionType.Throw:                      if (node.Operand == null)                      {                          Out(".Rethrow");                      }                      else                      {                          Out(".Throw"' Flow.Space);                      }                      break;                    case ExpressionType.IsFalse:                      Out(".IsFalse");                      break;                    case ExpressionType.IsTrue:                      Out(".IsTrue");                      break;                    case ExpressionType.Decrement:                      Out(".Decrement");                      break;                    case ExpressionType.Increment:                      Out(".Increment");                      break;                    case ExpressionType.PreDecrementAssign:                      Out("--");                      break;                    case ExpressionType.PreIncrementAssign:                      Out("++");                      break;                    case ExpressionType.Unbox:                      Out(".Unbox");                      break;              }
Missing Default,System.Linq.Expressions,DebugViewWriter,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\DebugViewWriter.net30.cs,VisitUnary,The following switch statement is missing a default case: switch (node.NodeType)              {                  case ExpressionType.TypeAs:                      Out(Flow.Space' ".As"' Flow.Space | Flow.Break);                      Out(node.Type.ToString());                      break;                    case ExpressionType.ArrayLength:                      Out(".Length");                      break;                    case ExpressionType.PostDecrementAssign:                      Out("--");                      break;                    case ExpressionType.PostIncrementAssign:                      Out("++");                      break;              }
Missing Default,System.Linq.Expressions,ExpressionStringBuilder,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\ExpressionStringBuilder.net30.cs,VisitNewArray,The following switch statement is missing a default case: switch (node.NodeType)              {                  case ExpressionType.NewArrayBounds:                      // new MyType[](expr1' expr2)                      Out("new " + node.Type);                      VisitExpressions('('' node.Expressions' ')');                      break;                    case ExpressionType.NewArrayInit:                      // new [] {expr1' expr2}                      Out("new [] ");                      VisitExpressions('{'' node.Expressions' '}');                      break;              }
Missing Default,System.Linq.Expressions,ExpressionStringBuilder,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\ExpressionStringBuilder.net30.cs,VisitTypeBinary,The following switch statement is missing a default case: switch (node.NodeType)              {                  case ExpressionType.TypeIs:                      Out(" Is ");                      break;                    case ExpressionType.TypeEqual:                      Out(" TypeEqual ");                      break;              }
Missing Default,System.Linq.Expressions,BinaryExpression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\BinaryExpression.net30.cs,IsOpAssignment,The following switch statement is missing a default case: switch (op)              {                  case ExpressionType.AddAssign:                  case ExpressionType.SubtractAssign:                  case ExpressionType.MultiplyAssign:                  case ExpressionType.AddAssignChecked:                  case ExpressionType.SubtractAssignChecked:                  case ExpressionType.MultiplyAssignChecked:                  case ExpressionType.DivideAssign:                  case ExpressionType.ModuloAssign:                  case ExpressionType.PowerAssign:                  case ExpressionType.AndAssign:                  case ExpressionType.OrAssign:                  case ExpressionType.RightShiftAssign:                  case ExpressionType.LeftShiftAssign:                  case ExpressionType.ExclusiveOrAssign:                      return true;              }
Missing Default,System.Linq.Expressions,ParameterExpression,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\ParameterExpression.net30.cs,Make,The following switch statement is missing a default case: switch (type.GetTypeCode())                      {                          case TypeCode.Boolean:                              return new PrimitiveParameterExpression<bool>(name);                            case TypeCode.Byte:                              return new PrimitiveParameterExpression<byte>(name);                            case TypeCode.Char:                              return new PrimitiveParameterExpression<char>(name);                            case TypeCode.DateTime:                              return new PrimitiveParameterExpression<DateTime>(name);                            case TypeCode.Decimal:                              return new PrimitiveParameterExpression<decimal>(name);                            case TypeCode.Double:                              return new PrimitiveParameterExpression<double>(name);                            case TypeCode.Int16:                              return new PrimitiveParameterExpression<short>(name);                            case TypeCode.Int32:                              return new PrimitiveParameterExpression<int>(name);                            case TypeCode.Int64:                              return new PrimitiveParameterExpression<long>(name);                            case TypeCode.Object:                              // common reference types which we optimize go here.  Of course object is in                              // the list' the others are driven by profiling of various workloads.  This list                              // should be kept short.                              if (type == typeof(object))                              {                                  return new ParameterExpression(name);                              }                              else if (type == typeof(Exception))                              {                                  return new PrimitiveParameterExpression<Exception>(name);                              }                              else if (type == typeof(object[]))                              {                                  return new PrimitiveParameterExpression<object[]>(name);                              }                              break;                            case TypeCode.SByte:                              return new PrimitiveParameterExpression<sbyte>(name);                            case TypeCode.Single:                              return new PrimitiveParameterExpression<float>(name);                            case TypeCode.String:                              return new PrimitiveParameterExpression<string>(name);                            case TypeCode.UInt16:                              return new PrimitiveParameterExpression<ushort>(name);                            case TypeCode.UInt32:                              return new PrimitiveParameterExpression<uint>(name);                            case TypeCode.UInt64:                              return new PrimitiveParameterExpression<ulong>(name);                      }
Missing Default,System.Linq.Expressions.Compiler,ILGen,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\ILGen.cs,CanEmitILConstant,The following switch statement is missing a default case: switch (type.GetTypeCode())              {                  case TypeCode.Boolean:                  case TypeCode.SByte:                  case TypeCode.Int16:                  case TypeCode.Int32:                  case TypeCode.Int64:                  case TypeCode.Single:                  case TypeCode.Double:                  case TypeCode.Char:                  case TypeCode.Byte:                  case TypeCode.UInt16:                  case TypeCode.UInt32:                  case TypeCode.UInt64:                  case TypeCode.Decimal:                  case TypeCode.String:                      return true;              }
Missing Default,System.Linq.Expressions.Compiler,LambdaCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.net30.cs,EmitAddressWriteBack,The following switch statement is missing a default case: switch (node.NodeType)                  {                      case ExpressionType.MemberAccess:                          result = AddressOfWriteBack((MemberExpression)node);                          break;                        case ExpressionType.Index:                          result = AddressOfWriteBack((IndexExpression)node);                          break;                  }
Missing Default,System.Linq.Expressions.Compiler,LambdaCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.net30.cs,EmitBinaryOperator,The following switch statement is missing a default case: switch (op)              {                  case ExpressionType.ArrayIndex:                      if (rightType != typeof(int))                      {                          throw ContractUtils.Unreachable;                      }                      _ilg.EmitLoadElement(leftType.GetElementType());                      return;                    case ExpressionType.Coalesce:                      throw Error.UnexpectedCoalesceOperator();              }
Missing Default,System.Linq.Expressions.Compiler,LambdaCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.net30.cs,EmitConvertArithmeticResult,The following switch statement is missing a default case: switch (resultType.GetTypeCode())              {                  case TypeCode.Byte:                      _ilg.Emit(IsChecked(op) ? OpCodes.Conv_Ovf_U1 : OpCodes.Conv_U1);                      break;                    case TypeCode.SByte:                      _ilg.Emit(IsChecked(op) ? OpCodes.Conv_Ovf_I1 : OpCodes.Conv_I1);                      break;                    case TypeCode.UInt16:                      _ilg.Emit(IsChecked(op) ? OpCodes.Conv_Ovf_U2 : OpCodes.Conv_U2);                      break;                    case TypeCode.Int16:                      _ilg.Emit(IsChecked(op) ? OpCodes.Conv_Ovf_I2 : OpCodes.Conv_I2);                      break;              }
Missing Default,System.Linq.Expressions.Compiler,LambdaCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.net30.cs,IsChecked,The following switch statement is missing a default case: switch (op)              {                  case ExpressionType.AddChecked:                  case ExpressionType.ConvertChecked:                  case ExpressionType.MultiplyChecked:                  case ExpressionType.NegateChecked:                  case ExpressionType.SubtractChecked:                  case ExpressionType.AddAssignChecked:                  case ExpressionType.MultiplyAssignChecked:                  case ExpressionType.SubtractAssignChecked:                      return true;              }
Missing Default,System.Linq.Expressions.Compiler,LambdaCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.net30.cs,EmitExpressionAndBranch,The following switch statement is missing a default case: switch (node.NodeType)                      {                          case ExpressionType.Not:                              EmitBranchNot(branchValue' (UnaryExpression)node' label);                              return;                            case ExpressionType.AndAlso:                          case ExpressionType.OrElse:                              EmitBranchLogical(branchValue' (BinaryExpression)node' label);                              return;                            case ExpressionType.Block:                              EmitBranchBlock(branchValue' (BlockExpression)node' label);                              return;                            case ExpressionType.Equal:                          case ExpressionType.NotEqual:                              EmitBranchComparison(branchValue' (BinaryExpression)node' label);                              return;                      }
Missing Default,System.Linq.Expressions.Compiler,BindingRewriter,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\StackSpiller.Bindings.net30.cs,Create,The following switch statement is missing a default case: switch (binding.BindingType)                  {                      case MemberBindingType.Assignment:                          var assign = (MemberAssignment)binding;                          return new MemberAssignmentRewriter(assign' spiller' stack);                        case MemberBindingType.ListBinding:                          var list = (MemberListBinding)binding;                          return new ListBindingRewriter(list' spiller' stack);                        case MemberBindingType.MemberBinding:                          var member = (MemberMemberBinding)binding;                          return new MemberMemberBindingRewriter(member' spiller' stack);                  }
Missing Default,System.Linq.Expressions.Compiler,MemberMemberBindingRewriter,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\StackSpiller.Bindings.net30.cs,AsBinding,The following switch statement is missing a default case: switch (RewriteAction)                  {                      case RewriteAction.None:                          return MemberBinding;                        case RewriteAction.Copy:                          var newBindings = new MemberBinding[_bindings.Count];                          for (var i = 0; i < _bindings.Count; i++)                          {                              newBindings[i] = _bindingRewriters[i].AsBinding();                          }                          return Expression.MemberBind(MemberBinding.Member' new TrueReadOnlyCollection<MemberBinding>(newBindings));                  }
Missing Default,System.Linq.Expressions.Compiler,ListBindingRewriter,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\StackSpiller.Bindings.net30.cs,AsBinding,The following switch statement is missing a default case: switch (RewriteAction)                  {                      case RewriteAction.None:                          return MemberBinding;                        case RewriteAction.Copy:                          var newInits = new ElementInit[_inits.Count];                          for (var i = 0; i < _inits.Count; i++)                          {                              var cr = _childRewriters[i];                              if (cr.Action == RewriteAction.None)                              {                                  newInits[i] = _inits[i];                              }                              else                              {                                  newInits[i] = Expression.ElementInit(_inits[i].AddMethod' cr[0' -1]);                              }                          }                          return Expression.ListBind(MemberBinding.Member' new TrueReadOnlyCollection<ElementInit>(newInits));                  }
Missing Default,System.Linq.Expressions.Compiler,MemberAssignmentRewriter,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Compiler\StackSpiller.Bindings.net30.cs,AsBinding,The following switch statement is missing a default case: switch (RewriteAction)                  {                      case RewriteAction.None:                          return MemberBinding;                        case RewriteAction.Copy:                          return Expression.Bind(MemberBinding.Member' _rhs);                  }
Missing Default,System.Linq.Expressions.Interpreter,CallInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\CallInstruction.Generated.net30.cs,GetArrayAccessor,The following switch statement is missing a default case: switch (arrayType.GetArrayRank())              {                  case 1:                      alternativeMethod = isGetter ?                          arrayType.GetMethod("GetValue"' new[] { typeof(int) }) :                          typeof(CallInstruction).GetMethod("ArrayItemSetter1");                      break;                    case 2:                      alternativeMethod = isGetter ?                          arrayType.GetMethod("GetValue"' new[] { typeof(int)' typeof(int) }) :                          typeof(CallInstruction).GetMethod("ArrayItemSetter2");                      break;                    case 3:                      alternativeMethod = isGetter ?                          arrayType.GetMethod("GetValue"' new[] { typeof(int)' typeof(int)' typeof(int) }) :                          typeof(CallInstruction).GetMethod("ArrayItemSetter3");                      break;              }
Missing Default,System.Linq.Expressions.Interpreter,LightCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\LightCompiler.net30.cs,CompileSwitchExpression,The following switch statement is missing a default case: switch (switchType)                      {                          case TypeCode.Int32:                              CompileIntSwitchExpression<int>(node);                              return;                            // the following cases are uncomon'                          // so to avoid numerous unecessary generic                          // instantiations of Dictionary<K' V> and related types                          // in AOT scenarios' we will just use "object" as the key                          // NOTE: this does not actually result in any                          //       extra boxing since both keys and values                          //       are already boxed when we get them                          case TypeCode.Byte:                          case TypeCode.SByte:                          case TypeCode.UInt16:                          case TypeCode.Int16:                          case TypeCode.UInt32:                          case TypeCode.UInt64:                          case TypeCode.Int64:                              CompileIntSwitchExpression<object>(node);                              return;                      }
Missing Default,System.Linq.Expressions.Interpreter,LightCompiler,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\LightCompiler.net30.cs,CompileMemberInit,The following switch statement is missing a default case: switch (binding.BindingType)                  {                      case MemberBindingType.Assignment:                          _instructions.EmitDup();                          CompileMemberAssignment(                              true'                              ((MemberAssignment)binding).Member'                              ((MemberAssignment)binding).Expression                          );                          break;                        case MemberBindingType.ListBinding:                          var memberList = (MemberListBinding)binding;                          _instructions.EmitDup();                          CompileMember(null' memberList.Member);                          CompileListInit(memberList.Initializers);                          _instructions.EmitPop();                          break;                        case MemberBindingType.MemberBinding:                          var memberMember = (MemberMemberBinding)binding;                          _instructions.EmitDup();                          var type = GetMemberType(memberMember.Member);                          if (memberMember.Member is PropertyInfo && type.IsValueType)                          {                              throw new InvalidOperationException("CannotAutoInitializeValueTypeMemberThroughProperty");                          }                            CompileMember(null' memberMember.Member);                          CompileMemberInit(memberMember.Bindings);                          _instructions.EmitPop();                          break;                  }
Missing Default,System.Linq.Expressions.Interpreter,CastInstruction,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\TypeOperations.net30.cs,Create,The following switch statement is missing a default case: switch (t.GetTypeCode())                  {                      case TypeCode.Boolean:                          return _boolean ?? (_boolean = new CastInstructionT<bool>());                        case TypeCode.Byte:                          return _byte ?? (_byte = new CastInstructionT<byte>());                        case TypeCode.Char:                          return _char ?? (_char = new CastInstructionT<char>());                        case TypeCode.DateTime:                          return _dateTime ?? (_dateTime = new CastInstructionT<DateTime>());                        case TypeCode.Decimal:                          return _decimal ?? (_decimal = new CastInstructionT<decimal>());                        case TypeCode.Double:                          return _double ?? (_double = new CastInstructionT<double>());                        case TypeCode.Int16:                          return _int16 ?? (_int16 = new CastInstructionT<short>());                        case TypeCode.Int32:                          return _int32 ?? (_int32 = new CastInstructionT<int>());                        case TypeCode.Int64:                          return _int64 ?? (_int64 = new CastInstructionT<long>());                        case TypeCode.SByte:                          return _sByte ?? (_sByte = new CastInstructionT<sbyte>());                        case TypeCode.Single:                          return _single ?? (_single = new CastInstructionT<float>());                        case TypeCode.String:                          return _string ?? (_string = new CastInstructionT<string>());                        case TypeCode.UInt16:                          return _uInt16 ?? (_uInt16 = new CastInstructionT<ushort>());                        case TypeCode.UInt32:                          return _uInt32 ?? (_uInt32 = new CastInstructionT<uint>());                        case TypeCode.UInt64:                          return _uInt64 ?? (_uInt64 = new CastInstructionT<ulong>());                  }
Missing Default,System.Linq.Expressions.Interpreter,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\Utilities.net30.cs,MakeDelegate,The following switch statement is missing a default case: switch (types.Length)                  {                      case 0:                          return typeof(Action);                        case 1:                          return typeof(Action<>).MakeGenericType(types);                        case 2:                          return typeof(Action<'>).MakeGenericType(types);                        case 3:                          return typeof(Action<''>).MakeGenericType(types);                        case 4:                          return typeof(Action<'''>).MakeGenericType(types);                        case 5:                          return typeof(Action<''''>).MakeGenericType(types);                        case 6:                          return typeof(Action<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Action<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Action<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Action<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Action<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Action<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Action<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Action<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Action<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Action<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Action<'''''''''''''''>).MakeGenericType(types);                  }
Missing Default,System.Linq.Expressions.Interpreter,DelegateHelpers,C:\repos\theraot_Theraot\Core\System\Linq\Expressions\Interpreter\Utilities.net30.cs,MakeDelegate,The following switch statement is missing a default case: switch (types.Length)                  {                      case 1:                          return typeof(Func<>).MakeGenericType(types);                        case 2:                          return typeof(Func<'>).MakeGenericType(types);                        case 3:                          return typeof(Func<''>).MakeGenericType(types);                        case 4:                          return typeof(Func<'''>).MakeGenericType(types);                        case 5:                          return typeof(Func<''''>).MakeGenericType(types);                        case 6:                          return typeof(Func<'''''>).MakeGenericType(types);                        case 7:                          return typeof(Func<''''''>).MakeGenericType(types);                        case 8:                          return typeof(Func<'''''''>).MakeGenericType(types);                        case 9:                          return typeof(Func<''''''''>).MakeGenericType(types);                        case 10:                          return typeof(Func<'''''''''>).MakeGenericType(types);                        case 11:                          return typeof(Func<''''''''''>).MakeGenericType(types);                        case 12:                          return typeof(Func<'''''''''''>).MakeGenericType(types);                        case 13:                          return typeof(Func<''''''''''''>).MakeGenericType(types);                        case 14:                          return typeof(Func<'''''''''''''>).MakeGenericType(types);                        case 15:                          return typeof(Func<''''''''''''''>).MakeGenericType(types);                        case 16:                          return typeof(Func<'''''''''''''''>).MakeGenericType(types);                        case 17:                          return typeof(Func<''''''''''''''''>).MakeGenericType(types);                  }
Missing Default,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetWrap,The following switch statement is missing a default case: switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(" ");                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                          }
Missing Default,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetWrap,The following switch statement is missing a default case: switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(" ");                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                          }
Missing Default,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetWrap,The following switch statement is missing a default case: switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                          }
Missing Default,System.Numerics,BigInteger,C:\repos\theraot_Theraot\Core\System\Numerics\BigInteger.net35.cs,SetWrap,The following switch statement is missing a default case: switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(" ");                                  break;                          }
Missing Default,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,GetHashCode,The following switch statement is missing a default case: switch (k)              {                  case 1:                      return ValueTuple.CombineHashCodes(EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 2:                      return ValueTuple.CombineHashCodes(EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 3:                      return ValueTuple.CombineHashCodes(EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 4:                      return ValueTuple.CombineHashCodes(EqualityComparer<T4>.Default.GetHashCode(Item4)'                                                         EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 5:                      return ValueTuple.CombineHashCodes(EqualityComparer<T3>.Default.GetHashCode(Item3)'                                                         EqualityComparer<T4>.Default.GetHashCode(Item4)'                                                         EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 6:                      return ValueTuple.CombineHashCodes(EqualityComparer<T2>.Default.GetHashCode(Item2)'                                                         EqualityComparer<T3>.Default.GetHashCode(Item3)'                                                         EqualityComparer<T4>.Default.GetHashCode(Item4)'                                                         EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());                    case 7:                  case 8:                      return ValueTuple.CombineHashCodes(EqualityComparer<T1>.Default.GetHashCode(Item1)'                                                         EqualityComparer<T2>.Default.GetHashCode(Item2)'                                                         EqualityComparer<T3>.Default.GetHashCode(Item3)'                                                         EqualityComparer<T4>.Default.GetHashCode(Item4)'                                                         EqualityComparer<T5>.Default.GetHashCode(Item5)'                                                         EqualityComparer<T6>.Default.GetHashCode(Item6)'                                                         EqualityComparer<T7>.Default.GetHashCode(Item7)'                                                         rest.GetHashCode());              }
Missing Default,System,ValueTuple,C:\repos\theraot_Theraot\Core\System\TupleExtensions.net40.cs,GetHashCodeCore,The following switch statement is missing a default case: switch (k)              {                  case 1:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 2:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 3:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)'                                                         rest.GetHashCode(comparer));                    case 4:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)'                                                         comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 5:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item3)' comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)'                                                         comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 6:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item2)' comparer.GetHashCode(Item3)' comparer.GetHashCode(Item4)'                                                         comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)'                                                         rest.GetHashCode(comparer));                    case 7:                  case 8:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item1)' comparer.GetHashCode(Item2)' comparer.GetHashCode(Item3)'                                                         comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)'                                                         comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));              }
Missing Default,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,Wait,The following switch statement is missing a default case: switch (Status)                  {                      case TaskStatus.WaitingForActivation:                          WaitAntecedent(cancellationToken' milliseconds' start);                          ExecutingTaskScheduler.InernalTryExecuteTaskInline(this' true);                          break;                        case TaskStatus.Created:                      case TaskStatus.WaitingToRun:                      case TaskStatus.Running:                      case TaskStatus.WaitingForChildrenToComplete:                          var waitHandle = _waitHandle.Value;                          if (_waitHandle.IsAlive)                          {                              waitHandle.Wait                                  (                                      TimeSpan.FromMilliseconds                                      (                                          milliseconds - ThreadingHelper.Milliseconds(ThreadingHelper.TicksNow() - start)                                      )'                                      cancellationToken                                  );                          }                          break;                        case TaskStatus.RanToCompletion:                          return true;                        case TaskStatus.Canceled:                          ThrowIfExceptional(true);                          return true;                        case TaskStatus.Faulted:                          ThrowIfExceptional(true);                          return true;                  }
Missing Default,System.Threading.Tasks,Task,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\ITaskCompletionAction.cs,PrivateWait,The following switch statement is missing a default case: switch (Status)                  {                      case TaskStatus.WaitingToRun:                          WaitAntecedent(CancellationToken);                          ExecutingTaskScheduler.InernalTryExecuteTaskInline(this' true);                          break;                        case TaskStatus.Created:                      case TaskStatus.WaitingForActivation:                      case TaskStatus.Running:                      case TaskStatus.WaitingForChildrenToComplete:                          var waitHandle = _waitHandle.Value;                          if (_waitHandle.IsAlive)                          {                              waitHandle.Wait(cancellationToken);                          }                          break;                        case TaskStatus.RanToCompletion:                      case TaskStatus.Canceled:                          done = true;                          break;                        case TaskStatus.Faulted:                          if (throwIfExceptional)                          {                              ThrowIfExceptional(true);                          }                          done = true;                          break;                  }
Missing Default,System.Threading.Tasks,TaskExtensions,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\TaskExtensions.net35.cs,TransferAsynchronously,The following switch statement is missing a default case: switch (outer.Status)                      {                          case TaskStatus.Canceled:                          case TaskStatus.Faulted:                              // The outer task has completed as canceled or faulted; transfer that                              // status to the completion source' and we're done.                              result = completionSource.TrySetFromTask(outer);                              break;                            case TaskStatus.RanToCompletion:                              Task inner = outer.Result;                              if (inner == null)                              {                                  // The outer task completed successfully' but with a null inner task;                                  // cancel the completionSource' and we're done.                                  result = completionSource.TrySetCanceled();                              }                              else if (inner.IsCompleted)                              {                                  // The inner task also completed!  Transfer the results' and we're done.                                  result = completionSource.TrySetFromTask(inner);                              }                              else                              {                                  // Run this delegate again once the inner task has completed.                                  inner.ConfigureAwait(false).GetAwaiter().UnsafeOnCompleted(innerCallback);                              }                              break;                      }
Missing Default,System.Threading.Tasks,TaskExtensions,C:\repos\theraot_Theraot\Core\System\Threading\Tasks\TaskExtensions.net35.cs,TrySetFromTask,The following switch statement is missing a default case: switch (task.Status)              {                  case TaskStatus.Canceled:                      result = completionSource.TrySetCanceled(ExtractCancellationToken(task));                      break;                    case TaskStatus.Faulted:                      result = completionSource.TrySetException(task.Exception.InnerExceptions);                      break;                    case TaskStatus.RanToCompletion:                      var resultTask = task as Task<TResult>;                      result = resultTask != null ?                          completionSource.TrySetResult(resultTask.Result) :                          completionSource.TrySetResult(default(TResult));                      break;              }
Missing Default,Theraot.Threading,GCMonitor,C:\repos\theraot_Theraot\Core\Theraot\Threading\GCMonitor.internal.cs,Initialize,The following switch statement is missing a default case: switch (check)              {                  case _statusNotReady:                      GC.KeepAlive(new GCProbe());                      Volatile.Write(ref _status' _statusReady);                      break;                    case _statusPending:                      ThreadingHelper.SpinWaitUntil(ref _status' _statusReady);                      break;              }
