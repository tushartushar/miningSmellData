Implementation smell,Namespace,Class,File,Method,Description
Long Method,System,Lazy<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Lazy.cs,Lazy,The method has 127 lines of code.
Long Method,System.Dynamic,MetaDynamic,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\DynamicObject.cs,BuildCallMethodWithResult,The method has 114 lines of code.
Long Method,System.Dynamic.Utils,DelegateHelpers,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\Utils\DelegateHelpers.cs,CreateObjectArrayDelegate,The method has 108 lines of code.
Long Method,System.Linq.Expressions,DebugViewWriter,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DebugViewWriter.cs,VisitBinary,The method has 157 lines of code.
Long Method,System.Linq.Expressions,DebugViewWriter,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DebugViewWriter.cs,GetOperatorPrecedence,The method has 104 lines of code.
Long Method,System.Linq.Expressions,ExpressionStringBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\ExpressionStringBuilder.cs,VisitBinary,The method has 134 lines of code.
Long Method,System.Linq.Expressions.Compiler,ILGen,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitNumericConversion,The method has 222 lines of code.
Long Method,System.Linq.Expressions.Compiler,LambdaCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.cs,EmitExpression,The method has 160 lines of code.
Long Method,System.Linq.Expressions.Compiler,LambdaCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.cs,EmitLift,The method has 163 lines of code.
Long Method,System.Linq.Expressions.Compiler,LambdaCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.cs,TryEmitHashtableSwitch,The method has 119 lines of code.
Long Method,System.Linq.Expressions.Compiler,LambdaCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.cs,EmitUnaryOperator,The method has 119 lines of code.
Long Method,System.Linq.Expressions.Compiler,StackSpiller,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\StackSpiller.Bindings.cs,RewriteExpression,The method has 160 lines of code.
Long Method,System.Linq.Expressions.Interpreter,LightCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\LightCompiler.cs,CompileBinaryExpression,The method has 185 lines of code.
Long Method,System.Linq.Expressions.Interpreter,LightCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\LightCompiler.cs,CompileNoLabelPush,The method has 153 lines of code.
Long Method,System.Linq.Expressions.Interpreter,LightCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\LightCompiler.cs,CompileTryExpression,The method has 113 lines of code.
Long Method,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,BigInteger,The method has 122 lines of code.
Long Method,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,FormatBigInteger,The method has 173 lines of code.
Long Method,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,ParseNumber,The method has 161 lines of code.
Long Method,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,SetWrap,The method has 190 lines of code.
Long Method,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,LehmerGcd,The method has 178 lines of code.
Long Method,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,ModDivCore,The method has 126 lines of code.
Long Method,System.Threading,Barrier,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Barrier.cs,SignalAndWait,The method has 118 lines of code.
Long Method,System.Threading,ReaderWriterLockSlim,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\ReaderWriterLockSlim.cs,TryEnterWriteLock,The method has 113 lines of code.
Long Method,System.Threading.Tasks,Parallel,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Parallel.cs,ForWorker,The method has 229 lines of code.
Long Method,System.Threading.Tasks,Parallel,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Parallel.cs,ForWorker64,The method has 233 lines of code.
Long Method,System.Threading.Tasks,Parallel,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Parallel.cs,InvokeExtracted,The method has 128 lines of code.
Long Method,System.Threading.Tasks,Parallel,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Parallel.cs,PartitionerForEachWorker,The method has 278 lines of code.
Long Method,Theraot.Reflection,TypeHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\TypeHelper.cs,IsImplicitNumericConversion,The method has 117 lines of code.
Complex Method,System,EnumTheraotExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\EnumTheraotExtensions.cs,HasFlag,Cyclomatic complexity of the method is 12
Complex Method,System,Tuple<T1;T2;T3;T4;T5;T6>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,CompareTo,Cyclomatic complexity of the method is 8
Complex Method,System,Tuple<T1;T2;T3;T4;T5;T6;T7>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,CompareTo,Cyclomatic complexity of the method is 9
Complex Method,System,Tuple<T1;T2;T3;T4;T5;T6;T7;TRest>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,CompareTo,Cyclomatic complexity of the method is 10
Complex Method,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,CompareTo,Cyclomatic complexity of the method is 8
Complex Method,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,GetHashCode,Cyclomatic complexity of the method is 10
Complex Method,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,CompareTo,Cyclomatic complexity of the method is 9
Complex Method,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,GetHashCodeCore,Cyclomatic complexity of the method is 10
Complex Method,System.Collections.Concurrent,BlockingCollection<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Collections\Concurrent\BlockingCollection.cs,AddToAny,Cyclomatic complexity of the method is 11
Complex Method,System.Collections.Concurrent,BlockingCollection<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Collections\Concurrent\BlockingCollection.cs,TakeFromAny,Cyclomatic complexity of the method is 11
Complex Method,System.Collections.Concurrent,BlockingCollection<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Collections\Concurrent\BlockingCollection.cs,TryAddToAny,Cyclomatic complexity of the method is 17
Complex Method,System.Collections.Concurrent,BlockingCollection<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Collections\Concurrent\BlockingCollection.cs,TryTakeFromAny,Cyclomatic complexity of the method is 17
Complex Method,System.Collections,InternalComparer,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Collections\StructuralComparisons.cs,Equals,Cyclomatic complexity of the method is 10
Complex Method,System.Collections.Specialized,NotifyCollectionChangedEventArgs,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Collections\Specialized\NotifyCollectionChangedEventArgs.cs,NotifyCollectionChangedEventArgs,Cyclomatic complexity of the method is 8
Complex Method,System.Dynamic,DynamicMetaObjectBinder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\DynamicMetaObjectBinder.cs,Bind,Cyclomatic complexity of the method is 12
Complex Method,System.Dynamic.Utils,DelegateHelpers,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\Utils\DelegateHelpers.cs,CreateObjectArrayDelegate,Cyclomatic complexity of the method is 12
Complex Method,System.Dynamic.Utils,TypeUtils,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\Utils\TypeUtils.cs,HasReferenceConversionTo,Cyclomatic complexity of the method is 8
Complex Method,System.Dynamic.Utils,TypeUtils,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\Utils\TypeUtils.cs,IsLegalExplicitVariantDelegateConversion,Cyclomatic complexity of the method is 11
Complex Method,System.Dynamic.Utils,TypeUtils,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\Utils\TypeUtils.cs,StrictHasReferenceConversionToInternal,Cyclomatic complexity of the method is 14
Complex Method,System.Linq,Enumerable,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Enumerable.append.cs,Max,Cyclomatic complexity of the method is 13
Complex Method,System.Linq,Enumerable,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Enumerable.append.cs,Max,Cyclomatic complexity of the method is 13
Complex Method,System.Linq,Enumerable,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Enumerable.append.cs,Max,Cyclomatic complexity of the method is 9
Complex Method,System.Linq,Enumerable,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Enumerable.append.cs,Max,Cyclomatic complexity of the method is 8
Complex Method,System.Linq,Enumerable,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Enumerable.append.cs,Max,Cyclomatic complexity of the method is 8
Complex Method,System.Linq,Enumerable,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Enumerable.append.cs,Max,Cyclomatic complexity of the method is 14
Complex Method,System.Linq,Enumerable,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Enumerable.append.cs,Max,Cyclomatic complexity of the method is 14
Complex Method,System.Linq,Enumerable,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Enumerable.append.cs,Min,Cyclomatic complexity of the method is 10
Complex Method,System.Linq,Enumerable,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Enumerable.append.cs,Min,Cyclomatic complexity of the method is 8
Complex Method,System.Linq,Enumerable,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Enumerable.append.cs,Min,Cyclomatic complexity of the method is 8
Complex Method,System.Linq,QueryableTransformer,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\QueryableTransformer.cs,MethodMatch,Cyclomatic complexity of the method is 9
Complex Method,System.Linq.Expressions,BinaryExpression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,GetBinaryOpFromAssignmentOp,Cyclomatic complexity of the method is 15
Complex Method,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,MakeBinary,Cyclomatic complexity of the method is 40
Complex Method,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateUserDefinedConditionalLogicOperator,Cyclomatic complexity of the method is 9
Complex Method,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,BlockCore,Cyclomatic complexity of the method is 8
Complex Method,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,RequiresCanWrite,Cyclomatic complexity of the method is 8
Complex Method,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,IsCompatible,Cyclomatic complexity of the method is 9
Complex Method,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateAccessorArgumentTypes,Cyclomatic complexity of the method is 11
Complex Method,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateIndexedProperty,Cyclomatic complexity of the method is 13
Complex Method,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateLambdaArgs,Cyclomatic complexity of the method is 12
Complex Method,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Property,Cyclomatic complexity of the method is 9
Complex Method,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,CallExtracted,Cyclomatic complexity of the method is 9
Complex Method,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,FindMethod,Cyclomatic complexity of the method is 9
Complex Method,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,NewArrayInitExtracted,Cyclomatic complexity of the method is 8
Complex Method,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateAnonymousTypeMember,Cyclomatic complexity of the method is 8
Complex Method,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateNewArgs,Cyclomatic complexity of the method is 19
Complex Method,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,SwitchExtracted,Cyclomatic complexity of the method is 17
Complex Method,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateTryAndCatchHaveSameType,Cyclomatic complexity of the method is 10
Complex Method,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,MakeUnary,Cyclomatic complexity of the method is 21
Complex Method,System.Linq.Expressions,DebugViewWriter,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DebugViewWriter.cs,VisitBinary,Cyclomatic complexity of the method is 44
Complex Method,System.Linq.Expressions,DebugViewWriter,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DebugViewWriter.cs,VisitUnary,Cyclomatic complexity of the method is 24
Complex Method,System.Linq.Expressions,DebugViewWriter,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DebugViewWriter.cs,GetOperatorPrecedence,Cyclomatic complexity of the method is 16
Complex Method,System.Linq.Expressions,DebugViewWriter,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DebugViewWriter.cs,NeedsParentheses,Cyclomatic complexity of the method is 8
Complex Method,System.Linq.Expressions,DebugViewWriter,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DebugViewWriter.cs,VisitExpressions,Cyclomatic complexity of the method is 9
Complex Method,System.Linq.Expressions,ExpressionStringBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\ExpressionStringBuilder.cs,VisitBinary,Cyclomatic complexity of the method is 34
Complex Method,System.Linq.Expressions,ExpressionStringBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\ExpressionStringBuilder.cs,VisitUnary,Cyclomatic complexity of the method is 23
Complex Method,System.Linq.Expressions,ExpressionTransformer,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\ExpressionTransformer.cs,Visit,Cyclomatic complexity of the method is 15
Complex Method,System.Linq.Expressions,ParameterExpression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\ParameterExpression.cs,Make,Cyclomatic complexity of the method is 22
Complex Method,System.Linq.Expressions.Compiler,BoundConstants,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\BoundConstants.cs,EmitCacheConstants,Cyclomatic complexity of the method is 8
Complex Method,System.Linq.Expressions.Compiler,ILGen,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitDefault,Cyclomatic complexity of the method is 10
Complex Method,System.Linq.Expressions.Compiler,ILGen,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitDefault,Cyclomatic complexity of the method is 9
Complex Method,System.Linq.Expressions.Compiler,ILGen,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitLoadElement,Cyclomatic complexity of the method is 11
Complex Method,System.Linq.Expressions.Compiler,ILGen,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitLoadValueIndirect,Cyclomatic complexity of the method is 11
Complex Method,System.Linq.Expressions.Compiler,ILGen,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitPrimitive,Cyclomatic complexity of the method is 12
Complex Method,System.Linq.Expressions.Compiler,ILGen,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitStoreElement,Cyclomatic complexity of the method is 8
Complex Method,System.Linq.Expressions.Compiler,ILGen,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitStoreValueIndirect,Cyclomatic complexity of the method is 8
Complex Method,System.Linq.Expressions.Compiler,ILGen,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\ILGen.cs,TryEmitConstant,Cyclomatic complexity of the method is 9
Complex Method,System.Linq.Expressions.Compiler,ILGen,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitDecimal,Cyclomatic complexity of the method is 13
Complex Method,System.Linq.Expressions.Compiler,ILGen,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitNumericConversion,Cyclomatic complexity of the method is 42
Complex Method,System.Linq.Expressions.Compiler,ILGen,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\ILGen.cs,TryEmitILConstant,Cyclomatic complexity of the method is 17
Complex Method,System.Linq.Expressions.Compiler,LabelInfo,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LabelInfo.cs,ValidateJump,Cyclomatic complexity of the method is 14
Complex Method,System.Linq.Expressions.Compiler,LambdaCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.cs,EmitAddress,Cyclomatic complexity of the method is 9
Complex Method,System.Linq.Expressions.Compiler,LambdaCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.cs,EmitLiftedBinaryOp,Cyclomatic complexity of the method is 8
Complex Method,System.Linq.Expressions.Compiler,LambdaCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.cs,EmitUnliftedBinaryOp,Cyclomatic complexity of the method is 22
Complex Method,System.Linq.Expressions.Compiler,LambdaCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.cs,GetLabelScopeChangeInfo,Cyclomatic complexity of the method is 15
Complex Method,System.Linq.Expressions.Compiler,LambdaCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.cs,EmitExpression,Cyclomatic complexity of the method is 37
Complex Method,System.Linq.Expressions.Compiler,LambdaCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.cs,EmitExpressionAsVoid,Cyclomatic complexity of the method is 9
Complex Method,System.Linq.Expressions.Compiler,LambdaCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.cs,EmitLift,Cyclomatic complexity of the method is 13
Complex Method,System.Linq.Expressions.Compiler,LambdaCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.cs,EmitSwitchBucket,Cyclomatic complexity of the method is 8
Complex Method,System.Linq.Expressions.Compiler,LambdaCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.cs,EmitTryExpression,Cyclomatic complexity of the method is 10
Complex Method,System.Linq.Expressions.Compiler,LambdaCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.cs,TryEmitHashtableSwitch,Cyclomatic complexity of the method is 9
Complex Method,System.Linq.Expressions.Compiler,LambdaCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.cs,TryEmitSwitchInstruction,Cyclomatic complexity of the method is 8
Complex Method,System.Linq.Expressions.Compiler,LambdaCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.cs,EmitUnaryOperator,Cyclomatic complexity of the method is 21
Complex Method,System.Linq.Expressions.Compiler,StackSpiller,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\StackSpiller.Bindings.cs,RewriteListInitExpression,Cyclomatic complexity of the method is 9
Complex Method,System.Linq.Expressions.Compiler,StackSpiller,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\StackSpiller.Bindings.cs,RewriteMemberInitExpression,Cyclomatic complexity of the method is 8
Complex Method,System.Linq.Expressions.Compiler,StackSpiller,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\StackSpiller.Bindings.cs,RewriteSwitchExpression,Cyclomatic complexity of the method is 12
Complex Method,System.Linq.Expressions.Compiler,StackSpiller,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\StackSpiller.Bindings.cs,RewriteExpression,Cyclomatic complexity of the method is 29
Complex Method,System.Linq.Expressions.Interpreter,AddInstruction,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\AddInstruction.cs,Create,Cyclomatic complexity of the method is 9
Complex Method,System.Linq.Expressions.Interpreter,AndInstruction,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\AndInstruction.cs,Create,Cyclomatic complexity of the method is 10
Complex Method,System.Linq.Expressions.Interpreter,DecrementInstruction,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\DecrementInstruction.cs,Create,Cyclomatic complexity of the method is 9
Complex Method,System.Linq.Expressions.Interpreter,DivInstruction,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\DivInstruction.cs,Create,Cyclomatic complexity of the method is 9
Complex Method,System.Linq.Expressions.Interpreter,EqualInstruction,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\EqualInstruction.cs,Create,Cyclomatic complexity of the method is 25
Complex Method,System.Linq.Expressions.Interpreter,ExclusiveOrInstruction,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\ExclusiveOrInstruction.cs,Create,Cyclomatic complexity of the method is 10
Complex Method,System.Linq.Expressions.Interpreter,GreaterThanInstruction,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\GreaterThanInstruction.cs,Create,Cyclomatic complexity of the method is 24
Complex Method,System.Linq.Expressions.Interpreter,GreaterThanOrEqualInstruction,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\GreaterThanOrEqualInstruction.cs,Create,Cyclomatic complexity of the method is 24
Complex Method,System.Linq.Expressions.Interpreter,IncrementInstruction,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\IncrementInstruction.cs,Create,Cyclomatic complexity of the method is 9
Complex Method,System.Linq.Expressions.Interpreter,InstructionList,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\InstructionList.cs,EmitLoad,Cyclomatic complexity of the method is 9
Complex Method,System.Linq.Expressions.Interpreter,LabelInfo,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\LabelInfo.cs,ValidateJump,Cyclomatic complexity of the method is 12
Complex Method,System.Linq.Expressions.Interpreter,LeftShiftInstruction,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\LeftShiftInstruction.cs,Create,Cyclomatic complexity of the method is 9
Complex Method,System.Linq.Expressions.Interpreter,LessThanInstruction,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\LessThanInstruction.cs,Create,Cyclomatic complexity of the method is 24
Complex Method,System.Linq.Expressions.Interpreter,LessThanOrEqualInstruction,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\LessThanOrEqualInstruction.cs,Create,Cyclomatic complexity of the method is 24
Complex Method,System.Linq.Expressions.Interpreter,LightCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\LightCompiler.cs,GetLabelScopeChangeInfo,Cyclomatic complexity of the method is 14
Complex Method,System.Linq.Expressions.Interpreter,LightCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\LightCompiler.cs,CompileAddress,Cyclomatic complexity of the method is 14
Complex Method,System.Linq.Expressions.Interpreter,LightCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\LightCompiler.cs,CompileArithmetic,Cyclomatic complexity of the method is 9
Complex Method,System.Linq.Expressions.Interpreter,LightCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\LightCompiler.cs,CompileAsVoid,Cyclomatic complexity of the method is 8
Complex Method,System.Linq.Expressions.Interpreter,LightCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\LightCompiler.cs,CompileBinaryExpression,Cyclomatic complexity of the method is 20
Complex Method,System.Linq.Expressions.Interpreter,LightCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\LightCompiler.cs,CompileCoalesceBinaryExpression,Cyclomatic complexity of the method is 9
Complex Method,System.Linq.Expressions.Interpreter,LightCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\LightCompiler.cs,CompileConvertToType,Cyclomatic complexity of the method is 14
Complex Method,System.Linq.Expressions.Interpreter,LightCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\LightCompiler.cs,CompileConvertUnaryExpression,Cyclomatic complexity of the method is 8
Complex Method,System.Linq.Expressions.Interpreter,LightCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\LightCompiler.cs,CompileMember,Cyclomatic complexity of the method is 11
Complex Method,System.Linq.Expressions.Interpreter,LightCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\LightCompiler.cs,CompileMethodCallExpression,Cyclomatic complexity of the method is 9
Complex Method,System.Linq.Expressions.Interpreter,LightCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\LightCompiler.cs,CompileNewExpression,Cyclomatic complexity of the method is 8
Complex Method,System.Linq.Expressions.Interpreter,LightCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\LightCompiler.cs,CompileNoLabelPush,Cyclomatic complexity of the method is 35
Complex Method,System.Linq.Expressions.Interpreter,LightCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\LightCompiler.cs,CompileSwitchExpression,Cyclomatic complexity of the method is 12
Complex Method,System.Linq.Expressions.Interpreter,LightCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\LightCompiler.cs,CompileUnaryExpression,Cyclomatic complexity of the method is 11
Complex Method,System.Linq.Expressions.Interpreter,DebugViewPrinter,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\LightLambda.cs,Analyze,Cyclomatic complexity of the method is 8
Complex Method,System.Linq.Expressions.Interpreter,ModuloInstruction,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\ModuloInstruction.cs,Create,Cyclomatic complexity of the method is 9
Complex Method,System.Linq.Expressions.Interpreter,MulInstruction,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\MulInstruction.cs,Create,Cyclomatic complexity of the method is 9
Complex Method,System.Linq.Expressions.Interpreter,NotEqualInstruction,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\NotEqualInstruction.cs,Create,Cyclomatic complexity of the method is 25
Complex Method,System.Linq.Expressions.Interpreter,NotInstruction,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\NotInstruction.cs,Create,Cyclomatic complexity of the method is 10
Complex Method,System.Linq.Expressions.Interpreter,Checked,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\NumericConvertInstruction.cs,Convert,Cyclomatic complexity of the method is 13
Complex Method,System.Linq.Expressions.Interpreter,ToUnderlying,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\NumericConvertInstruction.cs,Convert,Cyclomatic complexity of the method is 11
Complex Method,System.Linq.Expressions.Interpreter,Unchecked,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\NumericConvertInstruction.cs,Convert,Cyclomatic complexity of the method is 13
Complex Method,System.Linq.Expressions.Interpreter,OrInstruction,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\OrInstruction.cs,Create,Cyclomatic complexity of the method is 10
Complex Method,System.Linq.Expressions.Interpreter,RightShiftInstruction,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\RightShiftInstruction.cs,Create,Cyclomatic complexity of the method is 9
Complex Method,System.Linq.Expressions.Interpreter,SubInstruction,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\SubInstruction.cs,Create,Cyclomatic complexity of the method is 9
Complex Method,System.Linq.Expressions.Interpreter,CastInstruction,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\TypeOperations.cs,Create,Cyclomatic complexity of the method is 16
Complex Method,System.Linq.Expressions.Interpreter,CastReferenceToEnumInstruction,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\TypeOperations.cs,Run,Cyclomatic complexity of the method is 10
Complex Method,System.Linq.Expressions.Interpreter,ScriptingRuntimeHelpers,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\Utilities.cs,GetPrimitiveDefaultValue,Cyclomatic complexity of the method is 16
Complex Method,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,BigInteger,Cyclomatic complexity of the method is 20
Complex Method,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,BigInteger,Cyclomatic complexity of the method is 14
Complex Method,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,Log,Cyclomatic complexity of the method is 8
Complex Method,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,Pow,Cyclomatic complexity of the method is 17
Complex Method,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,CompareTo,Cyclomatic complexity of the method is 8
Complex Method,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,ToByteArray,Cyclomatic complexity of the method is 9
Complex Method,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,SetBitsFromDouble,Cyclomatic complexity of the method is 10
Complex Method,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,FormatBigInteger,Cyclomatic complexity of the method is 25
Complex Method,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,ParseNumber,Cyclomatic complexity of the method is 28
Complex Method,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,CreateBuilder,Cyclomatic complexity of the method is 11
Complex Method,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,NumberToBigInteger,Cyclomatic complexity of the method is 9
Complex Method,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,SetWrap,Cyclomatic complexity of the method is 42
Complex Method,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,StringWithGroups,Cyclomatic complexity of the method is 11
Complex Method,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,Mul,Cyclomatic complexity of the method is 11
Complex Method,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,Mul,Cyclomatic complexity of the method is 9
Complex Method,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,ShiftLeft,Cyclomatic complexity of the method is 11
Complex Method,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,ShiftRight,Cyclomatic complexity of the method is 8
Complex Method,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,Sub,Cyclomatic complexity of the method is 12
Complex Method,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,GetIntegerParts,Cyclomatic complexity of the method is 10
Complex Method,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,LehmerGcd,Cyclomatic complexity of the method is 29
Complex Method,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,ModDivCore,Cyclomatic complexity of the method is 23
Complex Method,System.Threading,Barrier,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Barrier.cs,AddParticipants,Cyclomatic complexity of the method is 11
Complex Method,System.Threading,Barrier,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Barrier.cs,RemoveParticipants,Cyclomatic complexity of the method is 9
Complex Method,System.Threading,Barrier,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Barrier.cs,SignalAndWait,Cyclomatic complexity of the method is 15
Complex Method,System.Threading,ManualResetEventSlim,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\ManualResetEventSlim.cs,Reset,Cyclomatic complexity of the method is 11
Complex Method,System.Threading,ManualResetEventSlim,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\ManualResetEventSlim.cs,Set,Cyclomatic complexity of the method is 11
Complex Method,System.Threading,ManualResetEventSlim,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\ManualResetEventSlim.cs,GetOrCreateWaitHandle,Cyclomatic complexity of the method is 10
Complex Method,System.Threading,SemaphoreSlim,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\SemaphoreSlim.cs,Wait,Cyclomatic complexity of the method is 9
Complex Method,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,FinishContinuations,Cyclomatic complexity of the method is 10
Complex Method,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,RetrieveContinuations,Cyclomatic complexity of the method is 8
Complex Method,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,Task,Cyclomatic complexity of the method is 9
Complex Method,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,PrivateWait,Cyclomatic complexity of the method is 8
Complex Method,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,WaitAll,Cyclomatic complexity of the method is 16
Complex Method,System.Threading.Tasks,WhenAllPromise,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,PrivateDone,Cyclomatic complexity of the method is 8
Complex Method,System.Threading.Tasks,WhenAllPromise<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,PrivateDone,Cyclomatic complexity of the method is 9
Complex Method,System.Threading.Tasks,TaskExceptionHolder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskExceptionHolder.cs,AddFaultException,Cyclomatic complexity of the method is 11
Complex Method,Theraot.Core,PathHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\PathHelper.cs,Combine,Cyclomatic complexity of the method is 10
Complex Method,Theraot.Core,StringProcessor,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\StringProcessor.cs,SkipUntil,Cyclomatic complexity of the method is 8
Complex Method,Theraot.Core,StringProcessor,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\StringProcessor.cs,SkipUntil,Cyclomatic complexity of the method is 8
Complex Method,System.Threading.Tasks.Sources,ManualResetValueTaskSourceCore,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Sources\ManualResetValueTaskSourceCore.cs,OnCompleted,Cyclomatic complexity of the method is 12
Complex Method,Theraot.Collections.Specialized,AVLNode<TKey;TValue>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\Specialized\AVLNode.cs,EnumerateFrom,Cyclomatic complexity of the method is 8
Complex Method,Theraot.Collections.ThreadSafe,BucketHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\ThreadSafe\BucketHelper.cs,InsertOrUpdateChecked,Cyclomatic complexity of the method is 8
Complex Method,Theraot.Reflection,DelegateBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\DelegateBuilder.cs,BuildDelegate,Cyclomatic complexity of the method is 8
Complex Method,Theraot.Reflection,DelegateBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\DelegateBuilder.cs,GetActionType,Cyclomatic complexity of the method is 19
Complex Method,Theraot.Reflection,DelegateBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\DelegateBuilder.cs,GetFuncType,Cyclomatic complexity of the method is 19
Complex Method,Theraot.Reflection,TypeHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\TypeHelper.cs,IsImplicitNumericConversion,Cyclomatic complexity of the method is 18
Long Parameter List,System,ArrayEx,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ArrayEx.cs,Copy,The method has 5 parameters. Parameters: sourceArray' sourceIndex' destinationArray' destinationIndex' length
Long Parameter List,System,HashCode,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\HashCode.cs,Combine,The method has 5 parameters. Parameters: value1' value2' value3' value4' value5
Long Parameter List,System,HashCode,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\HashCode.cs,Combine,The method has 6 parameters. Parameters: value1' value2' value3' value4' value5' value6
Long Parameter List,System,HashCode,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\HashCode.cs,Combine,The method has 7 parameters. Parameters: value1' value2' value3' value4' value5' value6' value7
Long Parameter List,System,HashCode,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\HashCode.cs,Combine,The method has 8 parameters. Parameters: value1' value2' value3' value4' value5' value6' value7' value8
Long Parameter List,System,StringEx,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\StringEx.cs,Implode,The method has 5 parameters. Parameters: separator' values' converter' start' end
Long Parameter List,System,StringEx,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\StringEx.cs,ImplodeExtractedExtracted,The method has 5 parameters. Parameters: separator' array' startIndex' maxIndex' length
Long Parameter List,System,Tuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,Create,The method has 5 parameters. Parameters: item1' item2' item3' item4' item5
Long Parameter List,System,Tuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,Create,The method has 6 parameters. Parameters: item1' item2' item3' item4' item5' item6
Long Parameter List,System,Tuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,Create,The method has 7 parameters. Parameters: item1' item2' item3' item4' item5' item6' item7
Long Parameter List,System,Tuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,Create,The method has 8 parameters. Parameters: item1' item2' item3' item4' item5' item6' item7' item8
Long Parameter List,System,Tuple<T1;T2;T3;T4;T5>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,Tuple,The method has 5 parameters. Parameters: item1' item2' item3' item4' item5
Long Parameter List,System,Tuple<T1;T2;T3;T4;T5;T6>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,Tuple,The method has 6 parameters. Parameters: item1' item2' item3' item4' item5' item6
Long Parameter List,System,Tuple<T1;T2;T3;T4;T5;T6;T7>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,Tuple,The method has 7 parameters. Parameters: item1' item2' item3' item4' item5' item6' item7
Long Parameter List,System,Tuple<T1;T2;T3;T4;T5;T6;T7;TRest>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,Tuple,The method has 8 parameters. Parameters: item1' item2' item3' item4' item5' item6' item7' rest
Long Parameter List,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,Deconstruct,The method has 5 parameters. Parameters: value' item1' item2' item3' item4
Long Parameter List,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,Deconstruct,The method has 6 parameters. Parameters: value' item1' item2' item3' item4' item5
Long Parameter List,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,Deconstruct,The method has 7 parameters. Parameters: value' item1' item2' item3' item4' item5' item6
Long Parameter List,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,Deconstruct,The method has 8 parameters. Parameters: value' item1' item2' item3' item4' item5' item6' item7
Long Parameter List,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,Deconstruct,The method has 9 parameters. Parameters: value' item1' item2' item3' item4' item5' item6' item7' item8
Long Parameter List,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,Deconstruct,The method has 10 parameters. Parameters: value' item1' item2' item3' item4' item5' item6' item7' item8' item9
Long Parameter List,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,Deconstruct,The method has 11 parameters. Parameters: value' item1' item2' item3' item4' item5' item6' item7' item8' item9' item10
Long Parameter List,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,Deconstruct,The method has 12 parameters. Parameters: value' item1' item2' item3' item4' item5' item6' item7' item8' item9' item10' item11
Long Parameter List,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,Deconstruct,The method has 13 parameters. Parameters: value' item1' item2' item3' item4' item5' item6' item7' item8' item9' item10' item11' item12
Long Parameter List,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,Deconstruct,The method has 14 parameters. Parameters: value' item1' item2' item3' item4' item5' item6' item7' item8' item9' item10' item11' item12' item13
Long Parameter List,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,Deconstruct,The method has 15 parameters. Parameters: value' item1' item2' item3' item4' item5' item6' item7' item8' item9' item10' item11' item12' item13' item14
Long Parameter List,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,Deconstruct,The method has 16 parameters. Parameters: value' item1' item2' item3' item4' item5' item6' item7' item8' item9' item10' item11' item12' item13' item14' item15
Long Parameter List,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,Deconstruct,The method has 17 parameters. Parameters: value' item1' item2' item3' item4' item5' item6' item7' item8' item9' item10' item11' item12' item13' item14' item15' item16
Long Parameter List,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,Deconstruct,The method has 18 parameters. Parameters: value' item1' item2' item3' item4' item5' item6' item7' item8' item9' item10' item11' item12' item13' item14' item15' item16' item17
Long Parameter List,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,Deconstruct,The method has 19 parameters. Parameters: value' item1' item2' item3' item4' item5' item6' item7' item8' item9' item10' item11' item12' item13' item14' item15' item16' item17' item18
Long Parameter List,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,Deconstruct,The method has 20 parameters. Parameters: value' item1' item2' item3' item4' item5' item6' item7' item8' item9' item10' item11' item12' item13' item14' item15' item16' item17' item18' item19
Long Parameter List,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,Deconstruct,The method has 21 parameters. Parameters: value' item1' item2' item3' item4' item5' item6' item7' item8' item9' item10' item11' item12' item13' item14' item15' item16' item17' item18' item19' item20
Long Parameter List,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,Deconstruct,The method has 22 parameters. Parameters: value' item1' item2' item3' item4' item5' item6' item7' item8' item9' item10' item11' item12' item13' item14' item15' item16' item17' item18' item19' item20' item21
Long Parameter List,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,CreateLong,The method has 8 parameters. Parameters: item1' item2' item3' item4' item5' item6' item7' rest
Long Parameter List,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,CreateLongRef,The method has 8 parameters. Parameters: item1' item2' item3' item4' item5' item6' item7' rest
Long Parameter List,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,Create,The method has 5 parameters. Parameters: item1' item2' item3' item4' item5
Long Parameter List,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,Create,The method has 6 parameters. Parameters: item1' item2' item3' item4' item5' item6
Long Parameter List,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,Create,The method has 7 parameters. Parameters: item1' item2' item3' item4' item5' item6' item7
Long Parameter List,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,Create,The method has 8 parameters. Parameters: item1' item2' item3' item4' item5' item6' item7' item8
Long Parameter List,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,CombineHashCodes,The method has 5 parameters. Parameters: h1' h2' h3' h4' h5
Long Parameter List,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,CombineHashCodes,The method has 6 parameters. Parameters: h1' h2' h3' h4' h5' h6
Long Parameter List,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,CombineHashCodes,The method has 7 parameters. Parameters: h1' h2' h3' h4' h5' h6' h7
Long Parameter List,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,CombineHashCodes,The method has 8 parameters. Parameters: h1' h2' h3' h4' h5' h6' h7' h8
Long Parameter List,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,ValueTuple,The method has 5 parameters. Parameters: item1' item2' item3' item4' item5
Long Parameter List,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,ValueTuple,The method has 6 parameters. Parameters: item1' item2' item3' item4' item5' item6
Long Parameter List,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,ValueTuple,The method has 7 parameters. Parameters: item1' item2' item3' item4' item5' item6' item7
Long Parameter List,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,ValueTuple,The method has 8 parameters. Parameters: item1' item2' item3' item4' item5' item6' item7' rest
Long Parameter List,System.Diagnostics.Contracts,ContractException,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Diagnostics\Contracts\ContractException.cs,ContractException,The method has 5 parameters. Parameters: kind' failure' userMessage' condition' innerException
Long Parameter List,System.Diagnostics.Contracts.Internal,ContractHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Diagnostics\Contracts\Internal\ContractHelper.cs,TriggerFailure,The method has 5 parameters. Parameters: kind' displayMessage' userMessage' conditionText' innerException
Long Parameter List,System.Dynamic,MetaDynamic,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\DynamicObject.cs,BuildCallMethodWithResult,The method has 5 parameters. Parameters: method' binder' args' fallbackResult' fallbackInvoke
Long Parameter List,System.Dynamic,MetaDynamic,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\DynamicObject.cs,CallMethodReturnLast,The method has 5 parameters. Parameters: method' binder' args' value' fallback
Long Parameter List,System.Dynamic,MetaDynamic,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\DynamicObject.cs,CallMethodWithResult,The method has 5 parameters. Parameters: method' binder' args' fallback' fallbackInvoke
Long Parameter List,System.Dynamic,ExpandoObject,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\ExpandoObject.cs,TryDeleteValue,The method has 5 parameters. Parameters: indexClass' index' name' ignoreCase' deleteValue
Long Parameter List,System.Dynamic,ExpandoObject,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\ExpandoObject.cs,TryGetValue,The method has 5 parameters. Parameters: indexClass' index' name' ignoreCase' value
Long Parameter List,System.Dynamic,ExpandoObject,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\ExpandoObject.cs,TrySetValue,The method has 6 parameters. Parameters: indexClass' index' value' name' ignoreCase' add
Long Parameter List,System.Dynamic,MetaExpando,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\ExpandoObject.cs,BindGetOrInvokeMember,The method has 5 parameters. Parameters: binder' name' ignoreCase' fallback' fallbackInvoke
Long Parameter List,System.Dynamic,MetaExpando,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\ExpandoObject.cs,GetClassEnsureIndex,The method has 5 parameters. Parameters: name' caseInsensitive' obj' class' index
Long Parameter List,System.Runtime.CompilerServices,RuntimeOps,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\ExpandoObject.cs,ExpandoTryDeleteValue,The method has 5 parameters. Parameters: expando' indexClass' index' name' ignoreCase
Long Parameter List,System.Runtime.CompilerServices,RuntimeOps,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\ExpandoObject.cs,ExpandoTryGetValue,The method has 6 parameters. Parameters: expando' indexClass' index' name' ignoreCase' value
Long Parameter List,System.Runtime.CompilerServices,RuntimeOps,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\ExpandoObject.cs,ExpandoTrySetValue,The method has 6 parameters. Parameters: expando' indexClass' index' value' name' ignoreCase
Long Parameter List,System.Runtime.CompilerServices,ContractHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Runtime\CompilerServices\ContractHelper.cs,TriggerFailure,The method has 5 parameters. Parameters: kind' displayMessage' userMessage' conditionText' innerException
Long Parameter List,System.Runtime.CompilerServices,ContractHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Runtime\CompilerServices\ContractHelper.cs,RaiseContractFailedEventImplementation,The method has 5 parameters. Parameters: failureKind' userMessage' conditionText' innerException' resultFailureMessage
Long Parameter List,System.Runtime.CompilerServices,ContractHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Runtime\CompilerServices\ContractHelper.cs,TriggerFailureImplementation,The method has 5 parameters. Parameters: kind' displayMessage' userMessage' conditionText' innerException
Long Parameter List,System.Dynamic.Utils,ContractUtils,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\Utils\ContractUtils.cs,RequiresArrayRange,The method has 5 parameters. Parameters: array' offset' count' offsetName' countName
Long Parameter List,System.Dynamic.Utils,ExpressionUtils,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\Utils\ExpressionUtils.cs,ValidateOneArgument,The method has 7 parameters. Parameters: method' nodeKind' arguments' pi' methodParamName' argumentParamName' index
Long Parameter List,System.IO,StreamTheraotExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\IO\StreamTheraotExtensions.cs,ReadAsync,The method has 5 parameters. Parameters: stream' buffer' offset' count' cancellationToken
Long Parameter List,System.IO,StreamTheraotExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\IO\StreamTheraotExtensions.cs,WriteAsync,The method has 5 parameters. Parameters: stream' buffer' offset' count' cancellationToken
Long Parameter List,System.IO,StreamTheraotExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\IO\StreamTheraotExtensions.cs,BeginRead,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,System.IO,StreamTheraotExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\IO\StreamTheraotExtensions.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,System.Linq,Enumerable,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Enumerable.append.cs,GroupBy,The method has 5 parameters. Parameters: source' keySelector' elementSelector' resultSelector' comparer
Long Parameter List,System.Linq,Enumerable,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Enumerable.append.cs,CreateGroupByIterator,The method has 5 parameters. Parameters: source' keySelector' elementSelector' resultSelector' comparer
Long Parameter List,System.Linq,Enumerable,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Enumerable.append.cs,GroupJoin,The method has 5 parameters. Parameters: outer' inner' outerKeySelector' innerKeySelector' resultSelector
Long Parameter List,System.Linq,Enumerable,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Enumerable.append.cs,GroupJoin,The method has 6 parameters. Parameters: outer' inner' outerKeySelector' innerKeySelector' resultSelector' comparer
Long Parameter List,System.Linq,Enumerable,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Enumerable.append.cs,Join,The method has 6 parameters. Parameters: outer' inner' outerKeySelector' innerKeySelector' resultSelector' comparer
Long Parameter List,System.Linq,Enumerable,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Enumerable.append.cs,Join,The method has 5 parameters. Parameters: outer' inner' outerKeySelector' innerKeySelector' resultSelector
Long Parameter List,System.Linq,GroupedConvertedEnumerable<TSource;TKey;TElement;TResult>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Enumerable.GroupedConvertedEnumerable.cs,GroupedConvertedEnumerable,The method has 5 parameters. Parameters: source' keySelector' elementSelector' resultSelector' comparer
Long Parameter List,System.Linq,Queryable,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Queryable.cs,GroupBy,The method has 5 parameters. Parameters: source' keySelector' elementSelector' resultSelector' comparer
Long Parameter List,System.Linq,Queryable,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Queryable.cs,GroupJoin,The method has 5 parameters. Parameters: outer' inner' outerKeySelector' innerKeySelector' resultSelector
Long Parameter List,System.Linq,Queryable,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Queryable.cs,GroupJoin,The method has 6 parameters. Parameters: outer' inner' outerKeySelector' innerKeySelector' resultSelector' comparer
Long Parameter List,System.Linq,Queryable,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Queryable.cs,Join,The method has 5 parameters. Parameters: outer' inner' outerKeySelector' innerKeySelector' resultSelector
Long Parameter List,System.Linq,Queryable,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Queryable.cs,Join,The method has 6 parameters. Parameters: outer' inner' outerKeySelector' innerKeySelector' resultSelector' comparer
Long Parameter List,System.Linq.Expressions,BinaryExpression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Create,The method has 6 parameters. Parameters: nodeType' left' right' type' method' conversion
Long Parameter List,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,MakeBinary,The method has 5 parameters. Parameters: binaryType' left' right' liftToNull' method
Long Parameter List,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,MakeBinary,The method has 6 parameters. Parameters: binaryType' left' right' liftToNull' method' conversion
Long Parameter List,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,GetComparisonOperator,The method has 5 parameters. Parameters: binaryType' opName' left' right' liftToNull
Long Parameter List,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,GetEqualityComparisonOperator,The method has 5 parameters. Parameters: binaryType' opName' left' right' liftToNull
Long Parameter List,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,GetMethodBasedAssignOperator,The method has 6 parameters. Parameters: binaryType' left' right' method' conversion' liftToNull
Long Parameter List,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,GetMethodBasedBinaryOperator,The method has 5 parameters. Parameters: binaryType' left' right' method' liftToNull
Long Parameter List,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,GetUserDefinedAssignOperatorOrThrow,The method has 6 parameters. Parameters: binaryType' name' left' right' conversion' liftToNull
Long Parameter List,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,GetUserDefinedBinaryOperator,The method has 5 parameters. Parameters: binaryType' name' left' right' liftToNull
Long Parameter List,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,GetUserDefinedBinaryOperatorOrThrow,The method has 5 parameters. Parameters: binaryType' name' left' right' liftToNull
Long Parameter List,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Block,The method has 5 parameters. Parameters: arg0' arg1' arg2' arg3' arg4
Long Parameter List,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,DebugInfo,The method has 5 parameters. Parameters: document' startLine' startColumn' endLine' endColumn
Long Parameter List,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Dynamic,The method has 5 parameters. Parameters: binder' returnType' arg0' arg1' arg2
Long Parameter List,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Dynamic,The method has 6 parameters. Parameters: binder' returnType' arg0' arg1' arg2' arg3
Long Parameter List,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,MakeDynamic,The method has 5 parameters. Parameters: delegateType' binder' arg0' arg1' arg2
Long Parameter List,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,MakeDynamic,The method has 6 parameters. Parameters: delegateType' binder' arg0' arg1' arg2' arg3
Long Parameter List,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateAccessor,The method has 5 parameters. Parameters: instance' method' indexes' arguments' paramName
Long Parameter List,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Invoke,The method has 5 parameters. Parameters: expression' arg0' arg1' arg2' arg3
Long Parameter List,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Invoke,The method has 6 parameters. Parameters: expression' arg0' arg1' arg2' arg3' arg4
Long Parameter List,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Lambda,The method has 5 parameters. Parameters: delegateType' body' name' tailCall' parameters
Long Parameter List,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,CreateLambda,The method has 5 parameters. Parameters: delegateType' body' name' tailCall' parameters
Long Parameter List,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,LambdaExtracted,The method has 5 parameters. Parameters: delegateType' body' name' tailCall' parameters
Long Parameter List,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Call,The method has 5 parameters. Parameters: method' arg0' arg1' arg2' arg3
Long Parameter List,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Call,The method has 6 parameters. Parameters: method' arg0' arg1' arg2' arg3' arg4
Long Parameter List,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Call,The method has 5 parameters. Parameters: instance' method' arg0' arg1' arg2
Long Parameter List,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,FindMethod,The method has 5 parameters. Parameters: type' methodName' typeArgs' args' flags
Long Parameter List,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateOneArgument,The method has 6 parameters. Parameters: method' nodeKind' arg' pi' methodParamName' argumentParamName
Long Parameter List,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Switch,The method has 5 parameters. Parameters: type' switchValue' defaultBody' comparison' cases
Long Parameter List,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Switch,The method has 5 parameters. Parameters: type' switchValue' defaultBody' comparison' cases
Long Parameter List,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,SwitchExtracted,The method has 5 parameters. Parameters: type' switchValue' defaultBody' comparison' cases
Long Parameter List,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,MakeTry,The method has 5 parameters. Parameters: type' body' finally' fault' handlers
Long Parameter List,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,MakeTryExtracted,The method has 5 parameters. Parameters: type' body' finally' fault' handlers
Long Parameter List,System.Linq.Expressions,MethodBinaryExpression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,MethodBinaryExpression,The method has 5 parameters. Parameters: nodeType' left' right' type' method
Long Parameter List,System.Linq.Expressions,OpAssignMethodConversionBinaryExpression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,OpAssignMethodConversionBinaryExpression,The method has 6 parameters. Parameters: nodeType' left' right' type' method' conversion
Long Parameter List,System.Linq.Expressions,Block5,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BlockExpression.cs,Block5,The method has 5 parameters. Parameters: arg0' arg1' arg2' arg3' arg4
Long Parameter List,System.Linq.Expressions,SpanDebugInfoExpression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DebugInfoExpression.cs,SpanDebugInfoExpression,The method has 5 parameters. Parameters: document' startLine' startColumn' endLine' endColumn
Long Parameter List,System.Linq.Expressions,DynamicExpression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,Dynamic,The method has 5 parameters. Parameters: binder' returnType' arg0' arg1' arg2
Long Parameter List,System.Linq.Expressions,DynamicExpression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,Dynamic,The method has 6 parameters. Parameters: binder' returnType' arg0' arg1' arg2' arg3
Long Parameter List,System.Linq.Expressions,DynamicExpression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,MakeDynamic,The method has 5 parameters. Parameters: delegateType' binder' arg0' arg1' arg2
Long Parameter List,System.Linq.Expressions,DynamicExpression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,MakeDynamic,The method has 6 parameters. Parameters: delegateType' binder' arg0' arg1' arg2' arg3
Long Parameter List,System.Linq.Expressions,DynamicExpression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,Make,The method has 5 parameters. Parameters: returnType' delegateType' binder' arg0' arg1
Long Parameter List,System.Linq.Expressions,DynamicExpression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,Make,The method has 6 parameters. Parameters: returnType' delegateType' binder' arg0' arg1' arg2
Long Parameter List,System.Linq.Expressions,DynamicExpression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,Make,The method has 7 parameters. Parameters: returnType' delegateType' binder' arg0' arg1' arg2' arg3
Long Parameter List,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,Dynamic,The method has 5 parameters. Parameters: binder' returnType' arg0' arg1' arg2
Long Parameter List,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,Dynamic,The method has 6 parameters. Parameters: binder' returnType' arg0' arg1' arg2' arg3
Long Parameter List,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,MakeDynamic,The method has 5 parameters. Parameters: delegateType' binder' arg0' arg1' arg2
Long Parameter List,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,MakeDynamic,The method has 6 parameters. Parameters: delegateType' binder' arg0' arg1' arg2' arg3
Long Parameter List,System.Linq.Expressions,DynamicExpression3,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,DynamicExpression3,The method has 5 parameters. Parameters: delegateType' binder' arg0' arg1' arg2
Long Parameter List,System.Linq.Expressions,DynamicExpression4,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,DynamicExpression4,The method has 6 parameters. Parameters: delegateType' binder' arg0' arg1' arg2' arg3
Long Parameter List,System.Linq.Expressions,TypedDynamicExpression2,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,TypedDynamicExpression2,The method has 5 parameters. Parameters: retType' delegateType' binder' arg0' arg1
Long Parameter List,System.Linq.Expressions,TypedDynamicExpression3,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,TypedDynamicExpression3,The method has 6 parameters. Parameters: retType' delegateType' binder' arg0' arg1' arg2
Long Parameter List,System.Linq.Expressions,TypedDynamicExpression4,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,TypedDynamicExpression4,The method has 7 parameters. Parameters: retType' delegateType' binder' arg0' arg1' arg2' arg3
Long Parameter List,System.Linq.Expressions,InvocationExpression3,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\InvocationExpression.cs,InvocationExpression3,The method has 5 parameters. Parameters: lambda' returnType' arg0' arg1' arg2
Long Parameter List,System.Linq.Expressions,InvocationExpression4,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\InvocationExpression.cs,InvocationExpression4,The method has 6 parameters. Parameters: lambda' returnType' arg0' arg1' arg2' arg3
Long Parameter List,System.Linq.Expressions,InvocationExpression5,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\InvocationExpression.cs,InvocationExpression5,The method has 7 parameters. Parameters: lambda' returnType' arg0' arg1' arg2' arg3' arg4
Long Parameter List,System.Linq.Expressions,InstanceMethodCallExpression3,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MethodCallExpression.cs,InstanceMethodCallExpression3,The method has 5 parameters. Parameters: method' instance' arg0' arg1' arg2
Long Parameter List,System.Linq.Expressions,MethodCallExpression4,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MethodCallExpression.cs,MethodCallExpression4,The method has 5 parameters. Parameters: method' arg0' arg1' arg2' arg3
Long Parameter List,System.Linq.Expressions,MethodCallExpression5,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MethodCallExpression.cs,MethodCallExpression5,The method has 6 parameters. Parameters: method' arg0' arg1' arg2' arg3' arg4
Long Parameter List,System.Linq.Expressions,SwitchExpression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\SwitchExpression.cs,SwitchExpression,The method has 5 parameters. Parameters: type' switchValue' defaultBody' comparison' cases
Long Parameter List,System.Linq.Expressions,TryExpression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\TryExpression.cs,TryExpression,The method has 5 parameters. Parameters: type' body' finally' fault' handlers
Long Parameter List,System.Linq.Expressions.Compiler,ILGen,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitConvertToType,The method has 5 parameters. Parameters: il' typeFrom' typeTo' isChecked' locals
Long Parameter List,System.Linq.Expressions.Compiler,ILGen,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitNonNullableToNullableConversion,The method has 5 parameters. Parameters: il' typeFrom' typeTo' isChecked' locals
Long Parameter List,System.Linq.Expressions.Compiler,ILGen,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitNullableConversion,The method has 5 parameters. Parameters: il' typeFrom' typeTo' isChecked' locals
Long Parameter List,System.Linq.Expressions.Compiler,ILGen,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitNullableToNonNullableConversion,The method has 5 parameters. Parameters: il' typeFrom' typeTo' isChecked' locals
Long Parameter List,System.Linq.Expressions.Compiler,ILGen,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitNullableToNonNullableStructConversion,The method has 5 parameters. Parameters: il' typeFrom' typeTo' isChecked' locals
Long Parameter List,System.Linq.Expressions.Compiler,ILGen,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitNullableToNullableConversion,The method has 5 parameters. Parameters: il' typeFrom' typeTo' isChecked' locals
Long Parameter List,System.Linq.Expressions.Compiler,LambdaCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.cs,EmitBinaryOperator,The method has 5 parameters. Parameters: op' leftType' rightType' resultType' liftedToNull
Long Parameter List,System.Linq.Expressions.Compiler,LambdaCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.cs,EmitLiftedBinaryOp,The method has 5 parameters. Parameters: op' leftType' rightType' resultType' liftedToNull
Long Parameter List,System.Linq.Expressions.Compiler,LambdaCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.cs,EmitLift,The method has 5 parameters. Parameters: nodeType' resultType' mc' paramList' argList
Long Parameter List,System.Linq.Expressions.Compiler,LambdaCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.cs,EmitSwitchCases,The method has 6 parameters. Parameters: node' labels' isGoto' default' end' flags
Long Parameter List,System.Linq.Expressions.Interpreter,CallInstruction,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\CallInstruction.cs,ArrayItemSetter3,The method has 5 parameters. Parameters: array' index0' index1' index2' value
Long Parameter List,System.Linq.Expressions.Interpreter,ExceptionHandler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\ExceptionHandler.cs,ExceptionHandler,The method has 5 parameters. Parameters: labelIndex' handlerStartIndex' handlerEndIndex' exceptionType' filter
Long Parameter List,System.Linq.Expressions.Interpreter,InstructionArray,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\InstructionList.cs,InstructionArray,The method has 6 parameters. Parameters: maxStackDepth' maxContinuationDepth' instructions' objects' labels' debugCookies
Long Parameter List,System.Linq.Expressions.Interpreter,InstructionView,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\InstructionList.cs,InstructionView,The method has 5 parameters. Parameters: instruction' name' index' stackDepth' continuationsDepth
Long Parameter List,System.Linq.Expressions.Interpreter,TryCatchFinallyHandler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\TryCatchFinallyHandler.cs,TryCatchFinallyHandler,The method has 6 parameters. Parameters: tryStart' tryEnd' gotoEndLabelIndex' finallyStart' finallyEnd' handlers
Long Parameter List,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,ModPowInner,The method has 5 parameters. Parameters: exp' regRes' regVal' regMod' regTmp
Long Parameter List,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,ModPowInner32,The method has 5 parameters. Parameters: exp' regRes' regVal' regMod' regTmp
Long Parameter List,System.Threading.Tasks,ContinuationResultTaskFromResultTask<TAntecedentResult;TResult>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ContinuationResultTaskFromResultTask.cs,ContinuationResultTaskFromResultTask,The method has 5 parameters. Parameters: antecedent' function' state' creationOptions' internalOptions
Long Parameter List,System.Threading.Tasks,ContinuationResultTaskFromTask<TResult>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ContinuationResultTaskFromTask.cs,ContinuationResultTaskFromTask,The method has 5 parameters. Parameters: antecedent' function' state' creationOptions' internalOptions
Long Parameter List,System.Threading.Tasks,ContinuationTaskFromResultTask<TAntecedentResult>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ContinuationTaskFromResultTask.cs,ContinuationTaskFromResultTask,The method has 5 parameters. Parameters: antecedent' action' state' creationOptions' internalOptions
Long Parameter List,System.Threading.Tasks,ContinuationTaskFromTask,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ContinuationTaskFromTask.cs,ContinuationTaskFromTask,The method has 5 parameters. Parameters: antecedent' action' state' creationOptions' internalOptions
Long Parameter List,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,ContinueWith,The method has 5 parameters. Parameters: continuationAction' state' cancellationToken' continuationOptions' scheduler
Long Parameter List,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,ContinueWith,The method has 5 parameters. Parameters: continuationFunction' state' cancellationToken' continuationOptions' scheduler
Long Parameter List,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,ContinueWith,The method has 5 parameters. Parameters: continuationAction' state' scheduler' cancellationToken' continuationOptions
Long Parameter List,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,ContinueWith,The method has 5 parameters. Parameters: continuationFunction' state' scheduler' cancellationToken' continuationOptions
Long Parameter List,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,Task,The method has 7 parameters. Parameters: action' state' parent' cancellationToken' creationOptions' internalOptions' scheduler
Long Parameter List,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,Task,The method has 6 parameters. Parameters: action' parent' cancellationToken' creationOptions' internalOptions' scheduler
Long Parameter List,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,Task,The method has 7 parameters. Parameters: action' state' parent' cancellationToken' creationOptions' internalOptions' scheduler
Long Parameter List,System.Threading.Tasks,Parallel,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Parallel.cs,For,The method has 5 parameters. Parameters: fromInclusive' toExclusive' localInit' body' localFinally
Long Parameter List,System.Threading.Tasks,Parallel,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Parallel.cs,For,The method has 5 parameters. Parameters: fromInclusive' toExclusive' localInit' body' localFinally
Long Parameter List,System.Threading.Tasks,Parallel,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Parallel.cs,For,The method has 6 parameters. Parameters: fromInclusive' toExclusive' parallelOptions' localInit' body' localFinally
Long Parameter List,System.Threading.Tasks,Parallel,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Parallel.cs,For,The method has 6 parameters. Parameters: fromInclusive' toExclusive' parallelOptions' localInit' body' localFinally
Long Parameter List,System.Threading.Tasks,Parallel,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Parallel.cs,ForEach,The method has 5 parameters. Parameters: source' parallelOptions' localInit' body' localFinally
Long Parameter List,System.Threading.Tasks,Parallel,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Parallel.cs,ForEach,The method has 5 parameters. Parameters: source' parallelOptions' localInit' body' localFinally
Long Parameter List,System.Threading.Tasks,Parallel,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Parallel.cs,ForEach,The method has 5 parameters. Parameters: source' parallelOptions' localInit' body' localFinally
Long Parameter List,System.Threading.Tasks,Parallel,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Parallel.cs,ForEach,The method has 5 parameters. Parameters: source' parallelOptions' localInit' body' localFinally
Long Parameter List,System.Threading.Tasks,Parallel,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Parallel.cs,ForEachWorker,The method has 9 parameters. Parameters: source' parallelOptions' body' bodyWithState' bodyWithStateAndIndex' bodyWithStateAndLocal' bodyWithEverything' localInit' localFinally
Long Parameter List,System.Threading.Tasks,Parallel,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Parallel.cs,ForEachWorker,The method has 9 parameters. Parameters: array' parallelOptions' body' bodyWithState' bodyWithStateAndIndex' bodyWithStateAndLocal' bodyWithEverything' localInit' localFinally
Long Parameter List,System.Threading.Tasks,Parallel,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Parallel.cs,ForEachWorker,The method has 9 parameters. Parameters: list' parallelOptions' body' bodyWithState' bodyWithStateAndIndex' bodyWithStateAndLocal' bodyWithEverything' localInit' localFinally
Long Parameter List,System.Threading.Tasks,Parallel,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Parallel.cs,ForWorker,The method has 8 parameters. Parameters: fromInclusive' toExclusive' parallelOptions' body' bodyWithState' bodyWithLocal' localInit' localFinally
Long Parameter List,System.Threading.Tasks,Parallel,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Parallel.cs,ForWorker64,The method has 8 parameters. Parameters: fromInclusive' toExclusive' parallelOptions' body' bodyWithState' bodyWithLocal' localInit' localFinally
Long Parameter List,System.Threading.Tasks,Parallel,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Parallel.cs,PartitionerForEachWorker,The method has 9 parameters. Parameters: source' parallelOptions' simpleBody' bodyWithState' bodyWithStateAndIndex' bodyWithStateAndLocal' bodyWithEverything' localInit' localFinally
Long Parameter List,System.Threading.Tasks,Task<TResult>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Task.await.cs,ContinueWith,The method has 5 parameters. Parameters: continuationAction' state' cancellationToken' continuationOptions' scheduler
Long Parameter List,System.Threading.Tasks,Task<TResult>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Task.await.cs,ContinueWith,The method has 5 parameters. Parameters: continuationFunction' state' cancellationToken' continuationOptions' scheduler
Long Parameter List,System.Threading.Tasks,Task<TResult>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Task.await.cs,ContinueWithInternal,The method has 5 parameters. Parameters: continuationAction' state' scheduler' cancellationToken' continuationOptions
Long Parameter List,System.Threading.Tasks,Task<TResult>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Task.await.cs,ContinueWithInternal,The method has 5 parameters. Parameters: continuationFunction' state' scheduler' cancellationToken' continuationOptions
Long Parameter List,System.Threading.Tasks,Task<TResult>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Task.await.cs,Task,The method has 6 parameters. Parameters: function' parent' cancellationToken' creationOptions' internalOptions' scheduler
Long Parameter List,System.Threading.Tasks,Task<TResult>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Task.await.cs,Task,The method has 5 parameters. Parameters: function' state' cancellationToken' creationOptions' scheduler
Long Parameter List,System.Threading.Tasks,Task<TResult>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Task.await.cs,Task,The method has 7 parameters. Parameters: function' state' parent' cancellationToken' creationOptions' internalOptions' scheduler
Long Parameter List,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The method has 5 parameters. Parameters: tasks' continuationAction' cancellationToken' continuationOptions' scheduler
Long Parameter List,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The method has 5 parameters. Parameters: tasks' continuationFunction' cancellationToken' continuationOptions' scheduler
Long Parameter List,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The method has 5 parameters. Parameters: tasks' continuationAction' cancellationToken' continuationOptions' scheduler
Long Parameter List,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The method has 5 parameters. Parameters: tasks' continuationFunction' cancellationToken' continuationOptions' scheduler
Long Parameter List,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The method has 5 parameters. Parameters: tasks' continuationAction' cancellationToken' continuationOptions' scheduler
Long Parameter List,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The method has 5 parameters. Parameters: tasks' continuationFunction' cancellationToken' continuationOptions' scheduler
Long Parameter List,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The method has 5 parameters. Parameters: tasks' continuationAction' cancellationToken' continuationOptions' scheduler
Long Parameter List,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The method has 5 parameters. Parameters: tasks' continuationFunction' cancellationToken' continuationOptions' scheduler
Long Parameter List,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,StartNew,The method has 5 parameters. Parameters: action' state' cancellationToken' creationOptions' scheduler
Long Parameter List,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,StartNew,The method has 5 parameters. Parameters: function' state' cancellationToken' creationOptions' scheduler
Long Parameter List,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,FromAsync,The method has 5 parameters. Parameters: beginMethod' endMethod' arg1' state' creationOptions
Long Parameter List,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,FromAsync,The method has 5 parameters. Parameters: beginMethod' endMethod' arg1' state' creationOptions
Long Parameter List,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,FromAsync,The method has 5 parameters. Parameters: beginMethod' endMethod' arg1' arg2' state
Long Parameter List,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,FromAsync,The method has 6 parameters. Parameters: beginMethod' endMethod' arg1' arg2' state' creationOptions
Long Parameter List,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,FromAsync,The method has 5 parameters. Parameters: beginMethod' endMethod' arg1' arg2' state
Long Parameter List,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,FromAsync,The method has 6 parameters. Parameters: beginMethod' endMethod' arg1' arg2' state' creationOptions
Long Parameter List,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,FromAsync,The method has 6 parameters. Parameters: beginMethod' endMethod' arg1' arg2' arg3' state
Long Parameter List,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,FromAsync,The method has 7 parameters. Parameters: beginMethod' endMethod' arg1' arg2' arg3' state' creationOptions
Long Parameter List,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,FromAsync,The method has 6 parameters. Parameters: beginMethod' endMethod' arg1' arg2' arg3' state
Long Parameter List,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,FromAsync,The method has 7 parameters. Parameters: beginMethod' endMethod' arg1' arg2' arg3' state' creationOptions
Long Parameter List,Theraot.Core,HelperNullAction<T1;T2;T3;T4;T5>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\ActionHelper.cs,NullAction,The method has 5 parameters. Parameters: arg1' arg2' arg3' arg4' arg5
Long Parameter List,Theraot.Core,HelperNullAction<T1;T2;T3;T4;T5;T6>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\ActionHelper.cs,NullAction,The method has 6 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6
Long Parameter List,Theraot.Core,HelperNullAction<T1;T2;T3;T4;T5;T6;T7>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\ActionHelper.cs,NullAction,The method has 7 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7
Long Parameter List,Theraot.Core,HelperNullAction<T1;T2;T3;T4;T5;T6;T7;T8>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\ActionHelper.cs,NullAction,The method has 8 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8
Long Parameter List,Theraot.Core,HelperNullAction<T1;T2;T3;T4;T5;T6;T7;T8;T9>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\ActionHelper.cs,NullAction,The method has 9 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9
Long Parameter List,Theraot.Core,HelperNullAction<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\ActionHelper.cs,NullAction,The method has 10 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10
Long Parameter List,Theraot.Core,HelperNullAction<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\ActionHelper.cs,NullAction,The method has 11 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11
Long Parameter List,Theraot.Core,HelperNullAction<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\ActionHelper.cs,NullAction,The method has 12 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12
Long Parameter List,Theraot.Core,HelperNullAction<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\ActionHelper.cs,NullAction,The method has 13 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13
Long Parameter List,Theraot.Core,HelperNullAction<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\ActionHelper.cs,NullAction,The method has 14 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14
Long Parameter List,Theraot.Core,HelperNullAction<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;T15>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\ActionHelper.cs,NullAction,The method has 15 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14' arg15
Long Parameter List,Theraot.Core,HelperNullAction<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;T15;T16>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\ActionHelper.cs,NullAction,The method has 16 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14' arg15' arg16
Long Parameter List,Theraot.Core,HelperDefaultFunc<T1;T2;T3;T4;T5;TReturn>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,DefaultFunc,The method has 5 parameters. Parameters: arg1' arg2' arg3' arg4' arg5
Long Parameter List,Theraot.Core,HelperDefaultFunc<T1;T2;T3;T4;T5;T6;TReturn>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,DefaultFunc,The method has 6 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6
Long Parameter List,Theraot.Core,HelperDefaultFunc<T1;T2;T3;T4;T5;T6;T7;TReturn>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,DefaultFunc,The method has 7 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7
Long Parameter List,Theraot.Core,HelperDefaultFunc<T1;T2;T3;T4;T5;T6;T7;T8;TReturn>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,DefaultFunc,The method has 8 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8
Long Parameter List,Theraot.Core,HelperDefaultFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;TReturn>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,DefaultFunc,The method has 9 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9
Long Parameter List,Theraot.Core,HelperDefaultFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;TReturn>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,DefaultFunc,The method has 10 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10
Long Parameter List,Theraot.Core,HelperDefaultFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;TReturn>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,DefaultFunc,The method has 11 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11
Long Parameter List,Theraot.Core,HelperDefaultFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;TReturn>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,DefaultFunc,The method has 12 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12
Long Parameter List,Theraot.Core,HelperDefaultFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;TReturn>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,DefaultFunc,The method has 13 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13
Long Parameter List,Theraot.Core,HelperDefaultFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;TReturn>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,DefaultFunc,The method has 14 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14
Long Parameter List,Theraot.Core,HelperDefaultFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;T15;TReturn>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,DefaultFunc,The method has 15 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14' arg15
Long Parameter List,Theraot.Core,HelperDefaultFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;T15;T16;TReturn>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,DefaultFunc,The method has 16 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14' arg15' arg16
Long Parameter List,Theraot.Core,HelperFallacyFunc<T1;T2;T3;T4;T5>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,FallacyFunc,The method has 5 parameters. Parameters: arg1' arg2' arg3' arg4' arg5
Long Parameter List,Theraot.Core,HelperFallacyFunc<T1;T2;T3;T4;T5;T6>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,FallacyFunc,The method has 6 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6
Long Parameter List,Theraot.Core,HelperFallacyFunc<T1;T2;T3;T4;T5;T6;T7>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,FallacyFunc,The method has 7 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7
Long Parameter List,Theraot.Core,HelperFallacyFunc<T1;T2;T3;T4;T5;T6;T7;T8>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,FallacyFunc,The method has 8 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8
Long Parameter List,Theraot.Core,HelperFallacyFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,FallacyFunc,The method has 9 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9
Long Parameter List,Theraot.Core,HelperFallacyFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,FallacyFunc,The method has 10 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10
Long Parameter List,Theraot.Core,HelperFallacyFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,FallacyFunc,The method has 11 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11
Long Parameter List,Theraot.Core,HelperFallacyFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,FallacyFunc,The method has 12 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12
Long Parameter List,Theraot.Core,HelperFallacyFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,FallacyFunc,The method has 13 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13
Long Parameter List,Theraot.Core,HelperFallacyFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,FallacyFunc,The method has 14 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14
Long Parameter List,Theraot.Core,HelperFallacyFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;T15>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,FallacyFunc,The method has 15 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14' arg15
Long Parameter List,Theraot.Core,HelperFallacyFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;T15;T16>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,FallacyFunc,The method has 16 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14' arg15' arg16
Long Parameter List,Theraot.Core,HelperTautologyFunc<T1;T2;T3;T4;T5>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,TautologyFunc,The method has 5 parameters. Parameters: arg1' arg2' arg3' arg4' arg5
Long Parameter List,Theraot.Core,HelperTautologyFunc<T1;T2;T3;T4;T5;T6>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,TautologyFunc,The method has 6 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6
Long Parameter List,Theraot.Core,HelperTautologyFunc<T1;T2;T3;T4;T5;T6;T7>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,TautologyFunc,The method has 7 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7
Long Parameter List,Theraot.Core,HelperTautologyFunc<T1;T2;T3;T4;T5;T6;T7;T8>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,TautologyFunc,The method has 8 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8
Long Parameter List,Theraot.Core,HelperTautologyFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,TautologyFunc,The method has 9 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9
Long Parameter List,Theraot.Core,HelperTautologyFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,TautologyFunc,The method has 10 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10
Long Parameter List,Theraot.Core,HelperTautologyFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,TautologyFunc,The method has 11 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11
Long Parameter List,Theraot.Core,HelperTautologyFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,TautologyFunc,The method has 12 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12
Long Parameter List,Theraot.Core,HelperTautologyFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,TautologyFunc,The method has 13 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13
Long Parameter List,Theraot.Core,HelperTautologyFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,TautologyFunc,The method has 14 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14
Long Parameter List,Theraot.Core,HelperTautologyFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;T15>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,TautologyFunc,The method has 15 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14' arg15
Long Parameter List,Theraot.Core,HelperTautologyFunc<T1;T2;T3;T4;T5;T6;T7;T8;T9;T10;T11;T12;T13;T14;T15;T16>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,TautologyFunc,The method has 16 parameters. Parameters: arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8' arg9' arg10' arg11' arg12' arg13' arg14' arg15' arg16
Long Parameter List,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,GetDoubleParts,The method has 5 parameters. Parameters: dbl' sign' exp' man' finite
Long Parameter List,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,GetParts,The method has 5 parameters. Parameters: value' sign' mantissa' exponent' finite
Long Parameter List,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,GetParts,The method has 5 parameters. Parameters: value' sign' mantissa' exponent' finite
Long Parameter List,Theraot.Core,SequenceHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\SequenceHelper.cs,ExploreSequence,The method has 5 parameters. Parameters: initial' endCondition' next' resultSelector' comparer
Long Parameter List,Theraot.Core,SequenceHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\SequenceHelper.cs,ExploreSequenceExtracted,The method has 5 parameters. Parameters: initial' endCondition' next' resultSelector' comparer
Long Parameter List,Theraot.Core,SequenceHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\SequenceHelper.cs,ExploreSequenceUntilNull,The method has 5 parameters. Parameters: initial' endCondition' next' resultSelector' comparer
Long Parameter List,Theraot.Core,SequenceHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\SequenceHelper.cs,ExploreSequenceUntilNull,The method has 5 parameters. Parameters: initial' endCondition' next' resultSelector' comparer
Long Parameter List,Theraot.Core,SequenceHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\SequenceHelper.cs,ExploreSequenceExtractedUntilNull,The method has 5 parameters. Parameters: initial' endCondition' next' resultSelector' comparer
Long Parameter List,Theraot.Core,SequenceHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\SequenceHelper.cs,ExploreSequenceExtractedUntilNull,The method has 5 parameters. Parameters: initial' endCondition' next' resultSelector' comparer
Long Parameter List,Theraot.Core,StringHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\StringHelper.cs,Match,The method has 5 parameters. Parameters: text' regexPattern' ignoreCase' startAt' length
Long Parameter List,Theraot.Core,StringHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\StringHelper.cs,Match,The method has 5 parameters. Parameters: text' regexPattern' regexOptions' startAt' length
Long Parameter List,Theraot.Collections,Extensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\Extensions.add.cs,GroupProgressiveBy,The method has 5 parameters. Parameters: source' keySelector' elementSelector' resultSelector' comparer
Long Parameter List,Theraot.Collections,Extensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\Extensions.add.cs,ConvertedCopyTo,The method has 5 parameters. Parameters: source' conversion' sourceIndex' array' arrayIndex
Long Parameter List,Theraot.Collections,Extensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\Extensions.add.cs,ConvertedCopyTo,The method has 6 parameters. Parameters: source' conversion' sourceIndex' array' arrayIndex' countLimit
Long Parameter List,Theraot.Collections,Extensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\Extensions.add.cs,ConvertedCopyTo,The method has 5 parameters. Parameters: source' conversion' array' arrayIndex' countLimit
Long Parameter List,Theraot.Collections,Extensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\Extensions.add.cs,CopyTo,The method has 5 parameters. Parameters: source' sourceIndex' array' arrayIndex' countLimit
Long Parameter List,Theraot.Collections.Specialized,AVLNode<TKey;TValue>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\Specialized\AVLNode.cs,AddNonDuplicateExtracted,The method has 5 parameters. Parameters: node' key' value' comparer' created
Long Parameter List,Theraot.Collections.ThreadSafe,BucketCore,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\ThreadSafe\BucketCore.cs,DoMayIncrement,The method has 5 parameters. Parameters: use' first' second' factory' callback
Long Parameter List,Theraot.Collections.ThreadSafe,BucketHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\ThreadSafe\BucketHelper.cs,InsertOrUpdate,The method has 5 parameters. Parameters: bucket' index' itemFactory' itemUpdateFactory' isNew
Long Parameter List,Theraot.Collections.ThreadSafe,BucketHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\ThreadSafe\BucketHelper.cs,InsertOrUpdateChecked,The method has 6 parameters. Parameters: bucket' index' itemFactory' itemUpdateFactory' check' isNew
Long Parameter List,Theraot.Collections.ThreadSafe,BucketHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\ThreadSafe\BucketHelper.cs,InsertOrUpdateChecked,The method has 6 parameters. Parameters: bucket' index' item' itemUpdateFactory' check' isNew
Long Parameter List,Theraot.Collections.ThreadSafe,BucketHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\ThreadSafe\BucketHelper.cs,InsertOrUpdateChecked,The method has 5 parameters. Parameters: bucket' index' item' check' isNew
Long Parameter List,Theraot.Threading,ThreadingHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeExchangeBounded,The method has 5 parameters. Parameters: check' value' minValue' maxValue' lastValue
Long Identifier,System.Runtime.CompilerServices,AsyncVoidMethodBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Runtime\CompilerServices\AsyncVoidMethodBuilder.cs,,The length of the parameter _preventUnobservedTaskExceptionsInvoked is 39.
Long Identifier,System.Dynamic.Utils,TypeUtils,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\Utils\TypeUtils.cs,IsGenericImplementationOf,The length of the parameter interfaceGenericTypeDefinition is 30.
Long Identifier,System.Linq.Expressions,BlockN,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BlockExpression.cs,,The length of the parameter _expressionsAsReadOnlyCollection is 32.
Long Identifier,System.Linq.Expressions,ScopeExpression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BlockExpression.cs,,The length of the parameter _variablesAsReadOnlyCollection is 30.
Long Identifier,System.Linq.Expressions,CachedReflectionInfo,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Common\CachedReflectionInfo.cs,,The length of the parameter _closureObjectArrayObjectArray is 30.
Long Identifier,System.Linq.Expressions,CachedReflectionInfo,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Common\CachedReflectionInfo.cs,,The length of the parameter _decimalCtorInt32Int32Int32BoolByte is 35.
Long Identifier,System.Linq.Expressions,CachedReflectionInfo,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Common\CachedReflectionInfo.cs,,The length of the parameter _dictionaryOfStringInt32AddStringInt32 is 38.
Long Identifier,System.Linq.Expressions,CachedReflectionInfo,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Common\CachedReflectionInfo.cs,,The length of the parameter _dictionaryOfStringInt32CtorInt32 is 33.
Long Identifier,System.Linq.Expressions,CachedReflectionInfo,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Common\CachedReflectionInfo.cs,,The length of the parameter _methodBaseGetMethodFromHandleRuntimeMethodHandle is 49.
Long Identifier,System.Linq.Expressions,CachedReflectionInfo,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Common\CachedReflectionInfo.cs,,The length of the parameter _methodBaseGetMethodFromHandleRuntimeMethodHandleRuntimeTypeHandle is 66.
Long Identifier,System.Linq.Expressions,CachedReflectionInfo,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Common\CachedReflectionInfo.cs,,The length of the parameter _runtimeOpsCreateRuntimeVariables is 33.
Long Identifier,System.Linq.Expressions,CachedReflectionInfo,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Common\CachedReflectionInfo.cs,,The length of the parameter _runtimeOpsCreateRuntimeVariablesObjectArrayInt64Array is 54.
Long Identifier,System.Linq.Expressions,CachedReflectionInfo,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Common\CachedReflectionInfo.cs,,The length of the parameter _runtimeOpsMergeRuntimeVariables is 32.
Long Identifier,System.Linq.Expressions,CachedReflectionInfo,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Common\CachedReflectionInfo.cs,,The length of the parameter _dynamicObjectTryBinaryOperation is 32.
Long Identifier,System.Linq.Expressions,CachedReflectionInfo,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Common\CachedReflectionInfo.cs,,The length of the parameter _dynamicObjectTryCreateInstance is 31.
Long Identifier,System.Linq.Expressions,CachedReflectionInfo,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Common\CachedReflectionInfo.cs,,The length of the parameter _dynamicObjectTryUnaryOperation is 31.
Long Identifier,System.Linq.Expressions,CachedReflectionInfo,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Common\CachedReflectionInfo.cs,,The length of the parameter _invalidCastExceptionCtorString is 31.
Long Identifier,System.Linq.Expressions,CachedReflectionInfo,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Common\CachedReflectionInfo.cs,,The length of the parameter _stringFormatStringObjectArray is 30.
Long Identifier,System.Linq.Expressions,DynamicExpressionN,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,,The length of the parameter _argumentsAsReadOnlyCollection is 30.
Long Identifier,System.Linq.Expressions,ElementInit,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\ElementInit.cs,,The length of the parameter _argumentsAsReadOnlyCollection is 30.
Long Identifier,System.Linq.Expressions,IndexExpression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\IndexExpression.cs,,The length of the parameter _argumentsAsReadOnlyCollection is 30.
Long Identifier,System.Linq.Expressions,ExpressionN<TDelegate>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\LambdaExpression.cs,,The length of the parameter _parametersAsReadOnlyCollection is 31.
Long Identifier,System.Linq.Expressions,InstanceMethodCallExpressionN,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MethodCallExpression.cs,,The length of the parameter _argumentsAsReadOnlyCollection is 30.
Long Identifier,System.Linq.Expressions,MethodCallExpressionN,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MethodCallExpression.cs,,The length of the parameter _argumentsAsReadOnlyCollection is 30.
Long Identifier,System.Linq.Expressions,NewArrayExpression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\NewArrayExpression.cs,,The length of the parameter _expressionsAsReadOnlyCollection is 32.
Long Identifier,System.Linq.Expressions,NewExpression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\NewExpression.cs,,The length of the parameter _argumentsAsReadOnlyCollection is 30.
Long Identifier,System.Linq.Expressions,RuntimeVariablesExpression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\RuntimeVariablesExpression.cs,,The length of the parameter _variablesAsReadOnlyCollection is 30.
Long Identifier,System.Linq.Expressions,SwitchCase,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\SwitchCase.cs,,The length of the parameter _textValuesAsReadOnlyCollection is 31.
Long Identifier,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,,The length of the parameter _isExceptionObservedByParentPredicate is 37.
Long Identifier,System.Threading.Tasks,TaskExceptionHolder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskExceptionHolder.cs,,The length of the parameter _failFastOnUnobservedException is 30.
Long Identifier,System.Threading.Tasks,TaskReplicator,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskReplicator.cs,,The length of the parameter _cooperativeMultitaskingTaskTimeoutIncrement is 44.
Long Identifier,System.Threading.Tasks,TaskReplicator,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskReplicator.cs,,The length of the parameter _cooperativeMultitaskingTaskTimeoutMin is 38.
Long Identifier,System.Threading.Tasks,TaskReplicator,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskReplicator.cs,,The length of the parameter _cooperativeMultitaskingTaskTimeoutRootTask is 43.
Long Identifier,System.Threading.Tasks,TaskScheduler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskScheduler.cs,PublishUnobservedTaskException,The length of the parameter unobservedTaskExceptionEventArgs is 32.
Long Statement,System,HashCode,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\HashCode.cs,MixState,The length of the statement  "            return BitOperations.RotateLeft(v1' 1) + BitOperations.RotateLeft(v2' 7) + BitOperations.RotateLeft(v3' 12) + BitOperations.RotateLeft(v4' 18); " is 143.
Long Statement,System,StringEx,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\StringEx.cs,Concat,The length of the statement  "                throw new ArgumentException("startIndex plus countLimit is greater than the number of elements in array."' nameof(array)); " is 122.
Long Statement,System,StringEx,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\StringEx.cs,Concat,The length of the statement  "                throw new ArgumentException("startIndex plus countLimit is greater than the number of elements in array."' nameof(array)); " is 122.
Long Statement,System,StringEx,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\StringEx.cs,Implode,The length of the statement  "            return arrayIndex == array.Length ? string.Empty : ImplodeExtracted(separator ?? string.Empty' array' arrayIndex' array.Length - arrayIndex); " is 141.
Long Statement,System,StringEx,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\StringEx.cs,Implode,The length of the statement  "            return arrayIndex == array.Length ? string.Empty : ImplodeExtracted(separator ?? string.Empty' array' arrayIndex' countLimit); " is 126.
Long Statement,System,StringEx,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\StringEx.cs,Implode,The length of the statement  "            return arrayIndex == array.Length ? string.Empty : ImplodeExtracted(separator ?? string.Empty' array' arrayIndex' array.Length - arrayIndex); " is 141.
Long Statement,System,StringEx,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\StringEx.cs,Implode,The length of the statement  "            return arrayIndex == array.Length ? string.Empty : ImplodeExtracted(separator ?? string.Empty' array' arrayIndex' countLimit); " is 126.
Long Statement,System,Tuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,Create,The length of the statement  "            return new Tuple<T1' T2' T3' T4' T5' T6' T7' Tuple<T8>>(item1' item2' item3' item4' item5' item6' item7' new Tuple<T8>(item8)); " is 127.
Long Statement,System,Tuple<T1;T2;T3;T4;T5;T6>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,ToString,The length of the statement  "            return string.Format(CultureInfo.InvariantCulture' "({0}' {1}' {2}' {3}' {4}' {5})"' Item1' Item2' Item3' Item4' Item5' Item6); " is 127.
Long Statement,System,Tuple<T1;T2;T3;T4;T5;T6;T7>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,ToString,The length of the statement  "            return string.Format(CultureInfo.InvariantCulture' "({0}' {1}' {2}' {3}' {4}' {5}' {6})"' Item1' Item2' Item3' Item4' Item5' Item6' Item7); " is 139.
Long Statement,System,Tuple<T1;T2;T3;T4;T5;T6;T7;TRest>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,ToString,The length of the statement  "            return string.Format(CultureInfo.InvariantCulture' "({0}' {1}' {2}' {3}' {4}' {5}' {6}' {7})"' Item1' Item2' Item3' Item4' Item5' Item6' Item7' restString.Substring(1' restString.Length - 2)); " is 192.
Long Statement,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,ToTuple,The length of the statement  "                Tuple.Create(value.Rest.Item1' value.Rest.Item2' value.Rest.Item3' value.Rest.Item4' value.Rest.Item5' value.Rest.Item6) " is 120.
Long Statement,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,ToTuple,The length of the statement  "                Tuple.Create(value.Rest.Item1' value.Rest.Item2' value.Rest.Item3' value.Rest.Item4' value.Rest.Item5' value.Rest.Item6' value.Rest.Item7) " is 138.
Long Statement,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,ToTuple,The length of the statement  "                    value.Rest.Item1' value.Rest.Item2' value.Rest.Item3' value.Rest.Item4' value.Rest.Item5' value.Rest.Item6' value.Rest.Item7' " is 125.
Long Statement,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,ToTuple,The length of the statement  "                    value.Rest.Item1' value.Rest.Item2' value.Rest.Item3' value.Rest.Item4' value.Rest.Item5' value.Rest.Item6' value.Rest.Item7' " is 125.
Long Statement,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,ToTuple,The length of the statement  "                    value.Rest.Item1' value.Rest.Item2' value.Rest.Item3' value.Rest.Item4' value.Rest.Item5' value.Rest.Item6' value.Rest.Item7' " is 125.
Long Statement,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,ToTuple,The length of the statement  "                    value.Rest.Item1' value.Rest.Item2' value.Rest.Item3' value.Rest.Item4' value.Rest.Item5' value.Rest.Item6' value.Rest.Item7' " is 125.
Long Statement,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,ToTuple,The length of the statement  "                    value.Rest.Item1' value.Rest.Item2' value.Rest.Item3' value.Rest.Item4' value.Rest.Item5' value.Rest.Item6' value.Rest.Item7' " is 125.
Long Statement,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,ToTuple,The length of the statement  "                    Tuple.Create(value.Rest.Rest.Item1' value.Rest.Rest.Item2' value.Rest.Rest.Item3' value.Rest.Rest.Item4' value.Rest.Rest.Item5) " is 127.
Long Statement,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,ToTuple,The length of the statement  "                    value.Rest.Item1' value.Rest.Item2' value.Rest.Item3' value.Rest.Item4' value.Rest.Item5' value.Rest.Item6' value.Rest.Item7' " is 125.
Long Statement,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,ToTuple,The length of the statement  "                    Tuple.Create(value.Rest.Rest.Item1' value.Rest.Rest.Item2' value.Rest.Rest.Item3' value.Rest.Rest.Item4' value.Rest.Rest.Item5' value.Rest.Rest.Item6) " is 150.
Long Statement,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,ToTuple,The length of the statement  "                    value.Rest.Item1' value.Rest.Item2' value.Rest.Item3' value.Rest.Item4' value.Rest.Item5' value.Rest.Item6' value.Rest.Item7' " is 125.
Long Statement,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,ToTuple,The length of the statement  "                    Tuple.Create(value.Rest.Rest.Item1' value.Rest.Rest.Item2' value.Rest.Rest.Item3' value.Rest.Rest.Item4' value.Rest.Rest.Item5' value.Rest.Rest.Item6' value.Rest.Rest.Item7) " is 173.
Long Statement,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,ToValueTuple,The length of the statement  "                ValueTuple.Create(value.Rest.Item1' value.Rest.Item2' value.Rest.Item3' value.Rest.Item4' value.Rest.Item5' value.Rest.Item6) " is 125.
Long Statement,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,ToValueTuple,The length of the statement  "                ValueTuple.Create(value.Rest.Item1' value.Rest.Item2' value.Rest.Item3' value.Rest.Item4' value.Rest.Item5' value.Rest.Item6' value.Rest.Item7) " is 143.
Long Statement,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,ToValueTuple,The length of the statement  "                    value.Rest.Item1' value.Rest.Item2' value.Rest.Item3' value.Rest.Item4' value.Rest.Item5' value.Rest.Item6' value.Rest.Item7' " is 125.
Long Statement,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,ToValueTuple,The length of the statement  "                    value.Rest.Item1' value.Rest.Item2' value.Rest.Item3' value.Rest.Item4' value.Rest.Item5' value.Rest.Item6' value.Rest.Item7' " is 125.
Long Statement,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,ToValueTuple,The length of the statement  "                    value.Rest.Item1' value.Rest.Item2' value.Rest.Item3' value.Rest.Item4' value.Rest.Item5' value.Rest.Item6' value.Rest.Item7' " is 125.
Long Statement,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,ToValueTuple,The length of the statement  "                    value.Rest.Item1' value.Rest.Item2' value.Rest.Item3' value.Rest.Item4' value.Rest.Item5' value.Rest.Item6' value.Rest.Item7' " is 125.
Long Statement,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,ToValueTuple,The length of the statement  "                    value.Rest.Item1' value.Rest.Item2' value.Rest.Item3' value.Rest.Item4' value.Rest.Item5' value.Rest.Item6' value.Rest.Item7' " is 125.
Long Statement,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,ToValueTuple,The length of the statement  "                    ValueTuple.Create(value.Rest.Rest.Item1' value.Rest.Rest.Item2' value.Rest.Rest.Item3' value.Rest.Rest.Item4' value.Rest.Rest.Item5) " is 132.
Long Statement,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,ToValueTuple,The length of the statement  "                    value.Rest.Item1' value.Rest.Item2' value.Rest.Item3' value.Rest.Item4' value.Rest.Item5' value.Rest.Item6' value.Rest.Item7' " is 125.
Long Statement,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,ToValueTuple,The length of the statement  "                    ValueTuple.Create(value.Rest.Rest.Item1' value.Rest.Rest.Item2' value.Rest.Rest.Item3' value.Rest.Rest.Item4' value.Rest.Rest.Item5' value.Rest.Rest.Item6) " is 155.
Long Statement,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,ToValueTuple,The length of the statement  "                    value.Rest.Item1' value.Rest.Item2' value.Rest.Item3' value.Rest.Item4' value.Rest.Item5' value.Rest.Item6' value.Rest.Item7' " is 125.
Long Statement,System,TupleExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\TupleExtensions.cs,ToValueTuple,The length of the statement  "                    ValueTuple.Create(value.Rest.Rest.Item1' value.Rest.Rest.Item2' value.Rest.Rest.Item3' value.Rest.Rest.Item4' value.Rest.Rest.Item5' value.Rest.Rest.Item6' value.Rest.Rest.Item7) " is 178.
Long Statement,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,Create,The length of the statement  "            return new ValueTuple<T1' T2' T3' T4' T5' T6' T7' ValueTuple<T8>>(item1' item2' item3' item4' item5' item6' item7' Create(item8)); " is 130.
Long Statement,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,ToString,The length of the statement  "            return "(" + (Item1 == null ? string.Empty : Item1.ToString()) + "' " + (Item2 == null ? string.Empty : Item2.ToString()) + ")"; " is 128.
Long Statement,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,ToStringEnd,The length of the statement  "            return (Item1 == null ? string.Empty : Item1.ToString()) + "' " + (Item2 == null ? string.Empty : Item2.ToString()) + ")"; " is 122.
Long Statement,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,ToString,The length of the statement  "            return "(" + (Item1 == null ? string.Empty : Item1.ToString()) + "' " + (Item2 == null ? string.Empty : Item2.ToString()) + "' " + (Item3 == null ? string.Empty : Item3.ToString()) + ")"; " is 187.
Long Statement,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,ToStringEnd,The length of the statement  "            return (Item1 == null ? string.Empty : Item1.ToString()) + "' " + (Item2 == null ? string.Empty : Item2.ToString()) + "' " + (Item3 == null ? string.Empty : Item3.ToString()) + ")"; " is 181.
Long Statement,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,ToString,The length of the statement  "            return "(" + (Item1 == null ? string.Empty : Item1.ToString()) + "' " + (Item2 == null ? string.Empty : Item2.ToString()) + "' " + (Item3 == null ? string.Empty : Item3.ToString()) + "' " + (Item4 == null ? string.Empty : Item4.ToString()) + ")"; " is 246.
Long Statement,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,ToStringEnd,The length of the statement  "            return (Item1 == null ? string.Empty : Item1.ToString()) + "' " + (Item2 == null ? string.Empty : Item2.ToString()) + "' " + (Item3 == null ? string.Empty : Item3.ToString()) + "' " + (Item4 == null ? string.Empty : Item4.ToString()) + ")"; " is 240.
Long Statement,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,ToString,The length of the statement  "            return "(" + (Item1 == null ? string.Empty : Item1.ToString()) + "' " + (Item2 == null ? string.Empty : Item2.ToString()) + "' " + (Item3 == null ? string.Empty : Item3.ToString()) + "' " + (Item4 == null ? string.Empty : Item4.ToString()) + "' " + (Item5 == null ? string.Empty : Item5.ToString()) + ")"; " is 305.
Long Statement,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,ToStringEnd,The length of the statement  "            return (Item1 == null ? string.Empty : Item1.ToString()) + "' " + (Item2 == null ? string.Empty : Item2.ToString()) + "' " + (Item3 == null ? string.Empty : Item3.ToString()) + "' " + (Item4 == null ? string.Empty : Item4.ToString()) + "' " + (Item5 == null ? string.Empty : Item5.ToString()) + ")"; " is 299.
Long Statement,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,ToString,The length of the statement  "            return "(" + (Item1 == null ? string.Empty : Item1.ToString()) + "' " + (Item2 == null ? string.Empty : Item2.ToString()) + "' " + (Item3 == null ? string.Empty : Item3.ToString()) + "' " + (Item4 == null ? string.Empty : Item4.ToString()) + "' " + (Item5 == null ? string.Empty : Item5.ToString()) + "' " + (Item6 == null ? string.Empty : Item6.ToString()) + ")"; " is 364.
Long Statement,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,ToStringEnd,The length of the statement  "            return (Item1 == null ? string.Empty : Item1.ToString()) + "' " + (Item2 == null ? string.Empty : Item2.ToString()) + "' " + (Item3 == null ? string.Empty : Item3.ToString()) + "' " + (Item4 == null ? string.Empty : Item4.ToString()) + "' " + (Item5 == null ? string.Empty : Item5.ToString()) + "' " + (Item6 == null ? string.Empty : Item6.ToString()) + ")"; " is 358.
Long Statement,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,ToString,The length of the statement  "            return "(" + (Item1 == null ? string.Empty : Item1.ToString()) + "' " + (Item2 == null ? string.Empty : Item2.ToString()) + "' " + (Item3 == null ? string.Empty : Item3.ToString()) + "' " + (Item4 == null ? string.Empty : Item4.ToString()) + "' " + (Item5 == null ? string.Empty : Item5.ToString()) + "' " + (Item6 == null ? string.Empty : Item6.ToString()) + "' " + (Item7 == null ? string.Empty : Item7.ToString()) + ")"; " is 423.
Long Statement,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,ToStringEnd,The length of the statement  "            return (Item1 == null ? string.Empty : Item1.ToString()) + "' " + (Item2 == null ? string.Empty : Item2.ToString()) + "' " + (Item3 == null ? string.Empty : Item3.ToString()) + "' " + (Item4 == null ? string.Empty : Item4.ToString()) + "' " + (Item5 == null ? string.Empty : Item5.ToString()) + "' " + (Item6 == null ? string.Empty : Item6.ToString()) + "' " + (Item7 == null ? string.Empty : Item7.ToString()) + ")"; " is 417.
Long Statement,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,GetHashCode,The length of the statement  "            // In this case' the rest member has less than 8 elements so we need to combine some our elements with the elements in rest " is 123.
Long Statement,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,ToString,The length of the statement  "            return !(Rest is ITupleInternal rest) ? $"({(Item1 == null ? string.Empty : Item1.ToString())}' {(Item2 == null ? string.Empty : Item2.ToString())}' {(Item3 == null ? string.Empty : Item3.ToString())}' {(Item4 == null ? string.Empty : Item4.ToString())}' {(Item5 == null ? string.Empty : Item5.ToString())}' {(Item6 == null ? string.Empty : Item6.ToString())}' {(Item7 == null ? string.Empty : Item7.ToString())}' {Rest})" : "(" + (Item1 == null ? string.Empty : Item1.ToString()) + "' " + (Item2 == null ? string.Empty : Item2.ToString()) + "' " + (Item3 == null ? string.Empty : Item3.ToString()) + "' " + (Item4 == null ? string.Empty : Item4.ToString()) + "' " + (Item5 == null ? string.Empty : Item5.ToString()) + "' " + (Item6 == null ? string.Empty : Item6.ToString()) + "' " + (Item7 == null ? string.Empty : Item7.ToString()) + "' " + rest.ToStringEnd(); " is 863.
Long Statement,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,GetHashCodeCore,The length of the statement  "            // In this case' the rest member has less than 8 elements so we need to combine some our elements with the elements in rest " is 123.
Long Statement,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,GetHashCodeCore,The length of the statement  "                    return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)' rest.GetHashCode(comparer)); " is 121.
Long Statement,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,ToStringEnd,The length of the statement  "            return !(Rest is ITupleInternal rest) ? $"{(Item1 == null ? string.Empty : Item1.ToString())}' {(Item2 == null ? string.Empty : Item2.ToString())}' {(Item3 == null ? string.Empty : Item3.ToString())}' {(Item4 == null ? string.Empty : Item4.ToString())}' {(Item5 == null ? string.Empty : Item5.ToString())}' {(Item6 == null ? string.Empty : Item6.ToString())}' {(Item7 == null ? string.Empty : Item7.ToString())}' {Rest})" : (Item1 == null ? string.Empty : Item1.ToString()) + "' " + (Item2 == null ? string.Empty : Item2.ToString()) + "' " + (Item3 == null ? string.Empty : Item3.ToString()) + "' " + (Item4 == null ? string.Empty : Item4.ToString()) + "' " + (Item5 == null ? string.Empty : Item5.ToString()) + "' " + (Item6 == null ? string.Empty : Item6.ToString()) + "' " + (Item7 == null ? string.Empty : Item7.ToString()) + "' " + rest.ToStringEnd(); " is 856.
Long Statement,System.Collections.Concurrent,BlockingCollection<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Collections\Concurrent\BlockingCollection.cs,AddToAny,The length of the statement  "                    throw new ArgumentException("At least one of collections has been marked as complete for adding."' nameof(collections)); " is 120.
Long Statement,System.Collections.Concurrent,BlockingCollection<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Collections\Concurrent\BlockingCollection.cs,AddToAny,The length of the statement  "                        throw new ArgumentException("At least one of collections has been marked as complete for adding."' nameof(collections)); " is 120.
Long Statement,System.Collections.Concurrent,BlockingCollection<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Collections\Concurrent\BlockingCollection.cs,TakeFromAny,The length of the statement  "                    throw new ArgumentException("At least one of collections has been marked as complete for adding."' nameof(collections)); " is 120.
Long Statement,System.Collections.Concurrent,BlockingCollection<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Collections\Concurrent\BlockingCollection.cs,TakeFromAny,The length of the statement  "                        throw new ArgumentException("At least one of collections has been marked as complete for adding."' nameof(collections)); " is 120.
Long Statement,System.Collections.Concurrent,BlockingCollection<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Collections\Concurrent\BlockingCollection.cs,TryAddToAny,The length of the statement  "                    throw new ArgumentException("At least one of collections has been marked as complete for adding."' nameof(collections)); " is 120.
Long Statement,System.Collections.Concurrent,BlockingCollection<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Collections\Concurrent\BlockingCollection.cs,TryAddToAny,The length of the statement  "                            throw new ArgumentException("At least one of collections has been marked as complete for adding."' nameof(collections)); " is 120.
Long Statement,System.Collections.Concurrent,BlockingCollection<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Collections\Concurrent\BlockingCollection.cs,TryAddToAny,The length of the statement  "                        throw new ArgumentException("At least one of collections has been marked as complete for adding."' nameof(collections)); " is 120.
Long Statement,System.Collections.Concurrent,BlockingCollection<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Collections\Concurrent\BlockingCollection.cs,TryTakeFromAny,The length of the statement  "                    throw new ArgumentException("At least one of collections has been marked as complete for adding."' nameof(collections)); " is 120.
Long Statement,System.Collections.Concurrent,BlockingCollection<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Collections\Concurrent\BlockingCollection.cs,TryTakeFromAny,The length of the statement  "                            throw new ArgumentException("At least one of collections has been marked as complete for adding."' nameof(collections)); " is 120.
Long Statement,System.Collections.Concurrent,BlockingCollection<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Collections\Concurrent\BlockingCollection.cs,TryTakeFromAny,The length of the statement  "                        throw new ArgumentException("At least one of collections has been marked as complete for adding."' nameof(collections)); " is 120.
Long Statement,System.Collections.Concurrent,PrivateData,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Collections\Concurrent\BlockingCollection.cs,TryAdd,The length of the statement  "                    throw new InvalidOperationException("The BlockingCollection<T> has been marked as complete with regards to additions."); " is 120.
Long Statement,System.Collections.Concurrent,PrivateData,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Collections\Concurrent\BlockingCollection.cs,TryAdd,The length of the statement  "                        throw new InvalidOperationException("The BlockingCollection<T> has been marked as complete with regards to additions."); " is 120.
Long Statement,System.Collections.Concurrent,PrivateData,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Collections\Concurrent\BlockingCollection.cs,TryTake,The length of the statement  "                    throw new InvalidOperationException("The underlying collection was modified outside this BlockingCollection<T> instance."); " is 123.
Long Statement,System.Collections.Concurrent,ConcurrentStack<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Collections\Concurrent\ConcurrentStack.cs,PushRange,The length of the statement  "                throw new ArgumentException("The sum of the startIndex and count arguments must be less than or equal to the collection's Count."); " is 131.
Long Statement,System.Collections.Concurrent,ConcurrentStack<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Collections\Concurrent\ConcurrentStack.cs,TryPopRange,The length of the statement  "                throw new ArgumentException("The sum of the startIndex and count arguments must be less than or equal to the collection's Count."); " is 131.
Long Statement,System.Collections.ObjectModel,ObservableCollection<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Collections\ObjectModel\ObservableCollection.cs,MoveItem,The length of the statement  "            InvokeCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Move' item!' newIndex' oldIndex)); " is 125.
Long Statement,System.Collections.ObjectModel,ObservableCollection<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Collections\ObjectModel\ObservableCollection.cs,SetItem,The length of the statement  "            InvokeCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Replace' item!' oldItem!' index)); " is 125.
Long Statement,System.ComponentModel.DataAnnotations,LocalizableString,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ComponentModel\DataAnnotations\LocalizableString.cs,GetCachedResult,The length of the statement  "            if (!resourceTypeInfo.IsVisible || property == null || property.PropertyType != typeof(string) || !IsGetterPublicAndStatic()) " is 125.
Long Statement,System.ComponentModel.DataAnnotations,LocalizableString,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ComponentModel\DataAnnotations\LocalizableString.cs,GetCachedResult,The length of the statement  "                return () => throw new InvalidOperationException($"Localization failed ({_propertyName}' {_resourceType.FullName}' _propertyValue)"); " is 133.
Long Statement,System.Diagnostics.Contracts,Contract,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Diagnostics\Contracts\Contract.bcl.cs,AssertMustUseRewriter,The length of the statement  "            ContractHelper.TriggerFailure(kind' $"The code has not been rewritten. ContractKind: {contractKind} - Source: {simpleName}"' null' null' null); " is 143.
Long Statement,System.Diagnostics.Contracts.Internal,ContractHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Diagnostics\Contracts\Internal\ContractHelper.cs,RaiseContractFailedEvent,The length of the statement  "            return Runtime.CompilerServices.ContractHelper.RaiseContractFailedEvent(failureKind' userMessage' conditionText' innerException); " is 129.
Long Statement,System.Diagnostics.Contracts.Internal,ContractHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Diagnostics\Contracts\Internal\ContractHelper.cs,TriggerFailure,The length of the statement  "            Runtime.CompilerServices.ContractHelper.TriggerFailure(kind' displayMessage' userMessage' conditionText' innerException); " is 121.
Long Statement,System.Dynamic,BindingRestrictions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\BindingRestrictions.cs,Combine,The length of the statement  "            return contributingObjects == null ? res : contributingObjects.Where(mo => mo != null).Aggregate(res' (current' mo) => current.Merge(mo.Restrictions)); " is 151.
Long Statement,System.Dynamic,CallInfo,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\CallInfo.cs,Equals,The length of the statement  "            return obj is CallInfo other && ArgumentCount == other.ArgumentCount && _argumentNames.ListEquals(other._argumentNames); " is 120.
Long Statement,System.Dynamic,DynamicMetaObject,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\DynamicMetaObject.cs,Create,The length of the statement  "                throw new InvalidOperationException($"An IDynamicMetaObjectProvider {ido.GetType()} created an invalid DynamicMetaObject instance."); " is 133.
Long Statement,System.Dynamic,DynamicMetaObjectBinder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\DynamicMetaObjectBinder.cs,Bind,The length of the statement  "                    throw new InvalidOperationException($"The result type '{expectedResult}' of the binder '{this}' is not compatible with the result type '{returnLabel.Type}' expected by the call site."); " is 185.
Long Statement,System.Dynamic,DynamicMetaObjectBinder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\DynamicMetaObjectBinder.cs,Bind,The length of the statement  "                    throw new InvalidCastException($"The result type '{body.Type}' of the dynamic binding produced by the object with type '{target.Value.GetType()}' for the binder '{this}' is not compatible with the result type '{expectedResult}' expected by the call site."); " is 257.
Long Statement,System.Dynamic,DynamicMetaObjectBinder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\DynamicMetaObjectBinder.cs,Bind,The length of the statement  "                throw new InvalidCastException($"The result type '{body.Type}' of the dynamic binding produced by binder '{this}' is not compatible with the result type '{expectedResult}' expected by the call site."); " is 201.
Long Statement,System.Dynamic,DynamicMetaObjectBinder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\DynamicMetaObjectBinder.cs,Bind,The length of the statement  "                throw new InvalidOperationException($"The result of the dynamic binding produced by the object with type '{target.Value?.GetType()}' for the binder '{this}' needs at least one restriction."); " is 191.
Long Statement,System.Dynamic,DynamicMetaObjectBinder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\DynamicMetaObjectBinder.cs,MakeDeferred,The length of the statement  "            var delegateType = DelegateHelper.GetDelegateTypeInternal(args.ConvertAll(ToType).Prepend(typeof(CallSite)).Append(ReturnType).ToArray()); " is 138.
Long Statement,System.Dynamic,MetaDynamic,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\DynamicObject.cs,BuildCallMethodWithResult,The length of the statement  "                var callArgs = method != CachedReflectionInfo.DynamicObjectTryBinaryOperation ? Expression.Parameter(typeof(object[])' null) : Expression.Parameter(typeof(object)' null); " is 170.
Long Statement,System.Dynamic,MetaDynamic,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\DynamicObject.cs,BuildCallMethodWithResult,The length of the statement  "                    var convertFailed = $"The result type '{{0}}' of the dynamic binding produced by the object with type '{Value!.GetType()}' for the binder '{binder.GetType()}' is not compatible with the result type '{binder.ReturnType}' expected by the call site."; " is 248.
Long Statement,System.Dynamic,MetaDynamic,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\DynamicObject.cs,BuildCallMethodWithResult,The length of the statement  "                            method != CachedReflectionInfo.DynamicObjectTryBinaryOperation ? Expression.Assign(callArgs' Expression.NewArrayInit(typeof(object)' callArgsValue)) : Expression.Assign(callArgs' callArgsValue[0])' " is 197.
Long Statement,System.Dynamic,MetaDynamic,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\DynamicObject.cs,GetLimitedSelf,The length of the statement  "                return TypeUtils.AreEquivalent(Expression.Type' typeof(DynamicObject)) ? Expression : Expression.Convert(Expression' typeof(DynamicObject)); " is 140.
Long Statement,System.Dynamic,MetaDynamic,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\DynamicObject.cs,IsOverridden,The length of the statement  "                return methods.Cast<MethodInfo>().Any(methodInfo => methodInfo.DeclaringType != typeof(DynamicObject) && methodInfo.GetBaseDefinition() == method); " is 147.
Long Statement,System.Dynamic,ExpandoObject,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\ExpandoObject.cs,CopyTo,The length of the statement  "                ContractUtils.RequiresArrayRange(array' arrayIndex' _count' nameof(arrayIndex)' nameof(ICollection<KeyValuePair<string' object>>.Count)); " is 137.
Long Statement,System.Dynamic,ExpandoObject,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\ExpandoObject.cs,TrySetValue,The length of the statement  "                    throw new ArgumentException($"An element with the same key '{name}' already exists in the ExpandoObject."' nameof(name)); " is 121.
Long Statement,System.Runtime.CompilerServices,AsyncTaskMethodBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Runtime\CompilerServices\AsyncTaskMethodBuilder.cs,SetException,The length of the statement  "            var setException = exception is OperationCanceledException ? completionSource.TrySetCanceled() : completionSource.TrySetException(exception); " is 141.
Long Statement,System.Runtime.CompilerServices,AsyncTaskMethodBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Runtime\CompilerServices\AsyncTaskMethodBuilder.cs,GetTaskForResult,The length of the statement  "            return asyncMethodTaskCache == null ? AsyncMethodTaskCache<TResult>.CreateCompleted(result) : asyncMethodTaskCache.FromResult(result); " is 134.
Long Statement,System.Runtime.CompilerServices,CallSiteHelpers,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Runtime\CompilerServices\CallSiteHelpers.cs,IsInternalFrame,The length of the statement  "            return string.Equals(mb.Name' CallSite.CallSiteTargetMethodName' StringComparison.Ordinal) && mb.GetType() != _knownNonDynamicMethodType; " is 137.
Long Statement,System.Runtime.CompilerServices,ConfiguredValueTaskAwaiter,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Runtime\CompilerServices\ConfiguredValueTaskAwaitable.cs,OnCompleted,The length of the statement  "                        ((IValueTaskSource)obj).OnCompleted(ValueTaskAwaiter.InvokeActionDelegate' continuation' _value.Token' (ValueTaskSourceOnCompletedFlags)(2 | (_value.ContinueOnCapturedContext ? 1 : 0))); " is 186.
Long Statement,System.Runtime.CompilerServices,ConfiguredValueTaskAwaiter,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Runtime\CompilerServices\ConfiguredValueTaskAwaitable.cs,UnsafeOnCompleted,The length of the statement  "                        ((IValueTaskSource)obj).OnCompleted(ValueTaskAwaiter.InvokeActionDelegate' continuation' _value.Token' _value.ContinueOnCapturedContext ? ValueTaskSourceOnCompletedFlags.UseSchedulingContext : ValueTaskSourceOnCompletedFlags.None); " is 231.
Long Statement,System.Runtime.CompilerServices,ConfiguredValueTaskAwaiter,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Runtime\CompilerServices\ConfiguredValueTaskAwaitable.cs,OnCompleted,The length of the statement  "                (_value._task ?? TaskEx.FromResult(_value._result)).ConfigureAwait(_continueOnCapturedContext).GetAwaiter().OnCompleted(continuation); " is 134.
Long Statement,System.Runtime.CompilerServices,ConfiguredValueTaskAwaiter,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Runtime\CompilerServices\ConfiguredValueTaskAwaitable.cs,UnsafeOnCompleted,The length of the statement  "                (_value._task ?? TaskEx.FromResult(_value._result)).ConfigureAwait(_continueOnCapturedContext).GetAwaiter().UnsafeOnCompleted(continuation); " is 140.
Long Statement,System.Runtime.CompilerServices,ContractHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Runtime\CompilerServices\ContractHelper.cs,RaiseContractFailedEvent,The length of the statement  "            RaiseContractFailedEventImplementation(failureKind' userMessage' conditionText' innerException' ref resultFailureMessage); " is 122.
Long Statement,System.Runtime.CompilerServices,ContractHelperEx,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Runtime\CompilerServices\ContractHelperEx.cs,GetFailureMessage,The length of the statement  "                    result = withCondition ? $"Postcondition failed after throwing an exception: {conditionText}" : "Postcondition failed after throwing an exception."; " is 148.
Long Statement,System.Runtime.CompilerServices,ReadOnlyCollectionBuilder<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Runtime\CompilerServices\ReadOnlyCollectionBuilder.cs,Add,The length of the statement  "                throw new ArgumentException($"The value null is not of type '{typeof(T)}' and cannot be used in this collection."' nameof(value)); " is 130.
Long Statement,System.Runtime.CompilerServices,ReadOnlyCollectionBuilder<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Runtime\CompilerServices\ReadOnlyCollectionBuilder.cs,Add,The length of the statement  "                throw new ArgumentException($"The value '{value?.GetType() as object ?? "null"}' is not of type '{typeof(T)}' and cannot be used in this collection."' nameof(value)); " is 166.
Long Statement,System.Runtime.CompilerServices,ReadOnlyCollectionBuilder<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Runtime\CompilerServices\ReadOnlyCollectionBuilder.cs,Insert,The length of the statement  "                throw new ArgumentException($"The value null is not of type '{typeof(T)}' and cannot be used in this collection."' nameof(value)); " is 130.
Long Statement,System.Runtime.CompilerServices,ReadOnlyCollectionBuilder<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Runtime\CompilerServices\ReadOnlyCollectionBuilder.cs,Insert,The length of the statement  "                throw new ArgumentException($"The value '{value?.GetType() as object ?? "null"}' is not of type '{typeof(T)}' and cannot be used in this collection."' nameof(value)); " is 166.
Long Statement,System.Runtime.CompilerServices,ValueTaskAwaiter,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Runtime\CompilerServices\ValueTaskAwaiter.cs,OnCompleted,The length of the statement  "                    ((IValueTaskSource)obj).OnCompleted(ValueTaskAwaiter.InvokeActionDelegate' continuation' _value.Token' ValueTaskSourceOnCompletedFlags.UseSchedulingContext | ValueTaskSourceOnCompletedFlags.FlowExecutionContext); " is 212.
Long Statement,System.Runtime.CompilerServices,ValueTaskAwaiter,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Runtime\CompilerServices\ValueTaskAwaiter.cs,UnsafeOnCompleted,The length of the statement  "                    ((IValueTaskSource)obj).OnCompleted(ValueTaskAwaiter.InvokeActionDelegate' continuation' _value.Token' ValueTaskSourceOnCompletedFlags.UseSchedulingContext); " is 157.
Long Statement,System.Dynamic.Utils,ExpressionUtils,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\Utils\ExpressionUtils.cs,ValidateArgumentTypes,The length of the statement  "            Debug.Assert(nodeKind == ExpressionType.Invoke || nodeKind == ExpressionType.Call || nodeKind == ExpressionType.Dynamic || nodeKind == ExpressionType.New); " is 155.
Long Statement,System.Dynamic.Utils,ExpressionUtils,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\Utils\ExpressionUtils.cs,ValidateOneArgument,The length of the statement  "                    throw new ArgumentException($"Expression of type '{arguments.Type}' cannot be used for constructor parameter of type '{pType}'"' index >= 0 ? $"{argumentParamName}[{index}]" : argumentParamName); " is 195.
Long Statement,System.Dynamic.Utils,ExpressionUtils,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\Utils\ExpressionUtils.cs,ValidateOneArgument,The length of the statement  "                    throw new ArgumentException($"Expression of type '{arguments.Type}' cannot be used for parameter of type '{pType}'"' index >= 0 ? $"{argumentParamName}[{index}]" : argumentParamName); " is 183.
Long Statement,System.Dynamic.Utils,ExpressionUtils,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\Utils\ExpressionUtils.cs,ValidateOneArgument,The length of the statement  "                    throw new ArgumentException($"Expression of type '{arguments.Type}' cannot be used for parameter of type '{pType}' of method '{method}'"' index >= 0 ? $"{argumentParamName}[{index}]" : argumentParamName); " is 204.
Long Statement,System.Dynamic.Utils,TypeUtils,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\Utils\TypeUtils.cs,GetStaticMethodInternal,The length of the statement  "            return Array.Find(type.GetMethods()' method => string.Equals(method.Name' name' StringComparison.Ordinal) && method.IsStatic && method.MatchesArgumentTypes(types)); " is 164.
Long Statement,System.Dynamic.Utils,TypeUtils,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\Utils\TypeUtils.cs,HasBuiltInEqualityOperator,The length of the statement  "            if (!left.IsValueType && !right.IsValueType && (left.IsReferenceAssignableFromInternal(right) || right.IsReferenceAssignableFromInternal(left))) " is 144.
Long Statement,System.Dynamic.Utils,TypeUtils,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\Utils\TypeUtils.cs,IsArrayTypeAssignableTo,The length of the statement  "            return type.GetArrayRank() == target.GetArrayRank() && type.GetElementType().IsAssignableToInternal(target.GetElementType()); " is 125.
Long Statement,System.Dynamic.Utils,TypeUtils,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\Utils\TypeUtils.cs,HasArrayToInterfaceConversion,The length of the statement  "            return _arrayAssignableInterfaces.Any(currentInterface => targetGen == currentInterface) && StrictHasReferenceConversionToInternal(source.GetElementType()' targetParams[0]' false); " is 180.
Long Statement,System.Dynamic.Utils,TypeUtils,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\Utils\TypeUtils.cs,HasInterfaceToArrayConversion,The length of the statement  "            return _arrayAssignableInterfaces.Any(currentInterface => sourceGen == currentInterface) && StrictHasReferenceConversionToInternal(sourceParams[0]' target.GetElementType()' false); " is 180.
Long Statement,System.Dynamic.Utils,TypeUtils,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\Utils\TypeUtils.cs,StrictHasReferenceConversionToInternal,The length of the statement  "                    return target.IsArray ? HasInterfaceToArrayConversion(source' target) || IsImplicitReferenceConversion(typeof(Array)' source) : IsLegalExplicitVariantDelegateConversion(source' target); " is 185.
Long Statement,System.Linq,Enumerable,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Enumerable.append.cs,GroupBy,The length of the statement  "            return new GroupedEnumerable<TSource' TKey' TSource>(source' keySelector' FuncHelper.GetIdentityFunc<TSource>()' comparer); " is 123.
Long Statement,System.Linq,Enumerable,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Enumerable.append.cs,GroupBy,The length of the statement  "            return new GroupedConvertedEnumerable<TSource' TKey' TSource' TResult>(source' keySelector' FuncHelper.GetIdentityFunc<TSource>()' resultSelector' comparer); " is 157.
Long Statement,System.Linq,Enumerable,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Enumerable.append.cs,CreateGroupByIterator,The length of the statement  "            return new GroupedEnumerable<TSource' TKey' TElement>(source' keySelector' elementSelector' comparer)/* as IEnumerable<IGrouping<TKey' TElement>>*/; " is 148.
Long Statement,System.Linq,Enumerable,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Enumerable.append.cs,CreateGroupByIterator,The length of the statement  "            return new GroupedConvertedEnumerable<TSource' TKey' TElement' TResult>(source' keySelector' elementSelector' resultSelector' comparer)/* as IEnumerable<TResult>*/; " is 164.
Long Statement,System.Linq,Queryable,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Queryable.cs,Cast,The length of the statement  "            return (IQueryable<TResult>)source.Provider.CreateQuery(StaticCall(MakeGeneric(MethodBase.GetCurrentMethod()' typeof(TResult))' source.Expression)); " is 148.
Long Statement,System.Linq,QueryableTransformer,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\QueryableTransformer.cs,ReplaceQueryableMethod,The length of the statement  "            throw new InvalidOperationException($"There is no method {method.Name} on type {targetType.FullName} that matches the specified arguments"); " is 140.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,AddAssignChecked,The length of the statement  "                return GetUserDefinedAssignOperatorOrThrow(ExpressionType.AddAssignChecked' "op_Addition"' left' right' conversion' true); " is 122.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,AndAlso,The length of the statement  "                    throw new InvalidOperationException($"The binary operator {ExpressionType.AndAlso} is not defined for the types '{left.Type}' and '{right.Type}'."); " is 148.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,AndAlso,The length of the statement  "                returnType = left.Type.IsNullable() && TypeUtils.AreEquivalent(method.ReturnType' left.Type.GetNonNullable()) ? left.Type : method.ReturnType; " is 142.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,AndAlso,The length of the statement  "            returnType = left.Type.IsNullable() && TypeUtils.AreEquivalent(method.ReturnType' left.Type.GetNonNullable()) ? left.Type : method.ReturnType; " is 142.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Coalesce,The length of the statement  "                throw new ArgumentException($"Incorrect number of arguments supplied for call to method '{conversion}'"' nameof(conversion)); " is 125.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Coalesce,The length of the statement  "                throw new InvalidOperationException($"The operands for operator '{ExpressionType.Coalesce}' do not match the parameters of method '{conversion}'."); " is 148.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Coalesce,The length of the statement  "                throw new InvalidOperationException($"The operands for operator '{ExpressionType.Coalesce}' do not match the parameters of method '{conversion}'."); " is 148.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Equal,The length of the statement  "            return method == null ? GetEqualityComparisonOperator(ExpressionType.Equal' "op_Equality"' left' right' liftToNull) : GetMethodBasedBinaryOperator(ExpressionType.Equal' left' right' method' liftToNull); " is 202.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ExclusiveOrAssign,The length of the statement  "                return GetUserDefinedAssignOperatorOrThrow(ExpressionType.ExclusiveOrAssign' "op_ExclusiveOr"' left' right' conversion' true); " is 126.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,GreaterThan,The length of the statement  "            return method == null ? GetComparisonOperator(ExpressionType.GreaterThan' "op_GreaterThan"' left' right' liftToNull) : GetMethodBasedBinaryOperator(ExpressionType.GreaterThan' left' right' method' liftToNull); " is 209.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,GreaterThanOrEqual,The length of the statement  "            return method == null ? GetComparisonOperator(ExpressionType.GreaterThanOrEqual' "op_GreaterThanOrEqual"' left' right' liftToNull) : GetMethodBasedBinaryOperator(ExpressionType.GreaterThanOrEqual' left' right' method' liftToNull); " is 230.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,LeftShiftAssign,The length of the statement  "                return GetUserDefinedAssignOperatorOrThrow(ExpressionType.LeftShiftAssign' "op_LeftShift"' left' right' conversion' true); " is 122.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,LessThan,The length of the statement  "            return method == null ? GetComparisonOperator(ExpressionType.LessThan' "op_LessThan"' left' right' liftToNull) : GetMethodBasedBinaryOperator(ExpressionType.LessThan' left' right' method' liftToNull); " is 200.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,LessThanOrEqual,The length of the statement  "            return method == null ? GetComparisonOperator(ExpressionType.LessThanOrEqual' "op_LessThanOrEqual"' left' right' liftToNull) : GetMethodBasedBinaryOperator(ExpressionType.LessThanOrEqual' left' right' method' liftToNull); " is 221.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,MultiplyAssign,The length of the statement  "                return GetUserDefinedAssignOperatorOrThrow(ExpressionType.MultiplyAssign' "op_Multiply"' left' right' conversion' true); " is 120.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,MultiplyAssignChecked,The length of the statement  "                return GetUserDefinedAssignOperatorOrThrow(ExpressionType.MultiplyAssignChecked' "op_Multiply"' left' right' conversion' true); " is 127.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,NotEqual,The length of the statement  "            return method == null ? GetEqualityComparisonOperator(ExpressionType.NotEqual' "op_Inequality"' left' right' liftToNull) : GetMethodBasedBinaryOperator(ExpressionType.NotEqual' left' right' method' liftToNull); " is 210.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,OrElse,The length of the statement  "                    throw new InvalidOperationException($"The binary operator {ExpressionType.OrElse} is not defined for the types '{left.Type}' and '{right.Type}'."); " is 147.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Power,The length of the statement  "                        throw new InvalidOperationException($"The binary operator {ExpressionType.Power} is not defined for the types '{left.Type}' and '{right.Type}'."); " is 146.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,PowerAssign,The length of the statement  "                throw new InvalidOperationException($"The binary operator {ExpressionType.PowerAssign} is not defined for the types '{left.Type}' and '{right.Type}'."); " is 152.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ReferenceEqual,The length of the statement  "            throw new InvalidOperationException($"Reference equality is not defined for the types '{left.Type}' and '{right.Type}'."); " is 122.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ReferenceNotEqual,The length of the statement  "            throw new InvalidOperationException($"Reference equality is not defined for the types '{left.Type}' and '{right.Type}'."); " is 122.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,RightShiftAssign,The length of the statement  "                return GetUserDefinedAssignOperatorOrThrow(ExpressionType.RightShiftAssign' "op_RightShift"' left' right' conversion' true); " is 124.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,SubtractAssign,The length of the statement  "                return GetUserDefinedAssignOperatorOrThrow(ExpressionType.SubtractAssign' "op_Subtraction"' left' right' conversion' true); " is 123.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,SubtractAssignChecked,The length of the statement  "                return GetUserDefinedAssignOperatorOrThrow(ExpressionType.SubtractAssignChecked' "op_Subtraction"' left' right' conversion' true); " is 130.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,GetEqualityComparisonOperator,The length of the statement  "                throw new InvalidOperationException($"The binary operator {binaryType} is not defined for the types '{left.Type}' and '{right.Type}'."); " is 136.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,GetMethodBasedAssignOperator,The length of the statement  "                    throw new ArgumentException($"The user-defined operator method '{bMethod.Name}' for operator '{binaryType}' must return the same type as its parameter or a derived type."); " is 172.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,GetMethodBasedBinaryOperator,The length of the statement  "            if (!left.Type.IsNullable() || !right.Type.IsNullable() || !ParameterIsAssignable(pms[0]' left.Type.GetNonNullable()) || !ParameterIsAssignable(pms[1]' right.Type.GetNonNullable()) || !method.ReturnType.IsValueType || method.ReturnType.IsNullable()) " is 249.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,GetMethodBasedBinaryOperator,The length of the statement  "                throw new InvalidOperationException($"The operands for operator '{binaryType}' do not match the parameters of method '{method.Name}'."); " is 136.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,GetUserDefinedAssignOperatorOrThrow,The length of the statement  "                    throw new ArgumentException($"The user-defined operator method '{bMethod.Name}' for operator '{binaryType}' must return the same type as its parameter or a derived type."); " is 172.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,GetUserDefinedBinaryOperatorOrThrow,The length of the statement  "                throw new InvalidOperationException($"The binary operator {binaryType} is not defined for the types '{left.Type}' and '{right.Type}'."); " is 136.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,IsValidLiftedConditionalLogicalOperator,The length of the statement  "            return TypeUtils.AreEquivalent(left' right) && right.IsNullable() && TypeUtils.AreEquivalent(pms[1].ParameterType' right.GetNonNullable()); " is 139.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateOpAssignConversionLambda,The length of the statement  "                throw new ArgumentException($"Incorrect number of arguments supplied for call to method '{conversion}'"' nameof(conversion)); " is 125.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateOpAssignConversionLambda,The length of the statement  "                throw new InvalidOperationException($"The operands for operator '{nodeType}' do not match the parameters of method '{conversion}'."); " is 133.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateOpAssignConversionLambda,The length of the statement  "                throw new InvalidOperationException($"The return type of overload method for operator '{nodeType}' does not match the parameter type of conversion method '{conversion}'."); " is 172.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateParamsWithOperandsOrThrow,The length of the statement  "                throw new InvalidOperationException($"The operands for operator '{exprType}' do not match the parameters of method '{name}'."); " is 127.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateUserDefinedConditionalLogicOperator,The length of the statement  "            if (!ParameterIsAssignable(pms[0]' left) && !(left.IsNullable() && ParameterIsAssignable(pms[0]' left.GetNonNullable()))) " is 121.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateUserDefinedConditionalLogicOperator,The length of the statement  "                throw new InvalidOperationException($"The operands for operator '{nodeType}' do not match the parameters of method '{method.Name}'."); " is 134.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateUserDefinedConditionalLogicOperator,The length of the statement  "            if (!ParameterIsAssignable(pms[1]' right) && !(right.IsNullable() && ParameterIsAssignable(pms[1]' right.GetNonNullable()))) " is 124.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateUserDefinedConditionalLogicOperator,The length of the statement  "                throw new InvalidOperationException($"The operands for operator '{nodeType}' do not match the parameters of method '{method.Name}'."); " is 134.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateUserDefinedConditionalLogicOperator,The length of the statement  "                throw new ArgumentException($"The user-defined operator method '{method.Name}' for operator '{nodeType}' must have identical parameter and return types."); " is 155.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateUserDefinedConditionalLogicOperator,The length of the statement  "                throw new ArgumentException($"The user-defined operator method '{method.Name}' for operator '{nodeType}' must have identical parameter and return types."); " is 155.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateUserDefinedConditionalLogicOperator,The length of the statement  "                throw new ArgumentException($"The user-defined operator method '{method.Name}' for operator '{nodeType}' must have associated boolean True and False operators."); " is 162.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateUserDefinedConditionalLogicOperator,The length of the statement  "                throw new ArgumentException($"The user-defined operator method '{method.Name}' for operator '{nodeType}' must have associated boolean True and False operators."); " is 162.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,VerifyOpTrueFalse,The length of the statement  "            if (!ParameterIsAssignable(pmsOpTrue[0]' left) && !(left.IsNullable() && ParameterIsAssignable(pmsOpTrue[0]' left.GetNonNullable()))) " is 133.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,VerifyOpTrueFalse,The length of the statement  "                throw new InvalidOperationException($"The operands for operator '{nodeType}' do not match the parameters of method '{opTrue.Name}'."); " is 134.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Block,The length of the statement  "            return lastExpression.Type == type ? GetOptimizedBlockExpression(expressionList) : BlockCore(type' variableList' expressionList); " is 129.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateVariables,The length of the statement  "                    throw new ArgumentException($"Variable '{v}' uses unsupported type '{v.Type}'. Reference types are not supported for variables."' i >= 0 ? $"{collectionName}[{i}]" : collectionName); " is 182.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateVariables,The length of the statement  "                    throw new ArgumentException($"Found duplicate parameter '{v}'. Each ParameterExpression in the list must be a unique object."' i >= 0 ? $"{collectionName}[{i}]" : collectionName); " is 179.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,MakeCatchBlock,The length of the statement  "                throw new ArgumentException($"Variable '{variable}' uses unsupported type '{variable.Type}'. Reference types are not supported for variables."' nameof(variable)); " is 162.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Condition,The length of the statement  "            if (type != typeof(void) && (!type.IsReferenceAssignableFromInternal(ifTrue.Type) || !type.IsReferenceAssignableFromInternal(ifFalse.Type))) " is 140.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateSpan,The length of the statement  "                throw new ArgumentOutOfRangeException(nameof(startColumn)' $"{nameof(startColumn)} must be greater than or equal to {1}"); " is 122.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateElementInitAddMethodInfo,The length of the statement  "                    throw new ArgumentException($"Parameter '{pi.Name}' of element initializer method '{addMethod.Name}' must not be a pass by reference parameter"' paramName); " is 156.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateGotoType,The length of the statement  "            if (expectedType != typeof(void) && !expectedType.IsReferenceAssignableFromInternal(value.Type) && !TryQuote(expectedType' ref value)) " is 134.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,FindInstanceProperty,The length of the statement  "                throw new ArgumentException($"Instance property '{propertyName}' that takes no argument is not defined for type '{type}'"); " is 123.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,FindInstanceProperty,The length of the statement  "            throw new ArgumentException($"Instance property '{propertyName}{GetArgTypesString(arguments)}' is not defined for type '{type}'"' nameof(propertyName)); " is 152.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,FindProperty,The length of the statement  "                    throw new InvalidOperationException($"More than one property '{propertyName}' on type '{type}' is compatible with the supplied arguments."); " is 140.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateAccessor,The length of the statement  "                    throw new ArgumentException("Static property requires null instance' non-static property requires non-null instance."' nameof(instance)); " is 137.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateAccessor,The length of the statement  "                    throw new ArgumentException("Static property requires null instance' non-static property requires non-null instance."' nameof(instance)); " is 137.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateAccessorArgumentTypes,The length of the statement  "                        throw new ArgumentException("Accessor indexes cannot be passed ByRef."' i >= 0 ? $"{nameof(indexes)}[{i}]" : nameof(indexes)); " is 126.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateAccessorArgumentTypes,The length of the statement  "                        throw new ArgumentException($"Expression of type '{arg.Type}' cannot be used for parameter of type '{pType}' of method '{method}'"' i >= 0 ? $"{nameof(arguments)}[{i}]" : nameof(arguments)); " is 190.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Invoke,The length of the statement  "            // COMPAT: This method is marked as non-public to avoid a gap between a 0-ary and 2-ary overload (see remark for the unary case below). " is 135.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,GetActionType,The length of the statement  "                        throw new ArgumentException("An incorrect number of type args were specified for the declaration of an Action type."' nameof(typeArgs)); " is 136.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,GetFuncType,The length of the statement  "                        throw new ArgumentException("An incorrect number of type args were specified for the declaration of a Func type."' nameof(typeArgs)); " is 133.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,CreateLambda,The length of the statement  "            var factories = TypeHelper.LazyCreate(ref _lambdaFactories' () => new CacheDict<Type' Func<Expression' string?' bool' ParameterExpression[]' LambdaExpression>>(50)); " is 165.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,CreateLambda,The length of the statement  "            var create = typeof(Expression<>).MakeGenericType(delegateType).GetMethod("Create"' BindingFlags.Static | BindingFlags.NonPublic); " is 130.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,LambdaExtracted,The length of the statement  "                        throw new ArgumentException($"Found duplicate parameter '{param}'. Each ParameterExpression in the list must be a unique object."' i >= 0 ? $"{nameof(parameters)}[{i}]" : nameof(parameters)); " is 191.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateLambdaArgs,The length of the statement  "                            throw new ArgumentException($"ParameterExpression of type '{pex.Type.MakeByRefType()}' cannot be used for delegate parameter of type '{pType}'"); " is 145.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateLambdaArgs,The length of the statement  "                        throw new ArgumentException($"ParameterExpression of type '{pex.Type}' cannot be used for delegate parameter of type '{pType}'"); " is 129.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateLambdaArgs,The length of the statement  "                        throw new ArgumentException($"Found duplicate parameter '{pex}'. Each ParameterExpression in the list must be a unique object."' i >= 0 ? $"{nameof(parameters)}[{i}]" : nameof(parameters)); " is 189.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateLambdaArgs,The length of the statement  "            if (mi.ReturnType != typeof(void) && !mi.ReturnType.IsReferenceAssignableFromInternal(body.Type) && !TryQuote(mi.ReturnType' ref body)) " is 135.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ListInitExtracted,The length of the statement  "            var addMethod = FindMethod(newExpression.Type' "Add"' null' new[] { initializerList[0] }' BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic); " is 160.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Field,The length of the statement  "                    throw new ArgumentException("Static field requires null instance' non-static field requires non-null instance."' nameof(expression)); " is 133.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Field,The length of the statement  "                    throw new ArgumentException("Static field requires null instance' non-static field requires non-null instance."' nameof(field)); " is 128.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Field,The length of the statement  "            var fi = expression.Type.GetField(fieldName' BindingFlags.Instance | BindingFlags.Public | BindingFlags.IgnoreCase | BindingFlags.FlattenHierarchy) " is 147.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Field,The length of the statement  "                     ?? expression.Type.GetField(fieldName' BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.IgnoreCase | BindingFlags.FlattenHierarchy); " is 145.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Field,The length of the statement  "            var fi = type.GetField(fieldName' BindingFlags.Static | BindingFlags.Instance | BindingFlags.Public | BindingFlags.IgnoreCase | BindingFlags.FlattenHierarchy) " is 158.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Field,The length of the statement  "                     ?? type.GetField(fieldName' BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.IgnoreCase | BindingFlags.FlattenHierarchy); " is 156.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Property,The length of the statement  "            var pi = expression.Type.GetProperty(propertyName' BindingFlags.Instance | BindingFlags.Public | BindingFlags.IgnoreCase | BindingFlags.FlattenHierarchy) " is 153.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Property,The length of the statement  "                     ?? expression.Type.GetProperty(propertyName' BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.IgnoreCase | BindingFlags.FlattenHierarchy); " is 151.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Property,The length of the statement  "                throw new ArgumentException($"Instance property '{propertyName}' is not defined for type '{expression.Type}'"' nameof(propertyName)); " is 133.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Property,The length of the statement  "            var pi = type.GetProperty(propertyName' BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.IgnoreCase | BindingFlags.FlattenHierarchy) " is 164.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Property,The length of the statement  "                     ?? type.GetProperty(propertyName' BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.IgnoreCase | BindingFlags.FlattenHierarchy); " is 162.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Property,The length of the statement  "                    throw new ArgumentException("Static property requires null instance' non-static property requires non-null instance."' nameof(expression)); " is 139.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Property,The length of the statement  "                    throw new ArgumentException("Static property requires null instance' non-static property requires non-null instance."' nameof(property)); " is 137.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,PropertyOrField,The length of the statement  "            var pi = expression.Type.GetProperty(propertyOrFieldName' BindingFlags.Instance | BindingFlags.Public | BindingFlags.IgnoreCase | BindingFlags.FlattenHierarchy); " is 161.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,PropertyOrField,The length of the statement  "            var fi = expression.Type.GetField(propertyOrFieldName' BindingFlags.Instance | BindingFlags.Public | BindingFlags.IgnoreCase | BindingFlags.FlattenHierarchy); " is 158.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,PropertyOrField,The length of the statement  "            pi = expression.Type.GetProperty(propertyOrFieldName' BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.IgnoreCase | BindingFlags.FlattenHierarchy); " is 160.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,PropertyOrField,The length of the statement  "            fi = expression.Type.GetField(propertyOrFieldName' BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.IgnoreCase | BindingFlags.FlattenHierarchy); " is 157.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,PropertyOrField,The length of the statement  "            throw new ArgumentException($"{propertyOrFieldName}' is not a member of type '{expression.Type}'"' nameof(propertyOrFieldName)); " is 128.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,CheckMethod,The length of the statement  "            return type?.IsInterface == true && string.Equals(method.Name' propertyMethod.Name' StringComparison.Ordinal) && type.GetMethod(method.Name) == propertyMethod; " is 159.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,GetProperty,The length of the statement  "                throw new ArgumentException($"The method '{mi.DeclaringType}.{mi.Name}' is not a property accessor"' index >= 0 ? $"{paramName}[{index}]" : paramName); " is 151.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,GetProperty,The length of the statement  "            throw new ArgumentException($"The method '{mi.DeclaringType}.{mi.Name}' is not a property accessor"' index >= 0 ? $"{paramName}[{index}]" : paramName); " is 151.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateMemberInitArgs,The length of the statement  "                    throw new ArgumentException($"{b.Member.Name}' is not a member of type '{type}'"' i >= 0 ? $"{nameof(bindings)}[{i}]" : nameof(bindings)); " is 138.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Call,The length of the statement  "            const BindingFlags flags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy; " is 128.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Call,The length of the statement  "            const BindingFlags flags = BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy; " is 126.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ArrayIndexExtracted,The length of the statement  "                    throw new ArgumentException("Argument for array index must be of type Int32"' i >= 0 ? $"{paramName}[{i}]" : paramName); " is 120.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,FindMethod,The length of the statement  "                    throw new InvalidOperationException($"No generic method '{methodName}' on type '{type}' is compatible with the supplied type arguments and arguments. No type arguments should be provided if the method is non-generic. "); " is 220.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,FindMethod,The length of the statement  "                throw new InvalidOperationException($"No method '{methodName}' on type '{type}' is compatible with the supplied arguments."); " is 125.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,FindMethod,The length of the statement  "                throw new InvalidOperationException($"More than one method '{methodName}' on type '{type}' is compatible with the supplied arguments."); " is 136.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,IsCompatible,The length of the statement  "                if (pType?.IsReferenceAssignableFromInternal(argType) == false && !(pType.IsSameOrSubclassOfInternal(typeof(LambdaExpression)) && pType.IsInstanceOfType(arg))) " is 159.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateCallInstanceType,The length of the statement  "                throw new ArgumentException($"Method '{method}' declared on type '{method.DeclaringType}' cannot be called with instance of type '{instanceType}'"); " is 148.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,NewArrayInitExtracted,The length of the statement  "                        throw new InvalidOperationException($"An expression of type '{expr.Type}' cannot be used to initialize an array of type '{type}'"); " is 131.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,New,The length of the statement  "            ContractUtils.RequiresNotNull(constructor.DeclaringType' nameof(constructor) + "." + nameof(constructor.DeclaringType)); " is 120.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,New,The length of the statement  "            ContractUtils.RequiresNotNull(constructor.DeclaringType' nameof(constructor) + "." + nameof(constructor.DeclaringType)); " is 120.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,New,The length of the statement  "            var ci = type.GetConstructors(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic).SingleOrDefault(c => c.GetParameters().Length == 0); " is 152.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateAnonymousTypeMember,The length of the statement  "                    throw new ArgumentException($"The property '{pi}' has no 'get' accessor"' index >= 0 ? $"{paramName}[{index}]" : paramName); " is 124.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateAnonymousTypeMember,The length of the statement  "                    throw new ArgumentException("Argument must be either a FieldInfo' PropertyInfo or MethodInfo"' index >= 0 ? $"{paramName}[{index}]" : paramName); " is 145.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateNewArgs,The length of the statement  "                        throw new ArgumentException($" The member '{member.Name}' is not declared on type '{constructor.DeclaringType?.Name}' being created"' i >= 0 ? $"{nameof(members)}[{i}]" : nameof(members)); " is 188.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateNewArgs,The length of the statement  "                        throw new ArgumentException($" Argument type '{arg.Type}' does not match the corresponding member type '{memberType}'"' i >= 0 ? $"{nameof(arguments)}[{i}]" : nameof(arguments)); " is 178.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateNewArgs,The length of the statement  "                        throw new ArgumentException($"Expression of type '{arg.Type}' cannot be used for constructor parameter of type '{pType}'"' i >= 0 ? $"{nameof(arguments)}[{i}]" : nameof(arguments)); " is 181.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,SwitchExtracted,The length of the statement  "            var resultType = type ?? (caseArray.Length != 0 ? caseArray[0].Body.Type : defaultBody != null ? defaultBody.Type : typeof(void)); " is 130.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,SwitchExtracted,The length of the statement  "                    throw new ArgumentException($"Incorrect number of arguments supplied for call to method '{comparison}'"' nameof(comparison)); " is 125.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,SwitchExtracted,The length of the statement  "                        throw new ArgumentException($"Switch value of type '{switchValue.Type}' cannot be used for the comparison method parameter of type '{leftParam.ParameterType}'"); " is 161.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,SwitchExtracted,The length of the statement  "                                throw new ArgumentException($"Test value of type '{rightOperandType}' cannot be used for the comparison method parameter of type '{rightParam.ParameterType}'"); " is 160.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,SwitchExtracted,The length of the statement  "                            throw new ArgumentException($"Test value of type '{rightOperandType}' cannot be used for the comparison method parameter of type '{rightParam.ParameterType}'"); " is 160.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,SwitchExtracted,The length of the statement  "                    throw new ArgumentException($"The user-defined equality method '{comparison}' must return a boolean value."' nameof(comparison)); " is 129.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Convert,The length of the statement  "            if (expression.Type.HasIdentityPrimitiveOrNullableConversionToInternal(type) || expression.Type.HasReferenceConversionToInternal(type)) " is 135.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,TypeAs,The length of the statement  "                throw new ArgumentException($"The type used in TypeAs Expression must be of reference or nullable type' {type} is neither"' nameof(type)); " is 138.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,UnaryPlus,The length of the statement  "            return expression.Type.IsArithmetic() ? new UnaryExpression(ExpressionType.UnaryPlus' expression' expression.Type' null) : GetUserDefinedUnaryOperatorOrThrow(ExpressionType.UnaryPlus' "op_UnaryPlus"' expression); " is 212.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,GetMethodBasedCoercionOperator,The length of the statement  "            throw new InvalidOperationException($"The operands for operator '{unaryType}' do not match the parameters of method '{method.Name}'."); " is 135.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,GetMethodBasedUnaryOperator,The length of the statement  "            throw new InvalidOperationException($"The operands for operator '{unaryType}' do not match the parameters of method '{method.Name}'."); " is 135.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,GetUserDefinedCoercionOrThrow,The length of the statement  "            throw new InvalidOperationException($"No coercion operator is defined between types '{expression.Type}' and '{convertToType}'."); " is 129.
Long Statement,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,MakeOpAssignUnary,The length of the statement  "                throw new ArgumentException($"The user-defined operator method '{method?.Name}' for operator '{kind}' must return the same type as its parameter or a derived type."); " is 166.
Long Statement,System.Linq.Expressions,DebugViewWriter,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DebugViewWriter.cs,NeedsParentheses,The length of the statement  "            if (child.NodeType == ExpressionType.Constant && (parent.NodeType == ExpressionType.Negate || parent.NodeType == ExpressionType.NegateChecked)) " is 143.
Long Statement,System.Linq.Expressions,DynamicExpression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,Make,The length of the statement  "            return returnType == typeof(object) ? new DynamicExpressionN(delegateType' binder' arguments) : new TypedDynamicExpressionN(returnType' delegateType' binder' arguments); " is 169.
Long Statement,System.Linq.Expressions,DynamicExpression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,Make,The length of the statement  "            return returnType == typeof(object) ? new DynamicExpression1(delegateType' binder' arg0) : new TypedDynamicExpression1(returnType' delegateType' binder' arg0); " is 159.
Long Statement,System.Linq.Expressions,DynamicExpression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,Make,The length of the statement  "            return returnType == typeof(object) ? new DynamicExpression2(delegateType' binder' arg0' arg1) : new TypedDynamicExpression2(returnType' delegateType' binder' arg0' arg1); " is 171.
Long Statement,System.Linq.Expressions,DynamicExpression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,Make,The length of the statement  "            return returnType == typeof(object) ? new DynamicExpression3(delegateType' binder' arg0' arg1' arg2) : new TypedDynamicExpression3(returnType' delegateType' binder' arg0' arg1' arg2); " is 183.
Long Statement,System.Linq.Expressions,DynamicExpression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,Make,The length of the statement  "            return returnType == typeof(object) ? new DynamicExpression4(delegateType' binder' arg0' arg1' arg2' arg3) : new TypedDynamicExpression4(returnType' delegateType' binder' arg0' arg1' arg2' arg3); " is 195.
Long Statement,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,Dynamic,The length of the statement  "            var delegateType = DelegateHelper.GetDelegateTypeInternal(typeof(CallSite)' arg0.Type' arg1.Type' arg2.Type' returnType); " is 121.
Long Statement,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,Dynamic,The length of the statement  "            var delegateType = DelegateHelper.GetDelegateTypeInternal(typeof(CallSite)' arg0.Type' arg1.Type' arg2.Type' arg3.Type' returnType); " is 132.
Long Statement,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,MakeDynamic,The length of the statement  "            ExpressionUtils.ValidateOneArgument(method' ExpressionType.Dynamic' arg0' parameters[1]' nameof(delegateType)' nameof(arg0)); " is 125.
Long Statement,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,MakeDynamic,The length of the statement  "            ExpressionUtils.ValidateOneArgument(method' ExpressionType.Dynamic' arg0' parameters[1]' nameof(delegateType)' nameof(arg0)); " is 125.
Long Statement,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,MakeDynamic,The length of the statement  "            ExpressionUtils.ValidateOneArgument(method' ExpressionType.Dynamic' arg1' parameters[2]' nameof(delegateType)' nameof(arg1)); " is 125.
Long Statement,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,MakeDynamic,The length of the statement  "            ExpressionUtils.ValidateOneArgument(method' ExpressionType.Dynamic' arg0' parameters[1]' nameof(delegateType)' nameof(arg0)); " is 125.
Long Statement,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,MakeDynamic,The length of the statement  "            ExpressionUtils.ValidateOneArgument(method' ExpressionType.Dynamic' arg1' parameters[2]' nameof(delegateType)' nameof(arg1)); " is 125.
Long Statement,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,MakeDynamic,The length of the statement  "            ExpressionUtils.ValidateOneArgument(method' ExpressionType.Dynamic' arg2' parameters[3]' nameof(delegateType)' nameof(arg2)); " is 125.
Long Statement,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,MakeDynamic,The length of the statement  "            ExpressionUtils.ValidateOneArgument(method' ExpressionType.Dynamic' arg0' parameters[1]' nameof(delegateType)' nameof(arg0)); " is 125.
Long Statement,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,MakeDynamic,The length of the statement  "            ExpressionUtils.ValidateOneArgument(method' ExpressionType.Dynamic' arg1' parameters[2]' nameof(delegateType)' nameof(arg1)); " is 125.
Long Statement,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,MakeDynamic,The length of the statement  "            ExpressionUtils.ValidateOneArgument(method' ExpressionType.Dynamic' arg2' parameters[3]' nameof(delegateType)' nameof(arg2)); " is 125.
Long Statement,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,MakeDynamic,The length of the statement  "            ExpressionUtils.ValidateOneArgument(method' ExpressionType.Dynamic' arg3' parameters[4]' nameof(delegateType)' nameof(arg3)); " is 125.
Long Statement,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,MakeDynamic,The length of the statement  "            var delegateType = DelegateHelper.GetDelegateTypeInternal(arguments.ConvertAll(exp => exp.Type).Prepend(typeof(CallSite)).Append(returnType).ToArray()); " is 152.
Long Statement,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,MakeDynamic,The length of the statement  "                case 4: return DynamicExpression.Make(returnType' delegateType' binder' arguments[0]' arguments[1]' arguments[2]' arguments[3]); " is 128.
Long Statement,System.Linq.Expressions,ExpressionTransformer,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\ExpressionTransformer.cs,VisitBinary,The length of the statement  "                return b.NodeType == ExpressionType.Coalesce && b.Conversion != null ? Expression.Coalesce(left' right' conversion as LambdaExpression) : Expression.MakeBinary(b.NodeType' left' right' b.IsLiftedToNull' b.Method); " is 213.
Long Statement,System.Linq.Expressions,ExpressionVisitor,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\ExpressionVisitor.cs,VisitAndConvert,The length of the statement  "            throw new InvalidOperationException($"When called from '{callerName}'' rewriting a node of type '{typeof(T)}' must return a non-null value of the same type. Alternatively' override '{callerName}' and change it to not visit children of this type."); " is 248.
Long Statement,System.Linq.Expressions,ExpressionVisitor,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\ExpressionVisitor.cs,VisitAndConvert,The length of the statement  "                    throw new InvalidOperationException($"When called from '{callerName}'' rewriting a node of type '{typeof(T)}' must return a non-null value of the same type. Alternatively' override '{callerName}' and change it to not visit children of this type."); " is 248.
Long Statement,System.Linq.Expressions,ExpressionVisitor,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\ExpressionVisitor.cs,ValidateBinary,The length of the statement  "                throw new InvalidOperationException($"Rewritten expression calls operator method '{after.Method}'' but the original node had no operator method. If this is is intentional' override '{nameof(VisitBinary)}' and change it to allow this rewrite."); " is 244.
Long Statement,System.Linq.Expressions,ExpressionVisitor,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\ExpressionVisitor.cs,ValidateChildType,The length of the statement  "            throw new InvalidOperationException($"Rewriting child expression from type '{before}' to type '{after}' is not allowed' because it would change the meaning of the operation. If this is intentional' override '{methodName}' and change it to allow this rewrite."); " is 261.
Long Statement,System.Linq.Expressions,ExpressionVisitor,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\ExpressionVisitor.cs,ValidateSwitch,The length of the statement  "                throw new InvalidOperationException($"Rewritten expression calls operator method '{after.Comparison}'' but the original node had no operator method. If this is is intentional' override '{nameof(VisitSwitch)}' and change it to allow this rewrite."); " is 248.
Long Statement,System.Linq.Expressions,ExpressionVisitor,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\ExpressionVisitor.cs,ValidateUnary,The length of the statement  "                throw new InvalidOperationException($"Rewritten expression calls operator method '{after.Method}'' but the original node had no operator method. If this is is intentional' override '{nameof(VisitUnary)}' and change it to allow this rewrite."); " is 243.
Long Statement,System.Linq.Expressions,ExpressionVisitor,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\ExpressionVisitor.cs,VisitCatchBlockExtracted,The length of the statement  "            return node.Update(node.Variable == null ? null : VisitAndConvert(node.Variable' nameof(VisitCatchBlock))' Visit(node.Filter)' Visit(node.Body)); " is 145.
Long Statement,System.Linq.Expressions,InvocationExpression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\InvocationExpression.cs,Update,The length of the statement  "            if (expression == Expression && arguments != null && ExpressionUtils.SameElements(ref arguments' Arguments.AsArrayInternal())) " is 126.
Long Statement,System.Linq.Expressions,InvocationExpression2,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\InvocationExpression.cs,Rewrite,The length of the statement  "            return arguments != null ? Invoke(lambda' arguments[0]' arguments[1]) : Invoke(lambda' ExpressionUtils.ReturnObject<Expression>(_arg0)' _arg1); " is 143.
Long Statement,System.Linq.Expressions,InvocationExpression3,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\InvocationExpression.cs,Rewrite,The length of the statement  "            return arguments != null ? Invoke(lambda' arguments[0]' arguments[1]' arguments[2]) : Invoke(lambda' ExpressionUtils.ReturnObject<Expression>(_arg0)' _arg1' _arg2); " is 164.
Long Statement,System.Linq.Expressions,InvocationExpression4,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\InvocationExpression.cs,Rewrite,The length of the statement  "            return arguments != null ? Invoke(lambda' arguments[0]' arguments[1]' arguments[2]' arguments[3]) : Invoke(lambda' ExpressionUtils.ReturnObject<Expression>(_arg0)' _arg1' _arg2' _arg3); " is 185.
Long Statement,System.Linq.Expressions,InvocationExpression5,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\InvocationExpression.cs,Rewrite,The length of the statement  "            return arguments != null ? Invoke(lambda' arguments[0]' arguments[1]' arguments[2]' arguments[3]' arguments[4]) : Invoke(lambda' ExpressionUtils.ReturnObject<Expression>(_arg0)' _arg1' _arg2' _arg3' _arg4); " is 206.
Long Statement,System.Linq.Expressions,Expression1<TDelegate>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\LambdaExpression.cs,Rewrite,The length of the statement  "            return parameters != null ? Lambda<TDelegate>(body' parameters) : Lambda<TDelegate>(body' ExpressionUtils.ReturnObject<ParameterExpression>(_par0)); " is 148.
Long Statement,System.Linq.Expressions,Expression2<TDelegate>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\LambdaExpression.cs,Rewrite,The length of the statement  "            return parameters != null ? Lambda<TDelegate>(body' parameters) : Lambda<TDelegate>(body' ExpressionUtils.ReturnObject<ParameterExpression>(_par0)' _par1); " is 155.
Long Statement,System.Linq.Expressions,Expression3<TDelegate>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\LambdaExpression.cs,Rewrite,The length of the statement  "            return parameters != null ? Lambda<TDelegate>(body' parameters) : Lambda<TDelegate>(body' ExpressionUtils.ReturnObject<ParameterExpression>(_par0)' _par1' _par2); " is 162.
Long Statement,System.Linq.Expressions,ListInitExpression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\ListInitExpression.cs,Update,The length of the statement  "            if (newExpression == NewExpression && initializers != null && ExpressionUtils.SameElements(ref initializers' Initializers.AsArrayInternal())) " is 141.
Long Statement,System.Linq.Expressions,InstanceMethodCallExpression2,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MethodCallExpression.cs,Rewrite,The length of the statement  "            return args != null ? Call(instance' Method' args[0]' args[1]) : Call(instance' Method' ExpressionUtils.ReturnObject<Expression>(_arg0)' _arg1); " is 144.
Long Statement,System.Linq.Expressions,InstanceMethodCallExpression3,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MethodCallExpression.cs,Rewrite,The length of the statement  "            return args != null ? Call(instance' Method' args[0]' args[1]' args[2]) : Call(instance' Method' ExpressionUtils.ReturnObject<Expression>(_arg0)' _arg1' _arg2); " is 160.
Long Statement,System.Linq.Expressions,MethodCallExpression2,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MethodCallExpression.cs,Rewrite,The length of the statement  "            return args != null ? Call(Method' args[0]' args[1]) : Call(Method' ExpressionUtils.ReturnObject<Expression>(_arg0)' _arg1); " is 124.
Long Statement,System.Linq.Expressions,MethodCallExpression3,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MethodCallExpression.cs,Rewrite,The length of the statement  "            return args != null ? Call(Method' args[0]' args[1]' args[2]) : Call(Method' ExpressionUtils.ReturnObject<Expression>(_arg0)' _arg1' _arg2); " is 140.
Long Statement,System.Linq.Expressions,MethodCallExpression4,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MethodCallExpression.cs,Rewrite,The length of the statement  "            return args != null ? Call(Method' args[0]' args[1]' args[2]' args[3]) : Call(Method' ExpressionUtils.ReturnObject<Expression>(_arg0)' _arg1' _arg2' _arg3); " is 156.
Long Statement,System.Linq.Expressions,MethodCallExpression5,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MethodCallExpression.cs,Rewrite,The length of the statement  "            return args != null ? Call(Method' args[0]' args[1]' args[2]' args[3]' args[4]) : Call(Method' ExpressionUtils.ReturnObject<Expression>(_arg0)' _arg1' _arg2' _arg3' _arg4); " is 172.
Long Statement,System.Linq.Expressions,StackGuard,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\StackGuard.cs,RunOnEmptyStackCore,The length of the statement  "                var task = Task.Factory.StartNew(action!' state' CancellationToken.None' TaskCreationOptions.DenyChildAttach' TaskScheduler.Default); " is 133.
Long Statement,System.Linq.Expressions,SwitchExpression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\SwitchExpression.cs,Update,The length of the statement  "            if (switchValue == SwitchValue && defaultBody == DefaultBody && cases != null && ExpressionUtils.SameElements(ref cases' _cases)) " is 129.
Long Statement,System.Linq.Expressions,TypeBinaryExpression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\TypeBinaryExpression.cs,ReduceTypeEqual,The length of the statement  "            Debug.Assert(typeof(object).IsReferenceAssignableFromInternal(Expression.Type)' "Expecting reference types only after this point."); " is 132.
Long Statement,System.Linq.Expressions.Compiler,AssemblyGen,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\AssemblyGen.cs,DefineDelegateType,The length of the statement  "                TypeAttributes.Class | TypeAttributes.Public | TypeAttributes.Sealed | TypeAttributes.AnsiClass | TypeAttributes.AutoClass " is 122.
Long Statement,System.Linq.Expressions.Compiler,AssemblyGen,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\AssemblyGen.cs,DefineType,The length of the statement  "            sb.Replace('+'' '_').Replace('['' '_').Replace(']'' '_').Replace('*'' '_').Replace('&'' '_').Replace('''' '_').Replace('\\'' '_'); " is 130.
Long Statement,System.Linq.Expressions.Compiler,BoundConstants,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\BoundConstants.cs,EmitCacheConstants,The length of the statement  "                    throw new InvalidOperationException($"CompileToMethod cannot compile constant '{reference.Key.Value}' because it is a non-trivial value' such as a live object. Instead' create an expression tree that can construct this value."); " is 228.
Long Statement,System.Linq.Expressions.Compiler,BoundConstants,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\BoundConstants.cs,EmitConstant,The length of the statement  "                throw new InvalidOperationException($"CompileToMethod cannot compile constant '{value}' because it is a non-trivial value' such as a live object. Instead' create an expression tree that can construct this value."); " is 214.
Long Statement,System.Linq.Expressions.Compiler,CompilerScope,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\CompilerScope.cs,ResolveVariable,The length of the statement  "            throw new InvalidOperationException($"variable '{variable.Name}' of type '{variable.Type}' referenced from scope '{CurrentLambdaName}'' but it is not defined"); " is 160.
Long Statement,System.Linq.Expressions.Compiler,LabelInfo,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LabelInfo.cs,ValidateJump,The length of the statement  "                throw new InvalidOperationException($"Cannot jump to non-local label '{_node.Name}' with a value. Only jumps to labels defined in outer blocks can pass values."); " is 162.
Long Statement,System.Linq.Expressions.Compiler,LambdaCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.cs,EmitBinaryExpression,The length of the statement  "            Debug.Assert(b.NodeType != ExpressionType.AndAlso && b.NodeType != ExpressionType.OrElse && b.NodeType != ExpressionType.Coalesce); " is 131.
Long Statement,System.Linq.Expressions.Compiler,LambdaCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.cs,EmitUnliftedBinaryOp,The length of the statement  "            Debug.Assert(leftType.IsPrimitive || ((op == ExpressionType.Equal || op == ExpressionType.NotEqual) && (!leftType.IsValueType || leftType.IsEnum))); " is 148.
Long Statement,System.Linq.Expressions.Compiler,LambdaCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.cs,CreateStaticField,The length of the statement  "            return _typeBuilder!.DefineField("<ExpressionCompilerImplementationDetails>{" + Interlocked.Increment(ref _counter) + "}" + name' type' FieldAttributes.Static | FieldAttributes.Private); " is 186.
Long Statement,System.Linq.Expressions.Compiler,LambdaCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.cs,UpdateEmitAsTailCallFlag,The length of the statement  "            Debug.Assert(newValue == CompilationFlags.EmitAsTail || newValue == CompilationFlags.EmitAsMiddle || newValue == CompilationFlags.EmitAsNoTail); " is 144.
Long Statement,System.Linq.Expressions.Compiler,LambdaCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.cs,EmitDynamicExpression,The length of the statement  "                throw new NotSupportedException("Dynamic expressions are not supported by CompileToMethod. Instead' create an expression tree that uses System.Runtime.CompilerServices.CallSite."); " is 180.
Long Statement,System.Linq.Expressions.Compiler,LambdaCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.cs,EmitInvocationExpression,The length of the statement  "            EmitMethodCall(expr' expr.Type.GetInvokeMethod()' node' CompilationFlags.EmitAsNoTail | CompilationFlags.EmitExpressionStart); " is 126.
Long Statement,System.Linq.Expressions.Compiler,LambdaCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.cs,EmitMemberListBinding,The length of the statement  "                throw new InvalidOperationException($"Cannot auto initialize elements of value type through property '{binding.Member}'' use assignment instead"); " is 146.
Long Statement,System.Linq.Expressions.Compiler,LambdaCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.cs,EmitMemberMemberBinding,The length of the statement  "                throw new InvalidOperationException($"Cannot auto initialize members of value type through property '{binding.Member}'' use assignment instead"); " is 145.
Long Statement,System.Linq.Expressions.Compiler,LambdaCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.cs,EmitDelegateConstruction,The length of the statement  "                IL.Emit(OpCodes.Callvirt' typeof(DynamicMethod).GetMethod(nameof(DynamicMethod.CreateDelegate)' new[] { typeof(Type)' typeof(object) })); " is 137.
Long Statement,System.Linq.Expressions.Compiler,LambdaCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.cs,TryEmitHashtableSwitch,The length of the statement  "            if (node.Comparison != CachedReflectionInfo.StringOpEqualityStringString && node.Comparison != CachedReflectionInfo.StringEqualsStringString) " is 141.
Long Statement,System.Linq.Expressions.Compiler,LambdaCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.cs,TryEmitHashtableSwitch,The length of the statement  "                cases.UncheckedAdd(Expression.SwitchCase(node.Cases[i].Body' ReadOnlyCollectionEx.Create<Expression>(Utils.Constant(i)))); " is 122.
Long Statement,System.Linq.Expressions.Compiler,StackSpiller,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\StackSpiller.Bindings.cs,RequireNoRefArgs,The length of the statement  "                throw new NotSupportedException($"TryExpression is not supported as an argument to method '{method}' because it has an argument with by-ref type. Construct the tree so the TryExpression is not nested inside of this expression."); " is 229.
Long Statement,System.Linq.Expressions.Compiler,StackSpiller,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\StackSpiller.Bindings.cs,RequireNotRefInstance,The length of the statement  "                throw new NotSupportedException($"TryExpression is not supported as a child expression when accessing a member on type '{instance.Type}' because it is a value type. Construct the tree so the TryExpression is not nested inside of this expression."); " is 248.
Long Statement,System.Linq.Expressions.Compiler,StackSpiller,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\StackSpiller.Bindings.cs,VerifyRewrite,The length of the statement  "            Debug.Assert((result.Action == RewriteAction.None) ^ (node != result.Node)' "rewrite action does not match node object identity"); " is 130.
Long Statement,System.Linq.Expressions.Compiler,BindingRewriter,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\StackSpiller.Bindings.cs,RequireNoValueProperty,The length of the statement  "                    throw new InvalidOperationException($"Cannot auto initialize members of value type through property '{property}'' use assignment instead"); " is 139.
Long Statement,System.Linq.Expressions.Compiler,VariableBinder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\VariableBinder.cs,Visit,The length of the statement  "            return !_guard.TryEnterOnCurrentStack() ? _guard.RunOnEmptyStack((@this' e) => @this.Visit(e)' this' node) : base.Visit(node); " is 126.
Long Statement,System.Linq.Expressions.Compiler,VariableBinder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\VariableBinder.cs,VisitParameter,The length of the statement  "                throw new InvalidOperationException($"variable '{node.Name}' of type '{node.Type}' referenced from scope '{CurrentLambdaName}'' but it is not defined"); " is 152.
Long Statement,System.Linq.Expressions.Compiler,VariableBinder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\VariableBinder.cs,VisitParameter,The length of the statement  "                    throw new InvalidOperationException($"Cannot close over byref parameter '{node.Name}' referenced in lambda '{CurrentLambdaName}'"); " is 131.
Long Statement,System.Linq.Expressions.Compiler,VariableBinder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\VariableBinder.cs,VisitParameter,The length of the statement  "            (referenceScope.ReferenceCount ?? (referenceScope.ReferenceCount = new Dictionary<ParameterExpression' int>())).TryGetValue(node' out var count); " is 145.
Long Statement,System.Linq.Expressions.Compiler,VariableBinder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\VariableBinder.cs,VisitRuntimeVariables,The length of the statement  "                    throw new InvalidOperationException($"variable '{v.Name}' of type '{v.Type}' referenced from scope '{CurrentLambdaName}'' but it is not defined"); " is 146.
Long Statement,System.Linq.Expressions.Compiler,VariableBinder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\VariableBinder.cs,VisitRuntimeVariables,The length of the statement  "                    throw new InvalidOperationException($"Cannot close over byref parameter '{v.Name}' referenced in lambda '{CurrentLambdaName}'"); " is 128.
Long Statement,System.Linq.Expressions.Compiler,VariableBinder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\VariableBinder.cs,MergeScopes,The length of the statement  "            var body = node is LambdaExpression lambda ? new ReadOnlyCollection<Expression>(new[] { lambda.Body }) : ((BlockExpression)node).Expressions; " is 141.
Long Statement,System.Linq.Expressions.Compiler,VariableBinder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\VariableBinder.cs,MergeScopes,The length of the statement  "                    (currentScope.MergedScopes ?? (currentScope.MergedScopes = new HashSet<BlockExpression>(ReferenceEqualityComparer<BlockExpression>.Instance))).Add(block); " is 154.
Long Statement,System.Linq.Expressions.Interpreter,BranchLabel,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\BranchLabel.cs,Mark,The length of the statement  "            //ContractUtils.Requires(_targetIndex == UnknownIndex && _stackDepth == UnknownDepth && _continuationStackDepth == UnknownDepth); " is 129.
Long Statement,System.Linq.Expressions.Interpreter,CallInstruction,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\CallInstruction.cs,Create,The length of the statement  "            if (info.DeclaringType?.IsArray == true && (string.Equals(info.Name' "Get"' StringComparison.Ordinal) || string.Equals(info.Name' "Set"' StringComparison.Ordinal))) " is 164.
Long Statement,System.Linq.Expressions.Interpreter,CallInstruction,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\CallInstruction.cs,GetArrayAccessor,The length of the statement  "                    alternativeMethod = isGetter ? arrayType.GetMethod("GetValue"' new[] { typeof(int) }) : typeof(CallInstruction).GetMethod(nameof(ArrayItemSetter1)); " is 148.
Long Statement,System.Linq.Expressions.Interpreter,CallInstruction,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\CallInstruction.cs,GetArrayAccessor,The length of the statement  "                    alternativeMethod = isGetter ? arrayType.GetMethod("GetValue"' new[] { typeof(int)' typeof(int) }) : typeof(CallInstruction).GetMethod(nameof(ArrayItemSetter2)); " is 161.
Long Statement,System.Linq.Expressions.Interpreter,CallInstruction,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\CallInstruction.cs,GetArrayAccessor,The length of the statement  "                    alternativeMethod = isGetter ? arrayType.GetMethod("GetValue"' new[] { typeof(int)' typeof(int)' typeof(int) }) : typeof(CallInstruction).GetMethod(nameof(ArrayItemSetter3)); " is 174.
Long Statement,System.Linq.Expressions.Interpreter,EnterTryCatchFinallyInstruction,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\ControlFlowInstructions.cs,Run,The length of the statement  "                    Debug.Assert(instructions[index] is GotoInstruction' "should be the 'Goto' instruction that jumps out the try/catch/finally"); " is 126.
Long Statement,System.Linq.Expressions.Interpreter,EnterTryCatchFinallyInstruction,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\ControlFlowInstructions.cs,Run,The length of the statement  "                        Debug.Assert(instructions[index] is GotoInstruction' "should be the 'Goto' instruction that jumps out the try/catch/finally"); " is 126.
Long Statement,System.Linq.Expressions.Interpreter,EnterTryCatchFinallyInstruction,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\ControlFlowInstructions.cs,Run,The length of the statement  "                    // In the first path' the continuation mechanism works and frame.InstructionIndex will be updated to point to the first instruction of the finally block " is 152.
Long Statement,System.Linq.Expressions.Interpreter,EnterTryCatchFinallyInstruction,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\ControlFlowInstructions.cs,Run,The length of the statement  "                    Debug.Assert(!isFromJump || (isFromJump && Handler.FinallyStartIndex == frame.InstructionIndex)' "we should already jump to the first instruction of the finally"); " is 163.
Long Statement,System.Linq.Expressions.Interpreter,DebugInfo,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\DebugInfo.cs,ToString,The length of the statement  "            return IsClear ? string.Format(CultureInfo.InvariantCulture' "{0}: clear"' Index) : string.Format(CultureInfo.InvariantCulture' "{0}: [{1}-{2}] '{3}'"' Index' StartLine' EndLine' FileName); " is 189.
Long Statement,System.Linq.Expressions.Interpreter,ExceptionHandler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\ExceptionHandler.cs,ToString,The length of the statement  "            return string.Format(CultureInfo.InvariantCulture' "catch({0}) [{1}->{2}]"' _exceptionType.Name' HandlerStartIndex' HandlerEndIndex); " is 133.
Long Statement,System.Linq.Expressions.Interpreter,InstructionList,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\InstructionList.cs,EmitByRefCall,The length of the statement  "            Emit(new ByRefMethodInfoCallInstruction(method' method.IsStatic ? parameters.Length : parameters.Length + 1' byrefArgs)); " is 121.
Long Statement,System.Linq.Expressions.Interpreter,InstructionList,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\InstructionList.cs,EmitLoadLocalFromClosureBoxed,The length of the statement  "                Emit(_loadLocalFromClosureBoxed[index] ?? (_loadLocalFromClosureBoxed[index] = new LoadLocalFromClosureBoxedInstruction(index))); " is 129.
Long Statement,System.Linq.Expressions.Interpreter,InstructionList,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\InstructionList.cs,UpdateStackDepth,The length of the statement  "            Debug.Assert(instruction.ConsumedStack >= 0 && instruction.ProducedStack >= 0 && instruction.ConsumedContinuations >= 0 && instruction.ProducedContinuations >= 0' "bad instruction " + instruction); " is 197.
Long Statement,System.Linq.Expressions.Interpreter,LabelInfo,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\LabelInfo.cs,ValidateJump,The length of the statement  "                throw new InvalidOperationException($"Cannot jump to non-local label '{_node.Name}' with a value. Only jumps to labels defined in outer blocks can pass values."); " is 162.
Long Statement,System.Linq.Expressions.Interpreter,LightCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\LightCompiler.cs,CompileConvertUnaryExpression,The length of the statement  "                CompileConvertToType(node.Operand!.Type' node.Type' node.NodeType == ExpressionType.ConvertChecked' node.IsLiftedToNull); " is 121.
Long Statement,System.Linq.Expressions.Interpreter,LightCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\LightCompiler.cs,CompileMemberInit,The length of the statement  "                            throw new InvalidOperationException($"Cannot auto initialize members of value type through property '{memberMember.Bindings}'' use assignment instead"); " is 152.
Long Statement,System.Linq.Expressions.Interpreter,LightCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\LightCompiler.cs,CompileMultiDimArrayAccess,The length of the statement  "            return new IndexMethodByRefUpdater(objTmp' indexLocals' array.Type.GetMethod("Set"' BindingFlags.Public | BindingFlags.Instance)' index); " is 137.
Long Statement,System.Linq.Expressions.Interpreter,LightLambda,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\LightLambda.cs,MakeDelegate,The length of the statement  "            return method.ReturnType == typeof(void) ? DelegateHelpers.CreateObjectArrayDelegate(delegateType' RunVoid) : DelegateHelpers.CreateObjectArrayDelegate(delegateType' Run); " is 171.
Long Statement,System.Linq.Expressions.Interpreter,DebugViewPrinter,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\LightLambda.cs,Analyze,The length of the statement  "                                    _handlerEnter.Add(catchHandler.HandlerStartIndex - 1 /* include EnterExceptionHandler instruction */' catchHandler.ToString()); " is 127.
Long Statement,System.Linq.Expressions.Interpreter,LocalVariable,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\LocalVariables.cs,ToString,The length of the statement  "            return string.Format(CultureInfo.InvariantCulture' "{0}: {1} {2}"' Index' IsBoxed ? "boxed" : null' InClosure ? "in closure" : null); " is 133.
Long Statement,System.Linq.Expressions.Interpreter,TryCatchFinallyHandler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\TryCatchFinallyHandler.cs,HasHandler,The length of the statement  "                    if (!candidate.Matches(exceptionType) || (candidate.Filter != null && !FilterPasses(frame' ref unwrappedException' candidate.Filter))) " is 134.
Long Statement,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,GetPartsForBitManipulation,The length of the statement  "            xd = x.InternalBits ?? (x.InternalSign >= 0 ? new[] { unchecked((uint)x.InternalSign) } : new[] { unchecked((uint)-x.InternalSign) }); " is 134.
Long Statement,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,FormatBigInteger,The length of the statement  "                                append = StringWithGroups(length' new ExtendedEnumerable<char>(new[] { '0'' '0' }' builder)' groupingSizes' groupingSeparator); " is 127.
Long Statement,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,ParseNumber,The length of the statement  "            if (!isCurrency && allowCurrencySymbol && reader.Read(currencySymbol)) // If the currency symbol is after the negative sign " is 123.
Long Statement,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,ParseNumber,The length of the statement  "            if (!isCurrency && allowCurrencySymbol && reader.Read(currencySymbol)) // If the currency symbol is after the negative sign " is 123.
Long Statement,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,TryValidateParseStyleInteger,The length of the statement  "            if ((style & NumberStyles.AllowHexSpecifier) == NumberStyles.None || (style & (NumberStyles.AllowLeadingSign | NumberStyles.AllowTrailingSign | NumberStyles.AllowParentheses | NumberStyles.AllowDecimalPoint | NumberStyles.AllowThousands | NumberStyles.AllowExponent | NumberStyles.AllowCurrencySymbol)) == NumberStyles.None) " is 324.
Long Statement,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,TryValidateParseStyleInteger,The length of the statement  "            e = new ArgumentException("With the AllowHexSpecifier bit set in the enum bit field' the only other valid bits that can be combined into the enum value must be a subset of those in HexNumber."); " is 194.
Long Statement,System.Threading,Barrier,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Barrier.cs,AddParticipant,The length of the statement  "                throw new InvalidOperationException("Adding participantCount participants would result in the number of participants exceeding the maximum number allowed."); " is 157.
Long Statement,System.Threading,Barrier,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Barrier.cs,AddParticipants,The length of the statement  "                    // Calculating the first phase for that participant' if the current phase already finished return the next phase else return the current phase " is 142.
Long Statement,System.Threading,Barrier,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Barrier.cs,AddParticipants,The length of the statement  "                    // phase odd even' so that means it didn't yet change the phase count' so currentPhase +1 is returned' otherwise currentPhase is returned " is 137.
Long Statement,System.Threading,Barrier,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Barrier.cs,AddParticipants,The length of the statement  "                    // If this participant is going to join the next phase' which means the postPhaseAction is being running' this participants must wait until this done " is 149.
Long Statement,System.Threading,Barrier,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Barrier.cs,AddParticipants,The length of the statement  "                    // Without that' if the postPhaseAction takes long time' this means the event that the current participant is going to wait on is still set " is 139.
Long Statement,System.Threading,Barrier,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Barrier.cs,AddParticipants,The length of the statement  "                    //This else to fix the racing where the current phase has been finished' m_currentPhase has been updated but the events have not been set/reset yet " is 147.
Long Statement,System.Threading,Barrier,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Barrier.cs,AddParticipants,The length of the statement  "                    // otherwise when this participant calls SignalAndWait it will wait on a set event however all other participants have not arrived yet. " is 135.
Long Statement,System.Threading,Barrier,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Barrier.cs,RemoveParticipants,The length of the statement  "                    throw new InvalidOperationException("The participantCount argument is greater than the number of participants that haven't yet arrived at the barrier in this phase."); " is 167.
Long Statement,System.Threading,Barrier,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Barrier.cs,SignalAndWait,The length of the statement  "                // This can be detected if the current is zero which means all participants for that phase has arrived and the phase number is not changed yet " is 142.
Long Statement,System.Threading,Barrier,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Barrier.cs,SignalAndWait,The length of the statement  "                    throw new InvalidOperationException("The number of threads using the barrier exceeded the total number of registered participants."); " is 133.
Long Statement,System.Threading,Barrier,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Barrier.cs,SignalAndWait,The length of the statement  "            catch (ObjectDisposedException) when (phase < CurrentPhaseNumber) // in case a race happen where one of the thread returned from SignalAndWait and the current thread calls Wait on a disposed event " is 196.
Long Statement,System.Threading,Barrier,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Barrier.cs,SignalAndWait,The length of the statement  "                    // If the timeout expired and the phase has just finished' return true and this is considered as succeeded SignalAndWait " is 120.
Long Statement,System.Threading,Barrier,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Barrier.cs,SignalAndWait,The length of the statement  "                        // The current phase has been finished' but we shouldn't return before the events are set/reset otherwise this thread could start " is 129.
Long Statement,System.Threading,Barrier,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Barrier.cs,SignalAndWait,The length of the statement  "                        // next phase and the appropriate event has not reset yet which could make it return immediately from the next phase SignalAndWait " is 130.
Long Statement,System.Threading,Barrier,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Barrier.cs,DiscontinuousWait,The length of the statement  "                //if the maxWait exceeded 10 seconds then we will stop increasing the maxWait time and keep it 10 seconds' otherwise keep doubling it " is 133.
Long Statement,System.Threading,CancellationTokenSource,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\CancellationTokenSource.cs,Register,The length of the statement  "                // Check if the source was just canceled and if so' it may be that it executed the callbacks except the one just added... " is 121.
Long Statement,System.Threading,CancellationTokenSource,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\CancellationTokenSource.cs,CancelExtracted,The length of the statement  "                // Whatever was added after the cancellation process started' it should run inline in Register... if they don't' handle then here. " is 130.
Long Statement,System.Threading,CountdownEvent,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\CountdownEvent.cs,TryAddCount,The length of the statement  "            if (ThreadingHelper.SpinWaitRelativeExchangeBounded(ref _currentCount' signalCount' 1' int.MaxValue' out var lastValue)) " is 120.
Long Statement,System.Threading,LazyInitializer,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\LazyInitializer.cs,EnsureInitialized,The length of the statement  "                    throw new MissingMemberException("The type being lazily initialized does not have a public' parameterless constructor."); " is 121.
Long Statement,System.Threading,ReaderWriterLockSlim,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\ReaderWriterLockSlim.cs,CheckState,The length of the statement  "            if (stateLockState != LockState.None && _noRecursion && (!((stateLockState & LockState.Upgradable) > 0) || validState == LockState.Upgradable)) " is 143.
Long Statement,System.Threading,ReaderWriterLockSlim,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\ReaderWriterLockSlim.cs,TryEnterReadLock,The length of the statement  "            if ((currentThreadState.LockState & LockState.Upgradable) > 0 || (!_noRecursion && (currentThreadState.LockState & LockState.Write) > 0)) " is 137.
Long Statement,System.Threading,SpinLock,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\SpinLock.cs,Enter,The length of the statement  "                if (Interlocked.CompareExchange(ref _isHeld' 1' 0) == 0 && Interlocked.CompareExchange(ref _ownerThread' Thread.CurrentThread' null) == null) " is 141.
Long Statement,System.Threading,SpinLock,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\SpinLock.cs,TryEnter,The length of the statement  "                lockTaken |= ThreadingHelper.SpinWaitSet(ref _isHeld' 1' 0' millisecondsTimeout) && Interlocked.CompareExchange(ref _ownerThread' Thread.CurrentThread' null) == null; " is 166.
Long Statement,System.Threading,ThreadLocal<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\ThreadLocal.cs,ToString,The length of the statement  "            return string.Format(CultureInfo.InvariantCulture' "[ThreadLocal: IsValueCreated={0}' Value={1}]"' IsValueCreated' Value); " is 122.
Long Statement,System.Threading.Tasks,AwaitTaskContinuation,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\AwaitTaskContinuation.cs,Run,The length of the statement  "                RunCallback(GetInvokeActionCallback()' Action' ref Task.InternalCurrent); // any exceptions from Action will be handled by s_callbackRunAction " is 142.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,ContinueWith,The length of the statement  "            return ContinueWith(continuationFunction' state' TaskScheduler.Current' cancellationToken' TaskContinuationOptions.None); " is 121.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,CreationOptionsFromContinuationOptions,The length of the statement  "            const TaskContinuationOptions notOnAnything = TaskContinuationOptions.NotOnCanceled | TaskContinuationOptions.NotOnFaulted | TaskContinuationOptions.NotOnRanToCompletion; " is 170.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,CreationOptionsFromContinuationOptions,The length of the statement  "            const TaskContinuationOptions creationOptionsMask = TaskContinuationOptions.PreferFairness | TaskContinuationOptions.LongRunning | TaskContinuationOptions.DenyChildAttach | TaskContinuationOptions.HideScheduler | TaskContinuationOptions.AttachedToParent | TaskContinuationOptions.RunContinuationsAsynchronously; " is 311.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,CreationOptionsFromContinuationOptions,The length of the statement  "            const TaskContinuationOptions illegalMask = TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.LongRunning; " is 127.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,CreationOptionsFromContinuationOptions,The length of the statement  "                throw new ArgumentOutOfRangeException(nameof(continuationOptions)' "The specified TaskContinuationOptions combined LongRunning and ExecuteSynchronously.  Synchronous continuations should not be long running."); " is 210.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,CreationOptionsFromContinuationOptions,The length of the statement  "            if ((continuationOptions & ~(creationOptionsMask | notOnAnything | TaskContinuationOptions.LazyCancellation | TaskContinuationOptions.ExecuteSynchronously)) != 0) " is 162.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,CreationOptionsFromContinuationOptions,The length of the statement  "                throw new ArgumentOutOfRangeException(nameof(continuationOptions)' "The specified TaskContinuationOptions excluded all continuation kinds."); " is 141.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,FinishContinuations,The length of the statement  "            if (Interlocked.CompareExchange(ref _continuationsStatus' _takingContinuations' _continuationsNotInitialized) == _continuationsNotInitialized) " is 142.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,FinishContinuations,The length of the statement  "            if (Interlocked.CompareExchange(ref _continuationsStatus' _takingContinuations' _continuationsInitialization) != _continuationsInitialization) " is 142.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,FinishContinuations,The length of the statement  "                if (!(continuations[index] is StandardTaskContinuation tc) || (tc.Options & TaskContinuationOptions.ExecuteSynchronously) != 0) " is 127.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,FinishContinuations,The length of the statement  "                            Contract.Assert(currentContinuation is ITaskCompletionAction' "Expected continuation element to be Action' TaskContinuation' or ITaskContinuationAction"); " is 154.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,RetrieveContinuations,The length of the statement  "                    if (Interlocked.CompareExchange(ref _continuationsStatus' _continuationsInitialization' _continuationsNotInitialized) == _continuationsNotInitialized) " is 150.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,RetrieveContinuations,The length of the statement  "                    while (Volatile.Read(ref _continuationsStatus) == _continuationsInitialization && (continuations = Interlocked.CompareExchange(ref _continuations' null' null)) == null) " is 168.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,InternalCancel,The length of the statement  "            Contract.Requires((_internalOptions & InternalTaskOptions.PromiseTask) == 0' "Task.InternalCancel() did not expect promise-style task"); " is 136.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,InternalCancel,The length of the statement  "                // Note: status may advance to TaskStatus.Running or even TaskStatus.RanToCompletion during the execution of this method " is 120.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,InternalCancel,The length of the statement  "                // We are going to pretend that the cancel call came after the task finished running' but we may still set to cancel on TaskStatus.WaitingForChildrenToComplete " is 159.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,InternalCancel,The length of the statement  "                status = Interlocked.CompareExchange(ref _status' (int)TaskStatus.Canceled' (int)TaskStatus.WaitingForChildrenToComplete); " is 122.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,PrivateRunSynchronously,The length of the statement  "                throw new InvalidOperationException("RunSynchronously may not be called on a task not bound to a delegate' such as the task returned from an asynchronous method."); " is 164.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,Delay,The length of the statement  "                throw new ArgumentOutOfRangeException(nameof(delay)' "The value needs to translate in milliseconds to - 1(signifying an infinite timeout)' 0 or a positive integer less than or equal to Int32.MaxValue"); " is 202.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,Delay,The length of the statement  "                throw new ArgumentOutOfRangeException(nameof(millisecondsDelay)' "The value needs to be either -1 (signifying an infinite timeout)' 0 or a positive integer."); " is 159.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,DisregardChild,The length of the statement  "            Contract.Assert(Volatile.Read(ref _completionCountdown) >= 2' "Task.DisregardChild(): Expected parent count to be >= 2"); " is 121.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,Finish,The length of the statement  "                    // Apparently some children still remain. It will be up to the last one to process the completion of this task on their own thread. " is 131.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,Finish,The length of the statement  "                // Now is the time to prune exceptional children. We'll walk the list and removes the ones whose exceptions we might have observed after they threw. " is 148.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,Finish,The length of the statement  "                // we use a local variable for exceptional children here because some other thread may be nulling out _exceptionalChildren " is 122.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,Finish,The length of the statement  "                    exceptionalChildren.RemoveAll(_isExceptionObservedByParentPredicate); // RemoveAll has better performance than doing it ourselves " is 129.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,FinishStageThree,The length of the statement  "            if (_parent != null && (_parent.CreationOptions & TaskCreationOptions.DenyChildAttach) == 0 && (CreationOptions & TaskCreationOptions.AttachedToParent) != 0) " is 157.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,FinishStageTwo,The length of the statement  "            var completionState = ExceptionRecorded ? TaskStatus.Faulted : IsCancellationRequested && IsCancellationAcknowledged ? TaskStatus.Canceled : TaskStatus.RanToCompletion; " is 168.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,ProcessChildCompletion,The length of the statement  "                // This call came from the final child to complete' and apparently we have previously given up this task's right to complete itself. " is 132.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,UpdateExceptionObservedStatus,The length of the statement  "            if (_parent != null && (CreationOptions & TaskCreationOptions.AttachedToParent) != 0 && (_parent.CreationOptions & TaskCreationOptions.DenyChildAttach) == 0 && InternalCurrent == _parent) " is 187.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,AddNewChild,The length of the statement  "            Contract.Assert(InternalCurrent == this || IsSelfReplicatingRoot' "Task.AddNewChild(): Called from an external context"); " is 121.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,AssignCancellationToken,The length of the statement  "                // We exclude Promise tasks from this' because TaskCompletionSource needs to fully control the inner tasks's lifetime (i.e. not allow external cancellations) " is 157.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,AssignCancellationToken,The length of the statement  "                if ((_internalOptions & (InternalTaskOptions.QueuedByRuntime | InternalTaskOptions.PromiseTask | InternalTaskOptions.LazyCancellation)) != 0) " is 141.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,AssignCancellationToken,The length of the statement  "                    var registration = cancellationToken.Register(_taskCancelCallback' antecedent == null ? (object)this : new Tuple<Task' Task' TaskContinuation?>(this' antecedent' continuation)); " is 177.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,HandleException,The length of the statement  "            if (unhandledException is OperationCanceledExceptionEx exceptionAsOce && IsCancellationRequested && CancellationToken == exceptionAsOce.CancellationToken) " is 154.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,TrySetCanceledPromise,The length of the statement  "            Contract.Assert(IsPromiseTask' "Task.RecordInternalCancellationRequest(CancellationToken) only valid for promise-style task"); " is 126.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,Run,The length of the statement  "            return Factory.StartNew(action' CancellationToken.None' TaskCreationOptions.DenyChildAttach' TaskScheduler.Default).Unwrap(); " is 125.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,Run,The length of the statement  "            return Factory.StartNew(action' cancellationToken' TaskCreationOptions.DenyChildAttach' TaskScheduler.Default).Unwrap(); " is 120.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,WaitAll,The length of the statement  "            // We make sure that the exception behavior of Task.Wait() is replicated the same for tasks handled in either of these code paths " is 129.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,SetNotificationForWaitCompletion,The length of the statement  "            Contract.Assert(IsPromiseTask' "Should only be used for promise-style tasks"); // hasn't been vetted on other kinds as there hasn't been a need " is 143.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,WhenAny,The length of the statement  "            return intermediate.ContinueWith(Task<TResult>.ContinuationConversion' default' TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.DenyChildAttach' TaskScheduler.Default); " is 191.
Long Statement,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,WhenAny,The length of the statement  "            return intermediate.ContinueWith(Task<TResult>.ContinuationConversion' default' TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.DenyChildAttach' TaskScheduler.Default); " is 191.
Long Statement,System.Threading.Tasks,WhenAllPromise,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,PrivateDone,The length of the statement  "                        (observedExceptions ??= new List<ExceptionDispatchInfo>()).AddRange(task._exceptionsHolder!.GetExceptionDispatchInfos()); " is 121.
Long Statement,System.Threading.Tasks,WhenAllPromise<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,PrivateDone,The length of the statement  "                        (observedExceptions ??= new List<ExceptionDispatchInfo>()).AddRange(task._exceptionsHolder!.GetExceptionDispatchInfos()); " is 121.
Long Statement,System.Threading.Tasks,Parallel,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Parallel.cs,ForWorker,The length of the statement  "                                                sharedPStateFlags.LoopStateFlags == ParallelLoopStateFlags.ParallelLoopStateNone // fast path check as SEL() doesn't inline " is 123.
Long Statement,System.Threading.Tasks,Parallel,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Parallel.cs,ForWorker,The length of the statement  "                                                sharedPStateFlags.LoopStateFlags == ParallelLoopStateFlags.ParallelLoopStateNone // fast path check as SEL() doesn't inline " is 123.
Long Statement,System.Threading.Tasks,Parallel,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Parallel.cs,ForWorker,The length of the statement  "                                                sharedPStateFlags.LoopStateFlags == ParallelLoopStateFlags.ParallelLoopStateNone // fast path check as SEL() doesn't inline " is 123.
Long Statement,System.Threading.Tasks,Parallel,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Parallel.cs,ForWorker64,The length of the statement  "                            var bLocalValueInitialized = false; // Tracks whether localInit ran without exceptions' so that we can skip localFinally if it wasn't " is 133.
Long Statement,System.Threading.Tasks,Parallel,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Parallel.cs,ForWorker64,The length of the statement  "                                                sharedPStateFlags.LoopStateFlags == ParallelLoopStateFlags.ParallelLoopStateNone // fast path check as SEL() doesn't inline " is 123.
Long Statement,System.Threading.Tasks,Parallel,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Parallel.cs,ForWorker64,The length of the statement  "                                                sharedPStateFlags.LoopStateFlags == ParallelLoopStateFlags.ParallelLoopStateNone // fast path check as SEL() doesn't inline " is 123.
Long Statement,System.Threading.Tasks,Parallel,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Parallel.cs,ForWorker64,The length of the statement  "                                                sharedPStateFlags.LoopStateFlags == ParallelLoopStateFlags.ParallelLoopStateNone // fast path check as SEL() doesn't inline " is 123.
Long Statement,System.Threading.Tasks,Parallel,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Parallel.cs,InvokeExtracted,The length of the statement  "                    ThrowSingleCancellationExceptionOrOtherException(exceptionQ' new AggregateException(exceptionQ[0])' parallelOptions.CancellationToken); " is 135.
Long Statement,System.Threading.Tasks,Parallel,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Parallel.cs,PartitionerForEachWorker,The length of the statement  "                            var bLocalValueInitialized = false; // Tracks whether localInit ran without exceptions' so that we can skip localFinally if it wasn't " is 133.
Long Statement,System.Threading.Tasks,Parallel,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Parallel.cs,PartitionerForEachWorker,The length of the statement  "                var d = orderablePartitionerSource != null ? orderablePartitionerSource as IDisposable : partitionerSource as IDisposable; " is 122.
Long Statement,System.Threading.Tasks,ParallelLoopState,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ParallelLoopState.cs,Break,The length of the statement  "                    ParallelLoopStateFlags.ParallelLoopStateStopped | ParallelLoopStateFlags.ParallelLoopStateExceptional | ParallelLoopStateFlags.ParallelLoopStateCanceled' " is 153.
Long Statement,System.Threading.Tasks,ParallelLoopState,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ParallelLoopState.cs,Break,The length of the statement  "            while (Interlocked.CompareExchange(ref parallelFlags._lowestBreakIteration' iteration' lowestBreakIteration) != lowestBreakIteration) " is 133.
Long Statement,System.Threading.Tasks,ParallelLoopState,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ParallelLoopState.cs,Break,The length of the statement  "                    ParallelLoopStateFlags.ParallelLoopStateStopped | ParallelLoopStateFlags.ParallelLoopStateExceptional | ParallelLoopStateFlags.ParallelLoopStateCanceled' " is 153.
Long Statement,System.Threading.Tasks,ParallelLoopState,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ParallelLoopState.cs,Break,The length of the statement  "            while (Interlocked.CompareExchange(ref parallelFlags._lowestBreakIteration' iteration' lowestBreakIteration) != lowestBreakIteration) " is 133.
Long Statement,System.Threading.Tasks,RangeWorker,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\RangeWorker.cs,FindNewWork,The length of the statement  "                        found = Interlocked.CompareExchange(ref _indexRanges[_currentIndexRange].SharedCurrentIndexOffset' created' null) ?? created; " is 125.
Long Statement,System.Threading.Tasks,Task<TResult>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Task.await.cs,ContinueWith,The length of the statement  "            return ContinueWithInternal(continuationAction' TaskScheduler.Current' cancellationToken' TaskContinuationOptions.None); " is 120.
Long Statement,System.Threading.Tasks,Task<TResult>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Task.await.cs,ContinueWith,The length of the statement  "            return ContinueWithInternal(continuationAction' state' TaskScheduler.Current' cancellationToken' TaskContinuationOptions.None); " is 127.
Long Statement,System.Threading.Tasks,Task<TResult>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Task.await.cs,ContinueWith,The length of the statement  "            return ContinueWithInternal(continuationFunction' TaskScheduler.Current' cancellationToken' TaskContinuationOptions.None); " is 122.
Long Statement,System.Threading.Tasks,Task<TResult>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Task.await.cs,ContinueWith,The length of the statement  "            return ContinueWithInternal(continuationFunction' state' TaskScheduler.Current' cancellationToken' TaskContinuationOptions.None); " is 129.
Long Statement,System.Threading.Tasks,TaskCompletionSource<TResult>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskCompletionSource.cs,SetCanceled,The length of the statement  "                throw new InvalidOperationException("An attempt was made to transition a task to a final state when it had already completed."); " is 128.
Long Statement,System.Threading.Tasks,TaskCompletionSource<TResult>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskCompletionSource.cs,SetException,The length of the statement  "                throw new InvalidOperationException("An attempt was made to transition a task to a final state when it had already completed."); " is 128.
Long Statement,System.Threading.Tasks,TaskCompletionSource<TResult>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskCompletionSource.cs,SetException,The length of the statement  "                throw new InvalidOperationException("An attempt was made to transition a task to a final state when it had already completed."); " is 128.
Long Statement,System.Threading.Tasks,TaskCompletionSource<TResult>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskCompletionSource.cs,SetResult,The length of the statement  "                throw new InvalidOperationException("An attempt was made to transition a task to a final state when it had already completed."); " is 128.
Long Statement,System.Threading.Tasks,TaskEx,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskEx.cs,WhenAny,The length of the statement  "            Task.Factory.ContinueWhenAny(tasks as Task<TResult>[] ?? tasks.ToArray()' tcs.TrySetResult' CancellationToken.None' TaskContinuationOptions.ExecuteSynchronously' TaskScheduler.Default); " is 185.
Long Statement,System.Threading.Tasks,TaskEx,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskEx.cs,WhenAny,The length of the statement  "            Task.Factory.ContinueWhenAny(tasks as Task[] ?? tasks.ToArray()' tcs.TrySetResult' CancellationToken.None' TaskContinuationOptions.ExecuteSynchronously' TaskScheduler.Default); " is 176.
Long Statement,System.Threading.Tasks,TaskEx,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskEx.cs,Delay,The length of the statement  "                throw new ArgumentOutOfRangeException(nameof(millisecondsDelay)' "The value needs to be either -1 (signifying an infinite timeout)' 0 or a positive integer."); " is 159.
Long Statement,System.Threading.Tasks,TaskExceptionHolder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskExceptionHolder.cs,Add,The length of the statement  "                "TaskExceptionHolder.Add(): Expected Exception' IEnumerable<Exception>' ExceptionDispatchInfo' or IEnumerable<ExceptionDispatchInfo>" " is 133.
Long Statement,System.Threading.Tasks,TaskExceptionHolder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskExceptionHolder.cs,CreateAggregateException,The length of the statement  "                "A Task's exception(s) were not observed either by Waiting on the Task or accessing its Exception property. As a result' the unobserved exception was rethrown by the finalizer thread."' " is 185.
Long Statement,System.Threading.Tasks,TaskExEx,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskExEx.completedtask.cs,FromWaitHandleInternal,The length of the statement  "                WaitHandleCancellableTaskCompletionSourceManager.CreateWithTimeout(waitHandle' cancellationToken' source' millisecondsTimeout); " is 127.
Long Statement,System.Threading.Tasks,TaskExEx,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskExEx.completedtask.cs,FromCanceled,The length of the statement  "            // Microsoft says Task.FromCancellation throws ArgumentOutOfRangeException when cancellation has not been requested for cancellationToken " is 137.
Long Statement,System.Threading.Tasks,TaskExEx,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskExEx.completedtask.cs,FromCanceled,The length of the statement  "            // Microsoft says Task.FromCancellation throws ArgumentOutOfRangeException when cancellation has not been requested for cancellationToken " is 137.
Long Statement,System.Threading.Tasks,WaitHandleCancellableTaskCompletionSourceManager,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskExEx.WaitHandleCancellableTaskCompletionSourceManager.cs,CreateWithoutTimeout,The length of the statement  "                result._registeredWaitHandle[0] = ThreadPool.RegisterWaitForSingleObject(waitHandle' result.CallbackWithoutTimeout' null' -1' true); " is 132.
Long Statement,System.Threading.Tasks,WaitHandleCancellableTaskCompletionSourceManager,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskExEx.WaitHandleCancellableTaskCompletionSourceManager.cs,CreateWithTimeout,The length of the statement  "                result._registeredWaitHandle[0] = ThreadPool.RegisterWaitForSingleObject(waitHandle' result.CallbackWithTimeout' null' millisecondsTimeout' true); " is 146.
Long Statement,System.Threading.Tasks,WaitHandleTaskCompletionSourceManager,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskExEx.WaitHandleTaskCompletionSourceManager.cs,CreateWithTimeout,The length of the statement  "                result._registeredWaitHandle[0] = ThreadPool.RegisterWaitForSingleObject(waitHandle' result.CallbackWithTimeout' null' millisecondsTimeout' true); " is 146.
Long Statement,System.Threading.Tasks,TaskExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskExtensions.cs,TransferAsynchronously,The length of the statement  "            // allocations.  Thus' this whole Unwrap operation generally results in four allocations: one for the TaskCompletionSource' " is 123.
Long Statement,System.Threading.Tasks,TaskExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskExtensions.cs,TrySetFromTask,The length of the statement  "                    result = task is Task<TResult> resultTask ? completionSource.TrySetResult(resultTask.Result) : completionSource.TrySetResult(default); " is 134.
Long Statement,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The length of the statement  "            return Task.WhenAll(tasks).ContinueWith(_ => continuationAction(tasks)' cancellationToken' TaskContinuationOptions.None' TaskScheduler.Current); " is 144.
Long Statement,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The length of the statement  "            return Task.WhenAll(tasks).ContinueWith(_ => continuationAction(tasks)' CancellationToken.None' continuationOptions' TaskScheduler.Current); " is 140.
Long Statement,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The length of the statement  "            return Task.WhenAll(tasks).ContinueWith(_ => continuationAction(tasks)' cancellationToken' continuationOptions' scheduler); " is 123.
Long Statement,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The length of the statement  "            return Task.WhenAll(tasks).ContinueWith(_ => continuationFunction(tasks)' cancellationToken' continuationOptions' scheduler); " is 125.
Long Statement,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The length of the statement  "            return Task.WhenAll(tasks).ContinueWith(_ => continuationFunction(tasks)' CancellationToken.None' continuationOptions' TaskScheduler.Current); " is 142.
Long Statement,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The length of the statement  "            return Task.WhenAll(tasks).ContinueWith(_ => continuationFunction(tasks)' cancellationToken' TaskContinuationOptions.None' TaskScheduler.Current); " is 146.
Long Statement,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The length of the statement  "            return Task.WhenAll(tasks).ContinueWith(_ => continuationFunction(tasks)' CancellationToken.None' TaskContinuationOptions.None' TaskScheduler.Current); " is 151.
Long Statement,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The length of the statement  "            return Task.WhenAll(tasks).ContinueWith(_ => continuationAction(tasks)' cancellationToken' continuationOptions' scheduler); " is 123.
Long Statement,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The length of the statement  "            return Task.WhenAll(tasks).ContinueWith(_ => continuationAction(tasks)' CancellationToken.None' continuationOptions' TaskScheduler.Current); " is 140.
Long Statement,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The length of the statement  "            return Task.WhenAll(tasks).ContinueWith(_ => continuationAction(tasks)' cancellationToken' TaskContinuationOptions.None' TaskScheduler.Current); " is 144.
Long Statement,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The length of the statement  "            return Task.WhenAll(tasks).ContinueWith(_ => continuationFunction(tasks)' cancellationToken' TaskContinuationOptions.None' TaskScheduler.Current); " is 146.
Long Statement,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The length of the statement  "            return Task.WhenAll(tasks).ContinueWith(_ => continuationFunction(tasks)' CancellationToken.None' continuationOptions' TaskScheduler.Current); " is 142.
Long Statement,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAll,The length of the statement  "            return Task.WhenAll(tasks).ContinueWith(_ => continuationFunction(tasks)' cancellationToken' continuationOptions' scheduler); " is 125.
Long Statement,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The length of the statement  "            return Task.WhenAny(tasks).ContinueWith(_ => continuationAction(tasks)' cancellationToken' TaskContinuationOptions.None' TaskScheduler.Current); " is 144.
Long Statement,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The length of the statement  "            return Task.WhenAny(tasks).ContinueWith(_ => continuationAction(tasks)' CancellationToken.None' continuationOptions' TaskScheduler.Current); " is 140.
Long Statement,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The length of the statement  "            return Task.WhenAny(tasks).ContinueWith(_ => continuationAction(tasks)' cancellationToken' continuationOptions' scheduler); " is 123.
Long Statement,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The length of the statement  "            return Task.WhenAny(tasks).ContinueWith(_ => continuationFunction(tasks)' cancellationToken' continuationOptions' scheduler); " is 125.
Long Statement,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The length of the statement  "            return Task.WhenAny(tasks).ContinueWith(_ => continuationFunction(tasks)' CancellationToken.None' continuationOptions' TaskScheduler.Current); " is 142.
Long Statement,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The length of the statement  "            return Task.WhenAny(tasks).ContinueWith(_ => continuationFunction(tasks)' cancellationToken' TaskContinuationOptions.None' TaskScheduler.Current); " is 146.
Long Statement,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The length of the statement  "            return Task.WhenAny(tasks).ContinueWith(_ => continuationAction(tasks)' cancellationToken' continuationOptions' scheduler); " is 123.
Long Statement,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The length of the statement  "            return Task.WhenAny(tasks).ContinueWith(_ => continuationAction(tasks)' CancellationToken.None' continuationOptions' TaskScheduler.Current); " is 140.
Long Statement,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The length of the statement  "            return Task.WhenAny(tasks).ContinueWith(_ => continuationAction(tasks)' cancellationToken' TaskContinuationOptions.None' TaskScheduler.Current); " is 144.
Long Statement,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The length of the statement  "            return Task.WhenAny(tasks).ContinueWith(_ => continuationFunction(tasks)' cancellationToken' TaskContinuationOptions.None' TaskScheduler.Current); " is 146.
Long Statement,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The length of the statement  "            return Task.WhenAny(tasks).ContinueWith(_ => continuationFunction(tasks)' CancellationToken.None' continuationOptions' TaskScheduler.Current); " is 142.
Long Statement,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,ContinueWhenAny,The length of the statement  "            return Task.WhenAny(tasks).ContinueWith(_ => continuationFunction(tasks)' cancellationToken' continuationOptions' scheduler); " is 125.
Long Statement,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,StartNew,The length of the statement  "            var result = new Task(action' null' CancellationToken.None' TaskCreationOptions.None' InternalTaskOptions.None' _scheduler); " is 124.
Long Statement,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,StartNew,The length of the statement  "            var result = new Task(action' Task.InternalCurrentIfAttached(creationOptions)' CancellationToken.None' creationOptions' InternalTaskOptions.None' _scheduler); " is 158.
Long Statement,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,StartNew,The length of the statement  "            var result = new Task(action' Task.InternalCurrentIfAttached(creationOptions)' cancellationToken' creationOptions' InternalTaskOptions.None' scheduler); " is 152.
Long Statement,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,StartNew,The length of the statement  "            var result = new Task(action' state' null' CancellationToken.None' TaskCreationOptions.None' InternalTaskOptions.None' _scheduler); " is 131.
Long Statement,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,StartNew,The length of the statement  "            var result = new Task(action' state' null' cancellationToken' TaskCreationOptions.None' InternalTaskOptions.None' _scheduler); " is 126.
Long Statement,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,StartNew,The length of the statement  "            var result = new Task(action' state' Task.InternalCurrentIfAttached(creationOptions)' CancellationToken.None' creationOptions' InternalTaskOptions.None' _scheduler); " is 165.
Long Statement,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,StartNew,The length of the statement  "            var result = new Task(action' state' Task.InternalCurrentIfAttached(creationOptions)' cancellationToken' creationOptions' InternalTaskOptions.None' scheduler); " is 159.
Long Statement,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,FromAsync,The length of the statement  "            return FromAsyncCore((callback' obj) => beginMethod(arg1' arg2' arg3' callback' obj)' endMethod' state' creationOptions); " is 121.
Long Statement,System.Threading.Tasks,TaskFactory,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskFactory.cs,FromAsyncCore,The length of the statement  "            var task = new Task<TResult>(() => endMethod(asyncResult)' Task.InternalCurrentIfAttached(creationOptions)' CancellationToken.None' creationOptions' InternalTaskOptions.None' scheduler); " is 186.
Long Statement,System.Threading.Tasks,TaskReplicator,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskReplicator.cs,Run,The length of the statement  "            var maxConcurrencyLevel = options.EffectiveMaxConcurrencyLevel > 0 ? options.EffectiveMaxConcurrencyLevel : int.MaxValue; " is 121.
Long Statement,System.Threading.Tasks,TaskReplicator,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskReplicator.cs,GenerateCooperativeMultitaskingTaskTimeout,The length of the statement  "            // Otherwise all worker will try to timeout at precisely the same point' which is bad if the work is just about to finish. " is 122.
Long Statement,System.Threading.Tasks,Replica<TState>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\TaskReplicator.cs,CreateNewReplica,The length of the statement  "                var newReplica = new Replica<TState>(Replicator' RemainingConcurrency' GenerateCooperativeMultitaskingTaskTimeout()' _action); " is 126.
Long Statement,System.Threading.Tasks,ValueTask,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ValueTask.cs,Equals,The length of the statement  "            return _task != null || other._task != null ? _task == other._task : EqualityComparer<TResult>.Default.Equals(_result' other._result); " is 134.
Long Statement,Theraot.Core,ComparerExtensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\ComparerExtensions.cs,Reverse,The length of the statement  "            return !(comparer is ReverseComparer<T> originalAsReverse) ? new ReverseComparer<T>(comparer ?? Comparer<T>.Default) : originalAsReverse.Wrapped; " is 145.
Long Statement,Theraot.Core,FuncHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,GetReturnFunc,The length of the statement  "            return (/*T1*/ arg1' /*T2*/ arg2' /*T3*/ arg3' /*T4*/ arg4' /*T5*/ arg5' /*T6*/ arg6' /*T7*/ arg7' /*T8*/ arg8' /*T9*/ arg9) => def; " is 132.
Long Statement,Theraot.Core,FuncHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,GetReturnFunc,The length of the statement  "            return (/*T1*/ arg1' /*T2*/ arg2' /*T3*/ arg3' /*T4*/ arg4' /*T5*/ arg5' /*T6*/ arg6' /*T7*/ arg7' /*T8*/ arg8' /*T9*/ arg9' /*T10*/ arg10) => def; " is 147.
Long Statement,Theraot.Core,FuncHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,GetReturnFunc,The length of the statement  "            return (/*T1*/ arg1' /*T2*/ arg2' /*T3*/ arg3' /*T4*/ arg4' /*T5*/ arg5' /*T6*/ arg6' /*T7*/ arg7' /*T8*/ arg8' /*T9*/ arg9' /*T10*/ arg10' /*T11*/ arg11) => def; " is 162.
Long Statement,Theraot.Core,FuncHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,GetReturnFunc,The length of the statement  "            return (/*T1*/ arg1' /*T2*/ arg2' /*T3*/ arg3' /*T4*/ arg4' /*T5*/ arg5' /*T6*/ arg6' /*T7*/ arg7' /*T8*/ arg8' /*T9*/ arg9' /*T10*/ arg10' /*T11*/ arg11' /*T12*/ arg12) => def; " is 177.
Long Statement,Theraot.Core,FuncHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,GetReturnFunc,The length of the statement  "            return (/*T1*/ arg1' /*T2*/ arg2' /*T3*/ arg3' /*T4*/ arg4' /*T5*/ arg5' /*T6*/ arg6' /*T7*/ arg7' /*T8*/ arg8' /*T9*/ arg9' /*T10*/ arg10' /*T11*/ arg11' /*T12*/ arg12' /*T13*/ arg13) => def; " is 192.
Long Statement,Theraot.Core,FuncHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,GetReturnFunc,The length of the statement  "            return (/*T1*/ arg1' /*T2*/ arg2' /*T3*/ arg3' /*T4*/ arg4' /*T5*/ arg5' /*T6*/ arg6' /*T7*/ arg7' /*T8*/ arg8' /*T9*/ arg9' /*T10*/ arg10' /*T11*/ arg11' /*T12*/ arg12' /*T13*/ arg13' /*T14*/ arg14) => def; " is 207.
Long Statement,Theraot.Core,FuncHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,GetReturnFunc,The length of the statement  "            return (/*T1*/ arg1' /*T2*/ arg2' /*T3*/ arg3' /*T4*/ arg4' /*T5*/ arg5' /*T6*/ arg6' /*T7*/ arg7' /*T8*/ arg8' /*T9*/ arg9' /*T10*/ arg10' /*T11*/ arg11' /*T12*/ arg12' /*T13*/ arg13' /*T14*/ arg14' /*T15*/ arg15) => def; " is 222.
Long Statement,Theraot.Core,FuncHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,GetReturnFunc,The length of the statement  "            return (/*T1*/ arg1' /*T2*/ arg2' /*T3*/ arg3' /*T4*/ arg4' /*T5*/ arg5' /*T6*/ arg6' /*T7*/ arg7' /*T8*/ arg8' /*T9*/ arg9' /*T10*/ arg10' /*T11*/ arg11' /*T12*/ arg12' /*T13*/ arg13' /*T14*/ arg14' /*T15*/ arg15' /*T16*/ arg16) => def; " is 237.
Long Statement,Theraot.Core,FuncHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,GetThrowFunc,The length of the statement  "            return (/*T1*/ arg1' /*T2*/ arg2' /*T3*/ arg3' /*T4*/ arg4' /*T5*/ arg5' /*T6*/ arg6' /*T7*/ arg7' /*T8*/ arg8) => throw exception; " is 131.
Long Statement,Theraot.Core,FuncHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,GetThrowFunc,The length of the statement  "            return (/*T1*/ arg1' /*T2*/ arg2' /*T3*/ arg3' /*T4*/ arg4' /*T5*/ arg5' /*T6*/ arg6' /*T7*/ arg7' /*T8*/ arg8' /*T9*/ arg9) => throw exception; " is 144.
Long Statement,Theraot.Core,FuncHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,GetThrowFunc,The length of the statement  "            return (/*T1*/ arg1' /*T2*/ arg2' /*T3*/ arg3' /*T4*/ arg4' /*T5*/ arg5' /*T6*/ arg6' /*T7*/ arg7' /*T8*/ arg8' /*T9*/ arg9' /*T10*/ arg10) => throw exception; " is 159.
Long Statement,Theraot.Core,FuncHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,GetThrowFunc,The length of the statement  "            return (/*T1*/ arg1' /*T2*/ arg2' /*T3*/ arg3' /*T4*/ arg4' /*T5*/ arg5' /*T6*/ arg6' /*T7*/ arg7' /*T8*/ arg8' /*T9*/ arg9' /*T10*/ arg10' /*T11*/ arg11) => throw exception; " is 174.
Long Statement,Theraot.Core,FuncHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,GetThrowFunc,The length of the statement  "            return (/*T1*/ arg1' /*T2*/ arg2' /*T3*/ arg3' /*T4*/ arg4' /*T5*/ arg5' /*T6*/ arg6' /*T7*/ arg7' /*T8*/ arg8' /*T9*/ arg9' /*T10*/ arg10' /*T11*/ arg11' /*T12*/ arg12) => throw exception; " is 189.
Long Statement,Theraot.Core,FuncHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,GetThrowFunc,The length of the statement  "            return (/*T1*/ arg1' /*T2*/ arg2' /*T3*/ arg3' /*T4*/ arg4' /*T5*/ arg5' /*T6*/ arg6' /*T7*/ arg7' /*T8*/ arg8' /*T9*/ arg9' /*T10*/ arg10' /*T11*/ arg11' /*T12*/ arg12' /*T13*/ arg13) => throw exception; " is 204.
Long Statement,Theraot.Core,FuncHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,GetThrowFunc,The length of the statement  "            return (/*T1*/ arg1' /*T2*/ arg2' /*T3*/ arg3' /*T4*/ arg4' /*T5*/ arg5' /*T6*/ arg6' /*T7*/ arg7' /*T8*/ arg8' /*T9*/ arg9' /*T10*/ arg10' /*T11*/ arg11' /*T12*/ arg12' /*T13*/ arg13' /*T14*/ arg14) => throw exception; " is 219.
Long Statement,Theraot.Core,FuncHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,GetThrowFunc,The length of the statement  "            return (/*T1*/ arg1' /*T2*/ arg2' /*T3*/ arg3' /*T4*/ arg4' /*T5*/ arg5' /*T6*/ arg6' /*T7*/ arg7' /*T8*/ arg8' /*T9*/ arg9' /*T10*/ arg10' /*T11*/ arg11' /*T12*/ arg12' /*T13*/ arg13' /*T14*/ arg14' /*T15*/ arg15) => throw exception; " is 234.
Long Statement,Theraot.Core,FuncHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FuncHelper.cs,GetThrowFunc,The length of the statement  "            return (/*T1*/ arg1' /*T2*/ arg2' /*T3*/ arg3' /*T4*/ arg4' /*T5*/ arg5' /*T6*/ arg6' /*T7*/ arg7' /*T8*/ arg8' /*T9*/ arg9' /*T10*/ arg10' /*T11*/ arg11' /*T12*/ arg12' /*T13*/ arg13' /*T14*/ arg14' /*T15*/ arg15' /*T16*/ arg16) => throw exception; " is 249.
Long Statement,Theraot.Core,GraphHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\GraphHelper.cs,ExploreBreadthFirstGraph,The length of the statement  "            return ExploreBreadthFirstGraphExtracted(branches' next' FuncHelper.GetIdentityFunc<T>()' comparer ?? EqualityComparer<T>.Default); " is 131.
Long Statement,Theraot.Core,GraphHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\GraphHelper.cs,ExploreBreadthFirstGraph,The length of the statement  "            return ExploreBreadthFirstGraphExtracted(branches' next' FuncHelper.GetIdentityFunc<T>()' comparer ?? EqualityComparer<T>.Default); " is 131.
Long Statement,Theraot.Core,GraphHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\GraphHelper.cs,ExploreDepthFirstGraph,The length of the statement  "            return ExploreDepthFirstGraphExtracted(branches' next' FuncHelper.GetIdentityFunc<T>()' comparer ?? EqualityComparer<T>.Default); " is 129.
Long Statement,Theraot.Core,GraphHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\GraphHelper.cs,ExploreDepthFirstGraph,The length of the statement  "            return ExploreDepthFirstGraphExtracted(branches' next' FuncHelper.GetIdentityFunc<T>()' comparer ?? EqualityComparer<T>.Default); " is 129.
Long Statement,Theraot.Core,PathHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\PathHelper.cs,Combine,The length of the statement  "            if (HasInvalidPathChars(path1) || HasInvalidPathChars(path2) || HasInvalidPathChars(path3) || HasInvalidPathChars(path4)) " is 121.
Long Statement,Theraot.Core,SequenceHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\SequenceHelper.cs,ExploreSequenceUntilNull,The length of the statement  "            return ExploreSequenceExtractedUntilNull(initial' endCondition' next' FuncHelper.GetIdentityFunc<T>()' EqualityComparer<T>.Default); " is 132.
Long Statement,Theraot.Core,SequenceHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\SequenceHelper.cs,ExploreSequenceUntilNull,The length of the statement  "            return ExploreSequenceExtractedUntilNull(initial' endCondition' next' FuncHelper.GetIdentityFunc<T>()' EqualityComparer<T>.Default); " is 132.
Long Statement,Theraot.Core,SequenceHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\SequenceHelper.cs,ExploreSequenceUntilNull,The length of the statement  "            return ExploreSequenceExtractedUntilNull(initial' endCondition' next' resultSelector' EqualityComparer<TInput>.Default); " is 120.
Long Statement,Theraot.Core,SequenceHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\SequenceHelper.cs,ExploreSequenceUntilNull,The length of the statement  "            return ExploreSequenceExtractedUntilNull(initial' endCondition' next' resultSelector' EqualityComparer<TInput>.Default); " is 120.
Long Statement,Theraot.Core,StringProcessor,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\StringProcessor.cs,ReadUntil,The length of the statement  "            return SkipUntil(targets' out found' stringComparison' greedy) ? String.Substring(oldPosition' _position - oldPosition) : null; " is 127.
Long Statement,System.Threading.Tasks.Sources,ManualResetValueTaskSourceCore,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Sources\ManualResetValueTaskSourceCore.cs,SignalCompletion,The length of the statement  "            if (_continuation != null || Interlocked.CompareExchange(ref _continuation' ManualResetValueTaskSourceCoreShared.Sentinel' null) != null) " is 137.
Long Statement,System.Threading.Tasks.Sources,ManualResetValueTaskSourceCore,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Sources\ManualResetValueTaskSourceCore.cs,InvokeContinuation,The length of the statement  "                    Task.Factory.StartNew(continuation' _continuationState' CancellationToken.None' TaskCreationOptions.DenyChildAttach' ts); " is 121.
Long Statement,Theraot.Collections,Extensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\Extensions.add.cs,GroupProgressiveBy,The length of the statement  "                return GroupBuilder<TKey' TSource' TElement>.CreateGroups(source' EqualityComparer<TKey>.Default' keySelector' resultSelector); " is 127.
Long Statement,Theraot.Collections,Extensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\Extensions.add.cs,GroupProgressiveBy,The length of the statement  "                return GroupBuilder<TKey' TSource' TSource>.CreateGroups(source' EqualityComparer<TKey>.Default' keySelector' FuncHelper.GetIdentityFunc<TSource>()); " is 149.
Long Statement,Theraot.Collections,Extensions,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\Extensions.add.cs,GroupProgressiveBy,The length of the statement  "            return GroupBuilder<TKey' TSource' TSource>.CreateGroups(source' comparer' keySelector' FuncHelper.GetIdentityFunc<TSource>()); " is 127.
Long Statement,Theraot.Collections,ProgressiveLookup<TKey;T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\ProgressiveLookup.cs,Create,The length of the statement  "            return new ProgressiveLookup<TKey' T>(source.GroupProgressiveBy(keySelector' elementSelector' keyComparer)' keyComparer); " is 121.
Long Statement,Theraot.Collections,ProgressiveLookup<TKey;T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\ProgressiveLookup.cs,Create,The length of the statement  "            return new ProgressiveLookup<TKey' T>(source.GroupProgressiveBy(item => item.Key' item => item.Value' keyComparer)' keyComparer); " is 129.
Long Statement,Theraot.Collections,Progressor<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\Progressor.cs,CreateFromIObservable,The length of the statement  "                    if (Interlocked.CompareExchange(ref tryTake[0]' (out T value1) => TakeReplacement(out value1)' tryTake[0]) == tryTake[0]) " is 121.
Long Statement,Theraot.Collections.Specialized,AVLNode<TKey;TValue>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\Specialized\AVLNode.cs,AddNonDuplicateExtracted,The length of the statement  "                return compare < 0 ? AddNonDuplicateExtracted(ref node._left' key' value' comparer' created) : AddNonDuplicateExtracted(ref node._right' key' value' comparer' created); " is 168.
Long Statement,Theraot.Collections.Specialized,NullAwareDictionary<TKey;TValue>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\Specialized\NullAwareDictionary.cs,CopyTo,The length of the statement  "            _wrapped.ConvertedCopyTo(pair => new KeyValuePair<ReadOnlyStructNeedle<TKey>' TValue>(new ReadOnlyStructNeedle<TKey>(pair.Key)' pair.Value)' array' arrayIndex); " is 160.
Long Statement,Theraot.Collections.Specialized,NullAwareDictionary<TKey;TValue>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\Specialized\NullAwareDictionary.cs,GetEnumerator,The length of the statement  "                yield return new KeyValuePair<ReadOnlyStructNeedle<TKey>' TValue>(new ReadOnlyStructNeedle<TKey>(pair.Key)' pair.Value); " is 120.
Long Statement,Theraot.Collections.ThreadSafe,ThreadSafeDictionary<TKey;TValue>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\ThreadSafe\ThreadSafeDictionary.cs,ContainsKey,The length of the statement  "                if (_bucket.TryGet(hashCode + attempts' out var found) && GetHashCode(found.Key) == hashCode && keyCheck(found.Key) && valueCheck(found.Value)) " is 143.
Long Statement,Theraot.Collections.ThreadSafe,ThreadSafeDictionary<TKey;TValue>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\ThreadSafe\ThreadSafeDictionary.cs,GetOrAdd,The length of the statement  "                if (_bucket.TryGetOrInsert(hashCode + attempts' () => new KeyValuePair<TKey' TValue>(key' valueFactory(key))' out var storedPair)) " is 130.
Long Statement,Theraot.Collections.ThreadSafe,ThreadSafeDictionary<TKey;TValue>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\ThreadSafe\ThreadSafeDictionary.cs,Set,The length of the statement  "                if (_bucket.InsertOrUpdateChecked(hashCode + attempts' insertPair' found => Comparer.Equals(found.Key' key)' out isNew)) " is 120.
Long Statement,Theraot.Collections.ThreadSafe,ThreadSafeDictionary<TKey;TValue>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\ThreadSafe\ThreadSafeDictionary.cs,TryGetOrAdd,The length of the statement  "                if (_bucket.TryGetOrInsert(hashCode + attempts' () => new KeyValuePair<TKey' TValue>(key' valueFactory(key))' out var storedPair)) " is 130.
Long Statement,Theraot.Collections.ThreadSafe,ThreadSafeDictionary<TKey;TValue>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\ThreadSafe\ThreadSafeDictionary.cs,TryUpdate,The length of the statement  "                if (_bucket.Update(hashCode + attempts' existing => new KeyValuePair<TKey' TValue>(key' newValue(existing.Value))' Check' out _)) " is 129.
Long Statement,Theraot.Collections.ThreadSafe,WeakDictionary<TKey;TValue>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\ThreadSafe\WeakDictionary.cs,Contains,The length of the statement  "            return Wrapped.ContainsKey(Comparer.GetHashCode(item.Key)' Check' input => EqualityComparer<TValue>.Default.Equals(input' item.Value)); " is 135.
Long Statement,Theraot.Collections.ThreadSafe,WeakDictionary<TKey;TValue>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\ThreadSafe\WeakDictionary.cs,ContainsKey,The length of the statement  "            return Wrapped.ContainsKey(Comparer.GetHashCode(key)' input => PrivateTryGetValue(input' out var foundKey) && Comparer.Equals(foundKey' key)); " is 142.
Long Statement,Theraot.Collections.ThreadSafe,WeakDictionary<TKey;TValue>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\ThreadSafe\WeakDictionary.cs,ContainsKey,The length of the statement  "            return Wrapped.ContainsKey(hashCode' input => PrivateTryGetValue(input' out var foundKey) && keyCheck(foundKey)' valueCheck); " is 125.
Long Statement,Theraot.Collections.ThreadSafe,WeakDictionary<TKey;TValue>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\ThreadSafe\WeakDictionary.cs,Remove,The length of the statement  "            return Wrapped.Remove(Comparer.GetHashCode(key)' input => PrivateTryGetValue(input' out var foundKey) && Comparer.Equals(foundKey' key)' out _); " is 144.
Long Statement,Theraot.Collections.ThreadSafe,WeakDictionary<TKey;TValue>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\ThreadSafe\WeakDictionary.cs,Remove,The length of the statement  "            return Wrapped.Remove(Comparer.GetHashCode(key)' input => PrivateTryGetValue(input' out var foundKey) && Comparer.Equals(foundKey' key)' valueCheck' out value); " is 160.
Long Statement,Theraot.Collections.ThreadSafe,WeakDictionary<TKey;TValue>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\ThreadSafe\WeakDictionary.cs,Remove,The length of the statement  "            return Wrapped.Remove(Comparer.GetHashCode(key)' input => PrivateTryGetValue(input' out var foundKey) && Comparer.Equals(foundKey' key)' out value); " is 148.
Long Statement,Theraot.Collections.ThreadSafe,WeakDictionary<TKey;TValue>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\ThreadSafe\WeakDictionary.cs,Remove,The length of the statement  "            return Wrapped.Remove(hashCode' input => PrivateTryGetValue(input' out var foundKey) && keyCheck.Invoke(foundKey)' out value); " is 126.
Long Statement,Theraot.Collections.ThreadSafe,WeakDictionary<TKey;TValue>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\ThreadSafe\WeakDictionary.cs,Remove,The length of the statement  "            return Wrapped.Remove(hashCode' input => PrivateTryGetValue(input' out var foundKey) && keyCheck.Invoke(foundKey)' valueCheck' out value); " is 138.
Long Statement,Theraot.Collections.ThreadSafe,WeakDictionary<TKey;TValue>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\ThreadSafe\WeakDictionary.cs,Remove,The length of the statement  "            return Wrapped.Remove(Comparer.GetHashCode(item.Key)' Check' input => EqualityComparer<TValue>.Default.Equals(input' item.Value)' out _); " is 137.
Long Statement,Theraot.Collections.ThreadSafe,WeakDictionary<TKey;TValue>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\ThreadSafe\WeakDictionary.cs,RemoveWhereKeyEnumerable,The length of the statement  "            return Wrapped.RemoveWhereKeyEnumerable(input => PrivateTryGetValue(input' out var foundKey) && keyCheck.Invoke(foundKey)); " is 123.
Long Statement,Theraot.Collections.ThreadSafe,WeakDictionary<TKey;TValue>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\ThreadSafe\WeakDictionary.cs,GetOrAdd,The length of the statement  "            if (!Wrapped.TryGetOrAdd(needle' input => !PrivateTryGetValue(input' out var foundKey) || keyOverwriteCheck(foundKey)' value' out var stored)) " is 142.
Long Statement,Theraot.Collections.ThreadSafe,WeakDictionary<TKey;TValue>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\ThreadSafe\WeakDictionary.cs,Set,The length of the statement  "            Wrapped.Set(needle' input => !PrivateTryGetValue(input' out var foundKey) || keyOverwriteCheck(foundKey)' value' out isNew); " is 124.
Long Statement,Theraot.Collections.ThreadSafe,WeakDictionary<TKey;TValue>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\ThreadSafe\WeakDictionary.cs,TryAdd,The length of the statement  "            if (Wrapped.TryAdd(needle' input => !PrivateTryGetValue(input' out var foundKey) || keyOverwriteCheck(foundKey)' value)) " is 120.
Long Statement,Theraot.Collections.ThreadSafe,WeakDictionary<TKey;TValue>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\ThreadSafe\WeakDictionary.cs,TryGetOrAdd,The length of the statement  "            if (Wrapped.TryGetOrAdd(needle' input => !PrivateTryGetValue(input' out var foundKey) || keyOverwriteCheck(foundKey)' value' out stored)) " is 137.
Long Statement,Theraot.Reflection,DelegateHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\DelegateHelper.cs,MakeNewCustomDelegate,The length of the statement  "            builder.DefineConstructor(_ctorAttributes' CallingConventions.Standard' _delegateCtorSignature).SetImplementationFlags(_implAttributes); " is 136.
Long Statement,Theraot.Reflection,DelegateHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\DelegateHelper.cs,MakeNewDelegate,The length of the statement  "            var needCustom = types.Length > _maximumArity || types.Any(type => type.IsByRef || /*type.IsByRefLike ||*/ type.IsPointer); " is 123.
Long Statement,Theraot.Reflection,DelegateHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\DelegateHelper.cs,MakeNewDelegate,The length of the statement  "            return types[types.Length - 1] == typeof(void) ? DelegateBuilder.GetActionType(types.RemoveLast())! : DelegateBuilder.GetFuncType(types)!; " is 138.
Long Statement,Theraot.Reflection,TypeHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\TypeHelper.cs,GetDelegateMethodInfo,The length of the statement  "            var methodInfo = delegateType.GetRuntimeMethods().FirstOrDefault(info => string.Equals(info.Name' "Invoke"' StringComparison.Ordinal)); " is 135.
Long Statement,Theraot.Reflection,TypeHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\TypeHelper.cs,LazyCreate,The length of the statement  "                throw new MissingMemberException("The type being lazily initialized does not have a public' parameterless constructor."); " is 121.
Long Statement,Theraot.Reflection,TypeHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\TypeHelper.cs,GetUserDefinedConversionMethod,The length of the statement  "                return FindConversionOperator(sourceStaticMethods = nonNullableSource.GetStaticMethodsInternal()' source' target' implicitOnly) " is 127.
Long Statement,Theraot.Reflection,TypeHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\TypeHelper.cs,GetUserDefinedConversionMethod,The length of the statement  "                       ?? FindConversionOperator(targetStaticMethods = nonNullableTarget.GetStaticMethodsInternal()' source' target' implicitOnly) " is 123.
Long Statement,Theraot.Reflection,TypeHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\TypeHelper.cs,GetUserDefinedConversionMethod,The length of the statement  "                return FindConversionOperator(sourceStaticMethods = nonNullableSource.GetStaticMethodsInternal()' source' target' implicitOnly) " is 127.
Long Statement,Theraot.Reflection,TypeHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\TypeHelper.cs,GetUserDefinedConversionMethod,The length of the statement  "                       ?? FindConversionOperator(targetStaticMethods = nonNullableTarget.GetStaticMethodsInternal()' source' target' implicitOnly) " is 123.
Long Statement,Theraot.Reflection,TypeHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\TypeHelper.cs,GetUserDefinedConversionMethod,The length of the statement  "            return FindConversionOperator(sourceStaticMethods = nonNullableSource.GetStaticMethodsInternal()' source' target' implicitOnly) " is 127.
Long Statement,Theraot.Reflection,TypeHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\TypeHelper.cs,GetUserDefinedConversionMethod,The length of the statement  "                   ?? FindConversionOperator(targetStaticMethods = nonNullableTarget.GetStaticMethodsInternal()' source' target' implicitOnly) " is 123.
Long Statement,Theraot.Threading,DisposableAkin,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Threading\DisposableAkin.cs,Dispose,The length of the statement  "            var found = Interlocked.CompareExchange(ref _threadUniqueId' null' new StrongBox<UniqueId>(ThreadUniqueId.CurrentThreadId)); " is 124.
Long Statement,Theraot.Threading,DisposableAkin,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Threading\DisposableAkin.cs,Dispose,The length of the statement  "                var found = Interlocked.CompareExchange(ref _threadUniqueId' null' new StrongBox<UniqueId>(ThreadUniqueId.CurrentThreadId)); " is 124.
Long Statement,Theraot.Threading,Internal,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Threading\GCMonitor.internal.cs,RaiseCollected,The length of the statement  "                    CollectedEventHandlers.Invoke(ActionHelper.GetNoopAction<Exception>()' DelegateCollectionInvokeOptions.None' null' EventArgs.Empty); " is 132.
Complex Conditional,System,Tuple<T1;T2;T3;T4;T5;T6;T7;TRest>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,CheckType,The conditional expression  "type == typeof(Tuple<>)                  || type == typeof(Tuple<'>)                  || type == typeof(Tuple<''>)                  || type == typeof(Tuple<'''>)                  || type == typeof(Tuple<''''>)                  || type == typeof(Tuple<'''''>)                  || type == typeof(Tuple<''''''>)                  || type == typeof(Tuple<'''''''>)"  is complex.
Complex Conditional,System.ComponentModel.DataAnnotations,LocalizableString,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ComponentModel\DataAnnotations\LocalizableString.cs,GetCachedResult,The conditional expression  "!resourceTypeInfo.IsVisible || property == null || property.PropertyType != typeof(string) || !IsGetterPublicAndStatic()"  is complex.
Complex Conditional,System.Dynamic.Utils,TypeUtils,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\Utils\TypeUtils.cs,HasBuiltInEqualityOperator,The conditional expression  "!left.IsValueType && !right.IsValueType && (left.IsReferenceAssignableFromInternal(right) || right.IsReferenceAssignableFromInternal(left))"  is complex.
Complex Conditional,System.Dynamic.Utils,TypeUtils,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\Utils\TypeUtils.cs,IsLegalExplicitVariantDelegateConversion,The conditional expression  "!PrivateIsDelegate(source) || !PrivateIsDelegate(target) || !source.IsGenericType || !target.IsGenericType"  is complex.
Complex Conditional,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,GetEqualityComparisonOperator,The conditional expression  "left.Type == right.Type                  &&                  (                      left.Type.IsNumeric()                      || left.Type == typeof(object)                      || left.Type.IsBool()                      || left.Type.GetNonNullable().IsEnum                  )"  is complex.
Complex Conditional,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,GetMethodBasedBinaryOperator,The conditional expression  "!left.Type.IsNullable() || !right.Type.IsNullable() || !ParameterIsAssignable(pms[0]' left.Type.GetNonNullable()) || !ParameterIsAssignable(pms[1]' right.Type.GetNonNullable()) || !method.ReturnType.IsValueType || method.ReturnType.IsNullable()"  is complex.
Complex Conditional,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateUserDefinedConditionalLogicOperator,The conditional expression  "opTrue == null || opTrue.ReturnType != typeof(bool) || opFalse == null || opFalse.ReturnType != typeof(bool)"  is complex.
Complex Conditional,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,DebugInfo,The conditional expression  "startLine == 0xfeefee && startColumn == 0 && endLine == 0xfeefee && endColumn == 0"  is complex.
Complex Conditional,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,GetMethodBasedCoercionOperator,The conditional expression  "(operand.Type.IsNullable() || convertToType.IsNullable())                  && ParameterIsAssignable(pms[0]' operand.Type.GetNonNullable())                  && (TypeUtils.AreEquivalent(method.ReturnType' convertToType.GetNonNullable())                      || TypeUtils.AreEquivalent(method.ReturnType' convertToType))"  is complex.
Complex Conditional,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,GetMethodBasedUnaryOperator,The conditional expression  "operand.Type.IsNullable()                  && ParameterIsAssignable(pms[0]' operand.Type.GetNonNullable())                  && method.ReturnType.IsValueType && !method.ReturnType.IsNullable()"  is complex.
Complex Conditional,System.Linq.Expressions,SwitchExpression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\SwitchExpression.cs,Update,The conditional expression  "switchValue == SwitchValue && defaultBody == DefaultBody && cases != null && ExpressionUtils.SameElements(ref cases' _cases)"  is complex.
Complex Conditional,System.Linq.Expressions,TryExpression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\TryExpression.cs,Update,The conditional expression  "body == Body && @finally == Finally && fault == Fault && ExpressionUtils.SameElements(ref handlers' _handlers)"  is complex.
Complex Conditional,System.Linq.Expressions.Compiler,ILGen,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitConvertToType,The conditional expression  "typeFrom.IsInterface // interface cast                  || typeTo.IsInterface                  || typeFrom == typeof(object) // boxing cast                  || typeTo == typeof(object)                  || typeFrom == typeof(Enum)                  || typeFrom == typeof(ValueType)                  || TypeUtils.IsLegalExplicitVariantDelegateConversion(typeFrom' typeTo)"  is complex.
Complex Conditional,System.Linq.Expressions.Compiler,ILGen,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitConvertToType,The conditional expression  "!(typeFrom.IsConvertible() && typeTo.IsConvertible()) // primitive runtime conversion                  &&                  (                      nnExprType.IsAssignableFrom(nnType) // down cast                      || nnType.IsAssignableFrom(nnExprType) // up cast                  )"  is complex.
Complex Conditional,System.Linq.Expressions.Compiler,LambdaCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.cs,AddressOf,The conditional expression  "node.Object != null                  && !node.Method.IsStatic                  && node.Object.Type.IsArray                  && node.Method == node.Object.Type.GetMethod("Get"' BindingFlags.Public | BindingFlags.Instance)"  is complex.
Complex Conditional,System.Linq.Expressions.Compiler,LambdaCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.cs,EmitBinaryExpression,The conditional expression  "(b.NodeType == ExpressionType.Equal || b.NodeType == ExpressionType.NotEqual)                  && (b.Type == typeof(bool) || b.Type == typeof(bool?))"  is complex.
Complex Conditional,System.Linq.Expressions.Interpreter,LightCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\LightCompiler.cs,CompileConvertToType,The conditional expression  "(nonNullableFrom.IsNumericOrBool() || nonNullableFrom.IsEnum)                  && (nonNullableTo.IsNumericOrBool() || nonNullableTo.IsEnum || nonNullableTo == typeof(decimal))"  is complex.
Complex Conditional,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,FormatBigInteger,The conditional expression  "fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R'"  is complex.
Complex Conditional,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,ParseFormatSpecifier,The conditional expression  "(chr < 'A' || chr > 'Z') && (chr < 'a' || chr > 'z')"  is complex.
Complex Conditional,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,Gcd,The conditional expression  "(reg1._iuLast <= 0 || reg1._bits![0] != 0) && (reg2._iuLast <= 0 || reg2._bits![0] != 0)"  is complex.
Complex Conditional,System.Threading,ReaderWriterLockSlim,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\ReaderWriterLockSlim.cs,CheckState,The conditional expression  "stateLockState != LockState.None && _noRecursion && (!((stateLockState & LockState.Upgradable) > 0) || validState == LockState.Upgradable)"  is complex.
Complex Conditional,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,UpdateExceptionObservedStatus,The conditional expression  "_parent != null && (CreationOptions & TaskCreationOptions.AttachedToParent) != 0 && (_parent.CreationOptions & TaskCreationOptions.DenyChildAttach) == 0 && InternalCurrent == _parent"  is complex.
Complex Conditional,Theraot.Core,PathHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\PathHelper.cs,Combine,The conditional expression  "combine.Count > 0                      && !current.EndsWith(DirectorySeparatorString' StringComparison.Ordinal)                      && !current.EndsWith(AltDirectorySeparatorString' StringComparison.Ordinal)                      && !current.EndsWith(VolumeSeparatorString' StringComparison.Ordinal)"  is complex.
Complex Conditional,Theraot.Core,PathHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\PathHelper.cs,Combine,The conditional expression  "path1.Length != 0                  && !path1.EndsWith(DirectorySeparatorString' StringComparison.Ordinal)                  && !path1.EndsWith(AltDirectorySeparatorString' StringComparison.Ordinal)                  && !path1.EndsWith(VolumeSeparatorString' StringComparison.Ordinal)"  is complex.
Complex Conditional,Theraot.Core,PathHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\PathHelper.cs,Combine,The conditional expression  "path1.Length != 0                  && !path1.EndsWith(DirectorySeparatorString' StringComparison.Ordinal)                  && !path1.EndsWith(AltDirectorySeparatorString' StringComparison.Ordinal)                  && !path1.EndsWith(VolumeSeparatorString' StringComparison.Ordinal)"  is complex.
Complex Conditional,Theraot.Core,PathHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\PathHelper.cs,Combine,The conditional expression  "HasInvalidPathChars(path1) || HasInvalidPathChars(path2) || HasInvalidPathChars(path3) || HasInvalidPathChars(path4)"  is complex.
Complex Conditional,Theraot.Core,PathHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\PathHelper.cs,Combine,The conditional expression  "path1.Length != 0                  && !path1.EndsWith(DirectorySeparatorString' StringComparison.Ordinal)                  && !path1.EndsWith(AltDirectorySeparatorString' StringComparison.Ordinal)                  && !path1.EndsWith(VolumeSeparatorString' StringComparison.Ordinal)"  is complex.
Complex Conditional,Theraot.Collections.ThreadSafe,ThreadSafeDictionary<TKey;TValue>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\ThreadSafe\ThreadSafeDictionary.cs,ContainsKey,The conditional expression  "_bucket.TryGet(hashCode + attempts' out var found) && GetHashCode(found.Key) == hashCode && keyCheck(found.Key) && valueCheck(found.Value)"  is complex.
Complex Conditional,Theraot.Reflection,TypeHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\TypeHelper.cs,IsImplicitNumericConversion,The conditional expression  "target == typeof(short)                      || target == typeof(int)                      || target == typeof(long)                      || target == typeof(float)                      || target == typeof(double)                      || target == typeof(decimal)"  is complex.
Complex Conditional,Theraot.Reflection,TypeHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\TypeHelper.cs,IsImplicitNumericConversion,The conditional expression  "target == typeof(short)                      || target == typeof(ushort)                      || target == typeof(int)                      || target == typeof(uint)                      || target == typeof(long)                      || target == typeof(ulong)                      || target == typeof(float)                      || target == typeof(double)                      || target == typeof(decimal)"  is complex.
Complex Conditional,Theraot.Reflection,TypeHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\TypeHelper.cs,IsImplicitNumericConversion,The conditional expression  "target == typeof(int)                      || target == typeof(long)                      || target == typeof(float)                      || target == typeof(double)                      || target == typeof(decimal)"  is complex.
Complex Conditional,Theraot.Reflection,TypeHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\TypeHelper.cs,IsImplicitNumericConversion,The conditional expression  "target == typeof(int)                      || target == typeof(uint)                      || target == typeof(long)                      || target == typeof(ulong)                      || target == typeof(float)                      || target == typeof(double)                      || target == typeof(decimal)"  is complex.
Complex Conditional,Theraot.Reflection,TypeHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\TypeHelper.cs,IsImplicitNumericConversion,The conditional expression  "target == typeof(long)                      || target == typeof(float)                      || target == typeof(double)                      || target == typeof(decimal)"  is complex.
Complex Conditional,Theraot.Reflection,TypeHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\TypeHelper.cs,IsImplicitNumericConversion,The conditional expression  "target == typeof(ulong)                      || target == typeof(float)                      || target == typeof(double)                      || target == typeof(decimal)"  is complex.
Complex Conditional,Theraot.Reflection,TypeHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\TypeHelper.cs,IsImplicitNumericConversion,The conditional expression  "target == typeof(ushort)                      || target == typeof(int)                      || target == typeof(uint)                      || target == typeof(long)                      || target == typeof(ulong)                      || target == typeof(float)                      || target == typeof(double)                      || target == typeof(decimal)"  is complex.
Complex Conditional,Theraot.Threading,ThreadingHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Threading\ThreadingHelper.cs,SpinWaitRelativeExchangeBounded,The conditional expression  "lastValue < minValue || lastValue > maxValue || lastValue + value < minValue || lastValue > maxValue - value"  is complex.
Empty Catch Block,Theraot.Core,FolderEnumeration,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FolderEnumeration.cs,GetFiles,The method has an empty catch block.
Empty Catch Block,Theraot.Core,FolderEnumeration,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\FolderEnumeration.cs,GetFiles,The method has an empty catch block.
Magic Number,System,HashCode,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\HashCode.cs,Combine,The following statement contains a magic number: hash += 4;
Magic Number,System,HashCode,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\HashCode.cs,Combine,The following statement contains a magic number: hash += 8;
Magic Number,System,HashCode,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\HashCode.cs,Combine,The following statement contains a magic number: hash += 12;
Magic Number,System,HashCode,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\HashCode.cs,Combine,The following statement contains a magic number: hash += 16;
Magic Number,System,HashCode,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\HashCode.cs,Combine,The following statement contains a magic number: hash += 20;
Magic Number,System,HashCode,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\HashCode.cs,Combine,The following statement contains a magic number: hash += 24;
Magic Number,System,HashCode,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\HashCode.cs,Combine,The following statement contains a magic number: hash += 28;
Magic Number,System,HashCode,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\HashCode.cs,Combine,The following statement contains a magic number: hash += 32;
Magic Number,System,HashCode,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\HashCode.cs,ToHashCode,The following statement contains a magic number: var position = length % 4;
Magic Number,System,HashCode,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\HashCode.cs,ToHashCode,The following statement contains a magic number: var hash = length < 4 ? MixEmptyState() : MixState(_v1' _v2' _v3' _v4);
Magic Number,System,HashCode,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\HashCode.cs,ToHashCode,The following statement contains a magic number: hash += length * 4;
Magic Number,System,HashCode,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\HashCode.cs,ToHashCode,The following statement contains a magic number: position > 2
Magic Number,System,HashCode,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\HashCode.cs,GenerateGlobalSeed,The following statement contains a magic number: var bytes = new byte[4];
Magic Number,System,HashCode,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\HashCode.cs,MixFinal,The following statement contains a magic number: hash ^= hash >> 15;
Magic Number,System,HashCode,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\HashCode.cs,MixFinal,The following statement contains a magic number: hash ^= hash >> 13;
Magic Number,System,HashCode,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\HashCode.cs,MixFinal,The following statement contains a magic number: hash ^= hash >> 16;
Magic Number,System,HashCode,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\HashCode.cs,MixState,The following statement contains a magic number: return BitOperations.RotateLeft(v1' 1) + BitOperations.RotateLeft(v2' 7) + BitOperations.RotateLeft(v3' 12) + BitOperations.RotateLeft(v4' 18);
Magic Number,System,HashCode,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\HashCode.cs,MixState,The following statement contains a magic number: return BitOperations.RotateLeft(v1' 1) + BitOperations.RotateLeft(v2' 7) + BitOperations.RotateLeft(v3' 12) + BitOperations.RotateLeft(v4' 18);
Magic Number,System,HashCode,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\HashCode.cs,MixState,The following statement contains a magic number: return BitOperations.RotateLeft(v1' 1) + BitOperations.RotateLeft(v2' 7) + BitOperations.RotateLeft(v3' 12) + BitOperations.RotateLeft(v4' 18);
Magic Number,System,HashCode,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\HashCode.cs,QueueRound,The following statement contains a magic number: return BitOperations.RotateLeft(hash + (queuedValue * _prime3)' 17) * _prime4;
Magic Number,System,HashCode,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\HashCode.cs,Round,The following statement contains a magic number: return BitOperations.RotateLeft(hash + (input * _prime2)' 13) * _prime1;
Magic Number,System,HashCode,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\HashCode.cs,Add,The following statement contains a magic number: var position = previousLength % 4;
Magic Number,System,IntPtrEx,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\IntPtrEx.cs,Add,The following statement contains a magic number: IntPtr.Size == 4
Magic Number,System,IntPtrEx,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\IntPtrEx.cs,Add,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,System,IntPtrEx,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\IntPtrEx.cs,Subtract,The following statement contains a magic number: IntPtr.Size == 4
Magic Number,System,IntPtrEx,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\IntPtrEx.cs,Subtract,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,System,Tuple<T1;T2>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(Item2);
Magic Number,System,Tuple<T1;T2;T3>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(Item2);
Magic Number,System,Tuple<T1;T2;T3>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(Item3);
Magic Number,System,Tuple<T1;T2;T3;T4>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(Item2);
Magic Number,System,Tuple<T1;T2;T3;T4>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(Item3);
Magic Number,System,Tuple<T1;T2;T3;T4>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(Item4);
Magic Number,System,Tuple<T1;T2;T3;T4;T5>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(Item2);
Magic Number,System,Tuple<T1;T2;T3;T4;T5>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(Item3);
Magic Number,System,Tuple<T1;T2;T3;T4;T5>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(Item4);
Magic Number,System,Tuple<T1;T2;T3;T4;T5>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(Item5);
Magic Number,System,Tuple<T1;T2;T3;T4;T5;T6>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(Item2);
Magic Number,System,Tuple<T1;T2;T3;T4;T5;T6>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(Item3);
Magic Number,System,Tuple<T1;T2;T3;T4;T5;T6>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(Item4);
Magic Number,System,Tuple<T1;T2;T3;T4;T5;T6>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(Item5);
Magic Number,System,Tuple<T1;T2;T3;T4;T5;T6>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(Item6);
Magic Number,System,Tuple<T1;T2;T3;T4;T5;T6;T7>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(Item2);
Magic Number,System,Tuple<T1;T2;T3;T4;T5;T6;T7>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(Item3);
Magic Number,System,Tuple<T1;T2;T3;T4;T5;T6;T7>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(Item4);
Magic Number,System,Tuple<T1;T2;T3;T4;T5;T6;T7>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(Item5);
Magic Number,System,Tuple<T1;T2;T3;T4;T5;T6;T7>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(Item6);
Magic Number,System,Tuple<T1;T2;T3;T4;T5;T6;T7>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(Item7);
Magic Number,System,Tuple<T1;T2;T3;T4;T5;T6;T7;TRest>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(Item2);
Magic Number,System,Tuple<T1;T2;T3;T4;T5;T6;T7;TRest>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(Item3);
Magic Number,System,Tuple<T1;T2;T3;T4;T5;T6;T7;TRest>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(Item4);
Magic Number,System,Tuple<T1;T2;T3;T4;T5;T6;T7;TRest>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(Item5);
Magic Number,System,Tuple<T1;T2;T3;T4;T5;T6;T7;TRest>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(Item6);
Magic Number,System,Tuple<T1;T2;T3;T4;T5;T6;T7;TRest>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(Item7);
Magic Number,System,Tuple<T1;T2;T3;T4;T5;T6;T7;TRest>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 5) - hash + comparer.GetHashCode(Rest);
Magic Number,System,Tuple<T1;T2;T3;T4;T5;T6;T7;TRest>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Tuple.cs,ToString,The following statement contains a magic number: return string.Format(CultureInfo.InvariantCulture' "({0}' {1}' {2}' {3}' {4}' {5}' {6}' {7})"' Item1' Item2' Item3' Item4' Item5' Item6' Item7' restString.Substring(1' restString.Length - 2));
Magic Number,System,UIntPtrEx,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\UIntPtrEx.cs,Add,The following statement contains a magic number: UIntPtr.Size == 4
Magic Number,System,UIntPtrEx,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\UIntPtrEx.cs,Add,The following statement contains a magic number: UIntPtr.Size == 8
Magic Number,System,UIntPtrEx,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\UIntPtrEx.cs,Subtract,The following statement contains a magic number: UIntPtr.Size == 4
Magic Number,System,UIntPtrEx,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\UIntPtrEx.cs,Subtract,The following statement contains a magic number: UIntPtr.Size == 8
Magic Number,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,GetHashCode,The following statement contains a magic number: size >= 8
Magic Number,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,GetHashCode,The following statement contains a magic number: switch (8 - size)              {                  case 1:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 2:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 3:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 4:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T4>.Default.GetHashCode(Item4)'                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 5:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T3>.Default.GetHashCode(Item3)'                          EqualityComparer<T4>.Default.GetHashCode(Item4)'                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 6:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T2>.Default.GetHashCode(Item2)'                          EqualityComparer<T3>.Default.GetHashCode(Item3)'                          EqualityComparer<T4>.Default.GetHashCode(Item4)'                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 7:                  case 8:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T1>.Default.GetHashCode(Item1)'                          EqualityComparer<T2>.Default.GetHashCode(Item2)'                          EqualityComparer<T3>.Default.GetHashCode(Item3)'                          EqualityComparer<T4>.Default.GetHashCode(Item4)'                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    default:                      DebugEx.Fail("Missed all cases for computing ValueTuple hash code");                      return -1;              }
Magic Number,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,GetHashCode,The following statement contains a magic number: switch (8 - size)              {                  case 1:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 2:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 3:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 4:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T4>.Default.GetHashCode(Item4)'                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 5:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T3>.Default.GetHashCode(Item3)'                          EqualityComparer<T4>.Default.GetHashCode(Item4)'                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 6:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T2>.Default.GetHashCode(Item2)'                          EqualityComparer<T3>.Default.GetHashCode(Item3)'                          EqualityComparer<T4>.Default.GetHashCode(Item4)'                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 7:                  case 8:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T1>.Default.GetHashCode(Item1)'                          EqualityComparer<T2>.Default.GetHashCode(Item2)'                          EqualityComparer<T3>.Default.GetHashCode(Item3)'                          EqualityComparer<T4>.Default.GetHashCode(Item4)'                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    default:                      DebugEx.Fail("Missed all cases for computing ValueTuple hash code");                      return -1;              }
Magic Number,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,GetHashCode,The following statement contains a magic number: switch (8 - size)              {                  case 1:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 2:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 3:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 4:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T4>.Default.GetHashCode(Item4)'                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 5:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T3>.Default.GetHashCode(Item3)'                          EqualityComparer<T4>.Default.GetHashCode(Item4)'                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 6:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T2>.Default.GetHashCode(Item2)'                          EqualityComparer<T3>.Default.GetHashCode(Item3)'                          EqualityComparer<T4>.Default.GetHashCode(Item4)'                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 7:                  case 8:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T1>.Default.GetHashCode(Item1)'                          EqualityComparer<T2>.Default.GetHashCode(Item2)'                          EqualityComparer<T3>.Default.GetHashCode(Item3)'                          EqualityComparer<T4>.Default.GetHashCode(Item4)'                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    default:                      DebugEx.Fail("Missed all cases for computing ValueTuple hash code");                      return -1;              }
Magic Number,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,GetHashCode,The following statement contains a magic number: switch (8 - size)              {                  case 1:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 2:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 3:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 4:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T4>.Default.GetHashCode(Item4)'                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 5:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T3>.Default.GetHashCode(Item3)'                          EqualityComparer<T4>.Default.GetHashCode(Item4)'                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 6:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T2>.Default.GetHashCode(Item2)'                          EqualityComparer<T3>.Default.GetHashCode(Item3)'                          EqualityComparer<T4>.Default.GetHashCode(Item4)'                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 7:                  case 8:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T1>.Default.GetHashCode(Item1)'                          EqualityComparer<T2>.Default.GetHashCode(Item2)'                          EqualityComparer<T3>.Default.GetHashCode(Item3)'                          EqualityComparer<T4>.Default.GetHashCode(Item4)'                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    default:                      DebugEx.Fail("Missed all cases for computing ValueTuple hash code");                      return -1;              }
Magic Number,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,GetHashCode,The following statement contains a magic number: switch (8 - size)              {                  case 1:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 2:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 3:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 4:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T4>.Default.GetHashCode(Item4)'                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 5:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T3>.Default.GetHashCode(Item3)'                          EqualityComparer<T4>.Default.GetHashCode(Item4)'                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 6:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T2>.Default.GetHashCode(Item2)'                          EqualityComparer<T3>.Default.GetHashCode(Item3)'                          EqualityComparer<T4>.Default.GetHashCode(Item4)'                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 7:                  case 8:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T1>.Default.GetHashCode(Item1)'                          EqualityComparer<T2>.Default.GetHashCode(Item2)'                          EqualityComparer<T3>.Default.GetHashCode(Item3)'                          EqualityComparer<T4>.Default.GetHashCode(Item4)'                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    default:                      DebugEx.Fail("Missed all cases for computing ValueTuple hash code");                      return -1;              }
Magic Number,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,GetHashCode,The following statement contains a magic number: switch (8 - size)              {                  case 1:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 2:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 3:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 4:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T4>.Default.GetHashCode(Item4)'                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 5:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T3>.Default.GetHashCode(Item3)'                          EqualityComparer<T4>.Default.GetHashCode(Item4)'                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 6:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T2>.Default.GetHashCode(Item2)'                          EqualityComparer<T3>.Default.GetHashCode(Item3)'                          EqualityComparer<T4>.Default.GetHashCode(Item4)'                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 7:                  case 8:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T1>.Default.GetHashCode(Item1)'                          EqualityComparer<T2>.Default.GetHashCode(Item2)'                          EqualityComparer<T3>.Default.GetHashCode(Item3)'                          EqualityComparer<T4>.Default.GetHashCode(Item4)'                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    default:                      DebugEx.Fail("Missed all cases for computing ValueTuple hash code");                      return -1;              }
Magic Number,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,GetHashCode,The following statement contains a magic number: switch (8 - size)              {                  case 1:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 2:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 3:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 4:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T4>.Default.GetHashCode(Item4)'                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 5:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T3>.Default.GetHashCode(Item3)'                          EqualityComparer<T4>.Default.GetHashCode(Item4)'                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 6:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T2>.Default.GetHashCode(Item2)'                          EqualityComparer<T3>.Default.GetHashCode(Item3)'                          EqualityComparer<T4>.Default.GetHashCode(Item4)'                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 7:                  case 8:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T1>.Default.GetHashCode(Item1)'                          EqualityComparer<T2>.Default.GetHashCode(Item2)'                          EqualityComparer<T3>.Default.GetHashCode(Item3)'                          EqualityComparer<T4>.Default.GetHashCode(Item4)'                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    default:                      DebugEx.Fail("Missed all cases for computing ValueTuple hash code");                      return -1;              }
Magic Number,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,GetHashCode,The following statement contains a magic number: switch (8 - size)              {                  case 1:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 2:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 3:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 4:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T4>.Default.GetHashCode(Item4)'                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 5:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T3>.Default.GetHashCode(Item3)'                          EqualityComparer<T4>.Default.GetHashCode(Item4)'                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 6:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T2>.Default.GetHashCode(Item2)'                          EqualityComparer<T3>.Default.GetHashCode(Item3)'                          EqualityComparer<T4>.Default.GetHashCode(Item4)'                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    case 7:                  case 8:                      return ValueTuple.CombineHashCodes                      (                          EqualityComparer<T1>.Default.GetHashCode(Item1)'                          EqualityComparer<T2>.Default.GetHashCode(Item2)'                          EqualityComparer<T3>.Default.GetHashCode(Item3)'                          EqualityComparer<T4>.Default.GetHashCode(Item4)'                          EqualityComparer<T5>.Default.GetHashCode(Item5)'                          EqualityComparer<T6>.Default.GetHashCode(Item6)'                          EqualityComparer<T7>.Default.GetHashCode(Item7)'                          rest.GetHashCode()                      );                    default:                      DebugEx.Fail("Missed all cases for computing ValueTuple hash code");                      return -1;              }
Magic Number,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,GetHashCodeCore,The following statement contains a magic number: size >= 8
Magic Number,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,GetHashCodeCore,The following statement contains a magic number: switch (8 - size)              {                  case 1:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 2:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 3:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)'                          rest.GetHashCode(comparer)                      );                    case 4:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)'                          comparer.GetHashCode(Item7)' rest.GetHashCode(comparer)                      );                    case 5:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item3)' comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)'                          comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)' rest.GetHashCode(comparer)                      );                    case 6:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item2)' comparer.GetHashCode(Item3)' comparer.GetHashCode(Item4)'                          comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)'                          rest.GetHashCode(comparer)                      );                    case 7:                  case 8:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item1)' comparer.GetHashCode(Item2)' comparer.GetHashCode(Item3)'                          comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)'                          comparer.GetHashCode(Item7)' rest.GetHashCode(comparer)                      );                    default:                      DebugEx.Fail("Missed all cases for computing ValueTuple hash code");                      return -1;              }
Magic Number,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,GetHashCodeCore,The following statement contains a magic number: switch (8 - size)              {                  case 1:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 2:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 3:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)'                          rest.GetHashCode(comparer)                      );                    case 4:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)'                          comparer.GetHashCode(Item7)' rest.GetHashCode(comparer)                      );                    case 5:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item3)' comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)'                          comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)' rest.GetHashCode(comparer)                      );                    case 6:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item2)' comparer.GetHashCode(Item3)' comparer.GetHashCode(Item4)'                          comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)'                          rest.GetHashCode(comparer)                      );                    case 7:                  case 8:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item1)' comparer.GetHashCode(Item2)' comparer.GetHashCode(Item3)'                          comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)'                          comparer.GetHashCode(Item7)' rest.GetHashCode(comparer)                      );                    default:                      DebugEx.Fail("Missed all cases for computing ValueTuple hash code");                      return -1;              }
Magic Number,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,GetHashCodeCore,The following statement contains a magic number: switch (8 - size)              {                  case 1:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 2:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 3:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)'                          rest.GetHashCode(comparer)                      );                    case 4:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)'                          comparer.GetHashCode(Item7)' rest.GetHashCode(comparer)                      );                    case 5:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item3)' comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)'                          comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)' rest.GetHashCode(comparer)                      );                    case 6:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item2)' comparer.GetHashCode(Item3)' comparer.GetHashCode(Item4)'                          comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)'                          rest.GetHashCode(comparer)                      );                    case 7:                  case 8:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item1)' comparer.GetHashCode(Item2)' comparer.GetHashCode(Item3)'                          comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)'                          comparer.GetHashCode(Item7)' rest.GetHashCode(comparer)                      );                    default:                      DebugEx.Fail("Missed all cases for computing ValueTuple hash code");                      return -1;              }
Magic Number,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,GetHashCodeCore,The following statement contains a magic number: switch (8 - size)              {                  case 1:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 2:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 3:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)'                          rest.GetHashCode(comparer)                      );                    case 4:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)'                          comparer.GetHashCode(Item7)' rest.GetHashCode(comparer)                      );                    case 5:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item3)' comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)'                          comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)' rest.GetHashCode(comparer)                      );                    case 6:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item2)' comparer.GetHashCode(Item3)' comparer.GetHashCode(Item4)'                          comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)'                          rest.GetHashCode(comparer)                      );                    case 7:                  case 8:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item1)' comparer.GetHashCode(Item2)' comparer.GetHashCode(Item3)'                          comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)'                          comparer.GetHashCode(Item7)' rest.GetHashCode(comparer)                      );                    default:                      DebugEx.Fail("Missed all cases for computing ValueTuple hash code");                      return -1;              }
Magic Number,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,GetHashCodeCore,The following statement contains a magic number: switch (8 - size)              {                  case 1:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 2:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 3:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)'                          rest.GetHashCode(comparer)                      );                    case 4:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)'                          comparer.GetHashCode(Item7)' rest.GetHashCode(comparer)                      );                    case 5:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item3)' comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)'                          comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)' rest.GetHashCode(comparer)                      );                    case 6:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item2)' comparer.GetHashCode(Item3)' comparer.GetHashCode(Item4)'                          comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)'                          rest.GetHashCode(comparer)                      );                    case 7:                  case 8:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item1)' comparer.GetHashCode(Item2)' comparer.GetHashCode(Item3)'                          comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)'                          comparer.GetHashCode(Item7)' rest.GetHashCode(comparer)                      );                    default:                      DebugEx.Fail("Missed all cases for computing ValueTuple hash code");                      return -1;              }
Magic Number,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,GetHashCodeCore,The following statement contains a magic number: switch (8 - size)              {                  case 1:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 2:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 3:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)'                          rest.GetHashCode(comparer)                      );                    case 4:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)'                          comparer.GetHashCode(Item7)' rest.GetHashCode(comparer)                      );                    case 5:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item3)' comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)'                          comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)' rest.GetHashCode(comparer)                      );                    case 6:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item2)' comparer.GetHashCode(Item3)' comparer.GetHashCode(Item4)'                          comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)'                          rest.GetHashCode(comparer)                      );                    case 7:                  case 8:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item1)' comparer.GetHashCode(Item2)' comparer.GetHashCode(Item3)'                          comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)'                          comparer.GetHashCode(Item7)' rest.GetHashCode(comparer)                      );                    default:                      DebugEx.Fail("Missed all cases for computing ValueTuple hash code");                      return -1;              }
Magic Number,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,GetHashCodeCore,The following statement contains a magic number: switch (8 - size)              {                  case 1:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 2:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 3:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)'                          rest.GetHashCode(comparer)                      );                    case 4:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)'                          comparer.GetHashCode(Item7)' rest.GetHashCode(comparer)                      );                    case 5:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item3)' comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)'                          comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)' rest.GetHashCode(comparer)                      );                    case 6:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item2)' comparer.GetHashCode(Item3)' comparer.GetHashCode(Item4)'                          comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)'                          rest.GetHashCode(comparer)                      );                    case 7:                  case 8:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item1)' comparer.GetHashCode(Item2)' comparer.GetHashCode(Item3)'                          comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)'                          comparer.GetHashCode(Item7)' rest.GetHashCode(comparer)                      );                    default:                      DebugEx.Fail("Missed all cases for computing ValueTuple hash code");                      return -1;              }
Magic Number,System,ValueTuple,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\ValueTuple.cs,GetHashCodeCore,The following statement contains a magic number: switch (8 - size)              {                  case 1:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 2:                      return ValueTuple.CombineHashCodes(comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)' rest.GetHashCode(comparer));                    case 3:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)'                          rest.GetHashCode(comparer)                      );                    case 4:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)'                          comparer.GetHashCode(Item7)' rest.GetHashCode(comparer)                      );                    case 5:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item3)' comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)'                          comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)' rest.GetHashCode(comparer)                      );                    case 6:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item2)' comparer.GetHashCode(Item3)' comparer.GetHashCode(Item4)'                          comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)' comparer.GetHashCode(Item7)'                          rest.GetHashCode(comparer)                      );                    case 7:                  case 8:                      return ValueTuple.CombineHashCodes                      (                          comparer.GetHashCode(Item1)' comparer.GetHashCode(Item2)' comparer.GetHashCode(Item3)'                          comparer.GetHashCode(Item4)' comparer.GetHashCode(Item5)' comparer.GetHashCode(Item6)'                          comparer.GetHashCode(Item7)' rest.GetHashCode(comparer)                      );                    default:                      DebugEx.Fail("Missed all cases for computing ValueTuple hash code");                      return -1;              }
Magic Number,System.Collections.Generic,ArrayBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Collections\ArrayBuilder.cs,EnsureCapacity,The following statement contains a magic number: var nextCapacity = capacity == 0 ? _defaultCapacity : 2 * capacity;
Magic Number,System.Collections.ObjectModel,ReadOnlyCollectionEx<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Collections\ObjectModel\ReadOnlyCollectionEx.cs,GetHashCode,The following statement contains a magic number: var h = 6551;
Magic Number,System.Collections.ObjectModel,ReadOnlyCollectionEx<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Collections\ObjectModel\ReadOnlyCollectionEx.cs,GetHashCode,The following statement contains a magic number: h ^= (h << 5) ^ cmp.GetHashCode(t);
Magic Number,System.Dynamic,ExpandoData,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\ExpandoObject.cs,GetAlignedSize,The following statement contains a magic number: const int dataArrayAlignment = 8;
Magic Number,System.Dynamic,SetIndexBinder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Dynamic\SetIndexBinder.cs,Bind,The following statement contains a magic number: ContractUtils.Requires(args.Length >= 2' nameof(args));
Magic Number,System.Runtime.CompilerServices,AsyncMethodInt32TaskCache,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Runtime\CompilerServices\AsyncMethodTaskCache.cs,CreateInt32Tasks,The following statement contains a magic number: var completionSourceArray = new TaskCompletionSource<int>[10];
Magic Number,System.Runtime.CompilerServices,CallSite,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Runtime\CompilerServices\CallSite.cs,Create,The following statement contains a magic number: _siteConstructors = constructors = new CacheDict<Type' Func<CallSiteBinder' CallSite>>(100);
Magic Number,System.Runtime.CompilerServices,CallSite<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Runtime\CompilerServices\CallSite.cs,MoveRule,The following statement contains a magic number: rules[i - 1] = rules[i - 2];
Magic Number,System.Runtime.CompilerServices,CallSite<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Runtime\CompilerServices\CallSite.cs,MoveRule,The following statement contains a magic number: rules[i - 2] = rule;
Magic Number,System.Runtime.CompilerServices,ConfiguredValueTaskAwaiter,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Runtime\CompilerServices\ConfiguredValueTaskAwaitable.cs,OnCompleted,The following statement contains a magic number: switch (obj)                  {                      case Task task:                          task.ConfigureAwait(_value.ContinueOnCapturedContext).GetAwaiter().OnCompleted(continuation);                          return;                        case null:                          ValueTask.CompletedTask.ConfigureAwait(_value.ContinueOnCapturedContext).GetAwaiter().OnCompleted(continuation);                          return;                        default:                          ((IValueTaskSource)obj).OnCompleted(ValueTaskAwaiter.InvokeActionDelegate' continuation' _value.Token' (ValueTaskSourceOnCompletedFlags)(2 | (_value.ContinueOnCapturedContext ? 1 : 0)));                          break;                  }
Magic Number,System.Runtime.CompilerServices,ReadOnlyCollectionBuilder<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Runtime\CompilerServices\ReadOnlyCollectionBuilder.cs,EnsureCapacity,The following statement contains a magic number: newCapacity = _items.Length * 2;
Magic Number,System.Runtime.CompilerServices,RuleCache<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Runtime\CompilerServices\RuleCache.cs,MoveRule,The following statement contains a magic number: const int maxSearch = 8;
Magic Number,System.Runtime.CompilerServices,RuleCache<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Runtime\CompilerServices\RuleCache.cs,MoveRule,The following statement contains a magic number: oldIndex < 2
Magic Number,System.Runtime.CompilerServices,RuleCache<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Runtime\CompilerServices\RuleCache.cs,MoveRule,The following statement contains a magic number: rules[oldIndex - 1] = rules[oldIndex - 2];
Magic Number,System.Runtime.CompilerServices,RuleCache<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Runtime\CompilerServices\RuleCache.cs,MoveRule,The following statement contains a magic number: rules[oldIndex - 2] = oldRule;
Magic Number,System.Linq.Expressions,BinaryExpression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ReduceIndex,The following statement contains a magic number: var vars = new ArrayBuilder<ParameterExpression>(index.ArgumentCount + 2);
Magic Number,System.Linq.Expressions,BinaryExpression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ReduceIndex,The following statement contains a magic number: var builder = new ArrayBuilder<Expression>(index.ArgumentCount + 3);
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,GetMethodBasedBinaryOperator,The following statement contains a magic number: pms.Length != 2
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,ValidateUserDefinedConditionalLogicOperator,The following statement contains a magic number: pms.Length != 2
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,GetOptimizedBlockExpression,The following statement contains a magic number: switch (expressions.Length)              {                  case 0: return BlockCore(typeof(void)' ArrayEx.Empty<ParameterExpression>()' ArrayEx.Empty<Expression>());                  case 2: return new Block2(expressions[0]' expressions[1]);                  case 3: return new Block3(expressions[0]' expressions[1]' expressions[2]);                  case 4: return new Block4(expressions[0]' expressions[1]' expressions[2]' expressions[3]);                  case 5: return new Block5(expressions[0]' expressions[1]' expressions[2]' expressions[3]' expressions[4]);                  default: return new BlockN(expressions);              }
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,GetOptimizedBlockExpression,The following statement contains a magic number: switch (expressions.Length)              {                  case 0: return BlockCore(typeof(void)' ArrayEx.Empty<ParameterExpression>()' ArrayEx.Empty<Expression>());                  case 2: return new Block2(expressions[0]' expressions[1]);                  case 3: return new Block3(expressions[0]' expressions[1]' expressions[2]);                  case 4: return new Block4(expressions[0]' expressions[1]' expressions[2]' expressions[3]);                  case 5: return new Block5(expressions[0]' expressions[1]' expressions[2]' expressions[3]' expressions[4]);                  default: return new BlockN(expressions);              }
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,GetOptimizedBlockExpression,The following statement contains a magic number: switch (expressions.Length)              {                  case 0: return BlockCore(typeof(void)' ArrayEx.Empty<ParameterExpression>()' ArrayEx.Empty<Expression>());                  case 2: return new Block2(expressions[0]' expressions[1]);                  case 3: return new Block3(expressions[0]' expressions[1]' expressions[2]);                  case 4: return new Block4(expressions[0]' expressions[1]' expressions[2]' expressions[3]);                  case 5: return new Block5(expressions[0]' expressions[1]' expressions[2]' expressions[3]' expressions[4]);                  default: return new BlockN(expressions);              }
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,GetOptimizedBlockExpression,The following statement contains a magic number: switch (expressions.Length)              {                  case 0: return BlockCore(typeof(void)' ArrayEx.Empty<ParameterExpression>()' ArrayEx.Empty<Expression>());                  case 2: return new Block2(expressions[0]' expressions[1]);                  case 3: return new Block3(expressions[0]' expressions[1]' expressions[2]);                  case 4: return new Block4(expressions[0]' expressions[1]' expressions[2]' expressions[3]);                  case 5: return new Block5(expressions[0]' expressions[1]' expressions[2]' expressions[3]' expressions[4]);                  default: return new BlockN(expressions);              }
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,GetOptimizedBlockExpression,The following statement contains a magic number: switch (expressions.Length)              {                  case 0: return BlockCore(typeof(void)' ArrayEx.Empty<ParameterExpression>()' ArrayEx.Empty<Expression>());                  case 2: return new Block2(expressions[0]' expressions[1]);                  case 3: return new Block3(expressions[0]' expressions[1]' expressions[2]);                  case 4: return new Block4(expressions[0]' expressions[1]' expressions[2]' expressions[3]);                  case 5: return new Block5(expressions[0]' expressions[1]' expressions[2]' expressions[3]' expressions[4]);                  default: return new BlockN(expressions);              }
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,GetOptimizedBlockExpression,The following statement contains a magic number: switch (expressions.Length)              {                  case 0: return BlockCore(typeof(void)' ArrayEx.Empty<ParameterExpression>()' ArrayEx.Empty<Expression>());                  case 2: return new Block2(expressions[0]' expressions[1]);                  case 3: return new Block3(expressions[0]' expressions[1]' expressions[2]);                  case 4: return new Block4(expressions[0]' expressions[1]' expressions[2]' expressions[3]);                  case 5: return new Block5(expressions[0]' expressions[1]' expressions[2]' expressions[3]' expressions[4]);                  default: return new BlockN(expressions);              }
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,GetOptimizedBlockExpression,The following statement contains a magic number: switch (expressions.Length)              {                  case 0: return BlockCore(typeof(void)' ArrayEx.Empty<ParameterExpression>()' ArrayEx.Empty<Expression>());                  case 2: return new Block2(expressions[0]' expressions[1]);                  case 3: return new Block3(expressions[0]' expressions[1]' expressions[2]);                  case 4: return new Block4(expressions[0]' expressions[1]' expressions[2]' expressions[3]);                  case 5: return new Block5(expressions[0]' expressions[1]' expressions[2]' expressions[3]' expressions[4]);                  default: return new BlockN(expressions);              }
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,GetOptimizedBlockExpression,The following statement contains a magic number: switch (expressions.Length)              {                  case 0: return BlockCore(typeof(void)' ArrayEx.Empty<ParameterExpression>()' ArrayEx.Empty<Expression>());                  case 2: return new Block2(expressions[0]' expressions[1]);                  case 3: return new Block3(expressions[0]' expressions[1]' expressions[2]);                  case 4: return new Block4(expressions[0]' expressions[1]' expressions[2]' expressions[3]);                  case 5: return new Block5(expressions[0]' expressions[1]' expressions[2]' expressions[3]' expressions[4]);                  default: return new BlockN(expressions);              }
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,GetOptimizedBlockExpression,The following statement contains a magic number: switch (expressions.Length)              {                  case 0: return BlockCore(typeof(void)' ArrayEx.Empty<ParameterExpression>()' ArrayEx.Empty<Expression>());                  case 2: return new Block2(expressions[0]' expressions[1]);                  case 3: return new Block3(expressions[0]' expressions[1]' expressions[2]);                  case 4: return new Block4(expressions[0]' expressions[1]' expressions[2]' expressions[3]);                  case 5: return new Block5(expressions[0]' expressions[1]' expressions[2]' expressions[3]' expressions[4]);                  default: return new BlockN(expressions);              }
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,GetOptimizedBlockExpression,The following statement contains a magic number: switch (expressions.Length)              {                  case 0: return BlockCore(typeof(void)' ArrayEx.Empty<ParameterExpression>()' ArrayEx.Empty<Expression>());                  case 2: return new Block2(expressions[0]' expressions[1]);                  case 3: return new Block3(expressions[0]' expressions[1]' expressions[2]);                  case 4: return new Block4(expressions[0]' expressions[1]' expressions[2]' expressions[3]);                  case 5: return new Block5(expressions[0]' expressions[1]' expressions[2]' expressions[3]' expressions[4]);                  default: return new BlockN(expressions);              }
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Invoke,The following statement contains a magic number: ValidateArgumentCount(method' ExpressionType.Invoke' 2' pis);
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Invoke,The following statement contains a magic number: ValidateArgumentCount(method' ExpressionType.Invoke' 3' pis);
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Invoke,The following statement contains a magic number: arg2 = ValidateOneArgument(method' ExpressionType.Invoke' arg2' pis[2]' nameof(expression)' nameof(arg2));
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Invoke,The following statement contains a magic number: ValidateArgumentCount(method' ExpressionType.Invoke' 4' pis);
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Invoke,The following statement contains a magic number: arg2 = ValidateOneArgument(method' ExpressionType.Invoke' arg2' pis[2]' nameof(expression)' nameof(arg2));
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Invoke,The following statement contains a magic number: arg3 = ValidateOneArgument(method' ExpressionType.Invoke' arg3' pis[3]' nameof(expression)' nameof(arg3));
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Invoke,The following statement contains a magic number: ValidateArgumentCount(method' ExpressionType.Invoke' 5' pis);
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Invoke,The following statement contains a magic number: arg2 = ValidateOneArgument(method' ExpressionType.Invoke' arg2' pis[2]' nameof(expression)' nameof(arg2));
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Invoke,The following statement contains a magic number: arg3 = ValidateOneArgument(method' ExpressionType.Invoke' arg3' pis[3]' nameof(expression)' nameof(arg3));
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Invoke,The following statement contains a magic number: arg4 = ValidateOneArgument(method' ExpressionType.Invoke' arg4' pis[4]' nameof(expression)' nameof(arg4));
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,InvokeExtracted,The following statement contains a magic number: switch (argumentList.Length)              {                  case 0:                      return Invoke(expression);                    case 1:                      return Invoke(expression' argumentList[0]);                    case 2:                      return Invoke(expression' argumentList[0]' argumentList[1]);                    case 3:                      return Invoke(expression' argumentList[0]' argumentList[1]' argumentList[2]);                    case 4:                      return Invoke(expression' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]);                    case 5:                      return Invoke(expression' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]' argumentList[4]);                    default:                      break;              }
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,InvokeExtracted,The following statement contains a magic number: switch (argumentList.Length)              {                  case 0:                      return Invoke(expression);                    case 1:                      return Invoke(expression' argumentList[0]);                    case 2:                      return Invoke(expression' argumentList[0]' argumentList[1]);                    case 3:                      return Invoke(expression' argumentList[0]' argumentList[1]' argumentList[2]);                    case 4:                      return Invoke(expression' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]);                    case 5:                      return Invoke(expression' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]' argumentList[4]);                    default:                      break;              }
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,InvokeExtracted,The following statement contains a magic number: switch (argumentList.Length)              {                  case 0:                      return Invoke(expression);                    case 1:                      return Invoke(expression' argumentList[0]);                    case 2:                      return Invoke(expression' argumentList[0]' argumentList[1]);                    case 3:                      return Invoke(expression' argumentList[0]' argumentList[1]' argumentList[2]);                    case 4:                      return Invoke(expression' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]);                    case 5:                      return Invoke(expression' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]' argumentList[4]);                    default:                      break;              }
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,InvokeExtracted,The following statement contains a magic number: switch (argumentList.Length)              {                  case 0:                      return Invoke(expression);                    case 1:                      return Invoke(expression' argumentList[0]);                    case 2:                      return Invoke(expression' argumentList[0]' argumentList[1]);                    case 3:                      return Invoke(expression' argumentList[0]' argumentList[1]' argumentList[2]);                    case 4:                      return Invoke(expression' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]);                    case 5:                      return Invoke(expression' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]' argumentList[4]);                    default:                      break;              }
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,InvokeExtracted,The following statement contains a magic number: switch (argumentList.Length)              {                  case 0:                      return Invoke(expression);                    case 1:                      return Invoke(expression' argumentList[0]);                    case 2:                      return Invoke(expression' argumentList[0]' argumentList[1]);                    case 3:                      return Invoke(expression' argumentList[0]' argumentList[1]' argumentList[2]);                    case 4:                      return Invoke(expression' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]);                    case 5:                      return Invoke(expression' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]' argumentList[4]);                    default:                      break;              }
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,InvokeExtracted,The following statement contains a magic number: switch (argumentList.Length)              {                  case 0:                      return Invoke(expression);                    case 1:                      return Invoke(expression' argumentList[0]);                    case 2:                      return Invoke(expression' argumentList[0]' argumentList[1]);                    case 3:                      return Invoke(expression' argumentList[0]' argumentList[1]' argumentList[2]);                    case 4:                      return Invoke(expression' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]);                    case 5:                      return Invoke(expression' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]' argumentList[4]);                    default:                      break;              }
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,InvokeExtracted,The following statement contains a magic number: switch (argumentList.Length)              {                  case 0:                      return Invoke(expression);                    case 1:                      return Invoke(expression' argumentList[0]);                    case 2:                      return Invoke(expression' argumentList[0]' argumentList[1]);                    case 3:                      return Invoke(expression' argumentList[0]' argumentList[1]' argumentList[2]);                    case 4:                      return Invoke(expression' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]);                    case 5:                      return Invoke(expression' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]' argumentList[4]);                    default:                      break;              }
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,InvokeExtracted,The following statement contains a magic number: switch (argumentList.Length)              {                  case 0:                      return Invoke(expression);                    case 1:                      return Invoke(expression' argumentList[0]);                    case 2:                      return Invoke(expression' argumentList[0]' argumentList[1]);                    case 3:                      return Invoke(expression' argumentList[0]' argumentList[1]' argumentList[2]);                    case 4:                      return Invoke(expression' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]);                    case 5:                      return Invoke(expression' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]' argumentList[4]);                    default:                      break;              }
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,InvokeExtracted,The following statement contains a magic number: switch (argumentList.Length)              {                  case 0:                      return Invoke(expression);                    case 1:                      return Invoke(expression' argumentList[0]);                    case 2:                      return Invoke(expression' argumentList[0]' argumentList[1]);                    case 3:                      return Invoke(expression' argumentList[0]' argumentList[1]' argumentList[2]);                    case 4:                      return Invoke(expression' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]);                    case 5:                      return Invoke(expression' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]' argumentList[4]);                    default:                      break;              }
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,InvokeExtracted,The following statement contains a magic number: switch (argumentList.Length)              {                  case 0:                      return Invoke(expression);                    case 1:                      return Invoke(expression' argumentList[0]);                    case 2:                      return Invoke(expression' argumentList[0]' argumentList[1]);                    case 3:                      return Invoke(expression' argumentList[0]' argumentList[1]' argumentList[2]);                    case 4:                      return Invoke(expression' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]);                    case 5:                      return Invoke(expression' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]' argumentList[4]);                    default:                      break;              }
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,CreateLambda,The following statement contains a magic number: var factories = TypeHelper.LazyCreate(ref _lambdaFactories' () => new CacheDict<Type' Func<Expression' string?' bool' ParameterExpression[]' LambdaExpression>>(50));
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Call,The following statement contains a magic number: ValidateArgumentCount(method' ExpressionType.Call' 2' pis);
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Call,The following statement contains a magic number: ValidateArgumentCount(method' ExpressionType.Call' 3' pis);
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Call,The following statement contains a magic number: arg2 = ValidateOneArgument(method' ExpressionType.Call' arg2' pis[2]' nameof(method)' nameof(arg2));
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Call,The following statement contains a magic number: ValidateArgumentCount(method' ExpressionType.Call' 4' pis);
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Call,The following statement contains a magic number: arg2 = ValidateOneArgument(method' ExpressionType.Call' arg2' pis[2]' nameof(method)' nameof(arg2));
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Call,The following statement contains a magic number: arg3 = ValidateOneArgument(method' ExpressionType.Call' arg3' pis[3]' nameof(method)' nameof(arg3));
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Call,The following statement contains a magic number: ValidateArgumentCount(method' ExpressionType.Call' 5' pis);
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Call,The following statement contains a magic number: arg2 = ValidateOneArgument(method' ExpressionType.Call' arg2' pis[2]' nameof(method)' nameof(arg2));
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Call,The following statement contains a magic number: arg3 = ValidateOneArgument(method' ExpressionType.Call' arg3' pis[3]' nameof(method)' nameof(arg3));
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Call,The following statement contains a magic number: arg4 = ValidateOneArgument(method' ExpressionType.Call' arg4' pis[4]' nameof(method)' nameof(arg4));
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Call,The following statement contains a magic number: ValidateArgumentCount(method' ExpressionType.Call' 2' pis);
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Call,The following statement contains a magic number: ValidateArgumentCount(method' ExpressionType.Call' 3' pis);
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,Call,The following statement contains a magic number: arg2 = ValidateOneArgument(method' ExpressionType.Call' arg2' pis[2]' nameof(method)' nameof(arg2));
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,CallExtracted,The following statement contains a magic number: switch (argCount)              {                  case 0:                      return Call(instance' method);                    case 1:                      return Call(instance' method' argumentList[0]);                    case 2:                      return Call(instance' method' argumentList[0]' argumentList[1]);                    case 3:                      return Call(instance' method' argumentList[0]' argumentList[1]' argumentList[2]);                    default:                      break;              }
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,CallExtracted,The following statement contains a magic number: switch (argCount)              {                  case 0:                      return Call(instance' method);                    case 1:                      return Call(instance' method' argumentList[0]);                    case 2:                      return Call(instance' method' argumentList[0]' argumentList[1]);                    case 3:                      return Call(instance' method' argumentList[0]' argumentList[1]' argumentList[2]);                    default:                      break;              }
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,CallExtracted,The following statement contains a magic number: switch (argCount)              {                  case 0:                      return Call(instance' method);                    case 1:                      return Call(instance' method' argumentList[0]);                    case 2:                      return Call(instance' method' argumentList[0]' argumentList[1]);                    case 3:                      return Call(instance' method' argumentList[0]' argumentList[1]' argumentList[2]);                    default:                      break;              }
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,CallExtracted,The following statement contains a magic number: switch (argCount)                  {                      case 4:                          return Call(method' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]);                        case 5:                          return Call(method' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]' argumentList[4]);                        default:                          break;                  }
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,CallExtracted,The following statement contains a magic number: switch (argCount)                  {                      case 4:                          return Call(method' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]);                        case 5:                          return Call(method' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]' argumentList[4]);                        default:                          break;                  }
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,CallExtracted,The following statement contains a magic number: switch (argCount)                  {                      case 4:                          return Call(method' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]);                        case 5:                          return Call(method' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]' argumentList[4]);                        default:                          break;                  }
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,CallExtracted,The following statement contains a magic number: switch (argCount)                  {                      case 4:                          return Call(method' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]);                        case 5:                          return Call(method' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]' argumentList[4]);                        default:                          break;                  }
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,CallExtracted,The following statement contains a magic number: switch (argCount)                  {                      case 4:                          return Call(method' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]);                        case 5:                          return Call(method' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]' argumentList[4]);                        default:                          break;                  }
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,CallExtracted,The following statement contains a magic number: switch (argCount)                  {                      case 4:                          return Call(method' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]);                        case 5:                          return Call(method' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]' argumentList[4]);                        default:                          break;                  }
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,CallExtracted,The following statement contains a magic number: switch (argCount)                  {                      case 4:                          return Call(method' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]);                        case 5:                          return Call(method' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]' argumentList[4]);                        default:                          break;                  }
Magic Number,System.Linq.Expressions,Expression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BinaryExpression.cs,SwitchExtracted,The following statement contains a magic number: pms.Length != 2
Magic Number,System.Linq.Expressions,Block2,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BlockExpression.cs,Rewrite,The following statement contains a magic number: Debug.Assert(args!.Length == 2);
Magic Number,System.Linq.Expressions,Block2,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BlockExpression.cs,SameExpressions,The following statement contains a magic number: expressions.Count != 2
Magic Number,System.Linq.Expressions,Block3,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BlockExpression.cs,GetExpression,The following statement contains a magic number: switch (index)              {                  case 0: return ExpressionUtils.ReturnObject<Expression>(_arg0);                  case 1: return _arg1;                  case 2: return _arg2;                  default: throw new ArgumentOutOfRangeException(nameof(index));              }
Magic Number,System.Linq.Expressions,Block3,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BlockExpression.cs,Rewrite,The following statement contains a magic number: Debug.Assert(args!.Length == 3);
Magic Number,System.Linq.Expressions,Block3,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BlockExpression.cs,Rewrite,The following statement contains a magic number: return new Block3(args[0]' args[1]' args[2]);
Magic Number,System.Linq.Expressions,Block3,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BlockExpression.cs,SameExpressions,The following statement contains a magic number: expressions.Count != 3
Magic Number,System.Linq.Expressions,Block4,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BlockExpression.cs,GetExpression,The following statement contains a magic number: switch (index)              {                  case 0: return ExpressionUtils.ReturnObject<Expression>(_arg0);                  case 1: return _arg1;                  case 2: return _arg2;                  case 3: return _arg3;                  default: throw new ArgumentOutOfRangeException(nameof(index));              }
Magic Number,System.Linq.Expressions,Block4,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BlockExpression.cs,GetExpression,The following statement contains a magic number: switch (index)              {                  case 0: return ExpressionUtils.ReturnObject<Expression>(_arg0);                  case 1: return _arg1;                  case 2: return _arg2;                  case 3: return _arg3;                  default: throw new ArgumentOutOfRangeException(nameof(index));              }
Magic Number,System.Linq.Expressions,Block4,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BlockExpression.cs,Rewrite,The following statement contains a magic number: Debug.Assert(args!.Length == 4);
Magic Number,System.Linq.Expressions,Block4,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BlockExpression.cs,Rewrite,The following statement contains a magic number: return new Block4(args[0]' args[1]' args[2]' args[3]);
Magic Number,System.Linq.Expressions,Block4,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BlockExpression.cs,Rewrite,The following statement contains a magic number: return new Block4(args[0]' args[1]' args[2]' args[3]);
Magic Number,System.Linq.Expressions,Block4,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BlockExpression.cs,SameExpressions,The following statement contains a magic number: expressions.Count != 4
Magic Number,System.Linq.Expressions,Block5,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BlockExpression.cs,GetExpression,The following statement contains a magic number: switch (index)              {                  case 0: return ExpressionUtils.ReturnObject<Expression>(_arg0);                  case 1: return _arg1;                  case 2: return _arg2;                  case 3: return _arg3;                  case 4: return _arg4;                  default: throw new ArgumentOutOfRangeException(nameof(index));              }
Magic Number,System.Linq.Expressions,Block5,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BlockExpression.cs,GetExpression,The following statement contains a magic number: switch (index)              {                  case 0: return ExpressionUtils.ReturnObject<Expression>(_arg0);                  case 1: return _arg1;                  case 2: return _arg2;                  case 3: return _arg3;                  case 4: return _arg4;                  default: throw new ArgumentOutOfRangeException(nameof(index));              }
Magic Number,System.Linq.Expressions,Block5,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BlockExpression.cs,GetExpression,The following statement contains a magic number: switch (index)              {                  case 0: return ExpressionUtils.ReturnObject<Expression>(_arg0);                  case 1: return _arg1;                  case 2: return _arg2;                  case 3: return _arg3;                  case 4: return _arg4;                  default: throw new ArgumentOutOfRangeException(nameof(index));              }
Magic Number,System.Linq.Expressions,Block5,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BlockExpression.cs,Rewrite,The following statement contains a magic number: Debug.Assert(args!.Length == 5);
Magic Number,System.Linq.Expressions,Block5,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BlockExpression.cs,Rewrite,The following statement contains a magic number: return new Block5(args[0]' args[1]' args[2]' args[3]' args[4]);
Magic Number,System.Linq.Expressions,Block5,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BlockExpression.cs,Rewrite,The following statement contains a magic number: return new Block5(args[0]' args[1]' args[2]' args[3]' args[4]);
Magic Number,System.Linq.Expressions,Block5,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BlockExpression.cs,Rewrite,The following statement contains a magic number: return new Block5(args[0]' args[1]' args[2]' args[3]' args[4]);
Magic Number,System.Linq.Expressions,Block5,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\BlockExpression.cs,SameExpressions,The following statement contains a magic number: expressions.Count != 5
Magic Number,System.Linq.Expressions,DebugViewWriter,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DebugViewWriter.cs,GetOperatorPrecedence,The following statement contains a magic number: switch (node.NodeType)              {                  // Assignment                  case ExpressionType.Assign:                  case ExpressionType.ExclusiveOrAssign:                  case ExpressionType.AddAssign:                  case ExpressionType.AddAssignChecked:                  case ExpressionType.SubtractAssign:                  case ExpressionType.SubtractAssignChecked:                  case ExpressionType.DivideAssign:                  case ExpressionType.ModuloAssign:                  case ExpressionType.MultiplyAssign:                  case ExpressionType.MultiplyAssignChecked:                  case ExpressionType.LeftShiftAssign:                  case ExpressionType.RightShiftAssign:                  case ExpressionType.AndAssign:                  case ExpressionType.OrAssign:                  case ExpressionType.PowerAssign:                  case ExpressionType.Coalesce:                      return 1;                    // Conditional (?:) would go here                    // Conditional OR                  case ExpressionType.OrElse:                      return 2;                    // Conditional AND                  case ExpressionType.AndAlso:                      return 3;                    // Logical OR                  case ExpressionType.Or:                      return 4;                    // Logical XOR                  case ExpressionType.ExclusiveOr:                      return 5;                    // Logical AND                  case ExpressionType.And:                      return 6;                    // Equality                  case ExpressionType.Equal:                  case ExpressionType.NotEqual:                      return 7;                    // Relational' type testing                  case ExpressionType.GreaterThan:                  case ExpressionType.LessThan:                  case ExpressionType.GreaterThanOrEqual:                  case ExpressionType.LessThanOrEqual:                  case ExpressionType.TypeAs:                  case ExpressionType.TypeIs:                  case ExpressionType.TypeEqual:                      return 8;                    // Shift                  case ExpressionType.LeftShift:                  case ExpressionType.RightShift:                      return 9;                    // Additive                  case ExpressionType.Add:                  case ExpressionType.AddChecked:                  case ExpressionType.Subtract:                  case ExpressionType.SubtractChecked:                      return 10;                    // Multiplicative                  case ExpressionType.Divide:                  case ExpressionType.Modulo:                  case ExpressionType.Multiply:                  case ExpressionType.MultiplyChecked:                      return 11;                    // Unary                  case ExpressionType.Negate:                  case ExpressionType.NegateChecked:                  case ExpressionType.UnaryPlus:                  case ExpressionType.Not:                  case ExpressionType.Convert:                  case ExpressionType.ConvertChecked:                  case ExpressionType.PreIncrementAssign:                  case ExpressionType.PreDecrementAssign:                  case ExpressionType.OnesComplement:                  case ExpressionType.Increment:                  case ExpressionType.Decrement:                  case ExpressionType.IsTrue:                  case ExpressionType.IsFalse:                  case ExpressionType.Unbox:                  case ExpressionType.Throw:                      return 12;                    // Power' which is not in C#                  // But VB/Python/Ruby put it here' above unary.                  case ExpressionType.Power:                      return 13;                    // Primary' which includes all other node types:                  //   member access' calls' indexing' new.                  case ExpressionType.PostIncrementAssign:                  case ExpressionType.PostDecrementAssign:                      return 14;                    // These aren't expressions' so never need parentheses:                  //   constants' variables                  case ExpressionType.Constant:                  case ExpressionType.Parameter:                      return 15;                    default:                      return 14;              }
Magic Number,System.Linq.Expressions,DebugViewWriter,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DebugViewWriter.cs,GetOperatorPrecedence,The following statement contains a magic number: switch (node.NodeType)              {                  // Assignment                  case ExpressionType.Assign:                  case ExpressionType.ExclusiveOrAssign:                  case ExpressionType.AddAssign:                  case ExpressionType.AddAssignChecked:                  case ExpressionType.SubtractAssign:                  case ExpressionType.SubtractAssignChecked:                  case ExpressionType.DivideAssign:                  case ExpressionType.ModuloAssign:                  case ExpressionType.MultiplyAssign:                  case ExpressionType.MultiplyAssignChecked:                  case ExpressionType.LeftShiftAssign:                  case ExpressionType.RightShiftAssign:                  case ExpressionType.AndAssign:                  case ExpressionType.OrAssign:                  case ExpressionType.PowerAssign:                  case ExpressionType.Coalesce:                      return 1;                    // Conditional (?:) would go here                    // Conditional OR                  case ExpressionType.OrElse:                      return 2;                    // Conditional AND                  case ExpressionType.AndAlso:                      return 3;                    // Logical OR                  case ExpressionType.Or:                      return 4;                    // Logical XOR                  case ExpressionType.ExclusiveOr:                      return 5;                    // Logical AND                  case ExpressionType.And:                      return 6;                    // Equality                  case ExpressionType.Equal:                  case ExpressionType.NotEqual:                      return 7;                    // Relational' type testing                  case ExpressionType.GreaterThan:                  case ExpressionType.LessThan:                  case ExpressionType.GreaterThanOrEqual:                  case ExpressionType.LessThanOrEqual:                  case ExpressionType.TypeAs:                  case ExpressionType.TypeIs:                  case ExpressionType.TypeEqual:                      return 8;                    // Shift                  case ExpressionType.LeftShift:                  case ExpressionType.RightShift:                      return 9;                    // Additive                  case ExpressionType.Add:                  case ExpressionType.AddChecked:                  case ExpressionType.Subtract:                  case ExpressionType.SubtractChecked:                      return 10;                    // Multiplicative                  case ExpressionType.Divide:                  case ExpressionType.Modulo:                  case ExpressionType.Multiply:                  case ExpressionType.MultiplyChecked:                      return 11;                    // Unary                  case ExpressionType.Negate:                  case ExpressionType.NegateChecked:                  case ExpressionType.UnaryPlus:                  case ExpressionType.Not:                  case ExpressionType.Convert:                  case ExpressionType.ConvertChecked:                  case ExpressionType.PreIncrementAssign:                  case ExpressionType.PreDecrementAssign:                  case ExpressionType.OnesComplement:                  case ExpressionType.Increment:                  case ExpressionType.Decrement:                  case ExpressionType.IsTrue:                  case ExpressionType.IsFalse:                  case ExpressionType.Unbox:                  case ExpressionType.Throw:                      return 12;                    // Power' which is not in C#                  // But VB/Python/Ruby put it here' above unary.                  case ExpressionType.Power:                      return 13;                    // Primary' which includes all other node types:                  //   member access' calls' indexing' new.                  case ExpressionType.PostIncrementAssign:                  case ExpressionType.PostDecrementAssign:                      return 14;                    // These aren't expressions' so never need parentheses:                  //   constants' variables                  case ExpressionType.Constant:                  case ExpressionType.Parameter:                      return 15;                    default:                      return 14;              }
Magic Number,System.Linq.Expressions,DebugViewWriter,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DebugViewWriter.cs,GetOperatorPrecedence,The following statement contains a magic number: switch (node.NodeType)              {                  // Assignment                  case ExpressionType.Assign:                  case ExpressionType.ExclusiveOrAssign:                  case ExpressionType.AddAssign:                  case ExpressionType.AddAssignChecked:                  case ExpressionType.SubtractAssign:                  case ExpressionType.SubtractAssignChecked:                  case ExpressionType.DivideAssign:                  case ExpressionType.ModuloAssign:                  case ExpressionType.MultiplyAssign:                  case ExpressionType.MultiplyAssignChecked:                  case ExpressionType.LeftShiftAssign:                  case ExpressionType.RightShiftAssign:                  case ExpressionType.AndAssign:                  case ExpressionType.OrAssign:                  case ExpressionType.PowerAssign:                  case ExpressionType.Coalesce:                      return 1;                    // Conditional (?:) would go here                    // Conditional OR                  case ExpressionType.OrElse:                      return 2;                    // Conditional AND                  case ExpressionType.AndAlso:                      return 3;                    // Logical OR                  case ExpressionType.Or:                      return 4;                    // Logical XOR                  case ExpressionType.ExclusiveOr:                      return 5;                    // Logical AND                  case ExpressionType.And:                      return 6;                    // Equality                  case ExpressionType.Equal:                  case ExpressionType.NotEqual:                      return 7;                    // Relational' type testing                  case ExpressionType.GreaterThan:                  case ExpressionType.LessThan:                  case ExpressionType.GreaterThanOrEqual:                  case ExpressionType.LessThanOrEqual:                  case ExpressionType.TypeAs:                  case ExpressionType.TypeIs:                  case ExpressionType.TypeEqual:                      return 8;                    // Shift                  case ExpressionType.LeftShift:                  case ExpressionType.RightShift:                      return 9;                    // Additive                  case ExpressionType.Add:                  case ExpressionType.AddChecked:                  case ExpressionType.Subtract:                  case ExpressionType.SubtractChecked:                      return 10;                    // Multiplicative                  case ExpressionType.Divide:                  case ExpressionType.Modulo:                  case ExpressionType.Multiply:                  case ExpressionType.MultiplyChecked:                      return 11;                    // Unary                  case ExpressionType.Negate:                  case ExpressionType.NegateChecked:                  case ExpressionType.UnaryPlus:                  case ExpressionType.Not:                  case ExpressionType.Convert:                  case ExpressionType.ConvertChecked:                  case ExpressionType.PreIncrementAssign:                  case ExpressionType.PreDecrementAssign:                  case ExpressionType.OnesComplement:                  case ExpressionType.Increment:                  case ExpressionType.Decrement:                  case ExpressionType.IsTrue:                  case ExpressionType.IsFalse:                  case ExpressionType.Unbox:                  case ExpressionType.Throw:                      return 12;                    // Power' which is not in C#                  // But VB/Python/Ruby put it here' above unary.                  case ExpressionType.Power:                      return 13;                    // Primary' which includes all other node types:                  //   member access' calls' indexing' new.                  case ExpressionType.PostIncrementAssign:                  case ExpressionType.PostDecrementAssign:                      return 14;                    // These aren't expressions' so never need parentheses:                  //   constants' variables                  case ExpressionType.Constant:                  case ExpressionType.Parameter:                      return 15;                    default:                      return 14;              }
Magic Number,System.Linq.Expressions,DebugViewWriter,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DebugViewWriter.cs,GetOperatorPrecedence,The following statement contains a magic number: switch (node.NodeType)              {                  // Assignment                  case ExpressionType.Assign:                  case ExpressionType.ExclusiveOrAssign:                  case ExpressionType.AddAssign:                  case ExpressionType.AddAssignChecked:                  case ExpressionType.SubtractAssign:                  case ExpressionType.SubtractAssignChecked:                  case ExpressionType.DivideAssign:                  case ExpressionType.ModuloAssign:                  case ExpressionType.MultiplyAssign:                  case ExpressionType.MultiplyAssignChecked:                  case ExpressionType.LeftShiftAssign:                  case ExpressionType.RightShiftAssign:                  case ExpressionType.AndAssign:                  case ExpressionType.OrAssign:                  case ExpressionType.PowerAssign:                  case ExpressionType.Coalesce:                      return 1;                    // Conditional (?:) would go here                    // Conditional OR                  case ExpressionType.OrElse:                      return 2;                    // Conditional AND                  case ExpressionType.AndAlso:                      return 3;                    // Logical OR                  case ExpressionType.Or:                      return 4;                    // Logical XOR                  case ExpressionType.ExclusiveOr:                      return 5;                    // Logical AND                  case ExpressionType.And:                      return 6;                    // Equality                  case ExpressionType.Equal:                  case ExpressionType.NotEqual:                      return 7;                    // Relational' type testing                  case ExpressionType.GreaterThan:                  case ExpressionType.LessThan:                  case ExpressionType.GreaterThanOrEqual:                  case ExpressionType.LessThanOrEqual:                  case ExpressionType.TypeAs:                  case ExpressionType.TypeIs:                  case ExpressionType.TypeEqual:                      return 8;                    // Shift                  case ExpressionType.LeftShift:                  case ExpressionType.RightShift:                      return 9;                    // Additive                  case ExpressionType.Add:                  case ExpressionType.AddChecked:                  case ExpressionType.Subtract:                  case ExpressionType.SubtractChecked:                      return 10;                    // Multiplicative                  case ExpressionType.Divide:                  case ExpressionType.Modulo:                  case ExpressionType.Multiply:                  case ExpressionType.MultiplyChecked:                      return 11;                    // Unary                  case ExpressionType.Negate:                  case ExpressionType.NegateChecked:                  case ExpressionType.UnaryPlus:                  case ExpressionType.Not:                  case ExpressionType.Convert:                  case ExpressionType.ConvertChecked:                  case ExpressionType.PreIncrementAssign:                  case ExpressionType.PreDecrementAssign:                  case ExpressionType.OnesComplement:                  case ExpressionType.Increment:                  case ExpressionType.Decrement:                  case ExpressionType.IsTrue:                  case ExpressionType.IsFalse:                  case ExpressionType.Unbox:                  case ExpressionType.Throw:                      return 12;                    // Power' which is not in C#                  // But VB/Python/Ruby put it here' above unary.                  case ExpressionType.Power:                      return 13;                    // Primary' which includes all other node types:                  //   member access' calls' indexing' new.                  case ExpressionType.PostIncrementAssign:                  case ExpressionType.PostDecrementAssign:                      return 14;                    // These aren't expressions' so never need parentheses:                  //   constants' variables                  case ExpressionType.Constant:                  case ExpressionType.Parameter:                      return 15;                    default:                      return 14;              }
Magic Number,System.Linq.Expressions,DebugViewWriter,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DebugViewWriter.cs,GetOperatorPrecedence,The following statement contains a magic number: switch (node.NodeType)              {                  // Assignment                  case ExpressionType.Assign:                  case ExpressionType.ExclusiveOrAssign:                  case ExpressionType.AddAssign:                  case ExpressionType.AddAssignChecked:                  case ExpressionType.SubtractAssign:                  case ExpressionType.SubtractAssignChecked:                  case ExpressionType.DivideAssign:                  case ExpressionType.ModuloAssign:                  case ExpressionType.MultiplyAssign:                  case ExpressionType.MultiplyAssignChecked:                  case ExpressionType.LeftShiftAssign:                  case ExpressionType.RightShiftAssign:                  case ExpressionType.AndAssign:                  case ExpressionType.OrAssign:                  case ExpressionType.PowerAssign:                  case ExpressionType.Coalesce:                      return 1;                    // Conditional (?:) would go here                    // Conditional OR                  case ExpressionType.OrElse:                      return 2;                    // Conditional AND                  case ExpressionType.AndAlso:                      return 3;                    // Logical OR                  case ExpressionType.Or:                      return 4;                    // Logical XOR                  case ExpressionType.ExclusiveOr:                      return 5;                    // Logical AND                  case ExpressionType.And:                      return 6;                    // Equality                  case ExpressionType.Equal:                  case ExpressionType.NotEqual:                      return 7;                    // Relational' type testing                  case ExpressionType.GreaterThan:                  case ExpressionType.LessThan:                  case ExpressionType.GreaterThanOrEqual:                  case ExpressionType.LessThanOrEqual:                  case ExpressionType.TypeAs:                  case ExpressionType.TypeIs:                  case ExpressionType.TypeEqual:                      return 8;                    // Shift                  case ExpressionType.LeftShift:                  case ExpressionType.RightShift:                      return 9;                    // Additive                  case ExpressionType.Add:                  case ExpressionType.AddChecked:                  case ExpressionType.Subtract:                  case ExpressionType.SubtractChecked:                      return 10;                    // Multiplicative                  case ExpressionType.Divide:                  case ExpressionType.Modulo:                  case ExpressionType.Multiply:                  case ExpressionType.MultiplyChecked:                      return 11;                    // Unary                  case ExpressionType.Negate:                  case ExpressionType.NegateChecked:                  case ExpressionType.UnaryPlus:                  case ExpressionType.Not:                  case ExpressionType.Convert:                  case ExpressionType.ConvertChecked:                  case ExpressionType.PreIncrementAssign:                  case ExpressionType.PreDecrementAssign:                  case ExpressionType.OnesComplement:                  case ExpressionType.Increment:                  case ExpressionType.Decrement:                  case ExpressionType.IsTrue:                  case ExpressionType.IsFalse:                  case ExpressionType.Unbox:                  case ExpressionType.Throw:                      return 12;                    // Power' which is not in C#                  // But VB/Python/Ruby put it here' above unary.                  case ExpressionType.Power:                      return 13;                    // Primary' which includes all other node types:                  //   member access' calls' indexing' new.                  case ExpressionType.PostIncrementAssign:                  case ExpressionType.PostDecrementAssign:                      return 14;                    // These aren't expressions' so never need parentheses:                  //   constants' variables                  case ExpressionType.Constant:                  case ExpressionType.Parameter:                      return 15;                    default:                      return 14;              }
Magic Number,System.Linq.Expressions,DebugViewWriter,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DebugViewWriter.cs,GetOperatorPrecedence,The following statement contains a magic number: switch (node.NodeType)              {                  // Assignment                  case ExpressionType.Assign:                  case ExpressionType.ExclusiveOrAssign:                  case ExpressionType.AddAssign:                  case ExpressionType.AddAssignChecked:                  case ExpressionType.SubtractAssign:                  case ExpressionType.SubtractAssignChecked:                  case ExpressionType.DivideAssign:                  case ExpressionType.ModuloAssign:                  case ExpressionType.MultiplyAssign:                  case ExpressionType.MultiplyAssignChecked:                  case ExpressionType.LeftShiftAssign:                  case ExpressionType.RightShiftAssign:                  case ExpressionType.AndAssign:                  case ExpressionType.OrAssign:                  case ExpressionType.PowerAssign:                  case ExpressionType.Coalesce:                      return 1;                    // Conditional (?:) would go here                    // Conditional OR                  case ExpressionType.OrElse:                      return 2;                    // Conditional AND                  case ExpressionType.AndAlso:                      return 3;                    // Logical OR                  case ExpressionType.Or:                      return 4;                    // Logical XOR                  case ExpressionType.ExclusiveOr:                      return 5;                    // Logical AND                  case ExpressionType.And:                      return 6;                    // Equality                  case ExpressionType.Equal:                  case ExpressionType.NotEqual:                      return 7;                    // Relational' type testing                  case ExpressionType.GreaterThan:                  case ExpressionType.LessThan:                  case ExpressionType.GreaterThanOrEqual:                  case ExpressionType.LessThanOrEqual:                  case ExpressionType.TypeAs:                  case ExpressionType.TypeIs:                  case ExpressionType.TypeEqual:                      return 8;                    // Shift                  case ExpressionType.LeftShift:                  case ExpressionType.RightShift:                      return 9;                    // Additive                  case ExpressionType.Add:                  case ExpressionType.AddChecked:                  case ExpressionType.Subtract:                  case ExpressionType.SubtractChecked:                      return 10;                    // Multiplicative                  case ExpressionType.Divide:                  case ExpressionType.Modulo:                  case ExpressionType.Multiply:                  case ExpressionType.MultiplyChecked:                      return 11;                    // Unary                  case ExpressionType.Negate:                  case ExpressionType.NegateChecked:                  case ExpressionType.UnaryPlus:                  case ExpressionType.Not:                  case ExpressionType.Convert:                  case ExpressionType.ConvertChecked:                  case ExpressionType.PreIncrementAssign:                  case ExpressionType.PreDecrementAssign:                  case ExpressionType.OnesComplement:                  case ExpressionType.Increment:                  case ExpressionType.Decrement:                  case ExpressionType.IsTrue:                  case ExpressionType.IsFalse:                  case ExpressionType.Unbox:                  case ExpressionType.Throw:                      return 12;                    // Power' which is not in C#                  // But VB/Python/Ruby put it here' above unary.                  case ExpressionType.Power:                      return 13;                    // Primary' which includes all other node types:                  //   member access' calls' indexing' new.                  case ExpressionType.PostIncrementAssign:                  case ExpressionType.PostDecrementAssign:                      return 14;                    // These aren't expressions' so never need parentheses:                  //   constants' variables                  case ExpressionType.Constant:                  case ExpressionType.Parameter:                      return 15;                    default:                      return 14;              }
Magic Number,System.Linq.Expressions,DebugViewWriter,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DebugViewWriter.cs,GetOperatorPrecedence,The following statement contains a magic number: switch (node.NodeType)              {                  // Assignment                  case ExpressionType.Assign:                  case ExpressionType.ExclusiveOrAssign:                  case ExpressionType.AddAssign:                  case ExpressionType.AddAssignChecked:                  case ExpressionType.SubtractAssign:                  case ExpressionType.SubtractAssignChecked:                  case ExpressionType.DivideAssign:                  case ExpressionType.ModuloAssign:                  case ExpressionType.MultiplyAssign:                  case ExpressionType.MultiplyAssignChecked:                  case ExpressionType.LeftShiftAssign:                  case ExpressionType.RightShiftAssign:                  case ExpressionType.AndAssign:                  case ExpressionType.OrAssign:                  case ExpressionType.PowerAssign:                  case ExpressionType.Coalesce:                      return 1;                    // Conditional (?:) would go here                    // Conditional OR                  case ExpressionType.OrElse:                      return 2;                    // Conditional AND                  case ExpressionType.AndAlso:                      return 3;                    // Logical OR                  case ExpressionType.Or:                      return 4;                    // Logical XOR                  case ExpressionType.ExclusiveOr:                      return 5;                    // Logical AND                  case ExpressionType.And:                      return 6;                    // Equality                  case ExpressionType.Equal:                  case ExpressionType.NotEqual:                      return 7;                    // Relational' type testing                  case ExpressionType.GreaterThan:                  case ExpressionType.LessThan:                  case ExpressionType.GreaterThanOrEqual:                  case ExpressionType.LessThanOrEqual:                  case ExpressionType.TypeAs:                  case ExpressionType.TypeIs:                  case ExpressionType.TypeEqual:                      return 8;                    // Shift                  case ExpressionType.LeftShift:                  case ExpressionType.RightShift:                      return 9;                    // Additive                  case ExpressionType.Add:                  case ExpressionType.AddChecked:                  case ExpressionType.Subtract:                  case ExpressionType.SubtractChecked:                      return 10;                    // Multiplicative                  case ExpressionType.Divide:                  case ExpressionType.Modulo:                  case ExpressionType.Multiply:                  case ExpressionType.MultiplyChecked:                      return 11;                    // Unary                  case ExpressionType.Negate:                  case ExpressionType.NegateChecked:                  case ExpressionType.UnaryPlus:                  case ExpressionType.Not:                  case ExpressionType.Convert:                  case ExpressionType.ConvertChecked:                  case ExpressionType.PreIncrementAssign:                  case ExpressionType.PreDecrementAssign:                  case ExpressionType.OnesComplement:                  case ExpressionType.Increment:                  case ExpressionType.Decrement:                  case ExpressionType.IsTrue:                  case ExpressionType.IsFalse:                  case ExpressionType.Unbox:                  case ExpressionType.Throw:                      return 12;                    // Power' which is not in C#                  // But VB/Python/Ruby put it here' above unary.                  case ExpressionType.Power:                      return 13;                    // Primary' which includes all other node types:                  //   member access' calls' indexing' new.                  case ExpressionType.PostIncrementAssign:                  case ExpressionType.PostDecrementAssign:                      return 14;                    // These aren't expressions' so never need parentheses:                  //   constants' variables                  case ExpressionType.Constant:                  case ExpressionType.Parameter:                      return 15;                    default:                      return 14;              }
Magic Number,System.Linq.Expressions,DebugViewWriter,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DebugViewWriter.cs,GetOperatorPrecedence,The following statement contains a magic number: switch (node.NodeType)              {                  // Assignment                  case ExpressionType.Assign:                  case ExpressionType.ExclusiveOrAssign:                  case ExpressionType.AddAssign:                  case ExpressionType.AddAssignChecked:                  case ExpressionType.SubtractAssign:                  case ExpressionType.SubtractAssignChecked:                  case ExpressionType.DivideAssign:                  case ExpressionType.ModuloAssign:                  case ExpressionType.MultiplyAssign:                  case ExpressionType.MultiplyAssignChecked:                  case ExpressionType.LeftShiftAssign:                  case ExpressionType.RightShiftAssign:                  case ExpressionType.AndAssign:                  case ExpressionType.OrAssign:                  case ExpressionType.PowerAssign:                  case ExpressionType.Coalesce:                      return 1;                    // Conditional (?:) would go here                    // Conditional OR                  case ExpressionType.OrElse:                      return 2;                    // Conditional AND                  case ExpressionType.AndAlso:                      return 3;                    // Logical OR                  case ExpressionType.Or:                      return 4;                    // Logical XOR                  case ExpressionType.ExclusiveOr:                      return 5;                    // Logical AND                  case ExpressionType.And:                      return 6;                    // Equality                  case ExpressionType.Equal:                  case ExpressionType.NotEqual:                      return 7;                    // Relational' type testing                  case ExpressionType.GreaterThan:                  case ExpressionType.LessThan:                  case ExpressionType.GreaterThanOrEqual:                  case ExpressionType.LessThanOrEqual:                  case ExpressionType.TypeAs:                  case ExpressionType.TypeIs:                  case ExpressionType.TypeEqual:                      return 8;                    // Shift                  case ExpressionType.LeftShift:                  case ExpressionType.RightShift:                      return 9;                    // Additive                  case ExpressionType.Add:                  case ExpressionType.AddChecked:                  case ExpressionType.Subtract:                  case ExpressionType.SubtractChecked:                      return 10;                    // Multiplicative                  case ExpressionType.Divide:                  case ExpressionType.Modulo:                  case ExpressionType.Multiply:                  case ExpressionType.MultiplyChecked:                      return 11;                    // Unary                  case ExpressionType.Negate:                  case ExpressionType.NegateChecked:                  case ExpressionType.UnaryPlus:                  case ExpressionType.Not:                  case ExpressionType.Convert:                  case ExpressionType.ConvertChecked:                  case ExpressionType.PreIncrementAssign:                  case ExpressionType.PreDecrementAssign:                  case ExpressionType.OnesComplement:                  case ExpressionType.Increment:                  case ExpressionType.Decrement:                  case ExpressionType.IsTrue:                  case ExpressionType.IsFalse:                  case ExpressionType.Unbox:                  case ExpressionType.Throw:                      return 12;                    // Power' which is not in C#                  // But VB/Python/Ruby put it here' above unary.                  case ExpressionType.Power:                      return 13;                    // Primary' which includes all other node types:                  //   member access' calls' indexing' new.                  case ExpressionType.PostIncrementAssign:                  case ExpressionType.PostDecrementAssign:                      return 14;                    // These aren't expressions' so never need parentheses:                  //   constants' variables                  case ExpressionType.Constant:                  case ExpressionType.Parameter:                      return 15;                    default:                      return 14;              }
Magic Number,System.Linq.Expressions,DebugViewWriter,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DebugViewWriter.cs,GetOperatorPrecedence,The following statement contains a magic number: switch (node.NodeType)              {                  // Assignment                  case ExpressionType.Assign:                  case ExpressionType.ExclusiveOrAssign:                  case ExpressionType.AddAssign:                  case ExpressionType.AddAssignChecked:                  case ExpressionType.SubtractAssign:                  case ExpressionType.SubtractAssignChecked:                  case ExpressionType.DivideAssign:                  case ExpressionType.ModuloAssign:                  case ExpressionType.MultiplyAssign:                  case ExpressionType.MultiplyAssignChecked:                  case ExpressionType.LeftShiftAssign:                  case ExpressionType.RightShiftAssign:                  case ExpressionType.AndAssign:                  case ExpressionType.OrAssign:                  case ExpressionType.PowerAssign:                  case ExpressionType.Coalesce:                      return 1;                    // Conditional (?:) would go here                    // Conditional OR                  case ExpressionType.OrElse:                      return 2;                    // Conditional AND                  case ExpressionType.AndAlso:                      return 3;                    // Logical OR                  case ExpressionType.Or:                      return 4;                    // Logical XOR                  case ExpressionType.ExclusiveOr:                      return 5;                    // Logical AND                  case ExpressionType.And:                      return 6;                    // Equality                  case ExpressionType.Equal:                  case ExpressionType.NotEqual:                      return 7;                    // Relational' type testing                  case ExpressionType.GreaterThan:                  case ExpressionType.LessThan:                  case ExpressionType.GreaterThanOrEqual:                  case ExpressionType.LessThanOrEqual:                  case ExpressionType.TypeAs:                  case ExpressionType.TypeIs:                  case ExpressionType.TypeEqual:                      return 8;                    // Shift                  case ExpressionType.LeftShift:                  case ExpressionType.RightShift:                      return 9;                    // Additive                  case ExpressionType.Add:                  case ExpressionType.AddChecked:                  case ExpressionType.Subtract:                  case ExpressionType.SubtractChecked:                      return 10;                    // Multiplicative                  case ExpressionType.Divide:                  case ExpressionType.Modulo:                  case ExpressionType.Multiply:                  case ExpressionType.MultiplyChecked:                      return 11;                    // Unary                  case ExpressionType.Negate:                  case ExpressionType.NegateChecked:                  case ExpressionType.UnaryPlus:                  case ExpressionType.Not:                  case ExpressionType.Convert:                  case ExpressionType.ConvertChecked:                  case ExpressionType.PreIncrementAssign:                  case ExpressionType.PreDecrementAssign:                  case ExpressionType.OnesComplement:                  case ExpressionType.Increment:                  case ExpressionType.Decrement:                  case ExpressionType.IsTrue:                  case ExpressionType.IsFalse:                  case ExpressionType.Unbox:                  case ExpressionType.Throw:                      return 12;                    // Power' which is not in C#                  // But VB/Python/Ruby put it here' above unary.                  case ExpressionType.Power:                      return 13;                    // Primary' which includes all other node types:                  //   member access' calls' indexing' new.                  case ExpressionType.PostIncrementAssign:                  case ExpressionType.PostDecrementAssign:                      return 14;                    // These aren't expressions' so never need parentheses:                  //   constants' variables                  case ExpressionType.Constant:                  case ExpressionType.Parameter:                      return 15;                    default:                      return 14;              }
Magic Number,System.Linq.Expressions,DebugViewWriter,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DebugViewWriter.cs,GetOperatorPrecedence,The following statement contains a magic number: switch (node.NodeType)              {                  // Assignment                  case ExpressionType.Assign:                  case ExpressionType.ExclusiveOrAssign:                  case ExpressionType.AddAssign:                  case ExpressionType.AddAssignChecked:                  case ExpressionType.SubtractAssign:                  case ExpressionType.SubtractAssignChecked:                  case ExpressionType.DivideAssign:                  case ExpressionType.ModuloAssign:                  case ExpressionType.MultiplyAssign:                  case ExpressionType.MultiplyAssignChecked:                  case ExpressionType.LeftShiftAssign:                  case ExpressionType.RightShiftAssign:                  case ExpressionType.AndAssign:                  case ExpressionType.OrAssign:                  case ExpressionType.PowerAssign:                  case ExpressionType.Coalesce:                      return 1;                    // Conditional (?:) would go here                    // Conditional OR                  case ExpressionType.OrElse:                      return 2;                    // Conditional AND                  case ExpressionType.AndAlso:                      return 3;                    // Logical OR                  case ExpressionType.Or:                      return 4;                    // Logical XOR                  case ExpressionType.ExclusiveOr:                      return 5;                    // Logical AND                  case ExpressionType.And:                      return 6;                    // Equality                  case ExpressionType.Equal:                  case ExpressionType.NotEqual:                      return 7;                    // Relational' type testing                  case ExpressionType.GreaterThan:                  case ExpressionType.LessThan:                  case ExpressionType.GreaterThanOrEqual:                  case ExpressionType.LessThanOrEqual:                  case ExpressionType.TypeAs:                  case ExpressionType.TypeIs:                  case ExpressionType.TypeEqual:                      return 8;                    // Shift                  case ExpressionType.LeftShift:                  case ExpressionType.RightShift:                      return 9;                    // Additive                  case ExpressionType.Add:                  case ExpressionType.AddChecked:                  case ExpressionType.Subtract:                  case ExpressionType.SubtractChecked:                      return 10;                    // Multiplicative                  case ExpressionType.Divide:                  case ExpressionType.Modulo:                  case ExpressionType.Multiply:                  case ExpressionType.MultiplyChecked:                      return 11;                    // Unary                  case ExpressionType.Negate:                  case ExpressionType.NegateChecked:                  case ExpressionType.UnaryPlus:                  case ExpressionType.Not:                  case ExpressionType.Convert:                  case ExpressionType.ConvertChecked:                  case ExpressionType.PreIncrementAssign:                  case ExpressionType.PreDecrementAssign:                  case ExpressionType.OnesComplement:                  case ExpressionType.Increment:                  case ExpressionType.Decrement:                  case ExpressionType.IsTrue:                  case ExpressionType.IsFalse:                  case ExpressionType.Unbox:                  case ExpressionType.Throw:                      return 12;                    // Power' which is not in C#                  // But VB/Python/Ruby put it here' above unary.                  case ExpressionType.Power:                      return 13;                    // Primary' which includes all other node types:                  //   member access' calls' indexing' new.                  case ExpressionType.PostIncrementAssign:                  case ExpressionType.PostDecrementAssign:                      return 14;                    // These aren't expressions' so never need parentheses:                  //   constants' variables                  case ExpressionType.Constant:                  case ExpressionType.Parameter:                      return 15;                    default:                      return 14;              }
Magic Number,System.Linq.Expressions,DebugViewWriter,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DebugViewWriter.cs,GetOperatorPrecedence,The following statement contains a magic number: switch (node.NodeType)              {                  // Assignment                  case ExpressionType.Assign:                  case ExpressionType.ExclusiveOrAssign:                  case ExpressionType.AddAssign:                  case ExpressionType.AddAssignChecked:                  case ExpressionType.SubtractAssign:                  case ExpressionType.SubtractAssignChecked:                  case ExpressionType.DivideAssign:                  case ExpressionType.ModuloAssign:                  case ExpressionType.MultiplyAssign:                  case ExpressionType.MultiplyAssignChecked:                  case ExpressionType.LeftShiftAssign:                  case ExpressionType.RightShiftAssign:                  case ExpressionType.AndAssign:                  case ExpressionType.OrAssign:                  case ExpressionType.PowerAssign:                  case ExpressionType.Coalesce:                      return 1;                    // Conditional (?:) would go here                    // Conditional OR                  case ExpressionType.OrElse:                      return 2;                    // Conditional AND                  case ExpressionType.AndAlso:                      return 3;                    // Logical OR                  case ExpressionType.Or:                      return 4;                    // Logical XOR                  case ExpressionType.ExclusiveOr:                      return 5;                    // Logical AND                  case ExpressionType.And:                      return 6;                    // Equality                  case ExpressionType.Equal:                  case ExpressionType.NotEqual:                      return 7;                    // Relational' type testing                  case ExpressionType.GreaterThan:                  case ExpressionType.LessThan:                  case ExpressionType.GreaterThanOrEqual:                  case ExpressionType.LessThanOrEqual:                  case ExpressionType.TypeAs:                  case ExpressionType.TypeIs:                  case ExpressionType.TypeEqual:                      return 8;                    // Shift                  case ExpressionType.LeftShift:                  case ExpressionType.RightShift:                      return 9;                    // Additive                  case ExpressionType.Add:                  case ExpressionType.AddChecked:                  case ExpressionType.Subtract:                  case ExpressionType.SubtractChecked:                      return 10;                    // Multiplicative                  case ExpressionType.Divide:                  case ExpressionType.Modulo:                  case ExpressionType.Multiply:                  case ExpressionType.MultiplyChecked:                      return 11;                    // Unary                  case ExpressionType.Negate:                  case ExpressionType.NegateChecked:                  case ExpressionType.UnaryPlus:                  case ExpressionType.Not:                  case ExpressionType.Convert:                  case ExpressionType.ConvertChecked:                  case ExpressionType.PreIncrementAssign:                  case ExpressionType.PreDecrementAssign:                  case ExpressionType.OnesComplement:                  case ExpressionType.Increment:                  case ExpressionType.Decrement:                  case ExpressionType.IsTrue:                  case ExpressionType.IsFalse:                  case ExpressionType.Unbox:                  case ExpressionType.Throw:                      return 12;                    // Power' which is not in C#                  // But VB/Python/Ruby put it here' above unary.                  case ExpressionType.Power:                      return 13;                    // Primary' which includes all other node types:                  //   member access' calls' indexing' new.                  case ExpressionType.PostIncrementAssign:                  case ExpressionType.PostDecrementAssign:                      return 14;                    // These aren't expressions' so never need parentheses:                  //   constants' variables                  case ExpressionType.Constant:                  case ExpressionType.Parameter:                      return 15;                    default:                      return 14;              }
Magic Number,System.Linq.Expressions,DebugViewWriter,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DebugViewWriter.cs,GetOperatorPrecedence,The following statement contains a magic number: switch (node.NodeType)              {                  // Assignment                  case ExpressionType.Assign:                  case ExpressionType.ExclusiveOrAssign:                  case ExpressionType.AddAssign:                  case ExpressionType.AddAssignChecked:                  case ExpressionType.SubtractAssign:                  case ExpressionType.SubtractAssignChecked:                  case ExpressionType.DivideAssign:                  case ExpressionType.ModuloAssign:                  case ExpressionType.MultiplyAssign:                  case ExpressionType.MultiplyAssignChecked:                  case ExpressionType.LeftShiftAssign:                  case ExpressionType.RightShiftAssign:                  case ExpressionType.AndAssign:                  case ExpressionType.OrAssign:                  case ExpressionType.PowerAssign:                  case ExpressionType.Coalesce:                      return 1;                    // Conditional (?:) would go here                    // Conditional OR                  case ExpressionType.OrElse:                      return 2;                    // Conditional AND                  case ExpressionType.AndAlso:                      return 3;                    // Logical OR                  case ExpressionType.Or:                      return 4;                    // Logical XOR                  case ExpressionType.ExclusiveOr:                      return 5;                    // Logical AND                  case ExpressionType.And:                      return 6;                    // Equality                  case ExpressionType.Equal:                  case ExpressionType.NotEqual:                      return 7;                    // Relational' type testing                  case ExpressionType.GreaterThan:                  case ExpressionType.LessThan:                  case ExpressionType.GreaterThanOrEqual:                  case ExpressionType.LessThanOrEqual:                  case ExpressionType.TypeAs:                  case ExpressionType.TypeIs:                  case ExpressionType.TypeEqual:                      return 8;                    // Shift                  case ExpressionType.LeftShift:                  case ExpressionType.RightShift:                      return 9;                    // Additive                  case ExpressionType.Add:                  case ExpressionType.AddChecked:                  case ExpressionType.Subtract:                  case ExpressionType.SubtractChecked:                      return 10;                    // Multiplicative                  case ExpressionType.Divide:                  case ExpressionType.Modulo:                  case ExpressionType.Multiply:                  case ExpressionType.MultiplyChecked:                      return 11;                    // Unary                  case ExpressionType.Negate:                  case ExpressionType.NegateChecked:                  case ExpressionType.UnaryPlus:                  case ExpressionType.Not:                  case ExpressionType.Convert:                  case ExpressionType.ConvertChecked:                  case ExpressionType.PreIncrementAssign:                  case ExpressionType.PreDecrementAssign:                  case ExpressionType.OnesComplement:                  case ExpressionType.Increment:                  case ExpressionType.Decrement:                  case ExpressionType.IsTrue:                  case ExpressionType.IsFalse:                  case ExpressionType.Unbox:                  case ExpressionType.Throw:                      return 12;                    // Power' which is not in C#                  // But VB/Python/Ruby put it here' above unary.                  case ExpressionType.Power:                      return 13;                    // Primary' which includes all other node types:                  //   member access' calls' indexing' new.                  case ExpressionType.PostIncrementAssign:                  case ExpressionType.PostDecrementAssign:                      return 14;                    // These aren't expressions' so never need parentheses:                  //   constants' variables                  case ExpressionType.Constant:                  case ExpressionType.Parameter:                      return 15;                    default:                      return 14;              }
Magic Number,System.Linq.Expressions,DebugViewWriter,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DebugViewWriter.cs,GetOperatorPrecedence,The following statement contains a magic number: switch (node.NodeType)              {                  // Assignment                  case ExpressionType.Assign:                  case ExpressionType.ExclusiveOrAssign:                  case ExpressionType.AddAssign:                  case ExpressionType.AddAssignChecked:                  case ExpressionType.SubtractAssign:                  case ExpressionType.SubtractAssignChecked:                  case ExpressionType.DivideAssign:                  case ExpressionType.ModuloAssign:                  case ExpressionType.MultiplyAssign:                  case ExpressionType.MultiplyAssignChecked:                  case ExpressionType.LeftShiftAssign:                  case ExpressionType.RightShiftAssign:                  case ExpressionType.AndAssign:                  case ExpressionType.OrAssign:                  case ExpressionType.PowerAssign:                  case ExpressionType.Coalesce:                      return 1;                    // Conditional (?:) would go here                    // Conditional OR                  case ExpressionType.OrElse:                      return 2;                    // Conditional AND                  case ExpressionType.AndAlso:                      return 3;                    // Logical OR                  case ExpressionType.Or:                      return 4;                    // Logical XOR                  case ExpressionType.ExclusiveOr:                      return 5;                    // Logical AND                  case ExpressionType.And:                      return 6;                    // Equality                  case ExpressionType.Equal:                  case ExpressionType.NotEqual:                      return 7;                    // Relational' type testing                  case ExpressionType.GreaterThan:                  case ExpressionType.LessThan:                  case ExpressionType.GreaterThanOrEqual:                  case ExpressionType.LessThanOrEqual:                  case ExpressionType.TypeAs:                  case ExpressionType.TypeIs:                  case ExpressionType.TypeEqual:                      return 8;                    // Shift                  case ExpressionType.LeftShift:                  case ExpressionType.RightShift:                      return 9;                    // Additive                  case ExpressionType.Add:                  case ExpressionType.AddChecked:                  case ExpressionType.Subtract:                  case ExpressionType.SubtractChecked:                      return 10;                    // Multiplicative                  case ExpressionType.Divide:                  case ExpressionType.Modulo:                  case ExpressionType.Multiply:                  case ExpressionType.MultiplyChecked:                      return 11;                    // Unary                  case ExpressionType.Negate:                  case ExpressionType.NegateChecked:                  case ExpressionType.UnaryPlus:                  case ExpressionType.Not:                  case ExpressionType.Convert:                  case ExpressionType.ConvertChecked:                  case ExpressionType.PreIncrementAssign:                  case ExpressionType.PreDecrementAssign:                  case ExpressionType.OnesComplement:                  case ExpressionType.Increment:                  case ExpressionType.Decrement:                  case ExpressionType.IsTrue:                  case ExpressionType.IsFalse:                  case ExpressionType.Unbox:                  case ExpressionType.Throw:                      return 12;                    // Power' which is not in C#                  // But VB/Python/Ruby put it here' above unary.                  case ExpressionType.Power:                      return 13;                    // Primary' which includes all other node types:                  //   member access' calls' indexing' new.                  case ExpressionType.PostIncrementAssign:                  case ExpressionType.PostDecrementAssign:                      return 14;                    // These aren't expressions' so never need parentheses:                  //   constants' variables                  case ExpressionType.Constant:                  case ExpressionType.Parameter:                      return 15;                    default:                      return 14;              }
Magic Number,System.Linq.Expressions,DebugViewWriter,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DebugViewWriter.cs,GetOperatorPrecedence,The following statement contains a magic number: switch (node.NodeType)              {                  // Assignment                  case ExpressionType.Assign:                  case ExpressionType.ExclusiveOrAssign:                  case ExpressionType.AddAssign:                  case ExpressionType.AddAssignChecked:                  case ExpressionType.SubtractAssign:                  case ExpressionType.SubtractAssignChecked:                  case ExpressionType.DivideAssign:                  case ExpressionType.ModuloAssign:                  case ExpressionType.MultiplyAssign:                  case ExpressionType.MultiplyAssignChecked:                  case ExpressionType.LeftShiftAssign:                  case ExpressionType.RightShiftAssign:                  case ExpressionType.AndAssign:                  case ExpressionType.OrAssign:                  case ExpressionType.PowerAssign:                  case ExpressionType.Coalesce:                      return 1;                    // Conditional (?:) would go here                    // Conditional OR                  case ExpressionType.OrElse:                      return 2;                    // Conditional AND                  case ExpressionType.AndAlso:                      return 3;                    // Logical OR                  case ExpressionType.Or:                      return 4;                    // Logical XOR                  case ExpressionType.ExclusiveOr:                      return 5;                    // Logical AND                  case ExpressionType.And:                      return 6;                    // Equality                  case ExpressionType.Equal:                  case ExpressionType.NotEqual:                      return 7;                    // Relational' type testing                  case ExpressionType.GreaterThan:                  case ExpressionType.LessThan:                  case ExpressionType.GreaterThanOrEqual:                  case ExpressionType.LessThanOrEqual:                  case ExpressionType.TypeAs:                  case ExpressionType.TypeIs:                  case ExpressionType.TypeEqual:                      return 8;                    // Shift                  case ExpressionType.LeftShift:                  case ExpressionType.RightShift:                      return 9;                    // Additive                  case ExpressionType.Add:                  case ExpressionType.AddChecked:                  case ExpressionType.Subtract:                  case ExpressionType.SubtractChecked:                      return 10;                    // Multiplicative                  case ExpressionType.Divide:                  case ExpressionType.Modulo:                  case ExpressionType.Multiply:                  case ExpressionType.MultiplyChecked:                      return 11;                    // Unary                  case ExpressionType.Negate:                  case ExpressionType.NegateChecked:                  case ExpressionType.UnaryPlus:                  case ExpressionType.Not:                  case ExpressionType.Convert:                  case ExpressionType.ConvertChecked:                  case ExpressionType.PreIncrementAssign:                  case ExpressionType.PreDecrementAssign:                  case ExpressionType.OnesComplement:                  case ExpressionType.Increment:                  case ExpressionType.Decrement:                  case ExpressionType.IsTrue:                  case ExpressionType.IsFalse:                  case ExpressionType.Unbox:                  case ExpressionType.Throw:                      return 12;                    // Power' which is not in C#                  // But VB/Python/Ruby put it here' above unary.                  case ExpressionType.Power:                      return 13;                    // Primary' which includes all other node types:                  //   member access' calls' indexing' new.                  case ExpressionType.PostIncrementAssign:                  case ExpressionType.PostDecrementAssign:                      return 14;                    // These aren't expressions' so never need parentheses:                  //   constants' variables                  case ExpressionType.Constant:                  case ExpressionType.Parameter:                      return 15;                    default:                      return 14;              }
Magic Number,System.Linq.Expressions,DebugViewWriter,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DebugViewWriter.cs,GetOperatorPrecedence,The following statement contains a magic number: switch (node.NodeType)              {                  // Assignment                  case ExpressionType.Assign:                  case ExpressionType.ExclusiveOrAssign:                  case ExpressionType.AddAssign:                  case ExpressionType.AddAssignChecked:                  case ExpressionType.SubtractAssign:                  case ExpressionType.SubtractAssignChecked:                  case ExpressionType.DivideAssign:                  case ExpressionType.ModuloAssign:                  case ExpressionType.MultiplyAssign:                  case ExpressionType.MultiplyAssignChecked:                  case ExpressionType.LeftShiftAssign:                  case ExpressionType.RightShiftAssign:                  case ExpressionType.AndAssign:                  case ExpressionType.OrAssign:                  case ExpressionType.PowerAssign:                  case ExpressionType.Coalesce:                      return 1;                    // Conditional (?:) would go here                    // Conditional OR                  case ExpressionType.OrElse:                      return 2;                    // Conditional AND                  case ExpressionType.AndAlso:                      return 3;                    // Logical OR                  case ExpressionType.Or:                      return 4;                    // Logical XOR                  case ExpressionType.ExclusiveOr:                      return 5;                    // Logical AND                  case ExpressionType.And:                      return 6;                    // Equality                  case ExpressionType.Equal:                  case ExpressionType.NotEqual:                      return 7;                    // Relational' type testing                  case ExpressionType.GreaterThan:                  case ExpressionType.LessThan:                  case ExpressionType.GreaterThanOrEqual:                  case ExpressionType.LessThanOrEqual:                  case ExpressionType.TypeAs:                  case ExpressionType.TypeIs:                  case ExpressionType.TypeEqual:                      return 8;                    // Shift                  case ExpressionType.LeftShift:                  case ExpressionType.RightShift:                      return 9;                    // Additive                  case ExpressionType.Add:                  case ExpressionType.AddChecked:                  case ExpressionType.Subtract:                  case ExpressionType.SubtractChecked:                      return 10;                    // Multiplicative                  case ExpressionType.Divide:                  case ExpressionType.Modulo:                  case ExpressionType.Multiply:                  case ExpressionType.MultiplyChecked:                      return 11;                    // Unary                  case ExpressionType.Negate:                  case ExpressionType.NegateChecked:                  case ExpressionType.UnaryPlus:                  case ExpressionType.Not:                  case ExpressionType.Convert:                  case ExpressionType.ConvertChecked:                  case ExpressionType.PreIncrementAssign:                  case ExpressionType.PreDecrementAssign:                  case ExpressionType.OnesComplement:                  case ExpressionType.Increment:                  case ExpressionType.Decrement:                  case ExpressionType.IsTrue:                  case ExpressionType.IsFalse:                  case ExpressionType.Unbox:                  case ExpressionType.Throw:                      return 12;                    // Power' which is not in C#                  // But VB/Python/Ruby put it here' above unary.                  case ExpressionType.Power:                      return 13;                    // Primary' which includes all other node types:                  //   member access' calls' indexing' new.                  case ExpressionType.PostIncrementAssign:                  case ExpressionType.PostDecrementAssign:                      return 14;                    // These aren't expressions' so never need parentheses:                  //   constants' variables                  case ExpressionType.Constant:                  case ExpressionType.Parameter:                      return 15;                    default:                      return 14;              }
Magic Number,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,MakeDynamic,The following statement contains a magic number: switch (argumentList.Length)              {                  case 1:                      return MakeDynamic(delegateType' binder' argumentList[0]);                    case 2:                      return MakeDynamic(delegateType' binder' argumentList[0]' argumentList[1]);                    case 3:                      return MakeDynamic(delegateType' binder' argumentList[0]' argumentList[1]' argumentList[2]);                    case 4:                      return MakeDynamic(delegateType' binder' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]);                    default:                      break;              }
Magic Number,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,MakeDynamic,The following statement contains a magic number: switch (argumentList.Length)              {                  case 1:                      return MakeDynamic(delegateType' binder' argumentList[0]);                    case 2:                      return MakeDynamic(delegateType' binder' argumentList[0]' argumentList[1]);                    case 3:                      return MakeDynamic(delegateType' binder' argumentList[0]' argumentList[1]' argumentList[2]);                    case 4:                      return MakeDynamic(delegateType' binder' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]);                    default:                      break;              }
Magic Number,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,MakeDynamic,The following statement contains a magic number: switch (argumentList.Length)              {                  case 1:                      return MakeDynamic(delegateType' binder' argumentList[0]);                    case 2:                      return MakeDynamic(delegateType' binder' argumentList[0]' argumentList[1]);                    case 3:                      return MakeDynamic(delegateType' binder' argumentList[0]' argumentList[1]' argumentList[2]);                    case 4:                      return MakeDynamic(delegateType' binder' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]);                    default:                      break;              }
Magic Number,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,MakeDynamic,The following statement contains a magic number: switch (argumentList.Length)              {                  case 1:                      return MakeDynamic(delegateType' binder' argumentList[0]);                    case 2:                      return MakeDynamic(delegateType' binder' argumentList[0]' argumentList[1]);                    case 3:                      return MakeDynamic(delegateType' binder' argumentList[0]' argumentList[1]' argumentList[2]);                    case 4:                      return MakeDynamic(delegateType' binder' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]);                    default:                      break;              }
Magic Number,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,MakeDynamic,The following statement contains a magic number: switch (argumentList.Length)              {                  case 1:                      return MakeDynamic(delegateType' binder' argumentList[0]);                    case 2:                      return MakeDynamic(delegateType' binder' argumentList[0]' argumentList[1]);                    case 3:                      return MakeDynamic(delegateType' binder' argumentList[0]' argumentList[1]' argumentList[2]);                    case 4:                      return MakeDynamic(delegateType' binder' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]);                    default:                      break;              }
Magic Number,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,MakeDynamic,The following statement contains a magic number: switch (argumentList.Length)              {                  case 1:                      return MakeDynamic(delegateType' binder' argumentList[0]);                    case 2:                      return MakeDynamic(delegateType' binder' argumentList[0]' argumentList[1]);                    case 3:                      return MakeDynamic(delegateType' binder' argumentList[0]' argumentList[1]' argumentList[2]);                    case 4:                      return MakeDynamic(delegateType' binder' argumentList[0]' argumentList[1]' argumentList[2]' argumentList[3]);                    default:                      break;              }
Magic Number,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,MakeDynamic,The following statement contains a magic number: ExpressionUtils.ValidateArgumentCount(method' ExpressionType.Dynamic' 2' parameters);
Magic Number,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,MakeDynamic,The following statement contains a magic number: ExpressionUtils.ValidateArgumentCount(method' ExpressionType.Dynamic' 3' parameters);
Magic Number,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,MakeDynamic,The following statement contains a magic number: ExpressionUtils.ValidateOneArgument(method' ExpressionType.Dynamic' arg1' parameters[2]' nameof(delegateType)' nameof(arg1));
Magic Number,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,MakeDynamic,The following statement contains a magic number: ExpressionUtils.ValidateArgumentCount(method' ExpressionType.Dynamic' 4' parameters);
Magic Number,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,MakeDynamic,The following statement contains a magic number: ExpressionUtils.ValidateOneArgument(method' ExpressionType.Dynamic' arg1' parameters[2]' nameof(delegateType)' nameof(arg1));
Magic Number,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,MakeDynamic,The following statement contains a magic number: ExpressionUtils.ValidateOneArgument(method' ExpressionType.Dynamic' arg2' parameters[3]' nameof(delegateType)' nameof(arg2));
Magic Number,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,MakeDynamic,The following statement contains a magic number: ExpressionUtils.ValidateArgumentCount(method' ExpressionType.Dynamic' 5' parameters);
Magic Number,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,MakeDynamic,The following statement contains a magic number: ExpressionUtils.ValidateOneArgument(method' ExpressionType.Dynamic' arg1' parameters[2]' nameof(delegateType)' nameof(arg1));
Magic Number,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,MakeDynamic,The following statement contains a magic number: ExpressionUtils.ValidateOneArgument(method' ExpressionType.Dynamic' arg2' parameters[3]' nameof(delegateType)' nameof(arg2));
Magic Number,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,MakeDynamic,The following statement contains a magic number: ExpressionUtils.ValidateOneArgument(method' ExpressionType.Dynamic' arg3' parameters[4]' nameof(delegateType)' nameof(arg3));
Magic Number,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,MakeDynamic,The following statement contains a magic number: switch (n)              {                  case 1: return DynamicExpression.Make(returnType' delegateType' binder' arguments[0]);                  case 2: return DynamicExpression.Make(returnType' delegateType' binder' arguments[0]' arguments[1]);                  case 3: return DynamicExpression.Make(returnType' delegateType' binder' arguments[0]' arguments[1]' arguments[2]);                  case 4: return DynamicExpression.Make(returnType' delegateType' binder' arguments[0]' arguments[1]' arguments[2]' arguments[3]);                  default: return DynamicExpression.Make(returnType' delegateType' binder' arguments);              }
Magic Number,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,MakeDynamic,The following statement contains a magic number: switch (n)              {                  case 1: return DynamicExpression.Make(returnType' delegateType' binder' arguments[0]);                  case 2: return DynamicExpression.Make(returnType' delegateType' binder' arguments[0]' arguments[1]);                  case 3: return DynamicExpression.Make(returnType' delegateType' binder' arguments[0]' arguments[1]' arguments[2]);                  case 4: return DynamicExpression.Make(returnType' delegateType' binder' arguments[0]' arguments[1]' arguments[2]' arguments[3]);                  default: return DynamicExpression.Make(returnType' delegateType' binder' arguments);              }
Magic Number,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,MakeDynamic,The following statement contains a magic number: switch (n)              {                  case 1: return DynamicExpression.Make(returnType' delegateType' binder' arguments[0]);                  case 2: return DynamicExpression.Make(returnType' delegateType' binder' arguments[0]' arguments[1]);                  case 3: return DynamicExpression.Make(returnType' delegateType' binder' arguments[0]' arguments[1]' arguments[2]);                  case 4: return DynamicExpression.Make(returnType' delegateType' binder' arguments[0]' arguments[1]' arguments[2]' arguments[3]);                  default: return DynamicExpression.Make(returnType' delegateType' binder' arguments);              }
Magic Number,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,MakeDynamic,The following statement contains a magic number: switch (n)              {                  case 1: return DynamicExpression.Make(returnType' delegateType' binder' arguments[0]);                  case 2: return DynamicExpression.Make(returnType' delegateType' binder' arguments[0]' arguments[1]);                  case 3: return DynamicExpression.Make(returnType' delegateType' binder' arguments[0]' arguments[1]' arguments[2]);                  case 4: return DynamicExpression.Make(returnType' delegateType' binder' arguments[0]' arguments[1]' arguments[2]' arguments[3]);                  default: return DynamicExpression.Make(returnType' delegateType' binder' arguments);              }
Magic Number,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,MakeDynamic,The following statement contains a magic number: switch (n)              {                  case 1: return DynamicExpression.Make(returnType' delegateType' binder' arguments[0]);                  case 2: return DynamicExpression.Make(returnType' delegateType' binder' arguments[0]' arguments[1]);                  case 3: return DynamicExpression.Make(returnType' delegateType' binder' arguments[0]' arguments[1]' arguments[2]);                  case 4: return DynamicExpression.Make(returnType' delegateType' binder' arguments[0]' arguments[1]' arguments[2]' arguments[3]);                  default: return DynamicExpression.Make(returnType' delegateType' binder' arguments);              }
Magic Number,System.Linq.Expressions,ExpressionExtension,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,MakeDynamic,The following statement contains a magic number: switch (n)              {                  case 1: return DynamicExpression.Make(returnType' delegateType' binder' arguments[0]);                  case 2: return DynamicExpression.Make(returnType' delegateType' binder' arguments[0]' arguments[1]);                  case 3: return DynamicExpression.Make(returnType' delegateType' binder' arguments[0]' arguments[1]' arguments[2]);                  case 4: return DynamicExpression.Make(returnType' delegateType' binder' arguments[0]' arguments[1]' arguments[2]' arguments[3]);                  default: return DynamicExpression.Make(returnType' delegateType' binder' arguments);              }
Magic Number,System.Linq.Expressions,DynamicExpression2,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,SameArguments,The following statement contains a magic number: arguments?.Count != 2
Magic Number,System.Linq.Expressions,DynamicExpression3,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,GetArgument,The following statement contains a magic number: switch (index)              {                  case 0: return ExpressionUtils.ReturnObject<Expression>(_arg0);                  case 1: return _arg1;                  case 2: return _arg2;                  default: throw new ArgumentOutOfRangeException(nameof(index));              }
Magic Number,System.Linq.Expressions,DynamicExpression3,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,Rewrite,The following statement contains a magic number: return ExpressionExtension.MakeDynamic(DelegateType' Binder' args![0]' args![1]' args![2]);
Magic Number,System.Linq.Expressions,DynamicExpression3,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,SameArguments,The following statement contains a magic number: arguments?.Count != 3
Magic Number,System.Linq.Expressions,DynamicExpression4,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,GetArgument,The following statement contains a magic number: switch (index)              {                  case 0: return ExpressionUtils.ReturnObject<Expression>(_arg0);                  case 1: return _arg1;                  case 2: return _arg2;                  case 3: return _arg3;                  default: throw new ArgumentOutOfRangeException(nameof(index));              }
Magic Number,System.Linq.Expressions,DynamicExpression4,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,GetArgument,The following statement contains a magic number: switch (index)              {                  case 0: return ExpressionUtils.ReturnObject<Expression>(_arg0);                  case 1: return _arg1;                  case 2: return _arg2;                  case 3: return _arg3;                  default: throw new ArgumentOutOfRangeException(nameof(index));              }
Magic Number,System.Linq.Expressions,DynamicExpression4,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,Rewrite,The following statement contains a magic number: return ExpressionExtension.MakeDynamic(DelegateType' Binder' args![0]' args![1]' args![2]' args![3]);
Magic Number,System.Linq.Expressions,DynamicExpression4,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,Rewrite,The following statement contains a magic number: return ExpressionExtension.MakeDynamic(DelegateType' Binder' args![0]' args![1]' args![2]' args![3]);
Magic Number,System.Linq.Expressions,DynamicExpression4,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\DynamicExpression.cs,SameArguments,The following statement contains a magic number: arguments?.Count != 4
Magic Number,System.Linq.Expressions,InvocationExpression2,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\InvocationExpression.cs,Rewrite,The following statement contains a magic number: Debug.Assert(arguments == null || arguments.Length == 2);
Magic Number,System.Linq.Expressions,InvocationExpression3,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\InvocationExpression.cs,GetArgument,The following statement contains a magic number: switch (index)              {                  case 0: return ExpressionUtils.ReturnObject<Expression>(_arg0);                  case 1: return _arg1;                  case 2: return _arg2;                  default: throw new ArgumentOutOfRangeException(nameof(index));              }
Magic Number,System.Linq.Expressions,InvocationExpression3,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\InvocationExpression.cs,Rewrite,The following statement contains a magic number: Debug.Assert(arguments == null || arguments.Length == 3);
Magic Number,System.Linq.Expressions,InvocationExpression3,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\InvocationExpression.cs,Rewrite,The following statement contains a magic number: return arguments != null ? Invoke(lambda' arguments[0]' arguments[1]' arguments[2]) : Invoke(lambda' ExpressionUtils.ReturnObject<Expression>(_arg0)' _arg1' _arg2);
Magic Number,System.Linq.Expressions,InvocationExpression4,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\InvocationExpression.cs,GetArgument,The following statement contains a magic number: switch (index)              {                  case 0: return ExpressionUtils.ReturnObject<Expression>(_arg0);                  case 1: return _arg1;                  case 2: return _arg2;                  case 3: return _arg3;                  default: throw new ArgumentOutOfRangeException(nameof(index));              }
Magic Number,System.Linq.Expressions,InvocationExpression4,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\InvocationExpression.cs,GetArgument,The following statement contains a magic number: switch (index)              {                  case 0: return ExpressionUtils.ReturnObject<Expression>(_arg0);                  case 1: return _arg1;                  case 2: return _arg2;                  case 3: return _arg3;                  default: throw new ArgumentOutOfRangeException(nameof(index));              }
Magic Number,System.Linq.Expressions,InvocationExpression4,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\InvocationExpression.cs,Rewrite,The following statement contains a magic number: Debug.Assert(arguments == null || arguments.Length == 4);
Magic Number,System.Linq.Expressions,InvocationExpression4,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\InvocationExpression.cs,Rewrite,The following statement contains a magic number: return arguments != null ? Invoke(lambda' arguments[0]' arguments[1]' arguments[2]' arguments[3]) : Invoke(lambda' ExpressionUtils.ReturnObject<Expression>(_arg0)' _arg1' _arg2' _arg3);
Magic Number,System.Linq.Expressions,InvocationExpression4,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\InvocationExpression.cs,Rewrite,The following statement contains a magic number: return arguments != null ? Invoke(lambda' arguments[0]' arguments[1]' arguments[2]' arguments[3]) : Invoke(lambda' ExpressionUtils.ReturnObject<Expression>(_arg0)' _arg1' _arg2' _arg3);
Magic Number,System.Linq.Expressions,InvocationExpression5,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\InvocationExpression.cs,GetArgument,The following statement contains a magic number: switch (index)              {                  case 0: return ExpressionUtils.ReturnObject<Expression>(_arg0);                  case 1: return _arg1;                  case 2: return _arg2;                  case 3: return _arg3;                  case 4: return _arg4;                  default: throw new ArgumentOutOfRangeException(nameof(index));              }
Magic Number,System.Linq.Expressions,InvocationExpression5,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\InvocationExpression.cs,GetArgument,The following statement contains a magic number: switch (index)              {                  case 0: return ExpressionUtils.ReturnObject<Expression>(_arg0);                  case 1: return _arg1;                  case 2: return _arg2;                  case 3: return _arg3;                  case 4: return _arg4;                  default: throw new ArgumentOutOfRangeException(nameof(index));              }
Magic Number,System.Linq.Expressions,InvocationExpression5,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\InvocationExpression.cs,GetArgument,The following statement contains a magic number: switch (index)              {                  case 0: return ExpressionUtils.ReturnObject<Expression>(_arg0);                  case 1: return _arg1;                  case 2: return _arg2;                  case 3: return _arg3;                  case 4: return _arg4;                  default: throw new ArgumentOutOfRangeException(nameof(index));              }
Magic Number,System.Linq.Expressions,InvocationExpression5,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\InvocationExpression.cs,Rewrite,The following statement contains a magic number: Debug.Assert(arguments == null || arguments.Length == 5);
Magic Number,System.Linq.Expressions,InvocationExpression5,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\InvocationExpression.cs,Rewrite,The following statement contains a magic number: return arguments != null ? Invoke(lambda' arguments[0]' arguments[1]' arguments[2]' arguments[3]' arguments[4]) : Invoke(lambda' ExpressionUtils.ReturnObject<Expression>(_arg0)' _arg1' _arg2' _arg3' _arg4);
Magic Number,System.Linq.Expressions,InvocationExpression5,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\InvocationExpression.cs,Rewrite,The following statement contains a magic number: return arguments != null ? Invoke(lambda' arguments[0]' arguments[1]' arguments[2]' arguments[3]' arguments[4]) : Invoke(lambda' ExpressionUtils.ReturnObject<Expression>(_arg0)' _arg1' _arg2' _arg3' _arg4);
Magic Number,System.Linq.Expressions,InvocationExpression5,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\InvocationExpression.cs,Rewrite,The following statement contains a magic number: return arguments != null ? Invoke(lambda' arguments[0]' arguments[1]' arguments[2]' arguments[3]' arguments[4]) : Invoke(lambda' ExpressionUtils.ReturnObject<Expression>(_arg0)' _arg1' _arg2' _arg3' _arg4);
Magic Number,System.Linq.Expressions,Expression<TDelegate>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\LambdaExpression.cs,Create,The following statement contains a magic number: switch (parameters.Length)              {                  case 0: return new Expression0<TDelegate>(body);                  case 1: return new Expression1<TDelegate>(body' parameters[0]);                  case 2: return new Expression2<TDelegate>(body' parameters[0]' parameters[1]);                  case 3: return new Expression3<TDelegate>(body' parameters[0]' parameters[1]' parameters[2]);                  default: return new ExpressionN<TDelegate>(body' parameters);              }
Magic Number,System.Linq.Expressions,Expression<TDelegate>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\LambdaExpression.cs,Create,The following statement contains a magic number: switch (parameters.Length)              {                  case 0: return new Expression0<TDelegate>(body);                  case 1: return new Expression1<TDelegate>(body' parameters[0]);                  case 2: return new Expression2<TDelegate>(body' parameters[0]' parameters[1]);                  case 3: return new Expression3<TDelegate>(body' parameters[0]' parameters[1]' parameters[2]);                  default: return new ExpressionN<TDelegate>(body' parameters);              }
Magic Number,System.Linq.Expressions,Expression<TDelegate>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\LambdaExpression.cs,Create,The following statement contains a magic number: switch (parameters.Length)              {                  case 0: return new Expression0<TDelegate>(body);                  case 1: return new Expression1<TDelegate>(body' parameters[0]);                  case 2: return new Expression2<TDelegate>(body' parameters[0]' parameters[1]);                  case 3: return new Expression3<TDelegate>(body' parameters[0]' parameters[1]' parameters[2]);                  default: return new ExpressionN<TDelegate>(body' parameters);              }
Magic Number,System.Linq.Expressions,Expression2<TDelegate>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\LambdaExpression.cs,Rewrite,The following statement contains a magic number: Debug.Assert(parameters == null || parameters.Length == 2);
Magic Number,System.Linq.Expressions,Expression2<TDelegate>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\LambdaExpression.cs,SameParameters,The following statement contains a magic number: parameters?.Count != 2
Magic Number,System.Linq.Expressions,Expression3<TDelegate>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\LambdaExpression.cs,GetParameter,The following statement contains a magic number: switch (index)              {                  case 0: return ExpressionUtils.ReturnObject<ParameterExpression>(_par0);                  case 1: return _par1;                  case 2: return _par2;                  default: throw new ArgumentOutOfRangeException(nameof(index));              }
Magic Number,System.Linq.Expressions,Expression3<TDelegate>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\LambdaExpression.cs,Rewrite,The following statement contains a magic number: Debug.Assert(parameters == null || parameters.Length == 3);
Magic Number,System.Linq.Expressions,Expression3<TDelegate>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\LambdaExpression.cs,SameParameters,The following statement contains a magic number: parameters?.Count != 3
Magic Number,System.Linq.Expressions,MemberInitExpression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MemberInitExpression.cs,ReduceListInit,The following statement contains a magic number: var block = new Expression[count + 2];
Magic Number,System.Linq.Expressions,MemberInitExpression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MemberInitExpression.cs,ReduceMemberInit,The following statement contains a magic number: var block = new Expression[count + 2];
Magic Number,System.Linq.Expressions,InstanceMethodCallExpression2,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MethodCallExpression.cs,Rewrite,The following statement contains a magic number: Debug.Assert(args == null || args.Count == 2);
Magic Number,System.Linq.Expressions,InstanceMethodCallExpression2,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MethodCallExpression.cs,SameArguments,The following statement contains a magic number: arguments?.Count != 2
Magic Number,System.Linq.Expressions,InstanceMethodCallExpression3,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MethodCallExpression.cs,GetArgument,The following statement contains a magic number: switch (index)              {                  case 0: return ExpressionUtils.ReturnObject<Expression>(_arg0);                  case 1: return _arg1;                  case 2: return _arg2;                  default: throw new ArgumentOutOfRangeException(nameof(index));              }
Magic Number,System.Linq.Expressions,InstanceMethodCallExpression3,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MethodCallExpression.cs,Rewrite,The following statement contains a magic number: Debug.Assert(args == null || args.Count == 3);
Magic Number,System.Linq.Expressions,InstanceMethodCallExpression3,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MethodCallExpression.cs,Rewrite,The following statement contains a magic number: return args != null ? Call(instance' Method' args[0]' args[1]' args[2]) : Call(instance' Method' ExpressionUtils.ReturnObject<Expression>(_arg0)' _arg1' _arg2);
Magic Number,System.Linq.Expressions,InstanceMethodCallExpression3,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MethodCallExpression.cs,SameArguments,The following statement contains a magic number: arguments?.Count != 3
Magic Number,System.Linq.Expressions,MethodCallExpression2,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MethodCallExpression.cs,Rewrite,The following statement contains a magic number: Debug.Assert(args == null || args.Count == 2);
Magic Number,System.Linq.Expressions,MethodCallExpression2,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MethodCallExpression.cs,SameArguments,The following statement contains a magic number: arguments?.Count != 2
Magic Number,System.Linq.Expressions,MethodCallExpression3,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MethodCallExpression.cs,GetArgument,The following statement contains a magic number: switch (index)              {                  case 0: return ExpressionUtils.ReturnObject<Expression>(_arg0);                  case 1: return _arg1;                  case 2: return _arg2;                  default: throw new ArgumentOutOfRangeException(nameof(index));              }
Magic Number,System.Linq.Expressions,MethodCallExpression3,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MethodCallExpression.cs,Rewrite,The following statement contains a magic number: Debug.Assert(args == null || args.Count == 3);
Magic Number,System.Linq.Expressions,MethodCallExpression3,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MethodCallExpression.cs,Rewrite,The following statement contains a magic number: return args != null ? Call(Method' args[0]' args[1]' args[2]) : Call(Method' ExpressionUtils.ReturnObject<Expression>(_arg0)' _arg1' _arg2);
Magic Number,System.Linq.Expressions,MethodCallExpression3,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MethodCallExpression.cs,SameArguments,The following statement contains a magic number: arguments?.Count != 3
Magic Number,System.Linq.Expressions,MethodCallExpression4,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MethodCallExpression.cs,GetArgument,The following statement contains a magic number: switch (index)              {                  case 0: return ExpressionUtils.ReturnObject<Expression>(_arg0);                  case 1: return _arg1;                  case 2: return _arg2;                  case 3: return _arg3;                  default: throw new ArgumentOutOfRangeException(nameof(index));              }
Magic Number,System.Linq.Expressions,MethodCallExpression4,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MethodCallExpression.cs,GetArgument,The following statement contains a magic number: switch (index)              {                  case 0: return ExpressionUtils.ReturnObject<Expression>(_arg0);                  case 1: return _arg1;                  case 2: return _arg2;                  case 3: return _arg3;                  default: throw new ArgumentOutOfRangeException(nameof(index));              }
Magic Number,System.Linq.Expressions,MethodCallExpression4,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MethodCallExpression.cs,Rewrite,The following statement contains a magic number: Debug.Assert(args == null || args.Count == 4);
Magic Number,System.Linq.Expressions,MethodCallExpression4,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MethodCallExpression.cs,Rewrite,The following statement contains a magic number: return args != null ? Call(Method' args[0]' args[1]' args[2]' args[3]) : Call(Method' ExpressionUtils.ReturnObject<Expression>(_arg0)' _arg1' _arg2' _arg3);
Magic Number,System.Linq.Expressions,MethodCallExpression4,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MethodCallExpression.cs,Rewrite,The following statement contains a magic number: return args != null ? Call(Method' args[0]' args[1]' args[2]' args[3]) : Call(Method' ExpressionUtils.ReturnObject<Expression>(_arg0)' _arg1' _arg2' _arg3);
Magic Number,System.Linq.Expressions,MethodCallExpression4,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MethodCallExpression.cs,SameArguments,The following statement contains a magic number: arguments?.Count != 4
Magic Number,System.Linq.Expressions,MethodCallExpression5,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MethodCallExpression.cs,GetArgument,The following statement contains a magic number: switch (index)              {                  case 0: return ExpressionUtils.ReturnObject<Expression>(_arg0);                  case 1: return _arg1;                  case 2: return _arg2;                  case 3: return _arg3;                  case 4: return _arg4;                  default: throw new ArgumentOutOfRangeException(nameof(index));              }
Magic Number,System.Linq.Expressions,MethodCallExpression5,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MethodCallExpression.cs,GetArgument,The following statement contains a magic number: switch (index)              {                  case 0: return ExpressionUtils.ReturnObject<Expression>(_arg0);                  case 1: return _arg1;                  case 2: return _arg2;                  case 3: return _arg3;                  case 4: return _arg4;                  default: throw new ArgumentOutOfRangeException(nameof(index));              }
Magic Number,System.Linq.Expressions,MethodCallExpression5,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MethodCallExpression.cs,GetArgument,The following statement contains a magic number: switch (index)              {                  case 0: return ExpressionUtils.ReturnObject<Expression>(_arg0);                  case 1: return _arg1;                  case 2: return _arg2;                  case 3: return _arg3;                  case 4: return _arg4;                  default: throw new ArgumentOutOfRangeException(nameof(index));              }
Magic Number,System.Linq.Expressions,MethodCallExpression5,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MethodCallExpression.cs,Rewrite,The following statement contains a magic number: Debug.Assert(args == null || args.Count == 5);
Magic Number,System.Linq.Expressions,MethodCallExpression5,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MethodCallExpression.cs,Rewrite,The following statement contains a magic number: return args != null ? Call(Method' args[0]' args[1]' args[2]' args[3]' args[4]) : Call(Method' ExpressionUtils.ReturnObject<Expression>(_arg0)' _arg1' _arg2' _arg3' _arg4);
Magic Number,System.Linq.Expressions,MethodCallExpression5,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MethodCallExpression.cs,Rewrite,The following statement contains a magic number: return args != null ? Call(Method' args[0]' args[1]' args[2]' args[3]' args[4]) : Call(Method' ExpressionUtils.ReturnObject<Expression>(_arg0)' _arg1' _arg2' _arg3' _arg4);
Magic Number,System.Linq.Expressions,MethodCallExpression5,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MethodCallExpression.cs,Rewrite,The following statement contains a magic number: return args != null ? Call(Method' args[0]' args[1]' args[2]' args[3]' args[4]) : Call(Method' ExpressionUtils.ReturnObject<Expression>(_arg0)' _arg1' _arg2' _arg3' _arg4);
Magic Number,System.Linq.Expressions,MethodCallExpression5,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\MethodCallExpression.cs,SameArguments,The following statement contains a magic number: arguments?.Count != 5
Magic Number,System.Linq.Expressions,UnaryExpression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\UnaryExpression.cs,ReduceIndex,The following statement contains a magic number: var block = new Expression[count + (prefix ? 2 : 4)];
Magic Number,System.Linq.Expressions,UnaryExpression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\UnaryExpression.cs,ReduceIndex,The following statement contains a magic number: var block = new Expression[count + (prefix ? 2 : 4)];
Magic Number,System.Linq.Expressions,UnaryExpression,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\UnaryExpression.cs,ReduceIndex,The following statement contains a magic number: var temps = new ParameterExpression[count + (prefix ? 1 : 2)];
Magic Number,System.Linq.Expressions,Utils,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Utils.cs,Constant,The following statement contains a magic number: switch (value)              {                  case -1: return _m1;                  case 0: return _0;                  case 1: return _1;                  case 2: return _2;                  case 3: return _3;                  default: return Expression.Constant(value);              }
Magic Number,System.Linq.Expressions,Utils,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Utils.cs,Constant,The following statement contains a magic number: switch (value)              {                  case -1: return _m1;                  case 0: return _0;                  case 1: return _1;                  case 2: return _2;                  case 3: return _3;                  default: return Expression.Constant(value);              }
Magic Number,System.Linq.Expressions.Compiler,BoundConstants,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\BoundConstants.cs,ShouldCache,The following statement contains a magic number: return refCount > 2;
Magic Number,System.Linq.Expressions.Compiler,CompilerScope,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\CompilerScope.cs,EmitVariableAccess,The following statement contains a magic number: var index = (parents << 32) | (uint)locals.Indexes[variable];
Magic Number,System.Linq.Expressions.Compiler,CompilerScope,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\CompilerScope.cs,ShouldCache,The following statement contains a magic number: return refCount > 2 && !_locals.ContainsKey(v);
Magic Number,System.Linq.Expressions.Compiler,ILGen,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitLoadArg,The following statement contains a magic number: switch (index)              {                  case 0:                      il.Emit(OpCodes.Ldarg_0);                      break;                    case 1:                      il.Emit(OpCodes.Ldarg_1);                      break;                    case 2:                      il.Emit(OpCodes.Ldarg_2);                      break;                    case 3:                      il.Emit(OpCodes.Ldarg_3);                      break;                    default:                      if (index <= byte.MaxValue)                      {                          il.Emit(OpCodes.Ldarg_S' (byte)index);                      }                      else                      {                          // cast to short' result is correct ushort.                          il.Emit(OpCodes.Ldarg' (short)index);                      }                        break;              }
Magic Number,System.Linq.Expressions.Compiler,ILGen,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitLoadArg,The following statement contains a magic number: switch (index)              {                  case 0:                      il.Emit(OpCodes.Ldarg_0);                      break;                    case 1:                      il.Emit(OpCodes.Ldarg_1);                      break;                    case 2:                      il.Emit(OpCodes.Ldarg_2);                      break;                    case 3:                      il.Emit(OpCodes.Ldarg_3);                      break;                    default:                      if (index <= byte.MaxValue)                      {                          il.Emit(OpCodes.Ldarg_S' (byte)index);                      }                      else                      {                          // cast to short' result is correct ushort.                          il.Emit(OpCodes.Ldarg' (short)index);                      }                        break;              }
Magic Number,System.Linq.Expressions.Compiler,ILGen,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitPrimitive,The following statement contains a magic number: switch (value)              {                  case -1:                      c = OpCodes.Ldc_I4_M1;                      break;                    case 0:                      c = OpCodes.Ldc_I4_0;                      break;                    case 1:                      c = OpCodes.Ldc_I4_1;                      break;                    case 2:                      c = OpCodes.Ldc_I4_2;                      break;                    case 3:                      c = OpCodes.Ldc_I4_3;                      break;                    case 4:                      c = OpCodes.Ldc_I4_4;                      break;                    case 5:                      c = OpCodes.Ldc_I4_5;                      break;                    case 6:                      c = OpCodes.Ldc_I4_6;                      break;                    case 7:                      c = OpCodes.Ldc_I4_7;                      break;                    case 8:                      c = OpCodes.Ldc_I4_8;                      break;                    default:                      if (value >= sbyte.MinValue && value <= sbyte.MaxValue)                      {                          il.Emit(OpCodes.Ldc_I4_S' (sbyte)value);                      }                      else                      {                          il.Emit(OpCodes.Ldc_I4' value);                      }                        return;              }
Magic Number,System.Linq.Expressions.Compiler,ILGen,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitPrimitive,The following statement contains a magic number: switch (value)              {                  case -1:                      c = OpCodes.Ldc_I4_M1;                      break;                    case 0:                      c = OpCodes.Ldc_I4_0;                      break;                    case 1:                      c = OpCodes.Ldc_I4_1;                      break;                    case 2:                      c = OpCodes.Ldc_I4_2;                      break;                    case 3:                      c = OpCodes.Ldc_I4_3;                      break;                    case 4:                      c = OpCodes.Ldc_I4_4;                      break;                    case 5:                      c = OpCodes.Ldc_I4_5;                      break;                    case 6:                      c = OpCodes.Ldc_I4_6;                      break;                    case 7:                      c = OpCodes.Ldc_I4_7;                      break;                    case 8:                      c = OpCodes.Ldc_I4_8;                      break;                    default:                      if (value >= sbyte.MinValue && value <= sbyte.MaxValue)                      {                          il.Emit(OpCodes.Ldc_I4_S' (sbyte)value);                      }                      else                      {                          il.Emit(OpCodes.Ldc_I4' value);                      }                        return;              }
Magic Number,System.Linq.Expressions.Compiler,ILGen,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitPrimitive,The following statement contains a magic number: switch (value)              {                  case -1:                      c = OpCodes.Ldc_I4_M1;                      break;                    case 0:                      c = OpCodes.Ldc_I4_0;                      break;                    case 1:                      c = OpCodes.Ldc_I4_1;                      break;                    case 2:                      c = OpCodes.Ldc_I4_2;                      break;                    case 3:                      c = OpCodes.Ldc_I4_3;                      break;                    case 4:                      c = OpCodes.Ldc_I4_4;                      break;                    case 5:                      c = OpCodes.Ldc_I4_5;                      break;                    case 6:                      c = OpCodes.Ldc_I4_6;                      break;                    case 7:                      c = OpCodes.Ldc_I4_7;                      break;                    case 8:                      c = OpCodes.Ldc_I4_8;                      break;                    default:                      if (value >= sbyte.MinValue && value <= sbyte.MaxValue)                      {                          il.Emit(OpCodes.Ldc_I4_S' (sbyte)value);                      }                      else                      {                          il.Emit(OpCodes.Ldc_I4' value);                      }                        return;              }
Magic Number,System.Linq.Expressions.Compiler,ILGen,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitPrimitive,The following statement contains a magic number: switch (value)              {                  case -1:                      c = OpCodes.Ldc_I4_M1;                      break;                    case 0:                      c = OpCodes.Ldc_I4_0;                      break;                    case 1:                      c = OpCodes.Ldc_I4_1;                      break;                    case 2:                      c = OpCodes.Ldc_I4_2;                      break;                    case 3:                      c = OpCodes.Ldc_I4_3;                      break;                    case 4:                      c = OpCodes.Ldc_I4_4;                      break;                    case 5:                      c = OpCodes.Ldc_I4_5;                      break;                    case 6:                      c = OpCodes.Ldc_I4_6;                      break;                    case 7:                      c = OpCodes.Ldc_I4_7;                      break;                    case 8:                      c = OpCodes.Ldc_I4_8;                      break;                    default:                      if (value >= sbyte.MinValue && value <= sbyte.MaxValue)                      {                          il.Emit(OpCodes.Ldc_I4_S' (sbyte)value);                      }                      else                      {                          il.Emit(OpCodes.Ldc_I4' value);                      }                        return;              }
Magic Number,System.Linq.Expressions.Compiler,ILGen,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitPrimitive,The following statement contains a magic number: switch (value)              {                  case -1:                      c = OpCodes.Ldc_I4_M1;                      break;                    case 0:                      c = OpCodes.Ldc_I4_0;                      break;                    case 1:                      c = OpCodes.Ldc_I4_1;                      break;                    case 2:                      c = OpCodes.Ldc_I4_2;                      break;                    case 3:                      c = OpCodes.Ldc_I4_3;                      break;                    case 4:                      c = OpCodes.Ldc_I4_4;                      break;                    case 5:                      c = OpCodes.Ldc_I4_5;                      break;                    case 6:                      c = OpCodes.Ldc_I4_6;                      break;                    case 7:                      c = OpCodes.Ldc_I4_7;                      break;                    case 8:                      c = OpCodes.Ldc_I4_8;                      break;                    default:                      if (value >= sbyte.MinValue && value <= sbyte.MaxValue)                      {                          il.Emit(OpCodes.Ldc_I4_S' (sbyte)value);                      }                      else                      {                          il.Emit(OpCodes.Ldc_I4' value);                      }                        return;              }
Magic Number,System.Linq.Expressions.Compiler,ILGen,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitPrimitive,The following statement contains a magic number: switch (value)              {                  case -1:                      c = OpCodes.Ldc_I4_M1;                      break;                    case 0:                      c = OpCodes.Ldc_I4_0;                      break;                    case 1:                      c = OpCodes.Ldc_I4_1;                      break;                    case 2:                      c = OpCodes.Ldc_I4_2;                      break;                    case 3:                      c = OpCodes.Ldc_I4_3;                      break;                    case 4:                      c = OpCodes.Ldc_I4_4;                      break;                    case 5:                      c = OpCodes.Ldc_I4_5;                      break;                    case 6:                      c = OpCodes.Ldc_I4_6;                      break;                    case 7:                      c = OpCodes.Ldc_I4_7;                      break;                    case 8:                      c = OpCodes.Ldc_I4_8;                      break;                    default:                      if (value >= sbyte.MinValue && value <= sbyte.MaxValue)                      {                          il.Emit(OpCodes.Ldc_I4_S' (sbyte)value);                      }                      else                      {                          il.Emit(OpCodes.Ldc_I4' value);                      }                        return;              }
Magic Number,System.Linq.Expressions.Compiler,ILGen,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitPrimitive,The following statement contains a magic number: switch (value)              {                  case -1:                      c = OpCodes.Ldc_I4_M1;                      break;                    case 0:                      c = OpCodes.Ldc_I4_0;                      break;                    case 1:                      c = OpCodes.Ldc_I4_1;                      break;                    case 2:                      c = OpCodes.Ldc_I4_2;                      break;                    case 3:                      c = OpCodes.Ldc_I4_3;                      break;                    case 4:                      c = OpCodes.Ldc_I4_4;                      break;                    case 5:                      c = OpCodes.Ldc_I4_5;                      break;                    case 6:                      c = OpCodes.Ldc_I4_6;                      break;                    case 7:                      c = OpCodes.Ldc_I4_7;                      break;                    case 8:                      c = OpCodes.Ldc_I4_8;                      break;                    default:                      if (value >= sbyte.MinValue && value <= sbyte.MaxValue)                      {                          il.Emit(OpCodes.Ldc_I4_S' (sbyte)value);                      }                      else                      {                          il.Emit(OpCodes.Ldc_I4' value);                      }                        return;              }
Magic Number,System.Linq.Expressions.Compiler,ILGen,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitDecimal,The following statement contains a magic number: var scale = (bits[3] & int.MaxValue) >> 16;
Magic Number,System.Linq.Expressions.Compiler,ILGen,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitDecimal,The following statement contains a magic number: var scale = (bits[3] & int.MaxValue) >> 16;
Magic Number,System.Linq.Expressions.Compiler,ILGen,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitDecimal,The following statement contains a magic number: il.EmitPrimitive(bits[2]);
Magic Number,System.Linq.Expressions.Compiler,ILGen,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\ILGen.cs,EmitDecimal,The following statement contains a magic number: il.EmitPrimitive((bits[3] & 0x80000000) != 0);
Magic Number,System.Linq.Expressions.Compiler,LambdaCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.cs,LambdaCompiler,The following statement contains a magic number: var startIndex = hasClosureArgument ? 2 : 1;
Magic Number,System.Linq.Expressions.Compiler,LambdaCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.cs,FitsInBucket,The following statement contains a magic number: return (buckets.Count + count) * 2 > jumpTableSlots;
Magic Number,System.Linq.Expressions.Compiler,LambdaCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.cs,MergeBuckets,The following statement contains a magic number: var first = buckets[buckets.Count - 2];
Magic Number,System.Linq.Expressions.Compiler,LambdaCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.cs,EmitSwitchBuckets,The following statement contains a magic number: var mid = (int)(((long)first + last + 1) / 2);
Magic Number,System.Linq.Expressions.Compiler,LambdaCompiler,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\LambdaCompiler.Address.cs,TryEmitHashtableSwitch,The following statement contains a magic number: tests < 7
Magic Number,System.Linq.Expressions.Compiler,StackSpiller,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\StackSpiller.Bindings.cs,RewriteBinaryExpression,The following statement contains a magic number: var cr = new NullAwareChildRewriter(this' stack' 3);
Magic Number,System.Linq.Expressions.Compiler,StackSpiller,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\StackSpiller.Bindings.cs,RewriteBinaryExpression,The following statement contains a magic number: return cr.Finish              (                  cr.Rewrite                      ? BinaryExpression.Create                      (                          node.NodeType'                          cr[0]!'                          cr[1]!'                          node.Type'                          node.Method'                          (LambdaExpression)cr[2]!                      )                      : expr              );
Magic Number,System.Linq.Expressions.Compiler,StackSpiller,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\StackSpiller.Bindings.cs,RewriteIndexAssignment,The following statement contains a magic number: var cr = new NullAwareChildRewriter(this' stack' 2 + index.ArgumentCount);
Magic Number,System.Linq.Expressions.Compiler,StackSpiller,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\StackSpiller.Bindings.cs,RewriteIndexAssignment,The following statement contains a magic number: node = new AssignBinaryExpression                  (                      new IndexExpression                      (                          cr[0]' // Object                          index.Indexer'                          cr[1' -2]! // arguments                      )'                      cr[-1]! // value                  );
Magic Number,System.Linq.Expressions.Compiler,StackSpiller,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\StackSpiller.Bindings.cs,RewriteListInitExpression,The following statement contains a magic number: switch (action)              {                  case RewriteAction.None:                      break;                    case RewriteAction.Copy:                      var newInitializer = new ElementInit[count];                      for (var i = 0; i < count; i++)                      {                          var cr = cloneCrs[i];                          if (cr.Action == RewriteAction.None)                          {                              newInitializer[i] = initializers[i];                          }                          else                          {                              newInitializer[i] = new ElementInit(initializers[i].AddMethod' cr[0' -1]);                          }                      }                        expr = new ListInitExpression((NewExpression)rewrittenNew' ReadOnlyCollectionEx.Create(newInitializer));                      break;                    case RewriteAction.SpillStack:                      var isRefNew = IsRefInstance(node.NewExpression);                        var comma = new ArrayBuilder<Expression>(count + 2 + (isRefNew ? 1 : 0));                      var tempNew = MakeTemp(rewrittenNew.Type);                      comma.UncheckedAdd(new AssignBinaryExpression(tempNew' rewrittenNew));                        var refTempNew = tempNew;                      if (isRefNew)                      {                          refTempNew = MakeTemp(tempNew.Type.MakeByRefType());                          comma.UncheckedAdd(new ByRefAssignBinaryExpression(refTempNew' tempNew));                      }                        for (var i = 0; i < count; i++)                      {                          var cr = cloneCrs[i];                          var add = cr.Finish(new InstanceMethodCallExpressionN(initializers[i].AddMethod' refTempNew' cr[0' -1]));                          comma.UncheckedAdd(add.Node);                      }                        comma.UncheckedAdd(tempNew);                        expr = MakeBlock(comma);                      break;                    default:                      throw ContractUtils.Unreachable;              }
Magic Number,System.Linq.Expressions.Compiler,StackSpiller,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\StackSpiller.Bindings.cs,RewriteMemberAssignment,The following statement contains a magic number: var cr = new NullAwareChildRewriter(this' stack' 2);
Magic Number,System.Linq.Expressions.Compiler,StackSpiller,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\StackSpiller.Bindings.cs,RewriteMemberInitExpression,The following statement contains a magic number: switch (action)              {                  case RewriteAction.None:                      break;                    case RewriteAction.Copy:                      var newBindings = new MemberBinding[count];                      for (var i = 0; i < count; i++)                      {                          newBindings[i] = bindingRewriters[i].AsBinding();                      }                        expr = new MemberInitExpression((NewExpression)rewrittenNew' newBindings);                      break;                    case RewriteAction.SpillStack:                      var isRefNew = IsRefInstance(node.NewExpression);                        var comma = new ArrayBuilder<Expression>(count + 2 + (isRefNew ? 1 : 0));                        var tempNew = MakeTemp(rewrittenNew.Type);                      comma.UncheckedAdd(new AssignBinaryExpression(tempNew' rewrittenNew));                        var refTempNew = tempNew;                      if (isRefNew)                      {                          refTempNew = MakeTemp(tempNew.Type.MakeByRefType());                          comma.UncheckedAdd(new ByRefAssignBinaryExpression(refTempNew' tempNew));                      }                        for (var i = 0; i < count; i++)                      {                          var cr = bindingRewriters[i];                          var initExpr = cr.AsExpression(refTempNew);                          comma.UncheckedAdd(initExpr);                      }                        comma.UncheckedAdd(tempNew);                        expr = MakeBlock(comma);                      break;                    default:                      throw ContractUtils.Unreachable;              }
Magic Number,System.Linq.Expressions.Compiler,ListBindingRewriter,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\StackSpiller.Bindings.cs,AsExpression,The following statement contains a magic number: var block = new Expression[count + 2];
Magic Number,System.Linq.Expressions.Compiler,MemberMemberBindingRewriter,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Compiler\StackSpiller.Bindings.cs,AsExpression,The following statement contains a magic number: var block = new Expression[count + 2];
Magic Number,System.Linq.Expressions.Interpreter,AddDouble,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\AddInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,AddDouble,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\AddInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)((double)left + (double)right);
Magic Number,System.Linq.Expressions.Interpreter,AddInt16,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\AddInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,AddInt16,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\AddInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)unchecked((short)((short)left + (short)right));
Magic Number,System.Linq.Expressions.Interpreter,AddInt32,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\AddInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,AddInt32,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\AddInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : ScriptingRuntimeHelpers.Int32ToObject(unchecked((int)left + (int)right));
Magic Number,System.Linq.Expressions.Interpreter,AddInt64,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\AddInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,AddInt64,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\AddInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)unchecked((long)left + (long)right);
Magic Number,System.Linq.Expressions.Interpreter,AddSingle,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\AddInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,AddSingle,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\AddInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)((float)left + (float)right);
Magic Number,System.Linq.Expressions.Interpreter,AddUInt16,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\AddInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,AddUInt16,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\AddInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)unchecked((ushort)((ushort)left + (ushort)right));
Magic Number,System.Linq.Expressions.Interpreter,AddUInt32,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\AddInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,AddUInt32,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\AddInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)unchecked((uint)left + (uint)right);
Magic Number,System.Linq.Expressions.Interpreter,AddUInt64,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\AddInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,AddUInt64,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\AddInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)unchecked((ulong)left + (ulong)right);
Magic Number,System.Linq.Expressions.Interpreter,AddOvfInt16,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\AddInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,AddOvfInt16,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\AddInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)checked((short)((short)left + (short)right));
Magic Number,System.Linq.Expressions.Interpreter,AddOvfInt32,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\AddInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,AddOvfInt32,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\AddInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : ScriptingRuntimeHelpers.Int32ToObject(checked((int)left + (int)right));
Magic Number,System.Linq.Expressions.Interpreter,AddOvfInt64,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\AddInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,AddOvfInt64,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\AddInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)checked((long)left + (long)right);
Magic Number,System.Linq.Expressions.Interpreter,AddOvfUInt16,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\AddInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,AddOvfUInt16,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\AddInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)checked((ushort)((ushort)left + (ushort)right));
Magic Number,System.Linq.Expressions.Interpreter,AddOvfUInt32,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\AddInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,AddOvfUInt32,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\AddInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)checked((uint)left + (uint)right);
Magic Number,System.Linq.Expressions.Interpreter,AddOvfUInt64,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\AddInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,AddOvfUInt64,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\AddInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)checked((ulong)left + (ulong)right);
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\CallInstruction.cs,GetArrayAccessor,The following statement contains a magic number: switch (arrayType?.GetArrayRank())              {                  case 1:                      alternativeMethod = isGetter ? arrayType.GetMethod("GetValue"' new[] { typeof(int) }) : typeof(CallInstruction).GetMethod(nameof(ArrayItemSetter1));                      break;                    case 2:                      alternativeMethod = isGetter ? arrayType.GetMethod("GetValue"' new[] { typeof(int)' typeof(int) }) : typeof(CallInstruction).GetMethod(nameof(ArrayItemSetter2));                      break;                    case 3:                      alternativeMethod = isGetter ? arrayType.GetMethod("GetValue"' new[] { typeof(int)' typeof(int)' typeof(int) }) : typeof(CallInstruction).GetMethod(nameof(ArrayItemSetter3));                      break;                    default:                      break;              }
Magic Number,System.Linq.Expressions.Interpreter,CallInstruction,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\CallInstruction.cs,GetArrayAccessor,The following statement contains a magic number: switch (arrayType?.GetArrayRank())              {                  case 1:                      alternativeMethod = isGetter ? arrayType.GetMethod("GetValue"' new[] { typeof(int) }) : typeof(CallInstruction).GetMethod(nameof(ArrayItemSetter1));                      break;                    case 2:                      alternativeMethod = isGetter ? arrayType.GetMethod("GetValue"' new[] { typeof(int)' typeof(int) }) : typeof(CallInstruction).GetMethod(nameof(ArrayItemSetter2));                      break;                    case 3:                      alternativeMethod = isGetter ? arrayType.GetMethod("GetValue"' new[] { typeof(int)' typeof(int)' typeof(int) }) : typeof(CallInstruction).GetMethod(nameof(ArrayItemSetter3));                      break;                    default:                      break;              }
Magic Number,System.Linq.Expressions.Interpreter,GotoInstruction,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\ControlFlowInstructions.cs,Create,The following statement contains a magic number: var index = (_variants * labelIndex) | (labelTargetGetsValue ? 4 : 0) | (hasResult ? 2 : 0) | (hasValue ? 1 : 0);
Magic Number,System.Linq.Expressions.Interpreter,GotoInstruction,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\ControlFlowInstructions.cs,Create,The following statement contains a magic number: var index = (_variants * labelIndex) | (labelTargetGetsValue ? 4 : 0) | (hasResult ? 2 : 0) | (hasValue ? 1 : 0);
Magic Number,System.Linq.Expressions.Interpreter,LeaveExceptionHandlerInstruction,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\ControlFlowInstructions.cs,Create,The following statement contains a magic number: var index = (2 * labelIndex) | (hasValue ? 1 : 0);
Magic Number,System.Linq.Expressions.Interpreter,DivDouble,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\DivInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,DivDouble,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\DivInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)((double)left / (double)right);
Magic Number,System.Linq.Expressions.Interpreter,DivInt16,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\DivInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,DivInt16,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\DivInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)unchecked((short)((short)left / (short)right));
Magic Number,System.Linq.Expressions.Interpreter,DivInt32,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\DivInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,DivInt32,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\DivInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : ScriptingRuntimeHelpers.Int32ToObject((int)left / (int)right);
Magic Number,System.Linq.Expressions.Interpreter,DivInt64,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\DivInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,DivInt64,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\DivInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)((long)left / (long)right);
Magic Number,System.Linq.Expressions.Interpreter,DivSingle,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\DivInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,DivSingle,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\DivInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)((float)left / (float)right);
Magic Number,System.Linq.Expressions.Interpreter,DivUInt16,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\DivInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,DivUInt16,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\DivInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)unchecked((ushort)((ushort)left / (ushort)right));
Magic Number,System.Linq.Expressions.Interpreter,DivUInt32,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\DivInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,DivUInt32,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\DivInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)((uint)left / (uint)right);
Magic Number,System.Linq.Expressions.Interpreter,DivUInt64,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\DivInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,DivUInt64,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\DivInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)((ulong)left / (ulong)right);
Magic Number,System.Linq.Expressions.Interpreter,LabelScopeChangeInfo,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\LabelScopeChangeInfo.cs,GetHashCode,The following statement contains a magic number: var hashCode = 1209964386;
Magic Number,System.Linq.Expressions.Interpreter,LabelScopeChangeInfo,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\LabelScopeChangeInfo.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * -1521134295) + EqualityComparer<LabelScopeInfo>.Default.GetHashCode(Parent);
Magic Number,System.Linq.Expressions.Interpreter,LabelScopeChangeInfo,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\LabelScopeChangeInfo.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * -1521134295) + Kind.GetHashCode();
Magic Number,System.Linq.Expressions.Interpreter,LabelScopeChangeInfo,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\LabelScopeChangeInfo.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * -1521134295) + EqualityComparer<IList<Expression>?>.Default.GetHashCode(Nodes);
Magic Number,System.Linq.Expressions.Interpreter,DebugViewPrinter,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\LightLambda.cs,Dedent,The following statement contains a magic number: _indent = new string(' '' _indent.Length - 2);
Magic Number,System.Linq.Expressions.Interpreter,DebugViewPrinter,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\LightLambda.cs,Indent,The following statement contains a magic number: _indent = new string(' '' _indent.Length + 2);
Magic Number,System.Linq.Expressions.Interpreter,ModuloDouble,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\ModuloInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,ModuloDouble,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\ModuloInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)((double)left % (double)right);
Magic Number,System.Linq.Expressions.Interpreter,ModuloInt16,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\ModuloInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,ModuloInt16,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\ModuloInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)unchecked((short)((short)left % (short)right));
Magic Number,System.Linq.Expressions.Interpreter,ModuloInt32,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\ModuloInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,ModuloInt32,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\ModuloInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : ScriptingRuntimeHelpers.Int32ToObject((int)left % (int)right);
Magic Number,System.Linq.Expressions.Interpreter,ModuloInt64,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\ModuloInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,ModuloInt64,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\ModuloInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)((long)left % (long)right);
Magic Number,System.Linq.Expressions.Interpreter,ModuloSingle,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\ModuloInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,ModuloSingle,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\ModuloInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)((float)left % (float)right);
Magic Number,System.Linq.Expressions.Interpreter,ModuloUInt16,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\ModuloInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,ModuloUInt16,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\ModuloInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)unchecked((ushort)((ushort)left % (ushort)right));
Magic Number,System.Linq.Expressions.Interpreter,ModuloUInt32,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\ModuloInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,ModuloUInt32,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\ModuloInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)((uint)left % (uint)right);
Magic Number,System.Linq.Expressions.Interpreter,ModuloUInt64,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\ModuloInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,ModuloUInt64,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\ModuloInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)((ulong)left % (ulong)right);
Magic Number,System.Linq.Expressions.Interpreter,MulDouble,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\MulInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,MulDouble,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\MulInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)((double)left * (double)right);
Magic Number,System.Linq.Expressions.Interpreter,MulInt16,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\MulInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,MulInt16,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\MulInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)unchecked((short)((short)left * (short)right));
Magic Number,System.Linq.Expressions.Interpreter,MulInt32,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\MulInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,MulInt32,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\MulInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : ScriptingRuntimeHelpers.Int32ToObject(unchecked((int)left * (int)right));
Magic Number,System.Linq.Expressions.Interpreter,MulInt64,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\MulInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,MulInt64,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\MulInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)unchecked((long)left * (long)right);
Magic Number,System.Linq.Expressions.Interpreter,MulSingle,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\MulInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,MulSingle,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\MulInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)((float)left * (float)right);
Magic Number,System.Linq.Expressions.Interpreter,MulUInt16,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\MulInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,MulUInt16,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\MulInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)unchecked((ushort)((ushort)left * (ushort)right));
Magic Number,System.Linq.Expressions.Interpreter,MulUInt32,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\MulInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,MulUInt32,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\MulInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)unchecked((uint)left * (uint)right);
Magic Number,System.Linq.Expressions.Interpreter,MulUInt64,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\MulInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,MulUInt64,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\MulInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)unchecked((ulong)left * (ulong)right);
Magic Number,System.Linq.Expressions.Interpreter,MulOvfInt16,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\MulInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,MulOvfInt16,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\MulInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)checked((short)((short)left * (short)right));
Magic Number,System.Linq.Expressions.Interpreter,MulOvfInt32,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\MulInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,MulOvfInt32,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\MulInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : ScriptingRuntimeHelpers.Int32ToObject(checked((int)left * (int)right));
Magic Number,System.Linq.Expressions.Interpreter,MulOvfInt64,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\MulInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,MulOvfInt64,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\MulInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)checked((long)left * (long)right);
Magic Number,System.Linq.Expressions.Interpreter,MulOvfUInt16,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\MulInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,MulOvfUInt16,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\MulInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)checked((ushort)((ushort)left * (ushort)right));
Magic Number,System.Linq.Expressions.Interpreter,MulOvfUInt32,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\MulInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,MulOvfUInt32,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\MulInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)checked((uint)left * (uint)right);
Magic Number,System.Linq.Expressions.Interpreter,MulOvfUInt64,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\MulInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,MulOvfUInt64,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\MulInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)checked((ulong)left * (ulong)right);
Magic Number,System.Linq.Expressions.Interpreter,SubDouble,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\SubInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,SubDouble,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\SubInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)((double)left - (double)right);
Magic Number,System.Linq.Expressions.Interpreter,SubInt16,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\SubInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,SubInt16,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\SubInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)unchecked((short)((short)left - (short)right));
Magic Number,System.Linq.Expressions.Interpreter,SubInt32,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\SubInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,SubInt32,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\SubInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : ScriptingRuntimeHelpers.Int32ToObject(unchecked((int)left - (int)right));
Magic Number,System.Linq.Expressions.Interpreter,SubInt64,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\SubInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,SubInt64,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\SubInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)unchecked((long)left - (long)right);
Magic Number,System.Linq.Expressions.Interpreter,SubSingle,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\SubInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,SubSingle,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\SubInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)((float)left - (float)right);
Magic Number,System.Linq.Expressions.Interpreter,SubUInt16,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\SubInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,SubUInt16,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\SubInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)unchecked((ushort)((ushort)left - (ushort)right));
Magic Number,System.Linq.Expressions.Interpreter,SubUInt32,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\SubInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,SubUInt32,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\SubInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)unchecked((uint)left - (uint)right);
Magic Number,System.Linq.Expressions.Interpreter,SubUInt64,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\SubInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,SubUInt64,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\SubInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)unchecked((ulong)left - (ulong)right);
Magic Number,System.Linq.Expressions.Interpreter,SubOvfInt16,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\SubInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,SubOvfInt16,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\SubInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)checked((short)((short)left - (short)right));
Magic Number,System.Linq.Expressions.Interpreter,SubOvfInt32,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\SubInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,SubOvfInt32,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\SubInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : ScriptingRuntimeHelpers.Int32ToObject(checked((int)left - (int)right));
Magic Number,System.Linq.Expressions.Interpreter,SubOvfInt64,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\SubInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,SubOvfInt64,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\SubInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)checked((long)left - (long)right);
Magic Number,System.Linq.Expressions.Interpreter,SubOvfUInt16,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\SubInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,SubOvfUInt16,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\SubInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)checked((ushort)((ushort)left - (ushort)right));
Magic Number,System.Linq.Expressions.Interpreter,SubOvfUInt32,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\SubInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,SubOvfUInt32,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\SubInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)checked((uint)left - (uint)right);
Magic Number,System.Linq.Expressions.Interpreter,SubOvfUInt64,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\SubInstruction.cs,Run,The following statement contains a magic number: var left = stack[index - 2];
Magic Number,System.Linq.Expressions.Interpreter,SubOvfUInt64,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\SubInstruction.cs,Run,The following statement contains a magic number: stack[index - 2] = right == null ? null : (object)checked((ulong)left - (ulong)right);
Magic Number,System.Linq.Expressions.Interpreter,ScriptingRuntimeHelpers,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\Utilities.cs,Int32ToObject,The following statement contains a magic number: switch (i)              {                  case -1:                      return Utils.BoxedIntM1;                    case 0:                      return Utils.BoxedInt0;                    case 1:                      return Utils.BoxedInt1;                    case 2:                      return Utils.BoxedInt2;                    case 3:                      return Utils.BoxedInt3;                    default:                      return i;              }
Magic Number,System.Linq.Expressions.Interpreter,ScriptingRuntimeHelpers,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Linq\Expressions\Interpreter\Utilities.cs,Int32ToObject,The following statement contains a magic number: switch (i)              {                  case -1:                      return Utils.BoxedIntM1;                    case 0:                      return Utils.BoxedInt0;                    case 1:                      return Utils.BoxedInt1;                    case 2:                      return Utils.BoxedInt2;                    case 3:                      return Utils.BoxedInt3;                    default:                      return i;              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: InternalBits = new[] { (uint)num' (uint)(num >> 32) };
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: InternalBits = new[] { (uint)value' (uint)(value >> 32) };
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: var size = 3;
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: var isNegative = valueLength > 0 && (value[valueLength - 1] & 128) == 128;
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: var isNegative = valueLength > 0 && (value[valueLength - 1] & 128) == 128;
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: var unalignedBytes = valueLength % 4;
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: var dwordCount = (valueLength / 4) + (unalignedBytes == 0 ? 0 : 1);
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: var byteIndex = 3;
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: current <<= 8;
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: byteInDword < 4
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: byteIndex += 8;
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: current <<= 8;
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: valueLength > 4
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,Log,The following statement contains a magic number: var d = 0.5;
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,Log,The following statement contains a magic number: var bitlen = ((length - 1) * 32) + topBits;
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,Log,The following statement contains a magic number: var currentBitMask = (uint)(1 << ((topBits - 1) & 31));
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,Log,The following statement contains a magic number: d *= 0.5;
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,Log,The following statement contains a magic number: return (Math.Log(c) + (0.69314718055994529D * bitlen)) / Math.Log(baseValue);
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,Log10,The following statement contains a magic number: return Log(value' 10);
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,CompareTo,The following statement contains a magic number: length > 2
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,CompareTo,The following statement contains a magic number: return length > 2 ? 1 : ULong(length' InternalBits).CompareTo(other);
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,Equals,The following statement contains a magic number: length > 2
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,Equals,The following statement contains a magic number: length > 2
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: switch (InternalBits)              {                  case null when InternalSign == 0:                      return new byte[1];                    case null:                      internalBits = new[] { unchecked((uint)InternalSign) };                      highByte = InternalSign < 0 ? (byte)0xff : (byte)0x00;                      break;                    default:                      {                          if (InternalSign != -1)                          {                              internalBits = InternalBits;                              highByte = 0;                          }                          else                          {                              internalBits = (uint[])InternalBits.Clone();                              NumericsHelpers.DangerousMakeTwosComplement(internalBits);                              highByte = 255;                          }                            break;                      }              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: var bytes = new byte[checked(4 * internalBits.Length)];
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: bytes[index] = (byte)(current & 255);
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: current >>= 8;
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: j < 4
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: var extra = (bytes[length] & 128) != (highByte & 128);
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,ToByteArray,The following statement contains a magic number: var extra = (bytes[length] & 128) != (highByte & 128);
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,ModPowInner32,The following statement contains a magic number: index < 32
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,SetBitsFromDouble,The following statement contains a magic number: valueExp <= -64
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,SetBitsFromDouble,The following statement contains a magic number: var tmp = valueMan >> (-valueExp & 63);
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,SetBitsFromDouble,The following statement contains a magic number: bits = new[] { (uint)tmp' (uint)(tmp >> 32) };
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,FormatBigInteger,The following statement contains a magic number: switch (fmt)              {                  case 'x':                  case 'X':                      return FormatBigIntegerToHexString(value' fmt' digits' info);                    case 'e':                  case 'E':                      {                          var precision = digits != -1 ? digits : 6;                            if (value.InternalBits == null)                          {                              return value.InternalSign.ToString(format' info);                          }                            var scale = (int)Math.Floor(Log10(value));                          // ---                          if (scale > precision + 10)                          {                              do                              {                                  value /= 1000000000;                              } while (Log10(value) > precision + 10);                          }                            while (Log10(value) > precision + 2)                          {                              value /= 10;                          }                            if (Log10(value) > precision + 1)                          {                              var round = value % 10 >= 5;                              value = (value / 10) + (round ? One : Zero);                          }                            ReverseStringBuilder builder;                            if (value.InternalBits == null)                          {                              builder = new ReverseStringBuilder(10);                              builder.Prepend($"{value.InternalSign:D}");                          }                          else                          {                              builder = CreateBuilder(value' info' false' 0);                          }                            // ---                          var decimalSeparator = info.NumberDecimalSeparator;                            var result = new StringBuilder(builder.Length + 6);                            var extra = 0;                            if (precision >= builder.Length)                          {                              extra = precision - (builder.Length - 1);                              precision = builder.Length - 1;                          }                            result.Append(builder.ToString(builder.Length' 1));                          result.Append(decimalSeparator);                          result.Append(builder.ToString(builder.Length - 1' precision));                          result.Append(new string('0'' extra));                          result.Append(fmt);                          result.Append(info.PositiveSign);                          if (scale < 10)                          {                              result.Append("00");                          }                          else if (scale < 100)                          {                              result.Append('0');                          }                            result.Append(scale);                            return result.ToString();                      }                  default:                      {                          var decimalFmt = fmt == 'g' || fmt == 'G' || fmt == 'd' || fmt == 'D' || fmt == 'r' || fmt == 'R';                          if (value.InternalBits == null)                          {                              if (fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R')                              {                                  format = digits > 0 ? "D" + digits.ToString(CultureInfo.InvariantCulture) : "D";                              }                                return value.InternalSign.ToString(format' info);                          }                            var builder = CreateBuilder(value' info' decimalFmt' digits);                          if (decimalFmt)                          {                              // Format Round-trip decimal                              // This format is supported for integral types only. The number is converted to a string of                              // decimal digits (0-9)' prefixed by a minus sign if the number is negative. The precision                              // specifier indicates the minimum number of digits desired in the resulting string. If required'                              // the number is padded with zeros to its left to produce the number of digits given by the                              // precision specifier.                              while (digits > 0 && digits >= builder.Length)                              {                                  builder.Prepend('0');                                  digits--;                              }                                if (value.InternalSign < 0)                              {                                  builder.Prepend(info.NegativeSign);                              }                                return builder.ToString();                          }                            // 'c'' 'C'' 'e'' 'E'' 'f'' 'F'' 'n'' 'N'' 'p'' 'P'' custom                          var precision = -1;                          var groupingSizes = new[] { 3 };                          var groupingSeparator = info.NumberGroupSeparator;                          var decimalSeparator = info.NumberDecimalSeparator;                          var groups = false;                          var type = 0;                          switch (fmt)                          {                              case '\0':                                  // parse custom                                  break;                                case 'c':                              case 'C':                                  decimalSeparator = info.CurrencyDecimalSeparator;                                  precision = digits != -1 ? digits : info.CurrencyDecimalDigits;                                  groupingSeparator = info.CurrencyGroupSeparator;                                  groupingSizes = info.CurrencyGroupSizes;                                  groups = true;                                  type = 1;                                  break;                                case 'f':                              case 'F':                                  precision = digits != -1 ? digits : info.NumberDecimalDigits;                                  break;                                case 'n':                              case 'N':                                  precision = digits != -1 ? digits : info.NumberDecimalDigits;                                  groups = true;                                  break;                                case 'p':                              case 'P':                                  decimalSeparator = info.PercentDecimalSeparator;                                  precision = digits != -1 ? digits : info.PercentDecimalDigits;                                  groups = true;                                  type = 2;                                  break;                                default:                                  throw new NotSupportedException();                          }                            var result = new StringBuilder(builder.Length + 20);                          var close = SetWrap(value' info' type' result);                          var append = builder;                          if (groups)                          {                              var extra = groupingSizes.Length - 1;                              if (groupingSizes[groupingSizes.Length - 1] != 0)                              {                                  var totalDigits = builder.Length;                                  extra += (int)Math.Ceiling(totalDigits * 1.0 / groupingSizes[groupingSizes.Length - 1]);                              }                                var length = extra + builder.Length;                              if (type == 2)                              {                                  length += 2;                                  append = StringWithGroups(length' new ExtendedEnumerable<char>(new[] { '0'' '0' }' builder)' groupingSizes' groupingSeparator);                              }                              else                              {                                  append = StringWithGroups(length' builder' groupingSizes' groupingSeparator);                              }                          }                            result.Append(append);                          if (precision > 0)                          {                              result.Append(decimalSeparator);                              result.Append(new string('0'' precision));                          }                            result.Append(close);                          return result.ToString();                      }              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,FormatBigInteger,The following statement contains a magic number: switch (fmt)              {                  case 'x':                  case 'X':                      return FormatBigIntegerToHexString(value' fmt' digits' info);                    case 'e':                  case 'E':                      {                          var precision = digits != -1 ? digits : 6;                            if (value.InternalBits == null)                          {                              return value.InternalSign.ToString(format' info);                          }                            var scale = (int)Math.Floor(Log10(value));                          // ---                          if (scale > precision + 10)                          {                              do                              {                                  value /= 1000000000;                              } while (Log10(value) > precision + 10);                          }                            while (Log10(value) > precision + 2)                          {                              value /= 10;                          }                            if (Log10(value) > precision + 1)                          {                              var round = value % 10 >= 5;                              value = (value / 10) + (round ? One : Zero);                          }                            ReverseStringBuilder builder;                            if (value.InternalBits == null)                          {                              builder = new ReverseStringBuilder(10);                              builder.Prepend($"{value.InternalSign:D}");                          }                          else                          {                              builder = CreateBuilder(value' info' false' 0);                          }                            // ---                          var decimalSeparator = info.NumberDecimalSeparator;                            var result = new StringBuilder(builder.Length + 6);                            var extra = 0;                            if (precision >= builder.Length)                          {                              extra = precision - (builder.Length - 1);                              precision = builder.Length - 1;                          }                            result.Append(builder.ToString(builder.Length' 1));                          result.Append(decimalSeparator);                          result.Append(builder.ToString(builder.Length - 1' precision));                          result.Append(new string('0'' extra));                          result.Append(fmt);                          result.Append(info.PositiveSign);                          if (scale < 10)                          {                              result.Append("00");                          }                          else if (scale < 100)                          {                              result.Append('0');                          }                            result.Append(scale);                            return result.ToString();                      }                  default:                      {                          var decimalFmt = fmt == 'g' || fmt == 'G' || fmt == 'd' || fmt == 'D' || fmt == 'r' || fmt == 'R';                          if (value.InternalBits == null)                          {                              if (fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R')                              {                                  format = digits > 0 ? "D" + digits.ToString(CultureInfo.InvariantCulture) : "D";                              }                                return value.InternalSign.ToString(format' info);                          }                            var builder = CreateBuilder(value' info' decimalFmt' digits);                          if (decimalFmt)                          {                              // Format Round-trip decimal                              // This format is supported for integral types only. The number is converted to a string of                              // decimal digits (0-9)' prefixed by a minus sign if the number is negative. The precision                              // specifier indicates the minimum number of digits desired in the resulting string. If required'                              // the number is padded with zeros to its left to produce the number of digits given by the                              // precision specifier.                              while (digits > 0 && digits >= builder.Length)                              {                                  builder.Prepend('0');                                  digits--;                              }                                if (value.InternalSign < 0)                              {                                  builder.Prepend(info.NegativeSign);                              }                                return builder.ToString();                          }                            // 'c'' 'C'' 'e'' 'E'' 'f'' 'F'' 'n'' 'N'' 'p'' 'P'' custom                          var precision = -1;                          var groupingSizes = new[] { 3 };                          var groupingSeparator = info.NumberGroupSeparator;                          var decimalSeparator = info.NumberDecimalSeparator;                          var groups = false;                          var type = 0;                          switch (fmt)                          {                              case '\0':                                  // parse custom                                  break;                                case 'c':                              case 'C':                                  decimalSeparator = info.CurrencyDecimalSeparator;                                  precision = digits != -1 ? digits : info.CurrencyDecimalDigits;                                  groupingSeparator = info.CurrencyGroupSeparator;                                  groupingSizes = info.CurrencyGroupSizes;                                  groups = true;                                  type = 1;                                  break;                                case 'f':                              case 'F':                                  precision = digits != -1 ? digits : info.NumberDecimalDigits;                                  break;                                case 'n':                              case 'N':                                  precision = digits != -1 ? digits : info.NumberDecimalDigits;                                  groups = true;                                  break;                                case 'p':                              case 'P':                                  decimalSeparator = info.PercentDecimalSeparator;                                  precision = digits != -1 ? digits : info.PercentDecimalDigits;                                  groups = true;                                  type = 2;                                  break;                                default:                                  throw new NotSupportedException();                          }                            var result = new StringBuilder(builder.Length + 20);                          var close = SetWrap(value' info' type' result);                          var append = builder;                          if (groups)                          {                              var extra = groupingSizes.Length - 1;                              if (groupingSizes[groupingSizes.Length - 1] != 0)                              {                                  var totalDigits = builder.Length;                                  extra += (int)Math.Ceiling(totalDigits * 1.0 / groupingSizes[groupingSizes.Length - 1]);                              }                                var length = extra + builder.Length;                              if (type == 2)                              {                                  length += 2;                                  append = StringWithGroups(length' new ExtendedEnumerable<char>(new[] { '0'' '0' }' builder)' groupingSizes' groupingSeparator);                              }                              else                              {                                  append = StringWithGroups(length' builder' groupingSizes' groupingSeparator);                              }                          }                            result.Append(append);                          if (precision > 0)                          {                              result.Append(decimalSeparator);                              result.Append(new string('0'' precision));                          }                            result.Append(close);                          return result.ToString();                      }              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,FormatBigInteger,The following statement contains a magic number: switch (fmt)              {                  case 'x':                  case 'X':                      return FormatBigIntegerToHexString(value' fmt' digits' info);                    case 'e':                  case 'E':                      {                          var precision = digits != -1 ? digits : 6;                            if (value.InternalBits == null)                          {                              return value.InternalSign.ToString(format' info);                          }                            var scale = (int)Math.Floor(Log10(value));                          // ---                          if (scale > precision + 10)                          {                              do                              {                                  value /= 1000000000;                              } while (Log10(value) > precision + 10);                          }                            while (Log10(value) > precision + 2)                          {                              value /= 10;                          }                            if (Log10(value) > precision + 1)                          {                              var round = value % 10 >= 5;                              value = (value / 10) + (round ? One : Zero);                          }                            ReverseStringBuilder builder;                            if (value.InternalBits == null)                          {                              builder = new ReverseStringBuilder(10);                              builder.Prepend($"{value.InternalSign:D}");                          }                          else                          {                              builder = CreateBuilder(value' info' false' 0);                          }                            // ---                          var decimalSeparator = info.NumberDecimalSeparator;                            var result = new StringBuilder(builder.Length + 6);                            var extra = 0;                            if (precision >= builder.Length)                          {                              extra = precision - (builder.Length - 1);                              precision = builder.Length - 1;                          }                            result.Append(builder.ToString(builder.Length' 1));                          result.Append(decimalSeparator);                          result.Append(builder.ToString(builder.Length - 1' precision));                          result.Append(new string('0'' extra));                          result.Append(fmt);                          result.Append(info.PositiveSign);                          if (scale < 10)                          {                              result.Append("00");                          }                          else if (scale < 100)                          {                              result.Append('0');                          }                            result.Append(scale);                            return result.ToString();                      }                  default:                      {                          var decimalFmt = fmt == 'g' || fmt == 'G' || fmt == 'd' || fmt == 'D' || fmt == 'r' || fmt == 'R';                          if (value.InternalBits == null)                          {                              if (fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R')                              {                                  format = digits > 0 ? "D" + digits.ToString(CultureInfo.InvariantCulture) : "D";                              }                                return value.InternalSign.ToString(format' info);                          }                            var builder = CreateBuilder(value' info' decimalFmt' digits);                          if (decimalFmt)                          {                              // Format Round-trip decimal                              // This format is supported for integral types only. The number is converted to a string of                              // decimal digits (0-9)' prefixed by a minus sign if the number is negative. The precision                              // specifier indicates the minimum number of digits desired in the resulting string. If required'                              // the number is padded with zeros to its left to produce the number of digits given by the                              // precision specifier.                              while (digits > 0 && digits >= builder.Length)                              {                                  builder.Prepend('0');                                  digits--;                              }                                if (value.InternalSign < 0)                              {                                  builder.Prepend(info.NegativeSign);                              }                                return builder.ToString();                          }                            // 'c'' 'C'' 'e'' 'E'' 'f'' 'F'' 'n'' 'N'' 'p'' 'P'' custom                          var precision = -1;                          var groupingSizes = new[] { 3 };                          var groupingSeparator = info.NumberGroupSeparator;                          var decimalSeparator = info.NumberDecimalSeparator;                          var groups = false;                          var type = 0;                          switch (fmt)                          {                              case '\0':                                  // parse custom                                  break;                                case 'c':                              case 'C':                                  decimalSeparator = info.CurrencyDecimalSeparator;                                  precision = digits != -1 ? digits : info.CurrencyDecimalDigits;                                  groupingSeparator = info.CurrencyGroupSeparator;                                  groupingSizes = info.CurrencyGroupSizes;                                  groups = true;                                  type = 1;                                  break;                                case 'f':                              case 'F':                                  precision = digits != -1 ? digits : info.NumberDecimalDigits;                                  break;                                case 'n':                              case 'N':                                  precision = digits != -1 ? digits : info.NumberDecimalDigits;                                  groups = true;                                  break;                                case 'p':                              case 'P':                                  decimalSeparator = info.PercentDecimalSeparator;                                  precision = digits != -1 ? digits : info.PercentDecimalDigits;                                  groups = true;                                  type = 2;                                  break;                                default:                                  throw new NotSupportedException();                          }                            var result = new StringBuilder(builder.Length + 20);                          var close = SetWrap(value' info' type' result);                          var append = builder;                          if (groups)                          {                              var extra = groupingSizes.Length - 1;                              if (groupingSizes[groupingSizes.Length - 1] != 0)                              {                                  var totalDigits = builder.Length;                                  extra += (int)Math.Ceiling(totalDigits * 1.0 / groupingSizes[groupingSizes.Length - 1]);                              }                                var length = extra + builder.Length;                              if (type == 2)                              {                                  length += 2;                                  append = StringWithGroups(length' new ExtendedEnumerable<char>(new[] { '0'' '0' }' builder)' groupingSizes' groupingSeparator);                              }                              else                              {                                  append = StringWithGroups(length' builder' groupingSizes' groupingSeparator);                              }                          }                            result.Append(append);                          if (precision > 0)                          {                              result.Append(decimalSeparator);                              result.Append(new string('0'' precision));                          }                            result.Append(close);                          return result.ToString();                      }              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,FormatBigInteger,The following statement contains a magic number: switch (fmt)              {                  case 'x':                  case 'X':                      return FormatBigIntegerToHexString(value' fmt' digits' info);                    case 'e':                  case 'E':                      {                          var precision = digits != -1 ? digits : 6;                            if (value.InternalBits == null)                          {                              return value.InternalSign.ToString(format' info);                          }                            var scale = (int)Math.Floor(Log10(value));                          // ---                          if (scale > precision + 10)                          {                              do                              {                                  value /= 1000000000;                              } while (Log10(value) > precision + 10);                          }                            while (Log10(value) > precision + 2)                          {                              value /= 10;                          }                            if (Log10(value) > precision + 1)                          {                              var round = value % 10 >= 5;                              value = (value / 10) + (round ? One : Zero);                          }                            ReverseStringBuilder builder;                            if (value.InternalBits == null)                          {                              builder = new ReverseStringBuilder(10);                              builder.Prepend($"{value.InternalSign:D}");                          }                          else                          {                              builder = CreateBuilder(value' info' false' 0);                          }                            // ---                          var decimalSeparator = info.NumberDecimalSeparator;                            var result = new StringBuilder(builder.Length + 6);                            var extra = 0;                            if (precision >= builder.Length)                          {                              extra = precision - (builder.Length - 1);                              precision = builder.Length - 1;                          }                            result.Append(builder.ToString(builder.Length' 1));                          result.Append(decimalSeparator);                          result.Append(builder.ToString(builder.Length - 1' precision));                          result.Append(new string('0'' extra));                          result.Append(fmt);                          result.Append(info.PositiveSign);                          if (scale < 10)                          {                              result.Append("00");                          }                          else if (scale < 100)                          {                              result.Append('0');                          }                            result.Append(scale);                            return result.ToString();                      }                  default:                      {                          var decimalFmt = fmt == 'g' || fmt == 'G' || fmt == 'd' || fmt == 'D' || fmt == 'r' || fmt == 'R';                          if (value.InternalBits == null)                          {                              if (fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R')                              {                                  format = digits > 0 ? "D" + digits.ToString(CultureInfo.InvariantCulture) : "D";                              }                                return value.InternalSign.ToString(format' info);                          }                            var builder = CreateBuilder(value' info' decimalFmt' digits);                          if (decimalFmt)                          {                              // Format Round-trip decimal                              // This format is supported for integral types only. The number is converted to a string of                              // decimal digits (0-9)' prefixed by a minus sign if the number is negative. The precision                              // specifier indicates the minimum number of digits desired in the resulting string. If required'                              // the number is padded with zeros to its left to produce the number of digits given by the                              // precision specifier.                              while (digits > 0 && digits >= builder.Length)                              {                                  builder.Prepend('0');                                  digits--;                              }                                if (value.InternalSign < 0)                              {                                  builder.Prepend(info.NegativeSign);                              }                                return builder.ToString();                          }                            // 'c'' 'C'' 'e'' 'E'' 'f'' 'F'' 'n'' 'N'' 'p'' 'P'' custom                          var precision = -1;                          var groupingSizes = new[] { 3 };                          var groupingSeparator = info.NumberGroupSeparator;                          var decimalSeparator = info.NumberDecimalSeparator;                          var groups = false;                          var type = 0;                          switch (fmt)                          {                              case '\0':                                  // parse custom                                  break;                                case 'c':                              case 'C':                                  decimalSeparator = info.CurrencyDecimalSeparator;                                  precision = digits != -1 ? digits : info.CurrencyDecimalDigits;                                  groupingSeparator = info.CurrencyGroupSeparator;                                  groupingSizes = info.CurrencyGroupSizes;                                  groups = true;                                  type = 1;                                  break;                                case 'f':                              case 'F':                                  precision = digits != -1 ? digits : info.NumberDecimalDigits;                                  break;                                case 'n':                              case 'N':                                  precision = digits != -1 ? digits : info.NumberDecimalDigits;                                  groups = true;                                  break;                                case 'p':                              case 'P':                                  decimalSeparator = info.PercentDecimalSeparator;                                  precision = digits != -1 ? digits : info.PercentDecimalDigits;                                  groups = true;                                  type = 2;                                  break;                                default:                                  throw new NotSupportedException();                          }                            var result = new StringBuilder(builder.Length + 20);                          var close = SetWrap(value' info' type' result);                          var append = builder;                          if (groups)                          {                              var extra = groupingSizes.Length - 1;                              if (groupingSizes[groupingSizes.Length - 1] != 0)                              {                                  var totalDigits = builder.Length;                                  extra += (int)Math.Ceiling(totalDigits * 1.0 / groupingSizes[groupingSizes.Length - 1]);                              }                                var length = extra + builder.Length;                              if (type == 2)                              {                                  length += 2;                                  append = StringWithGroups(length' new ExtendedEnumerable<char>(new[] { '0'' '0' }' builder)' groupingSizes' groupingSeparator);                              }                              else                              {                                  append = StringWithGroups(length' builder' groupingSizes' groupingSeparator);                              }                          }                            result.Append(append);                          if (precision > 0)                          {                              result.Append(decimalSeparator);                              result.Append(new string('0'' precision));                          }                            result.Append(close);                          return result.ToString();                      }              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,FormatBigInteger,The following statement contains a magic number: switch (fmt)              {                  case 'x':                  case 'X':                      return FormatBigIntegerToHexString(value' fmt' digits' info);                    case 'e':                  case 'E':                      {                          var precision = digits != -1 ? digits : 6;                            if (value.InternalBits == null)                          {                              return value.InternalSign.ToString(format' info);                          }                            var scale = (int)Math.Floor(Log10(value));                          // ---                          if (scale > precision + 10)                          {                              do                              {                                  value /= 1000000000;                              } while (Log10(value) > precision + 10);                          }                            while (Log10(value) > precision + 2)                          {                              value /= 10;                          }                            if (Log10(value) > precision + 1)                          {                              var round = value % 10 >= 5;                              value = (value / 10) + (round ? One : Zero);                          }                            ReverseStringBuilder builder;                            if (value.InternalBits == null)                          {                              builder = new ReverseStringBuilder(10);                              builder.Prepend($"{value.InternalSign:D}");                          }                          else                          {                              builder = CreateBuilder(value' info' false' 0);                          }                            // ---                          var decimalSeparator = info.NumberDecimalSeparator;                            var result = new StringBuilder(builder.Length + 6);                            var extra = 0;                            if (precision >= builder.Length)                          {                              extra = precision - (builder.Length - 1);                              precision = builder.Length - 1;                          }                            result.Append(builder.ToString(builder.Length' 1));                          result.Append(decimalSeparator);                          result.Append(builder.ToString(builder.Length - 1' precision));                          result.Append(new string('0'' extra));                          result.Append(fmt);                          result.Append(info.PositiveSign);                          if (scale < 10)                          {                              result.Append("00");                          }                          else if (scale < 100)                          {                              result.Append('0');                          }                            result.Append(scale);                            return result.ToString();                      }                  default:                      {                          var decimalFmt = fmt == 'g' || fmt == 'G' || fmt == 'd' || fmt == 'D' || fmt == 'r' || fmt == 'R';                          if (value.InternalBits == null)                          {                              if (fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R')                              {                                  format = digits > 0 ? "D" + digits.ToString(CultureInfo.InvariantCulture) : "D";                              }                                return value.InternalSign.ToString(format' info);                          }                            var builder = CreateBuilder(value' info' decimalFmt' digits);                          if (decimalFmt)                          {                              // Format Round-trip decimal                              // This format is supported for integral types only. The number is converted to a string of                              // decimal digits (0-9)' prefixed by a minus sign if the number is negative. The precision                              // specifier indicates the minimum number of digits desired in the resulting string. If required'                              // the number is padded with zeros to its left to produce the number of digits given by the                              // precision specifier.                              while (digits > 0 && digits >= builder.Length)                              {                                  builder.Prepend('0');                                  digits--;                              }                                if (value.InternalSign < 0)                              {                                  builder.Prepend(info.NegativeSign);                              }                                return builder.ToString();                          }                            // 'c'' 'C'' 'e'' 'E'' 'f'' 'F'' 'n'' 'N'' 'p'' 'P'' custom                          var precision = -1;                          var groupingSizes = new[] { 3 };                          var groupingSeparator = info.NumberGroupSeparator;                          var decimalSeparator = info.NumberDecimalSeparator;                          var groups = false;                          var type = 0;                          switch (fmt)                          {                              case '\0':                                  // parse custom                                  break;                                case 'c':                              case 'C':                                  decimalSeparator = info.CurrencyDecimalSeparator;                                  precision = digits != -1 ? digits : info.CurrencyDecimalDigits;                                  groupingSeparator = info.CurrencyGroupSeparator;                                  groupingSizes = info.CurrencyGroupSizes;                                  groups = true;                                  type = 1;                                  break;                                case 'f':                              case 'F':                                  precision = digits != -1 ? digits : info.NumberDecimalDigits;                                  break;                                case 'n':                              case 'N':                                  precision = digits != -1 ? digits : info.NumberDecimalDigits;                                  groups = true;                                  break;                                case 'p':                              case 'P':                                  decimalSeparator = info.PercentDecimalSeparator;                                  precision = digits != -1 ? digits : info.PercentDecimalDigits;                                  groups = true;                                  type = 2;                                  break;                                default:                                  throw new NotSupportedException();                          }                            var result = new StringBuilder(builder.Length + 20);                          var close = SetWrap(value' info' type' result);                          var append = builder;                          if (groups)                          {                              var extra = groupingSizes.Length - 1;                              if (groupingSizes[groupingSizes.Length - 1] != 0)                              {                                  var totalDigits = builder.Length;                                  extra += (int)Math.Ceiling(totalDigits * 1.0 / groupingSizes[groupingSizes.Length - 1]);                              }                                var length = extra + builder.Length;                              if (type == 2)                              {                                  length += 2;                                  append = StringWithGroups(length' new ExtendedEnumerable<char>(new[] { '0'' '0' }' builder)' groupingSizes' groupingSeparator);                              }                              else                              {                                  append = StringWithGroups(length' builder' groupingSizes' groupingSeparator);                              }                          }                            result.Append(append);                          if (precision > 0)                          {                              result.Append(decimalSeparator);                              result.Append(new string('0'' precision));                          }                            result.Append(close);                          return result.ToString();                      }              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,FormatBigInteger,The following statement contains a magic number: switch (fmt)              {                  case 'x':                  case 'X':                      return FormatBigIntegerToHexString(value' fmt' digits' info);                    case 'e':                  case 'E':                      {                          var precision = digits != -1 ? digits : 6;                            if (value.InternalBits == null)                          {                              return value.InternalSign.ToString(format' info);                          }                            var scale = (int)Math.Floor(Log10(value));                          // ---                          if (scale > precision + 10)                          {                              do                              {                                  value /= 1000000000;                              } while (Log10(value) > precision + 10);                          }                            while (Log10(value) > precision + 2)                          {                              value /= 10;                          }                            if (Log10(value) > precision + 1)                          {                              var round = value % 10 >= 5;                              value = (value / 10) + (round ? One : Zero);                          }                            ReverseStringBuilder builder;                            if (value.InternalBits == null)                          {                              builder = new ReverseStringBuilder(10);                              builder.Prepend($"{value.InternalSign:D}");                          }                          else                          {                              builder = CreateBuilder(value' info' false' 0);                          }                            // ---                          var decimalSeparator = info.NumberDecimalSeparator;                            var result = new StringBuilder(builder.Length + 6);                            var extra = 0;                            if (precision >= builder.Length)                          {                              extra = precision - (builder.Length - 1);                              precision = builder.Length - 1;                          }                            result.Append(builder.ToString(builder.Length' 1));                          result.Append(decimalSeparator);                          result.Append(builder.ToString(builder.Length - 1' precision));                          result.Append(new string('0'' extra));                          result.Append(fmt);                          result.Append(info.PositiveSign);                          if (scale < 10)                          {                              result.Append("00");                          }                          else if (scale < 100)                          {                              result.Append('0');                          }                            result.Append(scale);                            return result.ToString();                      }                  default:                      {                          var decimalFmt = fmt == 'g' || fmt == 'G' || fmt == 'd' || fmt == 'D' || fmt == 'r' || fmt == 'R';                          if (value.InternalBits == null)                          {                              if (fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R')                              {                                  format = digits > 0 ? "D" + digits.ToString(CultureInfo.InvariantCulture) : "D";                              }                                return value.InternalSign.ToString(format' info);                          }                            var builder = CreateBuilder(value' info' decimalFmt' digits);                          if (decimalFmt)                          {                              // Format Round-trip decimal                              // This format is supported for integral types only. The number is converted to a string of                              // decimal digits (0-9)' prefixed by a minus sign if the number is negative. The precision                              // specifier indicates the minimum number of digits desired in the resulting string. If required'                              // the number is padded with zeros to its left to produce the number of digits given by the                              // precision specifier.                              while (digits > 0 && digits >= builder.Length)                              {                                  builder.Prepend('0');                                  digits--;                              }                                if (value.InternalSign < 0)                              {                                  builder.Prepend(info.NegativeSign);                              }                                return builder.ToString();                          }                            // 'c'' 'C'' 'e'' 'E'' 'f'' 'F'' 'n'' 'N'' 'p'' 'P'' custom                          var precision = -1;                          var groupingSizes = new[] { 3 };                          var groupingSeparator = info.NumberGroupSeparator;                          var decimalSeparator = info.NumberDecimalSeparator;                          var groups = false;                          var type = 0;                          switch (fmt)                          {                              case '\0':                                  // parse custom                                  break;                                case 'c':                              case 'C':                                  decimalSeparator = info.CurrencyDecimalSeparator;                                  precision = digits != -1 ? digits : info.CurrencyDecimalDigits;                                  groupingSeparator = info.CurrencyGroupSeparator;                                  groupingSizes = info.CurrencyGroupSizes;                                  groups = true;                                  type = 1;                                  break;                                case 'f':                              case 'F':                                  precision = digits != -1 ? digits : info.NumberDecimalDigits;                                  break;                                case 'n':                              case 'N':                                  precision = digits != -1 ? digits : info.NumberDecimalDigits;                                  groups = true;                                  break;                                case 'p':                              case 'P':                                  decimalSeparator = info.PercentDecimalSeparator;                                  precision = digits != -1 ? digits : info.PercentDecimalDigits;                                  groups = true;                                  type = 2;                                  break;                                default:                                  throw new NotSupportedException();                          }                            var result = new StringBuilder(builder.Length + 20);                          var close = SetWrap(value' info' type' result);                          var append = builder;                          if (groups)                          {                              var extra = groupingSizes.Length - 1;                              if (groupingSizes[groupingSizes.Length - 1] != 0)                              {                                  var totalDigits = builder.Length;                                  extra += (int)Math.Ceiling(totalDigits * 1.0 / groupingSizes[groupingSizes.Length - 1]);                              }                                var length = extra + builder.Length;                              if (type == 2)                              {                                  length += 2;                                  append = StringWithGroups(length' new ExtendedEnumerable<char>(new[] { '0'' '0' }' builder)' groupingSizes' groupingSeparator);                              }                              else                              {                                  append = StringWithGroups(length' builder' groupingSizes' groupingSeparator);                              }                          }                            result.Append(append);                          if (precision > 0)                          {                              result.Append(decimalSeparator);                              result.Append(new string('0'' precision));                          }                            result.Append(close);                          return result.ToString();                      }              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,FormatBigInteger,The following statement contains a magic number: switch (fmt)              {                  case 'x':                  case 'X':                      return FormatBigIntegerToHexString(value' fmt' digits' info);                    case 'e':                  case 'E':                      {                          var precision = digits != -1 ? digits : 6;                            if (value.InternalBits == null)                          {                              return value.InternalSign.ToString(format' info);                          }                            var scale = (int)Math.Floor(Log10(value));                          // ---                          if (scale > precision + 10)                          {                              do                              {                                  value /= 1000000000;                              } while (Log10(value) > precision + 10);                          }                            while (Log10(value) > precision + 2)                          {                              value /= 10;                          }                            if (Log10(value) > precision + 1)                          {                              var round = value % 10 >= 5;                              value = (value / 10) + (round ? One : Zero);                          }                            ReverseStringBuilder builder;                            if (value.InternalBits == null)                          {                              builder = new ReverseStringBuilder(10);                              builder.Prepend($"{value.InternalSign:D}");                          }                          else                          {                              builder = CreateBuilder(value' info' false' 0);                          }                            // ---                          var decimalSeparator = info.NumberDecimalSeparator;                            var result = new StringBuilder(builder.Length + 6);                            var extra = 0;                            if (precision >= builder.Length)                          {                              extra = precision - (builder.Length - 1);                              precision = builder.Length - 1;                          }                            result.Append(builder.ToString(builder.Length' 1));                          result.Append(decimalSeparator);                          result.Append(builder.ToString(builder.Length - 1' precision));                          result.Append(new string('0'' extra));                          result.Append(fmt);                          result.Append(info.PositiveSign);                          if (scale < 10)                          {                              result.Append("00");                          }                          else if (scale < 100)                          {                              result.Append('0');                          }                            result.Append(scale);                            return result.ToString();                      }                  default:                      {                          var decimalFmt = fmt == 'g' || fmt == 'G' || fmt == 'd' || fmt == 'D' || fmt == 'r' || fmt == 'R';                          if (value.InternalBits == null)                          {                              if (fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R')                              {                                  format = digits > 0 ? "D" + digits.ToString(CultureInfo.InvariantCulture) : "D";                              }                                return value.InternalSign.ToString(format' info);                          }                            var builder = CreateBuilder(value' info' decimalFmt' digits);                          if (decimalFmt)                          {                              // Format Round-trip decimal                              // This format is supported for integral types only. The number is converted to a string of                              // decimal digits (0-9)' prefixed by a minus sign if the number is negative. The precision                              // specifier indicates the minimum number of digits desired in the resulting string. If required'                              // the number is padded with zeros to its left to produce the number of digits given by the                              // precision specifier.                              while (digits > 0 && digits >= builder.Length)                              {                                  builder.Prepend('0');                                  digits--;                              }                                if (value.InternalSign < 0)                              {                                  builder.Prepend(info.NegativeSign);                              }                                return builder.ToString();                          }                            // 'c'' 'C'' 'e'' 'E'' 'f'' 'F'' 'n'' 'N'' 'p'' 'P'' custom                          var precision = -1;                          var groupingSizes = new[] { 3 };                          var groupingSeparator = info.NumberGroupSeparator;                          var decimalSeparator = info.NumberDecimalSeparator;                          var groups = false;                          var type = 0;                          switch (fmt)                          {                              case '\0':                                  // parse custom                                  break;                                case 'c':                              case 'C':                                  decimalSeparator = info.CurrencyDecimalSeparator;                                  precision = digits != -1 ? digits : info.CurrencyDecimalDigits;                                  groupingSeparator = info.CurrencyGroupSeparator;                                  groupingSizes = info.CurrencyGroupSizes;                                  groups = true;                                  type = 1;                                  break;                                case 'f':                              case 'F':                                  precision = digits != -1 ? digits : info.NumberDecimalDigits;                                  break;                                case 'n':                              case 'N':                                  precision = digits != -1 ? digits : info.NumberDecimalDigits;                                  groups = true;                                  break;                                case 'p':                              case 'P':                                  decimalSeparator = info.PercentDecimalSeparator;                                  precision = digits != -1 ? digits : info.PercentDecimalDigits;                                  groups = true;                                  type = 2;                                  break;                                default:                                  throw new NotSupportedException();                          }                            var result = new StringBuilder(builder.Length + 20);                          var close = SetWrap(value' info' type' result);                          var append = builder;                          if (groups)                          {                              var extra = groupingSizes.Length - 1;                              if (groupingSizes[groupingSizes.Length - 1] != 0)                              {                                  var totalDigits = builder.Length;                                  extra += (int)Math.Ceiling(totalDigits * 1.0 / groupingSizes[groupingSizes.Length - 1]);                              }                                var length = extra + builder.Length;                              if (type == 2)                              {                                  length += 2;                                  append = StringWithGroups(length' new ExtendedEnumerable<char>(new[] { '0'' '0' }' builder)' groupingSizes' groupingSeparator);                              }                              else                              {                                  append = StringWithGroups(length' builder' groupingSizes' groupingSeparator);                              }                          }                            result.Append(append);                          if (precision > 0)                          {                              result.Append(decimalSeparator);                              result.Append(new string('0'' precision));                          }                            result.Append(close);                          return result.ToString();                      }              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,FormatBigInteger,The following statement contains a magic number: switch (fmt)              {                  case 'x':                  case 'X':                      return FormatBigIntegerToHexString(value' fmt' digits' info);                    case 'e':                  case 'E':                      {                          var precision = digits != -1 ? digits : 6;                            if (value.InternalBits == null)                          {                              return value.InternalSign.ToString(format' info);                          }                            var scale = (int)Math.Floor(Log10(value));                          // ---                          if (scale > precision + 10)                          {                              do                              {                                  value /= 1000000000;                              } while (Log10(value) > precision + 10);                          }                            while (Log10(value) > precision + 2)                          {                              value /= 10;                          }                            if (Log10(value) > precision + 1)                          {                              var round = value % 10 >= 5;                              value = (value / 10) + (round ? One : Zero);                          }                            ReverseStringBuilder builder;                            if (value.InternalBits == null)                          {                              builder = new ReverseStringBuilder(10);                              builder.Prepend($"{value.InternalSign:D}");                          }                          else                          {                              builder = CreateBuilder(value' info' false' 0);                          }                            // ---                          var decimalSeparator = info.NumberDecimalSeparator;                            var result = new StringBuilder(builder.Length + 6);                            var extra = 0;                            if (precision >= builder.Length)                          {                              extra = precision - (builder.Length - 1);                              precision = builder.Length - 1;                          }                            result.Append(builder.ToString(builder.Length' 1));                          result.Append(decimalSeparator);                          result.Append(builder.ToString(builder.Length - 1' precision));                          result.Append(new string('0'' extra));                          result.Append(fmt);                          result.Append(info.PositiveSign);                          if (scale < 10)                          {                              result.Append("00");                          }                          else if (scale < 100)                          {                              result.Append('0');                          }                            result.Append(scale);                            return result.ToString();                      }                  default:                      {                          var decimalFmt = fmt == 'g' || fmt == 'G' || fmt == 'd' || fmt == 'D' || fmt == 'r' || fmt == 'R';                          if (value.InternalBits == null)                          {                              if (fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R')                              {                                  format = digits > 0 ? "D" + digits.ToString(CultureInfo.InvariantCulture) : "D";                              }                                return value.InternalSign.ToString(format' info);                          }                            var builder = CreateBuilder(value' info' decimalFmt' digits);                          if (decimalFmt)                          {                              // Format Round-trip decimal                              // This format is supported for integral types only. The number is converted to a string of                              // decimal digits (0-9)' prefixed by a minus sign if the number is negative. The precision                              // specifier indicates the minimum number of digits desired in the resulting string. If required'                              // the number is padded with zeros to its left to produce the number of digits given by the                              // precision specifier.                              while (digits > 0 && digits >= builder.Length)                              {                                  builder.Prepend('0');                                  digits--;                              }                                if (value.InternalSign < 0)                              {                                  builder.Prepend(info.NegativeSign);                              }                                return builder.ToString();                          }                            // 'c'' 'C'' 'e'' 'E'' 'f'' 'F'' 'n'' 'N'' 'p'' 'P'' custom                          var precision = -1;                          var groupingSizes = new[] { 3 };                          var groupingSeparator = info.NumberGroupSeparator;                          var decimalSeparator = info.NumberDecimalSeparator;                          var groups = false;                          var type = 0;                          switch (fmt)                          {                              case '\0':                                  // parse custom                                  break;                                case 'c':                              case 'C':                                  decimalSeparator = info.CurrencyDecimalSeparator;                                  precision = digits != -1 ? digits : info.CurrencyDecimalDigits;                                  groupingSeparator = info.CurrencyGroupSeparator;                                  groupingSizes = info.CurrencyGroupSizes;                                  groups = true;                                  type = 1;                                  break;                                case 'f':                              case 'F':                                  precision = digits != -1 ? digits : info.NumberDecimalDigits;                                  break;                                case 'n':                              case 'N':                                  precision = digits != -1 ? digits : info.NumberDecimalDigits;                                  groups = true;                                  break;                                case 'p':                              case 'P':                                  decimalSeparator = info.PercentDecimalSeparator;                                  precision = digits != -1 ? digits : info.PercentDecimalDigits;                                  groups = true;                                  type = 2;                                  break;                                default:                                  throw new NotSupportedException();                          }                            var result = new StringBuilder(builder.Length + 20);                          var close = SetWrap(value' info' type' result);                          var append = builder;                          if (groups)                          {                              var extra = groupingSizes.Length - 1;                              if (groupingSizes[groupingSizes.Length - 1] != 0)                              {                                  var totalDigits = builder.Length;                                  extra += (int)Math.Ceiling(totalDigits * 1.0 / groupingSizes[groupingSizes.Length - 1]);                              }                                var length = extra + builder.Length;                              if (type == 2)                              {                                  length += 2;                                  append = StringWithGroups(length' new ExtendedEnumerable<char>(new[] { '0'' '0' }' builder)' groupingSizes' groupingSeparator);                              }                              else                              {                                  append = StringWithGroups(length' builder' groupingSizes' groupingSeparator);                              }                          }                            result.Append(append);                          if (precision > 0)                          {                              result.Append(decimalSeparator);                              result.Append(new string('0'' precision));                          }                            result.Append(close);                          return result.ToString();                      }              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,FormatBigInteger,The following statement contains a magic number: switch (fmt)              {                  case 'x':                  case 'X':                      return FormatBigIntegerToHexString(value' fmt' digits' info);                    case 'e':                  case 'E':                      {                          var precision = digits != -1 ? digits : 6;                            if (value.InternalBits == null)                          {                              return value.InternalSign.ToString(format' info);                          }                            var scale = (int)Math.Floor(Log10(value));                          // ---                          if (scale > precision + 10)                          {                              do                              {                                  value /= 1000000000;                              } while (Log10(value) > precision + 10);                          }                            while (Log10(value) > precision + 2)                          {                              value /= 10;                          }                            if (Log10(value) > precision + 1)                          {                              var round = value % 10 >= 5;                              value = (value / 10) + (round ? One : Zero);                          }                            ReverseStringBuilder builder;                            if (value.InternalBits == null)                          {                              builder = new ReverseStringBuilder(10);                              builder.Prepend($"{value.InternalSign:D}");                          }                          else                          {                              builder = CreateBuilder(value' info' false' 0);                          }                            // ---                          var decimalSeparator = info.NumberDecimalSeparator;                            var result = new StringBuilder(builder.Length + 6);                            var extra = 0;                            if (precision >= builder.Length)                          {                              extra = precision - (builder.Length - 1);                              precision = builder.Length - 1;                          }                            result.Append(builder.ToString(builder.Length' 1));                          result.Append(decimalSeparator);                          result.Append(builder.ToString(builder.Length - 1' precision));                          result.Append(new string('0'' extra));                          result.Append(fmt);                          result.Append(info.PositiveSign);                          if (scale < 10)                          {                              result.Append("00");                          }                          else if (scale < 100)                          {                              result.Append('0');                          }                            result.Append(scale);                            return result.ToString();                      }                  default:                      {                          var decimalFmt = fmt == 'g' || fmt == 'G' || fmt == 'd' || fmt == 'D' || fmt == 'r' || fmt == 'R';                          if (value.InternalBits == null)                          {                              if (fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R')                              {                                  format = digits > 0 ? "D" + digits.ToString(CultureInfo.InvariantCulture) : "D";                              }                                return value.InternalSign.ToString(format' info);                          }                            var builder = CreateBuilder(value' info' decimalFmt' digits);                          if (decimalFmt)                          {                              // Format Round-trip decimal                              // This format is supported for integral types only. The number is converted to a string of                              // decimal digits (0-9)' prefixed by a minus sign if the number is negative. The precision                              // specifier indicates the minimum number of digits desired in the resulting string. If required'                              // the number is padded with zeros to its left to produce the number of digits given by the                              // precision specifier.                              while (digits > 0 && digits >= builder.Length)                              {                                  builder.Prepend('0');                                  digits--;                              }                                if (value.InternalSign < 0)                              {                                  builder.Prepend(info.NegativeSign);                              }                                return builder.ToString();                          }                            // 'c'' 'C'' 'e'' 'E'' 'f'' 'F'' 'n'' 'N'' 'p'' 'P'' custom                          var precision = -1;                          var groupingSizes = new[] { 3 };                          var groupingSeparator = info.NumberGroupSeparator;                          var decimalSeparator = info.NumberDecimalSeparator;                          var groups = false;                          var type = 0;                          switch (fmt)                          {                              case '\0':                                  // parse custom                                  break;                                case 'c':                              case 'C':                                  decimalSeparator = info.CurrencyDecimalSeparator;                                  precision = digits != -1 ? digits : info.CurrencyDecimalDigits;                                  groupingSeparator = info.CurrencyGroupSeparator;                                  groupingSizes = info.CurrencyGroupSizes;                                  groups = true;                                  type = 1;                                  break;                                case 'f':                              case 'F':                                  precision = digits != -1 ? digits : info.NumberDecimalDigits;                                  break;                                case 'n':                              case 'N':                                  precision = digits != -1 ? digits : info.NumberDecimalDigits;                                  groups = true;                                  break;                                case 'p':                              case 'P':                                  decimalSeparator = info.PercentDecimalSeparator;                                  precision = digits != -1 ? digits : info.PercentDecimalDigits;                                  groups = true;                                  type = 2;                                  break;                                default:                                  throw new NotSupportedException();                          }                            var result = new StringBuilder(builder.Length + 20);                          var close = SetWrap(value' info' type' result);                          var append = builder;                          if (groups)                          {                              var extra = groupingSizes.Length - 1;                              if (groupingSizes[groupingSizes.Length - 1] != 0)                              {                                  var totalDigits = builder.Length;                                  extra += (int)Math.Ceiling(totalDigits * 1.0 / groupingSizes[groupingSizes.Length - 1]);                              }                                var length = extra + builder.Length;                              if (type == 2)                              {                                  length += 2;                                  append = StringWithGroups(length' new ExtendedEnumerable<char>(new[] { '0'' '0' }' builder)' groupingSizes' groupingSeparator);                              }                              else                              {                                  append = StringWithGroups(length' builder' groupingSizes' groupingSeparator);                              }                          }                            result.Append(append);                          if (precision > 0)                          {                              result.Append(decimalSeparator);                              result.Append(new string('0'' precision));                          }                            result.Append(close);                          return result.ToString();                      }              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,FormatBigInteger,The following statement contains a magic number: switch (fmt)              {                  case 'x':                  case 'X':                      return FormatBigIntegerToHexString(value' fmt' digits' info);                    case 'e':                  case 'E':                      {                          var precision = digits != -1 ? digits : 6;                            if (value.InternalBits == null)                          {                              return value.InternalSign.ToString(format' info);                          }                            var scale = (int)Math.Floor(Log10(value));                          // ---                          if (scale > precision + 10)                          {                              do                              {                                  value /= 1000000000;                              } while (Log10(value) > precision + 10);                          }                            while (Log10(value) > precision + 2)                          {                              value /= 10;                          }                            if (Log10(value) > precision + 1)                          {                              var round = value % 10 >= 5;                              value = (value / 10) + (round ? One : Zero);                          }                            ReverseStringBuilder builder;                            if (value.InternalBits == null)                          {                              builder = new ReverseStringBuilder(10);                              builder.Prepend($"{value.InternalSign:D}");                          }                          else                          {                              builder = CreateBuilder(value' info' false' 0);                          }                            // ---                          var decimalSeparator = info.NumberDecimalSeparator;                            var result = new StringBuilder(builder.Length + 6);                            var extra = 0;                            if (precision >= builder.Length)                          {                              extra = precision - (builder.Length - 1);                              precision = builder.Length - 1;                          }                            result.Append(builder.ToString(builder.Length' 1));                          result.Append(decimalSeparator);                          result.Append(builder.ToString(builder.Length - 1' precision));                          result.Append(new string('0'' extra));                          result.Append(fmt);                          result.Append(info.PositiveSign);                          if (scale < 10)                          {                              result.Append("00");                          }                          else if (scale < 100)                          {                              result.Append('0');                          }                            result.Append(scale);                            return result.ToString();                      }                  default:                      {                          var decimalFmt = fmt == 'g' || fmt == 'G' || fmt == 'd' || fmt == 'D' || fmt == 'r' || fmt == 'R';                          if (value.InternalBits == null)                          {                              if (fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R')                              {                                  format = digits > 0 ? "D" + digits.ToString(CultureInfo.InvariantCulture) : "D";                              }                                return value.InternalSign.ToString(format' info);                          }                            var builder = CreateBuilder(value' info' decimalFmt' digits);                          if (decimalFmt)                          {                              // Format Round-trip decimal                              // This format is supported for integral types only. The number is converted to a string of                              // decimal digits (0-9)' prefixed by a minus sign if the number is negative. The precision                              // specifier indicates the minimum number of digits desired in the resulting string. If required'                              // the number is padded with zeros to its left to produce the number of digits given by the                              // precision specifier.                              while (digits > 0 && digits >= builder.Length)                              {                                  builder.Prepend('0');                                  digits--;                              }                                if (value.InternalSign < 0)                              {                                  builder.Prepend(info.NegativeSign);                              }                                return builder.ToString();                          }                            // 'c'' 'C'' 'e'' 'E'' 'f'' 'F'' 'n'' 'N'' 'p'' 'P'' custom                          var precision = -1;                          var groupingSizes = new[] { 3 };                          var groupingSeparator = info.NumberGroupSeparator;                          var decimalSeparator = info.NumberDecimalSeparator;                          var groups = false;                          var type = 0;                          switch (fmt)                          {                              case '\0':                                  // parse custom                                  break;                                case 'c':                              case 'C':                                  decimalSeparator = info.CurrencyDecimalSeparator;                                  precision = digits != -1 ? digits : info.CurrencyDecimalDigits;                                  groupingSeparator = info.CurrencyGroupSeparator;                                  groupingSizes = info.CurrencyGroupSizes;                                  groups = true;                                  type = 1;                                  break;                                case 'f':                              case 'F':                                  precision = digits != -1 ? digits : info.NumberDecimalDigits;                                  break;                                case 'n':                              case 'N':                                  precision = digits != -1 ? digits : info.NumberDecimalDigits;                                  groups = true;                                  break;                                case 'p':                              case 'P':                                  decimalSeparator = info.PercentDecimalSeparator;                                  precision = digits != -1 ? digits : info.PercentDecimalDigits;                                  groups = true;                                  type = 2;                                  break;                                default:                                  throw new NotSupportedException();                          }                            var result = new StringBuilder(builder.Length + 20);                          var close = SetWrap(value' info' type' result);                          var append = builder;                          if (groups)                          {                              var extra = groupingSizes.Length - 1;                              if (groupingSizes[groupingSizes.Length - 1] != 0)                              {                                  var totalDigits = builder.Length;                                  extra += (int)Math.Ceiling(totalDigits * 1.0 / groupingSizes[groupingSizes.Length - 1]);                              }                                var length = extra + builder.Length;                              if (type == 2)                              {                                  length += 2;                                  append = StringWithGroups(length' new ExtendedEnumerable<char>(new[] { '0'' '0' }' builder)' groupingSizes' groupingSeparator);                              }                              else                              {                                  append = StringWithGroups(length' builder' groupingSizes' groupingSeparator);                              }                          }                            result.Append(append);                          if (precision > 0)                          {                              result.Append(decimalSeparator);                              result.Append(new string('0'' precision));                          }                            result.Append(close);                          return result.ToString();                      }              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,FormatBigInteger,The following statement contains a magic number: switch (fmt)              {                  case 'x':                  case 'X':                      return FormatBigIntegerToHexString(value' fmt' digits' info);                    case 'e':                  case 'E':                      {                          var precision = digits != -1 ? digits : 6;                            if (value.InternalBits == null)                          {                              return value.InternalSign.ToString(format' info);                          }                            var scale = (int)Math.Floor(Log10(value));                          // ---                          if (scale > precision + 10)                          {                              do                              {                                  value /= 1000000000;                              } while (Log10(value) > precision + 10);                          }                            while (Log10(value) > precision + 2)                          {                              value /= 10;                          }                            if (Log10(value) > precision + 1)                          {                              var round = value % 10 >= 5;                              value = (value / 10) + (round ? One : Zero);                          }                            ReverseStringBuilder builder;                            if (value.InternalBits == null)                          {                              builder = new ReverseStringBuilder(10);                              builder.Prepend($"{value.InternalSign:D}");                          }                          else                          {                              builder = CreateBuilder(value' info' false' 0);                          }                            // ---                          var decimalSeparator = info.NumberDecimalSeparator;                            var result = new StringBuilder(builder.Length + 6);                            var extra = 0;                            if (precision >= builder.Length)                          {                              extra = precision - (builder.Length - 1);                              precision = builder.Length - 1;                          }                            result.Append(builder.ToString(builder.Length' 1));                          result.Append(decimalSeparator);                          result.Append(builder.ToString(builder.Length - 1' precision));                          result.Append(new string('0'' extra));                          result.Append(fmt);                          result.Append(info.PositiveSign);                          if (scale < 10)                          {                              result.Append("00");                          }                          else if (scale < 100)                          {                              result.Append('0');                          }                            result.Append(scale);                            return result.ToString();                      }                  default:                      {                          var decimalFmt = fmt == 'g' || fmt == 'G' || fmt == 'd' || fmt == 'D' || fmt == 'r' || fmt == 'R';                          if (value.InternalBits == null)                          {                              if (fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R')                              {                                  format = digits > 0 ? "D" + digits.ToString(CultureInfo.InvariantCulture) : "D";                              }                                return value.InternalSign.ToString(format' info);                          }                            var builder = CreateBuilder(value' info' decimalFmt' digits);                          if (decimalFmt)                          {                              // Format Round-trip decimal                              // This format is supported for integral types only. The number is converted to a string of                              // decimal digits (0-9)' prefixed by a minus sign if the number is negative. The precision                              // specifier indicates the minimum number of digits desired in the resulting string. If required'                              // the number is padded with zeros to its left to produce the number of digits given by the                              // precision specifier.                              while (digits > 0 && digits >= builder.Length)                              {                                  builder.Prepend('0');                                  digits--;                              }                                if (value.InternalSign < 0)                              {                                  builder.Prepend(info.NegativeSign);                              }                                return builder.ToString();                          }                            // 'c'' 'C'' 'e'' 'E'' 'f'' 'F'' 'n'' 'N'' 'p'' 'P'' custom                          var precision = -1;                          var groupingSizes = new[] { 3 };                          var groupingSeparator = info.NumberGroupSeparator;                          var decimalSeparator = info.NumberDecimalSeparator;                          var groups = false;                          var type = 0;                          switch (fmt)                          {                              case '\0':                                  // parse custom                                  break;                                case 'c':                              case 'C':                                  decimalSeparator = info.CurrencyDecimalSeparator;                                  precision = digits != -1 ? digits : info.CurrencyDecimalDigits;                                  groupingSeparator = info.CurrencyGroupSeparator;                                  groupingSizes = info.CurrencyGroupSizes;                                  groups = true;                                  type = 1;                                  break;                                case 'f':                              case 'F':                                  precision = digits != -1 ? digits : info.NumberDecimalDigits;                                  break;                                case 'n':                              case 'N':                                  precision = digits != -1 ? digits : info.NumberDecimalDigits;                                  groups = true;                                  break;                                case 'p':                              case 'P':                                  decimalSeparator = info.PercentDecimalSeparator;                                  precision = digits != -1 ? digits : info.PercentDecimalDigits;                                  groups = true;                                  type = 2;                                  break;                                default:                                  throw new NotSupportedException();                          }                            var result = new StringBuilder(builder.Length + 20);                          var close = SetWrap(value' info' type' result);                          var append = builder;                          if (groups)                          {                              var extra = groupingSizes.Length - 1;                              if (groupingSizes[groupingSizes.Length - 1] != 0)                              {                                  var totalDigits = builder.Length;                                  extra += (int)Math.Ceiling(totalDigits * 1.0 / groupingSizes[groupingSizes.Length - 1]);                              }                                var length = extra + builder.Length;                              if (type == 2)                              {                                  length += 2;                                  append = StringWithGroups(length' new ExtendedEnumerable<char>(new[] { '0'' '0' }' builder)' groupingSizes' groupingSeparator);                              }                              else                              {                                  append = StringWithGroups(length' builder' groupingSizes' groupingSeparator);                              }                          }                            result.Append(append);                          if (precision > 0)                          {                              result.Append(decimalSeparator);                              result.Append(new string('0'' precision));                          }                            result.Append(close);                          return result.ToString();                      }              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,FormatBigInteger,The following statement contains a magic number: switch (fmt)              {                  case 'x':                  case 'X':                      return FormatBigIntegerToHexString(value' fmt' digits' info);                    case 'e':                  case 'E':                      {                          var precision = digits != -1 ? digits : 6;                            if (value.InternalBits == null)                          {                              return value.InternalSign.ToString(format' info);                          }                            var scale = (int)Math.Floor(Log10(value));                          // ---                          if (scale > precision + 10)                          {                              do                              {                                  value /= 1000000000;                              } while (Log10(value) > precision + 10);                          }                            while (Log10(value) > precision + 2)                          {                              value /= 10;                          }                            if (Log10(value) > precision + 1)                          {                              var round = value % 10 >= 5;                              value = (value / 10) + (round ? One : Zero);                          }                            ReverseStringBuilder builder;                            if (value.InternalBits == null)                          {                              builder = new ReverseStringBuilder(10);                              builder.Prepend($"{value.InternalSign:D}");                          }                          else                          {                              builder = CreateBuilder(value' info' false' 0);                          }                            // ---                          var decimalSeparator = info.NumberDecimalSeparator;                            var result = new StringBuilder(builder.Length + 6);                            var extra = 0;                            if (precision >= builder.Length)                          {                              extra = precision - (builder.Length - 1);                              precision = builder.Length - 1;                          }                            result.Append(builder.ToString(builder.Length' 1));                          result.Append(decimalSeparator);                          result.Append(builder.ToString(builder.Length - 1' precision));                          result.Append(new string('0'' extra));                          result.Append(fmt);                          result.Append(info.PositiveSign);                          if (scale < 10)                          {                              result.Append("00");                          }                          else if (scale < 100)                          {                              result.Append('0');                          }                            result.Append(scale);                            return result.ToString();                      }                  default:                      {                          var decimalFmt = fmt == 'g' || fmt == 'G' || fmt == 'd' || fmt == 'D' || fmt == 'r' || fmt == 'R';                          if (value.InternalBits == null)                          {                              if (fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R')                              {                                  format = digits > 0 ? "D" + digits.ToString(CultureInfo.InvariantCulture) : "D";                              }                                return value.InternalSign.ToString(format' info);                          }                            var builder = CreateBuilder(value' info' decimalFmt' digits);                          if (decimalFmt)                          {                              // Format Round-trip decimal                              // This format is supported for integral types only. The number is converted to a string of                              // decimal digits (0-9)' prefixed by a minus sign if the number is negative. The precision                              // specifier indicates the minimum number of digits desired in the resulting string. If required'                              // the number is padded with zeros to its left to produce the number of digits given by the                              // precision specifier.                              while (digits > 0 && digits >= builder.Length)                              {                                  builder.Prepend('0');                                  digits--;                              }                                if (value.InternalSign < 0)                              {                                  builder.Prepend(info.NegativeSign);                              }                                return builder.ToString();                          }                            // 'c'' 'C'' 'e'' 'E'' 'f'' 'F'' 'n'' 'N'' 'p'' 'P'' custom                          var precision = -1;                          var groupingSizes = new[] { 3 };                          var groupingSeparator = info.NumberGroupSeparator;                          var decimalSeparator = info.NumberDecimalSeparator;                          var groups = false;                          var type = 0;                          switch (fmt)                          {                              case '\0':                                  // parse custom                                  break;                                case 'c':                              case 'C':                                  decimalSeparator = info.CurrencyDecimalSeparator;                                  precision = digits != -1 ? digits : info.CurrencyDecimalDigits;                                  groupingSeparator = info.CurrencyGroupSeparator;                                  groupingSizes = info.CurrencyGroupSizes;                                  groups = true;                                  type = 1;                                  break;                                case 'f':                              case 'F':                                  precision = digits != -1 ? digits : info.NumberDecimalDigits;                                  break;                                case 'n':                              case 'N':                                  precision = digits != -1 ? digits : info.NumberDecimalDigits;                                  groups = true;                                  break;                                case 'p':                              case 'P':                                  decimalSeparator = info.PercentDecimalSeparator;                                  precision = digits != -1 ? digits : info.PercentDecimalDigits;                                  groups = true;                                  type = 2;                                  break;                                default:                                  throw new NotSupportedException();                          }                            var result = new StringBuilder(builder.Length + 20);                          var close = SetWrap(value' info' type' result);                          var append = builder;                          if (groups)                          {                              var extra = groupingSizes.Length - 1;                              if (groupingSizes[groupingSizes.Length - 1] != 0)                              {                                  var totalDigits = builder.Length;                                  extra += (int)Math.Ceiling(totalDigits * 1.0 / groupingSizes[groupingSizes.Length - 1]);                              }                                var length = extra + builder.Length;                              if (type == 2)                              {                                  length += 2;                                  append = StringWithGroups(length' new ExtendedEnumerable<char>(new[] { '0'' '0' }' builder)' groupingSizes' groupingSeparator);                              }                              else                              {                                  append = StringWithGroups(length' builder' groupingSizes' groupingSeparator);                              }                          }                            result.Append(append);                          if (precision > 0)                          {                              result.Append(decimalSeparator);                              result.Append(new string('0'' precision));                          }                            result.Append(close);                          return result.ToString();                      }              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,FormatBigInteger,The following statement contains a magic number: switch (fmt)              {                  case 'x':                  case 'X':                      return FormatBigIntegerToHexString(value' fmt' digits' info);                    case 'e':                  case 'E':                      {                          var precision = digits != -1 ? digits : 6;                            if (value.InternalBits == null)                          {                              return value.InternalSign.ToString(format' info);                          }                            var scale = (int)Math.Floor(Log10(value));                          // ---                          if (scale > precision + 10)                          {                              do                              {                                  value /= 1000000000;                              } while (Log10(value) > precision + 10);                          }                            while (Log10(value) > precision + 2)                          {                              value /= 10;                          }                            if (Log10(value) > precision + 1)                          {                              var round = value % 10 >= 5;                              value = (value / 10) + (round ? One : Zero);                          }                            ReverseStringBuilder builder;                            if (value.InternalBits == null)                          {                              builder = new ReverseStringBuilder(10);                              builder.Prepend($"{value.InternalSign:D}");                          }                          else                          {                              builder = CreateBuilder(value' info' false' 0);                          }                            // ---                          var decimalSeparator = info.NumberDecimalSeparator;                            var result = new StringBuilder(builder.Length + 6);                            var extra = 0;                            if (precision >= builder.Length)                          {                              extra = precision - (builder.Length - 1);                              precision = builder.Length - 1;                          }                            result.Append(builder.ToString(builder.Length' 1));                          result.Append(decimalSeparator);                          result.Append(builder.ToString(builder.Length - 1' precision));                          result.Append(new string('0'' extra));                          result.Append(fmt);                          result.Append(info.PositiveSign);                          if (scale < 10)                          {                              result.Append("00");                          }                          else if (scale < 100)                          {                              result.Append('0');                          }                            result.Append(scale);                            return result.ToString();                      }                  default:                      {                          var decimalFmt = fmt == 'g' || fmt == 'G' || fmt == 'd' || fmt == 'D' || fmt == 'r' || fmt == 'R';                          if (value.InternalBits == null)                          {                              if (fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R')                              {                                  format = digits > 0 ? "D" + digits.ToString(CultureInfo.InvariantCulture) : "D";                              }                                return value.InternalSign.ToString(format' info);                          }                            var builder = CreateBuilder(value' info' decimalFmt' digits);                          if (decimalFmt)                          {                              // Format Round-trip decimal                              // This format is supported for integral types only. The number is converted to a string of                              // decimal digits (0-9)' prefixed by a minus sign if the number is negative. The precision                              // specifier indicates the minimum number of digits desired in the resulting string. If required'                              // the number is padded with zeros to its left to produce the number of digits given by the                              // precision specifier.                              while (digits > 0 && digits >= builder.Length)                              {                                  builder.Prepend('0');                                  digits--;                              }                                if (value.InternalSign < 0)                              {                                  builder.Prepend(info.NegativeSign);                              }                                return builder.ToString();                          }                            // 'c'' 'C'' 'e'' 'E'' 'f'' 'F'' 'n'' 'N'' 'p'' 'P'' custom                          var precision = -1;                          var groupingSizes = new[] { 3 };                          var groupingSeparator = info.NumberGroupSeparator;                          var decimalSeparator = info.NumberDecimalSeparator;                          var groups = false;                          var type = 0;                          switch (fmt)                          {                              case '\0':                                  // parse custom                                  break;                                case 'c':                              case 'C':                                  decimalSeparator = info.CurrencyDecimalSeparator;                                  precision = digits != -1 ? digits : info.CurrencyDecimalDigits;                                  groupingSeparator = info.CurrencyGroupSeparator;                                  groupingSizes = info.CurrencyGroupSizes;                                  groups = true;                                  type = 1;                                  break;                                case 'f':                              case 'F':                                  precision = digits != -1 ? digits : info.NumberDecimalDigits;                                  break;                                case 'n':                              case 'N':                                  precision = digits != -1 ? digits : info.NumberDecimalDigits;                                  groups = true;                                  break;                                case 'p':                              case 'P':                                  decimalSeparator = info.PercentDecimalSeparator;                                  precision = digits != -1 ? digits : info.PercentDecimalDigits;                                  groups = true;                                  type = 2;                                  break;                                default:                                  throw new NotSupportedException();                          }                            var result = new StringBuilder(builder.Length + 20);                          var close = SetWrap(value' info' type' result);                          var append = builder;                          if (groups)                          {                              var extra = groupingSizes.Length - 1;                              if (groupingSizes[groupingSizes.Length - 1] != 0)                              {                                  var totalDigits = builder.Length;                                  extra += (int)Math.Ceiling(totalDigits * 1.0 / groupingSizes[groupingSizes.Length - 1]);                              }                                var length = extra + builder.Length;                              if (type == 2)                              {                                  length += 2;                                  append = StringWithGroups(length' new ExtendedEnumerable<char>(new[] { '0'' '0' }' builder)' groupingSizes' groupingSeparator);                              }                              else                              {                                  append = StringWithGroups(length' builder' groupingSizes' groupingSeparator);                              }                          }                            result.Append(append);                          if (precision > 0)                          {                              result.Append(decimalSeparator);                              result.Append(new string('0'' precision));                          }                            result.Append(close);                          return result.ToString();                      }              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,FormatBigInteger,The following statement contains a magic number: switch (fmt)              {                  case 'x':                  case 'X':                      return FormatBigIntegerToHexString(value' fmt' digits' info);                    case 'e':                  case 'E':                      {                          var precision = digits != -1 ? digits : 6;                            if (value.InternalBits == null)                          {                              return value.InternalSign.ToString(format' info);                          }                            var scale = (int)Math.Floor(Log10(value));                          // ---                          if (scale > precision + 10)                          {                              do                              {                                  value /= 1000000000;                              } while (Log10(value) > precision + 10);                          }                            while (Log10(value) > precision + 2)                          {                              value /= 10;                          }                            if (Log10(value) > precision + 1)                          {                              var round = value % 10 >= 5;                              value = (value / 10) + (round ? One : Zero);                          }                            ReverseStringBuilder builder;                            if (value.InternalBits == null)                          {                              builder = new ReverseStringBuilder(10);                              builder.Prepend($"{value.InternalSign:D}");                          }                          else                          {                              builder = CreateBuilder(value' info' false' 0);                          }                            // ---                          var decimalSeparator = info.NumberDecimalSeparator;                            var result = new StringBuilder(builder.Length + 6);                            var extra = 0;                            if (precision >= builder.Length)                          {                              extra = precision - (builder.Length - 1);                              precision = builder.Length - 1;                          }                            result.Append(builder.ToString(builder.Length' 1));                          result.Append(decimalSeparator);                          result.Append(builder.ToString(builder.Length - 1' precision));                          result.Append(new string('0'' extra));                          result.Append(fmt);                          result.Append(info.PositiveSign);                          if (scale < 10)                          {                              result.Append("00");                          }                          else if (scale < 100)                          {                              result.Append('0');                          }                            result.Append(scale);                            return result.ToString();                      }                  default:                      {                          var decimalFmt = fmt == 'g' || fmt == 'G' || fmt == 'd' || fmt == 'D' || fmt == 'r' || fmt == 'R';                          if (value.InternalBits == null)                          {                              if (fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R')                              {                                  format = digits > 0 ? "D" + digits.ToString(CultureInfo.InvariantCulture) : "D";                              }                                return value.InternalSign.ToString(format' info);                          }                            var builder = CreateBuilder(value' info' decimalFmt' digits);                          if (decimalFmt)                          {                              // Format Round-trip decimal                              // This format is supported for integral types only. The number is converted to a string of                              // decimal digits (0-9)' prefixed by a minus sign if the number is negative. The precision                              // specifier indicates the minimum number of digits desired in the resulting string. If required'                              // the number is padded with zeros to its left to produce the number of digits given by the                              // precision specifier.                              while (digits > 0 && digits >= builder.Length)                              {                                  builder.Prepend('0');                                  digits--;                              }                                if (value.InternalSign < 0)                              {                                  builder.Prepend(info.NegativeSign);                              }                                return builder.ToString();                          }                            // 'c'' 'C'' 'e'' 'E'' 'f'' 'F'' 'n'' 'N'' 'p'' 'P'' custom                          var precision = -1;                          var groupingSizes = new[] { 3 };                          var groupingSeparator = info.NumberGroupSeparator;                          var decimalSeparator = info.NumberDecimalSeparator;                          var groups = false;                          var type = 0;                          switch (fmt)                          {                              case '\0':                                  // parse custom                                  break;                                case 'c':                              case 'C':                                  decimalSeparator = info.CurrencyDecimalSeparator;                                  precision = digits != -1 ? digits : info.CurrencyDecimalDigits;                                  groupingSeparator = info.CurrencyGroupSeparator;                                  groupingSizes = info.CurrencyGroupSizes;                                  groups = true;                                  type = 1;                                  break;                                case 'f':                              case 'F':                                  precision = digits != -1 ? digits : info.NumberDecimalDigits;                                  break;                                case 'n':                              case 'N':                                  precision = digits != -1 ? digits : info.NumberDecimalDigits;                                  groups = true;                                  break;                                case 'p':                              case 'P':                                  decimalSeparator = info.PercentDecimalSeparator;                                  precision = digits != -1 ? digits : info.PercentDecimalDigits;                                  groups = true;                                  type = 2;                                  break;                                default:                                  throw new NotSupportedException();                          }                            var result = new StringBuilder(builder.Length + 20);                          var close = SetWrap(value' info' type' result);                          var append = builder;                          if (groups)                          {                              var extra = groupingSizes.Length - 1;                              if (groupingSizes[groupingSizes.Length - 1] != 0)                              {                                  var totalDigits = builder.Length;                                  extra += (int)Math.Ceiling(totalDigits * 1.0 / groupingSizes[groupingSizes.Length - 1]);                              }                                var length = extra + builder.Length;                              if (type == 2)                              {                                  length += 2;                                  append = StringWithGroups(length' new ExtendedEnumerable<char>(new[] { '0'' '0' }' builder)' groupingSizes' groupingSeparator);                              }                              else                              {                                  append = StringWithGroups(length' builder' groupingSizes' groupingSeparator);                              }                          }                            result.Append(append);                          if (precision > 0)                          {                              result.Append(decimalSeparator);                              result.Append(new string('0'' precision));                          }                            result.Append(close);                          return result.ToString();                      }              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,FormatBigInteger,The following statement contains a magic number: switch (fmt)              {                  case 'x':                  case 'X':                      return FormatBigIntegerToHexString(value' fmt' digits' info);                    case 'e':                  case 'E':                      {                          var precision = digits != -1 ? digits : 6;                            if (value.InternalBits == null)                          {                              return value.InternalSign.ToString(format' info);                          }                            var scale = (int)Math.Floor(Log10(value));                          // ---                          if (scale > precision + 10)                          {                              do                              {                                  value /= 1000000000;                              } while (Log10(value) > precision + 10);                          }                            while (Log10(value) > precision + 2)                          {                              value /= 10;                          }                            if (Log10(value) > precision + 1)                          {                              var round = value % 10 >= 5;                              value = (value / 10) + (round ? One : Zero);                          }                            ReverseStringBuilder builder;                            if (value.InternalBits == null)                          {                              builder = new ReverseStringBuilder(10);                              builder.Prepend($"{value.InternalSign:D}");                          }                          else                          {                              builder = CreateBuilder(value' info' false' 0);                          }                            // ---                          var decimalSeparator = info.NumberDecimalSeparator;                            var result = new StringBuilder(builder.Length + 6);                            var extra = 0;                            if (precision >= builder.Length)                          {                              extra = precision - (builder.Length - 1);                              precision = builder.Length - 1;                          }                            result.Append(builder.ToString(builder.Length' 1));                          result.Append(decimalSeparator);                          result.Append(builder.ToString(builder.Length - 1' precision));                          result.Append(new string('0'' extra));                          result.Append(fmt);                          result.Append(info.PositiveSign);                          if (scale < 10)                          {                              result.Append("00");                          }                          else if (scale < 100)                          {                              result.Append('0');                          }                            result.Append(scale);                            return result.ToString();                      }                  default:                      {                          var decimalFmt = fmt == 'g' || fmt == 'G' || fmt == 'd' || fmt == 'D' || fmt == 'r' || fmt == 'R';                          if (value.InternalBits == null)                          {                              if (fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R')                              {                                  format = digits > 0 ? "D" + digits.ToString(CultureInfo.InvariantCulture) : "D";                              }                                return value.InternalSign.ToString(format' info);                          }                            var builder = CreateBuilder(value' info' decimalFmt' digits);                          if (decimalFmt)                          {                              // Format Round-trip decimal                              // This format is supported for integral types only. The number is converted to a string of                              // decimal digits (0-9)' prefixed by a minus sign if the number is negative. The precision                              // specifier indicates the minimum number of digits desired in the resulting string. If required'                              // the number is padded with zeros to its left to produce the number of digits given by the                              // precision specifier.                              while (digits > 0 && digits >= builder.Length)                              {                                  builder.Prepend('0');                                  digits--;                              }                                if (value.InternalSign < 0)                              {                                  builder.Prepend(info.NegativeSign);                              }                                return builder.ToString();                          }                            // 'c'' 'C'' 'e'' 'E'' 'f'' 'F'' 'n'' 'N'' 'p'' 'P'' custom                          var precision = -1;                          var groupingSizes = new[] { 3 };                          var groupingSeparator = info.NumberGroupSeparator;                          var decimalSeparator = info.NumberDecimalSeparator;                          var groups = false;                          var type = 0;                          switch (fmt)                          {                              case '\0':                                  // parse custom                                  break;                                case 'c':                              case 'C':                                  decimalSeparator = info.CurrencyDecimalSeparator;                                  precision = digits != -1 ? digits : info.CurrencyDecimalDigits;                                  groupingSeparator = info.CurrencyGroupSeparator;                                  groupingSizes = info.CurrencyGroupSizes;                                  groups = true;                                  type = 1;                                  break;                                case 'f':                              case 'F':                                  precision = digits != -1 ? digits : info.NumberDecimalDigits;                                  break;                                case 'n':                              case 'N':                                  precision = digits != -1 ? digits : info.NumberDecimalDigits;                                  groups = true;                                  break;                                case 'p':                              case 'P':                                  decimalSeparator = info.PercentDecimalSeparator;                                  precision = digits != -1 ? digits : info.PercentDecimalDigits;                                  groups = true;                                  type = 2;                                  break;                                default:                                  throw new NotSupportedException();                          }                            var result = new StringBuilder(builder.Length + 20);                          var close = SetWrap(value' info' type' result);                          var append = builder;                          if (groups)                          {                              var extra = groupingSizes.Length - 1;                              if (groupingSizes[groupingSizes.Length - 1] != 0)                              {                                  var totalDigits = builder.Length;                                  extra += (int)Math.Ceiling(totalDigits * 1.0 / groupingSizes[groupingSizes.Length - 1]);                              }                                var length = extra + builder.Length;                              if (type == 2)                              {                                  length += 2;                                  append = StringWithGroups(length' new ExtendedEnumerable<char>(new[] { '0'' '0' }' builder)' groupingSizes' groupingSeparator);                              }                              else                              {                                  append = StringWithGroups(length' builder' groupingSizes' groupingSeparator);                              }                          }                            result.Append(append);                          if (precision > 0)                          {                              result.Append(decimalSeparator);                              result.Append(new string('0'' precision));                          }                            result.Append(close);                          return result.ToString();                      }              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,FormatBigInteger,The following statement contains a magic number: switch (fmt)              {                  case 'x':                  case 'X':                      return FormatBigIntegerToHexString(value' fmt' digits' info);                    case 'e':                  case 'E':                      {                          var precision = digits != -1 ? digits : 6;                            if (value.InternalBits == null)                          {                              return value.InternalSign.ToString(format' info);                          }                            var scale = (int)Math.Floor(Log10(value));                          // ---                          if (scale > precision + 10)                          {                              do                              {                                  value /= 1000000000;                              } while (Log10(value) > precision + 10);                          }                            while (Log10(value) > precision + 2)                          {                              value /= 10;                          }                            if (Log10(value) > precision + 1)                          {                              var round = value % 10 >= 5;                              value = (value / 10) + (round ? One : Zero);                          }                            ReverseStringBuilder builder;                            if (value.InternalBits == null)                          {                              builder = new ReverseStringBuilder(10);                              builder.Prepend($"{value.InternalSign:D}");                          }                          else                          {                              builder = CreateBuilder(value' info' false' 0);                          }                            // ---                          var decimalSeparator = info.NumberDecimalSeparator;                            var result = new StringBuilder(builder.Length + 6);                            var extra = 0;                            if (precision >= builder.Length)                          {                              extra = precision - (builder.Length - 1);                              precision = builder.Length - 1;                          }                            result.Append(builder.ToString(builder.Length' 1));                          result.Append(decimalSeparator);                          result.Append(builder.ToString(builder.Length - 1' precision));                          result.Append(new string('0'' extra));                          result.Append(fmt);                          result.Append(info.PositiveSign);                          if (scale < 10)                          {                              result.Append("00");                          }                          else if (scale < 100)                          {                              result.Append('0');                          }                            result.Append(scale);                            return result.ToString();                      }                  default:                      {                          var decimalFmt = fmt == 'g' || fmt == 'G' || fmt == 'd' || fmt == 'D' || fmt == 'r' || fmt == 'R';                          if (value.InternalBits == null)                          {                              if (fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R')                              {                                  format = digits > 0 ? "D" + digits.ToString(CultureInfo.InvariantCulture) : "D";                              }                                return value.InternalSign.ToString(format' info);                          }                            var builder = CreateBuilder(value' info' decimalFmt' digits);                          if (decimalFmt)                          {                              // Format Round-trip decimal                              // This format is supported for integral types only. The number is converted to a string of                              // decimal digits (0-9)' prefixed by a minus sign if the number is negative. The precision                              // specifier indicates the minimum number of digits desired in the resulting string. If required'                              // the number is padded with zeros to its left to produce the number of digits given by the                              // precision specifier.                              while (digits > 0 && digits >= builder.Length)                              {                                  builder.Prepend('0');                                  digits--;                              }                                if (value.InternalSign < 0)                              {                                  builder.Prepend(info.NegativeSign);                              }                                return builder.ToString();                          }                            // 'c'' 'C'' 'e'' 'E'' 'f'' 'F'' 'n'' 'N'' 'p'' 'P'' custom                          var precision = -1;                          var groupingSizes = new[] { 3 };                          var groupingSeparator = info.NumberGroupSeparator;                          var decimalSeparator = info.NumberDecimalSeparator;                          var groups = false;                          var type = 0;                          switch (fmt)                          {                              case '\0':                                  // parse custom                                  break;                                case 'c':                              case 'C':                                  decimalSeparator = info.CurrencyDecimalSeparator;                                  precision = digits != -1 ? digits : info.CurrencyDecimalDigits;                                  groupingSeparator = info.CurrencyGroupSeparator;                                  groupingSizes = info.CurrencyGroupSizes;                                  groups = true;                                  type = 1;                                  break;                                case 'f':                              case 'F':                                  precision = digits != -1 ? digits : info.NumberDecimalDigits;                                  break;                                case 'n':                              case 'N':                                  precision = digits != -1 ? digits : info.NumberDecimalDigits;                                  groups = true;                                  break;                                case 'p':                              case 'P':                                  decimalSeparator = info.PercentDecimalSeparator;                                  precision = digits != -1 ? digits : info.PercentDecimalDigits;                                  groups = true;                                  type = 2;                                  break;                                default:                                  throw new NotSupportedException();                          }                            var result = new StringBuilder(builder.Length + 20);                          var close = SetWrap(value' info' type' result);                          var append = builder;                          if (groups)                          {                              var extra = groupingSizes.Length - 1;                              if (groupingSizes[groupingSizes.Length - 1] != 0)                              {                                  var totalDigits = builder.Length;                                  extra += (int)Math.Ceiling(totalDigits * 1.0 / groupingSizes[groupingSizes.Length - 1]);                              }                                var length = extra + builder.Length;                              if (type == 2)                              {                                  length += 2;                                  append = StringWithGroups(length' new ExtendedEnumerable<char>(new[] { '0'' '0' }' builder)' groupingSizes' groupingSeparator);                              }                              else                              {                                  append = StringWithGroups(length' builder' groupingSizes' groupingSeparator);                              }                          }                            result.Append(append);                          if (precision > 0)                          {                              result.Append(decimalSeparator);                              result.Append(new string('0'' precision));                          }                            result.Append(close);                          return result.ToString();                      }              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,FormatBigInteger,The following statement contains a magic number: switch (fmt)              {                  case 'x':                  case 'X':                      return FormatBigIntegerToHexString(value' fmt' digits' info);                    case 'e':                  case 'E':                      {                          var precision = digits != -1 ? digits : 6;                            if (value.InternalBits == null)                          {                              return value.InternalSign.ToString(format' info);                          }                            var scale = (int)Math.Floor(Log10(value));                          // ---                          if (scale > precision + 10)                          {                              do                              {                                  value /= 1000000000;                              } while (Log10(value) > precision + 10);                          }                            while (Log10(value) > precision + 2)                          {                              value /= 10;                          }                            if (Log10(value) > precision + 1)                          {                              var round = value % 10 >= 5;                              value = (value / 10) + (round ? One : Zero);                          }                            ReverseStringBuilder builder;                            if (value.InternalBits == null)                          {                              builder = new ReverseStringBuilder(10);                              builder.Prepend($"{value.InternalSign:D}");                          }                          else                          {                              builder = CreateBuilder(value' info' false' 0);                          }                            // ---                          var decimalSeparator = info.NumberDecimalSeparator;                            var result = new StringBuilder(builder.Length + 6);                            var extra = 0;                            if (precision >= builder.Length)                          {                              extra = precision - (builder.Length - 1);                              precision = builder.Length - 1;                          }                            result.Append(builder.ToString(builder.Length' 1));                          result.Append(decimalSeparator);                          result.Append(builder.ToString(builder.Length - 1' precision));                          result.Append(new string('0'' extra));                          result.Append(fmt);                          result.Append(info.PositiveSign);                          if (scale < 10)                          {                              result.Append("00");                          }                          else if (scale < 100)                          {                              result.Append('0');                          }                            result.Append(scale);                            return result.ToString();                      }                  default:                      {                          var decimalFmt = fmt == 'g' || fmt == 'G' || fmt == 'd' || fmt == 'D' || fmt == 'r' || fmt == 'R';                          if (value.InternalBits == null)                          {                              if (fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R')                              {                                  format = digits > 0 ? "D" + digits.ToString(CultureInfo.InvariantCulture) : "D";                              }                                return value.InternalSign.ToString(format' info);                          }                            var builder = CreateBuilder(value' info' decimalFmt' digits);                          if (decimalFmt)                          {                              // Format Round-trip decimal                              // This format is supported for integral types only. The number is converted to a string of                              // decimal digits (0-9)' prefixed by a minus sign if the number is negative. The precision                              // specifier indicates the minimum number of digits desired in the resulting string. If required'                              // the number is padded with zeros to its left to produce the number of digits given by the                              // precision specifier.                              while (digits > 0 && digits >= builder.Length)                              {                                  builder.Prepend('0');                                  digits--;                              }                                if (value.InternalSign < 0)                              {                                  builder.Prepend(info.NegativeSign);                              }                                return builder.ToString();                          }                            // 'c'' 'C'' 'e'' 'E'' 'f'' 'F'' 'n'' 'N'' 'p'' 'P'' custom                          var precision = -1;                          var groupingSizes = new[] { 3 };                          var groupingSeparator = info.NumberGroupSeparator;                          var decimalSeparator = info.NumberDecimalSeparator;                          var groups = false;                          var type = 0;                          switch (fmt)                          {                              case '\0':                                  // parse custom                                  break;                                case 'c':                              case 'C':                                  decimalSeparator = info.CurrencyDecimalSeparator;                                  precision = digits != -1 ? digits : info.CurrencyDecimalDigits;                                  groupingSeparator = info.CurrencyGroupSeparator;                                  groupingSizes = info.CurrencyGroupSizes;                                  groups = true;                                  type = 1;                                  break;                                case 'f':                              case 'F':                                  precision = digits != -1 ? digits : info.NumberDecimalDigits;                                  break;                                case 'n':                              case 'N':                                  precision = digits != -1 ? digits : info.NumberDecimalDigits;                                  groups = true;                                  break;                                case 'p':                              case 'P':                                  decimalSeparator = info.PercentDecimalSeparator;                                  precision = digits != -1 ? digits : info.PercentDecimalDigits;                                  groups = true;                                  type = 2;                                  break;                                default:                                  throw new NotSupportedException();                          }                            var result = new StringBuilder(builder.Length + 20);                          var close = SetWrap(value' info' type' result);                          var append = builder;                          if (groups)                          {                              var extra = groupingSizes.Length - 1;                              if (groupingSizes[groupingSizes.Length - 1] != 0)                              {                                  var totalDigits = builder.Length;                                  extra += (int)Math.Ceiling(totalDigits * 1.0 / groupingSizes[groupingSizes.Length - 1]);                              }                                var length = extra + builder.Length;                              if (type == 2)                              {                                  length += 2;                                  append = StringWithGroups(length' new ExtendedEnumerable<char>(new[] { '0'' '0' }' builder)' groupingSizes' groupingSeparator);                              }                              else                              {                                  append = StringWithGroups(length' builder' groupingSizes' groupingSeparator);                              }                          }                            result.Append(append);                          if (precision > 0)                          {                              result.Append(decimalSeparator);                              result.Append(new string('0'' precision));                          }                            result.Append(close);                          return result.ToString();                      }              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,FormatBigInteger,The following statement contains a magic number: switch (fmt)              {                  case 'x':                  case 'X':                      return FormatBigIntegerToHexString(value' fmt' digits' info);                    case 'e':                  case 'E':                      {                          var precision = digits != -1 ? digits : 6;                            if (value.InternalBits == null)                          {                              return value.InternalSign.ToString(format' info);                          }                            var scale = (int)Math.Floor(Log10(value));                          // ---                          if (scale > precision + 10)                          {                              do                              {                                  value /= 1000000000;                              } while (Log10(value) > precision + 10);                          }                            while (Log10(value) > precision + 2)                          {                              value /= 10;                          }                            if (Log10(value) > precision + 1)                          {                              var round = value % 10 >= 5;                              value = (value / 10) + (round ? One : Zero);                          }                            ReverseStringBuilder builder;                            if (value.InternalBits == null)                          {                              builder = new ReverseStringBuilder(10);                              builder.Prepend($"{value.InternalSign:D}");                          }                          else                          {                              builder = CreateBuilder(value' info' false' 0);                          }                            // ---                          var decimalSeparator = info.NumberDecimalSeparator;                            var result = new StringBuilder(builder.Length + 6);                            var extra = 0;                            if (precision >= builder.Length)                          {                              extra = precision - (builder.Length - 1);                              precision = builder.Length - 1;                          }                            result.Append(builder.ToString(builder.Length' 1));                          result.Append(decimalSeparator);                          result.Append(builder.ToString(builder.Length - 1' precision));                          result.Append(new string('0'' extra));                          result.Append(fmt);                          result.Append(info.PositiveSign);                          if (scale < 10)                          {                              result.Append("00");                          }                          else if (scale < 100)                          {                              result.Append('0');                          }                            result.Append(scale);                            return result.ToString();                      }                  default:                      {                          var decimalFmt = fmt == 'g' || fmt == 'G' || fmt == 'd' || fmt == 'D' || fmt == 'r' || fmt == 'R';                          if (value.InternalBits == null)                          {                              if (fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R')                              {                                  format = digits > 0 ? "D" + digits.ToString(CultureInfo.InvariantCulture) : "D";                              }                                return value.InternalSign.ToString(format' info);                          }                            var builder = CreateBuilder(value' info' decimalFmt' digits);                          if (decimalFmt)                          {                              // Format Round-trip decimal                              // This format is supported for integral types only. The number is converted to a string of                              // decimal digits (0-9)' prefixed by a minus sign if the number is negative. The precision                              // specifier indicates the minimum number of digits desired in the resulting string. If required'                              // the number is padded with zeros to its left to produce the number of digits given by the                              // precision specifier.                              while (digits > 0 && digits >= builder.Length)                              {                                  builder.Prepend('0');                                  digits--;                              }                                if (value.InternalSign < 0)                              {                                  builder.Prepend(info.NegativeSign);                              }                                return builder.ToString();                          }                            // 'c'' 'C'' 'e'' 'E'' 'f'' 'F'' 'n'' 'N'' 'p'' 'P'' custom                          var precision = -1;                          var groupingSizes = new[] { 3 };                          var groupingSeparator = info.NumberGroupSeparator;                          var decimalSeparator = info.NumberDecimalSeparator;                          var groups = false;                          var type = 0;                          switch (fmt)                          {                              case '\0':                                  // parse custom                                  break;                                case 'c':                              case 'C':                                  decimalSeparator = info.CurrencyDecimalSeparator;                                  precision = digits != -1 ? digits : info.CurrencyDecimalDigits;                                  groupingSeparator = info.CurrencyGroupSeparator;                                  groupingSizes = info.CurrencyGroupSizes;                                  groups = true;                                  type = 1;                                  break;                                case 'f':                              case 'F':                                  precision = digits != -1 ? digits : info.NumberDecimalDigits;                                  break;                                case 'n':                              case 'N':                                  precision = digits != -1 ? digits : info.NumberDecimalDigits;                                  groups = true;                                  break;                                case 'p':                              case 'P':                                  decimalSeparator = info.PercentDecimalSeparator;                                  precision = digits != -1 ? digits : info.PercentDecimalDigits;                                  groups = true;                                  type = 2;                                  break;                                default:                                  throw new NotSupportedException();                          }                            var result = new StringBuilder(builder.Length + 20);                          var close = SetWrap(value' info' type' result);                          var append = builder;                          if (groups)                          {                              var extra = groupingSizes.Length - 1;                              if (groupingSizes[groupingSizes.Length - 1] != 0)                              {                                  var totalDigits = builder.Length;                                  extra += (int)Math.Ceiling(totalDigits * 1.0 / groupingSizes[groupingSizes.Length - 1]);                              }                                var length = extra + builder.Length;                              if (type == 2)                              {                                  length += 2;                                  append = StringWithGroups(length' new ExtendedEnumerable<char>(new[] { '0'' '0' }' builder)' groupingSizes' groupingSeparator);                              }                              else                              {                                  append = StringWithGroups(length' builder' groupingSizes' groupingSeparator);                              }                          }                            result.Append(append);                          if (precision > 0)                          {                              result.Append(decimalSeparator);                              result.Append(new string('0'' precision));                          }                            result.Append(close);                          return result.ToString();                      }              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,ParseFormatSpecifier,The following statement contains a magic number: digits = (digits * 10) + (format[index] - '0');
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,ParseNumber,The following statement contains a magic number: number.Scale += (exponentNegative ? -1 : 1) * (input.Length > 4 ? 9999 : exponentMagnitude);
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,ParseNumber,The following statement contains a magic number: number.Scale += (exponentNegative ? -1 : 1) * (input.Length > 4 ? 9999 : exponentMagnitude);
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,TryValidateParseStyleInteger,The following statement contains a magic number: ((int)style & -1024) != (int)NumberStyles.None
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,CreateBuilder,The following statement contains a magic number: const uint numericBase = 1000000000;
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,CreateBuilder,The following statement contains a magic number: const int numericBaseLog10 = 9;
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,CreateBuilder,The following statement contains a magic number: maxConvertedLength = checked((sourceLength * 10 / 9) + 2);
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,CreateBuilder,The following statement contains a magic number: maxConvertedLength = checked((sourceLength * 10 / 9) + 2);
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,CreateBuilder,The following statement contains a magic number: maxConvertedLength = checked((sourceLength * 10 / 9) + 2);
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,CreateBuilder,The following statement contains a magic number: result.Prepend((char)('0' + (cipherBlock % 10)));
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,CreateBuilder,The following statement contains a magic number: cipherBlock /= 10;
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,CreateBuilder,The following statement contains a magic number: result.Prepend((char)('0' + (cipherBlock % 10)));
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,CreateBuilder,The following statement contains a magic number: cipherBlock /= 10;
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,FormatBigIntegerToHexString,The following statement contains a magic number: var stringBuilder = new StringBuilder((byteArray.Length * 2) + 1);
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,FormatBigIntegerToHexString,The following statement contains a magic number: num = (byte)(num - 240);
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,FormatBigIntegerToHexString,The following statement contains a magic number: num > 247
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,FormatBigIntegerToHexString,The following statement contains a magic number: num < 8 || flag
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,HexNumberToBigInteger,The following statement contains a magic number: var bits = new byte[(len / 2) + (len % 2)];
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,HexNumberToBigInteger,The following statement contains a magic number: var bits = new byte[(len / 2) + (len % 2)];
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,HexNumberToBigInteger,The following statement contains a magic number: bits[bitIndex] = (byte)(bits[bitIndex] | (b << 4));
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,NumberToBigInteger,The following statement contains a magic number: value *= 10;
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,NumberToBigInteger,The following statement contains a magic number: value *= 1000000000;
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,NumberToBigInteger,The following statement contains a magic number: adjust -= 9;
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,NumberToBigInteger,The following statement contains a magic number: adjust > 9
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,NumberToBigInteger,The following statement contains a magic number: value *= 10;
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(' ');                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                                default:                                  break;                          }                      }                        break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                default:                                  break;                          }                      }                        break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                        break;              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(' ');                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                                default:                                  break;                          }                      }                        break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                default:                                  break;                          }                      }                        break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                        break;              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(' ');                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                                default:                                  break;                          }                      }                        break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                default:                                  break;                          }                      }                        break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                        break;              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(' ');                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                                default:                                  break;                          }                      }                        break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                default:                                  break;                          }                      }                        break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                        break;              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(' ');                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                                default:                                  break;                          }                      }                        break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                default:                                  break;                          }                      }                        break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                        break;              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(' ');                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                                default:                                  break;                          }                      }                        break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                default:                                  break;                          }                      }                        break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                        break;              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(' ');                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                                default:                                  break;                          }                      }                        break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                default:                                  break;                          }                      }                        break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                        break;              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(' ');                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                                default:                                  break;                          }                      }                        break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                default:                                  break;                          }                      }                        break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                        break;              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(' ');                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                                default:                                  break;                          }                      }                        break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                default:                                  break;                          }                      }                        break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                        break;              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(' ');                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                                default:                                  break;                          }                      }                        break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                default:                                  break;                          }                      }                        break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                        break;              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(' ');                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                                default:                                  break;                          }                      }                        break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                default:                                  break;                          }                      }                        break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                        break;              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(' ');                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                                default:                                  break;                          }                      }                        break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                default:                                  break;                          }                      }                        break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                        break;              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(' ');                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                                default:                                  break;                          }                      }                        break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                default:                                  break;                          }                      }                        break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                        break;              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(' ');                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                                default:                                  break;                          }                      }                        break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                default:                                  break;                          }                      }                        break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                        break;              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(' ');                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                                default:                                  break;                          }                      }                        break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                default:                                  break;                          }                      }                        break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                        break;              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(' ');                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                                default:                                  break;                          }                      }                        break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                default:                                  break;                          }                      }                        break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                        break;              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(' ');                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                                default:                                  break;                          }                      }                        break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                default:                                  break;                          }                      }                        break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                        break;              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(' ');                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                                default:                                  break;                          }                      }                        break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                default:                                  break;                          }                      }                        break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                        break;              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(' ');                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                                default:                                  break;                          }                      }                        break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                default:                                  break;                          }                      }                        break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                        break;              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(' ');                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                                default:                                  break;                          }                      }                        break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                default:                                  break;                          }                      }                        break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                        break;              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(' ');                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                                default:                                  break;                          }                      }                        break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                default:                                  break;                          }                      }                        break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                        break;              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(' ');                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                                default:                                  break;                          }                      }                        break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                default:                                  break;                          }                      }                        break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                        break;              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(' ');                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                                default:                                  break;                          }                      }                        break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                default:                                  break;                          }                      }                        break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                        break;              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(' ');                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                                default:                                  break;                          }                      }                        break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                default:                                  break;                          }                      }                        break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                        break;              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(' ');                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                                default:                                  break;                          }                      }                        break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                default:                                  break;                          }                      }                        break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                        break;              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(' ');                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                                default:                                  break;                          }                      }                        break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                default:                                  break;                          }                      }                        break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                        break;              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(' ');                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                                default:                                  break;                          }                      }                        break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                default:                                  break;                          }                      }                        break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                        break;              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(' ');                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                                default:                                  break;                          }                      }                        break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                default:                                  break;                          }                      }                        break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                        break;              }
Magic Number,System.Numerics,BigInteger,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigInteger.cs,SetWrap,The following statement contains a magic number: switch (type)              {                  case 1:                      if (value.InternalSign < 0)                      {                          switch (info.CurrencyNegativePattern)                          {                              case 0:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  close = ")";                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 3:                                  result.Append(info.CurrencySymbol);                                  close = info.NegativeSign;                                  break;                                case 4:                                  result.Append('(');                                  close = info.CurrencySymbol + ")";                                  break;                                case 5:                                  result.Append(info.NegativeSign);                                  close = info.CurrencySymbol;                                  break;                                case 6:                                  close = info.NegativeSign + info.CurrencySymbol;                                  break;                                case 7:                                  close = info.CurrencySymbol + info.NegativeSign;                                  break;                                case 8:                                  result.Append(info.NegativeSign);                                  close = " " + info.CurrencySymbol;                                  break;                                case 9:                                  result.Append(info.NegativeSign);                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 10:                                  close = " " + info.CurrencySymbol + info.NegativeSign;                                  break;                                case 11:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 12:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 13:                                  result.Append(info.CurrencySymbol);                                  result.Append(info.NegativeSign);                                  result.Append(' ');                                  break;                                case 14:                                  result.Append('(');                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  close = ")";                                  break;                                case 15:                                  result.Append('(');                                  close = " " + info.CurrencySymbol + ")";                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  result.Append(info.CurrencySymbol);                                  break;                                case 1:                                  close = info.CurrencySymbol;                                  break;                                case 2:                                  result.Append(info.CurrencySymbol);                                  result.Append(' ');                                  break;                                case 3:                                  close = " " + info.CurrencySymbol;                                  break;                                default:                                  break;                          }                      }                        break;                    case 2:                      if (value.InternalSign < 0)                      {                          switch (info.PercentNegativePattern)                          {                              case 0:                                  result.Append(info.NegativeSign);                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  result.Append(info.NegativeSign);                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(info.NegativeSign);                                  break;                                case 4:                                  result.Append(info.PercentSymbol);                                  close = info.NegativeSign;                                  break;                                case 5:                                  close = info.NegativeSign + info.PercentSymbol;                                  break;                                case 6:                                  close = info.PercentSymbol + info.NegativeSign;                                  break;                                case 7:                                  result.Append(info.NegativeSign);                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                case 8:                                  close = " " + info.PercentSymbol + info.NegativeSign;                                  break;                                case 9:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  close = info.NegativeSign;                                  break;                                case 10:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  result.Append(info.NegativeSign);                                  break;                                case 11:                                  close = info.NegativeSign + " " + info.PercentSymbol;                                  break;                                default:                                  break;                          }                      }                      else                      {                          switch (info.CurrencyPositivePattern)                          {                              case 0:                                  close = " " + info.PercentSymbol;                                  break;                                case 1:                                  close = info.PercentSymbol;                                  break;                                case 2:                                  result.Append(info.PercentSymbol);                                  break;                                case 3:                                  result.Append(info.PercentSymbol);                                  result.Append(' ');                                  break;                                default:                                  break;                          }                      }                        break;                    default:                      if (value.InternalSign < 0)                      {                          result.Append(info.NegativeSign);                      }                        break;              }
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,BigIntegerBuilder,The following statement contains a magic number: var num1 = num >> 31;
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,Add,The following statement contains a magic number: SetSizeLazy(2);
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,CbitLowZero,The following statement contains a magic number: return num1 + (num * 32);
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,GetApproxParts,The following statement contains a magic number: exp = num * 32;
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,GetApproxParts,The following statement contains a magic number: man = (man << num1) | (_bits[num - 1] >> (32 - num1));
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,Mul,The following statement contains a magic number: SetSizeKeep(_iuLast + 2' 0);
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,Set,The following statement contains a magic number: SetSizeLazy(2);
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,ShiftLeft,The following statement contains a magic number: ShiftLeft(cbit / 32' cbit % 32);
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,ShiftLeft,The following statement contains a magic number: ShiftLeft(cbit / 32' cbit % 32);
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,ShiftLeft,The following statement contains a magic number: high = High >> ((32 - cbitShift) & 31);
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,ShiftLeft,The following statement contains a magic number: high = High >> ((32 - cbitShift) & 31);
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,ShiftLeft,The following statement contains a magic number: _uSmall <<= cbitShift & 31;
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,ShiftLeft,The following statement contains a magic number: _bits[cuShift] = _uSmall << (cbitShift & 31);
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,ShiftRight,The following statement contains a magic number: ShiftRight(cbit / 32' cbit % 32);
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,ShiftRight,The following statement contains a magic number: ShiftRight(cbit / 32' cbit % 32);
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,ShiftRight,The following statement contains a magic number: _uSmall >>= cbitShift & 31;
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,GetIntegerParts,The following statement contains a magic number: _uSmall <= 2147483647
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,AddCarry,The following statement contains a magic number: return (uint)(num >> 32);
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,AddMulCarry,The following statement contains a magic number: return (uint)(num >> 32);
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,LehmerGcd,The following statement contains a magic number: num1 == 2
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,LehmerGcd,The following statement contains a magic number: high2 = (high2 << (num3 & 63)) | (reg1._bits![num1 - 3] >> ((32 - num3) & 31));
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,LehmerGcd,The following statement contains a magic number: high2 = (high2 << (num3 & 63)) | (reg1._bits![num1 - 3] >> ((32 - num3) & 31));
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,LehmerGcd,The following statement contains a magic number: high2 = (high2 << (num3 & 63)) | (reg1._bits![num1 - 3] >> ((32 - num3) & 31));
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,LehmerGcd,The following statement contains a magic number: high2 = (high2 << (num3 & 63)) | (reg1._bits![num1 - 3] >> ((32 - num3) & 31));
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,LehmerGcd,The following statement contains a magic number: high21 = (high21 << (num3 & 63)) | (reg2._bits![num1 - 3] >> ((32 - num3) & 31));
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,LehmerGcd,The following statement contains a magic number: high21 = (high21 << (num3 & 63)) | (reg2._bits![num1 - 3] >> ((32 - num3) & 31));
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,LehmerGcd,The following statement contains a magic number: high21 = (high21 << (num3 & 63)) | (reg2._bits![num1 - 3] >> ((32 - num3) & 31));
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,LehmerGcd,The following statement contains a magic number: high21 = (high21 << (num3 & 63)) | (reg2._bits![num1 - 3] >> ((32 - num3) & 31));
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,LehmerGcd,The following statement contains a magic number: num2 > num1 - 2
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,LehmerGcd,The following statement contains a magic number: reg1.Set(NumericHelper.GCD(reg1.GetHigh2(2)' reg2.GetHigh2(2)));
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,LehmerGcd,The following statement contains a magic number: reg1.Set(NumericHelper.GCD(reg1.GetHigh2(2)' reg2.GetHigh2(2)));
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,ModDivCore,The following statement contains a magic number: var num6 = regDen._bits[num1 - 2];
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,ModDivCore,The following statement contains a magic number: var num8 = 32 - num7;
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,ModDivCore,The following statement contains a magic number: num5 = (num5 << (num7 & 31)) | (num6 >> (num8 & 31));
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,ModDivCore,The following statement contains a magic number: num5 = (num5 << (num7 & 31)) | (num6 >> (num8 & 31));
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,ModDivCore,The following statement contains a magic number: num6 <<= num7 & 31;
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,ModDivCore,The following statement contains a magic number: num6 |= regDen._bits[num1 - 3] >> (num8 & 31);
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,ModDivCore,The following statement contains a magic number: num6 |= regDen._bits[num1 - 3] >> (num8 & 31);
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,ModDivCore,The following statement contains a magic number: num1 > 2
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,ModDivCore,The following statement contains a magic number: var num13 = regNum._bits[num9 + num1 - 2];
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,ModDivCore,The following statement contains a magic number: num12 = (num12 << (num7 & 63)) | (num13 >> (num8 & 31));
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,ModDivCore,The following statement contains a magic number: num12 = (num12 << (num7 & 63)) | (num13 >> (num8 & 31));
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,ModDivCore,The following statement contains a magic number: num13 <<= num7 & 31;
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,ModDivCore,The following statement contains a magic number: num13 |= regNum._bits[num9 + num1 - 3] >> (num8 & 31);
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,ModDivCore,The following statement contains a magic number: num13 |= regNum._bits[num9 + num1 - 3] >> (num8 & 31);
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,ModDivCore,The following statement contains a magic number: num9 + num1 >= 3
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,ModDivCore,The following statement contains a magic number: num16 >>= 32;
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,MulCarry,The following statement contains a magic number: return (uint)(num >> 32);
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,SubBorrow,The following statement contains a magic number: return (uint)-(int)(num >> 32);
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,SubRevBorrow,The following statement contains a magic number: return (uint)-(int)(num >> 32);
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,GetHigh2,The following statement contains a magic number: return NumericHelper.BuildUInt64(_bits![cu - 1]' _bits[cu - 2]);
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,GetHigh2,The following statement contains a magic number: return cu - 2 != _iuLast ? 0 : _bits![cu - 2];
Magic Number,System.Numerics,BigIntegerBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BigIntegerBuilder.cs,GetHigh2,The following statement contains a magic number: return cu - 2 != _iuLast ? 0 : _bits![cu - 2];
Magic Number,System.Numerics,BitOperations,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BitOperations.cs,LeadingZeroCount,The following statement contains a magic number: return 32;
Magic Number,System.Numerics,BitOperations,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BitOperations.cs,LeadingZeroCount,The following statement contains a magic number: return 31 - Log2SoftwareFallback(value);
Magic Number,System.Numerics,BitOperations,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BitOperations.cs,LeadingZeroCount,The following statement contains a magic number: var hi = (uint)(value >> 32);
Magic Number,System.Numerics,BitOperations,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BitOperations.cs,LeadingZeroCount,The following statement contains a magic number: return 32 + LeadingZeroCount((uint)value);
Magic Number,System.Numerics,BitOperations,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BitOperations.cs,Log2,The following statement contains a magic number: var hi = (uint)(value >> 32);
Magic Number,System.Numerics,BitOperations,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BitOperations.cs,Log2,The following statement contains a magic number: return 32 + Log2(hi);
Magic Number,System.Numerics,BitOperations,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BitOperations.cs,PopCount,The following statement contains a magic number: value = (value & c2) + ((value >> 2) & c2);
Magic Number,System.Numerics,BitOperations,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BitOperations.cs,PopCount,The following statement contains a magic number: value = (((value + (value >> 4)) & c3) * c4) >> 24;
Magic Number,System.Numerics,BitOperations,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BitOperations.cs,PopCount,The following statement contains a magic number: value = (((value + (value >> 4)) & c3) * c4) >> 24;
Magic Number,System.Numerics,BitOperations,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BitOperations.cs,PopCount,The following statement contains a magic number: value = (value & c2) + ((value >> 2) & c2);
Magic Number,System.Numerics,BitOperations,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BitOperations.cs,PopCount,The following statement contains a magic number: value = (((value + (value >> 4)) & c3) * c4) >> 56;
Magic Number,System.Numerics,BitOperations,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BitOperations.cs,PopCount,The following statement contains a magic number: value = (((value + (value >> 4)) & c3) * c4) >> 56;
Magic Number,System.Numerics,BitOperations,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BitOperations.cs,TrailingZeroCount,The following statement contains a magic number: return 32 + TrailingZeroCount((uint)(value >> 32));
Magic Number,System.Numerics,BitOperations,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\BitOperations.cs,TrailingZeroCount,The following statement contains a magic number: return 32 + TrailingZeroCount((uint)(value >> 32));
Magic Number,System.Numerics,Complex,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\Complex.cs,Atan,The following statement contains a magic number: return ImaginaryOne / new Complex(2' 0) * (Log(One - (ImaginaryOne * value)) - Log(One + (ImaginaryOne * value)));
Magic Number,System.Numerics,Complex,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\Complex.cs,Log10,The following statement contains a magic number: return Log(value' 10);
Magic Number,System.Numerics,Complex,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\Complex.cs,Sqrt,The following statement contains a magic number: return FromPolarCoordinates(Math.Sqrt(value.Magnitude)' value.Phase / 2);
Magic Number,System.Numerics,NumericsHelpers,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\NumericsHelpers.cs,CombineHash,The following statement contains a magic number: return ((u1 << 7) | (u1 >> 25)) ^ u2;
Magic Number,System.Numerics,NumericsHelpers,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Numerics\NumericsHelpers.cs,CombineHash,The following statement contains a magic number: return ((u1 << 7) | (u1 >> 25)) ^ u2;
Magic Number,System.Threading,Barrier,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Barrier.cs,AddParticipants,The following statement contains a magic number: newPhase = sense != (currentPhaseNumber % 2 == 0) ? currentPhaseNumber + 1 : currentPhaseNumber;
Magic Number,System.Threading,Barrier,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Barrier.cs,SignalAndWait,The following statement contains a magic number: current == 0 && sense != (CurrentPhaseNumber % 2 == 0)
Magic Number,System.Threading,Barrier,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Barrier.cs,GetCurrentTotal,The following statement contains a magic number: current = (currentTotal & _currentMask) >> 16;
Magic Number,System.Threading,Barrier,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Barrier.cs,DiscontinuousWait,The following statement contains a magic number: var maxWait = 100;
Magic Number,System.Threading,Barrier,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Barrier.cs,DiscontinuousWait,The following statement contains a magic number: const int waitTimeCeiling = 10000;
Magic Number,System.Threading,Barrier,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Barrier.cs,SetCurrentTotal,The following statement contains a magic number: var newCurrentTotal = (current << 16) | total;
Magic Number,System.Threading,ManualResetEventSlim,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\ManualResetEventSlim.cs,ManualResetEventSlim,The following statement contains a magic number: spinCount < 0 || spinCount > 2047
Magic Number,System.Threading,ReaderWriterLockSlim,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\ReaderWriterLockSlim.cs,ReaderWriterLockSlim,The following statement contains a magic number: _fastStateCache = new ThreadLockState[64];
Magic Number,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,SetRunning,The following statement contains a magic number: (preventDoubleExecution && lastValue >= 3) || lastValue == 6
Magic Number,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,SetRunning,The following statement contains a magic number: (preventDoubleExecution && lastValue >= 3) || lastValue == 6
Magic Number,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,SetRunning,The following statement contains a magic number: var tmp = Interlocked.CompareExchange(ref _status' 3' lastValue);
Magic Number,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,DisregardChild,The following statement contains a magic number: Contract.Assert(Volatile.Read(ref _completionCountdown) >= 2' "Task.DisregardChild(): Expected parent count to be >= 2");
Magic Number,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,SetCompleted,The following statement contains a magic number: (preventDoubleExecution && lastValue >= 3) || lastValue == 6
Magic Number,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,SetCompleted,The following statement contains a magic number: (preventDoubleExecution && lastValue >= 3) || lastValue == 6
Magic Number,System.Threading.Tasks,Task,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\ITaskCompletionAction.cs,SetCompleted,The following statement contains a magic number: var tmp = Interlocked.CompareExchange(ref _status' 5' lastValue);
Magic Number,System.Threading.Tasks,Parallel,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Parallel.cs,InvokeExtracted,The following statement contains a magic number: const int small_action_count_limit = 10;
Magic Number,System.Threading.Tasks,RangeManager,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\RangeManager.cs,RangeManager,The following statement contains a magic number: numExpectedWorkers = 2;
Magic Number,System.Threading.Tasks,RangeWorker,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\RangeWorker.cs,FindNewWork,The following statement contains a magic number: _incrementValue *= 2;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,BinaryReverse,The following statement contains a magic number: value = ((value & 0xcccccccc) >> 2) | ((value & 0x33333333) << 2);
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,BinaryReverse,The following statement contains a magic number: value = ((value & 0xcccccccc) >> 2) | ((value & 0x33333333) << 2);
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,BinaryReverse,The following statement contains a magic number: value = ((value & 0xf0f0f0f0) >> 4) | ((value & 0x0f0f0f0f) << 4);
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,BinaryReverse,The following statement contains a magic number: value = ((value & 0xf0f0f0f0) >> 4) | ((value & 0x0f0f0f0f) << 4);
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,BinaryReverse,The following statement contains a magic number: value = ((value & 0xff00ff00) >> 8) | ((value & 0x00ff00ff) << 8);
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,BinaryReverse,The following statement contains a magic number: value = ((value & 0xff00ff00) >> 8) | ((value & 0x00ff00ff) << 8);
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,BinaryReverse,The following statement contains a magic number: return (value >> 16) | (value << 16);
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,BinaryReverse,The following statement contains a magic number: return (value >> 16) | (value << 16);
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,BitsBinary,The following statement contains a magic number: byte check = 1 << 7;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,BitsBinary,The following statement contains a magic number: var log2 = 8;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,BitsBinary,The following statement contains a magic number: var check = (uint)1 << 31;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,BitsBinary,The following statement contains a magic number: var log2 = 32;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,BitsBinary,The following statement contains a magic number: var check = (ulong)1 << 63;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,BitsBinary,The following statement contains a magic number: var log2 = 64;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,BitsBinary,The following statement contains a magic number: byte check = 1 << 7;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,BitsBinary,The following statement contains a magic number: var log2 = 8;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,BitsBinary,The following statement contains a magic number: ushort check = 1 << 15;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,BitsBinary,The following statement contains a magic number: var log2 = 16;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,BitsBinary,The following statement contains a magic number: var check = (uint)1 << 31;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,BitsBinary,The following statement contains a magic number: var log2 = 32;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,BitsBinary,The following statement contains a magic number: var check = (ulong)1 << 63;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,BitsBinary,The following statement contains a magic number: var log2 = 64;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,BitsBinary,The following statement contains a magic number: ushort check = 1 << 15;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,BitsBinary,The following statement contains a magic number: var log2 = 16;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,LeadingZeroCount,The following statement contains a magic number: value |= value >> 2;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,LeadingZeroCount,The following statement contains a magic number: value |= value >> 4;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,LeadingZeroCount,The following statement contains a magic number: value |= value >> 8;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,LeadingZeroCount,The following statement contains a magic number: value |= value >> 16;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,LeadingZeroCount,The following statement contains a magic number: return (sizeof(int) * 8) - PopulationCount(value);
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,LeadingZeroCount,The following statement contains a magic number: value |= value >> 2;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,LeadingZeroCount,The following statement contains a magic number: value |= value >> 4;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,LeadingZeroCount,The following statement contains a magic number: value |= value >> 8;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,LeadingZeroCount,The following statement contains a magic number: value |= value >> 16;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,LeadingZeroCount,The following statement contains a magic number: value |= value >> 32;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,LeadingZeroCount,The following statement contains a magic number: return (sizeof(long) * 8) - PopulationCount(value);
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,PopulationCount,The following statement contains a magic number: value = (value & 0x33333333) + ((value >> 2) & 0x33333333);
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,PopulationCount,The following statement contains a magic number: value = (value + (value >> 4)) & 0x0F0F0F0F;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,PopulationCount,The following statement contains a magic number: value += value >> 8;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,PopulationCount,The following statement contains a magic number: value += value >> 16;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,PopulationCount,The following statement contains a magic number: value = (value & 0x3333333333333333UL) + ((value >> 2) & 0x3333333333333333UL);
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,PopulationCount,The following statement contains a magic number: value = (value + (value >> 4)) & 0x0f0f0f0f0f0f0f0fUL;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,PopulationCount,The following statement contains a magic number: return (int)((value * 0x0101010101010101UL) >> 56);
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,BuildInt64,The following statement contains a magic number: return unchecked((long)(((ulong)(uint)hi << 32) | (uint)lo));
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,BuildInt64,The following statement contains a magic number: return unchecked((long)(((ulong)hi << 32) | lo));
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,BuildUInt64,The following statement contains a magic number: return ((ulong)hi << 32) | lo;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,GetDoubleParts,The following statement contains a magic number: sign = 1 - ((int)(du.Uu >> 62) & 2);
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,GetDoubleParts,The following statement contains a magic number: sign = 1 - ((int)(du.Uu >> 62) & 2);
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,GetDoubleParts,The following statement contains a magic number: exp = (int)(du.Uu >> 52) & 0x7FF;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,GetDoubleParts,The following statement contains a magic number: switch (exp)              {                  case 0:                      {                          // Denormalized number.                          finite = true;                          if (man != 0)                          {                              exp = -1074;                          }                            break;                      }                    case 0x7FF:                      // NaN or Infinite.                      finite = false;                      exp = int.MaxValue;                      break;                    default:                      finite = true;                      man |= 0x0010000000000000;                      exp -= 1075;                      break;              }
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,GetDoubleParts,The following statement contains a magic number: switch (exp)              {                  case 0:                      {                          // Denormalized number.                          finite = true;                          if (man != 0)                          {                              exp = -1074;                          }                            break;                      }                    case 0x7FF:                      // NaN or Infinite.                      finite = false;                      exp = int.MaxValue;                      break;                    default:                      finite = true;                      man |= 0x0010000000000000;                      exp -= 1075;                      break;              }
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,GetParts,The following statement contains a magic number: hi = (short)(value >> 16);
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,GetParts,The following statement contains a magic number: hi = (int)((ulong)value >> 32);
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,GetParts,The following statement contains a magic number: hi = (ushort)(value >> 16);
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,GetParts,The following statement contains a magic number: hi = (uint)(value >> 32);
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,CbitHighZero,The following statement contains a magic number: return 32;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,CbitHighZero,The following statement contains a magic number: cbit += 16;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,CbitHighZero,The following statement contains a magic number: u <<= 16;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,CbitHighZero,The following statement contains a magic number: cbit += 8;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,CbitHighZero,The following statement contains a magic number: u <<= 8;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,CbitHighZero,The following statement contains a magic number: cbit += 4;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,CbitHighZero,The following statement contains a magic number: u <<= 4;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,CbitHighZero,The following statement contains a magic number: cbit += 2;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,CbitHighZero,The following statement contains a magic number: u <<= 2;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,CbitHighZero,The following statement contains a magic number: return 32 + CbitHighZero((uint)uu);
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,CbitHighZero,The following statement contains a magic number: return CbitHighZero((uint)(uu >> 32));
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,CbitLowZero,The following statement contains a magic number: return 32;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,CbitLowZero,The following statement contains a magic number: cbit += 16;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,CbitLowZero,The following statement contains a magic number: u >>= 16;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,CbitLowZero,The following statement contains a magic number: cbit += 8;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,CbitLowZero,The following statement contains a magic number: u >>= 8;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,CbitLowZero,The following statement contains a magic number: cbit += 4;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,CbitLowZero,The following statement contains a magic number: u >>= 4;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,CbitLowZero,The following statement contains a magic number: cbit += 2;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,CbitLowZero,The following statement contains a magic number: u >>= 2;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,Abs,The following statement contains a magic number: var mask = (uint)(a >> 31);
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,GCD,The following statement contains a magic number: const int cvMax = 32;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,GCD,The following statement contains a magic number: const int cvMax = 32;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,Log2,The following statement contains a magic number: number |= number >> 2;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,Log2,The following statement contains a magic number: number |= number >> 4;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,Log2,The following statement contains a magic number: number |= number >> 8;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,Log2,The following statement contains a magic number: number |= number >> 16;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,Log2,The following statement contains a magic number: number |= number >> 2;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,Log2,The following statement contains a magic number: number |= number >> 4;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,Log2,The following statement contains a magic number: number |= number >> 8;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,Log2,The following statement contains a magic number: number |= number >> 16;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,Log2,The following statement contains a magic number: number |= number >> 32;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,NextPowerOf2,The following statement contains a magic number: number |= number >> 2;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,NextPowerOf2,The following statement contains a magic number: number |= number >> 4;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,NextPowerOf2,The following statement contains a magic number: number |= number >> 8;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,NextPowerOf2,The following statement contains a magic number: number |= number >> 16;
Magic Number,Theraot.Core,NumericHelper,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Core\NumericHelper.Binary.cs,GetHi,The following statement contains a magic number: return (uint)(uu >> 32);
Magic Number,Theraot.Collections.Specialized,AVLNode<TKey;TValue>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\Specialized\AVLNode.cs,MakeBalanced,The following statement contains a magic number: current._balance >= 2
Magic Number,Theraot.Collections.ThreadSafe,FixedSizeBucket<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\ThreadSafe\FixedSizeBucket.cs,FixedSizeBucket,The following statement contains a magic number: _entries = ArrayReservoir<object>.GetArray(collection?.Count ?? 64);
Magic Number,Theraot.Collections.ThreadSafe,NeedleReservoir<T;TNeedle>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\ThreadSafe\NeedleReservoir.cs,NeedleReservoir,The following statement contains a magic number: _pool = new Pool<TNeedle>(64' Recycle);
Magic Number,Theraot.Collections.ThreadSafe,ThreadSafeQueue<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\ThreadSafe\ThreadSafeQueue.cs,ThreadSafeQueue,The following statement contains a magic number: _root = Node<FixedSizeQueue<T>>.GetNode(null' new FixedSizeQueue<T>(64));
Magic Number,Theraot.Collections.ThreadSafe,ThreadSafeQueue<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Collections\ThreadSafe\ThreadSafeQueue.cs,Add,The following statement contains a magic number: var node = Node<FixedSizeQueue<T>>.GetNode(null' new FixedSizeQueue<T>(64));
Magic Number,Theraot.Reflection,DelegateBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\DelegateBuilder.cs,GetActionType,The following statement contains a magic number: switch (types.Length)              {                  case 0:                      return typeof(Action);                    case 1:                      return typeof(Action<>).MakeGenericType(types);                    case 2:                      return typeof(Action<'>).MakeGenericType(types);                    case 3:                      return typeof(Action<''>).MakeGenericType(types);                    case 4:                      return typeof(Action<'''>).MakeGenericType(types);                    case 5:                      return typeof(Action<''''>).MakeGenericType(types);                    case 6:                      return typeof(Action<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Action<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Action<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Action<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Action<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Action<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Action<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Action<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Action<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Action<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Action<'''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,Theraot.Reflection,DelegateBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\DelegateBuilder.cs,GetActionType,The following statement contains a magic number: switch (types.Length)              {                  case 0:                      return typeof(Action);                    case 1:                      return typeof(Action<>).MakeGenericType(types);                    case 2:                      return typeof(Action<'>).MakeGenericType(types);                    case 3:                      return typeof(Action<''>).MakeGenericType(types);                    case 4:                      return typeof(Action<'''>).MakeGenericType(types);                    case 5:                      return typeof(Action<''''>).MakeGenericType(types);                    case 6:                      return typeof(Action<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Action<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Action<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Action<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Action<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Action<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Action<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Action<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Action<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Action<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Action<'''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,Theraot.Reflection,DelegateBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\DelegateBuilder.cs,GetActionType,The following statement contains a magic number: switch (types.Length)              {                  case 0:                      return typeof(Action);                    case 1:                      return typeof(Action<>).MakeGenericType(types);                    case 2:                      return typeof(Action<'>).MakeGenericType(types);                    case 3:                      return typeof(Action<''>).MakeGenericType(types);                    case 4:                      return typeof(Action<'''>).MakeGenericType(types);                    case 5:                      return typeof(Action<''''>).MakeGenericType(types);                    case 6:                      return typeof(Action<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Action<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Action<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Action<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Action<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Action<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Action<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Action<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Action<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Action<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Action<'''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,Theraot.Reflection,DelegateBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\DelegateBuilder.cs,GetActionType,The following statement contains a magic number: switch (types.Length)              {                  case 0:                      return typeof(Action);                    case 1:                      return typeof(Action<>).MakeGenericType(types);                    case 2:                      return typeof(Action<'>).MakeGenericType(types);                    case 3:                      return typeof(Action<''>).MakeGenericType(types);                    case 4:                      return typeof(Action<'''>).MakeGenericType(types);                    case 5:                      return typeof(Action<''''>).MakeGenericType(types);                    case 6:                      return typeof(Action<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Action<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Action<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Action<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Action<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Action<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Action<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Action<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Action<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Action<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Action<'''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,Theraot.Reflection,DelegateBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\DelegateBuilder.cs,GetActionType,The following statement contains a magic number: switch (types.Length)              {                  case 0:                      return typeof(Action);                    case 1:                      return typeof(Action<>).MakeGenericType(types);                    case 2:                      return typeof(Action<'>).MakeGenericType(types);                    case 3:                      return typeof(Action<''>).MakeGenericType(types);                    case 4:                      return typeof(Action<'''>).MakeGenericType(types);                    case 5:                      return typeof(Action<''''>).MakeGenericType(types);                    case 6:                      return typeof(Action<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Action<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Action<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Action<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Action<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Action<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Action<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Action<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Action<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Action<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Action<'''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,Theraot.Reflection,DelegateBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\DelegateBuilder.cs,GetActionType,The following statement contains a magic number: switch (types.Length)              {                  case 0:                      return typeof(Action);                    case 1:                      return typeof(Action<>).MakeGenericType(types);                    case 2:                      return typeof(Action<'>).MakeGenericType(types);                    case 3:                      return typeof(Action<''>).MakeGenericType(types);                    case 4:                      return typeof(Action<'''>).MakeGenericType(types);                    case 5:                      return typeof(Action<''''>).MakeGenericType(types);                    case 6:                      return typeof(Action<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Action<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Action<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Action<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Action<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Action<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Action<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Action<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Action<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Action<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Action<'''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,Theraot.Reflection,DelegateBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\DelegateBuilder.cs,GetActionType,The following statement contains a magic number: switch (types.Length)              {                  case 0:                      return typeof(Action);                    case 1:                      return typeof(Action<>).MakeGenericType(types);                    case 2:                      return typeof(Action<'>).MakeGenericType(types);                    case 3:                      return typeof(Action<''>).MakeGenericType(types);                    case 4:                      return typeof(Action<'''>).MakeGenericType(types);                    case 5:                      return typeof(Action<''''>).MakeGenericType(types);                    case 6:                      return typeof(Action<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Action<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Action<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Action<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Action<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Action<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Action<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Action<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Action<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Action<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Action<'''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,Theraot.Reflection,DelegateBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\DelegateBuilder.cs,GetActionType,The following statement contains a magic number: switch (types.Length)              {                  case 0:                      return typeof(Action);                    case 1:                      return typeof(Action<>).MakeGenericType(types);                    case 2:                      return typeof(Action<'>).MakeGenericType(types);                    case 3:                      return typeof(Action<''>).MakeGenericType(types);                    case 4:                      return typeof(Action<'''>).MakeGenericType(types);                    case 5:                      return typeof(Action<''''>).MakeGenericType(types);                    case 6:                      return typeof(Action<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Action<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Action<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Action<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Action<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Action<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Action<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Action<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Action<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Action<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Action<'''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,Theraot.Reflection,DelegateBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\DelegateBuilder.cs,GetActionType,The following statement contains a magic number: switch (types.Length)              {                  case 0:                      return typeof(Action);                    case 1:                      return typeof(Action<>).MakeGenericType(types);                    case 2:                      return typeof(Action<'>).MakeGenericType(types);                    case 3:                      return typeof(Action<''>).MakeGenericType(types);                    case 4:                      return typeof(Action<'''>).MakeGenericType(types);                    case 5:                      return typeof(Action<''''>).MakeGenericType(types);                    case 6:                      return typeof(Action<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Action<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Action<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Action<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Action<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Action<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Action<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Action<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Action<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Action<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Action<'''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,Theraot.Reflection,DelegateBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\DelegateBuilder.cs,GetActionType,The following statement contains a magic number: switch (types.Length)              {                  case 0:                      return typeof(Action);                    case 1:                      return typeof(Action<>).MakeGenericType(types);                    case 2:                      return typeof(Action<'>).MakeGenericType(types);                    case 3:                      return typeof(Action<''>).MakeGenericType(types);                    case 4:                      return typeof(Action<'''>).MakeGenericType(types);                    case 5:                      return typeof(Action<''''>).MakeGenericType(types);                    case 6:                      return typeof(Action<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Action<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Action<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Action<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Action<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Action<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Action<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Action<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Action<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Action<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Action<'''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,Theraot.Reflection,DelegateBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\DelegateBuilder.cs,GetActionType,The following statement contains a magic number: switch (types.Length)              {                  case 0:                      return typeof(Action);                    case 1:                      return typeof(Action<>).MakeGenericType(types);                    case 2:                      return typeof(Action<'>).MakeGenericType(types);                    case 3:                      return typeof(Action<''>).MakeGenericType(types);                    case 4:                      return typeof(Action<'''>).MakeGenericType(types);                    case 5:                      return typeof(Action<''''>).MakeGenericType(types);                    case 6:                      return typeof(Action<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Action<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Action<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Action<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Action<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Action<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Action<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Action<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Action<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Action<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Action<'''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,Theraot.Reflection,DelegateBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\DelegateBuilder.cs,GetActionType,The following statement contains a magic number: switch (types.Length)              {                  case 0:                      return typeof(Action);                    case 1:                      return typeof(Action<>).MakeGenericType(types);                    case 2:                      return typeof(Action<'>).MakeGenericType(types);                    case 3:                      return typeof(Action<''>).MakeGenericType(types);                    case 4:                      return typeof(Action<'''>).MakeGenericType(types);                    case 5:                      return typeof(Action<''''>).MakeGenericType(types);                    case 6:                      return typeof(Action<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Action<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Action<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Action<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Action<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Action<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Action<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Action<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Action<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Action<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Action<'''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,Theraot.Reflection,DelegateBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\DelegateBuilder.cs,GetActionType,The following statement contains a magic number: switch (types.Length)              {                  case 0:                      return typeof(Action);                    case 1:                      return typeof(Action<>).MakeGenericType(types);                    case 2:                      return typeof(Action<'>).MakeGenericType(types);                    case 3:                      return typeof(Action<''>).MakeGenericType(types);                    case 4:                      return typeof(Action<'''>).MakeGenericType(types);                    case 5:                      return typeof(Action<''''>).MakeGenericType(types);                    case 6:                      return typeof(Action<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Action<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Action<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Action<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Action<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Action<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Action<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Action<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Action<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Action<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Action<'''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,Theraot.Reflection,DelegateBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\DelegateBuilder.cs,GetActionType,The following statement contains a magic number: switch (types.Length)              {                  case 0:                      return typeof(Action);                    case 1:                      return typeof(Action<>).MakeGenericType(types);                    case 2:                      return typeof(Action<'>).MakeGenericType(types);                    case 3:                      return typeof(Action<''>).MakeGenericType(types);                    case 4:                      return typeof(Action<'''>).MakeGenericType(types);                    case 5:                      return typeof(Action<''''>).MakeGenericType(types);                    case 6:                      return typeof(Action<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Action<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Action<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Action<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Action<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Action<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Action<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Action<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Action<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Action<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Action<'''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,Theraot.Reflection,DelegateBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\DelegateBuilder.cs,GetActionType,The following statement contains a magic number: switch (types.Length)              {                  case 0:                      return typeof(Action);                    case 1:                      return typeof(Action<>).MakeGenericType(types);                    case 2:                      return typeof(Action<'>).MakeGenericType(types);                    case 3:                      return typeof(Action<''>).MakeGenericType(types);                    case 4:                      return typeof(Action<'''>).MakeGenericType(types);                    case 5:                      return typeof(Action<''''>).MakeGenericType(types);                    case 6:                      return typeof(Action<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Action<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Action<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Action<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Action<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Action<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Action<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Action<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Action<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Action<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Action<'''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,Theraot.Reflection,DelegateBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\DelegateBuilder.cs,GetFuncType,The following statement contains a magic number: switch (types.Length)              {                  case 1:                      return typeof(Func<>).MakeGenericType(types);                    case 2:                      return typeof(Func<'>).MakeGenericType(types);                    case 3:                      return typeof(Func<''>).MakeGenericType(types);                    case 4:                      return typeof(Func<'''>).MakeGenericType(types);                    case 5:                      return typeof(Func<''''>).MakeGenericType(types);                    case 6:                      return typeof(Func<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Func<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Func<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Func<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Func<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Func<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Func<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Func<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Func<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Func<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Func<'''''''''''''''>).MakeGenericType(types);                    case 17:                      return typeof(Func<''''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,Theraot.Reflection,DelegateBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\DelegateBuilder.cs,GetFuncType,The following statement contains a magic number: switch (types.Length)              {                  case 1:                      return typeof(Func<>).MakeGenericType(types);                    case 2:                      return typeof(Func<'>).MakeGenericType(types);                    case 3:                      return typeof(Func<''>).MakeGenericType(types);                    case 4:                      return typeof(Func<'''>).MakeGenericType(types);                    case 5:                      return typeof(Func<''''>).MakeGenericType(types);                    case 6:                      return typeof(Func<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Func<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Func<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Func<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Func<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Func<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Func<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Func<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Func<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Func<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Func<'''''''''''''''>).MakeGenericType(types);                    case 17:                      return typeof(Func<''''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,Theraot.Reflection,DelegateBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\DelegateBuilder.cs,GetFuncType,The following statement contains a magic number: switch (types.Length)              {                  case 1:                      return typeof(Func<>).MakeGenericType(types);                    case 2:                      return typeof(Func<'>).MakeGenericType(types);                    case 3:                      return typeof(Func<''>).MakeGenericType(types);                    case 4:                      return typeof(Func<'''>).MakeGenericType(types);                    case 5:                      return typeof(Func<''''>).MakeGenericType(types);                    case 6:                      return typeof(Func<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Func<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Func<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Func<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Func<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Func<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Func<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Func<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Func<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Func<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Func<'''''''''''''''>).MakeGenericType(types);                    case 17:                      return typeof(Func<''''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,Theraot.Reflection,DelegateBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\DelegateBuilder.cs,GetFuncType,The following statement contains a magic number: switch (types.Length)              {                  case 1:                      return typeof(Func<>).MakeGenericType(types);                    case 2:                      return typeof(Func<'>).MakeGenericType(types);                    case 3:                      return typeof(Func<''>).MakeGenericType(types);                    case 4:                      return typeof(Func<'''>).MakeGenericType(types);                    case 5:                      return typeof(Func<''''>).MakeGenericType(types);                    case 6:                      return typeof(Func<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Func<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Func<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Func<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Func<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Func<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Func<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Func<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Func<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Func<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Func<'''''''''''''''>).MakeGenericType(types);                    case 17:                      return typeof(Func<''''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,Theraot.Reflection,DelegateBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\DelegateBuilder.cs,GetFuncType,The following statement contains a magic number: switch (types.Length)              {                  case 1:                      return typeof(Func<>).MakeGenericType(types);                    case 2:                      return typeof(Func<'>).MakeGenericType(types);                    case 3:                      return typeof(Func<''>).MakeGenericType(types);                    case 4:                      return typeof(Func<'''>).MakeGenericType(types);                    case 5:                      return typeof(Func<''''>).MakeGenericType(types);                    case 6:                      return typeof(Func<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Func<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Func<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Func<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Func<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Func<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Func<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Func<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Func<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Func<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Func<'''''''''''''''>).MakeGenericType(types);                    case 17:                      return typeof(Func<''''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,Theraot.Reflection,DelegateBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\DelegateBuilder.cs,GetFuncType,The following statement contains a magic number: switch (types.Length)              {                  case 1:                      return typeof(Func<>).MakeGenericType(types);                    case 2:                      return typeof(Func<'>).MakeGenericType(types);                    case 3:                      return typeof(Func<''>).MakeGenericType(types);                    case 4:                      return typeof(Func<'''>).MakeGenericType(types);                    case 5:                      return typeof(Func<''''>).MakeGenericType(types);                    case 6:                      return typeof(Func<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Func<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Func<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Func<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Func<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Func<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Func<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Func<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Func<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Func<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Func<'''''''''''''''>).MakeGenericType(types);                    case 17:                      return typeof(Func<''''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,Theraot.Reflection,DelegateBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\DelegateBuilder.cs,GetFuncType,The following statement contains a magic number: switch (types.Length)              {                  case 1:                      return typeof(Func<>).MakeGenericType(types);                    case 2:                      return typeof(Func<'>).MakeGenericType(types);                    case 3:                      return typeof(Func<''>).MakeGenericType(types);                    case 4:                      return typeof(Func<'''>).MakeGenericType(types);                    case 5:                      return typeof(Func<''''>).MakeGenericType(types);                    case 6:                      return typeof(Func<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Func<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Func<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Func<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Func<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Func<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Func<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Func<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Func<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Func<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Func<'''''''''''''''>).MakeGenericType(types);                    case 17:                      return typeof(Func<''''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,Theraot.Reflection,DelegateBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\DelegateBuilder.cs,GetFuncType,The following statement contains a magic number: switch (types.Length)              {                  case 1:                      return typeof(Func<>).MakeGenericType(types);                    case 2:                      return typeof(Func<'>).MakeGenericType(types);                    case 3:                      return typeof(Func<''>).MakeGenericType(types);                    case 4:                      return typeof(Func<'''>).MakeGenericType(types);                    case 5:                      return typeof(Func<''''>).MakeGenericType(types);                    case 6:                      return typeof(Func<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Func<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Func<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Func<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Func<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Func<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Func<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Func<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Func<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Func<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Func<'''''''''''''''>).MakeGenericType(types);                    case 17:                      return typeof(Func<''''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,Theraot.Reflection,DelegateBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\DelegateBuilder.cs,GetFuncType,The following statement contains a magic number: switch (types.Length)              {                  case 1:                      return typeof(Func<>).MakeGenericType(types);                    case 2:                      return typeof(Func<'>).MakeGenericType(types);                    case 3:                      return typeof(Func<''>).MakeGenericType(types);                    case 4:                      return typeof(Func<'''>).MakeGenericType(types);                    case 5:                      return typeof(Func<''''>).MakeGenericType(types);                    case 6:                      return typeof(Func<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Func<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Func<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Func<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Func<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Func<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Func<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Func<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Func<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Func<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Func<'''''''''''''''>).MakeGenericType(types);                    case 17:                      return typeof(Func<''''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,Theraot.Reflection,DelegateBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\DelegateBuilder.cs,GetFuncType,The following statement contains a magic number: switch (types.Length)              {                  case 1:                      return typeof(Func<>).MakeGenericType(types);                    case 2:                      return typeof(Func<'>).MakeGenericType(types);                    case 3:                      return typeof(Func<''>).MakeGenericType(types);                    case 4:                      return typeof(Func<'''>).MakeGenericType(types);                    case 5:                      return typeof(Func<''''>).MakeGenericType(types);                    case 6:                      return typeof(Func<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Func<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Func<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Func<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Func<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Func<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Func<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Func<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Func<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Func<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Func<'''''''''''''''>).MakeGenericType(types);                    case 17:                      return typeof(Func<''''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,Theraot.Reflection,DelegateBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\DelegateBuilder.cs,GetFuncType,The following statement contains a magic number: switch (types.Length)              {                  case 1:                      return typeof(Func<>).MakeGenericType(types);                    case 2:                      return typeof(Func<'>).MakeGenericType(types);                    case 3:                      return typeof(Func<''>).MakeGenericType(types);                    case 4:                      return typeof(Func<'''>).MakeGenericType(types);                    case 5:                      return typeof(Func<''''>).MakeGenericType(types);                    case 6:                      return typeof(Func<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Func<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Func<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Func<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Func<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Func<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Func<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Func<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Func<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Func<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Func<'''''''''''''''>).MakeGenericType(types);                    case 17:                      return typeof(Func<''''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,Theraot.Reflection,DelegateBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\DelegateBuilder.cs,GetFuncType,The following statement contains a magic number: switch (types.Length)              {                  case 1:                      return typeof(Func<>).MakeGenericType(types);                    case 2:                      return typeof(Func<'>).MakeGenericType(types);                    case 3:                      return typeof(Func<''>).MakeGenericType(types);                    case 4:                      return typeof(Func<'''>).MakeGenericType(types);                    case 5:                      return typeof(Func<''''>).MakeGenericType(types);                    case 6:                      return typeof(Func<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Func<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Func<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Func<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Func<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Func<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Func<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Func<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Func<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Func<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Func<'''''''''''''''>).MakeGenericType(types);                    case 17:                      return typeof(Func<''''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,Theraot.Reflection,DelegateBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\DelegateBuilder.cs,GetFuncType,The following statement contains a magic number: switch (types.Length)              {                  case 1:                      return typeof(Func<>).MakeGenericType(types);                    case 2:                      return typeof(Func<'>).MakeGenericType(types);                    case 3:                      return typeof(Func<''>).MakeGenericType(types);                    case 4:                      return typeof(Func<'''>).MakeGenericType(types);                    case 5:                      return typeof(Func<''''>).MakeGenericType(types);                    case 6:                      return typeof(Func<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Func<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Func<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Func<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Func<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Func<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Func<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Func<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Func<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Func<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Func<'''''''''''''''>).MakeGenericType(types);                    case 17:                      return typeof(Func<''''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,Theraot.Reflection,DelegateBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\DelegateBuilder.cs,GetFuncType,The following statement contains a magic number: switch (types.Length)              {                  case 1:                      return typeof(Func<>).MakeGenericType(types);                    case 2:                      return typeof(Func<'>).MakeGenericType(types);                    case 3:                      return typeof(Func<''>).MakeGenericType(types);                    case 4:                      return typeof(Func<'''>).MakeGenericType(types);                    case 5:                      return typeof(Func<''''>).MakeGenericType(types);                    case 6:                      return typeof(Func<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Func<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Func<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Func<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Func<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Func<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Func<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Func<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Func<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Func<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Func<'''''''''''''''>).MakeGenericType(types);                    case 17:                      return typeof(Func<''''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,Theraot.Reflection,DelegateBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\DelegateBuilder.cs,GetFuncType,The following statement contains a magic number: switch (types.Length)              {                  case 1:                      return typeof(Func<>).MakeGenericType(types);                    case 2:                      return typeof(Func<'>).MakeGenericType(types);                    case 3:                      return typeof(Func<''>).MakeGenericType(types);                    case 4:                      return typeof(Func<'''>).MakeGenericType(types);                    case 5:                      return typeof(Func<''''>).MakeGenericType(types);                    case 6:                      return typeof(Func<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Func<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Func<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Func<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Func<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Func<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Func<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Func<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Func<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Func<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Func<'''''''''''''''>).MakeGenericType(types);                    case 17:                      return typeof(Func<''''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Magic Number,Theraot.Reflection,DelegateBuilder,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Reflection\DelegateBuilder.cs,GetFuncType,The following statement contains a magic number: switch (types.Length)              {                  case 1:                      return typeof(Func<>).MakeGenericType(types);                    case 2:                      return typeof(Func<'>).MakeGenericType(types);                    case 3:                      return typeof(Func<''>).MakeGenericType(types);                    case 4:                      return typeof(Func<'''>).MakeGenericType(types);                    case 5:                      return typeof(Func<''''>).MakeGenericType(types);                    case 6:                      return typeof(Func<'''''>).MakeGenericType(types);                    case 7:                      return typeof(Func<''''''>).MakeGenericType(types);                    case 8:                      return typeof(Func<'''''''>).MakeGenericType(types);                    case 9:                      return typeof(Func<''''''''>).MakeGenericType(types);                    case 10:                      return typeof(Func<'''''''''>).MakeGenericType(types);                    case 11:                      return typeof(Func<''''''''''>).MakeGenericType(types);                    case 12:                      return typeof(Func<'''''''''''>).MakeGenericType(types);                    case 13:                      return typeof(Func<''''''''''''>).MakeGenericType(types);                    case 14:                      return typeof(Func<'''''''''''''>).MakeGenericType(types);                    case 15:                      return typeof(Func<''''''''''''''>).MakeGenericType(types);                    case 16:                      return typeof(Func<'''''''''''''''>).MakeGenericType(types);                    case 17:                      return typeof(Func<''''''''''''''''>).MakeGenericType(types);                    default:                      return null;              }
Duplicate Code,System,Lazy<T>,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Lazy.cs,Lazy,The method contains a code clone-set at the following line numbers (starting from the method definition): ((53' 75)' (91' 113))
Missing Default,System.Threading.Tasks.Sources,ManualResetValueTaskSourceCore,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Sources\ManualResetValueTaskSourceCore.cs,OnCompleted,The following switch statement is missing a default case: switch (_capturedContext)                  {                      case null:  #if TARGETS_NET || TARGETS_NETCORE || GREATERTHAN_NETSTANDARD13                          if (_executionContext != null)                          {                              ThreadPoolEx.QueueUserWorkItem(continuation' state' preferLocal: true);                              return;                          }  #endif                          ThreadPoolEx.UnsafeQueueUserWorkItem(continuation' state' preferLocal: true);                          return;                        case SynchronizationContext sc:                          sc.Post(s =>                          {                              var tuple = (Tuple<Action<object?>' object?>)s!;                              tuple.Item1(tuple.Item2);                          }' Tuple.Create(continuation' state));                          return;                        case TaskScheduler ts:  #if NET40                          Task.Factory.StartNew(continuation' state' CancellationToken.None' TaskCreationOptions.None' ts);  #else                          Task.Factory.StartNew(continuation' state' CancellationToken.None' TaskCreationOptions.DenyChildAttach' ts);  #endif                          return;                  }
Missing Default,System.Threading.Tasks.Sources,ManualResetValueTaskSourceCore,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\System\Threading\Tasks\Sources\ManualResetValueTaskSourceCore.cs,InvokeContinuation,The following switch statement is missing a default case: switch (_capturedContext)              {                  case null:                      if (RunContinuationsAsynchronously)                      {  #if TARGETS_NET || TARGETS_NETCORE || GREATERTHAN_NETSTANDARD13                          if (_executionContext != null)                          {                              ThreadPoolEx.QueueUserWorkItem(continuation' _continuationState' preferLocal: true);                              return;                          }  #endif                          ThreadPoolEx.QueueUserWorkItem(continuation' _continuationState' preferLocal: true);                          return;                      }                        continuation(_continuationState);                      return;                    case SynchronizationContext sc:                      sc.Post(s =>                      {                          var state = (Tuple<Action<object?>' object?>)s!;                          state.Item1(state.Item2);                      }' Tuple.Create(continuation' _continuationState));                      return;                    case TaskScheduler ts:  #if NET40                      Task.Factory.StartNew(continuation' _continuationState' CancellationToken.None' TaskCreationOptions.None' ts);  #else                      Task.Factory.StartNew(continuation' _continuationState' CancellationToken.None' TaskCreationOptions.DenyChildAttach' ts);  #endif                      return;              }
Missing Default,Theraot.Threading,GCMonitor,D:\research\architectureSmells\repos1\theraot_Theraot\Framework.Core\Theraot\Threading\GCMonitor.cs,Initialize,The following switch statement is missing a default case: switch (Interlocked.CompareExchange(ref _status' _statusPending' _statusNotReady))              {                  case _statusNotReady:                      GC.KeepAlive(new GCProbe());                      Volatile.Write(ref _status' _statusReady);                      break;                    case _statusPending:                      ThreadingHelper.SpinWaitUntil(ref _status' _statusReady);                      break;              }
