Implementation smell,Namespace,Class,File,Method,Description
Long Method,FarseerPhysics.Collision,Collision,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Collision.cs,CollidePolygonAndCircle,The method has 121 lines of code.
Long Method,FarseerPhysics.Collision,Collision,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Collision.cs,CollidePolygons,The method has 110 lines of code.
Long Method,FarseerPhysics.Collision,Collision,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Collision.cs,CollideEdgeAndCircle,The method has 118 lines of code.
Long Method,FarseerPhysics.Collision,Collision,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Collision.cs,CollideEdgeAndPolygon,The method has 248 lines of code.
Long Method,FarseerPhysics.Collision,Simplex,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Distance.cs,Solve3,The method has 119 lines of code.
Long Method,FarseerPhysics.Collision,Distance,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Distance.cs,ComputeDistance,The method has 128 lines of code.
Long Method,FarseerPhysics.Collision,DynamicTree<T>,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\DynamicTree.cs,InsertLeaf,The method has 104 lines of code.
Long Method,FarseerPhysics.Collision,TimeOfImpact,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\TimeOfImpact.cs,CalculateTimeOfImpact,The method has 164 lines of code.
Long Method,FarseerPhysics.Collision.Shapes,PolygonShape,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Shapes\PolygonShape.cs,ComputeSubmergedArea,The method has 105 lines of code.
Long Method,FarseerPhysics.Common,WorldXmlSerializer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Serialization.cs,SerializeJoint,The method has 137 lines of code.
Long Method,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Serialization.cs,Deserialize,The method has 576 lines of code.
Long Method,FarseerPhysics.Common,Vertices,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Vertices.cs,CheckPolygon,The method has 105 lines of code.
Long Method,FarseerPhysics.Common,Vertices,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Vertices.cs,TraceEdge,The method has 168 lines of code.
Long Method,FarseerPhysics.Common,MarchingSquares,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\MarchingSquares.cs,DetectSquares,The method has 186 lines of code.
Long Method,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,DetectVertices,The method has 107 lines of code.
Long Method,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\BayazitDecomposer.cs,ConvexPartition,The method has 127 lines of code.
Long Method,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,TriangulatePolygon,The method has 113 lines of code.
Long Method,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PhysicsLogic\Explosion.cs,Activate,The method has 284 lines of code.
Long Method,FarseerPhysics.Dynamics,Island,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\Island.cs,Solve,The method has 216 lines of code.
Long Method,FarseerPhysics.Dynamics,World,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\World.cs,Solve,The method has 157 lines of code.
Long Method,FarseerPhysics.Dynamics,World,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\World.cs,SolveTOI,The method has 255 lines of code.
Long Method,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\Contacts\ContactSolver.cs,SolveVelocityConstraints,The method has 275 lines of code.
Long Method,FarseerPhysics.Dynamics.Joints,LineJoint,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\Joints\LineJoint.cs,InitVelocityConstraints,The method has 100 lines of code.
Long Method,FarseerPhysics.Dynamics.Joints,PrismaticJoint,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\Joints\PrismaticJoint.cs,InitVelocityConstraints,The method has 101 lines of code.
Long Method,FarseerPhysics.Dynamics.Joints,PulleyJoint,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\Joints\PulleyJoint.cs,SolvePositionConstraints,The method has 101 lines of code.
Long Method,FarseerPhysics.Dynamics.Joints,RevoluteJoint,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\Joints\RevoluteJoint.cs,SolveVelocityConstraints,The method has 104 lines of code.
Complex Method,FarseerPhysics.Collision,Collision,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Collision.cs,CollidePolygons,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Collision,Collision,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Collision.cs,CollideEdgeAndCircle,Cyclomatic complexity of the method is 11
Complex Method,FarseerPhysics.Collision,Collision,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Collision.cs,CollideEdgeAndPolygon,Cyclomatic complexity of the method is 19
Complex Method,FarseerPhysics.Collision,Distance,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Distance.cs,ComputeDistance,Cyclomatic complexity of the method is 12
Complex Method,FarseerPhysics.Collision,DynamicTree<T>,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\DynamicTree.cs,RayCast,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Collision,DynamicTree<T>,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\DynamicTree.cs,InsertLeaf,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Collision,TimeOfImpact,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\TimeOfImpact.cs,CalculateTimeOfImpact,Cyclomatic complexity of the method is 17
Complex Method,FarseerPhysics.Collision.Shapes,PolygonShape,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Shapes\PolygonShape.cs,ComputeSubmergedArea,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Common,PolygonTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonTools.cs,CreateCapsule,Cyclomatic complexity of the method is 10
Complex Method,FarseerPhysics.Common,WorldXmlSerializer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Serialization.cs,Serialize,Cyclomatic complexity of the method is 13
Complex Method,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Serialization.cs,Deserialize,Cyclomatic complexity of the method is 30
Complex Method,FarseerPhysics.Common,XMLFragmentParser,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Serialization.cs,TryParseNode,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Common,Vertices,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Vertices.cs,IsSimple2,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Common,Vertices,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Vertices.cs,CheckPolygon,Cyclomatic complexity of the method is 14
Complex Method,FarseerPhysics.Common,Vertices,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Vertices.cs,TraceEdge,Cyclomatic complexity of the method is 27
Complex Method,FarseerPhysics.Common,MSTerrain,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\MSTerrain.cs,ApplyTexture,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Common,MSTerrain,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\MSTerrain.cs,ApplyData,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Common,MSTerrain,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\MSTerrain.cs,RegenerateTerrain,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Common,MarchingSquares,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\MarchingSquares.cs,DetectSquares,Cyclomatic complexity of the method is 35
Complex Method,FarseerPhysics.Common,MarchingSquares,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\MarchingSquares.cs,MarchSquare,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Common,MarchingSquares,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\MarchingSquares.cs,combLeft,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,Initialize,Cyclomatic complexity of the method is 10
Complex Method,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,DetectVertices,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,SearchHoleEntrance,Cyclomatic complexity of the method is 13
Complex Method,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,SearchCrossingEdges,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,SplitPolygonEdge,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Common.ConvexHull,ChainHull,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\ConvexHull\ChainHull.cs,GetConvexHull,Cyclomatic complexity of the method is 19
Complex Method,FarseerPhysics.Common.ConvexHull,GiftWrap,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\ConvexHull\GiftWrap.cs,GetConvexHull,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\ConvexHull\Melkman.cs,GetConvexHull,Cyclomatic complexity of the method is 11
Complex Method,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\BayazitDecomposer.cs,ConvexPartition,Cyclomatic complexity of the method is 15
Complex Method,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\BayazitDecomposer.cs,CanSee,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,PolygonizeTriangles,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,TriangulatePolygon,Cyclomatic complexity of the method is 16
Complex Method,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,ResolvePinchPoint,Cyclomatic complexity of the method is 10
Complex Method,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,AddTriangle,Cyclomatic complexity of the method is 10
Complex Method,FarseerPhysics.Common.Decomposition,FlipcodeDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\FlipcodeDecomposer.cs,ConvexPartition,Cyclomatic complexity of the method is 11
Complex Method,FarseerPhysics.Common.Decomposition,TrapezoidalMap,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\SeidelDecomposer.cs,BoundingBox,Cyclomatic complexity of the method is 10
Complex Method,FarseerPhysics.Common.Decomposition,Triangulator,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\SeidelDecomposer.cs,Process,Cyclomatic complexity of the method is 8
Complex Method,Poly2Tri.Triangulation.Delaunay.Sweep,DTSweep,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\Sweep\DTSweep.cs,EdgeEvent,Cyclomatic complexity of the method is 10
Complex Method,Poly2Tri.Triangulation.Delaunay.Sweep,DTSweep,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\Sweep\DTSweep.cs,Legalize,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PhysicsLogic\Explosion.cs,Activate,Cyclomatic complexity of the method is 31
Complex Method,FarseerPhysics.Common.PolygonManipulation,CuttingTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonManipulation\CuttingTools.cs,SplitShape,Cyclomatic complexity of the method is 13
Complex Method,FarseerPhysics.Common.PolygonManipulation,CuttingTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonManipulation\CuttingTools.cs,Cut,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Common.PolygonManipulation,CuttingTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonManipulation\CuttingTools.cs,SanityCheck,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Common.PolygonManipulation,SimplifyTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonManipulation\SimplifyTools.cs,MergeParallelEdges,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Common.PolygonManipulation,YuPengClipper,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonManipulation\YuPengClipper.cs,CalculateIntersections,Cyclomatic complexity of the method is 12
Complex Method,FarseerPhysics.Common.PolygonManipulation,YuPengClipper,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonManipulation\YuPengClipper.cs,CalculateResultChain,Cyclomatic complexity of the method is 10
Complex Method,FarseerPhysics.Common.PolygonManipulation,YuPengClipper,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonManipulation\YuPengClipper.cs,BuildPolygonsFromChain,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Controllers,GravityController,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Controllers\GravityController.cs,Update,Cyclomatic complexity of the method is 12
Complex Method,FarseerPhysics.Dynamics,ContactManager,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\ContactManager.cs,AddPair,Cyclomatic complexity of the method is 13
Complex Method,FarseerPhysics.Dynamics,ContactManager,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\ContactManager.cs,Destroy,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Dynamics,ContactManager,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\ContactManager.cs,Collide,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Dynamics,ContactManager,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\ContactManager.cs,ShouldCollide,Cyclomatic complexity of the method is 8
Complex Method,FarseerPhysics.Dynamics,Island,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\Island.cs,Solve,Cyclomatic complexity of the method is 34
Complex Method,FarseerPhysics.Dynamics,Island,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\Island.cs,SolveTOI,Cyclomatic complexity of the method is 11
Complex Method,FarseerPhysics.Dynamics,FilterData,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\World.cs,IsActiveOn,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Dynamics,World,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\World.cs,ProcessRemovedJoints,Cyclomatic complexity of the method is 16
Complex Method,FarseerPhysics.Dynamics,World,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\World.cs,ProcessAddedJoints,Cyclomatic complexity of the method is 10
Complex Method,FarseerPhysics.Dynamics,World,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\World.cs,Step,Cyclomatic complexity of the method is 15
Complex Method,FarseerPhysics.Dynamics,World,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\World.cs,Solve,Cyclomatic complexity of the method is 26
Complex Method,FarseerPhysics.Dynamics,World,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\World.cs,SolveTOI,Cyclomatic complexity of the method is 27
Complex Method,FarseerPhysics.Dynamics.Contacts,Contact,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\Contacts\Contact.cs,Update,Cyclomatic complexity of the method is 14
Complex Method,FarseerPhysics.Dynamics.Joints,FixedLineJoint,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\Joints\FixedLineJoint.cs,InitVelocityConstraints,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Dynamics.Joints,LineJoint,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\Joints\LineJoint.cs,InitVelocityConstraints,Cyclomatic complexity of the method is 9
Complex Method,FarseerPhysics.Dynamics.Joints,PulleyJoint,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\Joints\PulleyJoint.cs,SolvePositionConstraints,Cyclomatic complexity of the method is 8
Long Parameter List,FarseerPhysics.Collision,AABB,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Collision.cs,TestOverlap,The method has 6 parameters. Parameters: shapeA' indexA' shapeB' indexB' xfA' xfB
Long Parameter List,FarseerPhysics.Collision,Collision,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Collision.cs,GetWorldManifold,The method has 7 parameters. Parameters: manifold' transformA' radiusA' transformB' radiusB' normal' points
Long Parameter List,FarseerPhysics.Collision,Collision,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Collision.cs,CollideCircles,The method has 5 parameters. Parameters: manifold' circleA' xfA' circleB' xfB
Long Parameter List,FarseerPhysics.Collision,Collision,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Collision.cs,CollidePolygonAndCircle,The method has 5 parameters. Parameters: manifold' polygonA' transformA' circleB' transformB
Long Parameter List,FarseerPhysics.Collision,Collision,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Collision.cs,CollidePolygons,The method has 5 parameters. Parameters: manifold' polyA' transformA' polyB' transformB
Long Parameter List,FarseerPhysics.Collision,Collision,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Collision.cs,CollideEdgeAndCircle,The method has 5 parameters. Parameters: manifold' edgeA' transformA' circleB' transformB
Long Parameter List,FarseerPhysics.Collision,Collision,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Collision.cs,CollideEdgeAndPolygon,The method has 5 parameters. Parameters: manifold' edgeA' xfA' polygonB' xfB
Long Parameter List,FarseerPhysics.Collision,Collision,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Collision.cs,ClipSegmentToLine,The method has 5 parameters. Parameters: vOut' vIn' normal' offset' vertexIndexA
Long Parameter List,FarseerPhysics.Collision,Collision,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Collision.cs,EdgeSeparation,The method has 5 parameters. Parameters: poly1' xf1' edge1' poly2' xf2
Long Parameter List,FarseerPhysics.Collision,Collision,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Collision.cs,FindMaxSeparation,The method has 5 parameters. Parameters: edgeIndex' poly1' xf1' poly2' xf2
Long Parameter List,FarseerPhysics.Collision,Collision,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Collision.cs,FindIncidentEdge,The method has 6 parameters. Parameters: c' poly1' xf1' edge1' poly2' xf2
Long Parameter List,FarseerPhysics.Collision,Simplex,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Distance.cs,ReadCache,The method has 5 parameters. Parameters: cache' proxyA' transformA' proxyB' transformB
Long Parameter List,FarseerPhysics.Collision,SeparationFunction,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\TimeOfImpact.cs,Set,The method has 6 parameters. Parameters: cache' proxyA' sweepA' proxyB' sweepB' t1
Long Parameter List,FarseerPhysics.Common,LineTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\LineTools.cs,LineIntersect2,The method has 5 parameters. Parameters: a0' a1' b0' b1' intersectionPoint
Long Parameter List,FarseerPhysics.Common,LineTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\LineTools.cs,LineIntersect,The method has 7 parameters. Parameters: point1' point2' point3' point4' firstIsSegment' secondIsSegment' point
Long Parameter List,FarseerPhysics.Common,LineTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\LineTools.cs,LineIntersect,The method has 7 parameters. Parameters: point1' point2' point3' point4' firstIsSegment' secondIsSegment' intersectionPoint
Long Parameter List,FarseerPhysics.Common,LineTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\LineTools.cs,LineIntersect,The method has 5 parameters. Parameters: point1' point2' point3' point4' intersectionPoint
Long Parameter List,FarseerPhysics.Common,LineTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\LineTools.cs,LineIntersect,The method has 5 parameters. Parameters: point1' point2' point3' point4' intersectionPoint
Long Parameter List,FarseerPhysics.Common,PolygonTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonTools.cs,CreateRoundedRectangle,The method has 5 parameters. Parameters: width' height' xRadius' yRadius' segments
Long Parameter List,FarseerPhysics.Common,PolygonTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonTools.cs,CreateCapsule,The method has 5 parameters. Parameters: height' topRadius' topEdges' bottomRadius' bottomEdges
Long Parameter List,FarseerPhysics.Common,PolygonTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonTools.cs,CreatePolygon,The method has 6 parameters. Parameters: data' width' hullTolerance' alphaTolerance' multiPartDetection' holeDetection
Long Parameter List,FarseerPhysics.Common,MarchingSquares,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\MarchingSquares.cs,DetectSquares,The method has 6 parameters. Parameters: domain' cellWidth' cellHeight' f' lerpCount' combine
Long Parameter List,FarseerPhysics.Common,MarchingSquares,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\MarchingSquares.cs,Xlerp,The method has 7 parameters. Parameters: x0' x1' y' v0' v1' f' c
Long Parameter List,FarseerPhysics.Common,MarchingSquares,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\MarchingSquares.cs,Ylerp,The method has 7 parameters. Parameters: y0' y1' x' v0' v1' f' c
Long Parameter List,FarseerPhysics.Common,MarchingSquares,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\MarchingSquares.cs,MarchSquare,The method has 10 parameters. Parameters: f' fs' poly' ax' ay' x0' y0' x1' y1' bin
Long Parameter List,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,TextureConverter,The method has 6 parameters. Parameters: alphaTolerance' hullTolerance' holeDetection' multipartDetection' pixelOffsetOptimization' transform
Long Parameter List,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,TextureConverter,The method has 8 parameters. Parameters: data' width' alphaTolerance' hullTolerance' holeDetection' multipartDetection' pixelOffsetOptimization' transform
Long Parameter List,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,Initialize,The method has 8 parameters. Parameters: data' width' alphaTolerance' hullTolerance' holeDetection' multipartDetection' pixelOffsetOptimization' transform
Long Parameter List,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,DetectVertices,The method has 6 parameters. Parameters: data' width' hullTolerance' alphaTolerance' multiPartDetection' holeDetection
Long Parameter List,FarseerPhysics.Factories,PathManager,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PathManager.cs,EvenlyDistributeShapesAlongPath,The method has 6 parameters. Parameters: world' path' shapes' type' copies' userData
Long Parameter List,FarseerPhysics.Factories,PathManager,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PathManager.cs,EvenlyDistributeShapesAlongPath,The method has 5 parameters. Parameters: world' path' shapes' type' copies
Long Parameter List,FarseerPhysics.Factories,PathManager,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PathManager.cs,EvenlyDistributeShapesAlongPath,The method has 6 parameters. Parameters: world' path' shape' type' copies' userData
Long Parameter List,FarseerPhysics.Factories,PathManager,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PathManager.cs,EvenlyDistributeShapesAlongPath,The method has 5 parameters. Parameters: world' path' shape' type' copies
Long Parameter List,FarseerPhysics.Factories,PathManager,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PathManager.cs,MoveBodyOnPath,The method has 5 parameters. Parameters: path' body' time' strength' timeStep
Long Parameter List,FarseerPhysics.Factories,PathManager,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PathManager.cs,AttachBodiesWithRevoluteJoint,The method has 6 parameters. Parameters: world' bodies' localAnchorA' localAnchorB' connectFirstAndLast' collideConnected
Long Parameter List,FarseerPhysics.Factories,PathManager,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PathManager.cs,AttachBodiesWithSliderJoint,The method has 8 parameters. Parameters: world' bodies' localAnchorA' localAnchorB' connectFirstAndLast' collideConnected' minLength' maxLength
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\BodyFactory.cs,CreateRectangle,The method has 5 parameters. Parameters: world' width' height' density' userData
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\BodyFactory.cs,CreateRectangle,The method has 5 parameters. Parameters: world' width' height' density' position
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\BodyFactory.cs,CreateRectangle,The method has 6 parameters. Parameters: world' width' height' density' position' userData
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\BodyFactory.cs,CreateCircle,The method has 5 parameters. Parameters: world' radius' density' position' userData
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\BodyFactory.cs,CreateEllipse,The method has 5 parameters. Parameters: world' xRadius' yRadius' edges' density
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\BodyFactory.cs,CreateEllipse,The method has 6 parameters. Parameters: world' xRadius' yRadius' edges' density' userData
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\BodyFactory.cs,CreateEllipse,The method has 6 parameters. Parameters: world' xRadius' yRadius' edges' density' position
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\BodyFactory.cs,CreateEllipse,The method has 7 parameters. Parameters: world' xRadius' yRadius' edges' density' position' userData
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\BodyFactory.cs,CreatePolygon,The method has 5 parameters. Parameters: world' vertices' density' position' userData
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\BodyFactory.cs,CreateCompoundPolygon,The method has 5 parameters. Parameters: world' list' density' position' userData
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\BodyFactory.cs,CreateGear,The method has 6 parameters. Parameters: world' radius' numberOfTeeth' tipPercentage' toothHeight' density
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\BodyFactory.cs,CreateGear,The method has 7 parameters. Parameters: world' radius' numberOfTeeth' tipPercentage' toothHeight' density' userData
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\BodyFactory.cs,CreateCapsule,The method has 9 parameters. Parameters: world' height' topRadius' topEdges' bottomRadius' bottomEdges' density' position' userData
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\BodyFactory.cs,CreateCapsule,The method has 8 parameters. Parameters: world' height' topRadius' topEdges' bottomRadius' bottomEdges' density' position
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\BodyFactory.cs,CreateCapsule,The method has 5 parameters. Parameters: world' height' endRadius' density' userData
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\BodyFactory.cs,CreateRoundedRectangle,The method has 9 parameters. Parameters: world' width' height' xRadius' yRadius' segments' density' position' userData
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\BodyFactory.cs,CreateRoundedRectangle,The method has 8 parameters. Parameters: world' width' height' xRadius' yRadius' segments' density' position
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\BodyFactory.cs,CreateRoundedRectangle,The method has 7 parameters. Parameters: world' width' height' xRadius' yRadius' segments' density
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\BodyFactory.cs,CreateRoundedRectangle,The method has 8 parameters. Parameters: world' width' height' xRadius' yRadius' segments' density' userData
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\BodyFactory.cs,CreateBreakableBody,The method has 5 parameters. Parameters: world' vertices' density' position' userData
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\BodyFactory.cs,CreateLineArc,The method has 7 parameters. Parameters: world' radians' sides' radius' position' angle' closed
Long Parameter List,FarseerPhysics.Factories,BodyFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\BodyFactory.cs,CreateSolidArc,The method has 7 parameters. Parameters: world' density' radians' sides' radius' position' angle
Long Parameter List,FarseerPhysics.Factories,FixtureFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\FixtureFactory.cs,AttachRectangle,The method has 6 parameters. Parameters: width' height' density' offset' body' userData
Long Parameter List,FarseerPhysics.Factories,FixtureFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\FixtureFactory.cs,AttachRectangle,The method has 5 parameters. Parameters: width' height' density' offset' body
Long Parameter List,FarseerPhysics.Factories,FixtureFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\FixtureFactory.cs,AttachCircle,The method has 5 parameters. Parameters: radius' density' body' offset' userData
Long Parameter List,FarseerPhysics.Factories,FixtureFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\FixtureFactory.cs,AttachEllipse,The method has 5 parameters. Parameters: xRadius' yRadius' edges' density' body
Long Parameter List,FarseerPhysics.Factories,FixtureFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\FixtureFactory.cs,AttachEllipse,The method has 6 parameters. Parameters: xRadius' yRadius' edges' density' body' userData
Long Parameter List,FarseerPhysics.Factories,FixtureFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\FixtureFactory.cs,AttachLineArc,The method has 7 parameters. Parameters: radians' sides' radius' position' angle' closed' body
Long Parameter List,FarseerPhysics.Factories,FixtureFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\FixtureFactory.cs,AttachSolidArc,The method has 7 parameters. Parameters: density' radians' sides' radius' position' angle' body
Long Parameter List,FarseerPhysics.Factories,JointFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\JointFactory.cs,CreateWeldJoint,The method has 5 parameters. Parameters: world' bodyA' bodyB' localAnchorA' localAnchorB
Long Parameter List,FarseerPhysics.Factories,JointFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\JointFactory.cs,CreatePrismaticJoint,The method has 5 parameters. Parameters: world' bodyA' bodyB' localanchorB' axis
Long Parameter List,FarseerPhysics.Factories,JointFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\JointFactory.cs,CreateLineJoint,The method has 5 parameters. Parameters: world' bodyA' bodyB' localanchorB' axis
Long Parameter List,FarseerPhysics.Factories,JointFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\JointFactory.cs,CreateDistanceJoint,The method has 5 parameters. Parameters: world' bodyA' bodyB' anchorA' anchorB
Long Parameter List,FarseerPhysics.Factories,JointFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\JointFactory.cs,CreateFrictionJoint,The method has 5 parameters. Parameters: world' bodyA' bodyB' anchorA' anchorB
Long Parameter List,FarseerPhysics.Factories,JointFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\JointFactory.cs,CreatePulleyJoint,The method has 8 parameters. Parameters: world' bodyA' bodyB' groundAnchorA' groundAnchorB' anchorA' anchorB' ratio
Long Parameter List,FarseerPhysics.Factories,JointFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\JointFactory.cs,CreateSliderJoint,The method has 7 parameters. Parameters: world' bodyA' bodyB' anchorA' anchorB' minLength' maxLength
Long Parameter List,FarseerPhysics.Factories,LinkFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\LinkFactory.cs,CreateChain,The method has 9 parameters. Parameters: world' start' end' linkWidth' linkHeight' fixStart' fixEnd' numberOfLinks' linkDensity
Long Parameter List,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,Triangle,The method has 6 parameters. Parameters: x1' y1' x2' y2' x3' y3
Long Parameter List,FarseerPhysics.Common.Decomposition,FlipcodeDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\FlipcodeDecomposer.cs,Snip,The method has 6 parameters. Parameters: contour' u' v' w' n' V
Long Parameter List,Poly2Tri.Triangulation.Delaunay.Sweep,DTSweep,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\Sweep\DTSweep.cs,EdgeEvent,The method has 5 parameters. Parameters: tcx' ep' eq' triangle' point
Long Parameter List,Poly2Tri.Triangulation.Delaunay.Sweep,DTSweep,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\Sweep\DTSweep.cs,FlipEdgeEvent,The method has 5 parameters. Parameters: tcx' ep' eq' t' p
Long Parameter List,Poly2Tri.Triangulation.Delaunay.Sweep,DTSweep,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\Sweep\DTSweep.cs,NextFlipTriangle,The method has 6 parameters. Parameters: tcx' o' t' ot' p' op
Long Parameter List,Poly2Tri.Triangulation.Delaunay.Sweep,DTSweep,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\Sweep\DTSweep.cs,FlipScanEdgeEvent,The method has 6 parameters. Parameters: tcx' ep' eq' flipTriangle' t' p
Long Parameter List,FarseerPhysics.Common.PolygonManipulation,CuttingTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonManipulation\CuttingTools.cs,SplitShape,The method has 6 parameters. Parameters: fixture' entryPoint' exitPoint' splitSize' first' second
Long Parameter List,FarseerPhysics.Common.PolygonManipulation,YuPengClipper,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonManipulation\YuPengClipper.cs,CalculateResultChain,The method has 6 parameters. Parameters: poly1Coeff' poly1Simplicies' poly2Coeff' poly2Simplicies' clipType' resultSimplices
Long Parameter List,FarseerPhysics.Controllers,BuoyancyController,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Controllers\BuoyancyController.cs,BuoyancyController,The method has 5 parameters. Parameters: container' density' linearDragCoefficient' rotationalDragCoefficient' gravity
Long Parameter List,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\Contacts\ContactSolver.cs,Solve,The method has 5 parameters. Parameters: cc' index' normal' point' separation
Long Parameter List,FarseerPhysics.Dynamics.Joints,PrismaticJoint,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\Joints\PrismaticJoint.cs,PrismaticJoint,The method has 5 parameters. Parameters: bodyA' bodyB' localAnchorA' localAnchorB' axis
Long Parameter List,FarseerPhysics.Dynamics.Joints,PulleyJoint,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\Joints\PulleyJoint.cs,PulleyJoint,The method has 7 parameters. Parameters: bodyA' bodyB' groundAnchorA' groundAnchorB' localAnchorA' localAnchorB' ratio
Long Parameter List,FarseerPhysics.Dynamics.Joints,SliderJoint,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\Joints\SliderJoint.cs,SliderJoint,The method has 6 parameters. Parameters: bodyA' bodyB' localAnchorA' localAnchorB' minLength' maxlength
Long Parameter List,FarseerPhysics,DebugView,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\DebugView.cs,DrawPolygon,The method has 5 parameters. Parameters: vertices' count' red' blue' green
Long Parameter List,FarseerPhysics,DebugView,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\DebugView.cs,DrawSolidPolygon,The method has 5 parameters. Parameters: vertices' count' red' blue' green
Long Parameter List,FarseerPhysics,DebugView,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\DebugView.cs,DrawCircle,The method has 5 parameters. Parameters: center' radius' red' blue' green
Long Parameter List,FarseerPhysics,DebugView,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\DebugView.cs,DrawSolidCircle,The method has 6 parameters. Parameters: center' radius' axis' red' blue' green
Long Parameter List,FarseerPhysics,DebugView,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\DebugView.cs,DrawSegment,The method has 5 parameters. Parameters: start' end' red' blue' green
Long Statement,FarseerPhysics.Common,PolygonTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonTools.cs,CreateCapsule,The length of the statement  "                    "The top radius must be lower than height / 2. Higher values of top radius would create a circle' and not a half circle."' " is 122.
Long Statement,FarseerPhysics.Common,PolygonTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonTools.cs,CreateCapsule,The length of the statement  "                    "The bottom radius must be lower than height / 2. Higher values of bottom radius would create a circle' and not a half circle."' " is 128.
Long Statement,FarseerPhysics.Common,MSTerrain,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\MSTerrain.cs,GenerateTerrain,The length of the statement  "            List<Vertices> polys = MarchingSquares.DetectSquares(new AABB(new Vector2(ax' ay)' new Vector2(ax + CellSize' ay + CellSize))' SubCellSize' SubCellSize' _terrainMap' Iterations' true); " is 184.
Long Statement,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,SetTextureData,The length of the statement  "                throw new ArgumentOutOfRangeException("data"' "'data' length can't be less then 4. Your texture must be at least 2 x 2 pixels in size."); " is 137.
Long Statement,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,SetTextureData,The length of the statement  "                throw new ArgumentOutOfRangeException("width"' "'width' can't be less then 2. Your texture must be at least 2 x 2 pixels in size."); " is 132.
Long Statement,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\BayazitDecomposer.cs,CanSee,The length of the statement  "                if (LineTools.LineIntersect(At(i' vertices)' At(j' vertices)' At(k' vertices)' At(k + 1' vertices)' out intersectionPoint)) " is 123.
Long Statement,FarseerPhysics.Common.PolygonManipulation,CuttingTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonManipulation\CuttingTools.cs,SplitShape,The length of the statement  "                if (Vector2.Dot(MathUtils.Cross(localExitPoint - localEntryPoint' 1)' vertices[i] - localEntryPoint) > Settings.Epsilon) " is 120.
Long Statement,FarseerPhysics.Common.PolygonManipulation,YuPengClipper,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonManipulation\YuPengClipper.cs,Execute,The length of the statement  "            Debug.Assert(subject.IsSimple() && clip.IsSimple()' "Non simple input!"' "Input polygons must be simple (cannot intersect themselves)."); " is 137.
Long Statement,FarseerPhysics.Controllers,SimpleWindForce,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Controllers\SimpleWindForce.cs,ApplyForce,The length of the statement  "                    //forceVector = Vector2.Transform(forceVector' Matrix.CreateRotationZ((MathHelper.Pi - MathHelper.Pi/2) * (float)Randomize.NextDouble())); " is 138.
Long Statement,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\Contacts\ContactSolver.cs,SolveVelocityConstraints,The length of the statement  "                    // In order to account of the accumulated impulse 'a' (because of the iterative nature of the solver which only requires " is 120.
Complex Conditional,FarseerPhysics.Collision,AABB,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Collision.cs,Contains,The conditional expression  "(point.X > (LowerBound.X + Settings.Epsilon) && point.X < (UpperBound.X - Settings.Epsilon) &&                   (point.Y > (LowerBound.Y + Settings.Epsilon) && point.Y < (UpperBound.Y - Settings.Epsilon)))"  is complex.
Complex Conditional,FarseerPhysics.Common,LineTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\LineTools.cs,LineIntersect2,The conditional expression  "a0 == b0 || a0 == b1 || a1 == b0 || a1 == b1"  is complex.
Complex Conditional,FarseerPhysics.Common,LineTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\LineTools.cs,LineIntersect2,The conditional expression  "(0 < ua) && (ua < 1) && (0 < ub) && (ub < 1)"  is complex.
Complex Conditional,FarseerPhysics.Common,MSTerrain,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\MSTerrain.cs,ApplyTexture,The conditional expression  "x >= 0 && x < _localWidth && y >= 0 && y < _localHeight"  is complex.
Complex Conditional,FarseerPhysics.Common,MSTerrain,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\MSTerrain.cs,ApplyData,The conditional expression  "x >= 0 && x < _localWidth && y >= 0 && y < _localHeight"  is complex.
Complex Conditional,FarseerPhysics.Common,MSTerrain,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\MSTerrain.cs,ModifyTerrain,The conditional expression  "p.X >= 0 && p.X < _localWidth && p.Y >= 0 && p.Y < _localHeight"  is complex.
Complex Conditional,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,IsSolid,The conditional expression  "_tempIsSolidX >= 0 && _tempIsSolidX < _width && _tempIsSolidY >= 0 && _tempIsSolidY < _height"  is complex.
Complex Conditional,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,IsSolid,The conditional expression  "x >= 0 && x < _width && y >= 0 && y < _height"  is complex.
Complex Conditional,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,SearchHoleEntrance,The conditional expression  "startY > 0 && startY < _height && endY > 0 && endY < _height"  is complex.
Complex Conditional,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,SearchCrossingEdges,The conditional expression  "(vertex1.Y >= y && vertex2.Y <= y) ||                          (vertex1.Y <= y && vertex2.Y >= y)"  is complex.
Complex Conditional,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,IsNearPixel,The conditional expression  "x >= 0 && x <= _width && y >= 0 && y <= _height"  is complex.
Complex Conditional,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,GetNextHullPoint,The conditional expression  "x >= 0 && x < _width && y >= 0 && y <= _height"  is complex.
Complex Conditional,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\BayazitDecomposer.cs,CanSee,The conditional expression  "(k + 1) % vertices.Count == i || k == i || (k + 1) % vertices.Count == j || k == j"  is complex.
Complex Conditional,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,PolygonizeTriangles,The conditional expression  "((triangulated[i].X[0] == triangulated[i].X[1]) && (triangulated[i].Y[0] == triangulated[i].Y[1]))                      ||                      ((triangulated[i].X[1] == triangulated[i].X[2]) && (triangulated[i].Y[1] == triangulated[i].Y[2]))                      ||                      ((triangulated[i].X[0] == triangulated[i].X[2]) && (triangulated[i].Y[0] == triangulated[i].Y[2]))"  is complex.
Complex Conditional,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The conditional expression  "(p1 == Points[2] && p2 == Points[1]) || (p1 == Points[1] && p2 == Points[2])"  is complex.
Complex Conditional,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The conditional expression  "(p1 == Points[0] && p2 == Points[2]) || (p1 == Points[2] && p2 == Points[0])"  is complex.
Complex Conditional,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The conditional expression  "(p1 == Points[0] && p2 == Points[1]) || (p1 == Points[1] && p2 == Points[0])"  is complex.
Complex Conditional,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PhysicsLogic\Explosion.cs,Activate,The conditional expression  "(_data.Count() > 1)                          && (i == valIndex - 1)                          && (_data.Last().Body == _data.First().Body)                          && (_data.Last().Max == _data.First().Min)"  is complex.
Complex Conditional,FarseerPhysics.Controllers,GravityController,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Controllers\GravityController.cs,Update,The conditional expression  "body1 == body2 || (body1.IsStatic && body2.IsStatic) || !body2.Enabled"  is complex.
Complex Conditional,FarseerPhysics.Dynamics,ContactManager,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\ContactManager.cs,AddPair,The conditional expression  "fA == fixtureA && fB == fixtureB && iA == indexA && iB == indexB"  is complex.
Complex Conditional,FarseerPhysics.Dynamics,ContactManager,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\ContactManager.cs,AddPair,The conditional expression  "fA == fixtureB && fB == fixtureA && iA == indexB && iB == indexA"  is complex.
Complex Conditional,FarseerPhysics.Dynamics.Contacts,Contact,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\Contacts\Contact.cs,Create,The conditional expression  "(type1 >= type2 || (type1 == ShapeType.Edge && type2 == ShapeType.Polygon))                      &&                      !(type2 == ShapeType.Edge && type1 == ShapeType.Polygon)"  is complex.
Complex Conditional,FarseerPhysics.Dynamics.Contacts,Contact,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\Contacts\Contact.cs,Create,The conditional expression  "(type1 >= type2 || (type1 == ShapeType.Edge && type2 == ShapeType.Polygon))                      &&                      !(type2 == ShapeType.Edge && type1 == ShapeType.Polygon)"  is complex.
Virtual Method Call from Constructor,FarseerPhysics.Dynamics,Fixture,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\Fixture.cs,Fixture,The constructor "Fixture" calls a virtual method "Clone".
Magic Number,FarseerPhysics.Collision,AABB,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Collision.cs,AABB,The following statement contains a magic number: LowerBound = center - new Vector2(width / 2' height / 2);
Magic Number,FarseerPhysics.Collision,AABB,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Collision.cs,AABB,The following statement contains a magic number: LowerBound = center - new Vector2(width / 2' height / 2);
Magic Number,FarseerPhysics.Collision,AABB,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Collision.cs,AABB,The following statement contains a magic number: UpperBound = center + new Vector2(width / 2' height / 2);
Magic Number,FarseerPhysics.Collision,AABB,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Collision.cs,AABB,The following statement contains a magic number: UpperBound = center + new Vector2(width / 2' height / 2);
Magic Number,FarseerPhysics.Collision,AABB,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Collision.cs,RayCast,The following statement contains a magic number: for (int i = 0; i < 2; ++i)              {                  float absD_i = i == 0 ? absD.X : absD.Y;                  float lowerBound_i = i == 0 ? LowerBound.X : LowerBound.Y;                  float upperBound_i = i == 0 ? UpperBound.X : UpperBound.Y;                  float p_i = i == 0 ? p.X : p.Y;                    if (absD_i < Settings.Epsilon)                  {                      // Parallel.                      if (p_i < lowerBound_i || upperBound_i < p_i)                      {                          return false;                      }                  }                  else                  {                      float d_i = i == 0 ? d.X : d.Y;                        float inv_d = 1.0f / d_i;                      float t1 = (lowerBound_i - p_i) * inv_d;                      float t2 = (upperBound_i - p_i) * inv_d;                        // Sign of the normal vector.                      float s = -1.0f;                        if (t1 > t2)                      {                          MathUtils.Swap(ref t1' ref t2);                          s = 1.0f;                      }                        // Push the min up                      if (t1 > tmin)                      {                          if (i == 0)                          {                              normal.X = s;                          }                          else                          {                              normal.Y = s;                          }                            tmin = t1;                      }                        // Pull the max down                      tmax = Math.Min(tmax' t2);                        if (tmin > tmax)                      {                          return false;                      }                  }              }
Magic Number,FarseerPhysics.Collision,Collision,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Collision.cs,CollidePolygons,The following statement contains a magic number: if (np < 2)                  return;
Magic Number,FarseerPhysics.Collision,Collision,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Collision.cs,CollidePolygons,The following statement contains a magic number: if (np < 2)              {                  return;              }
Magic Number,FarseerPhysics.Collision,Collision,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Collision.cs,CollideEdgeAndPolygon,The following statement contains a magic number: _proxyA.Count = 2;
Magic Number,FarseerPhysics.Collision,Collision,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Collision.cs,ComputeEdgeSeparation,The following statement contains a magic number: for (int i = 0; i < 2; ++i)              {                  Vector2 n = _tmpNormals[i];                    // Adjacency                  bool valid1 = MathUtils.Cross(n' _limit11) >= -Settings.AngularSlop &&                                MathUtils.Cross(_limit12' n) >= -Settings.AngularSlop;                  bool valid2 = MathUtils.Cross(n' _limit21) >= -Settings.AngularSlop &&                                MathUtils.Cross(_limit22' n) >= -Settings.AngularSlop;                    if (valid1 == false || valid2 == false)                  {                      continue;                  }                    EPAxis axis;                  axis.Type = EPAxisType.EdgeA;                  axis.Index = i;                  axis.Separation = Settings.MaxFloat;                    for (int j = 0; j < _proxyB.Count; ++j)                  {                      float s = Vector2.Dot(n' _proxyB.Vertices[j] - _edgeA.V1);                      if (s < axis.Separation)                      {                          axis.Separation = s;                      }                  }                    if (axis.Separation > _radius)                  {                      return axis;                  }                    if (axis.Separation > bestAxis.Separation)                  {                      bestAxis = axis;                  }              }
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Distance.cs,ReadCache,The following statement contains a magic number: Debug.Assert(cache.Count <= 3);
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Distance.cs,GetSearchDirection,The following statement contains a magic number: switch (Count)              {                  case 1:                      return -V[0].W;                    case 2:                      {                          Vector2 e12 = V[1].W - V[0].W;                          float sgn = MathUtils.Cross(e12' -V[0].W);                          if (sgn > 0.0f)                          {                              // Origin is left of e12.                              return new Vector2(-e12.Y' e12.X);                          }                          else                          {                              // Origin is right of e12.                              return new Vector2(e12.Y' -e12.X);                          }                      }                    default:                      Debug.Assert(false);                      return Vector2.Zero;              }
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Distance.cs,GetClosestPoint,The following statement contains a magic number: switch (Count)              {                  case 0:                      Debug.Assert(false);                      return Vector2.Zero;                    case 1:                      return V[0].W;                    case 2:                      return V[0].A * V[0].W + V[1].A * V[1].W;                    case 3:                      return Vector2.Zero;                    default:                      Debug.Assert(false);                      return Vector2.Zero;              }
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Distance.cs,GetClosestPoint,The following statement contains a magic number: switch (Count)              {                  case 0:                      Debug.Assert(false);                      return Vector2.Zero;                    case 1:                      return V[0].W;                    case 2:                      return V[0].A * V[0].W + V[1].A * V[1].W;                    case 3:                      return Vector2.Zero;                    default:                      Debug.Assert(false);                      return Vector2.Zero;              }
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Distance.cs,GetWitnessPoints,The following statement contains a magic number: switch (Count)              {                  case 0:                      pA = Vector2.Zero;                      pB = Vector2.Zero;                      Debug.Assert(false);                      break;                    case 1:                      pA = V[0].WA;                      pB = V[0].WB;                      break;                    case 2:                      pA = V[0].A * V[0].WA + V[1].A * V[1].WA;                      pB = V[0].A * V[0].WB + V[1].A * V[1].WB;                      break;                    case 3:                      pA = V[0].A * V[0].WA + V[1].A * V[1].WA + V[2].A * V[2].WA;                      pB = pA;                      break;                    default:                      throw new Exception();              }
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Distance.cs,GetWitnessPoints,The following statement contains a magic number: switch (Count)              {                  case 0:                      pA = Vector2.Zero;                      pB = Vector2.Zero;                      Debug.Assert(false);                      break;                    case 1:                      pA = V[0].WA;                      pB = V[0].WB;                      break;                    case 2:                      pA = V[0].A * V[0].WA + V[1].A * V[1].WA;                      pB = V[0].A * V[0].WB + V[1].A * V[1].WB;                      break;                    case 3:                      pA = V[0].A * V[0].WA + V[1].A * V[1].WA + V[2].A * V[2].WA;                      pB = pA;                      break;                    default:                      throw new Exception();              }
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Distance.cs,GetWitnessPoints,The following statement contains a magic number: switch (Count)              {                  case 0:                      pA = Vector2.Zero;                      pB = Vector2.Zero;                      Debug.Assert(false);                      break;                    case 1:                      pA = V[0].WA;                      pB = V[0].WB;                      break;                    case 2:                      pA = V[0].A * V[0].WA + V[1].A * V[1].WA;                      pB = V[0].A * V[0].WB + V[1].A * V[1].WB;                      break;                    case 3:                      pA = V[0].A * V[0].WA + V[1].A * V[1].WA + V[2].A * V[2].WA;                      pB = pA;                      break;                    default:                      throw new Exception();              }
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Distance.cs,GetWitnessPoints,The following statement contains a magic number: switch (Count)              {                  case 0:                      pA = Vector2.Zero;                      pB = Vector2.Zero;                      Debug.Assert(false);                      break;                    case 1:                      pA = V[0].WA;                      pB = V[0].WB;                      break;                    case 2:                      pA = V[0].A * V[0].WA + V[1].A * V[1].WA;                      pB = V[0].A * V[0].WB + V[1].A * V[1].WB;                      break;                    case 3:                      pA = V[0].A * V[0].WA + V[1].A * V[1].WA + V[2].A * V[2].WA;                      pB = pA;                      break;                    default:                      throw new Exception();              }
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Distance.cs,GetMetric,The following statement contains a magic number: switch (Count)              {                  case 0:                      Debug.Assert(false);                      return 0.0f;                    case 1:                      return 0.0f;                    case 2:                      return (V[0].W - V[1].W).Length();                    case 3:                      return MathUtils.Cross(V[1].W - V[0].W' V[2].W - V[0].W);                    default:                      Debug.Assert(false);                      return 0.0f;              }
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Distance.cs,GetMetric,The following statement contains a magic number: switch (Count)              {                  case 0:                      Debug.Assert(false);                      return 0.0f;                    case 1:                      return 0.0f;                    case 2:                      return (V[0].W - V[1].W).Length();                    case 3:                      return MathUtils.Cross(V[1].W - V[0].W' V[2].W - V[0].W);                    default:                      Debug.Assert(false);                      return 0.0f;              }
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Distance.cs,GetMetric,The following statement contains a magic number: switch (Count)              {                  case 0:                      Debug.Assert(false);                      return 0.0f;                    case 1:                      return 0.0f;                    case 2:                      return (V[0].W - V[1].W).Length();                    case 3:                      return MathUtils.Cross(V[1].W - V[0].W' V[2].W - V[0].W);                    default:                      Debug.Assert(false);                      return 0.0f;              }
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Distance.cs,Solve2,The following statement contains a magic number: Count = 2;
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Distance.cs,Solve3,The following statement contains a magic number: Vector2 w3 = V[2].W;
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Distance.cs,Solve3,The following statement contains a magic number: if (d12_1 > 0.0f && d12_2 > 0.0f && d123_3 <= 0.0f)              {                  float inv_d12 = 1.0f / (d12_1 + d12_2);                  SimplexVertex v0_2 = V[0];                  SimplexVertex v1_2 = V[1];                  v0_2.A = d12_1 * inv_d12;                  v1_2.A = d12_2 * inv_d12;                  V[0] = v0_2;                  V[1] = v1_2;                  Count = 2;                  return;              }
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Distance.cs,Solve3,The following statement contains a magic number: if (d13_1 > 0.0f && d13_2 > 0.0f && d123_2 <= 0.0f)              {                  float inv_d13 = 1.0f / (d13_1 + d13_2);                  SimplexVertex v0_3 = V[0];                  SimplexVertex v2_3 = V[2];                  v0_3.A = d13_1 * inv_d13;                  v2_3.A = d13_2 * inv_d13;                  V[0] = v0_3;                  V[2] = v2_3;                  Count = 2;                  V[1] = V[2];                  return;              }
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Distance.cs,Solve3,The following statement contains a magic number: if (d13_1 > 0.0f && d13_2 > 0.0f && d123_2 <= 0.0f)              {                  float inv_d13 = 1.0f / (d13_1 + d13_2);                  SimplexVertex v0_3 = V[0];                  SimplexVertex v2_3 = V[2];                  v0_3.A = d13_1 * inv_d13;                  v2_3.A = d13_2 * inv_d13;                  V[0] = v0_3;                  V[2] = v2_3;                  Count = 2;                  V[1] = V[2];                  return;              }
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Distance.cs,Solve3,The following statement contains a magic number: if (d13_1 > 0.0f && d13_2 > 0.0f && d123_2 <= 0.0f)              {                  float inv_d13 = 1.0f / (d13_1 + d13_2);                  SimplexVertex v0_3 = V[0];                  SimplexVertex v2_3 = V[2];                  v0_3.A = d13_1 * inv_d13;                  v2_3.A = d13_2 * inv_d13;                  V[0] = v0_3;                  V[2] = v2_3;                  Count = 2;                  V[1] = V[2];                  return;              }
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Distance.cs,Solve3,The following statement contains a magic number: if (d13_1 > 0.0f && d13_2 > 0.0f && d123_2 <= 0.0f)              {                  float inv_d13 = 1.0f / (d13_1 + d13_2);                  SimplexVertex v0_3 = V[0];                  SimplexVertex v2_3 = V[2];                  v0_3.A = d13_1 * inv_d13;                  v2_3.A = d13_2 * inv_d13;                  V[0] = v0_3;                  V[2] = v2_3;                  Count = 2;                  V[1] = V[2];                  return;              }
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Distance.cs,Solve3,The following statement contains a magic number: if (d13_1 <= 0.0f && d23_1 <= 0.0f)              {                  SimplexVertex v2_5 = V[2];                  v2_5.A = 1.0f;                  V[2] = v2_5;                  Count = 1;                  V[0] = V[2];                  return;              }
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Distance.cs,Solve3,The following statement contains a magic number: if (d13_1 <= 0.0f && d23_1 <= 0.0f)              {                  SimplexVertex v2_5 = V[2];                  v2_5.A = 1.0f;                  V[2] = v2_5;                  Count = 1;                  V[0] = V[2];                  return;              }
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Distance.cs,Solve3,The following statement contains a magic number: if (d13_1 <= 0.0f && d23_1 <= 0.0f)              {                  SimplexVertex v2_5 = V[2];                  v2_5.A = 1.0f;                  V[2] = v2_5;                  Count = 1;                  V[0] = V[2];                  return;              }
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Distance.cs,Solve3,The following statement contains a magic number: if (d23_1 > 0.0f && d23_2 > 0.0f && d123_1 <= 0.0f)              {                  float inv_d23 = 1.0f / (d23_1 + d23_2);                  SimplexVertex v1_6 = V[1];                  SimplexVertex v2_6 = V[2];                  v1_6.A = d23_1 * inv_d23;                  v2_6.A = d23_2 * inv_d23;                  V[1] = v1_6;                  V[2] = v2_6;                  Count = 2;                  V[0] = V[2];                  return;              }
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Distance.cs,Solve3,The following statement contains a magic number: if (d23_1 > 0.0f && d23_2 > 0.0f && d123_1 <= 0.0f)              {                  float inv_d23 = 1.0f / (d23_1 + d23_2);                  SimplexVertex v1_6 = V[1];                  SimplexVertex v2_6 = V[2];                  v1_6.A = d23_1 * inv_d23;                  v2_6.A = d23_2 * inv_d23;                  V[1] = v1_6;                  V[2] = v2_6;                  Count = 2;                  V[0] = V[2];                  return;              }
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Distance.cs,Solve3,The following statement contains a magic number: if (d23_1 > 0.0f && d23_2 > 0.0f && d123_1 <= 0.0f)              {                  float inv_d23 = 1.0f / (d23_1 + d23_2);                  SimplexVertex v1_6 = V[1];                  SimplexVertex v2_6 = V[2];                  v1_6.A = d23_1 * inv_d23;                  v2_6.A = d23_2 * inv_d23;                  V[1] = v1_6;                  V[2] = v2_6;                  Count = 2;                  V[0] = V[2];                  return;              }
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Distance.cs,Solve3,The following statement contains a magic number: if (d23_1 > 0.0f && d23_2 > 0.0f && d123_1 <= 0.0f)              {                  float inv_d23 = 1.0f / (d23_1 + d23_2);                  SimplexVertex v1_6 = V[1];                  SimplexVertex v2_6 = V[2];                  v1_6.A = d23_1 * inv_d23;                  v2_6.A = d23_2 * inv_d23;                  V[1] = v1_6;                  V[2] = v2_6;                  Count = 2;                  V[0] = V[2];                  return;              }
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Distance.cs,Solve3,The following statement contains a magic number: SimplexVertex v2_7 = V[2];
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Distance.cs,Solve3,The following statement contains a magic number: V[2] = v2_7;
Magic Number,FarseerPhysics.Collision,Simplex,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Distance.cs,Solve3,The following statement contains a magic number: Count = 3;
Magic Number,FarseerPhysics.Collision,Distance,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Distance.cs,ComputeDistance,The following statement contains a magic number: const int k_maxIters = 20;
Magic Number,FarseerPhysics.Collision,Distance,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Distance.cs,ComputeDistance,The following statement contains a magic number: while (iter < k_maxIters)              {                  // Copy simplex so we can identify duplicates.                  int saveCount = simplex.Count;                  for (int i = 0; i < saveCount; ++i)                  {                      saveA[i] = simplex.V[i].IndexA;                      saveB[i] = simplex.V[i].IndexB;                  }                    switch (simplex.Count)                  {                      case 1:                          break;                        case 2:                          simplex.Solve2();                          break;                        case 3:                          simplex.Solve3();                          break;                        default:                          Debug.Assert(false);                          break;                  }                    // If we have 3 points' then the origin is in the corresponding triangle.                  if (simplex.Count == 3)                  {                      break;                  }                    // Compute closest point.                  Vector2 p = simplex.GetClosestPoint();                  distanceSqr2 = p.LengthSquared();                    // Ensure progress                  if (distanceSqr2 >= distanceSqr1)                  {                      //break;                  }                  distanceSqr1 = distanceSqr2;                    // Get search direction.                  Vector2 d = simplex.GetSearchDirection();                    // Ensure the search direction is numerically fit.                  if (d.LengthSquared() < Settings.Epsilon * Settings.Epsilon)                  {                      // The origin is probably contained by a line segment                      // or triangle. Thus the shapes are overlapped.                        // We can't return zero here even though there may be overlap.                      // In case the simplex is a point' segment' or triangle it is difficult                      // to determine if the origin is contained in the CSO or very close to it.                      break;                  }                    // Compute a tentative new simplex vertex using support points.                  SimplexVertex vertex = simplex.V[simplex.Count];                  vertex.IndexA = input.ProxyA.GetSupport(MathUtils.MultiplyT(ref input.TransformA.R' -d));                  vertex.WA = MathUtils.Multiply(ref input.TransformA' input.ProxyA.Vertices[vertex.IndexA]);                    vertex.IndexB = input.ProxyB.GetSupport(MathUtils.MultiplyT(ref input.TransformB.R' d));                  vertex.WB = MathUtils.Multiply(ref input.TransformB' input.ProxyB.Vertices[vertex.IndexB]);                  vertex.W = vertex.WB - vertex.WA;                  simplex.V[simplex.Count] = vertex;                    // Iteration count is equated to the number of support point calls.                  ++iter;                  ++GJKIters;                    // Check for duplicate support points. This is the main termination criteria.                  bool duplicate = false;                  for (int i = 0; i < saveCount; ++i)                  {                      if (vertex.IndexA == saveA[i] && vertex.IndexB == saveB[i])                      {                          duplicate = true;                          break;                      }                  }                    // If we found a duplicate support point we must exit to avoid cycling.                  if (duplicate)                  {                      break;                  }                    // New vertex is ok and needed.                  ++simplex.Count;              }
Magic Number,FarseerPhysics.Collision,Distance,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Distance.cs,ComputeDistance,The following statement contains a magic number: while (iter < k_maxIters)              {                  // Copy simplex so we can identify duplicates.                  int saveCount = simplex.Count;                  for (int i = 0; i < saveCount; ++i)                  {                      saveA[i] = simplex.V[i].IndexA;                      saveB[i] = simplex.V[i].IndexB;                  }                    switch (simplex.Count)                  {                      case 1:                          break;                        case 2:                          simplex.Solve2();                          break;                        case 3:                          simplex.Solve3();                          break;                        default:                          Debug.Assert(false);                          break;                  }                    // If we have 3 points' then the origin is in the corresponding triangle.                  if (simplex.Count == 3)                  {                      break;                  }                    // Compute closest point.                  Vector2 p = simplex.GetClosestPoint();                  distanceSqr2 = p.LengthSquared();                    // Ensure progress                  if (distanceSqr2 >= distanceSqr1)                  {                      //break;                  }                  distanceSqr1 = distanceSqr2;                    // Get search direction.                  Vector2 d = simplex.GetSearchDirection();                    // Ensure the search direction is numerically fit.                  if (d.LengthSquared() < Settings.Epsilon * Settings.Epsilon)                  {                      // The origin is probably contained by a line segment                      // or triangle. Thus the shapes are overlapped.                        // We can't return zero here even though there may be overlap.                      // In case the simplex is a point' segment' or triangle it is difficult                      // to determine if the origin is contained in the CSO or very close to it.                      break;                  }                    // Compute a tentative new simplex vertex using support points.                  SimplexVertex vertex = simplex.V[simplex.Count];                  vertex.IndexA = input.ProxyA.GetSupport(MathUtils.MultiplyT(ref input.TransformA.R' -d));                  vertex.WA = MathUtils.Multiply(ref input.TransformA' input.ProxyA.Vertices[vertex.IndexA]);                    vertex.IndexB = input.ProxyB.GetSupport(MathUtils.MultiplyT(ref input.TransformB.R' d));                  vertex.WB = MathUtils.Multiply(ref input.TransformB' input.ProxyB.Vertices[vertex.IndexB]);                  vertex.W = vertex.WB - vertex.WA;                  simplex.V[simplex.Count] = vertex;                    // Iteration count is equated to the number of support point calls.                  ++iter;                  ++GJKIters;                    // Check for duplicate support points. This is the main termination criteria.                  bool duplicate = false;                  for (int i = 0; i < saveCount; ++i)                  {                      if (vertex.IndexA == saveA[i] && vertex.IndexB == saveB[i])                      {                          duplicate = true;                          break;                      }                  }                    // If we found a duplicate support point we must exit to avoid cycling.                  if (duplicate)                  {                      break;                  }                    // New vertex is ok and needed.                  ++simplex.Count;              }
Magic Number,FarseerPhysics.Collision,Distance,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Distance.cs,ComputeDistance,The following statement contains a magic number: while (iter < k_maxIters)              {                  // Copy simplex so we can identify duplicates.                  int saveCount = simplex.Count;                  for (int i = 0; i < saveCount; ++i)                  {                      saveA[i] = simplex.V[i].IndexA;                      saveB[i] = simplex.V[i].IndexB;                  }                    switch (simplex.Count)                  {                      case 1:                          break;                        case 2:                          simplex.Solve2();                          break;                        case 3:                          simplex.Solve3();                          break;                        default:                          Debug.Assert(false);                          break;                  }                    // If we have 3 points' then the origin is in the corresponding triangle.                  if (simplex.Count == 3)                  {                      break;                  }                    // Compute closest point.                  Vector2 p = simplex.GetClosestPoint();                  distanceSqr2 = p.LengthSquared();                    // Ensure progress                  if (distanceSqr2 >= distanceSqr1)                  {                      //break;                  }                  distanceSqr1 = distanceSqr2;                    // Get search direction.                  Vector2 d = simplex.GetSearchDirection();                    // Ensure the search direction is numerically fit.                  if (d.LengthSquared() < Settings.Epsilon * Settings.Epsilon)                  {                      // The origin is probably contained by a line segment                      // or triangle. Thus the shapes are overlapped.                        // We can't return zero here even though there may be overlap.                      // In case the simplex is a point' segment' or triangle it is difficult                      // to determine if the origin is contained in the CSO or very close to it.                      break;                  }                    // Compute a tentative new simplex vertex using support points.                  SimplexVertex vertex = simplex.V[simplex.Count];                  vertex.IndexA = input.ProxyA.GetSupport(MathUtils.MultiplyT(ref input.TransformA.R' -d));                  vertex.WA = MathUtils.Multiply(ref input.TransformA' input.ProxyA.Vertices[vertex.IndexA]);                    vertex.IndexB = input.ProxyB.GetSupport(MathUtils.MultiplyT(ref input.TransformB.R' d));                  vertex.WB = MathUtils.Multiply(ref input.TransformB' input.ProxyB.Vertices[vertex.IndexB]);                  vertex.W = vertex.WB - vertex.WA;                  simplex.V[simplex.Count] = vertex;                    // Iteration count is equated to the number of support point calls.                  ++iter;                  ++GJKIters;                    // Check for duplicate support points. This is the main termination criteria.                  bool duplicate = false;                  for (int i = 0; i < saveCount; ++i)                  {                      if (vertex.IndexA == saveA[i] && vertex.IndexB == saveB[i])                      {                          duplicate = true;                          break;                      }                  }                    // If we found a duplicate support point we must exit to avoid cycling.                  if (duplicate)                  {                      break;                  }                    // New vertex is ok and needed.                  ++simplex.Count;              }
Magic Number,FarseerPhysics.Collision,DynamicTree<T>,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\DynamicTree.cs,DynamicTree,The following statement contains a magic number: _nodeCapacity = 16;
Magic Number,FarseerPhysics.Collision,DynamicTree<T>,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\DynamicTree.cs,AllocateNode,The following statement contains a magic number: if (_freeList == NullNode)              {                  Debug.Assert(_nodeCount == _nodeCapacity);                    // The free list is empty. Rebuild a bigger pool.                  DynamicTreeNode<T>[] oldNodes = _nodes;                  _nodeCapacity *= 2;                  _nodes = new DynamicTreeNode<T>[_nodeCapacity];                  Array.Copy(oldNodes' _nodes' _nodeCount);                    // Build a linked list for the free list. The parent                  // pointer becomes the "next" pointer.                  for (int i = _nodeCount; i < _nodeCapacity - 1; ++i)                  {                      _nodes[i].ParentOrNext = i + 1;                  }                  _nodes[_nodeCapacity - 1].ParentOrNext = NullNode;                  _freeList = _nodeCount;              }
Magic Number,FarseerPhysics.Collision,DynamicTreeBroadPhase,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\DynamicTreeBroadPhase.cs,DynamicTreeBroadPhase,The following statement contains a magic number: _pairCapacity = 16;
Magic Number,FarseerPhysics.Collision,DynamicTreeBroadPhase,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\DynamicTreeBroadPhase.cs,DynamicTreeBroadPhase,The following statement contains a magic number: _moveCapacity = 16;
Magic Number,FarseerPhysics.Collision,DynamicTreeBroadPhase,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\DynamicTreeBroadPhase.cs,UpdatePairs,The following statement contains a magic number: _tree.Rebalance(4);
Magic Number,FarseerPhysics.Collision,DynamicTreeBroadPhase,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\DynamicTreeBroadPhase.cs,BufferMove,The following statement contains a magic number: if (_moveCount == _moveCapacity)              {                  int[] oldBuffer = _moveBuffer;                  _moveCapacity *= 2;                  _moveBuffer = new int[_moveCapacity];                  Array.Copy(oldBuffer' _moveBuffer' _moveCount);              }
Magic Number,FarseerPhysics.Collision,DynamicTreeBroadPhase,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\DynamicTreeBroadPhase.cs,QueryCallback,The following statement contains a magic number: if (_pairCount == _pairCapacity)              {                  Pair[] oldBuffer = _pairBuffer;                  _pairCapacity *= 2;                  _pairBuffer = new Pair[_pairCapacity];                  Array.Copy(oldBuffer' _pairBuffer' _pairCount);              }
Magic Number,FarseerPhysics.Collision,SeparationFunction,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\TimeOfImpact.cs,Set,The following statement contains a magic number: Debug.Assert(0 < count && count < 3);
Magic Number,FarseerPhysics.Collision,TimeOfImpact,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\TimeOfImpact.cs,CalculateTimeOfImpact,The following statement contains a magic number: const int k_maxIterations = 20;
Magic Number,FarseerPhysics.Collision,TimeOfImpact,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\TimeOfImpact.cs,CalculateTimeOfImpact,The following statement contains a magic number: for (; ; )              {                  Transform xfA' xfB;                  sweepA.GetTransform(out xfA' t1);                  sweepB.GetTransform(out xfB' t1);                    // Get the distance between shapes. We can also use the results                  // to get a separating axis.                  _distanceInput.TransformA = xfA;                  _distanceInput.TransformB = xfB;                  DistanceOutput distanceOutput;                  Distance.ComputeDistance(out distanceOutput' out cache' _distanceInput);                    // If the shapes are overlapped' we give up on continuous collision.                  if (distanceOutput.Distance <= 0.0f)                  {                      // Failure!                      output.State = TOIOutputState.Overlapped;                      output.T = 0.0f;                      break;                  }                    if (distanceOutput.Distance < target + tolerance)                  {                      // Victory!                      output.State = TOIOutputState.Touching;                      output.T = t1;                      break;                  }                    SeparationFunction.Set(ref cache' input.ProxyA' ref sweepA' input.ProxyB' ref sweepB' t1);                    // Compute the TOI on the separating axis. We do this by successively                  // resolving the deepest point. This loop is bounded by the number of vertices.                  bool done = false;                  float t2 = tMax;                  int pushBackIter = 0;                  for (; ; )                  {                      // Find the deepest point at t2. Store the witness point indices.                      int indexA' indexB;                      float s2 = SeparationFunction.FindMinSeparation(out indexA' out indexB' t2);                        // Is the final configuration separated?                      if (s2 > target + tolerance)                      {                          // Victory!                          output.State = TOIOutputState.Seperated;                          output.T = tMax;                          done = true;                          break;                      }                        // Has the separation reached tolerance?                      if (s2 > target - tolerance)                      {                          // Advance the sweeps                          t1 = t2;                          break;                      }                        // Compute the initial separation of the witness points.                      float s1 = SeparationFunction.Evaluate(indexA' indexB' t1);                        // Check for initial overlap. This might happen if the root finder                      // runs out of iterations.                      if (s1 < target - tolerance)                      {                          output.State = TOIOutputState.Failed;                          output.T = t1;                          done = true;                          break;                      }                        // Check for touching                      if (s1 <= target + tolerance)                      {                          // Victory! t1 should hold the TOI (could be 0.0).                          output.State = TOIOutputState.Touching;                          output.T = t1;                          done = true;                          break;                      }                        // Compute 1D root of: f(x) - target = 0                      int rootIterCount = 0;                      float a1 = t1' a2 = t2;                      for (; ; )                      {                          // Use a mix of the secant rule and bisection.                          float t;                          if ((rootIterCount & 1) != 0)                          {                              // Secant rule to improve convergence.                              t = a1 + (target - s1) * (a2 - a1) / (s2 - s1);                          }                          else                          {                              // Bisection to guarantee progress.                              t = 0.5f * (a1 + a2);                          }                            float s = SeparationFunction.Evaluate(indexA' indexB' t);                            if (Math.Abs(s - target) < tolerance)                          {                              // t2 holds a tentative value for t1                              t2 = t;                              break;                          }                            // Ensure we continue to bracket the root.                          if (s > target)                          {                              a1 = t;                              s1 = s;                          }                          else                          {                              a2 = t;                              s2 = s;                          }                            ++rootIterCount;                          ++TOIRootIters;                            if (rootIterCount == 50)                          {                              break;                          }                      }                        TOIMaxRootIters = Math.Max(TOIMaxRootIters' rootIterCount);                        ++pushBackIter;                        if (pushBackIter == Settings.MaxPolygonVertices)                      {                          break;                      }                  }                    ++iter;                  ++TOIIters;                    if (done)                  {                      break;                  }                    if (iter == k_maxIterations)                  {                      // Root finder got stuck. Semi-victory.                      output.State = TOIOutputState.Failed;                      output.T = t1;                      break;                  }              }
Magic Number,FarseerPhysics.Collision.Shapes,CircleShape,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Shapes\CircleShape.cs,ComputeSubmergedArea,The following statement contains a magic number: float area = r2 * (float)((Math.Asin(l / Radius) + Settings.Pi / 2) + l * Math.Sqrt(r2 - l2));
Magic Number,FarseerPhysics.Collision.Shapes,LoopShape,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Shapes\LoopShape.cs,GetChildEdge,The following statement contains a magic number: Debug.Assert(2 <= Vertices.Count);
Magic Number,FarseerPhysics.Collision.Shapes,LoopShape,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Shapes\LoopShape.cs,GetChildEdge,The following statement contains a magic number: int i3 = index + 2;
Magic Number,FarseerPhysics.Collision.Shapes,PolygonShape,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Shapes\PolygonShape.cs,Set,The following statement contains a magic number: Debug.Assert(vertices.Count >= 3 && vertices.Count <= Settings.MaxPolygonVertices);
Magic Number,FarseerPhysics.Collision.Shapes,PolygonShape,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Shapes\PolygonShape.cs,ComputeProperties,The following statement contains a magic number: Debug.Assert(Vertices.Count >= 3);
Magic Number,FarseerPhysics.Collision.Shapes,MassData,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Shapes\Shape.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int result = Area.GetHashCode();                  result = (result * 397) ^ Centroid.GetHashCode();                  result = (result * 397) ^ Inertia.GetHashCode();                  result = (result * 397) ^ Mass.GetHashCode();                  return result;              }
Magic Number,FarseerPhysics.Collision.Shapes,MassData,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Shapes\Shape.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int result = Area.GetHashCode();                  result = (result * 397) ^ Centroid.GetHashCode();                  result = (result * 397) ^ Inertia.GetHashCode();                  result = (result * 397) ^ Mass.GetHashCode();                  return result;              }
Magic Number,FarseerPhysics.Collision.Shapes,MassData,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Shapes\Shape.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int result = Area.GetHashCode();                  result = (result * 397) ^ Centroid.GetHashCode();                  result = (result * 397) ^ Inertia.GetHashCode();                  result = (result * 397) ^ Mass.GetHashCode();                  return result;              }
Magic Number,FarseerPhysics.Common,MathUtils,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Math.cs,VectorAngle,The following statement contains a magic number: while (dtheta > Math.PI)                  dtheta -= (2 * Math.PI);
Magic Number,FarseerPhysics.Common,MathUtils,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Math.cs,VectorAngle,The following statement contains a magic number: while (dtheta < -Math.PI)                  dtheta += (2 * Math.PI);
Magic Number,FarseerPhysics.Common,Path,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Path.cs,GetPosition,The following statement contains a magic number: if (ControlPoints.Count < 2)                  throw new Exception("You need at least 2 control points to calculate a position.");
Magic Number,FarseerPhysics.Common,Path,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Path.cs,GetPosition,The following statement contains a magic number: if (Closed)              {                  Add(ControlPoints[0]);                    _deltaT = 1f / (ControlPoints.Count - 1);                    int p = (int)(time / _deltaT);                    // use a circular indexing system                  int p0 = p - 1;                  if (p0 < 0) p0 = p0 + (ControlPoints.Count - 1);                  else if (p0 >= ControlPoints.Count - 1) p0 = p0 - (ControlPoints.Count - 1);                  int p1 = p;                  if (p1 < 0) p1 = p1 + (ControlPoints.Count - 1);                  else if (p1 >= ControlPoints.Count - 1) p1 = p1 - (ControlPoints.Count - 1);                  int p2 = p + 1;                  if (p2 < 0) p2 = p2 + (ControlPoints.Count - 1);                  else if (p2 >= ControlPoints.Count - 1) p2 = p2 - (ControlPoints.Count - 1);                  int p3 = p + 2;                  if (p3 < 0) p3 = p3 + (ControlPoints.Count - 1);                  else if (p3 >= ControlPoints.Count - 1) p3 = p3 - (ControlPoints.Count - 1);                    // relative time                  float lt = (time - _deltaT * p) / _deltaT;                    temp = Vector2.CatmullRom(ControlPoints[p0]' ControlPoints[p1]' ControlPoints[p2]' ControlPoints[p3]' lt);                    RemoveAt(ControlPoints.Count - 1);              }              else              {                  int p = (int)(time / _deltaT);                    //                   int p0 = p - 1;                  if (p0 < 0) p0 = 0;                  else if (p0 >= ControlPoints.Count - 1) p0 = ControlPoints.Count - 1;                  int p1 = p;                  if (p1 < 0) p1 = 0;                  else if (p1 >= ControlPoints.Count - 1) p1 = ControlPoints.Count - 1;                  int p2 = p + 1;                  if (p2 < 0) p2 = 0;                  else if (p2 >= ControlPoints.Count - 1) p2 = ControlPoints.Count - 1;                  int p3 = p + 2;                  if (p3 < 0) p3 = 0;                  else if (p3 >= ControlPoints.Count - 1) p3 = ControlPoints.Count - 1;                    // relative time                  float lt = (time - _deltaT * p) / _deltaT;                    temp = Vector2.CatmullRom(ControlPoints[p0]' ControlPoints[p1]' ControlPoints[p2]' ControlPoints[p3]' lt);              }
Magic Number,FarseerPhysics.Common,Path,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Path.cs,GetPosition,The following statement contains a magic number: if (Closed)              {                  Add(ControlPoints[0]);                    _deltaT = 1f / (ControlPoints.Count - 1);                    int p = (int)(time / _deltaT);                    // use a circular indexing system                  int p0 = p - 1;                  if (p0 < 0) p0 = p0 + (ControlPoints.Count - 1);                  else if (p0 >= ControlPoints.Count - 1) p0 = p0 - (ControlPoints.Count - 1);                  int p1 = p;                  if (p1 < 0) p1 = p1 + (ControlPoints.Count - 1);                  else if (p1 >= ControlPoints.Count - 1) p1 = p1 - (ControlPoints.Count - 1);                  int p2 = p + 1;                  if (p2 < 0) p2 = p2 + (ControlPoints.Count - 1);                  else if (p2 >= ControlPoints.Count - 1) p2 = p2 - (ControlPoints.Count - 1);                  int p3 = p + 2;                  if (p3 < 0) p3 = p3 + (ControlPoints.Count - 1);                  else if (p3 >= ControlPoints.Count - 1) p3 = p3 - (ControlPoints.Count - 1);                    // relative time                  float lt = (time - _deltaT * p) / _deltaT;                    temp = Vector2.CatmullRom(ControlPoints[p0]' ControlPoints[p1]' ControlPoints[p2]' ControlPoints[p3]' lt);                    RemoveAt(ControlPoints.Count - 1);              }              else              {                  int p = (int)(time / _deltaT);                    //                   int p0 = p - 1;                  if (p0 < 0) p0 = 0;                  else if (p0 >= ControlPoints.Count - 1) p0 = ControlPoints.Count - 1;                  int p1 = p;                  if (p1 < 0) p1 = 0;                  else if (p1 >= ControlPoints.Count - 1) p1 = ControlPoints.Count - 1;                  int p2 = p + 1;                  if (p2 < 0) p2 = 0;                  else if (p2 >= ControlPoints.Count - 1) p2 = ControlPoints.Count - 1;                  int p3 = p + 2;                  if (p3 < 0) p3 = 0;                  else if (p3 >= ControlPoints.Count - 1) p3 = ControlPoints.Count - 1;                    // relative time                  float lt = (time - _deltaT * p) / _deltaT;                    temp = Vector2.CatmullRom(ControlPoints[p0]' ControlPoints[p1]' ControlPoints[p2]' ControlPoints[p3]' lt);              }
Magic Number,FarseerPhysics.Common,Path,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Path.cs,GetLength,The following statement contains a magic number: List<Vector2> verts = GetVertices(ControlPoints.Count * 25);
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonTools.cs,CreateRectangle,The following statement contains a magic number: Vertices vertices = new Vertices(4);
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonTools.cs,CreateRectangle,The following statement contains a magic number: for (int i = 0; i < 4; ++i)              {                  vertices[i] = MathUtils.Multiply(ref xf' vertices[i]);              }
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: if (yRadius > height / 2 || xRadius > width / 2)                  throw new Exception("Rounding amount can't be more than half the height and width respectively.");
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: if (yRadius > height / 2 || xRadius > width / 2)                  throw new Exception("Rounding amount can't be more than half the height and width respectively.");
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: Debug.Assert(Settings.MaxPolygonVertices >= 8);
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: if (segments == 0)              {                  vertices.Add(new Vector2(width * .5f - xRadius' -height * .5f));                  vertices.Add(new Vector2(width * .5f' -height * .5f + yRadius));                    vertices.Add(new Vector2(width * .5f' height * .5f - yRadius));                  vertices.Add(new Vector2(width * .5f - xRadius' height * .5f));                    vertices.Add(new Vector2(-width * .5f + xRadius' height * .5f));                  vertices.Add(new Vector2(-width * .5f' height * .5f - yRadius));                    vertices.Add(new Vector2(-width * .5f' -height * .5f + yRadius));                  vertices.Add(new Vector2(-width * .5f + xRadius' -height * .5f));              }              else              {                  int numberOfEdges = (segments * 4 + 8);                    float stepSize = MathHelper.TwoPi / (numberOfEdges - 4);                  int perPhase = numberOfEdges / 4;                    Vector2 posOffset = new Vector2(width / 2 - xRadius' height / 2 - yRadius);                  vertices.Add(posOffset + new Vector2(xRadius' -yRadius + yRadius));                  short phase = 0;                  for (int i = 1; i < numberOfEdges; i++)                  {                      if (i - perPhase == 0 || i - perPhase * 3 == 0)                      {                          posOffset.X *= -1;                          phase--;                      }                      else if (i - perPhase * 2 == 0)                      {                          posOffset.Y *= -1;                          phase--;                      }                        vertices.Add(posOffset + new Vector2(xRadius * (float)Math.Cos(stepSize * -(i + phase))'                                                           -yRadius * (float)Math.Sin(stepSize * -(i + phase))));                  }              }
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: if (segments == 0)              {                  vertices.Add(new Vector2(width * .5f - xRadius' -height * .5f));                  vertices.Add(new Vector2(width * .5f' -height * .5f + yRadius));                    vertices.Add(new Vector2(width * .5f' height * .5f - yRadius));                  vertices.Add(new Vector2(width * .5f - xRadius' height * .5f));                    vertices.Add(new Vector2(-width * .5f + xRadius' height * .5f));                  vertices.Add(new Vector2(-width * .5f' height * .5f - yRadius));                    vertices.Add(new Vector2(-width * .5f' -height * .5f + yRadius));                  vertices.Add(new Vector2(-width * .5f + xRadius' -height * .5f));              }              else              {                  int numberOfEdges = (segments * 4 + 8);                    float stepSize = MathHelper.TwoPi / (numberOfEdges - 4);                  int perPhase = numberOfEdges / 4;                    Vector2 posOffset = new Vector2(width / 2 - xRadius' height / 2 - yRadius);                  vertices.Add(posOffset + new Vector2(xRadius' -yRadius + yRadius));                  short phase = 0;                  for (int i = 1; i < numberOfEdges; i++)                  {                      if (i - perPhase == 0 || i - perPhase * 3 == 0)                      {                          posOffset.X *= -1;                          phase--;                      }                      else if (i - perPhase * 2 == 0)                      {                          posOffset.Y *= -1;                          phase--;                      }                        vertices.Add(posOffset + new Vector2(xRadius * (float)Math.Cos(stepSize * -(i + phase))'                                                           -yRadius * (float)Math.Sin(stepSize * -(i + phase))));                  }              }
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: if (segments == 0)              {                  vertices.Add(new Vector2(width * .5f - xRadius' -height * .5f));                  vertices.Add(new Vector2(width * .5f' -height * .5f + yRadius));                    vertices.Add(new Vector2(width * .5f' height * .5f - yRadius));                  vertices.Add(new Vector2(width * .5f - xRadius' height * .5f));                    vertices.Add(new Vector2(-width * .5f + xRadius' height * .5f));                  vertices.Add(new Vector2(-width * .5f' height * .5f - yRadius));                    vertices.Add(new Vector2(-width * .5f' -height * .5f + yRadius));                  vertices.Add(new Vector2(-width * .5f + xRadius' -height * .5f));              }              else              {                  int numberOfEdges = (segments * 4 + 8);                    float stepSize = MathHelper.TwoPi / (numberOfEdges - 4);                  int perPhase = numberOfEdges / 4;                    Vector2 posOffset = new Vector2(width / 2 - xRadius' height / 2 - yRadius);                  vertices.Add(posOffset + new Vector2(xRadius' -yRadius + yRadius));                  short phase = 0;                  for (int i = 1; i < numberOfEdges; i++)                  {                      if (i - perPhase == 0 || i - perPhase * 3 == 0)                      {                          posOffset.X *= -1;                          phase--;                      }                      else if (i - perPhase * 2 == 0)                      {                          posOffset.Y *= -1;                          phase--;                      }                        vertices.Add(posOffset + new Vector2(xRadius * (float)Math.Cos(stepSize * -(i + phase))'                                                           -yRadius * (float)Math.Sin(stepSize * -(i + phase))));                  }              }
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: if (segments == 0)              {                  vertices.Add(new Vector2(width * .5f - xRadius' -height * .5f));                  vertices.Add(new Vector2(width * .5f' -height * .5f + yRadius));                    vertices.Add(new Vector2(width * .5f' height * .5f - yRadius));                  vertices.Add(new Vector2(width * .5f - xRadius' height * .5f));                    vertices.Add(new Vector2(-width * .5f + xRadius' height * .5f));                  vertices.Add(new Vector2(-width * .5f' height * .5f - yRadius));                    vertices.Add(new Vector2(-width * .5f' -height * .5f + yRadius));                  vertices.Add(new Vector2(-width * .5f + xRadius' -height * .5f));              }              else              {                  int numberOfEdges = (segments * 4 + 8);                    float stepSize = MathHelper.TwoPi / (numberOfEdges - 4);                  int perPhase = numberOfEdges / 4;                    Vector2 posOffset = new Vector2(width / 2 - xRadius' height / 2 - yRadius);                  vertices.Add(posOffset + new Vector2(xRadius' -yRadius + yRadius));                  short phase = 0;                  for (int i = 1; i < numberOfEdges; i++)                  {                      if (i - perPhase == 0 || i - perPhase * 3 == 0)                      {                          posOffset.X *= -1;                          phase--;                      }                      else if (i - perPhase * 2 == 0)                      {                          posOffset.Y *= -1;                          phase--;                      }                        vertices.Add(posOffset + new Vector2(xRadius * (float)Math.Cos(stepSize * -(i + phase))'                                                           -yRadius * (float)Math.Sin(stepSize * -(i + phase))));                  }              }
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: if (segments == 0)              {                  vertices.Add(new Vector2(width * .5f - xRadius' -height * .5f));                  vertices.Add(new Vector2(width * .5f' -height * .5f + yRadius));                    vertices.Add(new Vector2(width * .5f' height * .5f - yRadius));                  vertices.Add(new Vector2(width * .5f - xRadius' height * .5f));                    vertices.Add(new Vector2(-width * .5f + xRadius' height * .5f));                  vertices.Add(new Vector2(-width * .5f' height * .5f - yRadius));                    vertices.Add(new Vector2(-width * .5f' -height * .5f + yRadius));                  vertices.Add(new Vector2(-width * .5f + xRadius' -height * .5f));              }              else              {                  int numberOfEdges = (segments * 4 + 8);                    float stepSize = MathHelper.TwoPi / (numberOfEdges - 4);                  int perPhase = numberOfEdges / 4;                    Vector2 posOffset = new Vector2(width / 2 - xRadius' height / 2 - yRadius);                  vertices.Add(posOffset + new Vector2(xRadius' -yRadius + yRadius));                  short phase = 0;                  for (int i = 1; i < numberOfEdges; i++)                  {                      if (i - perPhase == 0 || i - perPhase * 3 == 0)                      {                          posOffset.X *= -1;                          phase--;                      }                      else if (i - perPhase * 2 == 0)                      {                          posOffset.Y *= -1;                          phase--;                      }                        vertices.Add(posOffset + new Vector2(xRadius * (float)Math.Cos(stepSize * -(i + phase))'                                                           -yRadius * (float)Math.Sin(stepSize * -(i + phase))));                  }              }
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: if (segments == 0)              {                  vertices.Add(new Vector2(width * .5f - xRadius' -height * .5f));                  vertices.Add(new Vector2(width * .5f' -height * .5f + yRadius));                    vertices.Add(new Vector2(width * .5f' height * .5f - yRadius));                  vertices.Add(new Vector2(width * .5f - xRadius' height * .5f));                    vertices.Add(new Vector2(-width * .5f + xRadius' height * .5f));                  vertices.Add(new Vector2(-width * .5f' height * .5f - yRadius));                    vertices.Add(new Vector2(-width * .5f' -height * .5f + yRadius));                  vertices.Add(new Vector2(-width * .5f + xRadius' -height * .5f));              }              else              {                  int numberOfEdges = (segments * 4 + 8);                    float stepSize = MathHelper.TwoPi / (numberOfEdges - 4);                  int perPhase = numberOfEdges / 4;                    Vector2 posOffset = new Vector2(width / 2 - xRadius' height / 2 - yRadius);                  vertices.Add(posOffset + new Vector2(xRadius' -yRadius + yRadius));                  short phase = 0;                  for (int i = 1; i < numberOfEdges; i++)                  {                      if (i - perPhase == 0 || i - perPhase * 3 == 0)                      {                          posOffset.X *= -1;                          phase--;                      }                      else if (i - perPhase * 2 == 0)                      {                          posOffset.Y *= -1;                          phase--;                      }                        vertices.Add(posOffset + new Vector2(xRadius * (float)Math.Cos(stepSize * -(i + phase))'                                                           -yRadius * (float)Math.Sin(stepSize * -(i + phase))));                  }              }
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: if (segments == 0)              {                  vertices.Add(new Vector2(width * .5f - xRadius' -height * .5f));                  vertices.Add(new Vector2(width * .5f' -height * .5f + yRadius));                    vertices.Add(new Vector2(width * .5f' height * .5f - yRadius));                  vertices.Add(new Vector2(width * .5f - xRadius' height * .5f));                    vertices.Add(new Vector2(-width * .5f + xRadius' height * .5f));                  vertices.Add(new Vector2(-width * .5f' height * .5f - yRadius));                    vertices.Add(new Vector2(-width * .5f' -height * .5f + yRadius));                  vertices.Add(new Vector2(-width * .5f + xRadius' -height * .5f));              }              else              {                  int numberOfEdges = (segments * 4 + 8);                    float stepSize = MathHelper.TwoPi / (numberOfEdges - 4);                  int perPhase = numberOfEdges / 4;                    Vector2 posOffset = new Vector2(width / 2 - xRadius' height / 2 - yRadius);                  vertices.Add(posOffset + new Vector2(xRadius' -yRadius + yRadius));                  short phase = 0;                  for (int i = 1; i < numberOfEdges; i++)                  {                      if (i - perPhase == 0 || i - perPhase * 3 == 0)                      {                          posOffset.X *= -1;                          phase--;                      }                      else if (i - perPhase * 2 == 0)                      {                          posOffset.Y *= -1;                          phase--;                      }                        vertices.Add(posOffset + new Vector2(xRadius * (float)Math.Cos(stepSize * -(i + phase))'                                                           -yRadius * (float)Math.Sin(stepSize * -(i + phase))));                  }              }
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonTools.cs,CreateRoundedRectangle,The following statement contains a magic number: if (segments == 0)              {                  vertices.Add(new Vector2(width * .5f - xRadius' -height * .5f));                  vertices.Add(new Vector2(width * .5f' -height * .5f + yRadius));                    vertices.Add(new Vector2(width * .5f' height * .5f - yRadius));                  vertices.Add(new Vector2(width * .5f - xRadius' height * .5f));                    vertices.Add(new Vector2(-width * .5f + xRadius' height * .5f));                  vertices.Add(new Vector2(-width * .5f' height * .5f - yRadius));                    vertices.Add(new Vector2(-width * .5f' -height * .5f + yRadius));                  vertices.Add(new Vector2(-width * .5f + xRadius' -height * .5f));              }              else              {                  int numberOfEdges = (segments * 4 + 8);                    float stepSize = MathHelper.TwoPi / (numberOfEdges - 4);                  int perPhase = numberOfEdges / 4;                    Vector2 posOffset = new Vector2(width / 2 - xRadius' height / 2 - yRadius);                  vertices.Add(posOffset + new Vector2(xRadius' -yRadius + yRadius));                  short phase = 0;                  for (int i = 1; i < numberOfEdges; i++)                  {                      if (i - perPhase == 0 || i - perPhase * 3 == 0)                      {                          posOffset.X *= -1;                          phase--;                      }                      else if (i - perPhase * 2 == 0)                      {                          posOffset.Y *= -1;                          phase--;                      }                        vertices.Add(posOffset + new Vector2(xRadius * (float)Math.Cos(stepSize * -(i + phase))'                                                           -yRadius * (float)Math.Sin(stepSize * -(i + phase))));                  }              }
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonTools.cs,CreateLine,The following statement contains a magic number: Vertices vertices = new Vertices(2);
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonTools.cs,CreateCapsule,The following statement contains a magic number: if (endRadius >= height / 2)                  throw new ArgumentException(                      "The radius must be lower than height / 2. Higher values of radius would create a circle' and not a half circle."'                      "endRadius");
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonTools.cs,CreateCapsule,The following statement contains a magic number: if (topRadius >= height / 2)                  throw new ArgumentException(                      "The top radius must be lower than height / 2. Higher values of top radius would create a circle' and not a half circle."'                      "topRadius");
Magic Number,FarseerPhysics.Common,PolygonTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonTools.cs,CreateCapsule,The following statement contains a magic number: if (bottomRadius >= height / 2)                  throw new ArgumentException(                      "The bottom radius must be lower than height / 2. Higher values of bottom radius would create a circle' and not a half circle."'                      "bottomRadius");
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Vertices.cs,IsCounterClockWise,The following statement contains a magic number: if (Count < 3)                  return true;
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Vertices.cs,CheckPolygon,The following statement contains a magic number: if (Count < 3 || Count > Settings.MaxPolygonVertices)              {                  error = 0;              }
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Vertices.cs,CheckPolygon,The following statement contains a magic number: if (!IsSimple())              {                  error = 2;              }
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Vertices.cs,CheckPolygon,The following statement contains a magic number: if (GetArea() < Settings.Epsilon)              {                  error = 3;              }
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Vertices.cs,CheckPolygon,The following statement contains a magic number: for (int i = 0; i < Count; ++i)              {                  int iminus = (i == 0) ? Count - 1 : i - 1;                    //Parallel sides check                  float cross = MathUtils.Cross(normals[iminus]' normals[i]);                  cross = MathUtils.Clamp(cross' -1.0f' 1.0f);                  float angle = (float)Math.Asin(cross);                  if (angle <= Settings.AngularSlop)                  {                      error = 4;                      break;                  }                    //Too skinny check                  for (int j = 0; j < Count; ++j)                  {                      if (j == i || j == (i + 1) % Count)                      {                          continue;                      }                      float s = Vector2.Dot(normals[i]' vertices[j] - vertices[i]);                      if (s >= -Settings.LinearSlop)                      {                          error = 5;                      }                  }                      Vector2 centroid = vertices.GetCentroid();                  Vector2 n1 = normals[iminus];                  Vector2 n2 = normals[i];                  Vector2 v = vertices[i] - centroid;                    Vector2 d = new Vector2();                  d.X = Vector2.Dot(n1' v); // - toiSlop;                  d.Y = Vector2.Dot(n2' v); // - toiSlop;                    // Shifting the edge inward by toiSlop should                  // not cause the plane to pass the centroid.                  if ((d.X < 0.0f) || (d.Y < 0.0f))                  {                      error = 6;                  }              }
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Vertices.cs,CheckPolygon,The following statement contains a magic number: for (int i = 0; i < Count; ++i)              {                  int iminus = (i == 0) ? Count - 1 : i - 1;                    //Parallel sides check                  float cross = MathUtils.Cross(normals[iminus]' normals[i]);                  cross = MathUtils.Clamp(cross' -1.0f' 1.0f);                  float angle = (float)Math.Asin(cross);                  if (angle <= Settings.AngularSlop)                  {                      error = 4;                      break;                  }                    //Too skinny check                  for (int j = 0; j < Count; ++j)                  {                      if (j == i || j == (i + 1) % Count)                      {                          continue;                      }                      float s = Vector2.Dot(normals[i]' vertices[j] - vertices[i]);                      if (s >= -Settings.LinearSlop)                      {                          error = 5;                      }                  }                      Vector2 centroid = vertices.GetCentroid();                  Vector2 n1 = normals[iminus];                  Vector2 n2 = normals[i];                  Vector2 v = vertices[i] - centroid;                    Vector2 d = new Vector2();                  d.X = Vector2.Dot(n1' v); // - toiSlop;                  d.Y = Vector2.Dot(n2' v); // - toiSlop;                    // Shifting the edge inward by toiSlop should                  // not cause the plane to pass the centroid.                  if ((d.X < 0.0f) || (d.Y < 0.0f))                  {                      error = 6;                  }              }
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Vertices.cs,CheckPolygon,The following statement contains a magic number: for (int i = 0; i < Count; ++i)              {                  int iminus = (i == 0) ? Count - 1 : i - 1;                    //Parallel sides check                  float cross = MathUtils.Cross(normals[iminus]' normals[i]);                  cross = MathUtils.Clamp(cross' -1.0f' 1.0f);                  float angle = (float)Math.Asin(cross);                  if (angle <= Settings.AngularSlop)                  {                      error = 4;                      break;                  }                    //Too skinny check                  for (int j = 0; j < Count; ++j)                  {                      if (j == i || j == (i + 1) % Count)                      {                          continue;                      }                      float s = Vector2.Dot(normals[i]' vertices[j] - vertices[i]);                      if (s >= -Settings.LinearSlop)                      {                          error = 5;                      }                  }                      Vector2 centroid = vertices.GetCentroid();                  Vector2 n1 = normals[iminus];                  Vector2 n2 = normals[i];                  Vector2 v = vertices[i] - centroid;                    Vector2 d = new Vector2();                  d.X = Vector2.Dot(n1' v); // - toiSlop;                  d.Y = Vector2.Dot(n2' v); // - toiSlop;                    // Shifting the edge inward by toiSlop should                  // not cause the plane to pass the centroid.                  if ((d.X < 0.0f) || (d.Y < 0.0f))                  {                      error = 6;                  }              }
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Vertices.cs,CheckPolygon,The following statement contains a magic number: if (error != -1)              {                  Debug.WriteLine("Found invalid polygon' ");                  switch (error)                  {                      case 0:                          Debug.WriteLine(string.Format("must have between 3 and {0} vertices.\n"'                                                        Settings.MaxPolygonVertices));                          break;                      case 1:                          Debug.WriteLine("must be convex.\n");                          break;                      case 2:                          Debug.WriteLine("must be simple (cannot intersect itself).\n");                          break;                      case 3:                          Debug.WriteLine("area is too small.\n");                          break;                      case 4:                          Debug.WriteLine("sides are too close to parallel.\n");                          break;                      case 5:                          Debug.WriteLine("polygon is too thin.\n");                          break;                      case 6:                          Debug.WriteLine("core shape generation would move edge past centroid (too thin).\n");                          break;                      default:                          Debug.WriteLine("don't know why.\n");                          break;                  }              }
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Vertices.cs,CheckPolygon,The following statement contains a magic number: if (error != -1)              {                  Debug.WriteLine("Found invalid polygon' ");                  switch (error)                  {                      case 0:                          Debug.WriteLine(string.Format("must have between 3 and {0} vertices.\n"'                                                        Settings.MaxPolygonVertices));                          break;                      case 1:                          Debug.WriteLine("must be convex.\n");                          break;                      case 2:                          Debug.WriteLine("must be simple (cannot intersect itself).\n");                          break;                      case 3:                          Debug.WriteLine("area is too small.\n");                          break;                      case 4:                          Debug.WriteLine("sides are too close to parallel.\n");                          break;                      case 5:                          Debug.WriteLine("polygon is too thin.\n");                          break;                      case 6:                          Debug.WriteLine("core shape generation would move edge past centroid (too thin).\n");                          break;                      default:                          Debug.WriteLine("don't know why.\n");                          break;                  }              }
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Vertices.cs,CheckPolygon,The following statement contains a magic number: if (error != -1)              {                  Debug.WriteLine("Found invalid polygon' ");                  switch (error)                  {                      case 0:                          Debug.WriteLine(string.Format("must have between 3 and {0} vertices.\n"'                                                        Settings.MaxPolygonVertices));                          break;                      case 1:                          Debug.WriteLine("must be convex.\n");                          break;                      case 2:                          Debug.WriteLine("must be simple (cannot intersect itself).\n");                          break;                      case 3:                          Debug.WriteLine("area is too small.\n");                          break;                      case 4:                          Debug.WriteLine("sides are too close to parallel.\n");                          break;                      case 5:                          Debug.WriteLine("polygon is too thin.\n");                          break;                      case 6:                          Debug.WriteLine("core shape generation would move edge past centroid (too thin).\n");                          break;                      default:                          Debug.WriteLine("don't know why.\n");                          break;                  }              }
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Vertices.cs,CheckPolygon,The following statement contains a magic number: if (error != -1)              {                  Debug.WriteLine("Found invalid polygon' ");                  switch (error)                  {                      case 0:                          Debug.WriteLine(string.Format("must have between 3 and {0} vertices.\n"'                                                        Settings.MaxPolygonVertices));                          break;                      case 1:                          Debug.WriteLine("must be convex.\n");                          break;                      case 2:                          Debug.WriteLine("must be simple (cannot intersect itself).\n");                          break;                      case 3:                          Debug.WriteLine("area is too small.\n");                          break;                      case 4:                          Debug.WriteLine("sides are too close to parallel.\n");                          break;                      case 5:                          Debug.WriteLine("polygon is too thin.\n");                          break;                      case 6:                          Debug.WriteLine("core shape generation would move edge past centroid (too thin).\n");                          break;                      default:                          Debug.WriteLine("don't know why.\n");                          break;                  }              }
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Vertices.cs,CheckPolygon,The following statement contains a magic number: if (error != -1)              {                  Debug.WriteLine("Found invalid polygon' ");                  switch (error)                  {                      case 0:                          Debug.WriteLine(string.Format("must have between 3 and {0} vertices.\n"'                                                        Settings.MaxPolygonVertices));                          break;                      case 1:                          Debug.WriteLine("must be convex.\n");                          break;                      case 2:                          Debug.WriteLine("must be simple (cannot intersect itself).\n");                          break;                      case 3:                          Debug.WriteLine("area is too small.\n");                          break;                      case 4:                          Debug.WriteLine("sides are too close to parallel.\n");                          break;                      case 5:                          Debug.WriteLine("polygon is too thin.\n");                          break;                      case 6:                          Debug.WriteLine("core shape generation would move edge past centroid (too thin).\n");                          break;                      default:                          Debug.WriteLine("don't know why.\n");                          break;                  }              }
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Vertices.cs,TraceEdge,The following statement contains a magic number: while (foundDupe)              {                  foundDupe = false;                  for (int i = 0; i < nNodes; ++i)                  {                      if (nodes[i].NConnected == 0) continue;                      for (int j = i + 1; j < nNodes; ++j)                      {                          if (nodes[j].NConnected == 0) continue;                          Vector2 diff = nodes[i].Position - nodes[j].Position;                          if (diff.LengthSquared() <= Settings.Epsilon * Settings.Epsilon)                          {                              if (nActive <= 3)                                  return new Vertices();                                //printf("Found dupe' %d left\n"'nActive);                              --nActive;                              foundDupe = true;                              PolyNode inode = nodes[i];                              PolyNode jnode = nodes[j];                              //Move all of j's connections to i' and orphan j                              int njConn = jnode.NConnected;                              for (int k = 0; k < njConn; ++k)                              {                                  PolyNode knode = jnode.Connected[k];                                  Debug.Assert(knode != jnode);                                  if (knode != inode)                                  {                                      inode.AddConnection(knode);                                      knode.AddConnection(inode);                                  }                                  knode.RemoveConnection(jnode);                              }                              jnode.NConnected = 0;                          }                      }                  }              }
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Vertices.cs,TraceEdge,The following statement contains a magic number: Vector2[] resultVecs = new Vector2[4 * nNodes];
Magic Number,FarseerPhysics.Common,Vertices,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Vertices.cs,TraceEdge,The following statement contains a magic number: while (nextNode != startNode)              {                  if (nResultVecs > 4 * nNodes)                  {                      Debug.Assert(false);                  }                  resultVecs[nResultVecs++] = nextNode.Position;                  PolyNode oldNode = currentNode;                  currentNode = nextNode;                  nextNode = currentNode.GetRightestConnection(oldNode);                  if (nextNode == null)                  {                      Vertices vertices = new Vertices(nResultVecs);                      for (int i = 0; i < nResultVecs; ++i)                      {                          vertices.Add(resultVecs[i]);                      }                      return vertices;                  }                  // There was a problem' so jump out of the loop and use whatever garbage we've generated so far              }
Magic Number,FarseerPhysics.Common,MSTerrain,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\MSTerrain.cs,MSTerrain,The following statement contains a magic number: Width = area.Extents.X * 2;
Magic Number,FarseerPhysics.Common,MSTerrain,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\MSTerrain.cs,MSTerrain,The following statement contains a magic number: Height = area.Extents.Y * 2;
Magic Number,FarseerPhysics.Common,MSTerrain,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\MSTerrain.cs,GenerateTerrain,The following statement contains a magic number: foreach (var item in polys)              {                  // does this need to be negative?                  item.Scale(ref scale);                  item.Translate(ref _topLeft);                  item.ForceCounterClockWise();                  Vertices p = FarseerPhysics.Common.PolygonManipulation.SimplifyTools.CollinearSimplify(item);                  List<Vertices> decompPolys = new List<Vertices>();                    switch (Decomposer)                  {                      case Decomposer.Bayazit:                          decompPolys = Decomposition.BayazitDecomposer.ConvexPartition(p);                          break;                      case Decomposer.CDT:                          decompPolys = Decomposition.CDTDecomposer.ConvexPartition(p);                          break;                      case Decomposer.Earclip:                          decompPolys = Decomposition.EarclipDecomposer.ConvexPartition(p);                          break;                      case Decomposer.Flipcode:                          decompPolys = Decomposition.FlipcodeDecomposer.ConvexPartition(p);                          break;                      case Decomposer.Seidel:                          decompPolys = Decomposition.SeidelDecomposer.ConvexPartition(p' 0.001f);                          break;                      default:                          break;                  }                    foreach (Vertices poly in decompPolys)                  {                      if (poly.Count > 2)                          _bodyMap[gx' gy].Add(BodyFactory.CreatePolygon(World' poly' 1));                  }              }
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\MarchingSquares.cs,DetectSquares,The following statement contains a magic number: int xn = (int)(domain.Extents.X * 2 / cellWidth);
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\MarchingSquares.cs,DetectSquares,The following statement contains a magic number: bool xp = xn == (domain.Extents.X * 2 / cellWidth);
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\MarchingSquares.cs,DetectSquares,The following statement contains a magic number: int yn = (int)(domain.Extents.Y * 2 / cellHeight);
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\MarchingSquares.cs,DetectSquares,The following statement contains a magic number: bool yp = yn == (domain.Extents.Y * 2 / cellHeight);
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\MarchingSquares.cs,DetectSquares,The following statement contains a magic number: for (int y = 0; y < yn; y++)              {                  float y0 = y * cellHeight + domain.LowerBound.Y;                  float y1;                  if (y == yn - 1) y1 = domain.UpperBound.Y;                  else y1 = y0 + cellHeight;                  GeomPoly pre = null;                  for (int x = 0; x < xn; x++)                  {                      float x0 = x * cellWidth + domain.LowerBound.X;                      float x1;                      if (x == xn - 1) x1 = domain.UpperBound.X;                      else x1 = x0 + cellWidth;                        gp = new GeomPoly();                        int key = MarchSquare(f' fs' ref gp' x' y' x0' y0' x1' y1' lerpCount);                      if (gp.Length != 0)                      {                          if (combine && pre != null && (key & 9) != 0)                          {                              combLeft(ref pre' ref gp);                              gp = pre;                          }                          else                              ret.Add(gp);                          ps[x' y] = new GeomPolyVal(gp' key);                      }                      else                          gp = null;                      pre = gp;                  }              }
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\MarchingSquares.cs,DetectSquares,The following statement contains a magic number: for (int y = 1; y < yn; y++)              {                  int x = 0;                  while (x < xn)                  {                      GeomPolyVal p = ps[x' y];                        //skip along scan line if no polygon exists at this point                      if (p == null)                      {                          x++;                          continue;                      }                        //skip along if current polygon cannot be combined above.                      if ((p.Key & 12) == 0)                      {                          x++;                          continue;                      }                        //skip along if no polygon exists above.                      GeomPolyVal u = ps[x' y - 1];                      if (u == null)                      {                          x++;                          continue;                      }                        //skip along if polygon above cannot be combined with.                      if ((u.Key & 3) == 0)                      {                          x++;                          continue;                      }                        float ax = x * cellWidth + domain.LowerBound.X;                      float ay = y * cellHeight + domain.LowerBound.Y;                        CxFastList<Vector2> bp = p.GeomP.Points;                      CxFastList<Vector2> ap = u.GeomP.Points;                        //skip if it's already been combined with above polygon                      if (u.GeomP == p.GeomP)                      {                          x++;                          continue;                      }                        //combine above (but disallow the hole thingies                      CxFastListNode<Vector2> bi = bp.Begin();                      while (Square(bi.Elem().Y - ay) > Settings.Epsilon || bi.Elem().X < ax) bi = bi.Next();                        //NOTE: Unused                      //Vector2 b0 = bi.elem();                      Vector2 b1 = bi.Next().Elem();                      if (Square(b1.Y - ay) > Settings.Epsilon)                      {                          x++;                          continue;                      }                        bool brk = true;                      CxFastListNode<Vector2> ai = ap.Begin();                      while (ai != ap.End())                      {                          if (VecDsq(ai.Elem()' b1) < Settings.Epsilon)                          {                              brk = false;                              break;                          }                          ai = ai.Next();                      }                      if (brk)                      {                          x++;                          continue;                      }                        CxFastListNode<Vector2> bj = bi.Next().Next();                      if (bj == bp.End()) bj = bp.Begin();                      while (bj != bi)                      {                          ai = ap.Insert(ai' bj.Elem()); // .clone()                          bj = bj.Next();                          if (bj == bp.End()) bj = bp.Begin();                          u.GeomP.Length++;                      }                      //u.p.simplify(float.Epsilon'float.Epsilon);                      //                      ax = x + 1;                      while (ax < xn)                      {                          GeomPolyVal p2 = ps[(int)ax' y];                          if (p2 == null || p2.GeomP != p.GeomP)                          {                              ax++;                              continue;                          }                          p2.GeomP = u.GeomP;                          ax++;                      }                      ax = x - 1;                      while (ax >= 0)                      {                          GeomPolyVal p2 = ps[(int)ax' y];                          if (p2 == null || p2.GeomP != p.GeomP)                          {                              ax--;                              continue;                          }                          p2.GeomP = u.GeomP;                          ax--;                      }                      ret.Remove(p.GeomP);                      p.GeomP = u.GeomP;                        x = (int)((bi.Next().Elem().X - domain.LowerBound.X) / cellWidth) + 1;                      //x++; this was already commented out!                  }              }
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\MarchingSquares.cs,DetectSquares,The following statement contains a magic number: for (int y = 1; y < yn; y++)              {                  int x = 0;                  while (x < xn)                  {                      GeomPolyVal p = ps[x' y];                        //skip along scan line if no polygon exists at this point                      if (p == null)                      {                          x++;                          continue;                      }                        //skip along if current polygon cannot be combined above.                      if ((p.Key & 12) == 0)                      {                          x++;                          continue;                      }                        //skip along if no polygon exists above.                      GeomPolyVal u = ps[x' y - 1];                      if (u == null)                      {                          x++;                          continue;                      }                        //skip along if polygon above cannot be combined with.                      if ((u.Key & 3) == 0)                      {                          x++;                          continue;                      }                        float ax = x * cellWidth + domain.LowerBound.X;                      float ay = y * cellHeight + domain.LowerBound.Y;                        CxFastList<Vector2> bp = p.GeomP.Points;                      CxFastList<Vector2> ap = u.GeomP.Points;                        //skip if it's already been combined with above polygon                      if (u.GeomP == p.GeomP)                      {                          x++;                          continue;                      }                        //combine above (but disallow the hole thingies                      CxFastListNode<Vector2> bi = bp.Begin();                      while (Square(bi.Elem().Y - ay) > Settings.Epsilon || bi.Elem().X < ax) bi = bi.Next();                        //NOTE: Unused                      //Vector2 b0 = bi.elem();                      Vector2 b1 = bi.Next().Elem();                      if (Square(b1.Y - ay) > Settings.Epsilon)                      {                          x++;                          continue;                      }                        bool brk = true;                      CxFastListNode<Vector2> ai = ap.Begin();                      while (ai != ap.End())                      {                          if (VecDsq(ai.Elem()' b1) < Settings.Epsilon)                          {                              brk = false;                              break;                          }                          ai = ai.Next();                      }                      if (brk)                      {                          x++;                          continue;                      }                        CxFastListNode<Vector2> bj = bi.Next().Next();                      if (bj == bp.End()) bj = bp.Begin();                      while (bj != bi)                      {                          ai = ap.Insert(ai' bj.Elem()); // .clone()                          bj = bj.Next();                          if (bj == bp.End()) bj = bp.Begin();                          u.GeomP.Length++;                      }                      //u.p.simplify(float.Epsilon'float.Epsilon);                      //                      ax = x + 1;                      while (ax < xn)                      {                          GeomPolyVal p2 = ps[(int)ax' y];                          if (p2 == null || p2.GeomP != p.GeomP)                          {                              ax++;                              continue;                          }                          p2.GeomP = u.GeomP;                          ax++;                      }                      ax = x - 1;                      while (ax >= 0)                      {                          GeomPolyVal p2 = ps[(int)ax' y];                          if (p2 == null || p2.GeomP != p.GeomP)                          {                              ax--;                              continue;                          }                          p2.GeomP = u.GeomP;                          ax--;                      }                      ret.Remove(p.GeomP);                      p.GeomP = u.GeomP;                        x = (int)((bi.Next().Elem().X - domain.LowerBound.X) / cellWidth) + 1;                      //x++; this was already commented out!                  }              }
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (v0 < 0) key |= 8;
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (v1 < 0) key |= 4;
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (v2 < 0) key |= 2;
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (val != 0)              {                  CxFastListNode<Vector2> pi = null;                  for (int i = 0; i < 8; i++)                  {                      Vector2 p;                      if ((val & (1 << i)) != 0)                      {                          if (i == 7 && (val & 1) == 0)                              poly.Points.Add(p = new Vector2(x0' Ylerp(y0' y1' x0' v0' v3' f' bin)));                          else                          {                              if (i == 0) p = new Vector2(x0' y0);                              else if (i == 2) p = new Vector2(x1' y0);                              else if (i == 4) p = new Vector2(x1' y1);                              else if (i == 6) p = new Vector2(x0' y1);                                else if (i == 1) p = new Vector2(Xlerp(x0' x1' y0' v0' v1' f' bin)' y0);                              else if (i == 5) p = new Vector2(Xlerp(x0' x1' y1' v3' v2' f' bin)' y1);                                else if (i == 3) p = new Vector2(x1' Ylerp(y0' y1' x1' v1' v2' f' bin));                              else p = new Vector2(x0' Ylerp(y0' y1' x0' v0' v3' f' bin));                                pi = poly.Points.Insert(pi' p);                          }                          poly.Length++;                      }                  }                  //poly.simplify(float.Epsilon'float.Epsilon);              }
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (val != 0)              {                  CxFastListNode<Vector2> pi = null;                  for (int i = 0; i < 8; i++)                  {                      Vector2 p;                      if ((val & (1 << i)) != 0)                      {                          if (i == 7 && (val & 1) == 0)                              poly.Points.Add(p = new Vector2(x0' Ylerp(y0' y1' x0' v0' v3' f' bin)));                          else                          {                              if (i == 0) p = new Vector2(x0' y0);                              else if (i == 2) p = new Vector2(x1' y0);                              else if (i == 4) p = new Vector2(x1' y1);                              else if (i == 6) p = new Vector2(x0' y1);                                else if (i == 1) p = new Vector2(Xlerp(x0' x1' y0' v0' v1' f' bin)' y0);                              else if (i == 5) p = new Vector2(Xlerp(x0' x1' y1' v3' v2' f' bin)' y1);                                else if (i == 3) p = new Vector2(x1' Ylerp(y0' y1' x1' v1' v2' f' bin));                              else p = new Vector2(x0' Ylerp(y0' y1' x0' v0' v3' f' bin));                                pi = poly.Points.Insert(pi' p);                          }                          poly.Length++;                      }                  }                  //poly.simplify(float.Epsilon'float.Epsilon);              }
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (val != 0)              {                  CxFastListNode<Vector2> pi = null;                  for (int i = 0; i < 8; i++)                  {                      Vector2 p;                      if ((val & (1 << i)) != 0)                      {                          if (i == 7 && (val & 1) == 0)                              poly.Points.Add(p = new Vector2(x0' Ylerp(y0' y1' x0' v0' v3' f' bin)));                          else                          {                              if (i == 0) p = new Vector2(x0' y0);                              else if (i == 2) p = new Vector2(x1' y0);                              else if (i == 4) p = new Vector2(x1' y1);                              else if (i == 6) p = new Vector2(x0' y1);                                else if (i == 1) p = new Vector2(Xlerp(x0' x1' y0' v0' v1' f' bin)' y0);                              else if (i == 5) p = new Vector2(Xlerp(x0' x1' y1' v3' v2' f' bin)' y1);                                else if (i == 3) p = new Vector2(x1' Ylerp(y0' y1' x1' v1' v2' f' bin));                              else p = new Vector2(x0' Ylerp(y0' y1' x0' v0' v3' f' bin));                                pi = poly.Points.Insert(pi' p);                          }                          poly.Length++;                      }                  }                  //poly.simplify(float.Epsilon'float.Epsilon);              }
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (val != 0)              {                  CxFastListNode<Vector2> pi = null;                  for (int i = 0; i < 8; i++)                  {                      Vector2 p;                      if ((val & (1 << i)) != 0)                      {                          if (i == 7 && (val & 1) == 0)                              poly.Points.Add(p = new Vector2(x0' Ylerp(y0' y1' x0' v0' v3' f' bin)));                          else                          {                              if (i == 0) p = new Vector2(x0' y0);                              else if (i == 2) p = new Vector2(x1' y0);                              else if (i == 4) p = new Vector2(x1' y1);                              else if (i == 6) p = new Vector2(x0' y1);                                else if (i == 1) p = new Vector2(Xlerp(x0' x1' y0' v0' v1' f' bin)' y0);                              else if (i == 5) p = new Vector2(Xlerp(x0' x1' y1' v3' v2' f' bin)' y1);                                else if (i == 3) p = new Vector2(x1' Ylerp(y0' y1' x1' v1' v2' f' bin));                              else p = new Vector2(x0' Ylerp(y0' y1' x0' v0' v3' f' bin));                                pi = poly.Points.Insert(pi' p);                          }                          poly.Length++;                      }                  }                  //poly.simplify(float.Epsilon'float.Epsilon);              }
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (val != 0)              {                  CxFastListNode<Vector2> pi = null;                  for (int i = 0; i < 8; i++)                  {                      Vector2 p;                      if ((val & (1 << i)) != 0)                      {                          if (i == 7 && (val & 1) == 0)                              poly.Points.Add(p = new Vector2(x0' Ylerp(y0' y1' x0' v0' v3' f' bin)));                          else                          {                              if (i == 0) p = new Vector2(x0' y0);                              else if (i == 2) p = new Vector2(x1' y0);                              else if (i == 4) p = new Vector2(x1' y1);                              else if (i == 6) p = new Vector2(x0' y1);                                else if (i == 1) p = new Vector2(Xlerp(x0' x1' y0' v0' v1' f' bin)' y0);                              else if (i == 5) p = new Vector2(Xlerp(x0' x1' y1' v3' v2' f' bin)' y1);                                else if (i == 3) p = new Vector2(x1' Ylerp(y0' y1' x1' v1' v2' f' bin));                              else p = new Vector2(x0' Ylerp(y0' y1' x0' v0' v3' f' bin));                                pi = poly.Points.Insert(pi' p);                          }                          poly.Length++;                      }                  }                  //poly.simplify(float.Epsilon'float.Epsilon);              }
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (val != 0)              {                  CxFastListNode<Vector2> pi = null;                  for (int i = 0; i < 8; i++)                  {                      Vector2 p;                      if ((val & (1 << i)) != 0)                      {                          if (i == 7 && (val & 1) == 0)                              poly.Points.Add(p = new Vector2(x0' Ylerp(y0' y1' x0' v0' v3' f' bin)));                          else                          {                              if (i == 0) p = new Vector2(x0' y0);                              else if (i == 2) p = new Vector2(x1' y0);                              else if (i == 4) p = new Vector2(x1' y1);                              else if (i == 6) p = new Vector2(x0' y1);                                else if (i == 1) p = new Vector2(Xlerp(x0' x1' y0' v0' v1' f' bin)' y0);                              else if (i == 5) p = new Vector2(Xlerp(x0' x1' y1' v3' v2' f' bin)' y1);                                else if (i == 3) p = new Vector2(x1' Ylerp(y0' y1' x1' v1' v2' f' bin));                              else p = new Vector2(x0' Ylerp(y0' y1' x0' v0' v3' f' bin));                                pi = poly.Points.Insert(pi' p);                          }                          poly.Length++;                      }                  }                  //poly.simplify(float.Epsilon'float.Epsilon);              }
Magic Number,FarseerPhysics.Common,MarchingSquares,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\MarchingSquares.cs,MarchSquare,The following statement contains a magic number: if (val != 0)              {                  CxFastListNode<Vector2> pi = null;                  for (int i = 0; i < 8; i++)                  {                      Vector2 p;                      if ((val & (1 << i)) != 0)                      {                          if (i == 7 && (val & 1) == 0)                              poly.Points.Add(p = new Vector2(x0' Ylerp(y0' y1' x0' v0' v3' f' bin)));                          else                          {                              if (i == 0) p = new Vector2(x0' y0);                              else if (i == 2) p = new Vector2(x1' y0);                              else if (i == 4) p = new Vector2(x1' y1);                              else if (i == 6) p = new Vector2(x0' y1);                                else if (i == 1) p = new Vector2(Xlerp(x0' x1' y0' v0' v1' f' bin)' y0);                              else if (i == 5) p = new Vector2(Xlerp(x0' x1' y1' v3' v2' f' bin)' y1);                                else if (i == 3) p = new Vector2(x1' Ylerp(y0' y1' x1' v1' v2' f' bin));                              else p = new Vector2(x0' Ylerp(y0' y1' x0' v0' v3' f' bin));                                pi = poly.Points.Insert(pi' p);                          }                          poly.Length++;                      }                  }                  //poly.simplify(float.Epsilon'float.Epsilon);              }
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,Initialize,The following statement contains a magic number: if (alphaTolerance.HasValue)                  AlphaTolerance = alphaTolerance.Value;              else                  AlphaTolerance = 20;
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,SetTextureData,The following statement contains a magic number: if (data.Length < 4)                  throw new ArgumentOutOfRangeException("data"' "'data' length can't be less then 4. Your texture must be at least 2 x 2 pixels in size.");
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,SetTextureData,The following statement contains a magic number: if (width < 2)                  throw new ArgumentOutOfRangeException("width"' "'width' can't be less then 2. Your texture must be at least 2 x 2 pixels in size.");
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,DetectVertices,The following statement contains a magic number: if (_data.Length < 4)                  throw new Exception(                      "'_data' length can't be less then 4. Your texture must be at least 2 x 2 pixels in size. " +                      "You have to use SetTextureData(uint[] data' int width) before calling this method.");
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,DetectVertices,The following statement contains a magic number: if (_width < 2)                  throw new Exception(                      "'_width' can't be less then 2. Your texture must be at least 2 x 2 pixels in size. " +                      "You have to use SetTextureData(uint[] data' int width) before calling this method.");
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,DetectVertices,The following statement contains a magic number: do              {                  if (detectedPolygons.Count == 0)                  {                      // First pass / single polygon                      polygon = new DetectedVertices(CreateSimplePolygon(Vector2.Zero' Vector2.Zero));                        if (polygon.Count > 2)                          polygonEntrance = GetTopMostVertex(polygon);                  }                  else if (polygonEntrance.HasValue)                  {                      // Multi pass / multiple polygons                      polygon = new DetectedVertices(CreateSimplePolygon(                          polygonEntrance.Value' new Vector2(polygonEntrance.Value.X - 1f' polygonEntrance.Value.Y)));                  }                  else                      break;                    searchOn = false;                      if (polygon.Count > 2)                  {                      if (_holeDetection)                      {                          do                          {                              holeEntrance = SearchHoleEntrance(polygon' holeEntrance);                                if (holeEntrance.HasValue)                              {                                  if (!blackList.Contains(holeEntrance.Value))                                  {                                      blackList.Add(holeEntrance.Value);                                      holePolygon = CreateSimplePolygon(holeEntrance.Value'                                          new Vector2(holeEntrance.Value.X + 1' holeEntrance.Value.Y));                                        if (holePolygon != null && holePolygon.Count > 2)                                      {                                          switch (_polygonDetectionType)                                          {                                              case VerticesDetectionType.Integrated:                                                    // Add first hole polygon vertex to close the hole polygon.                                                  holePolygon.Add(holePolygon[0]);                                                    int vertex1Index' vertex2Index;                                                  if (SplitPolygonEdge(polygon' holeEntrance.Value' out vertex1Index' out vertex2Index))                                                      polygon.InsertRange(vertex2Index' holePolygon);                                                    break;                                                case VerticesDetectionType.Separated:                                                  if (polygon.Holes == null)                                                      polygon.Holes = new List<Vertices>();                                                    polygon.Holes.Add(holePolygon);                                                  break;                                          }                                      }                                  }                                  else                                      break;                              }                              else                                  break;                          }                          while (true);                      }                        detectedPolygons.Add(polygon);                  }                    if (_multipartDetection || polygon.Count <= 2)                  {                      if (SearchNextHullEntrance(detectedPolygons' polygonEntrance.Value' out polygonEntrance))                          searchOn = true;                  }              }              while (searchOn);
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,DetectVertices,The following statement contains a magic number: do              {                  if (detectedPolygons.Count == 0)                  {                      // First pass / single polygon                      polygon = new DetectedVertices(CreateSimplePolygon(Vector2.Zero' Vector2.Zero));                        if (polygon.Count > 2)                          polygonEntrance = GetTopMostVertex(polygon);                  }                  else if (polygonEntrance.HasValue)                  {                      // Multi pass / multiple polygons                      polygon = new DetectedVertices(CreateSimplePolygon(                          polygonEntrance.Value' new Vector2(polygonEntrance.Value.X - 1f' polygonEntrance.Value.Y)));                  }                  else                      break;                    searchOn = false;                      if (polygon.Count > 2)                  {                      if (_holeDetection)                      {                          do                          {                              holeEntrance = SearchHoleEntrance(polygon' holeEntrance);                                if (holeEntrance.HasValue)                              {                                  if (!blackList.Contains(holeEntrance.Value))                                  {                                      blackList.Add(holeEntrance.Value);                                      holePolygon = CreateSimplePolygon(holeEntrance.Value'                                          new Vector2(holeEntrance.Value.X + 1' holeEntrance.Value.Y));                                        if (holePolygon != null && holePolygon.Count > 2)                                      {                                          switch (_polygonDetectionType)                                          {                                              case VerticesDetectionType.Integrated:                                                    // Add first hole polygon vertex to close the hole polygon.                                                  holePolygon.Add(holePolygon[0]);                                                    int vertex1Index' vertex2Index;                                                  if (SplitPolygonEdge(polygon' holeEntrance.Value' out vertex1Index' out vertex2Index))                                                      polygon.InsertRange(vertex2Index' holePolygon);                                                    break;                                                case VerticesDetectionType.Separated:                                                  if (polygon.Holes == null)                                                      polygon.Holes = new List<Vertices>();                                                    polygon.Holes.Add(holePolygon);                                                  break;                                          }                                      }                                  }                                  else                                      break;                              }                              else                                  break;                          }                          while (true);                      }                        detectedPolygons.Add(polygon);                  }                    if (_multipartDetection || polygon.Count <= 2)                  {                      if (SearchNextHullEntrance(detectedPolygons' polygonEntrance.Value' out polygonEntrance))                          searchOn = true;                  }              }              while (searchOn);
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,DetectVertices,The following statement contains a magic number: do              {                  if (detectedPolygons.Count == 0)                  {                      // First pass / single polygon                      polygon = new DetectedVertices(CreateSimplePolygon(Vector2.Zero' Vector2.Zero));                        if (polygon.Count > 2)                          polygonEntrance = GetTopMostVertex(polygon);                  }                  else if (polygonEntrance.HasValue)                  {                      // Multi pass / multiple polygons                      polygon = new DetectedVertices(CreateSimplePolygon(                          polygonEntrance.Value' new Vector2(polygonEntrance.Value.X - 1f' polygonEntrance.Value.Y)));                  }                  else                      break;                    searchOn = false;                      if (polygon.Count > 2)                  {                      if (_holeDetection)                      {                          do                          {                              holeEntrance = SearchHoleEntrance(polygon' holeEntrance);                                if (holeEntrance.HasValue)                              {                                  if (!blackList.Contains(holeEntrance.Value))                                  {                                      blackList.Add(holeEntrance.Value);                                      holePolygon = CreateSimplePolygon(holeEntrance.Value'                                          new Vector2(holeEntrance.Value.X + 1' holeEntrance.Value.Y));                                        if (holePolygon != null && holePolygon.Count > 2)                                      {                                          switch (_polygonDetectionType)                                          {                                              case VerticesDetectionType.Integrated:                                                    // Add first hole polygon vertex to close the hole polygon.                                                  holePolygon.Add(holePolygon[0]);                                                    int vertex1Index' vertex2Index;                                                  if (SplitPolygonEdge(polygon' holeEntrance.Value' out vertex1Index' out vertex2Index))                                                      polygon.InsertRange(vertex2Index' holePolygon);                                                    break;                                                case VerticesDetectionType.Separated:                                                  if (polygon.Holes == null)                                                      polygon.Holes = new List<Vertices>();                                                    polygon.Holes.Add(holePolygon);                                                  break;                                          }                                      }                                  }                                  else                                      break;                              }                              else                                  break;                          }                          while (true);                      }                        detectedPolygons.Add(polygon);                  }                    if (_multipartDetection || polygon.Count <= 2)                  {                      if (SearchNextHullEntrance(detectedPolygons' polygonEntrance.Value' out polygonEntrance))                          searchOn = true;                  }              }              while (searchOn);
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,DetectVertices,The following statement contains a magic number: do              {                  if (detectedPolygons.Count == 0)                  {                      // First pass / single polygon                      polygon = new DetectedVertices(CreateSimplePolygon(Vector2.Zero' Vector2.Zero));                        if (polygon.Count > 2)                          polygonEntrance = GetTopMostVertex(polygon);                  }                  else if (polygonEntrance.HasValue)                  {                      // Multi pass / multiple polygons                      polygon = new DetectedVertices(CreateSimplePolygon(                          polygonEntrance.Value' new Vector2(polygonEntrance.Value.X - 1f' polygonEntrance.Value.Y)));                  }                  else                      break;                    searchOn = false;                      if (polygon.Count > 2)                  {                      if (_holeDetection)                      {                          do                          {                              holeEntrance = SearchHoleEntrance(polygon' holeEntrance);                                if (holeEntrance.HasValue)                              {                                  if (!blackList.Contains(holeEntrance.Value))                                  {                                      blackList.Add(holeEntrance.Value);                                      holePolygon = CreateSimplePolygon(holeEntrance.Value'                                          new Vector2(holeEntrance.Value.X + 1' holeEntrance.Value.Y));                                        if (holePolygon != null && holePolygon.Count > 2)                                      {                                          switch (_polygonDetectionType)                                          {                                              case VerticesDetectionType.Integrated:                                                    // Add first hole polygon vertex to close the hole polygon.                                                  holePolygon.Add(holePolygon[0]);                                                    int vertex1Index' vertex2Index;                                                  if (SplitPolygonEdge(polygon' holeEntrance.Value' out vertex1Index' out vertex2Index))                                                      polygon.InsertRange(vertex2Index' holePolygon);                                                    break;                                                case VerticesDetectionType.Separated:                                                  if (polygon.Holes == null)                                                      polygon.Holes = new List<Vertices>();                                                    polygon.Holes.Add(holePolygon);                                                  break;                                          }                                      }                                  }                                  else                                      break;                              }                              else                                  break;                          }                          while (true);                      }                        detectedPolygons.Add(polygon);                  }                    if (_multipartDetection || polygon.Count <= 2)                  {                      if (SearchNextHullEntrance(detectedPolygons' polygonEntrance.Value' out polygonEntrance))                          searchOn = true;                  }              }              while (searchOn);
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,SearchHoleEntrance,The following statement contains a magic number: if (polygon.Count < 3)                  throw new ArgumentException("'polygon.MainPolygon.Count' can't be less then 3.");
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,SearchHoleEntrance,The following statement contains a magic number: if (startY > 0 && startY < _height && endY > 0 && endY < _height)              {                  // go from top to bottom of the polygon                  for (int y = startY; y <= endY; y++)                  {                      // get x-coord of every polygon edge which crosses y                      xCoords = SearchCrossingEdges(polygon' y);                        // We need an even number of crossing edges.                       // It's always a pair of start and end edge: nothing | polygon | hole | polygon | nothing ...                      // If it's not then don't bother' it's probably a peak ...                      // ...which should be filtered out by SearchCrossingEdges() anyway.                      if (xCoords.Count > 1 && xCoords.Count % 2 == 0)                      {                          // Ok' this is short' but probably a little bit confusing.                          // This part searches from left to right between the edges inside the polygon.                          // The problem: We are using the polygon data to search in the texture data.                          // That's simply not accurate' but necessary because of performance.                          for (int i = 0; i < xCoords.Count; i += 2)                          {                              foundSolid = false;                              foundTransparent = false;                                // We search between the edges inside the polygon.                              for (int x = (int)xCoords[i]; x <= (int)xCoords[i + 1]; x++)                              {                                  // First pass: IsSolid might return false.                                  // In that case the polygon edge doesn't lie on the texture's solid pixel' because of the hull tolearance.                                  // If the edge lies before the first solid pixel then we need to skip our transparent pixel finds.                                    // The algorithm starts to search for a relevant transparent pixel (which indicates a possible hole)                                   // after it has found a solid pixel.                                    // After we've found a solid and a transparent pixel (a hole's left edge)                                   // we search for a solid pixel again (a hole's right edge).                                  // When found the distance of that coodrinate has to be greater then the hull tolerance.                                    if (IsSolid(ref x' ref y))                                  {                                      if (!foundTransparent)                                      {                                          foundSolid = true;                                          lastSolid = x;                                      }                                        if (foundSolid && foundTransparent)                                      {                                          entrance = new Vector2(lastSolid' y);                                            if (DistanceToHullAcceptable(polygon' entrance.Value' true))                                              return entrance;                                            entrance = null;                                          break;                                      }                                  }                                  else                                  {                                      if (foundSolid)                                          foundTransparent = true;                                  }                              }                          }                      }                      else                      {                          if (xCoords.Count % 2 == 0)                              Debug.WriteLine("SearchCrossingEdges() % 2 != 0");                      }                  }              }
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,SearchHoleEntrance,The following statement contains a magic number: if (startY > 0 && startY < _height && endY > 0 && endY < _height)              {                  // go from top to bottom of the polygon                  for (int y = startY; y <= endY; y++)                  {                      // get x-coord of every polygon edge which crosses y                      xCoords = SearchCrossingEdges(polygon' y);                        // We need an even number of crossing edges.                       // It's always a pair of start and end edge: nothing | polygon | hole | polygon | nothing ...                      // If it's not then don't bother' it's probably a peak ...                      // ...which should be filtered out by SearchCrossingEdges() anyway.                      if (xCoords.Count > 1 && xCoords.Count % 2 == 0)                      {                          // Ok' this is short' but probably a little bit confusing.                          // This part searches from left to right between the edges inside the polygon.                          // The problem: We are using the polygon data to search in the texture data.                          // That's simply not accurate' but necessary because of performance.                          for (int i = 0; i < xCoords.Count; i += 2)                          {                              foundSolid = false;                              foundTransparent = false;                                // We search between the edges inside the polygon.                              for (int x = (int)xCoords[i]; x <= (int)xCoords[i + 1]; x++)                              {                                  // First pass: IsSolid might return false.                                  // In that case the polygon edge doesn't lie on the texture's solid pixel' because of the hull tolearance.                                  // If the edge lies before the first solid pixel then we need to skip our transparent pixel finds.                                    // The algorithm starts to search for a relevant transparent pixel (which indicates a possible hole)                                   // after it has found a solid pixel.                                    // After we've found a solid and a transparent pixel (a hole's left edge)                                   // we search for a solid pixel again (a hole's right edge).                                  // When found the distance of that coodrinate has to be greater then the hull tolerance.                                    if (IsSolid(ref x' ref y))                                  {                                      if (!foundTransparent)                                      {                                          foundSolid = true;                                          lastSolid = x;                                      }                                        if (foundSolid && foundTransparent)                                      {                                          entrance = new Vector2(lastSolid' y);                                            if (DistanceToHullAcceptable(polygon' entrance.Value' true))                                              return entrance;                                            entrance = null;                                          break;                                      }                                  }                                  else                                  {                                      if (foundSolid)                                          foundTransparent = true;                                  }                              }                          }                      }                      else                      {                          if (xCoords.Count % 2 == 0)                              Debug.WriteLine("SearchCrossingEdges() % 2 != 0");                      }                  }              }
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,SearchHoleEntrance,The following statement contains a magic number: if (startY > 0 && startY < _height && endY > 0 && endY < _height)              {                  // go from top to bottom of the polygon                  for (int y = startY; y <= endY; y++)                  {                      // get x-coord of every polygon edge which crosses y                      xCoords = SearchCrossingEdges(polygon' y);                        // We need an even number of crossing edges.                       // It's always a pair of start and end edge: nothing | polygon | hole | polygon | nothing ...                      // If it's not then don't bother' it's probably a peak ...                      // ...which should be filtered out by SearchCrossingEdges() anyway.                      if (xCoords.Count > 1 && xCoords.Count % 2 == 0)                      {                          // Ok' this is short' but probably a little bit confusing.                          // This part searches from left to right between the edges inside the polygon.                          // The problem: We are using the polygon data to search in the texture data.                          // That's simply not accurate' but necessary because of performance.                          for (int i = 0; i < xCoords.Count; i += 2)                          {                              foundSolid = false;                              foundTransparent = false;                                // We search between the edges inside the polygon.                              for (int x = (int)xCoords[i]; x <= (int)xCoords[i + 1]; x++)                              {                                  // First pass: IsSolid might return false.                                  // In that case the polygon edge doesn't lie on the texture's solid pixel' because of the hull tolearance.                                  // If the edge lies before the first solid pixel then we need to skip our transparent pixel finds.                                    // The algorithm starts to search for a relevant transparent pixel (which indicates a possible hole)                                   // after it has found a solid pixel.                                    // After we've found a solid and a transparent pixel (a hole's left edge)                                   // we search for a solid pixel again (a hole's right edge).                                  // When found the distance of that coodrinate has to be greater then the hull tolerance.                                    if (IsSolid(ref x' ref y))                                  {                                      if (!foundTransparent)                                      {                                          foundSolid = true;                                          lastSolid = x;                                      }                                        if (foundSolid && foundTransparent)                                      {                                          entrance = new Vector2(lastSolid' y);                                            if (DistanceToHullAcceptable(polygon' entrance.Value' true))                                              return entrance;                                            entrance = null;                                          break;                                      }                                  }                                  else                                  {                                      if (foundSolid)                                          foundTransparent = true;                                  }                              }                          }                      }                      else                      {                          if (xCoords.Count % 2 == 0)                              Debug.WriteLine("SearchCrossingEdges() % 2 != 0");                      }                  }              }
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,DistanceToHullAcceptable,The following statement contains a magic number: if (polygon.Count < 3)                  throw new ArgumentException("'polygon.MainPolygon.Count' can't be less then 3.");
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,DistanceToHullAcceptable,The following statement contains a magic number: if (polygon.Count < 3)                  throw new ArgumentException("'polygon.Count' can't be less then 3.");
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,InPolygon,The following statement contains a magic number: if (!inPolygon)              {                  List<float> xCoords = SearchCrossingEdges(polygon' (int)point.Y);                    if (xCoords.Count > 0 && xCoords.Count % 2 == 0)                  {                      for (int i = 0; i < xCoords.Count; i += 2)                      {                          if (xCoords[i] <= point.X && xCoords[i + 1] >= point.X)                              return true;                      }                  }                    return false;              }
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,InPolygon,The following statement contains a magic number: if (!inPolygon)              {                  List<float> xCoords = SearchCrossingEdges(polygon' (int)point.Y);                    if (xCoords.Count > 0 && xCoords.Count % 2 == 0)                  {                      for (int i = 0; i < xCoords.Count; i += 2)                      {                          if (xCoords[i] <= point.X && xCoords[i + 1] >= point.X)                              return true;                      }                  }                    return false;              }
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,SearchCrossingEdges,The following statement contains a magic number: if (polygon.Count < 3)                  throw new ArgumentException("'polygon.MainPolygon.Count' can't be less then 3.");
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,SearchCrossingEdges,The following statement contains a magic number: if (polygon.Count > 2)              {                  // There is a gap between the last and the first vertex in the vertex list.                  // We will bridge that by setting the last vertex (vertex2) to the last                   // vertex in the list.                  vertex2 = polygon[polygon.Count - 1];                    // We are moving along the polygon edges.                  for (int i = 0; i < polygon.Count; i++)                  {                      vertex1 = polygon[i];                        // Approx. check if the edge crosses our y coord.                      if ((vertex1.Y >= y && vertex2.Y <= y) ||                          (vertex1.Y <= y && vertex2.Y >= y))                      {                          // Ignore edges that are parallel to y.                          if (vertex1.Y != vertex2.Y)                          {                              addFind = true;                              slope = vertex2 - vertex1;                                // Special threatment for edges that end at the y coord.                              if (vertex1.Y == y)                              {                                  // Create preview of the next edge.                                  nextVertex = polygon[(i + 1) % polygon.Count];                                  nextSlope = vertex1 - nextVertex;                                    // Ignore peaks.                                   // If thwo edges are aligned like this: /\ and the y coordinate lies on the top'                                  // then we get the same x coord twice and we don't need that.                                  if (slope.Y > 0)                                      addFind = (nextSlope.Y <= 0);                                  else                                      addFind = (nextSlope.Y >= 0);                              }                                if (addFind)                                  edges.Add((y - vertex1.Y) / slope.Y * slope.X + vertex1.X); // Calculate and add the x coord.                          }                      }                        // vertex1 becomes vertex2 :).                      vertex2 = vertex1;                  }              }
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,SplitPolygonEdge,The following statement contains a magic number: if (xCoords != null && xCoords.Count > 1 && xCoords.Count % 2 == 0)              {                  float distance;                  for (int i = 0; i < xCoords.Count; i++)                  {                      if (xCoords[i] < coordInsideThePolygon.X)                      {                          distance = coordInsideThePolygon.X - xCoords[i];                            if (distance < shortestDistance)                          {                              shortestDistance = distance;                              foundEdgeCoord.X = xCoords[i];                                edgeCoordFound = true;                          }                      }                  }                    if (edgeCoordFound)                  {                      shortestDistance = float.MaxValue;                        int edgeVertex2Index = polygon.Count - 1;                        int edgeVertex1Index;                      for (edgeVertex1Index = 0; edgeVertex1Index < polygon.Count; edgeVertex1Index++)                      {                          Vector2 tempVector1 = polygon[edgeVertex1Index];                          Vector2 tempVector2 = polygon[edgeVertex2Index];                          distance = LineTools.DistanceBetweenPointAndLineSegment(ref foundEdgeCoord'                                                                                  ref tempVector1' ref tempVector2);                          if (distance < shortestDistance)                          {                              shortestDistance = distance;                                nearestEdgeVertex1Index = edgeVertex1Index;                              nearestEdgeVertex2Index = edgeVertex2Index;                                edgeFound = true;                          }                            edgeVertex2Index = edgeVertex1Index;                      }                        if (edgeFound)                      {                          slope = polygon[nearestEdgeVertex2Index] - polygon[nearestEdgeVertex1Index];                          slope.Normalize();                            Vector2 tempVector = polygon[nearestEdgeVertex1Index];                          distance = LineTools.DistanceBetweenPointAndPoint(ref tempVector' ref foundEdgeCoord);                            vertex1Index = nearestEdgeVertex1Index;                          vertex2Index = nearestEdgeVertex1Index + 1;                            polygon.Insert(nearestEdgeVertex1Index' distance * slope + polygon[vertex1Index]);                          polygon.Insert(nearestEdgeVertex1Index' distance * slope + polygon[vertex2Index]);                            return true;                      }                  }              }
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,CreateSimplePolygon,The following statement contains a magic number: Vertices polygon = new Vertices(32);
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,CreateSimplePolygon,The following statement contains a magic number: Vertices hullArea = new Vertices(32);
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,CreateSimplePolygon,The following statement contains a magic number: Vertices endOfHullArea = new Vertices(32);
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,SearchForOutstandingVertex,The following statement contains a magic number: if (hullArea.Count > 2)              {                  int hullAreaLastPoint = hullArea.Count - 1;                    Vector2 tempVector1;                  Vector2 tempVector2 = hullArea[0];                  Vector2 tempVector3 = hullArea[hullAreaLastPoint];                    // Search between the first and last hull point.                  for (int i = 1; i < hullAreaLastPoint; i++)                  {                      tempVector1 = hullArea[i];                        // Check if the distance is over the one that's tolerable.                      if (LineTools.DistanceBetweenPointAndLineSegment(ref tempVector1' ref tempVector2' ref tempVector3) >= _hullTolerance)                      {                          outstandingResult = hullArea[i];                          found = true;                          break;                      }                  }              }
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: switch ((int)(current.X - last.X))              {                  case 1:                      switch ((int)(current.Y - last.Y))                      {                          case 1:                              return 1;                            case 0:                              return 0;                            case -1:                              return 7;                      }                      break;                    case 0:                      switch ((int)(current.Y - last.Y))                      {                          case 1:                              return 2;                            case -1:                              return 6;                      }                      break;                    case -1:                      switch ((int)(current.Y - last.Y))                      {                          case 1:                              return 3;                            case 0:                              return 4;                            case -1:                              return 5;                      }                      break;              }
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: switch ((int)(current.X - last.X))              {                  case 1:                      switch ((int)(current.Y - last.Y))                      {                          case 1:                              return 1;                            case 0:                              return 0;                            case -1:                              return 7;                      }                      break;                    case 0:                      switch ((int)(current.Y - last.Y))                      {                          case 1:                              return 2;                            case -1:                              return 6;                      }                      break;                    case -1:                      switch ((int)(current.Y - last.Y))                      {                          case 1:                              return 3;                            case 0:                              return 4;                            case -1:                              return 5;                      }                      break;              }
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: switch ((int)(current.X - last.X))              {                  case 1:                      switch ((int)(current.Y - last.Y))                      {                          case 1:                              return 1;                            case 0:                              return 0;                            case -1:                              return 7;                      }                      break;                    case 0:                      switch ((int)(current.Y - last.Y))                      {                          case 1:                              return 2;                            case -1:                              return 6;                      }                      break;                    case -1:                      switch ((int)(current.Y - last.Y))                      {                          case 1:                              return 3;                            case 0:                              return 4;                            case -1:                              return 5;                      }                      break;              }
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: switch ((int)(current.X - last.X))              {                  case 1:                      switch ((int)(current.Y - last.Y))                      {                          case 1:                              return 1;                            case 0:                              return 0;                            case -1:                              return 7;                      }                      break;                    case 0:                      switch ((int)(current.Y - last.Y))                      {                          case 1:                              return 2;                            case -1:                              return 6;                      }                      break;                    case -1:                      switch ((int)(current.Y - last.Y))                      {                          case 1:                              return 3;                            case 0:                              return 4;                            case -1:                              return 5;                      }                      break;              }
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: switch ((int)(current.X - last.X))              {                  case 1:                      switch ((int)(current.Y - last.Y))                      {                          case 1:                              return 1;                            case 0:                              return 0;                            case -1:                              return 7;                      }                      break;                    case 0:                      switch ((int)(current.Y - last.Y))                      {                          case 1:                              return 2;                            case -1:                              return 6;                      }                      break;                    case -1:                      switch ((int)(current.Y - last.Y))                      {                          case 1:                              return 3;                            case 0:                              return 4;                            case -1:                              return 5;                      }                      break;              }
Magic Number,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following statement contains a magic number: switch ((int)(current.X - last.X))              {                  case 1:                      switch ((int)(current.Y - last.Y))                      {                          case 1:                              return 1;                            case 0:                              return 0;                            case -1:                              return 7;                      }                      break;                    case 0:                      switch ((int)(current.Y - last.Y))                      {                          case 1:                              return 2;                            case -1:                              return 6;                      }                      break;                    case -1:                      switch ((int)(current.Y - last.Y))                      {                          case 1:                              return 3;                            case 0:                              return 4;                            case -1:                              return 5;                      }                      break;              }
Magic Number,FarseerPhysics.Factories,BodyFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\BodyFactory.cs,CreateRectangle,The following statement contains a magic number: Vertices rectangleVertices = PolygonTools.CreateRectangle(width / 2' height / 2);
Magic Number,FarseerPhysics.Factories,BodyFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\BodyFactory.cs,CreateRectangle,The following statement contains a magic number: Vertices rectangleVertices = PolygonTools.CreateRectangle(width / 2' height / 2);
Magic Number,FarseerPhysics.Factories,BodyFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\BodyFactory.cs,CreateCapsule,The following statement contains a magic number: Vertices rectangle = PolygonTools.CreateRectangle(endRadius' height / 2);
Magic Number,FarseerPhysics.Factories,BodyFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\BodyFactory.cs,CreateCapsule,The following statement contains a magic number: topCircle.Position = new Vector2(0' height / 2);
Magic Number,FarseerPhysics.Factories,BodyFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\BodyFactory.cs,CreateCapsule,The following statement contains a magic number: bottomCircle.Position = new Vector2(0' -(height / 2));
Magic Number,FarseerPhysics.Factories,FixtureFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\FixtureFactory.cs,AttachRectangle,The following statement contains a magic number: Vertices rectangleVertices = PolygonTools.CreateRectangle(width / 2' height / 2);
Magic Number,FarseerPhysics.Factories,FixtureFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\FixtureFactory.cs,AttachRectangle,The following statement contains a magic number: Vertices rectangleVertices = PolygonTools.CreateRectangle(width / 2' height / 2);
Magic Number,FarseerPhysics.Factories,FixtureFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\FixtureFactory.cs,AttachCompoundPolygon,The following statement contains a magic number: foreach (Vertices vertices in list)              {                  if (vertices.Count == 2)                  {                      EdgeShape shape = new EdgeShape(vertices[0]' vertices[1]);                      res.Add(body.CreateFixture(shape' userData));                  }                  else                  {                      PolygonShape shape = new PolygonShape(vertices' density);                      res.Add(body.CreateFixture(shape' userData));                  }              }
Magic Number,FarseerPhysics.Factories,FixtureFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\FixtureFactory.cs,AttachLineArc,The following statement contains a magic number: arc.Rotate((MathHelper.Pi - radians) / 2 + angle);
Magic Number,FarseerPhysics.Factories,FixtureFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\FixtureFactory.cs,AttachSolidArc,The following statement contains a magic number: arc.Rotate((MathHelper.Pi - radians) / 2 + angle);
Magic Number,FarseerPhysics.Factories,LinkFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\LinkFactory.cs,CreateChain,The following statement contains a magic number: if (fixStart)              {                  //Fix the first chainlink to the world                  JointFactory.CreateFixedRevoluteJoint(world' chainLinks[0]' new Vector2(0' -(linkHeight / 2))'                                                        chainLinks[0].Position);              }
Magic Number,FarseerPhysics.Factories,LinkFactory,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Factories\LinkFactory.cs,CreateChain,The following statement contains a magic number: if (fixEnd)              {                  //Fix the last chainlink to the world                  JointFactory.CreateFixedRevoluteJoint(world' chainLinks[chainLinks.Count - 1]'                                                        new Vector2(0' (linkHeight / 2))'                                                        chainLinks[chainLinks.Count - 1].Position);              }
Magic Number,FarseerPhysics.Common.ConvexHull,ChainHull,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\ConvexHull\ChainHull.cs,GetConvexHull,The following statement contains a magic number: for (i = n - 2; i >= 0; i--)                  if (P[i].X != xmax) break;
Magic Number,FarseerPhysics.Common.ConvexHull,GiftWrap,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\ConvexHull\GiftWrap.cs,GetConvexHull,The following statement contains a magic number: if (vertices.Count < 3)                  return vertices;
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: if (vertices.Count < 3)                  return vertices;
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: int qf = 3' qb = 0;
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: int startIndex = 3;
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: float k = MathUtils.Area(vertices[0]' vertices[1]' vertices[2]);
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: if (k == 0)              {                  //Vertices are collinear.                  deque[0] = vertices[0];                  deque[1] = vertices[2]; //We can skip vertex 1 because it should be between 0 and 2                  deque[2] = vertices[0];                  qf = 2;                    //Go until the end of the collinear sequence of vertices                  for (startIndex = 3; startIndex < vertices.Count; startIndex++)                  {                      Vector2 tmp = vertices[startIndex];                      if (MathUtils.Area(ref deque[0]' ref deque[1]' ref tmp) == 0) //This point is also collinear                          deque[1] = vertices[startIndex];                      else break;                  }              }              else              {                  deque[0] = deque[3] = vertices[2];                  if (k > 0)                  {                      //Is Left.  Set deque = {2' 0' 1' 2}                      deque[1] = vertices[0];                      deque[2] = vertices[1];                  }                  else                  {                      //Is Right. Set deque = {2' 1' 0' 2}                      deque[1] = vertices[1];                      deque[2] = vertices[0];                  }              }
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: if (k == 0)              {                  //Vertices are collinear.                  deque[0] = vertices[0];                  deque[1] = vertices[2]; //We can skip vertex 1 because it should be between 0 and 2                  deque[2] = vertices[0];                  qf = 2;                    //Go until the end of the collinear sequence of vertices                  for (startIndex = 3; startIndex < vertices.Count; startIndex++)                  {                      Vector2 tmp = vertices[startIndex];                      if (MathUtils.Area(ref deque[0]' ref deque[1]' ref tmp) == 0) //This point is also collinear                          deque[1] = vertices[startIndex];                      else break;                  }              }              else              {                  deque[0] = deque[3] = vertices[2];                  if (k > 0)                  {                      //Is Left.  Set deque = {2' 0' 1' 2}                      deque[1] = vertices[0];                      deque[2] = vertices[1];                  }                  else                  {                      //Is Right. Set deque = {2' 1' 0' 2}                      deque[1] = vertices[1];                      deque[2] = vertices[0];                  }              }
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: if (k == 0)              {                  //Vertices are collinear.                  deque[0] = vertices[0];                  deque[1] = vertices[2]; //We can skip vertex 1 because it should be between 0 and 2                  deque[2] = vertices[0];                  qf = 2;                    //Go until the end of the collinear sequence of vertices                  for (startIndex = 3; startIndex < vertices.Count; startIndex++)                  {                      Vector2 tmp = vertices[startIndex];                      if (MathUtils.Area(ref deque[0]' ref deque[1]' ref tmp) == 0) //This point is also collinear                          deque[1] = vertices[startIndex];                      else break;                  }              }              else              {                  deque[0] = deque[3] = vertices[2];                  if (k > 0)                  {                      //Is Left.  Set deque = {2' 0' 1' 2}                      deque[1] = vertices[0];                      deque[2] = vertices[1];                  }                  else                  {                      //Is Right. Set deque = {2' 1' 0' 2}                      deque[1] = vertices[1];                      deque[2] = vertices[0];                  }              }
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: if (k == 0)              {                  //Vertices are collinear.                  deque[0] = vertices[0];                  deque[1] = vertices[2]; //We can skip vertex 1 because it should be between 0 and 2                  deque[2] = vertices[0];                  qf = 2;                    //Go until the end of the collinear sequence of vertices                  for (startIndex = 3; startIndex < vertices.Count; startIndex++)                  {                      Vector2 tmp = vertices[startIndex];                      if (MathUtils.Area(ref deque[0]' ref deque[1]' ref tmp) == 0) //This point is also collinear                          deque[1] = vertices[startIndex];                      else break;                  }              }              else              {                  deque[0] = deque[3] = vertices[2];                  if (k > 0)                  {                      //Is Left.  Set deque = {2' 0' 1' 2}                      deque[1] = vertices[0];                      deque[2] = vertices[1];                  }                  else                  {                      //Is Right. Set deque = {2' 1' 0' 2}                      deque[1] = vertices[1];                      deque[2] = vertices[0];                  }              }
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: if (k == 0)              {                  //Vertices are collinear.                  deque[0] = vertices[0];                  deque[1] = vertices[2]; //We can skip vertex 1 because it should be between 0 and 2                  deque[2] = vertices[0];                  qf = 2;                    //Go until the end of the collinear sequence of vertices                  for (startIndex = 3; startIndex < vertices.Count; startIndex++)                  {                      Vector2 tmp = vertices[startIndex];                      if (MathUtils.Area(ref deque[0]' ref deque[1]' ref tmp) == 0) //This point is also collinear                          deque[1] = vertices[startIndex];                      else break;                  }              }              else              {                  deque[0] = deque[3] = vertices[2];                  if (k > 0)                  {                      //Is Left.  Set deque = {2' 0' 1' 2}                      deque[1] = vertices[0];                      deque[2] = vertices[1];                  }                  else                  {                      //Is Right. Set deque = {2' 1' 0' 2}                      deque[1] = vertices[1];                      deque[2] = vertices[0];                  }              }
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: if (k == 0)              {                  //Vertices are collinear.                  deque[0] = vertices[0];                  deque[1] = vertices[2]; //We can skip vertex 1 because it should be between 0 and 2                  deque[2] = vertices[0];                  qf = 2;                    //Go until the end of the collinear sequence of vertices                  for (startIndex = 3; startIndex < vertices.Count; startIndex++)                  {                      Vector2 tmp = vertices[startIndex];                      if (MathUtils.Area(ref deque[0]' ref deque[1]' ref tmp) == 0) //This point is also collinear                          deque[1] = vertices[startIndex];                      else break;                  }              }              else              {                  deque[0] = deque[3] = vertices[2];                  if (k > 0)                  {                      //Is Left.  Set deque = {2' 0' 1' 2}                      deque[1] = vertices[0];                      deque[2] = vertices[1];                  }                  else                  {                      //Is Right. Set deque = {2' 1' 0' 2}                      deque[1] = vertices[1];                      deque[2] = vertices[0];                  }              }
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: if (k == 0)              {                  //Vertices are collinear.                  deque[0] = vertices[0];                  deque[1] = vertices[2]; //We can skip vertex 1 because it should be between 0 and 2                  deque[2] = vertices[0];                  qf = 2;                    //Go until the end of the collinear sequence of vertices                  for (startIndex = 3; startIndex < vertices.Count; startIndex++)                  {                      Vector2 tmp = vertices[startIndex];                      if (MathUtils.Area(ref deque[0]' ref deque[1]' ref tmp) == 0) //This point is also collinear                          deque[1] = vertices[startIndex];                      else break;                  }              }              else              {                  deque[0] = deque[3] = vertices[2];                  if (k > 0)                  {                      //Is Left.  Set deque = {2' 0' 1' 2}                      deque[1] = vertices[0];                      deque[2] = vertices[1];                  }                  else                  {                      //Is Right. Set deque = {2' 1' 0' 2}                      deque[1] = vertices[1];                      deque[2] = vertices[0];                  }              }
Magic Number,FarseerPhysics.Common.ConvexHull,Melkman,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\ConvexHull\Melkman.cs,GetConvexHull,The following statement contains a magic number: if (k == 0)              {                  //Vertices are collinear.                  deque[0] = vertices[0];                  deque[1] = vertices[2]; //We can skip vertex 1 because it should be between 0 and 2                  deque[2] = vertices[0];                  qf = 2;                    //Go until the end of the collinear sequence of vertices                  for (startIndex = 3; startIndex < vertices.Count; startIndex++)                  {                      Vector2 tmp = vertices[startIndex];                      if (MathUtils.Area(ref deque[0]' ref deque[1]' ref tmp) == 0) //This point is also collinear                          deque[1] = vertices[startIndex];                      else break;                  }              }              else              {                  deque[0] = deque[3] = vertices[2];                  if (k > 0)                  {                      //Is Left.  Set deque = {2' 0' 1' 2}                      deque[1] = vertices[0];                      deque[2] = vertices[1];                  }                  else                  {                      //Is Right. Set deque = {2' 1' 0' 2}                      deque[1] = vertices[1];                      deque[2] = vertices[0];                  }              }
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\BayazitDecomposer.cs,ConvexPartition,The following statement contains a magic number: for (int i = 0; i < vertices.Count; ++i)              {                  if (Reflex(i' vertices))                  {                      lowerDist = upperDist = float.MaxValue; // std::numeric_limits<qreal>::max();                      for (int j = 0; j < vertices.Count; ++j)                      {                          // if line intersects with an edge                          if (Left(At(i - 1' vertices)' At(i' vertices)' At(j' vertices)) &&                              RightOn(At(i - 1' vertices)' At(i' vertices)' At(j - 1' vertices)))                          {                              // find the point of intersection                              p = LineTools.LineIntersect(At(i - 1' vertices)' At(i' vertices)' At(j' vertices)'                                                          At(j - 1' vertices));                              if (Right(At(i + 1' vertices)' At(i' vertices)' p))                              {                                  // make sure it's inside the poly                                  d = SquareDist(At(i' vertices)' p);                                  if (d < lowerDist)                                  {                                      // keep only the closest intersection                                      lowerDist = d;                                      lowerInt = p;                                      lowerIndex = j;                                  }                              }                          }                            if (Left(At(i + 1' vertices)' At(i' vertices)' At(j + 1' vertices)) &&                              RightOn(At(i + 1' vertices)' At(i' vertices)' At(j' vertices)))                          {                              p = LineTools.LineIntersect(At(i + 1' vertices)' At(i' vertices)' At(j' vertices)'                                                          At(j + 1' vertices));                              if (Left(At(i - 1' vertices)' At(i' vertices)' p))                              {                                  d = SquareDist(At(i' vertices)' p);                                  if (d < upperDist)                                  {                                      upperDist = d;                                      upperIndex = j;                                      upperInt = p;                                  }                              }                          }                      }                        // if there are no vertices to connect to' choose a point in the middle                      if (lowerIndex == (upperIndex + 1) % vertices.Count)                      {                          Vector2 sp = ((lowerInt + upperInt) / 2);                            lowerPoly = Copy(i' upperIndex' vertices);                          lowerPoly.Add(sp);                          upperPoly = Copy(lowerIndex' i' vertices);                          upperPoly.Add(sp);                      }                      else                      {                          double highestScore = 0' bestIndex = lowerIndex;                          while (upperIndex < lowerIndex) upperIndex += vertices.Count;                          for (int j = lowerIndex; j <= upperIndex; ++j)                          {                              if (CanSee(i' j' vertices))                              {                                  double score = 1 / (SquareDist(At(i' vertices)' At(j' vertices)) + 1);                                  if (Reflex(j' vertices))                                  {                                      if (RightOn(At(j - 1' vertices)' At(j' vertices)' At(i' vertices)) &&                                          LeftOn(At(j + 1' vertices)' At(j' vertices)' At(i' vertices)))                                      {                                          score += 3;                                      }                                      else                                      {                                          score += 2;                                      }                                  }                                  else                                  {                                      score += 1;                                  }                                  if (score > highestScore)                                  {                                      bestIndex = j;                                      highestScore = score;                                  }                              }                          }                          lowerPoly = Copy(i' (int)bestIndex' vertices);                          upperPoly = Copy((int)bestIndex' i' vertices);                      }                      list.AddRange(ConvexPartition(lowerPoly));                      list.AddRange(ConvexPartition(upperPoly));                      return list;                  }              }
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\BayazitDecomposer.cs,ConvexPartition,The following statement contains a magic number: for (int i = 0; i < vertices.Count; ++i)              {                  if (Reflex(i' vertices))                  {                      lowerDist = upperDist = float.MaxValue; // std::numeric_limits<qreal>::max();                      for (int j = 0; j < vertices.Count; ++j)                      {                          // if line intersects with an edge                          if (Left(At(i - 1' vertices)' At(i' vertices)' At(j' vertices)) &&                              RightOn(At(i - 1' vertices)' At(i' vertices)' At(j - 1' vertices)))                          {                              // find the point of intersection                              p = LineTools.LineIntersect(At(i - 1' vertices)' At(i' vertices)' At(j' vertices)'                                                          At(j - 1' vertices));                              if (Right(At(i + 1' vertices)' At(i' vertices)' p))                              {                                  // make sure it's inside the poly                                  d = SquareDist(At(i' vertices)' p);                                  if (d < lowerDist)                                  {                                      // keep only the closest intersection                                      lowerDist = d;                                      lowerInt = p;                                      lowerIndex = j;                                  }                              }                          }                            if (Left(At(i + 1' vertices)' At(i' vertices)' At(j + 1' vertices)) &&                              RightOn(At(i + 1' vertices)' At(i' vertices)' At(j' vertices)))                          {                              p = LineTools.LineIntersect(At(i + 1' vertices)' At(i' vertices)' At(j' vertices)'                                                          At(j + 1' vertices));                              if (Left(At(i - 1' vertices)' At(i' vertices)' p))                              {                                  d = SquareDist(At(i' vertices)' p);                                  if (d < upperDist)                                  {                                      upperDist = d;                                      upperIndex = j;                                      upperInt = p;                                  }                              }                          }                      }                        // if there are no vertices to connect to' choose a point in the middle                      if (lowerIndex == (upperIndex + 1) % vertices.Count)                      {                          Vector2 sp = ((lowerInt + upperInt) / 2);                            lowerPoly = Copy(i' upperIndex' vertices);                          lowerPoly.Add(sp);                          upperPoly = Copy(lowerIndex' i' vertices);                          upperPoly.Add(sp);                      }                      else                      {                          double highestScore = 0' bestIndex = lowerIndex;                          while (upperIndex < lowerIndex) upperIndex += vertices.Count;                          for (int j = lowerIndex; j <= upperIndex; ++j)                          {                              if (CanSee(i' j' vertices))                              {                                  double score = 1 / (SquareDist(At(i' vertices)' At(j' vertices)) + 1);                                  if (Reflex(j' vertices))                                  {                                      if (RightOn(At(j - 1' vertices)' At(j' vertices)' At(i' vertices)) &&                                          LeftOn(At(j + 1' vertices)' At(j' vertices)' At(i' vertices)))                                      {                                          score += 3;                                      }                                      else                                      {                                          score += 2;                                      }                                  }                                  else                                  {                                      score += 1;                                  }                                  if (score > highestScore)                                  {                                      bestIndex = j;                                      highestScore = score;                                  }                              }                          }                          lowerPoly = Copy(i' (int)bestIndex' vertices);                          upperPoly = Copy((int)bestIndex' i' vertices);                      }                      list.AddRange(ConvexPartition(lowerPoly));                      list.AddRange(ConvexPartition(upperPoly));                      return list;                  }              }
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\BayazitDecomposer.cs,ConvexPartition,The following statement contains a magic number: for (int i = 0; i < vertices.Count; ++i)              {                  if (Reflex(i' vertices))                  {                      lowerDist = upperDist = float.MaxValue; // std::numeric_limits<qreal>::max();                      for (int j = 0; j < vertices.Count; ++j)                      {                          // if line intersects with an edge                          if (Left(At(i - 1' vertices)' At(i' vertices)' At(j' vertices)) &&                              RightOn(At(i - 1' vertices)' At(i' vertices)' At(j - 1' vertices)))                          {                              // find the point of intersection                              p = LineTools.LineIntersect(At(i - 1' vertices)' At(i' vertices)' At(j' vertices)'                                                          At(j - 1' vertices));                              if (Right(At(i + 1' vertices)' At(i' vertices)' p))                              {                                  // make sure it's inside the poly                                  d = SquareDist(At(i' vertices)' p);                                  if (d < lowerDist)                                  {                                      // keep only the closest intersection                                      lowerDist = d;                                      lowerInt = p;                                      lowerIndex = j;                                  }                              }                          }                            if (Left(At(i + 1' vertices)' At(i' vertices)' At(j + 1' vertices)) &&                              RightOn(At(i + 1' vertices)' At(i' vertices)' At(j' vertices)))                          {                              p = LineTools.LineIntersect(At(i + 1' vertices)' At(i' vertices)' At(j' vertices)'                                                          At(j + 1' vertices));                              if (Left(At(i - 1' vertices)' At(i' vertices)' p))                              {                                  d = SquareDist(At(i' vertices)' p);                                  if (d < upperDist)                                  {                                      upperDist = d;                                      upperIndex = j;                                      upperInt = p;                                  }                              }                          }                      }                        // if there are no vertices to connect to' choose a point in the middle                      if (lowerIndex == (upperIndex + 1) % vertices.Count)                      {                          Vector2 sp = ((lowerInt + upperInt) / 2);                            lowerPoly = Copy(i' upperIndex' vertices);                          lowerPoly.Add(sp);                          upperPoly = Copy(lowerIndex' i' vertices);                          upperPoly.Add(sp);                      }                      else                      {                          double highestScore = 0' bestIndex = lowerIndex;                          while (upperIndex < lowerIndex) upperIndex += vertices.Count;                          for (int j = lowerIndex; j <= upperIndex; ++j)                          {                              if (CanSee(i' j' vertices))                              {                                  double score = 1 / (SquareDist(At(i' vertices)' At(j' vertices)) + 1);                                  if (Reflex(j' vertices))                                  {                                      if (RightOn(At(j - 1' vertices)' At(j' vertices)' At(i' vertices)) &&                                          LeftOn(At(j + 1' vertices)' At(j' vertices)' At(i' vertices)))                                      {                                          score += 3;                                      }                                      else                                      {                                          score += 2;                                      }                                  }                                  else                                  {                                      score += 1;                                  }                                  if (score > highestScore)                                  {                                      bestIndex = j;                                      highestScore = score;                                  }                              }                          }                          lowerPoly = Copy(i' (int)bestIndex' vertices);                          upperPoly = Copy((int)bestIndex' i' vertices);                      }                      list.AddRange(ConvexPartition(lowerPoly));                      list.AddRange(ConvexPartition(upperPoly));                      return list;                  }              }
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\BayazitDecomposer.cs,ConvexPartition,The following statement contains a magic number: if (vertices.Count > Settings.MaxPolygonVertices)              {                  lowerPoly = Copy(0' vertices.Count / 2' vertices);                  upperPoly = Copy(vertices.Count / 2' 0' vertices);                  list.AddRange(ConvexPartition(lowerPoly));                  list.AddRange(ConvexPartition(upperPoly));              }              else                  list.Add(vertices);
Magic Number,FarseerPhysics.Common.Decomposition,BayazitDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\BayazitDecomposer.cs,ConvexPartition,The following statement contains a magic number: if (vertices.Count > Settings.MaxPolygonVertices)              {                  lowerPoly = Copy(0' vertices.Count / 2' vertices);                  upperPoly = Copy(vertices.Count / 2' 0' vertices);                  list.AddRange(ConvexPartition(lowerPoly));                  list.AddRange(ConvexPartition(upperPoly));              }              else                  list.Add(vertices);
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,ConvexPartition,The following statement contains a magic number: if (vertices.Count < 3)                  return new List<Vertices> { vertices };
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,PolygonizeTriangles,The following statement contains a magic number: List<Vertices> polys = new List<Vertices>(50);
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,PolygonizeTriangles,The following statement contains a magic number: for (int i = 0; i < triangulated.Count; ++i)              {                  covered[i] = false;                    //Check here for degenerate triangles                  if (((triangulated[i].X[0] == triangulated[i].X[1]) && (triangulated[i].Y[0] == triangulated[i].Y[1]))                      ||                      ((triangulated[i].X[1] == triangulated[i].X[2]) && (triangulated[i].Y[1] == triangulated[i].Y[2]))                      ||                      ((triangulated[i].X[0] == triangulated[i].X[2]) && (triangulated[i].Y[0] == triangulated[i].Y[2])))                  {                      covered[i] = true;                  }              }
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,PolygonizeTriangles,The following statement contains a magic number: for (int i = 0; i < triangulated.Count; ++i)              {                  covered[i] = false;                    //Check here for degenerate triangles                  if (((triangulated[i].X[0] == triangulated[i].X[1]) && (triangulated[i].Y[0] == triangulated[i].Y[1]))                      ||                      ((triangulated[i].X[1] == triangulated[i].X[2]) && (triangulated[i].Y[1] == triangulated[i].Y[2]))                      ||                      ((triangulated[i].X[0] == triangulated[i].X[2]) && (triangulated[i].Y[0] == triangulated[i].Y[2])))                  {                      covered[i] = true;                  }              }
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,PolygonizeTriangles,The following statement contains a magic number: for (int i = 0; i < triangulated.Count; ++i)              {                  covered[i] = false;                    //Check here for degenerate triangles                  if (((triangulated[i].X[0] == triangulated[i].X[1]) && (triangulated[i].Y[0] == triangulated[i].Y[1]))                      ||                      ((triangulated[i].X[1] == triangulated[i].X[2]) && (triangulated[i].Y[1] == triangulated[i].Y[2]))                      ||                      ((triangulated[i].X[0] == triangulated[i].X[2]) && (triangulated[i].Y[0] == triangulated[i].Y[2])))                  {                      covered[i] = true;                  }              }
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,PolygonizeTriangles,The following statement contains a magic number: for (int i = 0; i < triangulated.Count; ++i)              {                  covered[i] = false;                    //Check here for degenerate triangles                  if (((triangulated[i].X[0] == triangulated[i].X[1]) && (triangulated[i].Y[0] == triangulated[i].Y[1]))                      ||                      ((triangulated[i].X[1] == triangulated[i].X[2]) && (triangulated[i].Y[1] == triangulated[i].Y[2]))                      ||                      ((triangulated[i].X[0] == triangulated[i].X[2]) && (triangulated[i].Y[0] == triangulated[i].Y[2])))                  {                      covered[i] = true;                  }              }
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,PolygonizeTriangles,The following statement contains a magic number: while (notDone)              {                  int currTri = -1;                  for (int i = 0; i < triangulated.Count; ++i)                  {                      if (covered[i])                          continue;                      currTri = i;                      break;                  }                  if (currTri == -1)                  {                      notDone = false;                  }                  else                  {                      Vertices poly = new Vertices(3);                        for (int i = 0; i < 3; i++)                      {                          poly.Add(new Vector2(triangulated[currTri].X[i]' triangulated[currTri].Y[i]));                      }                        covered[currTri] = true;                      int index = 0;                      for (int i = 0; i < 2 * triangulated.Count; ++i' ++index)                      {                          while (index >= triangulated.Count) index -= triangulated.Count;                          if (covered[index])                          {                              continue;                          }                          Vertices newP = AddTriangle(triangulated[index]' poly);                          if (newP == null)                              continue; // is this right                            if (newP.Count > Settings.MaxPolygonVertices)                              continue;                            if (newP.IsConvex())                          {                              //Or should it be IsUsable?  Maybe re-write IsConvex to apply the angle threshold from Box2d                              poly = new Vertices(newP);                              covered[index] = true;                          }                      }                        //We have a maximum of polygons that we need to keep under.                      if (polyIndex < maxPolys)                      {                          //SimplifyTools.MergeParallelEdges(poly' tolerance);                            //If identical points are present' a triangle gets                          //borked by the MergeParallelEdges function' hence                          //the vertex number check                          if (poly.Count >= 3)                              polys.Add(new Vertices(poly));                          //else                          //    printf("Skipping corrupt poly\n");                      }                      if (poly.Count >= 3)                          polyIndex++; //Must be outside (polyIndex < polysLength) test                  }              }
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,PolygonizeTriangles,The following statement contains a magic number: while (notDone)              {                  int currTri = -1;                  for (int i = 0; i < triangulated.Count; ++i)                  {                      if (covered[i])                          continue;                      currTri = i;                      break;                  }                  if (currTri == -1)                  {                      notDone = false;                  }                  else                  {                      Vertices poly = new Vertices(3);                        for (int i = 0; i < 3; i++)                      {                          poly.Add(new Vector2(triangulated[currTri].X[i]' triangulated[currTri].Y[i]));                      }                        covered[currTri] = true;                      int index = 0;                      for (int i = 0; i < 2 * triangulated.Count; ++i' ++index)                      {                          while (index >= triangulated.Count) index -= triangulated.Count;                          if (covered[index])                          {                              continue;                          }                          Vertices newP = AddTriangle(triangulated[index]' poly);                          if (newP == null)                              continue; // is this right                            if (newP.Count > Settings.MaxPolygonVertices)                              continue;                            if (newP.IsConvex())                          {                              //Or should it be IsUsable?  Maybe re-write IsConvex to apply the angle threshold from Box2d                              poly = new Vertices(newP);                              covered[index] = true;                          }                      }                        //We have a maximum of polygons that we need to keep under.                      if (polyIndex < maxPolys)                      {                          //SimplifyTools.MergeParallelEdges(poly' tolerance);                            //If identical points are present' a triangle gets                          //borked by the MergeParallelEdges function' hence                          //the vertex number check                          if (poly.Count >= 3)                              polys.Add(new Vertices(poly));                          //else                          //    printf("Skipping corrupt poly\n");                      }                      if (poly.Count >= 3)                          polyIndex++; //Must be outside (polyIndex < polysLength) test                  }              }
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,PolygonizeTriangles,The following statement contains a magic number: while (notDone)              {                  int currTri = -1;                  for (int i = 0; i < triangulated.Count; ++i)                  {                      if (covered[i])                          continue;                      currTri = i;                      break;                  }                  if (currTri == -1)                  {                      notDone = false;                  }                  else                  {                      Vertices poly = new Vertices(3);                        for (int i = 0; i < 3; i++)                      {                          poly.Add(new Vector2(triangulated[currTri].X[i]' triangulated[currTri].Y[i]));                      }                        covered[currTri] = true;                      int index = 0;                      for (int i = 0; i < 2 * triangulated.Count; ++i' ++index)                      {                          while (index >= triangulated.Count) index -= triangulated.Count;                          if (covered[index])                          {                              continue;                          }                          Vertices newP = AddTriangle(triangulated[index]' poly);                          if (newP == null)                              continue; // is this right                            if (newP.Count > Settings.MaxPolygonVertices)                              continue;                            if (newP.IsConvex())                          {                              //Or should it be IsUsable?  Maybe re-write IsConvex to apply the angle threshold from Box2d                              poly = new Vertices(newP);                              covered[index] = true;                          }                      }                        //We have a maximum of polygons that we need to keep under.                      if (polyIndex < maxPolys)                      {                          //SimplifyTools.MergeParallelEdges(poly' tolerance);                            //If identical points are present' a triangle gets                          //borked by the MergeParallelEdges function' hence                          //the vertex number check                          if (poly.Count >= 3)                              polys.Add(new Vertices(poly));                          //else                          //    printf("Skipping corrupt poly\n");                      }                      if (poly.Count >= 3)                          polyIndex++; //Must be outside (polyIndex < polysLength) test                  }              }
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,PolygonizeTriangles,The following statement contains a magic number: while (notDone)              {                  int currTri = -1;                  for (int i = 0; i < triangulated.Count; ++i)                  {                      if (covered[i])                          continue;                      currTri = i;                      break;                  }                  if (currTri == -1)                  {                      notDone = false;                  }                  else                  {                      Vertices poly = new Vertices(3);                        for (int i = 0; i < 3; i++)                      {                          poly.Add(new Vector2(triangulated[currTri].X[i]' triangulated[currTri].Y[i]));                      }                        covered[currTri] = true;                      int index = 0;                      for (int i = 0; i < 2 * triangulated.Count; ++i' ++index)                      {                          while (index >= triangulated.Count) index -= triangulated.Count;                          if (covered[index])                          {                              continue;                          }                          Vertices newP = AddTriangle(triangulated[index]' poly);                          if (newP == null)                              continue; // is this right                            if (newP.Count > Settings.MaxPolygonVertices)                              continue;                            if (newP.IsConvex())                          {                              //Or should it be IsUsable?  Maybe re-write IsConvex to apply the angle threshold from Box2d                              poly = new Vertices(newP);                              covered[index] = true;                          }                      }                        //We have a maximum of polygons that we need to keep under.                      if (polyIndex < maxPolys)                      {                          //SimplifyTools.MergeParallelEdges(poly' tolerance);                            //If identical points are present' a triangle gets                          //borked by the MergeParallelEdges function' hence                          //the vertex number check                          if (poly.Count >= 3)                              polys.Add(new Vertices(poly));                          //else                          //    printf("Skipping corrupt poly\n");                      }                      if (poly.Count >= 3)                          polyIndex++; //Must be outside (polyIndex < polysLength) test                  }              }
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,PolygonizeTriangles,The following statement contains a magic number: while (notDone)              {                  int currTri = -1;                  for (int i = 0; i < triangulated.Count; ++i)                  {                      if (covered[i])                          continue;                      currTri = i;                      break;                  }                  if (currTri == -1)                  {                      notDone = false;                  }                  else                  {                      Vertices poly = new Vertices(3);                        for (int i = 0; i < 3; i++)                      {                          poly.Add(new Vector2(triangulated[currTri].X[i]' triangulated[currTri].Y[i]));                      }                        covered[currTri] = true;                      int index = 0;                      for (int i = 0; i < 2 * triangulated.Count; ++i' ++index)                      {                          while (index >= triangulated.Count) index -= triangulated.Count;                          if (covered[index])                          {                              continue;                          }                          Vertices newP = AddTriangle(triangulated[index]' poly);                          if (newP == null)                              continue; // is this right                            if (newP.Count > Settings.MaxPolygonVertices)                              continue;                            if (newP.IsConvex())                          {                              //Or should it be IsUsable?  Maybe re-write IsConvex to apply the angle threshold from Box2d                              poly = new Vertices(newP);                              covered[index] = true;                          }                      }                        //We have a maximum of polygons that we need to keep under.                      if (polyIndex < maxPolys)                      {                          //SimplifyTools.MergeParallelEdges(poly' tolerance);                            //If identical points are present' a triangle gets                          //borked by the MergeParallelEdges function' hence                          //the vertex number check                          if (poly.Count >= 3)                              polys.Add(new Vertices(poly));                          //else                          //    printf("Skipping corrupt poly\n");                      }                      if (poly.Count >= 3)                          polyIndex++; //Must be outside (polyIndex < polysLength) test                  }              }
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,TriangulatePolygon,The following statement contains a magic number: if (vertices.Count < 3)                  return new List<Triangle>();
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,TriangulatePolygon,The following statement contains a magic number: Triangle[] buffer = new Triangle[vertices.Count - 2];
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,TriangulatePolygon,The following statement contains a magic number: while (vNum > 3)              {                  // Find an ear                  int earIndex = -1;                  float earMaxMinCross = -10.0f;                  for (int i = 0; i < vNum; ++i)                  {                      if (IsEar(i' xrem' yrem' vNum))                      {                          int lower = Remainder(i - 1' vNum);                          int upper = Remainder(i + 1' vNum);                          Vector2 d1 = new Vector2(xrem[upper] - xrem[i]' yrem[upper] - yrem[i]);                          Vector2 d2 = new Vector2(xrem[i] - xrem[lower]' yrem[i] - yrem[lower]);                          Vector2 d3 = new Vector2(xrem[lower] - xrem[upper]' yrem[lower] - yrem[upper]);                            d1.Normalize();                          d2.Normalize();                          d3.Normalize();                          float cross12;                          MathUtils.Cross(ref d1' ref d2' out cross12);                          cross12 = Math.Abs(cross12);                            float cross23;                          MathUtils.Cross(ref d2' ref d3' out cross23);                          cross23 = Math.Abs(cross23);                            float cross31;                          MathUtils.Cross(ref d3' ref d1' out cross31);                          cross31 = Math.Abs(cross31);                            //Find the maximum minimum angle                          float minCross = Math.Min(cross12' Math.Min(cross23' cross31));                          if (minCross > earMaxMinCross)                          {                              earIndex = i;                              earMaxMinCross = minCross;                          }                      }                  }                    // If we still haven't found an ear' we're screwed.                  // Note: sometimes this is happening because the                  // remaining points are collinear.  Really these                  // should just be thrown out without halting triangulation.                  if (earIndex == -1)                  {                      for (int i = 0; i < bufferSize; i++)                      {                          results.Add(new Triangle(buffer[i]));                      }                        return results;                  }                    // Clip off the ear:                  // - remove the ear tip from the list                    --vNum;                  float[] newx = new float[vNum];                  float[] newy = new float[vNum];                  int currDest = 0;                  for (int i = 0; i < vNum; ++i)                  {                      if (currDest == earIndex) ++currDest;                      newx[i] = xrem[currDest];                      newy[i] = yrem[currDest];                      ++currDest;                  }                    // - add the clipped triangle to the triangle list                  int under = (earIndex == 0) ? (vNum) : (earIndex - 1);                  int over = (earIndex == vNum) ? 0 : (earIndex + 1);                  Triangle toAdd = new Triangle(xrem[earIndex]' yrem[earIndex]' xrem[over]' yrem[over]' xrem[under]'                                                yrem[under]);                  buffer[bufferSize] = toAdd;                  ++bufferSize;                    // - replace the old list with the new one                  xrem = newx;                  yrem = newy;              }
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,TriangulatePolygon,The following statement contains a magic number: Triangle tooAdd = new Triangle(xrem[1]' yrem[1]' xrem[2]' yrem[2]' xrem[0]' yrem[0]);
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,TriangulatePolygon,The following statement contains a magic number: Triangle tooAdd = new Triangle(xrem[1]' yrem[1]' xrem[2]' yrem[2]' xrem[0]' yrem[0]);
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,ResolvePinchPoint,The following statement contains a magic number: if (pin.Count < 3)                  return false;
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,AddTriangle,The following statement contains a magic number: for (int i = 0; i < vertices.Count; i++)              {                  if (t.X[0] == vertices[i].X && t.Y[0] == vertices[i].Y)                  {                      if (firstP == -1)                      {                          firstP = i;                          firstT = 0;                      }                      else                      {                          secondP = i;                          secondT = 0;                      }                  }                  else if (t.X[1] == vertices[i].X && t.Y[1] == vertices[i].Y)                  {                      if (firstP == -1)                      {                          firstP = i;                          firstT = 1;                      }                      else                      {                          secondP = i;                          secondT = 1;                      }                  }                  else if (t.X[2] == vertices[i].X && t.Y[2] == vertices[i].Y)                  {                      if (firstP == -1)                      {                          firstP = i;                          firstT = 2;                      }                      else                      {                          secondP = i;                          secondT = 2;                      }                  }              }
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,AddTriangle,The following statement contains a magic number: for (int i = 0; i < vertices.Count; i++)              {                  if (t.X[0] == vertices[i].X && t.Y[0] == vertices[i].Y)                  {                      if (firstP == -1)                      {                          firstP = i;                          firstT = 0;                      }                      else                      {                          secondP = i;                          secondT = 0;                      }                  }                  else if (t.X[1] == vertices[i].X && t.Y[1] == vertices[i].Y)                  {                      if (firstP == -1)                      {                          firstP = i;                          firstT = 1;                      }                      else                      {                          secondP = i;                          secondT = 1;                      }                  }                  else if (t.X[2] == vertices[i].X && t.Y[2] == vertices[i].Y)                  {                      if (firstP == -1)                      {                          firstP = i;                          firstT = 2;                      }                      else                      {                          secondP = i;                          secondT = 2;                      }                  }              }
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,AddTriangle,The following statement contains a magic number: for (int i = 0; i < vertices.Count; i++)              {                  if (t.X[0] == vertices[i].X && t.Y[0] == vertices[i].Y)                  {                      if (firstP == -1)                      {                          firstP = i;                          firstT = 0;                      }                      else                      {                          secondP = i;                          secondT = 0;                      }                  }                  else if (t.X[1] == vertices[i].X && t.Y[1] == vertices[i].Y)                  {                      if (firstP == -1)                      {                          firstP = i;                          firstT = 1;                      }                      else                      {                          secondP = i;                          secondT = 1;                      }                  }                  else if (t.X[2] == vertices[i].X && t.Y[2] == vertices[i].Y)                  {                      if (firstP == -1)                      {                          firstP = i;                          firstT = 2;                      }                      else                      {                          secondP = i;                          secondT = 2;                      }                  }              }
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,AddTriangle,The following statement contains a magic number: for (int i = 0; i < vertices.Count; i++)              {                  if (t.X[0] == vertices[i].X && t.Y[0] == vertices[i].Y)                  {                      if (firstP == -1)                      {                          firstP = i;                          firstT = 0;                      }                      else                      {                          secondP = i;                          secondT = 0;                      }                  }                  else if (t.X[1] == vertices[i].X && t.Y[1] == vertices[i].Y)                  {                      if (firstP == -1)                      {                          firstP = i;                          firstT = 1;                      }                      else                      {                          secondP = i;                          secondT = 1;                      }                  }                  else if (t.X[2] == vertices[i].X && t.Y[2] == vertices[i].Y)                  {                      if (firstP == -1)                      {                          firstP = i;                          firstT = 2;                      }                      else                      {                          secondP = i;                          secondT = 2;                      }                  }              }
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,AddTriangle,The following statement contains a magic number: if (tipT == firstT || tipT == secondT)                  tipT = 2;
Magic Number,FarseerPhysics.Common.Decomposition,EarclipDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,IsEar,The following statement contains a magic number: if (i >= xvLength || i < 0 || xvLength < 3)              {                  return false;              }
Magic Number,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,Triangle,The following statement contains a magic number: X = new float[3];
Magic Number,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,Triangle,The following statement contains a magic number: Y = new float[3];
Magic Number,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,Triangle,The following statement contains a magic number: if (ccw)              {                  X[0] = x1;                  X[1] = x2;                  X[2] = x3;                  Y[0] = y1;                  Y[1] = y2;                  Y[2] = y3;              }              else              {                  X[0] = x1;                  X[1] = x3;                  X[2] = x2;                  Y[0] = y1;                  Y[1] = y3;                  Y[2] = y2;              }
Magic Number,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,Triangle,The following statement contains a magic number: if (ccw)              {                  X[0] = x1;                  X[1] = x2;                  X[2] = x3;                  Y[0] = y1;                  Y[1] = y2;                  Y[2] = y3;              }              else              {                  X[0] = x1;                  X[1] = x3;                  X[2] = x2;                  Y[0] = y1;                  Y[1] = y3;                  Y[2] = y2;              }
Magic Number,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,Triangle,The following statement contains a magic number: if (ccw)              {                  X[0] = x1;                  X[1] = x2;                  X[2] = x3;                  Y[0] = y1;                  Y[1] = y2;                  Y[2] = y3;              }              else              {                  X[0] = x1;                  X[1] = x3;                  X[2] = x2;                  Y[0] = y1;                  Y[1] = y3;                  Y[2] = y2;              }
Magic Number,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,Triangle,The following statement contains a magic number: if (ccw)              {                  X[0] = x1;                  X[1] = x2;                  X[2] = x3;                  Y[0] = y1;                  Y[1] = y2;                  Y[2] = y3;              }              else              {                  X[0] = x1;                  X[1] = x3;                  X[2] = x2;                  Y[0] = y1;                  Y[1] = y3;                  Y[2] = y2;              }
Magic Number,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,Triangle,The following statement contains a magic number: X = new float[3];
Magic Number,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,Triangle,The following statement contains a magic number: Y = new float[3];
Magic Number,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,Triangle,The following statement contains a magic number: X[2] = t.X[2];
Magic Number,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,Triangle,The following statement contains a magic number: X[2] = t.X[2];
Magic Number,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,Triangle,The following statement contains a magic number: Y[2] = t.Y[2];
Magic Number,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,Triangle,The following statement contains a magic number: Y[2] = t.Y[2];
Magic Number,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,IsInside,The following statement contains a magic number: if (x < X[0] && x < X[1] && x < X[2]) return false;
Magic Number,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,IsInside,The following statement contains a magic number: if (x > X[0] && x > X[1] && x > X[2]) return false;
Magic Number,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,IsInside,The following statement contains a magic number: if (y < Y[0] && y < Y[1] && y < Y[2]) return false;
Magic Number,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,IsInside,The following statement contains a magic number: if (y > Y[0] && y > Y[1] && y > Y[2]) return false;
Magic Number,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,IsInside,The following statement contains a magic number: float vx0 = X[2] - X[0];
Magic Number,FarseerPhysics.Common.Decomposition,Triangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\EarclipDecomposer.cs,IsInside,The following statement contains a magic number: float vy0 = Y[2] - Y[0];
Magic Number,FarseerPhysics.Common.Decomposition,FlipcodeDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\FlipcodeDecomposer.cs,ConvexPartition,The following statement contains a magic number: if (n < 3)                  return new List<Vertices>();
Magic Number,FarseerPhysics.Common.Decomposition,FlipcodeDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\FlipcodeDecomposer.cs,ConvexPartition,The following statement contains a magic number: int count = 2 * nv;
Magic Number,FarseerPhysics.Common.Decomposition,FlipcodeDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\FlipcodeDecomposer.cs,ConvexPartition,The following statement contains a magic number: for (int v = nv - 1; nv > 2; )              {                  // If we loop' it is probably a non-simple polygon                   if (0 >= (count--))                  {                      // Triangulate: ERROR - probable bad polygon!                      return new List<Vertices>();                  }                    // Three consecutive vertices in current polygon' <u'v'w>                  int u = v;                  if (nv <= u)                      u = 0; // Previous                   v = u + 1;                  if (nv <= v)                      v = 0; // New v                     int w = v + 1;                  if (nv <= w)                      w = 0; // Next                     _tmpA = contour[V[u]];                  _tmpB = contour[V[v]];                  _tmpC = contour[V[w]];                    if (Snip(contour' u' v' w' nv' V))                  {                      int s' t;                        // Output Triangle                      Vertices triangle = new Vertices(3);                      triangle.Add(_tmpA);                      triangle.Add(_tmpB);                      triangle.Add(_tmpC);                      result.Add(triangle);                        // Remove v from remaining polygon                       for (s = v' t = v + 1; t < nv; s++' t++)                      {                          V[s] = V[t];                      }                      nv--;                        // Reset error detection counter                      count = 2 * nv;                  }              }
Magic Number,FarseerPhysics.Common.Decomposition,FlipcodeDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\FlipcodeDecomposer.cs,ConvexPartition,The following statement contains a magic number: for (int v = nv - 1; nv > 2; )              {                  // If we loop' it is probably a non-simple polygon                   if (0 >= (count--))                  {                      // Triangulate: ERROR - probable bad polygon!                      return new List<Vertices>();                  }                    // Three consecutive vertices in current polygon' <u'v'w>                  int u = v;                  if (nv <= u)                      u = 0; // Previous                   v = u + 1;                  if (nv <= v)                      v = 0; // New v                     int w = v + 1;                  if (nv <= w)                      w = 0; // Next                     _tmpA = contour[V[u]];                  _tmpB = contour[V[v]];                  _tmpC = contour[V[w]];                    if (Snip(contour' u' v' w' nv' V))                  {                      int s' t;                        // Output Triangle                      Vertices triangle = new Vertices(3);                      triangle.Add(_tmpA);                      triangle.Add(_tmpB);                      triangle.Add(_tmpC);                      result.Add(triangle);                        // Remove v from remaining polygon                       for (s = v' t = v + 1; t < nv; s++' t++)                      {                          V[s] = V[t];                      }                      nv--;                        // Reset error detection counter                      count = 2 * nv;                  }              }
Magic Number,FarseerPhysics.Common.Decomposition,FlipcodeDecomposer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\FlipcodeDecomposer.cs,ConvexPartition,The following statement contains a magic number: for (int v = nv - 1; nv > 2; )              {                  // If we loop' it is probably a non-simple polygon                   if (0 >= (count--))                  {                      // Triangulate: ERROR - probable bad polygon!                      return new List<Vertices>();                  }                    // Three consecutive vertices in current polygon' <u'v'w>                  int u = v;                  if (nv <= u)                      u = 0; // Previous                   v = u + 1;                  if (nv <= v)                      v = 0; // New v                     int w = v + 1;                  if (nv <= w)                      w = 0; // Next                     _tmpA = contour[V[u]];                  _tmpB = contour[V[v]];                  _tmpC = contour[V[w]];                    if (Snip(contour' u' v' w' nv' V))                  {                      int s' t;                        // Output Triangle                      Vertices triangle = new Vertices(3);                      triangle.Add(_tmpA);                      triangle.Add(_tmpB);                      triangle.Add(_tmpC);                      result.Add(triangle);                        // Remove v from remaining polygon                       for (s = v' t = v + 1; t < nv; s++' t++)                      {                          V[s] = V[t];                      }                      nv--;                        // Reset error detection counter                      count = 2 * nv;                  }              }
Magic Number,FarseerPhysics.Common.Decomposition,MonotoneMountain,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\SeidelDecomposer.cs,Add,The following statement contains a magic number: if (_size == 0)              {                  _head = point;                  _size = 1;              }              else if (_size == 1)              {                  // Keep repeat points out of the list                  _tail = point;                  _tail.Prev = _head;                  _head.Next = _tail;                  _size = 2;              }              else              {                  // Keep repeat points out of the list                  _tail.Next = point;                  point.Prev = _tail;                  _tail = point;                  _size += 1;              }
Magic Number,FarseerPhysics.Common.Decomposition,MonotoneMountain,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\SeidelDecomposer.cs,Triangulate,The following statement contains a magic number: while (_convexPoints.Count != 0)              {                  IEnumerator<Point> e = _convexPoints.GetEnumerator();                  e.MoveNext();                  Point ear = e.Current;                    _convexPoints.Remove(ear);                  Point a = ear.Prev;                  Point b = ear;                  Point c = ear.Next;                  List<Point> triangle = new List<Point>(3);                  triangle.Add(a);                  triangle.Add(b);                  triangle.Add(c);                    Triangles.Add(triangle);                    // Remove ear' update angles and convex list                  Remove(ear);                  if (Valid(a))                      _convexPoints.Add(a);                  if (Valid(c))                      _convexPoints.Add(c);              }
Magic Number,FarseerPhysics.Common.Decomposition,MonotoneMountain,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\SeidelDecomposer.cs,Triangulate,The following statement contains a magic number: Debug.Assert(_size <= 3' "Triangulation bug' please report");
Magic Number,FarseerPhysics.Common.Decomposition,QueryGraph,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\SeidelDecomposer.cs,Case1,The following statement contains a magic number: YNode yNode = new YNode(edge' Sink.Isink(tList[1])' Sink.Isink(tList[2]));
Magic Number,FarseerPhysics.Common.Decomposition,QueryGraph,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\SeidelDecomposer.cs,Case1,The following statement contains a magic number: XNode qNode = new XNode(edge.Q' yNode' Sink.Isink(tList[3]));
Magic Number,FarseerPhysics.Common.Decomposition,QueryGraph,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\SeidelDecomposer.cs,Case2,The following statement contains a magic number: YNode yNode = new YNode(edge' Sink.Isink(tList[1])' Sink.Isink(tList[2]));
Magic Number,FarseerPhysics.Common.Decomposition,QueryGraph,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\SeidelDecomposer.cs,Case4,The following statement contains a magic number: XNode qNode = new XNode(edge.Q' yNode' Sink.Isink(tList[2]));
Magic Number,FarseerPhysics.Common.Decomposition,TrapezoidalMap,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\SeidelDecomposer.cs,Case1,The following statement contains a magic number: Trapezoid[] trapezoids = new Trapezoid[4];
Magic Number,FarseerPhysics.Common.Decomposition,TrapezoidalMap,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\SeidelDecomposer.cs,Case1,The following statement contains a magic number: trapezoids[2] = new Trapezoid(e.P' e.Q' e' t.Bottom);
Magic Number,FarseerPhysics.Common.Decomposition,TrapezoidalMap,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\SeidelDecomposer.cs,Case1,The following statement contains a magic number: trapezoids[3] = new Trapezoid(e.Q' t.RightPoint' t.Top' t.Bottom);
Magic Number,FarseerPhysics.Common.Decomposition,TrapezoidalMap,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\SeidelDecomposer.cs,Case1,The following statement contains a magic number: trapezoids[1].UpdateLeftRight(trapezoids[0]' null' trapezoids[3]' null);
Magic Number,FarseerPhysics.Common.Decomposition,TrapezoidalMap,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\SeidelDecomposer.cs,Case1,The following statement contains a magic number: trapezoids[2].UpdateLeftRight(null' trapezoids[0]' null' trapezoids[3]);
Magic Number,FarseerPhysics.Common.Decomposition,TrapezoidalMap,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\SeidelDecomposer.cs,Case1,The following statement contains a magic number: trapezoids[2].UpdateLeftRight(null' trapezoids[0]' null' trapezoids[3]);
Magic Number,FarseerPhysics.Common.Decomposition,TrapezoidalMap,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\SeidelDecomposer.cs,Case1,The following statement contains a magic number: trapezoids[3].UpdateRight(t.UpperRight' t.LowerRight);
Magic Number,FarseerPhysics.Common.Decomposition,TrapezoidalMap,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\SeidelDecomposer.cs,Case2,The following statement contains a magic number: Trapezoid[] trapezoids = new Trapezoid[3];
Magic Number,FarseerPhysics.Common.Decomposition,TrapezoidalMap,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\SeidelDecomposer.cs,Case2,The following statement contains a magic number: trapezoids[2] = new Trapezoid(e.P' rp' e' t.Bottom);
Magic Number,FarseerPhysics.Common.Decomposition,TrapezoidalMap,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\SeidelDecomposer.cs,Case2,The following statement contains a magic number: trapezoids[2].UpdateLeftRight(null' trapezoids[0]' null' t.LowerRight);
Magic Number,FarseerPhysics.Common.Decomposition,TrapezoidalMap,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\SeidelDecomposer.cs,Case2,The following statement contains a magic number: e.Below = trapezoids[2];
Magic Number,FarseerPhysics.Common.Decomposition,TrapezoidalMap,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\SeidelDecomposer.cs,Case3,The following statement contains a magic number: Trapezoid[] trapezoids = new Trapezoid[2];
Magic Number,FarseerPhysics.Common.Decomposition,TrapezoidalMap,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\SeidelDecomposer.cs,Case4,The following statement contains a magic number: Trapezoid[] trapezoids = new Trapezoid[3];
Magic Number,FarseerPhysics.Common.Decomposition,TrapezoidalMap,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\SeidelDecomposer.cs,Case4,The following statement contains a magic number: trapezoids[2] = new Trapezoid(e.Q' t.RightPoint' t.Top' t.Bottom);
Magic Number,FarseerPhysics.Common.Decomposition,TrapezoidalMap,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\SeidelDecomposer.cs,Case4,The following statement contains a magic number: trapezoids[2].UpdateLeftRight(trapezoids[0]' trapezoids[1]' t.UpperRight' t.LowerRight);
Magic Number,FarseerPhysics.Common.Decomposition,Trapezoid,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\SeidelDecomposer.cs,Vertices,The following statement contains a magic number: List<Point> verts = new List<Point>(4);
Magic Number,FarseerPhysics.Common.Decomposition,Triangulator,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\SeidelDecomposer.cs,CreateMountains,The following statement contains a magic number: foreach (Edge edge in _edgeList)              {                  if (edge.MPoints.Count > 2)                  {                      MonotoneMountain mountain = new MonotoneMountain();                        // Sorting is a perfromance hit. Literature says this can be accomplised in                      // linear time' although I don't see a way around using traditional methods                      // when using a randomized incremental algorithm                        // Insertion sort is one of the fastest algorithms for sorting arrays containing                       // fewer than ten elements' or for lists that are already mostly sorted.                        List<Point> points = new List<Point>(edge.MPoints);                      points.Sort((p1' p2) => p1.X.CompareTo(p2.X));                        foreach (Point p in points)                          mountain.Add(p);                        // Triangulate monotone mountain                      mountain.Process();                        // Extract the triangles into a single list                      foreach (List<Point> t in mountain.Triangles)                      {                          Triangles.Add(t);                      }                        _xMonoPoly.Add(mountain);                  }              }
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,DelaunayTriangle,The following statement contains a magic number: Points[2] = p3;
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,IndexCW,The following statement contains a magic number: switch (index)              {                  case 0:                      return 2;                  case 1:                      return 0;                  default:                      return 1;              }
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,IndexCCW,The following statement contains a magic number: switch (index)              {                  case 0:                      return 1;                  case 1:                      return 2;                  default:                      return 0;              }
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,Contains,The following statement contains a magic number: return (p == Points[0] || p == Points[1] || p == Points[2]);
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if ((p1 == Points[2] && p2 == Points[1]) || (p1 == Points[1] && p2 == Points[2]))              {                  Neighbors[0] = t;              }              else if ((p1 == Points[0] && p2 == Points[2]) || (p1 == Points[2] && p2 == Points[0]))              {                  Neighbors[1] = t;              }              else if ((p1 == Points[0] && p2 == Points[1]) || (p1 == Points[1] && p2 == Points[0]))              {                  Neighbors[2] = t;              }              else              {                  Debug.WriteLine("Neighbor error' please report!");                  // throw new Exception("Neighbor error' please report!");              }
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if ((p1 == Points[2] && p2 == Points[1]) || (p1 == Points[1] && p2 == Points[2]))              {                  Neighbors[0] = t;              }              else if ((p1 == Points[0] && p2 == Points[2]) || (p1 == Points[2] && p2 == Points[0]))              {                  Neighbors[1] = t;              }              else if ((p1 == Points[0] && p2 == Points[1]) || (p1 == Points[1] && p2 == Points[0]))              {                  Neighbors[2] = t;              }              else              {                  Debug.WriteLine("Neighbor error' please report!");                  // throw new Exception("Neighbor error' please report!");              }
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if ((p1 == Points[2] && p2 == Points[1]) || (p1 == Points[1] && p2 == Points[2]))              {                  Neighbors[0] = t;              }              else if ((p1 == Points[0] && p2 == Points[2]) || (p1 == Points[2] && p2 == Points[0]))              {                  Neighbors[1] = t;              }              else if ((p1 == Points[0] && p2 == Points[1]) || (p1 == Points[1] && p2 == Points[0]))              {                  Neighbors[2] = t;              }              else              {                  Debug.WriteLine("Neighbor error' please report!");                  // throw new Exception("Neighbor error' please report!");              }
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if ((p1 == Points[2] && p2 == Points[1]) || (p1 == Points[1] && p2 == Points[2]))              {                  Neighbors[0] = t;              }              else if ((p1 == Points[0] && p2 == Points[2]) || (p1 == Points[2] && p2 == Points[0]))              {                  Neighbors[1] = t;              }              else if ((p1 == Points[0] && p2 == Points[1]) || (p1 == Points[1] && p2 == Points[0]))              {                  Neighbors[2] = t;              }              else              {                  Debug.WriteLine("Neighbor error' please report!");                  // throw new Exception("Neighbor error' please report!");              }
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if ((p1 == Points[2] && p2 == Points[1]) || (p1 == Points[1] && p2 == Points[2]))              {                  Neighbors[0] = t;              }              else if ((p1 == Points[0] && p2 == Points[2]) || (p1 == Points[2] && p2 == Points[0]))              {                  Neighbors[1] = t;              }              else if ((p1 == Points[0] && p2 == Points[1]) || (p1 == Points[1] && p2 == Points[0]))              {                  Neighbors[2] = t;              }              else              {                  Debug.WriteLine("Neighbor error' please report!");                  // throw new Exception("Neighbor error' please report!");              }
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if (t.Contains(Points[1]' Points[2]))              {                  Neighbors[0] = t;                  t.MarkNeighbor(Points[1]' Points[2]' this);              }              else if (t.Contains(Points[0]' Points[2]))              {                  Neighbors[1] = t;                  t.MarkNeighbor(Points[0]' Points[2]' this);              }              else if (t.Contains(Points[0]' Points[1]))              {                  Neighbors[2] = t;                  t.MarkNeighbor(Points[0]' Points[1]' this);              }              else              {                  Debug.WriteLine("markNeighbor failed");              }
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if (t.Contains(Points[1]' Points[2]))              {                  Neighbors[0] = t;                  t.MarkNeighbor(Points[1]' Points[2]' this);              }              else if (t.Contains(Points[0]' Points[2]))              {                  Neighbors[1] = t;                  t.MarkNeighbor(Points[0]' Points[2]' this);              }              else if (t.Contains(Points[0]' Points[1]))              {                  Neighbors[2] = t;                  t.MarkNeighbor(Points[0]' Points[1]' this);              }              else              {                  Debug.WriteLine("markNeighbor failed");              }
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if (t.Contains(Points[1]' Points[2]))              {                  Neighbors[0] = t;                  t.MarkNeighbor(Points[1]' Points[2]' this);              }              else if (t.Contains(Points[0]' Points[2]))              {                  Neighbors[1] = t;                  t.MarkNeighbor(Points[0]' Points[2]' this);              }              else if (t.Contains(Points[0]' Points[1]))              {                  Neighbors[2] = t;                  t.MarkNeighbor(Points[0]' Points[1]' this);              }              else              {                  Debug.WriteLine("markNeighbor failed");              }
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if (t.Contains(Points[1]' Points[2]))              {                  Neighbors[0] = t;                  t.MarkNeighbor(Points[1]' Points[2]' this);              }              else if (t.Contains(Points[0]' Points[2]))              {                  Neighbors[1] = t;                  t.MarkNeighbor(Points[0]' Points[2]' this);              }              else if (t.Contains(Points[0]' Points[1]))              {                  Neighbors[2] = t;                  t.MarkNeighbor(Points[0]' Points[1]' this);              }              else              {                  Debug.WriteLine("markNeighbor failed");              }
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighbor,The following statement contains a magic number: if (t.Contains(Points[1]' Points[2]))              {                  Neighbors[0] = t;                  t.MarkNeighbor(Points[1]' Points[2]' this);              }              else if (t.Contains(Points[0]' Points[2]))              {                  Neighbors[1] = t;                  t.MarkNeighbor(Points[0]' Points[2]' this);              }              else if (t.Contains(Points[0]' Points[1]))              {                  Neighbors[2] = t;                  t.MarkNeighbor(Points[0]' Points[1]' this);              }              else              {                  Debug.WriteLine("markNeighbor failed");              }
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,ClearNeighbors,The following statement contains a magic number: Neighbors[0] = Neighbors[1] = Neighbors[2] = null;
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,ClearNeighbor,The following statement contains a magic number: if (Neighbors[0] == triangle)              {                  Neighbors[0] = null;              }              else if (Neighbors[1] == triangle)              {                  Neighbors[1] = null;              }              else              {                  Neighbors[2] = null;              }
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,Clear,The following statement contains a magic number: for (int i = 0; i < 3; i++)              {                  t = Neighbors[i];                  if (t != null)                  {                      t.ClearNeighbor(this);                  }              }
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,Clear,The following statement contains a magic number: Points[0] = Points[1] = Points[2] = null;
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,NeighborCW,The following statement contains a magic number: return Neighbors[(Points.IndexOf(point) + 1)%3];
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,NeighborCCW,The following statement contains a magic number: return Neighbors[(Points.IndexOf(point) + 2)%3];
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,NeighborCCW,The following statement contains a magic number: return Neighbors[(Points.IndexOf(point) + 2)%3];
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,PointCCW,The following statement contains a magic number: return Points[(IndexOf(point) + 1)%3];
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,PointCW,The following statement contains a magic number: return Points[(IndexOf(point) + 2)%3];
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,PointCW,The following statement contains a magic number: return Points[(IndexOf(point) + 2)%3];
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,RotateCW,The following statement contains a magic number: var t = Points[2];
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,RotateCW,The following statement contains a magic number: Points[2] = Points[1];
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,ToString,The following statement contains a magic number: return Points[0] + "'" + Points[1] + "'" + Points[2];
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighborEdges,The following statement contains a magic number: for (int i = 0; i < 3; i++)                  if (EdgeIsConstrained[i] && Neighbors[i] != null)                  {                      Neighbors[i].MarkConstrainedEdge(Points[(i + 1)%3]' Points[(i + 2)%3]);                  }
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighborEdges,The following statement contains a magic number: for (int i = 0; i < 3; i++)                  if (EdgeIsConstrained[i] && Neighbors[i] != null)                  {                      Neighbors[i].MarkConstrainedEdge(Points[(i + 1)%3]' Points[(i + 2)%3]);                  }
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighborEdges,The following statement contains a magic number: for (int i = 0; i < 3; i++)                  if (EdgeIsConstrained[i] && Neighbors[i] != null)                  {                      Neighbors[i].MarkConstrainedEdge(Points[(i + 1)%3]' Points[(i + 2)%3]);                  }
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkNeighborEdges,The following statement contains a magic number: for (int i = 0; i < 3; i++)                  if (EdgeIsConstrained[i] && Neighbors[i] != null)                  {                      Neighbors[i].MarkConstrainedEdge(Points[(i + 1)%3]' Points[(i + 2)%3]);                  }
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: for (int i = 0; i < 3; i++)                  if (EdgeIsConstrained[i])                  {                      triangle.MarkConstrainedEdge(Points[(i + 1)%3]' Points[(i + 2)%3]);                  }
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: for (int i = 0; i < 3; i++)                  if (EdgeIsConstrained[i])                  {                      triangle.MarkConstrainedEdge(Points[(i + 1)%3]' Points[(i + 2)%3]);                  }
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: for (int i = 0; i < 3; i++)                  if (EdgeIsConstrained[i])                  {                      triangle.MarkConstrainedEdge(Points[(i + 1)%3]' Points[(i + 2)%3]);                  }
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: for (int i = 0; i < 3; i++)                  if (EdgeIsConstrained[i])                  {                      triangle.MarkConstrainedEdge(Points[(i + 1)%3]' Points[(i + 2)%3]);                  }
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: foreach (DelaunayTriangle t in tList)                  for (int i = 0; i < 3; i++)                      if (t.EdgeIsConstrained[i])                      {                          MarkConstrainedEdge(t.Points[(i + 1)%3]' t.Points[(i + 2)%3]);                      }
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: foreach (DelaunayTriangle t in tList)                  for (int i = 0; i < 3; i++)                      if (t.EdgeIsConstrained[i])                      {                          MarkConstrainedEdge(t.Points[(i + 1)%3]' t.Points[(i + 2)%3]);                      }
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: foreach (DelaunayTriangle t in tList)                  for (int i = 0; i < 3; i++)                      if (t.EdgeIsConstrained[i])                      {                          MarkConstrainedEdge(t.Points[(i + 1)%3]' t.Points[(i + 2)%3]);                      }
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,MarkEdge,The following statement contains a magic number: foreach (DelaunayTriangle t in tList)                  for (int i = 0; i < 3; i++)                      if (t.EdgeIsConstrained[i])                      {                          MarkConstrainedEdge(t.Points[(i + 1)%3]' t.Points[(i + 2)%3]);                      }
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,Area,The following statement contains a magic number: double h = Points[2].Y - Points[1].Y;
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,Centroid,The following statement contains a magic number: double cx = (Points[0].X + Points[1].X + Points[2].X)/3f;
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,Centroid,The following statement contains a magic number: double cy = (Points[0].Y + Points[1].Y + Points[2].Y)/3f;
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,EdgeIndex,The following statement contains a magic number: bool c = (i1 == 2 || i2 == 2);
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,EdgeIndex,The following statement contains a magic number: bool c = (i1 == 2 || i2 == 2);
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,EdgeIndex,The following statement contains a magic number: if (a && b) return 2;
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,GetConstrainedEdgeCCW,The following statement contains a magic number: return EdgeIsConstrained[(IndexOf(p) + 2)%3];
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,GetConstrainedEdgeCCW,The following statement contains a magic number: return EdgeIsConstrained[(IndexOf(p) + 2)%3];
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,GetConstrainedEdgeCW,The following statement contains a magic number: return EdgeIsConstrained[(IndexOf(p) + 1)%3];
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,SetConstrainedEdgeCCW,The following statement contains a magic number: EdgeIsConstrained[(IndexOf(p) + 2)%3] = ce;
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,SetConstrainedEdgeCCW,The following statement contains a magic number: EdgeIsConstrained[(IndexOf(p) + 2)%3] = ce;
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,SetConstrainedEdgeCW,The following statement contains a magic number: EdgeIsConstrained[(IndexOf(p) + 1)%3] = ce;
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,GetDelaunayEdgeCCW,The following statement contains a magic number: return EdgeIsDelaunay[(IndexOf(p) + 2)%3];
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,GetDelaunayEdgeCCW,The following statement contains a magic number: return EdgeIsDelaunay[(IndexOf(p) + 2)%3];
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,GetDelaunayEdgeCW,The following statement contains a magic number: return EdgeIsDelaunay[(IndexOf(p) + 1)%3];
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,SetDelaunayEdgeCCW,The following statement contains a magic number: EdgeIsDelaunay[(IndexOf(p) + 2)%3] = ce;
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,SetDelaunayEdgeCCW,The following statement contains a magic number: EdgeIsDelaunay[(IndexOf(p) + 2)%3] = ce;
Magic Number,Poly2Tri.Triangulation.Delaunay,DelaunayTriangle,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\DelaunayTriangle.cs,SetDelaunayEdgeCW,The following statement contains a magic number: EdgeIsDelaunay[(IndexOf(p) + 1)%3] = ce;
Magic Number,Poly2Tri.Triangulation.Delaunay.Sweep,DTSweep,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\Sweep\DTSweep.cs,Legalize,The following statement contains a magic number: for (int i = 0; i < 3; i++)              {                  // TODO: fix so that cEdge is always valid when creating new triangles then we can check it here                  //       instead of below with ot                  if (t.EdgeIsDelaunay[i])                  {                      continue;                  }                    ot = t.Neighbors[i];                  if (ot != null)                  {                      p = t.Points[i];                      op = ot.OppositePoint(t' p);                      oi = ot.IndexOf(op);                      // If this is a Constrained Edge or a Delaunay Edge(only during recursive legalization)                      // then we should not try to legalize                      if (ot.EdgeIsConstrained[oi] || ot.EdgeIsDelaunay[oi])                      {                          t.EdgeIsConstrained[i] = ot.EdgeIsConstrained[oi];                              // XXX: have no good way of setting this property when creating new triangles so lets set it here                          continue;                      }                        inside = TriangulationUtil.SmartIncircle(p'                                                               t.PointCCW(p)'                                                               t.PointCW(p)'                                                               op);                        if (inside)                      {                          bool notLegalized;                            // Lets mark this shared edge as Delaunay                           t.EdgeIsDelaunay[i] = true;                          ot.EdgeIsDelaunay[oi] = true;                            // Lets rotate shared edge one vertex CW to legalize it                          RotateTrianglePair(t' p' ot' op);                            // We now got one valid Delaunay Edge shared by two triangles                          // This gives us 4 new edges to check for Delaunay                            // Make sure that triangle to node mapping is done only one time for a specific triangle                          notLegalized = !Legalize(tcx' t);                            if (notLegalized)                          {                              tcx.MapTriangleToNodes(t);                          }                          notLegalized = !Legalize(tcx' ot);                          if (notLegalized)                          {                              tcx.MapTriangleToNodes(ot);                          }                            // Reset the Delaunay edges' since they only are valid Delaunay edges                          // until we add a new triangle or point.                          // XXX: need to think about this. Can these edges be tried after we                           //      return to previous recursive level?                          t.EdgeIsDelaunay[i] = false;                          ot.EdgeIsDelaunay[oi] = false;                            // If triangle have been legalized no need to check the other edges since                          // the recursive legalization will handles those so we can end here.                          return true;                      }                  }              }
Magic Number,Poly2Tri.Triangulation.Delaunay.Sweep,DTSweepContext,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\Sweep\DTSweepContext.cs,MeshCleanReq,The following statement contains a magic number: if (triangle != null && !triangle.IsInterior)              {                  triangle.IsInterior = true;                  Triangulatable.AddTriangle(triangle);                  for (int i = 0; i < 3; i++)                  {                      if (!triangle.EdgeIsConstrained[i])                      {                          MeshCleanReq(triangle.Neighbors[i]);                      }                  }              }
Magic Number,Poly2Tri.Triangulation.Delaunay.Sweep,DTSweepContext,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\Sweep\DTSweepContext.cs,CreateAdvancingFront,The following statement contains a magic number: tail = new AdvancingFrontNode(iTriangle.Points[2]);
Magic Number,Poly2Tri.Triangulation.Delaunay.Sweep,DTSweepContext,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Delaunay\Sweep\DTSweepContext.cs,MapTriangleToNodes,The following statement contains a magic number: for (int i = 0; i < 3; i++)              {                  if (t.Neighbors[i] == null)                  {                      n = aFront.LocatePoint(t.PointCW(t.Points[i]));                      if (n != null)                      {                          n.Triangle = t;                      }                  }              }
Magic Number,Poly2Tri.Triangulation.Polygon,Polygon,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Polygon\Polygon.cs,Polygon,The following statement contains a magic number: if (points.Count < 3) throw new ArgumentException("List has fewer than 3 points"' "points");
Magic Number,Poly2Tri.Triangulation.Sets,ConstrainedPointSet,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Sets\ConstrainedPointSet.cs,PrepareTriangulation,The following statement contains a magic number: if (_constrainedPointList != null)              {                  TriangulationPoint p1' p2;                  List<TriangulationPoint>.Enumerator iterator = _constrainedPointList.GetEnumerator();                  while (iterator.MoveNext())                  {                      p1 = iterator.Current;                      iterator.MoveNext();                      p2 = iterator.Current;                      tcx.NewConstraint(p1' p2);                  }              }              else              {                  for (int i = 0; i < EdgeIndex.Length; i += 2)                  {                      // XXX: must change!!                      tcx.NewConstraint(Points[EdgeIndex[i]]' Points[EdgeIndex[i + 1]]);                  }              }
Magic Number,Poly2Tri.Triangulation.Util,FixedArray3,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Util\FixedArray3.cs,Contains,The following statement contains a magic number: for (int i = 0; i < 3; ++i) if (this[i] == value) return true;
Magic Number,Poly2Tri.Triangulation.Util,FixedArray3,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Util\FixedArray3.cs,IndexOf,The following statement contains a magic number: for (int i = 0; i < 3; ++i) if (this[i] == value) return i;
Magic Number,Poly2Tri.Triangulation.Util,FixedArray3,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Util\FixedArray3.cs,Clear,The following statement contains a magic number: for (int i = 0; i < 3; ++i) if (this[i] == value) this[i] = null;
Magic Number,Poly2Tri.Triangulation.Util,FixedArray3,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Util\FixedArray3.cs,Enumerate,The following statement contains a magic number: for (int i = 0; i < 3; ++i) yield return this[i];
Magic Number,Poly2Tri.Triangulation.Util,FixedBitArray3,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Util\FixedBitArray3.cs,Contains,The following statement contains a magic number: for (int i = 0; i < 3; ++i) if (this[i] == value) return true;
Magic Number,Poly2Tri.Triangulation.Util,FixedBitArray3,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Util\FixedBitArray3.cs,IndexOf,The following statement contains a magic number: for (int i = 0; i < 3; ++i) if (this[i] == value) return i;
Magic Number,Poly2Tri.Triangulation.Util,FixedBitArray3,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Util\FixedBitArray3.cs,Clear,The following statement contains a magic number: for (int i = 0; i < 3; ++i) if (this[i] == value) this[i] = false;
Magic Number,Poly2Tri.Triangulation.Util,FixedBitArray3,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Util\FixedBitArray3.cs,Enumerate,The following statement contains a magic number: for (int i = 0; i < 3; ++i) yield return this[i];
Magic Number,Poly2Tri.Triangulation.Util,PointGenerator,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Util\PointGenerator.cs,UniformDistribution,The following statement contains a magic number: for (int i = 0; i < n; i++)              {                  points.Add(new TriangulationPoint(scale*(0.5 - RNG.NextDouble())' scale*(0.5 - RNG.NextDouble())));              }
Magic Number,Poly2Tri.Triangulation.Util,PointGenerator,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Util\PointGenerator.cs,UniformDistribution,The following statement contains a magic number: for (int i = 0; i < n; i++)              {                  points.Add(new TriangulationPoint(scale*(0.5 - RNG.NextDouble())' scale*(0.5 - RNG.NextDouble())));              }
Magic Number,Poly2Tri.Triangulation.Util,PointGenerator,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Util\PointGenerator.cs,UniformGrid,The following statement contains a magic number: double halfScale = 0.5*scale;
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: double radius = scale/4;
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++)              {                  do                  {                      if (i%250 == 0)                      {                          radius += scale/2*(0.5 - RNG.NextDouble());                      }                      else if (i%50 == 0)                      {                          radius += scale/5*(0.5 - RNG.NextDouble());                      }                      else                      {                          radius += 25*scale/vertexCount*(0.5 - RNG.NextDouble());                      }                      radius = radius > scale/2 ? scale/2 : radius;                      radius = radius < scale/10 ? scale/10 : radius;                  } while (radius < scale/10 || radius > scale/2);                  point = new PolygonPoint(radius*Math.Cos((PI_2*i)/vertexCount)'                                           radius*Math.Sin((PI_2*i)/vertexCount));                  points[i] = point;              }
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++)              {                  do                  {                      if (i%250 == 0)                      {                          radius += scale/2*(0.5 - RNG.NextDouble());                      }                      else if (i%50 == 0)                      {                          radius += scale/5*(0.5 - RNG.NextDouble());                      }                      else                      {                          radius += 25*scale/vertexCount*(0.5 - RNG.NextDouble());                      }                      radius = radius > scale/2 ? scale/2 : radius;                      radius = radius < scale/10 ? scale/10 : radius;                  } while (radius < scale/10 || radius > scale/2);                  point = new PolygonPoint(radius*Math.Cos((PI_2*i)/vertexCount)'                                           radius*Math.Sin((PI_2*i)/vertexCount));                  points[i] = point;              }
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++)              {                  do                  {                      if (i%250 == 0)                      {                          radius += scale/2*(0.5 - RNG.NextDouble());                      }                      else if (i%50 == 0)                      {                          radius += scale/5*(0.5 - RNG.NextDouble());                      }                      else                      {                          radius += 25*scale/vertexCount*(0.5 - RNG.NextDouble());                      }                      radius = radius > scale/2 ? scale/2 : radius;                      radius = radius < scale/10 ? scale/10 : radius;                  } while (radius < scale/10 || radius > scale/2);                  point = new PolygonPoint(radius*Math.Cos((PI_2*i)/vertexCount)'                                           radius*Math.Sin((PI_2*i)/vertexCount));                  points[i] = point;              }
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++)              {                  do                  {                      if (i%250 == 0)                      {                          radius += scale/2*(0.5 - RNG.NextDouble());                      }                      else if (i%50 == 0)                      {                          radius += scale/5*(0.5 - RNG.NextDouble());                      }                      else                      {                          radius += 25*scale/vertexCount*(0.5 - RNG.NextDouble());                      }                      radius = radius > scale/2 ? scale/2 : radius;                      radius = radius < scale/10 ? scale/10 : radius;                  } while (radius < scale/10 || radius > scale/2);                  point = new PolygonPoint(radius*Math.Cos((PI_2*i)/vertexCount)'                                           radius*Math.Sin((PI_2*i)/vertexCount));                  points[i] = point;              }
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++)              {                  do                  {                      if (i%250 == 0)                      {                          radius += scale/2*(0.5 - RNG.NextDouble());                      }                      else if (i%50 == 0)                      {                          radius += scale/5*(0.5 - RNG.NextDouble());                      }                      else                      {                          radius += 25*scale/vertexCount*(0.5 - RNG.NextDouble());                      }                      radius = radius > scale/2 ? scale/2 : radius;                      radius = radius < scale/10 ? scale/10 : radius;                  } while (radius < scale/10 || radius > scale/2);                  point = new PolygonPoint(radius*Math.Cos((PI_2*i)/vertexCount)'                                           radius*Math.Sin((PI_2*i)/vertexCount));                  points[i] = point;              }
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++)              {                  do                  {                      if (i%250 == 0)                      {                          radius += scale/2*(0.5 - RNG.NextDouble());                      }                      else if (i%50 == 0)                      {                          radius += scale/5*(0.5 - RNG.NextDouble());                      }                      else                      {                          radius += 25*scale/vertexCount*(0.5 - RNG.NextDouble());                      }                      radius = radius > scale/2 ? scale/2 : radius;                      radius = radius < scale/10 ? scale/10 : radius;                  } while (radius < scale/10 || radius > scale/2);                  point = new PolygonPoint(radius*Math.Cos((PI_2*i)/vertexCount)'                                           radius*Math.Sin((PI_2*i)/vertexCount));                  points[i] = point;              }
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++)              {                  do                  {                      if (i%250 == 0)                      {                          radius += scale/2*(0.5 - RNG.NextDouble());                      }                      else if (i%50 == 0)                      {                          radius += scale/5*(0.5 - RNG.NextDouble());                      }                      else                      {                          radius += 25*scale/vertexCount*(0.5 - RNG.NextDouble());                      }                      radius = radius > scale/2 ? scale/2 : radius;                      radius = radius < scale/10 ? scale/10 : radius;                  } while (radius < scale/10 || radius > scale/2);                  point = new PolygonPoint(radius*Math.Cos((PI_2*i)/vertexCount)'                                           radius*Math.Sin((PI_2*i)/vertexCount));                  points[i] = point;              }
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++)              {                  do                  {                      if (i%250 == 0)                      {                          radius += scale/2*(0.5 - RNG.NextDouble());                      }                      else if (i%50 == 0)                      {                          radius += scale/5*(0.5 - RNG.NextDouble());                      }                      else                      {                          radius += 25*scale/vertexCount*(0.5 - RNG.NextDouble());                      }                      radius = radius > scale/2 ? scale/2 : radius;                      radius = radius < scale/10 ? scale/10 : radius;                  } while (radius < scale/10 || radius > scale/2);                  point = new PolygonPoint(radius*Math.Cos((PI_2*i)/vertexCount)'                                           radius*Math.Sin((PI_2*i)/vertexCount));                  points[i] = point;              }
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++)              {                  do                  {                      if (i%250 == 0)                      {                          radius += scale/2*(0.5 - RNG.NextDouble());                      }                      else if (i%50 == 0)                      {                          radius += scale/5*(0.5 - RNG.NextDouble());                      }                      else                      {                          radius += 25*scale/vertexCount*(0.5 - RNG.NextDouble());                      }                      radius = radius > scale/2 ? scale/2 : radius;                      radius = radius < scale/10 ? scale/10 : radius;                  } while (radius < scale/10 || radius > scale/2);                  point = new PolygonPoint(radius*Math.Cos((PI_2*i)/vertexCount)'                                           radius*Math.Sin((PI_2*i)/vertexCount));                  points[i] = point;              }
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++)              {                  do                  {                      if (i%250 == 0)                      {                          radius += scale/2*(0.5 - RNG.NextDouble());                      }                      else if (i%50 == 0)                      {                          radius += scale/5*(0.5 - RNG.NextDouble());                      }                      else                      {                          radius += 25*scale/vertexCount*(0.5 - RNG.NextDouble());                      }                      radius = radius > scale/2 ? scale/2 : radius;                      radius = radius < scale/10 ? scale/10 : radius;                  } while (radius < scale/10 || radius > scale/2);                  point = new PolygonPoint(radius*Math.Cos((PI_2*i)/vertexCount)'                                           radius*Math.Sin((PI_2*i)/vertexCount));                  points[i] = point;              }
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++)              {                  do                  {                      if (i%250 == 0)                      {                          radius += scale/2*(0.5 - RNG.NextDouble());                      }                      else if (i%50 == 0)                      {                          radius += scale/5*(0.5 - RNG.NextDouble());                      }                      else                      {                          radius += 25*scale/vertexCount*(0.5 - RNG.NextDouble());                      }                      radius = radius > scale/2 ? scale/2 : radius;                      radius = radius < scale/10 ? scale/10 : radius;                  } while (radius < scale/10 || radius > scale/2);                  point = new PolygonPoint(radius*Math.Cos((PI_2*i)/vertexCount)'                                           radius*Math.Sin((PI_2*i)/vertexCount));                  points[i] = point;              }
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++)              {                  do                  {                      if (i%250 == 0)                      {                          radius += scale/2*(0.5 - RNG.NextDouble());                      }                      else if (i%50 == 0)                      {                          radius += scale/5*(0.5 - RNG.NextDouble());                      }                      else                      {                          radius += 25*scale/vertexCount*(0.5 - RNG.NextDouble());                      }                      radius = radius > scale/2 ? scale/2 : radius;                      radius = radius < scale/10 ? scale/10 : radius;                  } while (radius < scale/10 || radius > scale/2);                  point = new PolygonPoint(radius*Math.Cos((PI_2*i)/vertexCount)'                                           radius*Math.Sin((PI_2*i)/vertexCount));                  points[i] = point;              }
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++)              {                  do                  {                      if (i%250 == 0)                      {                          radius += scale/2*(0.5 - RNG.NextDouble());                      }                      else if (i%50 == 0)                      {                          radius += scale/5*(0.5 - RNG.NextDouble());                      }                      else                      {                          radius += 25*scale/vertexCount*(0.5 - RNG.NextDouble());                      }                      radius = radius > scale/2 ? scale/2 : radius;                      radius = radius < scale/10 ? scale/10 : radius;                  } while (radius < scale/10 || radius > scale/2);                  point = new PolygonPoint(radius*Math.Cos((PI_2*i)/vertexCount)'                                           radius*Math.Sin((PI_2*i)/vertexCount));                  points[i] = point;              }
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++)              {                  do                  {                      if (i%250 == 0)                      {                          radius += scale/2*(0.5 - RNG.NextDouble());                      }                      else if (i%50 == 0)                      {                          radius += scale/5*(0.5 - RNG.NextDouble());                      }                      else                      {                          radius += 25*scale/vertexCount*(0.5 - RNG.NextDouble());                      }                      radius = radius > scale/2 ? scale/2 : radius;                      radius = radius < scale/10 ? scale/10 : radius;                  } while (radius < scale/10 || radius > scale/2);                  point = new PolygonPoint(radius*Math.Cos((PI_2*i)/vertexCount)'                                           radius*Math.Sin((PI_2*i)/vertexCount));                  points[i] = point;              }
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: double radius = scale/4;
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++)              {                  do                  {                      radius += scale/5*(0.5 - RNG.NextDouble());                      radius = radius > scale/2 ? scale/2 : radius;                      radius = radius < scale/10 ? scale/10 : radius;                  } while (radius < scale/10 || radius > scale/2);                  point = new PolygonPoint(radius*Math.Cos((PI_2*i)/vertexCount)'                                           radius*Math.Sin((PI_2*i)/vertexCount));                  points[i] = point;              }
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++)              {                  do                  {                      radius += scale/5*(0.5 - RNG.NextDouble());                      radius = radius > scale/2 ? scale/2 : radius;                      radius = radius < scale/10 ? scale/10 : radius;                  } while (radius < scale/10 || radius > scale/2);                  point = new PolygonPoint(radius*Math.Cos((PI_2*i)/vertexCount)'                                           radius*Math.Sin((PI_2*i)/vertexCount));                  points[i] = point;              }
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++)              {                  do                  {                      radius += scale/5*(0.5 - RNG.NextDouble());                      radius = radius > scale/2 ? scale/2 : radius;                      radius = radius < scale/10 ? scale/10 : radius;                  } while (radius < scale/10 || radius > scale/2);                  point = new PolygonPoint(radius*Math.Cos((PI_2*i)/vertexCount)'                                           radius*Math.Sin((PI_2*i)/vertexCount));                  points[i] = point;              }
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++)              {                  do                  {                      radius += scale/5*(0.5 - RNG.NextDouble());                      radius = radius > scale/2 ? scale/2 : radius;                      radius = radius < scale/10 ? scale/10 : radius;                  } while (radius < scale/10 || radius > scale/2);                  point = new PolygonPoint(radius*Math.Cos((PI_2*i)/vertexCount)'                                           radius*Math.Sin((PI_2*i)/vertexCount));                  points[i] = point;              }
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++)              {                  do                  {                      radius += scale/5*(0.5 - RNG.NextDouble());                      radius = radius > scale/2 ? scale/2 : radius;                      radius = radius < scale/10 ? scale/10 : radius;                  } while (radius < scale/10 || radius > scale/2);                  point = new PolygonPoint(radius*Math.Cos((PI_2*i)/vertexCount)'                                           radius*Math.Sin((PI_2*i)/vertexCount));                  points[i] = point;              }
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++)              {                  do                  {                      radius += scale/5*(0.5 - RNG.NextDouble());                      radius = radius > scale/2 ? scale/2 : radius;                      radius = radius < scale/10 ? scale/10 : radius;                  } while (radius < scale/10 || radius > scale/2);                  point = new PolygonPoint(radius*Math.Cos((PI_2*i)/vertexCount)'                                           radius*Math.Sin((PI_2*i)/vertexCount));                  points[i] = point;              }
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++)              {                  do                  {                      radius += scale/5*(0.5 - RNG.NextDouble());                      radius = radius > scale/2 ? scale/2 : radius;                      radius = radius < scale/10 ? scale/10 : radius;                  } while (radius < scale/10 || radius > scale/2);                  point = new PolygonPoint(radius*Math.Cos((PI_2*i)/vertexCount)'                                           radius*Math.Sin((PI_2*i)/vertexCount));                  points[i] = point;              }
Magic Number,Poly2Tri.Triangulation.Util,PolygonGenerator,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Decomposition\CDT\Util\PolygonGenerator.cs,RandomCircleSweep2,The following statement contains a magic number: for (int i = 0; i < vertexCount; i++)              {                  do                  {                      radius += scale/5*(0.5 - RNG.NextDouble());                      radius = radius > scale/2 ? scale/2 : radius;                      radius = radius < scale/10 ? scale/10 : radius;                  } while (radius < scale/10 || radius > scale/2);                  point = new PolygonPoint(radius*Math.Cos((PI_2*i)/vertexCount)'                                           radius*Math.Sin((PI_2*i)/vertexCount));                  points[i] = point;              }
Magic Number,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PhysicsLogic\Explosion.cs,Activate,The following statement contains a magic number: Fixture[] containedShapes = new Fixture[5];
Magic Number,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PhysicsLogic\Explosion.cs,Activate,The following statement contains a magic number: float[] vals = new float[shapeCount * 2];
Magic Number,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PhysicsLogic\Explosion.cs,Activate,The following statement contains a magic number: for (int i = 0; i < shapeCount; ++i)              {                  PolygonShape ps;                  CircleShape cs = shapes[i].Shape as CircleShape;                  if (cs != null)                  {                      // We create a "diamond" approximation of the circle                      Vertices v = new Vertices();                      Vector2 vec = Vector2.Zero + new Vector2(cs.Radius' 0);                      v.Add(vec);                      vec = Vector2.Zero + new Vector2(0' cs.Radius);                      v.Add(vec);                      vec = Vector2.Zero + new Vector2(-cs.Radius' cs.Radius);                      v.Add(vec);                      vec = Vector2.Zero + new Vector2(0' -cs.Radius);                      v.Add(vec);                      ps = new PolygonShape(v' 0);                  }                  else                      ps = shapes[i].Shape as PolygonShape;                    if ((shapes[i].Body.BodyType == BodyType.Dynamic) && ps != null)                  {                      Vector2 toCentroid = shapes[i].Body.GetWorldPoint(ps.MassData.Centroid) - pos;                      float angleToCentroid = (float)Math.Atan2(toCentroid.Y' toCentroid.X);                      float min = float.MaxValue;                      float max = float.MinValue;                      float minAbsolute = 0.0f;                      float maxAbsolute = 0.0f;                        for (int j = 0; j < (ps.Vertices.Count()); ++j)                      {                          Vector2 toVertex = (shapes[i].Body.GetWorldPoint(ps.Vertices[j]) - pos);                          float newAngle = (float)Math.Atan2(toVertex.Y' toVertex.X);                          float diff = (newAngle - angleToCentroid);                            diff = (diff - MathHelper.Pi) % (2 * MathHelper.Pi);                          // the minus pi is important. It means cutoff for going other direction is at 180 deg where it needs to be                            if (diff < 0.0f)                              diff += 2 * MathHelper.Pi; // correction for not handling negs                            diff -= MathHelper.Pi;                            if (Math.Abs(diff) > MathHelper.Pi)                              throw new ArgumentException("OMG!");                          // Something's wrong' point not in shape but exists angle diff > 180                            if (diff > max)                          {                              max = diff;                              maxAbsolute = newAngle;                          }                          if (diff < min)                          {                              min = diff;                              minAbsolute = newAngle;                          }                      }                        vals[valIndex] = minAbsolute;                      ++valIndex;                      vals[valIndex] = maxAbsolute;                      ++valIndex;                  }              }
Magic Number,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PhysicsLogic\Explosion.cs,Activate,The following statement contains a magic number: for (int i = 0; i < shapeCount; ++i)              {                  PolygonShape ps;                  CircleShape cs = shapes[i].Shape as CircleShape;                  if (cs != null)                  {                      // We create a "diamond" approximation of the circle                      Vertices v = new Vertices();                      Vector2 vec = Vector2.Zero + new Vector2(cs.Radius' 0);                      v.Add(vec);                      vec = Vector2.Zero + new Vector2(0' cs.Radius);                      v.Add(vec);                      vec = Vector2.Zero + new Vector2(-cs.Radius' cs.Radius);                      v.Add(vec);                      vec = Vector2.Zero + new Vector2(0' -cs.Radius);                      v.Add(vec);                      ps = new PolygonShape(v' 0);                  }                  else                      ps = shapes[i].Shape as PolygonShape;                    if ((shapes[i].Body.BodyType == BodyType.Dynamic) && ps != null)                  {                      Vector2 toCentroid = shapes[i].Body.GetWorldPoint(ps.MassData.Centroid) - pos;                      float angleToCentroid = (float)Math.Atan2(toCentroid.Y' toCentroid.X);                      float min = float.MaxValue;                      float max = float.MinValue;                      float minAbsolute = 0.0f;                      float maxAbsolute = 0.0f;                        for (int j = 0; j < (ps.Vertices.Count()); ++j)                      {                          Vector2 toVertex = (shapes[i].Body.GetWorldPoint(ps.Vertices[j]) - pos);                          float newAngle = (float)Math.Atan2(toVertex.Y' toVertex.X);                          float diff = (newAngle - angleToCentroid);                            diff = (diff - MathHelper.Pi) % (2 * MathHelper.Pi);                          // the minus pi is important. It means cutoff for going other direction is at 180 deg where it needs to be                            if (diff < 0.0f)                              diff += 2 * MathHelper.Pi; // correction for not handling negs                            diff -= MathHelper.Pi;                            if (Math.Abs(diff) > MathHelper.Pi)                              throw new ArgumentException("OMG!");                          // Something's wrong' point not in shape but exists angle diff > 180                            if (diff > max)                          {                              max = diff;                              maxAbsolute = newAngle;                          }                          if (diff < min)                          {                              min = diff;                              minAbsolute = newAngle;                          }                      }                        vals[valIndex] = minAbsolute;                      ++valIndex;                      vals[valIndex] = maxAbsolute;                      ++valIndex;                  }              }
Magic Number,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PhysicsLogic\Explosion.cs,Activate,The following statement contains a magic number: for (int i = 0; i < valIndex; ++i)              {                  Fixture shape = null;                  float midpt;                    int iplus = (i == valIndex - 1 ? 0 : i + 1);                  if (vals[i] == vals[iplus])                      continue;                    if (i == valIndex - 1)                  {                      // the single edgecase                      midpt = (vals[0] + MathHelper.Pi * 2 + vals[i]);                  }                  else                  {                      midpt = (vals[i + 1] + vals[i]);                  }                    midpt = midpt / 2;                    Vector2 p1 = pos;                  Vector2 p2 = radius * new Vector2((float)Math.Cos(midpt)'                                                  (float)Math.Sin(midpt)) + pos;                    // RaycastOne                  bool hitClosest = false;                  World.RayCast((f' p' n' fr) =>                                    {                                        Body body = f.Body;                                          if (!IsActiveOn(body))                                            return 0;                                          if (body.UserData != null)                                        {                                            int index = (int)body.UserData;                                            if (index == 0)                                            {                                                // filter                                                return -1.0f;                                            }                                        }                                          hitClosest = true;                                        shape = f;                                        return fr;                                    }' p1' p2);                    //draws radius points                  if ((hitClosest) && (shape.Body.BodyType == BodyType.Dynamic))                  {                      if ((_data.Count() > 0) && (_data.Last().Body == shape.Body) && (!rayMissed))                      {                          int laPos = _data.Count - 1;                          ShapeData la = _data[laPos];                          la.Max = vals[iplus];                          _data[laPos] = la;                      }                      else                      {                          // make new                          ShapeData d;                          d.Body = shape.Body;                          d.Min = vals[i];                          d.Max = vals[iplus];                          _data.Add(d);                      }                        if ((_data.Count() > 1)                          && (i == valIndex - 1)                          && (_data.Last().Body == _data.First().Body)                          && (_data.Last().Max == _data.First().Min))                      {                          ShapeData fi = _data[0];                          fi.Min = _data.Last().Min;                          _data.RemoveAt(_data.Count() - 1);                          _data[0] = fi;                          while (_data.First().Min >= _data.First().Max)                          {                              fi.Min -= MathHelper.Pi * 2;                              _data[0] = fi;                          }                      }                        int lastPos = _data.Count - 1;                      ShapeData last = _data[lastPos];                      while ((_data.Count() > 0)                             && (_data.Last().Min >= _data.Last().Max)) // just making sure min<max                      {                          last.Min = _data.Last().Min - 2 * MathHelper.Pi;                          _data[lastPos] = last;                      }                      rayMissed = false;                  }                  else                  {                      rayMissed = true; // raycast did not find a shape                  }              }
Magic Number,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PhysicsLogic\Explosion.cs,Activate,The following statement contains a magic number: for (int i = 0; i < valIndex; ++i)              {                  Fixture shape = null;                  float midpt;                    int iplus = (i == valIndex - 1 ? 0 : i + 1);                  if (vals[i] == vals[iplus])                      continue;                    if (i == valIndex - 1)                  {                      // the single edgecase                      midpt = (vals[0] + MathHelper.Pi * 2 + vals[i]);                  }                  else                  {                      midpt = (vals[i + 1] + vals[i]);                  }                    midpt = midpt / 2;                    Vector2 p1 = pos;                  Vector2 p2 = radius * new Vector2((float)Math.Cos(midpt)'                                                  (float)Math.Sin(midpt)) + pos;                    // RaycastOne                  bool hitClosest = false;                  World.RayCast((f' p' n' fr) =>                                    {                                        Body body = f.Body;                                          if (!IsActiveOn(body))                                            return 0;                                          if (body.UserData != null)                                        {                                            int index = (int)body.UserData;                                            if (index == 0)                                            {                                                // filter                                                return -1.0f;                                            }                                        }                                          hitClosest = true;                                        shape = f;                                        return fr;                                    }' p1' p2);                    //draws radius points                  if ((hitClosest) && (shape.Body.BodyType == BodyType.Dynamic))                  {                      if ((_data.Count() > 0) && (_data.Last().Body == shape.Body) && (!rayMissed))                      {                          int laPos = _data.Count - 1;                          ShapeData la = _data[laPos];                          la.Max = vals[iplus];                          _data[laPos] = la;                      }                      else                      {                          // make new                          ShapeData d;                          d.Body = shape.Body;                          d.Min = vals[i];                          d.Max = vals[iplus];                          _data.Add(d);                      }                        if ((_data.Count() > 1)                          && (i == valIndex - 1)                          && (_data.Last().Body == _data.First().Body)                          && (_data.Last().Max == _data.First().Min))                      {                          ShapeData fi = _data[0];                          fi.Min = _data.Last().Min;                          _data.RemoveAt(_data.Count() - 1);                          _data[0] = fi;                          while (_data.First().Min >= _data.First().Max)                          {                              fi.Min -= MathHelper.Pi * 2;                              _data[0] = fi;                          }                      }                        int lastPos = _data.Count - 1;                      ShapeData last = _data[lastPos];                      while ((_data.Count() > 0)                             && (_data.Last().Min >= _data.Last().Max)) // just making sure min<max                      {                          last.Min = _data.Last().Min - 2 * MathHelper.Pi;                          _data[lastPos] = last;                      }                      rayMissed = false;                  }                  else                  {                      rayMissed = true; // raycast did not find a shape                  }              }
Magic Number,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PhysicsLogic\Explosion.cs,Activate,The following statement contains a magic number: for (int i = 0; i < valIndex; ++i)              {                  Fixture shape = null;                  float midpt;                    int iplus = (i == valIndex - 1 ? 0 : i + 1);                  if (vals[i] == vals[iplus])                      continue;                    if (i == valIndex - 1)                  {                      // the single edgecase                      midpt = (vals[0] + MathHelper.Pi * 2 + vals[i]);                  }                  else                  {                      midpt = (vals[i + 1] + vals[i]);                  }                    midpt = midpt / 2;                    Vector2 p1 = pos;                  Vector2 p2 = radius * new Vector2((float)Math.Cos(midpt)'                                                  (float)Math.Sin(midpt)) + pos;                    // RaycastOne                  bool hitClosest = false;                  World.RayCast((f' p' n' fr) =>                                    {                                        Body body = f.Body;                                          if (!IsActiveOn(body))                                            return 0;                                          if (body.UserData != null)                                        {                                            int index = (int)body.UserData;                                            if (index == 0)                                            {                                                // filter                                                return -1.0f;                                            }                                        }                                          hitClosest = true;                                        shape = f;                                        return fr;                                    }' p1' p2);                    //draws radius points                  if ((hitClosest) && (shape.Body.BodyType == BodyType.Dynamic))                  {                      if ((_data.Count() > 0) && (_data.Last().Body == shape.Body) && (!rayMissed))                      {                          int laPos = _data.Count - 1;                          ShapeData la = _data[laPos];                          la.Max = vals[iplus];                          _data[laPos] = la;                      }                      else                      {                          // make new                          ShapeData d;                          d.Body = shape.Body;                          d.Min = vals[i];                          d.Max = vals[iplus];                          _data.Add(d);                      }                        if ((_data.Count() > 1)                          && (i == valIndex - 1)                          && (_data.Last().Body == _data.First().Body)                          && (_data.Last().Max == _data.First().Min))                      {                          ShapeData fi = _data[0];                          fi.Min = _data.Last().Min;                          _data.RemoveAt(_data.Count() - 1);                          _data[0] = fi;                          while (_data.First().Min >= _data.First().Max)                          {                              fi.Min -= MathHelper.Pi * 2;                              _data[0] = fi;                          }                      }                        int lastPos = _data.Count - 1;                      ShapeData last = _data[lastPos];                      while ((_data.Count() > 0)                             && (_data.Last().Min >= _data.Last().Max)) // just making sure min<max                      {                          last.Min = _data.Last().Min - 2 * MathHelper.Pi;                          _data[lastPos] = last;                      }                      rayMissed = false;                  }                  else                  {                      rayMissed = true; // raycast did not find a shape                  }              }
Magic Number,FarseerPhysics.Common.PhysicsLogic,Explosion,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PhysicsLogic\Explosion.cs,Activate,The following statement contains a magic number: for (int i = 0; i < valIndex; ++i)              {                  Fixture shape = null;                  float midpt;                    int iplus = (i == valIndex - 1 ? 0 : i + 1);                  if (vals[i] == vals[iplus])                      continue;                    if (i == valIndex - 1)                  {                      // the single edgecase                      midpt = (vals[0] + MathHelper.Pi * 2 + vals[i]);                  }                  else                  {                      midpt = (vals[i + 1] + vals[i]);                  }                    midpt = midpt / 2;                    Vector2 p1 = pos;                  Vector2 p2 = radius * new Vector2((float)Math.Cos(midpt)'                                                  (float)Math.Sin(midpt)) + pos;                    // RaycastOne                  bool hitClosest = false;                  World.RayCast((f' p' n' fr) =>                                    {                                        Body body = f.Body;                                          if (!IsActiveOn(body))                                            return 0;                                          if (body.UserData != null)                                        {                                            int index = (int)body.UserData;                                            if (index == 0)                                            {                                                // filter                                                return -1.0f;                                            }                                        }                                          hitClosest = true;                                        shape = f;                                        return fr;                                    }' p1' p2);                    //draws radius points                  if ((hitClosest) && (shape.Body.BodyType == BodyType.Dynamic))                  {                      if ((_data.Count() > 0) && (_data.Last().Body == shape.Body) && (!rayMissed))                      {                          int laPos = _data.Count - 1;                          ShapeData la = _data[laPos];                          la.Max = vals[iplus];                          _data[laPos] = la;                      }                      else                      {                          // make new                          ShapeData d;                          d.Body = shape.Body;                          d.Min = vals[i];                          d.Max = vals[iplus];                          _data.Add(d);                      }                        if ((_data.Count() > 1)                          && (i == valIndex - 1)                          && (_data.Last().Body == _data.First().Body)                          && (_data.Last().Max == _data.First().Min))                      {                          ShapeData fi = _data[0];                          fi.Min = _data.Last().Min;                          _data.RemoveAt(_data.Count() - 1);                          _data[0] = fi;                          while (_data.First().Min >= _data.First().Max)                          {                              fi.Min -= MathHelper.Pi * 2;                              _data[0] = fi;                          }                      }                        int lastPos = _data.Count - 1;                      ShapeData last = _data[lastPos];                      while ((_data.Count() > 0)                             && (_data.Last().Min >= _data.Last().Max)) // just making sure min<max                      {                          last.Min = _data.Last().Min - 2 * MathHelper.Pi;                          _data[lastPos] = last;                      }                      rayMissed = false;                  }                  else                  {                      rayMissed = true; // raycast did not find a shape                  }              }
Magic Number,FarseerPhysics.Common.PolygonManipulation,CuttingTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonManipulation\CuttingTools.cs,SplitShape,The following statement contains a magic number: Vertices[] newPolygon = new Vertices[2];
Magic Number,FarseerPhysics.Common.PolygonManipulation,CuttingTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonManipulation\CuttingTools.cs,SplitShape,The following statement contains a magic number: for (int n = 0; n < 2; n++)              {                  Vector2 offset;                  if (cutAdded[n] > 0)                  {                      offset = (newPolygon[n][cutAdded[n] - 1] - newPolygon[n][cutAdded[n]]);                  }                  else                  {                      offset = (newPolygon[n][newPolygon[n].Count - 1] - newPolygon[n][0]);                  }                  offset.Normalize();                    newPolygon[n][cutAdded[n]] += splitSize * offset;                    if (cutAdded[n] < newPolygon[n].Count - 2)                  {                      offset = (newPolygon[n][cutAdded[n] + 2] - newPolygon[n][cutAdded[n] + 1]);                  }                  else                  {                      offset = (newPolygon[n][0] - newPolygon[n][newPolygon[n].Count - 1]);                  }                  offset.Normalize();                    newPolygon[n][cutAdded[n] + 1] += splitSize * offset;              }
Magic Number,FarseerPhysics.Common.PolygonManipulation,CuttingTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonManipulation\CuttingTools.cs,SplitShape,The following statement contains a magic number: for (int n = 0; n < 2; n++)              {                  Vector2 offset;                  if (cutAdded[n] > 0)                  {                      offset = (newPolygon[n][cutAdded[n] - 1] - newPolygon[n][cutAdded[n]]);                  }                  else                  {                      offset = (newPolygon[n][newPolygon[n].Count - 1] - newPolygon[n][0]);                  }                  offset.Normalize();                    newPolygon[n][cutAdded[n]] += splitSize * offset;                    if (cutAdded[n] < newPolygon[n].Count - 2)                  {                      offset = (newPolygon[n][cutAdded[n] + 2] - newPolygon[n][cutAdded[n] + 1]);                  }                  else                  {                      offset = (newPolygon[n][0] - newPolygon[n][newPolygon[n].Count - 1]);                  }                  offset.Normalize();                    newPolygon[n][cutAdded[n] + 1] += splitSize * offset;              }
Magic Number,FarseerPhysics.Common.PolygonManipulation,CuttingTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonManipulation\CuttingTools.cs,SplitShape,The following statement contains a magic number: for (int n = 0; n < 2; n++)              {                  Vector2 offset;                  if (cutAdded[n] > 0)                  {                      offset = (newPolygon[n][cutAdded[n] - 1] - newPolygon[n][cutAdded[n]]);                  }                  else                  {                      offset = (newPolygon[n][newPolygon[n].Count - 1] - newPolygon[n][0]);                  }                  offset.Normalize();                    newPolygon[n][cutAdded[n]] += splitSize * offset;                    if (cutAdded[n] < newPolygon[n].Count - 2)                  {                      offset = (newPolygon[n][cutAdded[n] + 2] - newPolygon[n][cutAdded[n] + 1]);                  }                  else                  {                      offset = (newPolygon[n][0] - newPolygon[n][newPolygon[n].Count - 1]);                  }                  offset.Normalize();                    newPolygon[n][cutAdded[n] + 1] += splitSize * offset;              }
Magic Number,FarseerPhysics.Common.PolygonManipulation,CuttingTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonManipulation\CuttingTools.cs,Cut,The following statement contains a magic number: if (entryPoints.Count + exitPoints.Count < 2)                  return;
Magic Number,FarseerPhysics.Common.PolygonManipulation,CuttingTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonManipulation\CuttingTools.cs,SanityCheck,The following statement contains a magic number: if (vertices.Count < 3)                  return false;
Magic Number,FarseerPhysics.Common.PolygonManipulation,SimplifyTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonManipulation\SimplifyTools.cs,CollinearSimplify,The following statement contains a magic number: if (vertices.Count < 3)                  return vertices;
Magic Number,FarseerPhysics.Common.PolygonManipulation,SimplifyTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonManipulation\SimplifyTools.cs,ReduceByArea,The following statement contains a magic number: if (vertices.Count <= 3)                  return vertices;
Magic Number,FarseerPhysics.Common.PolygonManipulation,SimplifyTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonManipulation\SimplifyTools.cs,ReduceByArea,The following statement contains a magic number: v1 = vertices[vertices.Count - 2];
Magic Number,FarseerPhysics.Common.PolygonManipulation,SimplifyTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonManipulation\SimplifyTools.cs,ReduceByArea,The following statement contains a magic number: areaTolerance *= 2;
Magic Number,FarseerPhysics.Common.PolygonManipulation,SimplifyTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonManipulation\SimplifyTools.cs,MergeParallelEdges,The following statement contains a magic number: if (vertices.Count <= 3)                  return;
Magic Number,FarseerPhysics.Common.PolygonManipulation,SimplifyTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonManipulation\SimplifyTools.cs,MergeParallelEdges,The following statement contains a magic number: for (int i = 0; i < vertices.Count; ++i)              {                  int lower = (i == 0) ? (vertices.Count - 1) : (i - 1);                  int middle = i;                  int upper = (i == vertices.Count - 1) ? (0) : (i + 1);                    float dx0 = vertices[middle].X - vertices[lower].X;                  float dy0 = vertices[middle].Y - vertices[lower].Y;                  float dx1 = vertices[upper].Y - vertices[middle].X;                  float dy1 = vertices[upper].Y - vertices[middle].Y;                  float norm0 = (float)Math.Sqrt(dx0 * dx0 + dy0 * dy0);                  float norm1 = (float)Math.Sqrt(dx1 * dx1 + dy1 * dy1);                    if (!(norm0 > 0.0f && norm1 > 0.0f) && newNVertices > 3)                  {                      //Merge identical points                      mergeMe[i] = true;                      --newNVertices;                  }                    dx0 /= norm0;                  dy0 /= norm0;                  dx1 /= norm1;                  dy1 /= norm1;                  float cross = dx0 * dy1 - dx1 * dy0;                  float dot = dx0 * dx1 + dy0 * dy1;                    if (Math.Abs(cross) < tolerance && dot > 0 && newNVertices > 3)                  {                      mergeMe[i] = true;                      --newNVertices;                  }                  else                      mergeMe[i] = false;              }
Magic Number,FarseerPhysics.Common.PolygonManipulation,SimplifyTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonManipulation\SimplifyTools.cs,MergeParallelEdges,The following statement contains a magic number: for (int i = 0; i < vertices.Count; ++i)              {                  int lower = (i == 0) ? (vertices.Count - 1) : (i - 1);                  int middle = i;                  int upper = (i == vertices.Count - 1) ? (0) : (i + 1);                    float dx0 = vertices[middle].X - vertices[lower].X;                  float dy0 = vertices[middle].Y - vertices[lower].Y;                  float dx1 = vertices[upper].Y - vertices[middle].X;                  float dy1 = vertices[upper].Y - vertices[middle].Y;                  float norm0 = (float)Math.Sqrt(dx0 * dx0 + dy0 * dy0);                  float norm1 = (float)Math.Sqrt(dx1 * dx1 + dy1 * dy1);                    if (!(norm0 > 0.0f && norm1 > 0.0f) && newNVertices > 3)                  {                      //Merge identical points                      mergeMe[i] = true;                      --newNVertices;                  }                    dx0 /= norm0;                  dy0 /= norm0;                  dx1 /= norm1;                  dy1 /= norm1;                  float cross = dx0 * dy1 - dx1 * dy0;                  float dot = dx0 * dx1 + dy0 * dy1;                    if (Math.Abs(cross) < tolerance && dot > 0 && newNVertices > 3)                  {                      mergeMe[i] = true;                      --newNVertices;                  }                  else                      mergeMe[i] = false;              }
Magic Number,FarseerPhysics.Common.PolygonManipulation,SimplifyTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonManipulation\SimplifyTools.cs,ReduceByDistance,The following statement contains a magic number: if (vertices.Count < 3)                  return vertices;
Magic Number,FarseerPhysics.Common.PolygonManipulation,SimplifyTools,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonManipulation\SimplifyTools.cs,ReduceByNth,The following statement contains a magic number: if (vertices.Count < 3)                  return vertices;
Magic Number,FarseerPhysics.Common.PolygonManipulation,YuPengClipper,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\PolygonManipulation\YuPengClipper.cs,BuildPolygonsFromChain,The following statement contains a magic number: while (simplicies.Count > 0)              {                  Vertices output = new Vertices();                  output.Add(simplicies[0].EdgeStart);                  output.Add(simplicies[0].EdgeEnd);                  simplicies.RemoveAt(0);                  bool closed = false;                  int index = 0;                  int count = simplicies.Count; // Needed to catch infinite loops                  while (!closed && simplicies.Count > 0)                  {                      if (VectorEqual(output[output.Count - 1]' simplicies[index].EdgeStart))                      {                          if (VectorEqual(simplicies[index].EdgeEnd' output[0]))                          {                              closed = true;                          }                          else                          {                              output.Add(simplicies[index].EdgeEnd);                          }                          simplicies.RemoveAt(index);                          --index;                      }                      else if (VectorEqual(output[output.Count - 1]' simplicies[index].EdgeEnd))                      {                          if (VectorEqual(simplicies[index].EdgeStart' output[0]))                          {                              closed = true;                          }                          else                          {                              output.Add(simplicies[index].EdgeStart);                          }                          simplicies.RemoveAt(index);                          --index;                      }                      if (!closed)                      {                          if (++index == simplicies.Count)                          {                              if (count == simplicies.Count)                              {                                  result = new List<Vertices>();                                  Debug.WriteLine("Undefined error while building result polygon(s).");                                  return PolyClipError.BrokenResult;                              }                              index = 0;                              count = simplicies.Count;                          }                      }                  }                  if (output.Count < 3)                  {                      errVal = PolyClipError.DegeneratedOutput;                      Debug.WriteLine("Degenerated output polygon produced (vertices < 3).");                  }                  result.Add(output);              }
Magic Number,FarseerPhysics.Controllers,AbstractForceController,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Controllers\AbstractForceController.cs,AbstractForceController,The following statement contains a magic number: Randomize = new Random(1234);
Magic Number,FarseerPhysics.Controllers,AbstractForceController,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Controllers\AbstractForceController.cs,AbstractForceController,The following statement contains a magic number: StrengthCurve.Keys.Add(new CurveKey(0' 5));
Magic Number,FarseerPhysics.Controllers,AbstractForceController,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Controllers\AbstractForceController.cs,AbstractForceController,The following statement contains a magic number: StrengthCurve.Keys.Add(new CurveKey(0.1f' 5));
Magic Number,FarseerPhysics.Controllers,AbstractForceController,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Controllers\AbstractForceController.cs,AbstractForceController,The following statement contains a magic number: StrengthCurve.Keys.Add(new CurveKey(0.2f' -4));
Magic Number,FarseerPhysics.Dynamics,Body,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\Body.cs,Body,The following statement contains a magic number: FixtureList = new List<Fixture>(32);
Magic Number,FarseerPhysics.Dynamics,Body,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\Body.cs,Body,The following statement contains a magic number: FixtureList = new List<Fixture>(32);
Magic Number,FarseerPhysics.Dynamics,Island,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\Island.cs,Reset,The following statement contains a magic number: if (_contacts == null || _contacts.Length < contactCapacity)              {                  _contacts = new Contact[contactCapacity * 2];              }
Magic Number,FarseerPhysics.Dynamics,Island,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\Island.cs,Reset,The following statement contains a magic number: if (_joints == null || _joints.Length < jointCapacity)              {                  _joints = new Joint[jointCapacity * 2];              }
Magic Number,FarseerPhysics.Dynamics,World,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\World.cs,World,The following statement contains a magic number: BodyList = new List<Body>(32);
Magic Number,FarseerPhysics.Dynamics,World,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\World.cs,World,The following statement contains a magic number: JointList = new List<Joint>(32);
Magic Number,FarseerPhysics.Dynamics,World,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\World.cs,Solve,The following statement contains a magic number: if (stackSize > _stack.Length)                  _stack = new Body[Math.Max(_stack.Length * 2' stackSize)];
Magic Number,FarseerPhysics.Dynamics,World,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\World.cs,SolveTOI,The following statement contains a magic number: Island.Reset(2 * Settings.MaxTOIContacts' Settings.MaxTOIContacts' 0' ContactManager);
Magic Number,FarseerPhysics.Dynamics,World,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\World.cs,SolveTOI,The following statement contains a magic number: for (; ; )              {                  // Find the first TOI.                  Contact minContact = null;                  float minAlpha = 1.0f;                    for (int i = 0; i < ContactManager.ContactList.Count; i++)                  {                      Contact c = ContactManager.ContactList[i];                        // Is this contact disabled?                      if (c.Enabled == false)                      {                          continue;                      }                        // Prevent excessive sub-stepping.                      if (c.TOICount > Settings.MaxSubSteps)                      {                          continue;                      }                        float alpha;                      if ((c.Flags & ContactFlags.TOI) == ContactFlags.TOI)                      {                          // This contact has a valid cached TOI.                          alpha = c.TOI;                      }                      else                      {                          Fixture fA = c.FixtureA;                          Fixture fB = c.FixtureB;                            // Is there a sensor?                          if (fA.IsSensor || fB.IsSensor)                          {                              continue;                          }                            Body bA = fA.Body;                          Body bB = fB.Body;                            BodyType typeA = bA.BodyType;                          BodyType typeB = bB.BodyType;                          Debug.Assert(typeA == BodyType.Dynamic || typeB == BodyType.Dynamic);                            bool awakeA = bA.Awake && typeA != BodyType.Static;                          bool awakeB = bB.Awake && typeB != BodyType.Static;                            // Is at least one body awake?                          if (awakeA == false && awakeB == false)                          {                              continue;                          }                            bool collideA = (bA.IsBullet || typeA != BodyType.Dynamic) && !bA.IgnoreCCD;                          bool collideB = (bB.IsBullet || typeB != BodyType.Dynamic) && !bB.IgnoreCCD;                            // Are these two non-bullet dynamic bodies?                          if (collideA == false && collideB == false)                          {                              continue;                          }                            // Compute the TOI for this contact.                          // Put the sweeps onto the same time interval.                          float alpha0 = bA.Sweep.Alpha0;                            if (bA.Sweep.Alpha0 < bB.Sweep.Alpha0)                          {                              alpha0 = bB.Sweep.Alpha0;                              bA.Sweep.Advance(alpha0);                          }                          else if (bB.Sweep.Alpha0 < bA.Sweep.Alpha0)                          {                              alpha0 = bA.Sweep.Alpha0;                              bB.Sweep.Advance(alpha0);                          }                            Debug.Assert(alpha0 < 1.0f);                            // Compute the time of impact in interval [0' minTOI]                          _input.ProxyA.Set(fA.Shape' c.ChildIndexA);                          _input.ProxyB.Set(fB.Shape' c.ChildIndexB);                          _input.SweepA = bA.Sweep;                          _input.SweepB = bB.Sweep;                          _input.TMax = 1.0f;                            TOIOutput output;                          TimeOfImpact.CalculateTimeOfImpact(out output' _input);                            // Beta is the fraction of the remaining portion of the .                          float beta = output.T;                          if (output.State == TOIOutputState.Touching)                          {                              alpha = Math.Min(alpha0 + (1.0f - alpha0) * beta' 1.0f);                          }                          else                          {                              alpha = 1.0f;                          }                            c.TOI = alpha;                          c.Flags |= ContactFlags.TOI;                      }                        if (alpha < minAlpha)                      {                          // This is the minimum TOI found so far.                          minContact = c;                          minAlpha = alpha;                      }                  }                    if (minContact == null || 1.0f - 10.0f * Settings.Epsilon < minAlpha)                  {                      // No more TOI events. Done!                      _stepComplete = true;                      break;                  }                    // Advance the bodies to the TOI.                  Fixture fA1 = minContact.FixtureA;                  Fixture fB1 = minContact.FixtureB;                  Body bA1 = fA1.Body;                  Body bB1 = fB1.Body;                    Sweep backup1 = bA1.Sweep;                  Sweep backup2 = bB1.Sweep;                    bA1.Advance(minAlpha);                  bB1.Advance(minAlpha);                    // The TOI contact likely has some new contact points.                  minContact.Update(ContactManager);                  minContact.Flags &= ~ContactFlags.TOI;                  ++minContact.TOICount;                    // Is the contact solid?                  if (minContact.Enabled == false || minContact.IsTouching() == false)                  {                      // Restore the sweeps.                      minContact.Enabled = false;                      bA1.Sweep = backup1;                      bB1.Sweep = backup2;                      bA1.SynchronizeTransform();                      bB1.SynchronizeTransform();                      continue;                  }                    bA1.Awake = true;                  bB1.Awake = true;                    // Build the island                  Island.Clear();                  Island.Add(bA1);                  Island.Add(bB1);                  Island.Add(minContact);                    bA1.Flags |= BodyFlags.Island;                  bB1.Flags |= BodyFlags.Island;                  minContact.Flags |= ContactFlags.Island;                    // Get contacts on bodyA and bodyB.                  Body[] bodies = { bA1' bB1 };                  for (int i = 0; i < 2; ++i)                  {                      Body body = bodies[i];                      if (body.BodyType == BodyType.Dynamic)                      {                          // for (ContactEdge ce = body.ContactList; ce && Island.BodyCount < Settings.MaxTOIContacts; ce = ce.Next)                          for (ContactEdge ce = body.ContactList; ce != null; ce = ce.Next)                          {                              Contact contact = ce.Contact;                                // Has this contact already been added to the island?                              if ((contact.Flags & ContactFlags.Island) == ContactFlags.Island)                              {                                  continue;                              }                                // Only add static' kinematic' or bullet bodies.                              Body other = ce.Other;                              if (other.BodyType == BodyType.Dynamic &&                                  body.IsBullet == false && other.IsBullet == false)                              {                                  continue;                              }                                // Skip sensors.                              if (contact.FixtureA.IsSensor || contact.FixtureB.IsSensor)                              {                                  continue;                              }                                // Tentatively advance the body to the TOI.                              Sweep backup = other.Sweep;                              if ((other.Flags & BodyFlags.Island) == 0)                              {                                  other.Advance(minAlpha);                              }                                // Update the contact points                              contact.Update(ContactManager);                                // Was the contact disabled by the user?                              if (contact.Enabled == false)                              {                                  other.Sweep = backup;                                  other.SynchronizeTransform();                                  continue;                              }                                // Are there contact points?                              if (contact.IsTouching() == false)                              {                                  other.Sweep = backup;                                  other.SynchronizeTransform();                                  continue;                              }                                // Add the contact to the island                              contact.Flags |= ContactFlags.Island;                              Island.Add(contact);                                // Has the other body already been added to the island?                              if ((other.Flags & BodyFlags.Island) == BodyFlags.Island)                              {                                  continue;                              }                                // Add the other body to the island.                              other.Flags |= BodyFlags.Island;                                if (other.BodyType != BodyType.Static)                              {                                  other.Awake = true;                              }                                Island.Add(other);                          }                      }                  }                    TimeStep subStep;                  subStep.dt = (1.0f - minAlpha) * step.dt;                  subStep.inv_dt = 1.0f / subStep.dt;                  subStep.dtRatio = 1.0f;                  //subStep.positionIterations = 20;                  //subStep.velocityIterations = step.velocityIterations;                  //subStep.warmStarting = false;                  Island.SolveTOI(ref subStep);                    // Reset island flags and synchronize broad-phase proxies.                  for (int i = 0; i < Island.BodyCount; ++i)                  {                      Body body = Island.Bodies[i];                      body.Flags &= ~BodyFlags.Island;                        if (body.BodyType != BodyType.Dynamic)                      {                          continue;                      }                        body.SynchronizeFixtures();                        // Invalidate all contact TOIs on this displaced body.                      for (ContactEdge ce = body.ContactList; ce != null; ce = ce.Next)                      {                          ce.Contact.Flags &= ~(ContactFlags.TOI | ContactFlags.Island);                      }                  }                    // Commit fixture proxy movements to the broad-phase so that new contacts are created.                  // Also' some contacts can be destroyed.                  ContactManager.FindNewContacts();                    if (EnableSubStepping)                  {                      _stepComplete = false;                      break;                  }              }
Magic Number,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\Contacts\ContactSolver.cs,Reset,The following statement contains a magic number: if (Constraints == null || Constraints.Length < _constraintCount)              {                  Constraints = new ContactConstraint[_constraintCount * 2];                    for (int i = 0; i < Constraints.Length; i++)                  {                      Constraints[i] = new ContactConstraint();                  }              }
Magic Number,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\Contacts\ContactSolver.cs,InitializeVelocityConstraints,The following statement contains a magic number: for (int i = 0; i < _constraintCount; ++i)              {                  ContactConstraint cc = Constraints[i];                    float radiusA = cc.RadiusA;                  float radiusB = cc.RadiusB;                  Body bodyA = cc.BodyA;                  Body bodyB = cc.BodyB;                  Manifold manifold = cc.Manifold;                    Vector2 vA = bodyA.LinearVelocity;                  Vector2 vB = bodyB.LinearVelocity;                  float wA = bodyA.AngularVelocity;                  float wB = bodyB.AngularVelocity;                    Debug.Assert(manifold.PointCount > 0);                  FixedArray2<Vector2> points;                    Collision.Collision.GetWorldManifold(ref manifold' ref bodyA.Xf' radiusA' ref bodyB.Xf' radiusB'                                                       out cc.Normal' out points);                  Vector2 tangent = new Vector2(cc.Normal.Y' -cc.Normal.X);                    for (int j = 0; j < cc.PointCount; ++j)                  {                      ContactConstraintPoint ccp = cc.Points[j];                        ccp.rA = points[j] - bodyA.Sweep.C;                      ccp.rB = points[j] - bodyB.Sweep.C;                        float rnA = ccp.rA.X * cc.Normal.Y - ccp.rA.Y * cc.Normal.X;                      float rnB = ccp.rB.X * cc.Normal.Y - ccp.rB.Y * cc.Normal.X;                      rnA *= rnA;                      rnB *= rnB;                        float kNormal = bodyA.InvMass + bodyB.InvMass + bodyA.InvI * rnA + bodyB.InvI * rnB;                        Debug.Assert(kNormal > Settings.Epsilon);                      ccp.NormalMass = 1.0f / kNormal;                        float rtA = ccp.rA.X * tangent.Y - ccp.rA.Y * tangent.X;                      float rtB = ccp.rB.X * tangent.Y - ccp.rB.Y * tangent.X;                        rtA *= rtA;                      rtB *= rtB;                      float kTangent = bodyA.InvMass + bodyB.InvMass + bodyA.InvI * rtA + bodyB.InvI * rtB;                        Debug.Assert(kTangent > Settings.Epsilon);                      ccp.TangentMass = 1.0f / kTangent;                        // Setup a velocity bias for restitution.                      ccp.VelocityBias = 0.0f;                      float vRel = cc.Normal.X * (vB.X + -wB * ccp.rB.Y - vA.X - -wA * ccp.rA.Y) +                                   cc.Normal.Y * (vB.Y + wB * ccp.rB.X - vA.Y - wA * ccp.rA.X);                      if (vRel < -Settings.VelocityThreshold)                      {                          ccp.VelocityBias = -cc.Restitution * vRel;                      }                  }                    // If we have two points' then prepare the block solver.                  if (cc.PointCount == 2)                  {                      ContactConstraintPoint ccp1 = cc.Points[0];                      ContactConstraintPoint ccp2 = cc.Points[1];                        float invMassA = bodyA.InvMass;                      float invIA = bodyA.InvI;                      float invMassB = bodyB.InvMass;                      float invIB = bodyB.InvI;                        float rn1A = ccp1.rA.X * cc.Normal.Y - ccp1.rA.Y * cc.Normal.X;                      float rn1B = ccp1.rB.X * cc.Normal.Y - ccp1.rB.Y * cc.Normal.X;                      float rn2A = ccp2.rA.X * cc.Normal.Y - ccp2.rA.Y * cc.Normal.X;                      float rn2B = ccp2.rB.X * cc.Normal.Y - ccp2.rB.Y * cc.Normal.X;                        float k11 = invMassA + invMassB + invIA * rn1A * rn1A + invIB * rn1B * rn1B;                      float k22 = invMassA + invMassB + invIA * rn2A * rn2A + invIB * rn2B * rn2B;                      float k12 = invMassA + invMassB + invIA * rn1A * rn2A + invIB * rn1B * rn2B;                        // Ensure a reasonable condition number.                      const float k_maxConditionNumber = 100.0f;                      if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12))                      {                          // K is safe to invert.                          cc.K.Col1.X = k11;                          cc.K.Col1.Y = k12;                          cc.K.Col2.X = k12;                          cc.K.Col2.Y = k22;                            float a = cc.K.Col1.X' b = cc.K.Col2.X' c = cc.K.Col1.Y' d = cc.K.Col2.Y;                          float det = a * d - b * c;                          if (det != 0.0f)                          {                              det = 1.0f / det;                          }                            cc.NormalMass.Col1.X = det * d;                          cc.NormalMass.Col1.Y = -det * c;                          cc.NormalMass.Col2.X = -det * b;                          cc.NormalMass.Col2.Y = det * a;                      }                      else                      {                          // The constraints are redundant' just use one.                          // TODO_ERIN use deepest?                          cc.PointCount = 1;                      }                  }              }
Magic Number,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\Contacts\ContactSolver.cs,SolveVelocityConstraints,The following statement contains a magic number: for (int i = 0; i < _constraintCount; ++i)              {                  ContactConstraint c = Constraints[i];                  float wA = c.BodyA.AngularVelocityInternal;                  float wB = c.BodyB.AngularVelocityInternal;                    float tangentx = c.Normal.Y;                  float tangenty = -c.Normal.X;                    float friction = c.Friction;                    Debug.Assert(c.PointCount == 1 || c.PointCount == 2);                    // Solve tangent constraints                  for (int j = 0; j < c.PointCount; ++j)                  {                      ContactConstraintPoint ccp = c.Points[j];                      float lambda = ccp.TangentMass *                                     -((c.BodyB.LinearVelocityInternal.X + (-wB * ccp.rB.Y) -                                        c.BodyA.LinearVelocityInternal.X - (-wA * ccp.rA.Y)) * tangentx +                                       (c.BodyB.LinearVelocityInternal.Y + (wB * ccp.rB.X) -                                        c.BodyA.LinearVelocityInternal.Y - (wA * ccp.rA.X)) * tangenty);                        // MathUtils.Clamp the accumulated force                      float maxFriction = friction * ccp.NormalImpulse;                      float newImpulse = Math.Max(-maxFriction' Math.Min(ccp.TangentImpulse + lambda' maxFriction));                      lambda = newImpulse - ccp.TangentImpulse;                        // Apply contact impulse                      float px = lambda * tangentx;                      float py = lambda * tangenty;                        c.BodyA.LinearVelocityInternal.X -= c.BodyA.InvMass * px;                      c.BodyA.LinearVelocityInternal.Y -= c.BodyA.InvMass * py;                      wA -= c.BodyA.InvI * (ccp.rA.X * py - ccp.rA.Y * px);                        c.BodyB.LinearVelocityInternal.X += c.BodyB.InvMass * px;                      c.BodyB.LinearVelocityInternal.Y += c.BodyB.InvMass * py;                      wB += c.BodyB.InvI * (ccp.rB.X * py - ccp.rB.Y * px);                        ccp.TangentImpulse = newImpulse;                  }                    // Solve normal constraints                  if (c.PointCount == 1)                  {                      ContactConstraintPoint ccp = c.Points[0];                        // Relative velocity at contact                      // Compute normal impulse                      float lambda = -ccp.NormalMass *                                     ((c.BodyB.LinearVelocityInternal.X + (-wB * ccp.rB.Y) -                                       c.BodyA.LinearVelocityInternal.X - (-wA * ccp.rA.Y)) * c.Normal.X +                                      (c.BodyB.LinearVelocityInternal.Y + (wB * ccp.rB.X) -                                       c.BodyA.LinearVelocityInternal.Y -                                       (wA * ccp.rA.X)) * c.Normal.Y - ccp.VelocityBias);                        // Clamp the accumulated impulse                      float newImpulse = Math.Max(ccp.NormalImpulse + lambda' 0.0f);                      lambda = newImpulse - ccp.NormalImpulse;                        // Apply contact impulse                      float px = lambda * c.Normal.X;                      float py = lambda * c.Normal.Y;                        c.BodyA.LinearVelocityInternal.X -= c.BodyA.InvMass * px;                      c.BodyA.LinearVelocityInternal.Y -= c.BodyA.InvMass * py;                      wA -= c.BodyA.InvI * (ccp.rA.X * py - ccp.rA.Y * px);                        c.BodyB.LinearVelocityInternal.X += c.BodyB.InvMass * px;                      c.BodyB.LinearVelocityInternal.Y += c.BodyB.InvMass * py;                      wB += c.BodyB.InvI * (ccp.rB.X * py - ccp.rB.Y * px);                        ccp.NormalImpulse = newImpulse;                  }                  else                  {                      // Block solver developed in collaboration with Dirk Gregorius (back in 01/07 on Box2D_Lite).                      // Build the mini LCP for this contact patch                      //                      // vn = A * x + b' vn >= 0' ' vn >= 0' x >= 0 and vn_i * x_i = 0 with i = 1..2                      //                      // A = J * W * JT and J = ( -n' -r1 x n' n' r2 x n )                      // b = vn_0 - velocityBias                      //                      // The system is solved using the "Total enumeration method" (s. Murty). The complementary constraint vn_i * x_i                      // implies that we must have in any solution either vn_i = 0 or x_i = 0. So for the 2D contact problem the cases                      // vn1 = 0 and vn2 = 0' x1 = 0 and x2 = 0' x1 = 0 and vn2 = 0' x2 = 0 and vn1 = 0 need to be tested. The first valid                      // solution that satisfies the problem is chosen.                      //                       // In order to account of the accumulated impulse 'a' (because of the iterative nature of the solver which only requires                      // that the accumulated impulse is clamped and not the incremental impulse) we change the impulse variable (x_i).                      //                      // Substitute:                      //                       // x = x' - a                      //                       // Plug into above equation:                      //                      // vn = A * x + b                      //    = A * (x' - a) + b                      //    = A * x' + b - A * a                      //    = A * x' + b'                      // b' = b - A * a;                        ContactConstraintPoint cp1 = c.Points[0];                      ContactConstraintPoint cp2 = c.Points[1];                        float ax = cp1.NormalImpulse;                      float ay = cp2.NormalImpulse;                      Debug.Assert(ax >= 0.0f && ay >= 0.0f);                        // Relative velocity at contact                      // Compute normal velocity                      float vn1 = (c.BodyB.LinearVelocityInternal.X + (-wB * cp1.rB.Y) - c.BodyA.LinearVelocityInternal.X -                                   (-wA * cp1.rA.Y)) * c.Normal.X +                                  (c.BodyB.LinearVelocityInternal.Y + (wB * cp1.rB.X) - c.BodyA.LinearVelocityInternal.Y -                                   (wA * cp1.rA.X)) * c.Normal.Y;                      float vn2 = (c.BodyB.LinearVelocityInternal.X + (-wB * cp2.rB.Y) - c.BodyA.LinearVelocityInternal.X -                                   (-wA * cp2.rA.Y)) * c.Normal.X +                                  (c.BodyB.LinearVelocityInternal.Y + (wB * cp2.rB.X) - c.BodyA.LinearVelocityInternal.Y -                                   (wA * cp2.rA.X)) * c.Normal.Y;                        float bx = vn1 - cp1.VelocityBias - (c.K.Col1.X * ax + c.K.Col2.X * ay);                      float by = vn2 - cp2.VelocityBias - (c.K.Col1.Y * ax + c.K.Col2.Y * ay);                        float xx = -(c.NormalMass.Col1.X * bx + c.NormalMass.Col2.X * by);                      float xy = -(c.NormalMass.Col1.Y * bx + c.NormalMass.Col2.Y * by);                        while (true)                      {                          //                          // Case 1: vn = 0                          //                          // 0 = A * x' + b'                          //                          // Solve for x':                          //                          // x' = - inv(A) * b'                          //                          if (xx >= 0.0f && xy >= 0.0f)                          {                              // Resubstitute for the incremental impulse                              float dx = xx - ax;                              float dy = xy - ay;                                // Apply incremental impulse                              float p1x = dx * c.Normal.X;                              float p1y = dx * c.Normal.Y;                                float p2x = dy * c.Normal.X;                              float p2y = dy * c.Normal.Y;                                float p12x = p1x + p2x;                              float p12y = p1y + p2y;                                c.BodyA.LinearVelocityInternal.X -= c.BodyA.InvMass * p12x;                              c.BodyA.LinearVelocityInternal.Y -= c.BodyA.InvMass * p12y;                              wA -= c.BodyA.InvI * ((cp1.rA.X * p1y - cp1.rA.Y * p1x) + (cp2.rA.X * p2y - cp2.rA.Y * p2x));                                c.BodyB.LinearVelocityInternal.X += c.BodyB.InvMass * p12x;                              c.BodyB.LinearVelocityInternal.Y += c.BodyB.InvMass * p12y;                              wB += c.BodyB.InvI * ((cp1.rB.X * p1y - cp1.rB.Y * p1x) + (cp2.rB.X * p2y - cp2.rB.Y * p2x));                                // Accumulate                              cp1.NormalImpulse = xx;                              cp2.NormalImpulse = xy;    #if B2_DEBUG_SOLVER                                 			                float k_errorTol = 1e-3f;    					        // Postconditions  					        dv1 = vB + MathUtils.Cross(wB' cp1.rB) - vA - MathUtils.Cross(wA' cp1.rA);  					        dv2 = vB + MathUtils.Cross(wB' cp2.rB) - vA - MathUtils.Cross(wA' cp2.rA);    					        // Compute normal velocity  					        vn1 = Vector2.Dot(dv1' normal);  					        vn2 = Vector2.Dot(dv2' normal);    					        Debug.Assert(MathUtils.Abs(vn1 - cp1.velocityBias) < k_errorTol);  					        Debug.Assert(MathUtils.Abs(vn2 - cp2.velocityBias) < k_errorTol);  #endif                              break;                          }                            //                          // Case 2: vn1 = 0 and x2 = 0                          //                          //   0 = a11 * x1' + a12 * 0 + b1'                           // vn2 = a21 * x1' + a22 * 0 + b2'                          //                          xx = -cp1.NormalMass * bx;                          xy = 0.0f;                          vn1 = 0.0f;                          vn2 = c.K.Col1.Y * xx + by;                            if (xx >= 0.0f && vn2 >= 0.0f)                          {                              // Resubstitute for the incremental impulse                              float dx = xx - ax;                              float dy = xy - ay;                                // Apply incremental impulse                              float p1x = dx * c.Normal.X;                              float p1y = dx * c.Normal.Y;                                float p2x = dy * c.Normal.X;                              float p2y = dy * c.Normal.Y;                                float p12x = p1x + p2x;                              float p12y = p1y + p2y;                                c.BodyA.LinearVelocityInternal.X -= c.BodyA.InvMass * p12x;                              c.BodyA.LinearVelocityInternal.Y -= c.BodyA.InvMass * p12y;                              wA -= c.BodyA.InvI * ((cp1.rA.X * p1y - cp1.rA.Y * p1x) + (cp2.rA.X * p2y - cp2.rA.Y * p2x));                                c.BodyB.LinearVelocityInternal.X += c.BodyB.InvMass * p12x;                              c.BodyB.LinearVelocityInternal.Y += c.BodyB.InvMass * p12y;                              wB += c.BodyB.InvI * ((cp1.rB.X * p1y - cp1.rB.Y * p1x) + (cp2.rB.X * p2y - cp2.rB.Y * p2x));                                // Accumulate                              cp1.NormalImpulse = xx;                              cp2.NormalImpulse = xy;    #if B2_DEBUG_SOLVER       // Postconditions  					        dv1 = vB + MathUtils.Cross(wB' cp1.rB) - vA - MathUtils.Cross(wA' cp1.rA);    					        // Compute normal velocity  					        vn1 = Vector2.Dot(dv1' normal);    					        Debug.Assert(MathUtils.Abs(vn1 - cp1.velocityBias) < k_errorTol);  #endif                              break;                          }                              //                          // Case 3: vn2 = 0 and x1 = 0                          //                          // vn1 = a11 * 0 + a12 * x2' + b1'                           //   0 = a21 * 0 + a22 * x2' + b2'                          //                          xx = 0.0f;                          xy = -cp2.NormalMass * by;                          vn1 = c.K.Col2.X * xy + bx;                          vn2 = 0.0f;                            if (xy >= 0.0f && vn1 >= 0.0f)                          {                              // Resubstitute for the incremental impulse                              float dx = xx - ax;                              float dy = xy - ay;                                // Apply incremental impulse                              float p1x = dx * c.Normal.X;                              float p1y = dx * c.Normal.Y;                                float p2x = dy * c.Normal.X;                              float p2y = dy * c.Normal.Y;                                float p12x = p1x + p2x;                              float p12y = p1y + p2y;                                c.BodyA.LinearVelocityInternal.X -= c.BodyA.InvMass * p12x;                              c.BodyA.LinearVelocityInternal.Y -= c.BodyA.InvMass * p12y;                              wA -= c.BodyA.InvI * ((cp1.rA.X * p1y - cp1.rA.Y * p1x) + (cp2.rA.X * p2y - cp2.rA.Y * p2x));                                c.BodyB.LinearVelocityInternal.X += c.BodyB.InvMass * p12x;                              c.BodyB.LinearVelocityInternal.Y += c.BodyB.InvMass * p12y;                              wB += c.BodyB.InvI * ((cp1.rB.X * p1y - cp1.rB.Y * p1x) + (cp2.rB.X * p2y - cp2.rB.Y * p2x));                                // Accumulate                              cp1.NormalImpulse = xx;                              cp2.NormalImpulse = xy;    #if B2_DEBUG_SOLVER       // Postconditions  					        dv2 = vB + MathUtils.Cross(wB' cp2.rB) - vA - MathUtils.Cross(wA' cp2.rA);    					        // Compute normal velocity  					        vn2 = Vector2.Dot(dv2' normal);    					        Debug.Assert(MathUtils.Abs(vn2 - cp2.velocityBias) < k_errorTol);  #endif                              break;                          }                            //                          // Case 4: x1 = 0 and x2 = 0                          //                           // vn1 = b1                          // vn2 = b2;                          xx = 0.0f;                          xy = 0.0f;                          vn1 = bx;                          vn2 = by;                            if (vn1 >= 0.0f && vn2 >= 0.0f)                          {                              // Resubstitute for the incremental impulse                              float dx = xx - ax;                              float dy = xy - ay;                                // Apply incremental impulse                              float p1x = dx * c.Normal.X;                              float p1y = dx * c.Normal.Y;                                float p2x = dy * c.Normal.X;                              float p2y = dy * c.Normal.Y;                                float p12x = p1x + p2x;                              float p12y = p1y + p2y;                                c.BodyA.LinearVelocityInternal.X -= c.BodyA.InvMass * p12x;                              c.BodyA.LinearVelocityInternal.Y -= c.BodyA.InvMass * p12y;                              wA -= c.BodyA.InvI * ((cp1.rA.X * p1y - cp1.rA.Y * p1x) + (cp2.rA.X * p2y - cp2.rA.Y * p2x));                                c.BodyB.LinearVelocityInternal.X += c.BodyB.InvMass * p12x;                              c.BodyB.LinearVelocityInternal.Y += c.BodyB.InvMass * p12y;                              wB += c.BodyB.InvI * ((cp1.rB.X * p1y - cp1.rB.Y * p1x) + (cp2.rB.X * p2y - cp2.rB.Y * p2x));                                // Accumulate                              cp1.NormalImpulse = xx;                              cp2.NormalImpulse = xy;                                break;                          }                            // No solution' give up. This is hit sometimes' but it doesn't seem to matter.                          break;                      }                  }                    c.BodyA.AngularVelocityInternal = wA;                  c.BodyB.AngularVelocityInternal = wB;              }
Magic Number,FarseerPhysics.Dynamics.Joints,FixedFrictionJoint,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\Joints\FixedFrictionJoint.cs,FixedFrictionJoint,The following statement contains a magic number: float radius = (float)Math.Sqrt(2.0 * (body.Inertia / body.Mass));
Duplicate Code,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\Contacts\ContactSolver.cs,SolveVelocityConstraints,The method contains a code clone-set at the following line numbers (starting from the method definition): ((143' 170)' (200' 227)' (252' 279))
Duplicate Code,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\Contacts\ContactSolver.cs,SolveVelocityConstraints,The method contains a code clone-set at the following line numbers (starting from the method definition): ((143' 169)' (302' 328)' (200' 226)' (252' 278))
Duplicate Code,FarseerPhysics.Dynamics.Contacts,ContactSolver,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\Contacts\ContactSolver.cs,SolveVelocityConstraints,The method contains a code clone-set at the following line numbers (starting from the method definition): ((200' 228)' (252' 280))
Missing Default,FarseerPhysics.Collision.Shapes,PolygonShape,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Collision\Shapes\PolygonShape.cs,ComputeSubmergedArea,The following switch statement is missing a default case: switch (diveCount)              {                  case 0:                      if (lastSubmerged)                      {                          //Completely submerged                          sc = MathUtils.Multiply(ref xf' MassData.Centroid);                          return MassData.Mass / Density;                      }                      else                      {                          //Completely dry                          return 0;                      }                      break;                  case 1:                      if (intoIndex == -1)                      {                          intoIndex = Vertices.Count - 1;                      }                      else                      {                          outoIndex = Vertices.Count - 1;                      }                      break;              }
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower())                                          {                                              case "vertices":                                                  {                                                      List<Vector2> verts = new List<Vector2>();                                                        foreach (XMLFragmentElement vert in sn.Elements)                                                          verts.Add(ReadVector(vert));                                                        shape.Set(new Vertices(verts.ToArray()));                                                  }                                                  break;                                              case "centroid":                                                  shape.MassData.Centroid = ReadVector(sn);                                                  break;                                          }
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower())                              {                                  case "shape":                                      fixture.Shape = _shapes[int.Parse(sn.Value)];                                      break;                                  case "density":                                      fixture.Shape.Density = float.Parse(sn.Value);                                      break;                                  case "filterdata":                                      foreach (XMLFragmentElement ssn in sn.Elements)                                      {                                          switch (ssn.Name.ToLower())                                          {                                              case "categorybits":                                                  fixture._collisionCategories = (Category)int.Parse(ssn.Value);                                                  break;                                              case "maskbits":                                                  fixture._collidesWith = (Category)int.Parse(ssn.Value);                                                  break;                                              case "groupindex":                                                  fixture._collisionGroup = short.Parse(ssn.Value);                                                  break;                                          }                                      }                                        break;                                  case "friction":                                      fixture.Friction = float.Parse(sn.Value);                                      break;                                  case "issensor":                                      fixture.IsSensor = bool.Parse(sn.Value);                                      break;                                  case "restitution":                                      fixture.Restitution = float.Parse(sn.Value);                                      break;                                  case "userdata":                                      fixture.UserData = ReadSimpleType(sn' null' false);                                      break;                              }
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (ssn.Name.ToLower())                                          {                                              case "categorybits":                                                  fixture._collisionCategories = (Category)int.Parse(ssn.Value);                                                  break;                                              case "maskbits":                                                  fixture._collidesWith = (Category)int.Parse(ssn.Value);                                                  break;                                              case "groupindex":                                                  fixture._collisionGroup = short.Parse(ssn.Value);                                                  break;                                          }
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower())                              {                                  case "active":                                      if (bool.Parse(sn.Value))                                          body.Flags |= BodyFlags.Enabled;                                      else                                          body.Flags &= ~BodyFlags.Enabled;                                      break;                                  case "allowsleep":                                      body.SleepingAllowed = bool.Parse(sn.Value);                                      break;                                  case "angle":                                      {                                          Vector2 position = body.Position;                                          body.SetTransformIgnoreContacts(ref position' float.Parse(sn.Value));                                      }                                      break;                                  case "angulardamping":                                      body.AngularDamping = float.Parse(sn.Value);                                      break;                                  case "angularvelocity":                                      body.AngularVelocity = float.Parse(sn.Value);                                      break;                                  case "awake":                                      body.Awake = bool.Parse(sn.Value);                                      break;                                  case "bullet":                                      body.IsBullet = bool.Parse(sn.Value);                                      break;                                  case "fixedrotation":                                      body.FixedRotation = bool.Parse(sn.Value);                                      break;                                  case "lineardamping":                                      body.LinearDamping = float.Parse(sn.Value);                                      break;                                  case "linearvelocity":                                      body.LinearVelocity = ReadVector(sn);                                      break;                                  case "position":                                      {                                          float rotation = body.Rotation;                                          Vector2 position = ReadVector(sn);                                          body.SetTransformIgnoreContacts(ref position' rotation);                                      }                                      break;                                  case "userdata":                                      body.UserData = ReadSimpleType(sn' null' false);                                      break;                                  case "fixtures":                                      {                                          foreach (XMLFragmentElement v in sn.Elements)                                          {                                              Fixture blueprint = _fixtures[int.Parse(v.Value)];                                              Fixture f = new Fixture(body' blueprint.Shape);                                              f.Restitution = blueprint.Restitution;                                              f.UserData = blueprint.UserData;                                              f.Friction = blueprint.Friction;                                              f.CollidesWith = blueprint.CollidesWith;                                              f.CollisionCategories = blueprint.CollisionCategories;                                              f.CollisionGroup = blueprint.CollisionGroup;                                          }                                          break;                                      }                              }
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower())                              {                                  case "bodya":                                      bodyAIndex = int.Parse(sn.Value);                                      break;                                  case "bodyb":                                      bodyBIndex = int.Parse(sn.Value);                                      break;                                  case "collideconnected":                                      collideConnected = bool.Parse(sn.Value);                                      break;                                  case "userdata":                                      userData = ReadSimpleType(sn' null' false);                                      break;                              }
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (type)                              {                                  case JointType.Distance:                                      {                                          switch (sn.Name.ToLower())                                          {                                              case "dampingratio":                                                  ((DistanceJoint)joint).DampingRatio = float.Parse(sn.Value);                                                  break;                                              case "frequencyhz":                                                  ((DistanceJoint)joint).Frequency = float.Parse(sn.Value);                                                  break;                                              case "length":                                                  ((DistanceJoint)joint).Length = float.Parse(sn.Value);                                                  break;                                              case "localanchora":                                                  ((DistanceJoint)joint).LocalAnchorA = ReadVector(sn);                                                  break;                                              case "localanchorb":                                                  ((DistanceJoint)joint).LocalAnchorB = ReadVector(sn);                                                  break;                                          }                                      }                                      break;                                  case JointType.Friction:                                      {                                          switch (sn.Name.ToLower())                                          {                                              case "localanchora":                                                  ((FrictionJoint)joint).LocalAnchorA = ReadVector(sn);                                                  break;                                              case "localanchorb":                                                  ((FrictionJoint)joint).LocalAnchorB = ReadVector(sn);                                                  break;                                              case "maxforce":                                                  ((FrictionJoint)joint).MaxForce = float.Parse(sn.Value);                                                  break;                                              case "maxtorque":                                                  ((FrictionJoint)joint).MaxTorque = float.Parse(sn.Value);                                                  break;                                          }                                      }                                      break;                                  case JointType.Line:                                      {                                          switch (sn.Name.ToLower())                                          {                                              case "enablemotor":                                                  ((LineJoint)joint).MotorEnabled = bool.Parse(sn.Value);                                                  break;                                              case "localanchora":                                                  ((LineJoint)joint).LocalAnchorA = ReadVector(sn);                                                  break;                                              case "localanchorb":                                                  ((LineJoint)joint).LocalAnchorB = ReadVector(sn);                                                  break;                                              case "motorspeed":                                                  ((LineJoint)joint).MotorSpeed = float.Parse(sn.Value);                                                  break;                                              case "dampingratio":                                                  ((LineJoint)joint).DampingRatio = float.Parse(sn.Value);                                                  break;                                              case "maxmotortorque":                                                  ((LineJoint)joint).MaxMotorTorque = float.Parse(sn.Value);                                                  break;                                              case "frequencyhz":                                                  ((LineJoint)joint).Frequency = float.Parse(sn.Value);                                                  break;                                              case "localxaxis":                                                  ((LineJoint)joint).LocalXAxis = ReadVector(sn);                                                  break;                                          }                                      }                                      break;                                  case JointType.Prismatic:                                      {                                          switch (sn.Name.ToLower())                                          {                                              case "enablelimit":                                                  ((PrismaticJoint)joint).LimitEnabled = bool.Parse(sn.Value);                                                  break;                                              case "enablemotor":                                                  ((PrismaticJoint)joint).MotorEnabled = bool.Parse(sn.Value);                                                  break;                                              case "localanchora":                                                  ((PrismaticJoint)joint).LocalAnchorA = ReadVector(sn);                                                  break;                                              case "localanchorb":                                                  ((PrismaticJoint)joint).LocalAnchorB = ReadVector(sn);                                                  break;                                              case "local1axis1":                                                  ((PrismaticJoint)joint).LocalXAxis1 = ReadVector(sn);                                                  break;                                              case "maxmotorforce":                                                  ((PrismaticJoint)joint).MaxMotorForce = float.Parse(sn.Value);                                                  break;                                              case "motorspeed":                                                  ((PrismaticJoint)joint).MotorSpeed = float.Parse(sn.Value);                                                  break;                                              case "lowertranslation":                                                  ((PrismaticJoint)joint).LowerLimit = float.Parse(sn.Value);                                                  break;                                              case "uppertranslation":                                                  ((PrismaticJoint)joint).UpperLimit = float.Parse(sn.Value);                                                  break;                                              case "referenceangle":                                                  ((PrismaticJoint)joint).ReferenceAngle = float.Parse(sn.Value);                                                  break;                                          }                                      }                                      break;                                  case JointType.Pulley:                                      {                                          switch (sn.Name.ToLower())                                          {                                              case "groundanchora":                                                  ((PulleyJoint)joint).GroundAnchorA = ReadVector(sn);                                                  break;                                              case "groundanchorb":                                                  ((PulleyJoint)joint).GroundAnchorB = ReadVector(sn);                                                  break;                                              case "lengtha":                                                  ((PulleyJoint)joint).LengthA = float.Parse(sn.Value);                                                  break;                                              case "lengthb":                                                  ((PulleyJoint)joint).LengthB = float.Parse(sn.Value);                                                  break;                                              case "localanchora":                                                  ((PulleyJoint)joint).LocalAnchorA = ReadVector(sn);                                                  break;                                              case "localanchorb":                                                  ((PulleyJoint)joint).LocalAnchorB = ReadVector(sn);                                                  break;                                              case "maxlengtha":                                                  ((PulleyJoint)joint).MaxLengthA = float.Parse(sn.Value);                                                  break;                                              case "maxlengthb":                                                  ((PulleyJoint)joint).MaxLengthB = float.Parse(sn.Value);                                                  break;                                              case "ratio":                                                  ((PulleyJoint)joint).Ratio = float.Parse(sn.Value);                                                  break;                                          }                                      }                                      break;                                  case JointType.Revolute:                                      {                                          switch (sn.Name.ToLower())                                          {                                              case "enablelimit":                                                  ((RevoluteJoint)joint).LimitEnabled = bool.Parse(sn.Value);                                                  break;                                              case "enablemotor":                                                  ((RevoluteJoint)joint).MotorEnabled = bool.Parse(sn.Value);                                                  break;                                              case "localanchora":                                                  ((RevoluteJoint)joint).LocalAnchorA = ReadVector(sn);                                                  break;                                              case "localanchorb":                                                  ((RevoluteJoint)joint).LocalAnchorB = ReadVector(sn);                                                  break;                                              case "maxmotortorque":                                                  ((RevoluteJoint)joint).MaxMotorTorque = float.Parse(sn.Value);                                                  break;                                              case "motorspeed":                                                  ((RevoluteJoint)joint).MotorSpeed = float.Parse(sn.Value);                                                  break;                                              case "lowerangle":                                                  ((RevoluteJoint)joint).LowerLimit = float.Parse(sn.Value);                                                  break;                                              case "upperangle":                                                  ((RevoluteJoint)joint).UpperLimit = float.Parse(sn.Value);                                                  break;                                              case "referenceangle":                                                  ((RevoluteJoint)joint).ReferenceAngle = float.Parse(sn.Value);                                                  break;                                          }                                      }                                      break;                                  case JointType.Weld:                                      {                                          switch (sn.Name.ToLower())                                          {                                              case "localanchora":                                                  ((WeldJoint)joint).LocalAnchorA = ReadVector(sn);                                                  break;                                              case "localanchorb":                                                  ((WeldJoint)joint).LocalAnchorB = ReadVector(sn);                                                  break;                                          }                                      }                                      break;                                  case JointType.Rope:                                      {                                          switch (sn.Name.ToLower())                                          {                                              case "localanchora":                                                  ((RopeJoint)joint).LocalAnchorA = ReadVector(sn);                                                  break;                                              case "localanchorb":                                                  ((RopeJoint)joint).LocalAnchorB = ReadVector(sn);                                                  break;                                              case "maxlength":                                                  ((RopeJoint)joint).MaxLength = float.Parse(sn.Value);                                                  break;                                          }                                      }                                      break;                                  case JointType.Gear:                                      throw new Exception("Gear joint is unsupported");                                  case JointType.Angle:                                      {                                          switch (sn.Name.ToLower())                                          {                                              case "biasfactor":                                                  ((AngleJoint)joint).BiasFactor = float.Parse(sn.Value);                                                  break;                                              case "maximpulse":                                                  ((AngleJoint)joint).MaxImpulse = float.Parse(sn.Value);                                                  break;                                              case "softness":                                                  ((AngleJoint)joint).Softness = float.Parse(sn.Value);                                                  break;                                              case "targetangle":                                                  ((AngleJoint)joint).TargetAngle = float.Parse(sn.Value);                                                  break;                                          }                                      }                                      break;                                  case JointType.Slider:                                      {                                          switch (sn.Name.ToLower())                                          {                                              case "dampingratio":                                                  ((SliderJoint)joint).DampingRatio = float.Parse(sn.Value);                                                  break;                                              case "frequencyhz":                                                  ((SliderJoint)joint).Frequency = float.Parse(sn.Value);                                                  break;                                              case "maxlength":                                                  ((SliderJoint)joint).MaxLength = float.Parse(sn.Value);                                                  break;                                              case "minlength":                                                  ((SliderJoint)joint).MinLength = float.Parse(sn.Value);                                                  break;                                              case "localanchora":                                                  ((SliderJoint)joint).LocalAnchorA = ReadVector(sn);                                                  break;                                              case "localanchorb":                                                  ((SliderJoint)joint).LocalAnchorB = ReadVector(sn);                                                  break;                                          }                                      }                                      break;                              }
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower())                                          {                                              case "dampingratio":                                                  ((DistanceJoint)joint).DampingRatio = float.Parse(sn.Value);                                                  break;                                              case "frequencyhz":                                                  ((DistanceJoint)joint).Frequency = float.Parse(sn.Value);                                                  break;                                              case "length":                                                  ((DistanceJoint)joint).Length = float.Parse(sn.Value);                                                  break;                                              case "localanchora":                                                  ((DistanceJoint)joint).LocalAnchorA = ReadVector(sn);                                                  break;                                              case "localanchorb":                                                  ((DistanceJoint)joint).LocalAnchorB = ReadVector(sn);                                                  break;                                          }
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower())                                          {                                              case "localanchora":                                                  ((FrictionJoint)joint).LocalAnchorA = ReadVector(sn);                                                  break;                                              case "localanchorb":                                                  ((FrictionJoint)joint).LocalAnchorB = ReadVector(sn);                                                  break;                                              case "maxforce":                                                  ((FrictionJoint)joint).MaxForce = float.Parse(sn.Value);                                                  break;                                              case "maxtorque":                                                  ((FrictionJoint)joint).MaxTorque = float.Parse(sn.Value);                                                  break;                                          }
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower())                                          {                                              case "enablemotor":                                                  ((LineJoint)joint).MotorEnabled = bool.Parse(sn.Value);                                                  break;                                              case "localanchora":                                                  ((LineJoint)joint).LocalAnchorA = ReadVector(sn);                                                  break;                                              case "localanchorb":                                                  ((LineJoint)joint).LocalAnchorB = ReadVector(sn);                                                  break;                                              case "motorspeed":                                                  ((LineJoint)joint).MotorSpeed = float.Parse(sn.Value);                                                  break;                                              case "dampingratio":                                                  ((LineJoint)joint).DampingRatio = float.Parse(sn.Value);                                                  break;                                              case "maxmotortorque":                                                  ((LineJoint)joint).MaxMotorTorque = float.Parse(sn.Value);                                                  break;                                              case "frequencyhz":                                                  ((LineJoint)joint).Frequency = float.Parse(sn.Value);                                                  break;                                              case "localxaxis":                                                  ((LineJoint)joint).LocalXAxis = ReadVector(sn);                                                  break;                                          }
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower())                                          {                                              case "enablelimit":                                                  ((PrismaticJoint)joint).LimitEnabled = bool.Parse(sn.Value);                                                  break;                                              case "enablemotor":                                                  ((PrismaticJoint)joint).MotorEnabled = bool.Parse(sn.Value);                                                  break;                                              case "localanchora":                                                  ((PrismaticJoint)joint).LocalAnchorA = ReadVector(sn);                                                  break;                                              case "localanchorb":                                                  ((PrismaticJoint)joint).LocalAnchorB = ReadVector(sn);                                                  break;                                              case "local1axis1":                                                  ((PrismaticJoint)joint).LocalXAxis1 = ReadVector(sn);                                                  break;                                              case "maxmotorforce":                                                  ((PrismaticJoint)joint).MaxMotorForce = float.Parse(sn.Value);                                                  break;                                              case "motorspeed":                                                  ((PrismaticJoint)joint).MotorSpeed = float.Parse(sn.Value);                                                  break;                                              case "lowertranslation":                                                  ((PrismaticJoint)joint).LowerLimit = float.Parse(sn.Value);                                                  break;                                              case "uppertranslation":                                                  ((PrismaticJoint)joint).UpperLimit = float.Parse(sn.Value);                                                  break;                                              case "referenceangle":                                                  ((PrismaticJoint)joint).ReferenceAngle = float.Parse(sn.Value);                                                  break;                                          }
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower())                                          {                                              case "groundanchora":                                                  ((PulleyJoint)joint).GroundAnchorA = ReadVector(sn);                                                  break;                                              case "groundanchorb":                                                  ((PulleyJoint)joint).GroundAnchorB = ReadVector(sn);                                                  break;                                              case "lengtha":                                                  ((PulleyJoint)joint).LengthA = float.Parse(sn.Value);                                                  break;                                              case "lengthb":                                                  ((PulleyJoint)joint).LengthB = float.Parse(sn.Value);                                                  break;                                              case "localanchora":                                                  ((PulleyJoint)joint).LocalAnchorA = ReadVector(sn);                                                  break;                                              case "localanchorb":                                                  ((PulleyJoint)joint).LocalAnchorB = ReadVector(sn);                                                  break;                                              case "maxlengtha":                                                  ((PulleyJoint)joint).MaxLengthA = float.Parse(sn.Value);                                                  break;                                              case "maxlengthb":                                                  ((PulleyJoint)joint).MaxLengthB = float.Parse(sn.Value);                                                  break;                                              case "ratio":                                                  ((PulleyJoint)joint).Ratio = float.Parse(sn.Value);                                                  break;                                          }
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower())                                          {                                              case "enablelimit":                                                  ((RevoluteJoint)joint).LimitEnabled = bool.Parse(sn.Value);                                                  break;                                              case "enablemotor":                                                  ((RevoluteJoint)joint).MotorEnabled = bool.Parse(sn.Value);                                                  break;                                              case "localanchora":                                                  ((RevoluteJoint)joint).LocalAnchorA = ReadVector(sn);                                                  break;                                              case "localanchorb":                                                  ((RevoluteJoint)joint).LocalAnchorB = ReadVector(sn);                                                  break;                                              case "maxmotortorque":                                                  ((RevoluteJoint)joint).MaxMotorTorque = float.Parse(sn.Value);                                                  break;                                              case "motorspeed":                                                  ((RevoluteJoint)joint).MotorSpeed = float.Parse(sn.Value);                                                  break;                                              case "lowerangle":                                                  ((RevoluteJoint)joint).LowerLimit = float.Parse(sn.Value);                                                  break;                                              case "upperangle":                                                  ((RevoluteJoint)joint).UpperLimit = float.Parse(sn.Value);                                                  break;                                              case "referenceangle":                                                  ((RevoluteJoint)joint).ReferenceAngle = float.Parse(sn.Value);                                                  break;                                          }
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower())                                          {                                              case "localanchora":                                                  ((WeldJoint)joint).LocalAnchorA = ReadVector(sn);                                                  break;                                              case "localanchorb":                                                  ((WeldJoint)joint).LocalAnchorB = ReadVector(sn);                                                  break;                                          }
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower())                                          {                                              case "localanchora":                                                  ((RopeJoint)joint).LocalAnchorA = ReadVector(sn);                                                  break;                                              case "localanchorb":                                                  ((RopeJoint)joint).LocalAnchorB = ReadVector(sn);                                                  break;                                              case "maxlength":                                                  ((RopeJoint)joint).MaxLength = float.Parse(sn.Value);                                                  break;                                          }
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower())                                          {                                              case "biasfactor":                                                  ((AngleJoint)joint).BiasFactor = float.Parse(sn.Value);                                                  break;                                              case "maximpulse":                                                  ((AngleJoint)joint).MaxImpulse = float.Parse(sn.Value);                                                  break;                                              case "softness":                                                  ((AngleJoint)joint).Softness = float.Parse(sn.Value);                                                  break;                                              case "targetangle":                                                  ((AngleJoint)joint).TargetAngle = float.Parse(sn.Value);                                                  break;                                          }
Missing Default,FarseerPhysics.Common,WorldXmlDeserializer,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\Serialization.cs,Deserialize,The following switch statement is missing a default case: switch (sn.Name.ToLower())                                          {                                              case "dampingratio":                                                  ((SliderJoint)joint).DampingRatio = float.Parse(sn.Value);                                                  break;                                              case "frequencyhz":                                                  ((SliderJoint)joint).Frequency = float.Parse(sn.Value);                                                  break;                                              case "maxlength":                                                  ((SliderJoint)joint).MaxLength = float.Parse(sn.Value);                                                  break;                                              case "minlength":                                                  ((SliderJoint)joint).MinLength = float.Parse(sn.Value);                                                  break;                                              case "localanchora":                                                  ((SliderJoint)joint).LocalAnchorA = ReadVector(sn);                                                  break;                                              case "localanchorb":                                                  ((SliderJoint)joint).LocalAnchorB = ReadVector(sn);                                                  break;                                          }
Missing Default,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,DetectVertices,The following switch statement is missing a default case: switch (_polygonDetectionType)                                          {                                              case VerticesDetectionType.Integrated:                                                    // Add first hole polygon vertex to close the hole polygon.                                                  holePolygon.Add(holePolygon[0]);                                                    int vertex1Index' vertex2Index;                                                  if (SplitPolygonEdge(polygon' holeEntrance.Value' out vertex1Index' out vertex2Index))                                                      polygon.InsertRange(vertex2Index' holePolygon);                                                    break;                                                case VerticesDetectionType.Separated:                                                  if (polygon.Holes == null)                                                      polygon.Holes = new List<Vertices>();                                                    polygon.Holes.Add(holePolygon);                                                  break;                                          }
Missing Default,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following switch statement is missing a default case: switch ((int)(current.X - last.X))              {                  case 1:                      switch ((int)(current.Y - last.Y))                      {                          case 1:                              return 1;                            case 0:                              return 0;                            case -1:                              return 7;                      }                      break;                    case 0:                      switch ((int)(current.Y - last.Y))                      {                          case 1:                              return 2;                            case -1:                              return 6;                      }                      break;                    case -1:                      switch ((int)(current.Y - last.Y))                      {                          case 1:                              return 3;                            case 0:                              return 4;                            case -1:                              return 5;                      }                      break;              }
Missing Default,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following switch statement is missing a default case: switch ((int)(current.Y - last.Y))                      {                          case 1:                              return 1;                            case 0:                              return 0;                            case -1:                              return 7;                      }
Missing Default,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following switch statement is missing a default case: switch ((int)(current.Y - last.Y))                      {                          case 1:                              return 2;                            case -1:                              return 6;                      }
Missing Default,FarseerPhysics.Common,TextureConverter,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Common\TextureTools\TextureConverter.cs,GetIndexOfFirstPixelToCheck,The following switch statement is missing a default case: switch ((int)(current.Y - last.Y))                      {                          case 1:                              return 3;                            case 0:                              return 4;                            case -1:                              return 5;                      }
Missing Default,FarseerPhysics.Controllers,AbstractForceController,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Controllers\AbstractForceController.cs,AbstractForceController,The following switch statement is missing a default case: switch (mode)              {                  case TimingModes.Switched:                      Enabled = true;                      break;                  case TimingModes.Triggered:                      Enabled = false;                      break;                  case TimingModes.Curve:                      Enabled = false;                      break;              }
Missing Default,FarseerPhysics.Controllers,AbstractForceController,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Controllers\AbstractForceController.cs,Update,The following switch statement is missing a default case: switch (TimingMode)              {                  case TimingModes.Switched:                      {                          if (Enabled)                          {                              ApplyForce(dt' Strength);                          }                          break;                      }                  case TimingModes.Triggered:                      {                          if (Enabled && Triggered)                          {                              if (ImpulseTime < ImpulseLength)                              {                                  ApplyForce(dt' Strength);                                  ImpulseTime += dt;                              }                              else                              {                                  Triggered = false;                              }                          }                          break;                      }                  case TimingModes.Curve:                      {                          if (Enabled && Triggered)                          {                              if (ImpulseTime < ImpulseLength)                              {                                  ApplyForce(dt' Strength * StrengthCurve.Evaluate(ImpulseTime));                                  ImpulseTime += dt;                              }                              else                              {                                  Triggered = false;                              }                          }                          break;                      }              }
Missing Default,FarseerPhysics.Controllers,GravityController,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Controllers\GravityController.cs,Update,The following switch statement is missing a default case: switch (GravityType)                      {                          case GravityType.DistanceSquared:                              f = Strength / r2 / (float)Math.Sqrt(r2) * body1.Mass * body2.Mass * d;                              break;                          case GravityType.Linear:                              f = Strength / r2 * body1.Mass * body2.Mass * d;                              break;                      }
Missing Default,FarseerPhysics.Controllers,GravityController,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Controllers\GravityController.cs,Update,The following switch statement is missing a default case: switch (GravityType)                      {                          case GravityType.DistanceSquared:                              f = Strength / r2 / (float)Math.Sqrt(r2) * body1.Mass * d;                              break;                          case GravityType.Linear:                              f = Strength / r2 * body1.Mass * d;                              break;                      }
Missing Default,FarseerPhysics.Dynamics.Contacts,Contact,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\Contacts\Contact.cs,Evaluate,The following switch statement is missing a default case: switch (_type)              {                  case ContactType.Polygon:                      Collision.Collision.CollidePolygons(ref manifold'                                                          (PolygonShape)FixtureA.Shape' ref transformA'                                                          (PolygonShape)FixtureB.Shape' ref transformB);                      break;                  case ContactType.PolygonAndCircle:                      Collision.Collision.CollidePolygonAndCircle(ref manifold'                                                                  (PolygonShape)FixtureA.Shape' ref transformA'                                                                  (CircleShape)FixtureB.Shape' ref transformB);                      break;                  case ContactType.EdgeAndCircle:                      Collision.Collision.CollideEdgeAndCircle(ref manifold'                                                               (EdgeShape)FixtureA.Shape' ref transformA'                                                               (CircleShape)FixtureB.Shape' ref transformB);                      break;                  case ContactType.EdgeAndPolygon:                      Collision.Collision.CollideEdgeAndPolygon(ref manifold'                                                                (EdgeShape)FixtureA.Shape' ref transformA'                                                                (PolygonShape)FixtureB.Shape' ref transformB);                      break;                  case ContactType.LoopAndCircle:                      LoopShape loop = (LoopShape)FixtureA.Shape;                      loop.GetChildEdge(ref _edge' ChildIndexA);                      Collision.Collision.CollideEdgeAndCircle(ref manifold' _edge' ref transformA'                                                               (CircleShape)FixtureB.Shape' ref transformB);                      break;                  case ContactType.LoopAndPolygon:                      LoopShape loop2 = (LoopShape)FixtureA.Shape;                      loop2.GetChildEdge(ref _edge' ChildIndexA);                      Collision.Collision.CollideEdgeAndPolygon(ref manifold' _edge' ref transformA'                                                                (PolygonShape)FixtureB.Shape' ref transformB);                      break;                  case ContactType.Circle:                      Collision.Collision.CollideCircles(ref manifold'                                                         (CircleShape)FixtureA.Shape' ref transformA'                                                         (CircleShape)FixtureB.Shape' ref transformB);                      break;              }
Missing Default,FarseerPhysics.Dynamics.Joints,GearJoint,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\Joints\GearJoint.cs,GearJoint,The following switch statement is missing a default case: switch (type1)              {                  case JointType.Revolute:                      BodyA = jointA.BodyB;                      _revolute1 = (RevoluteJoint)jointA;                      LocalAnchor1 = _revolute1.LocalAnchorB;                      coordinate1 = _revolute1.JointAngle;                      break;                  case JointType.Prismatic:                      BodyA = jointA.BodyB;                      _prismatic1 = (PrismaticJoint)jointA;                      LocalAnchor1 = _prismatic1.LocalAnchorB;                      coordinate1 = _prismatic1.JointTranslation;                      break;                  case JointType.FixedRevolute:                      BodyA = jointA.BodyA;                      _fixedRevolute1 = (FixedRevoluteJoint)jointA;                      LocalAnchor1 = _fixedRevolute1.LocalAnchorA;                      coordinate1 = _fixedRevolute1.JointAngle;                      break;                  case JointType.FixedPrismatic:                      BodyA = jointA.BodyA;                      _fixedPrismatic1 = (FixedPrismaticJoint)jointA;                      LocalAnchor1 = _fixedPrismatic1.LocalAnchorA;                      coordinate1 = _fixedPrismatic1.JointTranslation;                      break;              }
Missing Default,FarseerPhysics.Dynamics.Joints,GearJoint,C:\repos\CartBlanche_MonoGame-Samples\FarseerPhysicsEngine\Dynamics\Joints\GearJoint.cs,GearJoint,The following switch statement is missing a default case: switch (type2)              {                  case JointType.Revolute:                      BodyB = jointB.BodyB;                      _revolute2 = (RevoluteJoint)jointB;                      LocalAnchor2 = _revolute2.LocalAnchorB;                      coordinate2 = _revolute2.JointAngle;                      break;                  case JointType.Prismatic:                      BodyB = jointB.BodyB;                      _prismatic2 = (PrismaticJoint)jointB;                      LocalAnchor2 = _prismatic2.LocalAnchorB;                      coordinate2 = _prismatic2.JointTranslation;                      break;                  case JointType.FixedRevolute:                      BodyB = jointB.BodyA;                      _fixedRevolute2 = (FixedRevoluteJoint)jointB;                      LocalAnchor2 = _fixedRevolute2.LocalAnchorA;                      coordinate2 = _fixedRevolute2.JointAngle;                      break;                  case JointType.FixedPrismatic:                      BodyB = jointB.BodyA;                      _fixedPrismatic2 = (FixedPrismaticJoint)jointB;                      LocalAnchor2 = _fixedPrismatic2.LocalAnchorA;                      coordinate2 = _fixedPrismatic2.JointTranslation;                      break;              }
