Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Flood_Control,Game1,C:\repos\CartBlanche_MonoGame-Samples\BookSourceCode\XNAGameDevelopmentbyExampleCode\FloodControl\Game1.cs,Draw,Cyclomatic complexity of the method is 11
Complex Method,Flood_Control,GameBoard,C:\repos\CartBlanche_MonoGame-Samples\BookSourceCode\XNAGameDevelopmentbyExampleCode\FloodControl\GameBoard.cs,GenerateNewPieces,Cyclomatic complexity of the method is 8
Complex Conditional,Flood_Control,Game1,C:\repos\CartBlanche_MonoGame-Samples\BookSourceCode\XNAGameDevelopmentbyExampleCode\FloodControl\Game1.cs,HandleMouseInput,The conditional expression  "(x >= 0) && (x < GameBoard.GameBoardWidth) &&                (y >= 0) && (y < GameBoard.GameBoardHeight)"  is complex.
Complex Conditional,Flood_Control,GameBoard,C:\repos\CartBlanche_MonoGame-Samples\BookSourceCode\XNAGameDevelopmentbyExampleCode\FloodControl\GameBoard.cs,PropagateWater,The conditional expression  "(y >= 0) && (y < GameBoardHeight) &&                  (x >= 0) && (x < GameBoardWidth)"  is complex.
Magic Number,Flood_Control,Game1,C:\repos\CartBlanche_MonoGame-Samples\BookSourceCode\XNAGameDevelopmentbyExampleCode\FloodControl\Game1.cs,Initialize,The following statement contains a magic number: graphics.PreferredBackBufferWidth = 800;
Magic Number,Flood_Control,Game1,C:\repos\CartBlanche_MonoGame-Samples\BookSourceCode\XNAGameDevelopmentbyExampleCode\FloodControl\Game1.cs,Initialize,The following statement contains a magic number: graphics.PreferredBackBufferHeight = 600;
Magic Number,Flood_Control,Game1,C:\repos\CartBlanche_MonoGame-Samples\BookSourceCode\XNAGameDevelopmentbyExampleCode\FloodControl\Game1.cs,DetermineScore,The following statement contains a magic number: return (int)((Math.Pow((SquareCount / 5)' 2) + SquareCount) * 10);
Magic Number,Flood_Control,Game1,C:\repos\CartBlanche_MonoGame-Samples\BookSourceCode\XNAGameDevelopmentbyExampleCode\FloodControl\Game1.cs,DetermineScore,The following statement contains a magic number: return (int)((Math.Pow((SquareCount / 5)' 2) + SquareCount) * 10);
Magic Number,Flood_Control,Game1,C:\repos\CartBlanche_MonoGame-Samples\BookSourceCode\XNAGameDevelopmentbyExampleCode\FloodControl\Game1.cs,DetermineScore,The following statement contains a magic number: return (int)((Math.Pow((SquareCount / 5)' 2) + SquareCount) * 10);
Magic Number,Flood_Control,Game1,C:\repos\CartBlanche_MonoGame-Samples\BookSourceCode\XNAGameDevelopmentbyExampleCode\FloodControl\Game1.cs,CheckScoringChain,The following statement contains a magic number: if (WaterChain.Count > 0)              {                  Vector2 LastPipe = WaterChain[WaterChain.Count - 1];                    if (LastPipe.X == GameBoard.GameBoardWidth - 1)                  {                      if (gameBoard.HasConnector(                          (int)LastPipe.X' (int)LastPipe.Y' "Right"))                      {                          playerScore += DetermineScore(WaterChain.Count);                            linesCompletedThisLevel++;                            floodCount = MathHelper.Clamp(floodCount -                              (DetermineScore(WaterChain.Count) / 10)' 0.0f' 100.0f);                            ScoreZooms.Enqueue(new ScoreZoom("+" +                              DetermineScore(WaterChain.Count).ToString()'                              new Color(1.0f' 0.0f' 0.0f' 0.4f)));                            foreach (Vector2 ScoringSquare in WaterChain)                          {                              gameBoard.AddFadingPiece(                                  (int)ScoringSquare.X'                                  (int)ScoringSquare.Y'                                  gameBoard.GetSquare(                                    (int)ScoringSquare.X'                                    (int)ScoringSquare.Y));                                gameBoard.SetSquare((int)ScoringSquare.X'                                  (int)ScoringSquare.Y' "Empty");                          }                            if (linesCompletedThisLevel >= 10)                          {                              StartNewLevel();                          }                      }                  }              }
Magic Number,Flood_Control,Game1,C:\repos\CartBlanche_MonoGame-Samples\BookSourceCode\XNAGameDevelopmentbyExampleCode\FloodControl\Game1.cs,CheckScoringChain,The following statement contains a magic number: if (WaterChain.Count > 0)              {                  Vector2 LastPipe = WaterChain[WaterChain.Count - 1];                    if (LastPipe.X == GameBoard.GameBoardWidth - 1)                  {                      if (gameBoard.HasConnector(                          (int)LastPipe.X' (int)LastPipe.Y' "Right"))                      {                          playerScore += DetermineScore(WaterChain.Count);                            linesCompletedThisLevel++;                            floodCount = MathHelper.Clamp(floodCount -                              (DetermineScore(WaterChain.Count) / 10)' 0.0f' 100.0f);                            ScoreZooms.Enqueue(new ScoreZoom("+" +                              DetermineScore(WaterChain.Count).ToString()'                              new Color(1.0f' 0.0f' 0.0f' 0.4f)));                            foreach (Vector2 ScoringSquare in WaterChain)                          {                              gameBoard.AddFadingPiece(                                  (int)ScoringSquare.X'                                  (int)ScoringSquare.Y'                                  gameBoard.GetSquare(                                    (int)ScoringSquare.X'                                    (int)ScoringSquare.Y));                                gameBoard.SetSquare((int)ScoringSquare.X'                                  (int)ScoringSquare.Y' "Empty");                          }                            if (linesCompletedThisLevel >= 10)                          {                              StartNewLevel();                          }                      }                  }              }
Magic Number,Flood_Control,Game1,C:\repos\CartBlanche_MonoGame-Samples\BookSourceCode\XNAGameDevelopmentbyExampleCode\FloodControl\Game1.cs,DrawRotatingPiece,The following statement contains a magic number: spriteBatch.Draw(                playingPieces'                new Rectangle(pixelX + (GamePiece.PieceWidth / 2)'                    pixelY + (GamePiece.PieceHeight / 2)'                    GamePiece.PieceWidth'                    GamePiece.PieceHeight)'                gameBoard.rotatingPieces[positionName].GetSourceRect()'                Color.White'                gameBoard.rotatingPieces[positionName].RotationAmount'                new Vector2(GamePiece.PieceWidth / 2'                    GamePiece.PieceHeight / 2)'                SpriteEffects.None' 0.0f);
Magic Number,Flood_Control,Game1,C:\repos\CartBlanche_MonoGame-Samples\BookSourceCode\XNAGameDevelopmentbyExampleCode\FloodControl\Game1.cs,DrawRotatingPiece,The following statement contains a magic number: spriteBatch.Draw(                playingPieces'                new Rectangle(pixelX + (GamePiece.PieceWidth / 2)'                    pixelY + (GamePiece.PieceHeight / 2)'                    GamePiece.PieceWidth'                    GamePiece.PieceHeight)'                gameBoard.rotatingPieces[positionName].GetSourceRect()'                Color.White'                gameBoard.rotatingPieces[positionName].RotationAmount'                new Vector2(GamePiece.PieceWidth / 2'                    GamePiece.PieceHeight / 2)'                SpriteEffects.None' 0.0f);
Magic Number,Flood_Control,Game1,C:\repos\CartBlanche_MonoGame-Samples\BookSourceCode\XNAGameDevelopmentbyExampleCode\FloodControl\Game1.cs,DrawRotatingPiece,The following statement contains a magic number: spriteBatch.Draw(                playingPieces'                new Rectangle(pixelX + (GamePiece.PieceWidth / 2)'                    pixelY + (GamePiece.PieceHeight / 2)'                    GamePiece.PieceWidth'                    GamePiece.PieceHeight)'                gameBoard.rotatingPieces[positionName].GetSourceRect()'                Color.White'                gameBoard.rotatingPieces[positionName].RotationAmount'                new Vector2(GamePiece.PieceWidth / 2'                    GamePiece.PieceHeight / 2)'                SpriteEffects.None' 0.0f);
Magic Number,Flood_Control,Game1,C:\repos\CartBlanche_MonoGame-Samples\BookSourceCode\XNAGameDevelopmentbyExampleCode\FloodControl\Game1.cs,DrawRotatingPiece,The following statement contains a magic number: spriteBatch.Draw(                playingPieces'                new Rectangle(pixelX + (GamePiece.PieceWidth / 2)'                    pixelY + (GamePiece.PieceHeight / 2)'                    GamePiece.PieceWidth'                    GamePiece.PieceHeight)'                gameBoard.rotatingPieces[positionName].GetSourceRect()'                Color.White'                gameBoard.rotatingPieces[positionName].RotationAmount'                new Vector2(GamePiece.PieceWidth / 2'                    GamePiece.PieceHeight / 2)'                SpriteEffects.None' 0.0f);
Magic Number,Flood_Control,Game1,C:\repos\CartBlanche_MonoGame-Samples\BookSourceCode\XNAGameDevelopmentbyExampleCode\FloodControl\Game1.cs,Draw,The following statement contains a magic number: if ((gameState == GameStates.Playing) ||                  (gameState == GameStates.GameOver))                {                  spriteBatch.Begin();                    spriteBatch.Draw(backgroundScreen'                      new Rectangle(0' 0'                          this.Window.ClientBounds.Width'                          this.Window.ClientBounds.Height)'                      Color.White);                    for (int x = 0; x < GameBoard.GameBoardWidth; x++)                      for (int y = 0; y < GameBoard.GameBoardHeight; y++)                      {                          int pixelX = (int)gameBoardDisplayOrigin.X +                              (x * GamePiece.PieceWidth);                          int pixelY = (int)gameBoardDisplayOrigin.Y +                              (y * GamePiece.PieceHeight);                            DrawEmptyPiece(pixelX' pixelY);                            bool pieceDrawn = false;                            string positionName = x.ToString() + "_" + y.ToString();                            if (gameBoard.rotatingPieces.ContainsKey(positionName))                          {                              DrawRotatingPiece(pixelX' pixelY' positionName);                              pieceDrawn = true;                          }                            if (gameBoard.fadingPieces.ContainsKey(positionName))                          {                              DrawFadingPiece(pixelX' pixelY' positionName);                              pieceDrawn = true;                          }                            if (gameBoard.fallingPieces.ContainsKey(positionName))                          {                              DrawFallingPiece(pixelX' pixelY' positionName);                              pieceDrawn = true;                          }                            if (!pieceDrawn)                          {                              DrawStandardPiece(x' y' pixelX' pixelY);                          }                      }                    foreach (ScoreZoom zoom in ScoreZooms)                  {                      spriteBatch.DrawString(pericles36Font' zoom.Text'                          new Vector2(this.Window.ClientBounds.Width / 2'                              this.Window.ClientBounds.Height / 2)'                          zoom.DrawColor' 0.0f'                          new Vector2(pericles36Font.MeasureString(zoom.Text).X / 2'                              pericles36Font.MeasureString(zoom.Text).Y / 2)'                          zoom.Scale' SpriteEffects.None' 0.0f);                  }                    spriteBatch.DrawString(pericles36Font'                      playerScore.ToString()'                      scorePosition'                      Color.Black);                    spriteBatch.DrawString(pericles36Font'                      currentLevel.ToString()'                      levelTextPosition'                      Color.Black);                    int waterHeight = (int)(MaxWaterHeight * (floodCount / 100));                    spriteBatch.Draw(backgroundScreen'                      new Rectangle(                          (int)waterPosition.X'                          (int)waterPosition.Y + (MaxWaterHeight - waterHeight)'                          WaterWidth'                          waterHeight)'                      new Rectangle(                          (int)waterOverlayStart.X'                          (int)waterOverlayStart.Y + (MaxWaterHeight - waterHeight)'                          WaterWidth'                          waterHeight)'                      new Color(255' 255' 255' 180));                    spriteBatch.End();              }
Magic Number,Flood_Control,Game1,C:\repos\CartBlanche_MonoGame-Samples\BookSourceCode\XNAGameDevelopmentbyExampleCode\FloodControl\Game1.cs,Draw,The following statement contains a magic number: if ((gameState == GameStates.Playing) ||                  (gameState == GameStates.GameOver))                {                  spriteBatch.Begin();                    spriteBatch.Draw(backgroundScreen'                      new Rectangle(0' 0'                          this.Window.ClientBounds.Width'                          this.Window.ClientBounds.Height)'                      Color.White);                    for (int x = 0; x < GameBoard.GameBoardWidth; x++)                      for (int y = 0; y < GameBoard.GameBoardHeight; y++)                      {                          int pixelX = (int)gameBoardDisplayOrigin.X +                              (x * GamePiece.PieceWidth);                          int pixelY = (int)gameBoardDisplayOrigin.Y +                              (y * GamePiece.PieceHeight);                            DrawEmptyPiece(pixelX' pixelY);                            bool pieceDrawn = false;                            string positionName = x.ToString() + "_" + y.ToString();                            if (gameBoard.rotatingPieces.ContainsKey(positionName))                          {                              DrawRotatingPiece(pixelX' pixelY' positionName);                              pieceDrawn = true;                          }                            if (gameBoard.fadingPieces.ContainsKey(positionName))                          {                              DrawFadingPiece(pixelX' pixelY' positionName);                              pieceDrawn = true;                          }                            if (gameBoard.fallingPieces.ContainsKey(positionName))                          {                              DrawFallingPiece(pixelX' pixelY' positionName);                              pieceDrawn = true;                          }                            if (!pieceDrawn)                          {                              DrawStandardPiece(x' y' pixelX' pixelY);                          }                      }                    foreach (ScoreZoom zoom in ScoreZooms)                  {                      spriteBatch.DrawString(pericles36Font' zoom.Text'                          new Vector2(this.Window.ClientBounds.Width / 2'                              this.Window.ClientBounds.Height / 2)'                          zoom.DrawColor' 0.0f'                          new Vector2(pericles36Font.MeasureString(zoom.Text).X / 2'                              pericles36Font.MeasureString(zoom.Text).Y / 2)'                          zoom.Scale' SpriteEffects.None' 0.0f);                  }                    spriteBatch.DrawString(pericles36Font'                      playerScore.ToString()'                      scorePosition'                      Color.Black);                    spriteBatch.DrawString(pericles36Font'                      currentLevel.ToString()'                      levelTextPosition'                      Color.Black);                    int waterHeight = (int)(MaxWaterHeight * (floodCount / 100));                    spriteBatch.Draw(backgroundScreen'                      new Rectangle(                          (int)waterPosition.X'                          (int)waterPosition.Y + (MaxWaterHeight - waterHeight)'                          WaterWidth'                          waterHeight)'                      new Rectangle(                          (int)waterOverlayStart.X'                          (int)waterOverlayStart.Y + (MaxWaterHeight - waterHeight)'                          WaterWidth'                          waterHeight)'                      new Color(255' 255' 255' 180));                    spriteBatch.End();              }
Magic Number,Flood_Control,Game1,C:\repos\CartBlanche_MonoGame-Samples\BookSourceCode\XNAGameDevelopmentbyExampleCode\FloodControl\Game1.cs,Draw,The following statement contains a magic number: if ((gameState == GameStates.Playing) ||                  (gameState == GameStates.GameOver))                {                  spriteBatch.Begin();                    spriteBatch.Draw(backgroundScreen'                      new Rectangle(0' 0'                          this.Window.ClientBounds.Width'                          this.Window.ClientBounds.Height)'                      Color.White);                    for (int x = 0; x < GameBoard.GameBoardWidth; x++)                      for (int y = 0; y < GameBoard.GameBoardHeight; y++)                      {                          int pixelX = (int)gameBoardDisplayOrigin.X +                              (x * GamePiece.PieceWidth);                          int pixelY = (int)gameBoardDisplayOrigin.Y +                              (y * GamePiece.PieceHeight);                            DrawEmptyPiece(pixelX' pixelY);                            bool pieceDrawn = false;                            string positionName = x.ToString() + "_" + y.ToString();                            if (gameBoard.rotatingPieces.ContainsKey(positionName))                          {                              DrawRotatingPiece(pixelX' pixelY' positionName);                              pieceDrawn = true;                          }                            if (gameBoard.fadingPieces.ContainsKey(positionName))                          {                              DrawFadingPiece(pixelX' pixelY' positionName);                              pieceDrawn = true;                          }                            if (gameBoard.fallingPieces.ContainsKey(positionName))                          {                              DrawFallingPiece(pixelX' pixelY' positionName);                              pieceDrawn = true;                          }                            if (!pieceDrawn)                          {                              DrawStandardPiece(x' y' pixelX' pixelY);                          }                      }                    foreach (ScoreZoom zoom in ScoreZooms)                  {                      spriteBatch.DrawString(pericles36Font' zoom.Text'                          new Vector2(this.Window.ClientBounds.Width / 2'                              this.Window.ClientBounds.Height / 2)'                          zoom.DrawColor' 0.0f'                          new Vector2(pericles36Font.MeasureString(zoom.Text).X / 2'                              pericles36Font.MeasureString(zoom.Text).Y / 2)'                          zoom.Scale' SpriteEffects.None' 0.0f);                  }                    spriteBatch.DrawString(pericles36Font'                      playerScore.ToString()'                      scorePosition'                      Color.Black);                    spriteBatch.DrawString(pericles36Font'                      currentLevel.ToString()'                      levelTextPosition'                      Color.Black);                    int waterHeight = (int)(MaxWaterHeight * (floodCount / 100));                    spriteBatch.Draw(backgroundScreen'                      new Rectangle(                          (int)waterPosition.X'                          (int)waterPosition.Y + (MaxWaterHeight - waterHeight)'                          WaterWidth'                          waterHeight)'                      new Rectangle(                          (int)waterOverlayStart.X'                          (int)waterOverlayStart.Y + (MaxWaterHeight - waterHeight)'                          WaterWidth'                          waterHeight)'                      new Color(255' 255' 255' 180));                    spriteBatch.End();              }
Magic Number,Flood_Control,Game1,C:\repos\CartBlanche_MonoGame-Samples\BookSourceCode\XNAGameDevelopmentbyExampleCode\FloodControl\Game1.cs,Draw,The following statement contains a magic number: if ((gameState == GameStates.Playing) ||                  (gameState == GameStates.GameOver))                {                  spriteBatch.Begin();                    spriteBatch.Draw(backgroundScreen'                      new Rectangle(0' 0'                          this.Window.ClientBounds.Width'                          this.Window.ClientBounds.Height)'                      Color.White);                    for (int x = 0; x < GameBoard.GameBoardWidth; x++)                      for (int y = 0; y < GameBoard.GameBoardHeight; y++)                      {                          int pixelX = (int)gameBoardDisplayOrigin.X +                              (x * GamePiece.PieceWidth);                          int pixelY = (int)gameBoardDisplayOrigin.Y +                              (y * GamePiece.PieceHeight);                            DrawEmptyPiece(pixelX' pixelY);                            bool pieceDrawn = false;                            string positionName = x.ToString() + "_" + y.ToString();                            if (gameBoard.rotatingPieces.ContainsKey(positionName))                          {                              DrawRotatingPiece(pixelX' pixelY' positionName);                              pieceDrawn = true;                          }                            if (gameBoard.fadingPieces.ContainsKey(positionName))                          {                              DrawFadingPiece(pixelX' pixelY' positionName);                              pieceDrawn = true;                          }                            if (gameBoard.fallingPieces.ContainsKey(positionName))                          {                              DrawFallingPiece(pixelX' pixelY' positionName);                              pieceDrawn = true;                          }                            if (!pieceDrawn)                          {                              DrawStandardPiece(x' y' pixelX' pixelY);                          }                      }                    foreach (ScoreZoom zoom in ScoreZooms)                  {                      spriteBatch.DrawString(pericles36Font' zoom.Text'                          new Vector2(this.Window.ClientBounds.Width / 2'                              this.Window.ClientBounds.Height / 2)'                          zoom.DrawColor' 0.0f'                          new Vector2(pericles36Font.MeasureString(zoom.Text).X / 2'                              pericles36Font.MeasureString(zoom.Text).Y / 2)'                          zoom.Scale' SpriteEffects.None' 0.0f);                  }                    spriteBatch.DrawString(pericles36Font'                      playerScore.ToString()'                      scorePosition'                      Color.Black);                    spriteBatch.DrawString(pericles36Font'                      currentLevel.ToString()'                      levelTextPosition'                      Color.Black);                    int waterHeight = (int)(MaxWaterHeight * (floodCount / 100));                    spriteBatch.Draw(backgroundScreen'                      new Rectangle(                          (int)waterPosition.X'                          (int)waterPosition.Y + (MaxWaterHeight - waterHeight)'                          WaterWidth'                          waterHeight)'                      new Rectangle(                          (int)waterOverlayStart.X'                          (int)waterOverlayStart.Y + (MaxWaterHeight - waterHeight)'                          WaterWidth'                          waterHeight)'                      new Color(255' 255' 255' 180));                    spriteBatch.End();              }
Magic Number,Flood_Control,Game1,C:\repos\CartBlanche_MonoGame-Samples\BookSourceCode\XNAGameDevelopmentbyExampleCode\FloodControl\Game1.cs,Draw,The following statement contains a magic number: if ((gameState == GameStates.Playing) ||                  (gameState == GameStates.GameOver))                {                  spriteBatch.Begin();                    spriteBatch.Draw(backgroundScreen'                      new Rectangle(0' 0'                          this.Window.ClientBounds.Width'                          this.Window.ClientBounds.Height)'                      Color.White);                    for (int x = 0; x < GameBoard.GameBoardWidth; x++)                      for (int y = 0; y < GameBoard.GameBoardHeight; y++)                      {                          int pixelX = (int)gameBoardDisplayOrigin.X +                              (x * GamePiece.PieceWidth);                          int pixelY = (int)gameBoardDisplayOrigin.Y +                              (y * GamePiece.PieceHeight);                            DrawEmptyPiece(pixelX' pixelY);                            bool pieceDrawn = false;                            string positionName = x.ToString() + "_" + y.ToString();                            if (gameBoard.rotatingPieces.ContainsKey(positionName))                          {                              DrawRotatingPiece(pixelX' pixelY' positionName);                              pieceDrawn = true;                          }                            if (gameBoard.fadingPieces.ContainsKey(positionName))                          {                              DrawFadingPiece(pixelX' pixelY' positionName);                              pieceDrawn = true;                          }                            if (gameBoard.fallingPieces.ContainsKey(positionName))                          {                              DrawFallingPiece(pixelX' pixelY' positionName);                              pieceDrawn = true;                          }                            if (!pieceDrawn)                          {                              DrawStandardPiece(x' y' pixelX' pixelY);                          }                      }                    foreach (ScoreZoom zoom in ScoreZooms)                  {                      spriteBatch.DrawString(pericles36Font' zoom.Text'                          new Vector2(this.Window.ClientBounds.Width / 2'                              this.Window.ClientBounds.Height / 2)'                          zoom.DrawColor' 0.0f'                          new Vector2(pericles36Font.MeasureString(zoom.Text).X / 2'                              pericles36Font.MeasureString(zoom.Text).Y / 2)'                          zoom.Scale' SpriteEffects.None' 0.0f);                  }                    spriteBatch.DrawString(pericles36Font'                      playerScore.ToString()'                      scorePosition'                      Color.Black);                    spriteBatch.DrawString(pericles36Font'                      currentLevel.ToString()'                      levelTextPosition'                      Color.Black);                    int waterHeight = (int)(MaxWaterHeight * (floodCount / 100));                    spriteBatch.Draw(backgroundScreen'                      new Rectangle(                          (int)waterPosition.X'                          (int)waterPosition.Y + (MaxWaterHeight - waterHeight)'                          WaterWidth'                          waterHeight)'                      new Rectangle(                          (int)waterOverlayStart.X'                          (int)waterOverlayStart.Y + (MaxWaterHeight - waterHeight)'                          WaterWidth'                          waterHeight)'                      new Color(255' 255' 255' 180));                    spriteBatch.End();              }
Magic Number,Flood_Control,Game1,C:\repos\CartBlanche_MonoGame-Samples\BookSourceCode\XNAGameDevelopmentbyExampleCode\FloodControl\Game1.cs,Draw,The following statement contains a magic number: if ((gameState == GameStates.Playing) ||                  (gameState == GameStates.GameOver))                {                  spriteBatch.Begin();                    spriteBatch.Draw(backgroundScreen'                      new Rectangle(0' 0'                          this.Window.ClientBounds.Width'                          this.Window.ClientBounds.Height)'                      Color.White);                    for (int x = 0; x < GameBoard.GameBoardWidth; x++)                      for (int y = 0; y < GameBoard.GameBoardHeight; y++)                      {                          int pixelX = (int)gameBoardDisplayOrigin.X +                              (x * GamePiece.PieceWidth);                          int pixelY = (int)gameBoardDisplayOrigin.Y +                              (y * GamePiece.PieceHeight);                            DrawEmptyPiece(pixelX' pixelY);                            bool pieceDrawn = false;                            string positionName = x.ToString() + "_" + y.ToString();                            if (gameBoard.rotatingPieces.ContainsKey(positionName))                          {                              DrawRotatingPiece(pixelX' pixelY' positionName);                              pieceDrawn = true;                          }                            if (gameBoard.fadingPieces.ContainsKey(positionName))                          {                              DrawFadingPiece(pixelX' pixelY' positionName);                              pieceDrawn = true;                          }                            if (gameBoard.fallingPieces.ContainsKey(positionName))                          {                              DrawFallingPiece(pixelX' pixelY' positionName);                              pieceDrawn = true;                          }                            if (!pieceDrawn)                          {                              DrawStandardPiece(x' y' pixelX' pixelY);                          }                      }                    foreach (ScoreZoom zoom in ScoreZooms)                  {                      spriteBatch.DrawString(pericles36Font' zoom.Text'                          new Vector2(this.Window.ClientBounds.Width / 2'                              this.Window.ClientBounds.Height / 2)'                          zoom.DrawColor' 0.0f'                          new Vector2(pericles36Font.MeasureString(zoom.Text).X / 2'                              pericles36Font.MeasureString(zoom.Text).Y / 2)'                          zoom.Scale' SpriteEffects.None' 0.0f);                  }                    spriteBatch.DrawString(pericles36Font'                      playerScore.ToString()'                      scorePosition'                      Color.Black);                    spriteBatch.DrawString(pericles36Font'                      currentLevel.ToString()'                      levelTextPosition'                      Color.Black);                    int waterHeight = (int)(MaxWaterHeight * (floodCount / 100));                    spriteBatch.Draw(backgroundScreen'                      new Rectangle(                          (int)waterPosition.X'                          (int)waterPosition.Y + (MaxWaterHeight - waterHeight)'                          WaterWidth'                          waterHeight)'                      new Rectangle(                          (int)waterOverlayStart.X'                          (int)waterOverlayStart.Y + (MaxWaterHeight - waterHeight)'                          WaterWidth'                          waterHeight)'                      new Color(255' 255' 255' 180));                    spriteBatch.End();              }
Magic Number,Flood_Control,Game1,C:\repos\CartBlanche_MonoGame-Samples\BookSourceCode\XNAGameDevelopmentbyExampleCode\FloodControl\Game1.cs,Draw,The following statement contains a magic number: if ((gameState == GameStates.Playing) ||                  (gameState == GameStates.GameOver))                {                  spriteBatch.Begin();                    spriteBatch.Draw(backgroundScreen'                      new Rectangle(0' 0'                          this.Window.ClientBounds.Width'                          this.Window.ClientBounds.Height)'                      Color.White);                    for (int x = 0; x < GameBoard.GameBoardWidth; x++)                      for (int y = 0; y < GameBoard.GameBoardHeight; y++)                      {                          int pixelX = (int)gameBoardDisplayOrigin.X +                              (x * GamePiece.PieceWidth);                          int pixelY = (int)gameBoardDisplayOrigin.Y +                              (y * GamePiece.PieceHeight);                            DrawEmptyPiece(pixelX' pixelY);                            bool pieceDrawn = false;                            string positionName = x.ToString() + "_" + y.ToString();                            if (gameBoard.rotatingPieces.ContainsKey(positionName))                          {                              DrawRotatingPiece(pixelX' pixelY' positionName);                              pieceDrawn = true;                          }                            if (gameBoard.fadingPieces.ContainsKey(positionName))                          {                              DrawFadingPiece(pixelX' pixelY' positionName);                              pieceDrawn = true;                          }                            if (gameBoard.fallingPieces.ContainsKey(positionName))                          {                              DrawFallingPiece(pixelX' pixelY' positionName);                              pieceDrawn = true;                          }                            if (!pieceDrawn)                          {                              DrawStandardPiece(x' y' pixelX' pixelY);                          }                      }                    foreach (ScoreZoom zoom in ScoreZooms)                  {                      spriteBatch.DrawString(pericles36Font' zoom.Text'                          new Vector2(this.Window.ClientBounds.Width / 2'                              this.Window.ClientBounds.Height / 2)'                          zoom.DrawColor' 0.0f'                          new Vector2(pericles36Font.MeasureString(zoom.Text).X / 2'                              pericles36Font.MeasureString(zoom.Text).Y / 2)'                          zoom.Scale' SpriteEffects.None' 0.0f);                  }                    spriteBatch.DrawString(pericles36Font'                      playerScore.ToString()'                      scorePosition'                      Color.Black);                    spriteBatch.DrawString(pericles36Font'                      currentLevel.ToString()'                      levelTextPosition'                      Color.Black);                    int waterHeight = (int)(MaxWaterHeight * (floodCount / 100));                    spriteBatch.Draw(backgroundScreen'                      new Rectangle(                          (int)waterPosition.X'                          (int)waterPosition.Y + (MaxWaterHeight - waterHeight)'                          WaterWidth'                          waterHeight)'                      new Rectangle(                          (int)waterOverlayStart.X'                          (int)waterOverlayStart.Y + (MaxWaterHeight - waterHeight)'                          WaterWidth'                          waterHeight)'                      new Color(255' 255' 255' 180));                    spriteBatch.End();              }
Magic Number,Flood_Control,Game1,C:\repos\CartBlanche_MonoGame-Samples\BookSourceCode\XNAGameDevelopmentbyExampleCode\FloodControl\Game1.cs,Draw,The following statement contains a magic number: if ((gameState == GameStates.Playing) ||                  (gameState == GameStates.GameOver))                {                  spriteBatch.Begin();                    spriteBatch.Draw(backgroundScreen'                      new Rectangle(0' 0'                          this.Window.ClientBounds.Width'                          this.Window.ClientBounds.Height)'                      Color.White);                    for (int x = 0; x < GameBoard.GameBoardWidth; x++)                      for (int y = 0; y < GameBoard.GameBoardHeight; y++)                      {                          int pixelX = (int)gameBoardDisplayOrigin.X +                              (x * GamePiece.PieceWidth);                          int pixelY = (int)gameBoardDisplayOrigin.Y +                              (y * GamePiece.PieceHeight);                            DrawEmptyPiece(pixelX' pixelY);                            bool pieceDrawn = false;                            string positionName = x.ToString() + "_" + y.ToString();                            if (gameBoard.rotatingPieces.ContainsKey(positionName))                          {                              DrawRotatingPiece(pixelX' pixelY' positionName);                              pieceDrawn = true;                          }                            if (gameBoard.fadingPieces.ContainsKey(positionName))                          {                              DrawFadingPiece(pixelX' pixelY' positionName);                              pieceDrawn = true;                          }                            if (gameBoard.fallingPieces.ContainsKey(positionName))                          {                              DrawFallingPiece(pixelX' pixelY' positionName);                              pieceDrawn = true;                          }                            if (!pieceDrawn)                          {                              DrawStandardPiece(x' y' pixelX' pixelY);                          }                      }                    foreach (ScoreZoom zoom in ScoreZooms)                  {                      spriteBatch.DrawString(pericles36Font' zoom.Text'                          new Vector2(this.Window.ClientBounds.Width / 2'                              this.Window.ClientBounds.Height / 2)'                          zoom.DrawColor' 0.0f'                          new Vector2(pericles36Font.MeasureString(zoom.Text).X / 2'                              pericles36Font.MeasureString(zoom.Text).Y / 2)'                          zoom.Scale' SpriteEffects.None' 0.0f);                  }                    spriteBatch.DrawString(pericles36Font'                      playerScore.ToString()'                      scorePosition'                      Color.Black);                    spriteBatch.DrawString(pericles36Font'                      currentLevel.ToString()'                      levelTextPosition'                      Color.Black);                    int waterHeight = (int)(MaxWaterHeight * (floodCount / 100));                    spriteBatch.Draw(backgroundScreen'                      new Rectangle(                          (int)waterPosition.X'                          (int)waterPosition.Y + (MaxWaterHeight - waterHeight)'                          WaterWidth'                          waterHeight)'                      new Rectangle(                          (int)waterOverlayStart.X'                          (int)waterOverlayStart.Y + (MaxWaterHeight - waterHeight)'                          WaterWidth'                          waterHeight)'                      new Color(255' 255' 255' 180));                    spriteBatch.End();              }
Magic Number,Flood_Control,Game1,C:\repos\CartBlanche_MonoGame-Samples\BookSourceCode\XNAGameDevelopmentbyExampleCode\FloodControl\Game1.cs,Draw,The following statement contains a magic number: if ((gameState == GameStates.Playing) ||                  (gameState == GameStates.GameOver))                {                  spriteBatch.Begin();                    spriteBatch.Draw(backgroundScreen'                      new Rectangle(0' 0'                          this.Window.ClientBounds.Width'                          this.Window.ClientBounds.Height)'                      Color.White);                    for (int x = 0; x < GameBoard.GameBoardWidth; x++)                      for (int y = 0; y < GameBoard.GameBoardHeight; y++)                      {                          int pixelX = (int)gameBoardDisplayOrigin.X +                              (x * GamePiece.PieceWidth);                          int pixelY = (int)gameBoardDisplayOrigin.Y +                              (y * GamePiece.PieceHeight);                            DrawEmptyPiece(pixelX' pixelY);                            bool pieceDrawn = false;                            string positionName = x.ToString() + "_" + y.ToString();                            if (gameBoard.rotatingPieces.ContainsKey(positionName))                          {                              DrawRotatingPiece(pixelX' pixelY' positionName);                              pieceDrawn = true;                          }                            if (gameBoard.fadingPieces.ContainsKey(positionName))                          {                              DrawFadingPiece(pixelX' pixelY' positionName);                              pieceDrawn = true;                          }                            if (gameBoard.fallingPieces.ContainsKey(positionName))                          {                              DrawFallingPiece(pixelX' pixelY' positionName);                              pieceDrawn = true;                          }                            if (!pieceDrawn)                          {                              DrawStandardPiece(x' y' pixelX' pixelY);                          }                      }                    foreach (ScoreZoom zoom in ScoreZooms)                  {                      spriteBatch.DrawString(pericles36Font' zoom.Text'                          new Vector2(this.Window.ClientBounds.Width / 2'                              this.Window.ClientBounds.Height / 2)'                          zoom.DrawColor' 0.0f'                          new Vector2(pericles36Font.MeasureString(zoom.Text).X / 2'                              pericles36Font.MeasureString(zoom.Text).Y / 2)'                          zoom.Scale' SpriteEffects.None' 0.0f);                  }                    spriteBatch.DrawString(pericles36Font'                      playerScore.ToString()'                      scorePosition'                      Color.Black);                    spriteBatch.DrawString(pericles36Font'                      currentLevel.ToString()'                      levelTextPosition'                      Color.Black);                    int waterHeight = (int)(MaxWaterHeight * (floodCount / 100));                    spriteBatch.Draw(backgroundScreen'                      new Rectangle(                          (int)waterPosition.X'                          (int)waterPosition.Y + (MaxWaterHeight - waterHeight)'                          WaterWidth'                          waterHeight)'                      new Rectangle(                          (int)waterOverlayStart.X'                          (int)waterOverlayStart.Y + (MaxWaterHeight - waterHeight)'                          WaterWidth'                          waterHeight)'                      new Color(255' 255' 255' 180));                    spriteBatch.End();              }
Missing Default,Flood_Control,Game1,C:\repos\CartBlanche_MonoGame-Samples\BookSourceCode\XNAGameDevelopmentbyExampleCode\FloodControl\Game1.cs,Update,The following switch statement is missing a default case: switch (gameState)              {                  case GameStates.TitleScreen:                      if (Keyboard.GetState().IsKeyDown(Keys.Space))                      {                          gameBoard.ClearBoard();                          gameBoard.GenerateNewPieces(false);                          playerScore = 0;                          currentLevel = 0;                          floodIncreaseAmount = 0.0f;                          StartNewLevel();                          gameState = GameStates.Playing;                      }                      break;                    case GameStates.Playing:                      timeSinceLastInput +=                          (float)gameTime.ElapsedGameTime.TotalSeconds;                        timeSinceLastFloodIncrease +=                           (float)gameTime.ElapsedGameTime.TotalSeconds;                            if (timeSinceLastFloodIncrease >= timeBetweenFloodIncreases)                          {                              floodCount += floodIncreaseAmount;                              timeSinceLastFloodIncrease = 0.0f;                              if (floodCount >= MaxFloodCounter)                              {                                  gameOverTimer = 8.0f;                                  gameState = GameStates.GameOver;                              }                          }                        if (gameBoard.ArePiecesAnimating())                      {                          gameBoard.UpdateAnimatedPieces();                      }                      else                      {                          gameBoard.ResetWater();                            for (int y = 0; y < GameBoard.GameBoardHeight; y++)                          {                              CheckScoringChain(gameBoard.GetWaterChain(y));                          }                            gameBoard.GenerateNewPieces(true);                            if (timeSinceLastInput >= MinTimeSinceLastInput)                          {                              HandleMouseInput(Mouse.GetState());                          }                      }                      UpdateScoreZooms();                        break;                    case GameStates.GameOver:                      gameOverTimer -= (float)gameTime.ElapsedGameTime.TotalSeconds;                      if (gameOverTimer <= 0)                      {                          gameState = GameStates.TitleScreen;                      }                      break;                }
Missing Default,Flood_Control,GameBoard,C:\repos\CartBlanche_MonoGame-Samples\BookSourceCode\XNAGameDevelopmentbyExampleCode\FloodControl\GameBoard.cs,PropagateWater,The following switch statement is missing a default case: switch (end)                          {                              case "Left": PropagateWater(x - 1' y' "Right");                                  break;                              case "Right": PropagateWater(x + 1' y' "Left");                                  break;                              case "Top": PropagateWater(x' y - 1' "Bottom");                                  break;                              case "Bottom": PropagateWater(x' y + 1' "Top");                                  break;                          }
Missing Default,Flood_Control,GamePiece,C:\repos\CartBlanche_MonoGame-Samples\BookSourceCode\XNAGameDevelopmentbyExampleCode\FloodControl\GamePiece.cs,RotatePiece,The following switch statement is missing a default case: switch (pieceType)              {                  case "Left'Right":                      pieceType = "Top'Bottom";                      break;                  case "Top'Bottom":                      pieceType = "Left'Right";                      break;                  case "Left'Top":                      if (Clockwise)                          pieceType = "Top'Right";                      else                          pieceType = "Bottom'Left";                      break;                  case "Top'Right":                      if (Clockwise)                          pieceType = "Right'Bottom";                      else                          pieceType = "Left'Top";                      break;                  case "Right'Bottom":                      if (Clockwise)                          pieceType = "Bottom'Left";                      else                          pieceType = "Top'Right";                      break;                  case "Bottom'Left":                      if (Clockwise)                          pieceType = "Left'Top";                      else                          pieceType = "Right'Bottom";                      break;                  case "Empty":                      break;              }
