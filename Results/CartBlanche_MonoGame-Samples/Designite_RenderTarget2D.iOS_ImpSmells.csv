Implementation smell,Namespace,Class,File,Method,Description
Long Statement,RenderTarget2DSample,Game1,F:\newReposMay17\CartBlanche_MonoGame-Samples\RenderTarget2DSample\Game1.cs,LoadContent,The length of the statement  "	renderTarget = new RenderTarget2D (GraphicsDevice' GraphicsDevice.PresentationParameters.BackBufferWidth' GraphicsDevice.PresentationParameters.BackBufferHeight' false' SurfaceFormat.Color' DepthFormat.None); " is 208.
Long Statement,RenderTarget2DSample,Game1,F:\newReposMay17\CartBlanche_MonoGame-Samples\RenderTarget2DSample\Game1.cs,Draw,The length of the statement  "		spriteBatch.Draw (logo' new Vector2 ((renderTarget.Width / 2f) - (logo.Width / 2f)' (renderTarget.Height / 2f) - (logo.Height / 2f))' Color.White); " is 147.
Long Statement,RenderTarget2DSample,Game1,F:\newReposMay17\CartBlanche_MonoGame-Samples\RenderTarget2DSample\Game1.cs,Draw,The length of the statement  "	spriteBatch.Draw (renderTarget' new Vector2 (GraphicsDevice.PresentationParameters.BackBufferWidth / 2' GraphicsDevice.PresentationParameters.BackBufferHeight / 2)' null' Color.White' 0f' new Vector2 (renderTarget.Width / 2' renderTarget.Height / 2)' scale' SpriteEffects.None' 0f); " is 282.
Long Statement,RenderTarget2DSample,Game1,F:\newReposMay17\CartBlanche_MonoGame-Samples\RenderTarget2DSample\Game1.cs,GrabScreenshot,The length of the statement  "	//OpenTK.Graphics.ES11.GL.ReadPixels(0' 0' rendertarget.Width' rendertarget.Height' OpenTK.Graphics.ES11.All.Rgb' OpenTK.Graphics.ES11.All.UnsignedByte' ref data);             " is 163.
Empty Catch Block,RenderTarget2DSample,Game1,F:\newReposMay17\CartBlanche_MonoGame-Samples\RenderTarget2DSample\Game1.cs,UnloadContent,The method has an empty catch block.
Magic Number,RenderTarget2DSample,Game1,F:\newReposMay17\CartBlanche_MonoGame-Samples\RenderTarget2DSample\Game1.cs,Draw,The following statement contains a magic number: if (oneTimeOnly) {  	oneTimeOnly = false;  	// Set renderTarget as the surface to draw to instead of the back buffer  	GraphicsDevice.SetRenderTarget (renderTarget);  	// Clear the renderTarget. By default it's all a bright purple color. I like to use Color.Transparent to  	// enable easy alpha blending.  	GraphicsDevice.Clear (Color.Transparent);  	Vector2 woodPosition = Vector2.Zero;  	// Begin drawing  	spriteBatch.Begin ();  	int xBlank = 0;  	int yBlank = 0;  	// Use nested do-whiles to fill the rendertarget with tiles. We use some trickery to draw every other tile  	do {  		do {  			// We use the modulus operator to get the remainder of dividing xBlank by 2. If xBlank is odd' it'll  			// return 1 and the spriteBatch.Draw call gets skipped. If it's even' it'll return 0 so  			// spriteBatch.Draw will get called and it'll draw a tile there.  			if (xBlank % 2 == 0) {  				spriteBatch.Draw (checker' woodPosition' Color.White);  			}  			// Increment xBlank by one so that every other tile will get drawn.  			xBlank++;  			// Increase the X coordinate of where we'll draw the wood tile in order to progressively draw  			// each column of tiles.  			woodPosition.X += checker.Width;  			// We draw so long as woodPosition.X is less than our renderTarget's width  		} while (woodPosition.X < renderTarget.Width);  		// We increment yBlank by one. Why is explained below.  		yBlank++;  		// We use the modulus operater to get the remainder of dividing yBlank by 2. If yBlank is odd' we reset  		// xBlank to 1. If it's even' we reset xBlank to 0. This way each row shifts by one so that the tiles  		// are drawn in a checkered pattern rather than in columns.  		if (yBlank % 2 == 0) {  			xBlank = 0;  		} else {  			xBlank = 1;  		}  		// Reset woodPosition.X to zero so that we start drawing from the beginning of the next row.  		woodPosition.X = 0;  		// Increase the Y coord of where we'll draw the wood tile in order to progressively draw each  		// row of tiles.  		woodPosition.Y += checker.Height;  		// We draw so long as woodPosition.Y is less than our renderTarget's width  	} while (woodPosition.Y < renderTarget.Height);  	// Now that we've drawn the wood tiles' we draw Moo the Merciless. We draw him centered in the rendertarget.  	spriteBatch.Draw (logo' new Vector2 ((renderTarget.Width / 2f) - (logo.Width / 2f)' (renderTarget.Height / 2f) - (logo.Height / 2f))' Color.White);  	// End the spriteBatch draw.  	spriteBatch.End ();  	// Switch back to drawing onto the back buffer  	GraphicsDevice.SetRenderTarget (null);  	//GrabScreenshot(renderTarget);  }  
Magic Number,RenderTarget2DSample,Game1,F:\newReposMay17\CartBlanche_MonoGame-Samples\RenderTarget2DSample\Game1.cs,Draw,The following statement contains a magic number: if (oneTimeOnly) {  	oneTimeOnly = false;  	// Set renderTarget as the surface to draw to instead of the back buffer  	GraphicsDevice.SetRenderTarget (renderTarget);  	// Clear the renderTarget. By default it's all a bright purple color. I like to use Color.Transparent to  	// enable easy alpha blending.  	GraphicsDevice.Clear (Color.Transparent);  	Vector2 woodPosition = Vector2.Zero;  	// Begin drawing  	spriteBatch.Begin ();  	int xBlank = 0;  	int yBlank = 0;  	// Use nested do-whiles to fill the rendertarget with tiles. We use some trickery to draw every other tile  	do {  		do {  			// We use the modulus operator to get the remainder of dividing xBlank by 2. If xBlank is odd' it'll  			// return 1 and the spriteBatch.Draw call gets skipped. If it's even' it'll return 0 so  			// spriteBatch.Draw will get called and it'll draw a tile there.  			if (xBlank % 2 == 0) {  				spriteBatch.Draw (checker' woodPosition' Color.White);  			}  			// Increment xBlank by one so that every other tile will get drawn.  			xBlank++;  			// Increase the X coordinate of where we'll draw the wood tile in order to progressively draw  			// each column of tiles.  			woodPosition.X += checker.Width;  			// We draw so long as woodPosition.X is less than our renderTarget's width  		} while (woodPosition.X < renderTarget.Width);  		// We increment yBlank by one. Why is explained below.  		yBlank++;  		// We use the modulus operater to get the remainder of dividing yBlank by 2. If yBlank is odd' we reset  		// xBlank to 1. If it's even' we reset xBlank to 0. This way each row shifts by one so that the tiles  		// are drawn in a checkered pattern rather than in columns.  		if (yBlank % 2 == 0) {  			xBlank = 0;  		} else {  			xBlank = 1;  		}  		// Reset woodPosition.X to zero so that we start drawing from the beginning of the next row.  		woodPosition.X = 0;  		// Increase the Y coord of where we'll draw the wood tile in order to progressively draw each  		// row of tiles.  		woodPosition.Y += checker.Height;  		// We draw so long as woodPosition.Y is less than our renderTarget's width  	} while (woodPosition.Y < renderTarget.Height);  	// Now that we've drawn the wood tiles' we draw Moo the Merciless. We draw him centered in the rendertarget.  	spriteBatch.Draw (logo' new Vector2 ((renderTarget.Width / 2f) - (logo.Width / 2f)' (renderTarget.Height / 2f) - (logo.Height / 2f))' Color.White);  	// End the spriteBatch draw.  	spriteBatch.End ();  	// Switch back to drawing onto the back buffer  	GraphicsDevice.SetRenderTarget (null);  	//GrabScreenshot(renderTarget);  }  
Magic Number,RenderTarget2DSample,Game1,F:\newReposMay17\CartBlanche_MonoGame-Samples\RenderTarget2DSample\Game1.cs,Draw,The following statement contains a magic number: do {  	do {  		// We use the modulus operator to get the remainder of dividing xBlank by 2. If xBlank is odd' it'll  		// return 1 and the spriteBatch.Draw call gets skipped. If it's even' it'll return 0 so  		// spriteBatch.Draw will get called and it'll draw a tile there.  		if (xBlank % 2 == 0) {  			spriteBatch.Draw (checker' woodPosition' Color.White);  		}  		// Increment xBlank by one so that every other tile will get drawn.  		xBlank++;  		// Increase the X coordinate of where we'll draw the wood tile in order to progressively draw  		// each column of tiles.  		woodPosition.X += checker.Width;  		// We draw so long as woodPosition.X is less than our renderTarget's width  	} while (woodPosition.X < renderTarget.Width);  	// We increment yBlank by one. Why is explained below.  	yBlank++;  	// We use the modulus operater to get the remainder of dividing yBlank by 2. If yBlank is odd' we reset  	// xBlank to 1. If it's even' we reset xBlank to 0. This way each row shifts by one so that the tiles  	// are drawn in a checkered pattern rather than in columns.  	if (yBlank % 2 == 0) {  		xBlank = 0;  	} else {  		xBlank = 1;  	}  	// Reset woodPosition.X to zero so that we start drawing from the beginning of the next row.  	woodPosition.X = 0;  	// Increase the Y coord of where we'll draw the wood tile in order to progressively draw each  	// row of tiles.  	woodPosition.Y += checker.Height;  	// We draw so long as woodPosition.Y is less than our renderTarget's width  } while (woodPosition.Y < renderTarget.Height);  
Magic Number,RenderTarget2DSample,Game1,F:\newReposMay17\CartBlanche_MonoGame-Samples\RenderTarget2DSample\Game1.cs,Draw,The following statement contains a magic number: do {  	do {  		// We use the modulus operator to get the remainder of dividing xBlank by 2. If xBlank is odd' it'll  		// return 1 and the spriteBatch.Draw call gets skipped. If it's even' it'll return 0 so  		// spriteBatch.Draw will get called and it'll draw a tile there.  		if (xBlank % 2 == 0) {  			spriteBatch.Draw (checker' woodPosition' Color.White);  		}  		// Increment xBlank by one so that every other tile will get drawn.  		xBlank++;  		// Increase the X coordinate of where we'll draw the wood tile in order to progressively draw  		// each column of tiles.  		woodPosition.X += checker.Width;  		// We draw so long as woodPosition.X is less than our renderTarget's width  	} while (woodPosition.X < renderTarget.Width);  	// We increment yBlank by one. Why is explained below.  	yBlank++;  	// We use the modulus operater to get the remainder of dividing yBlank by 2. If yBlank is odd' we reset  	// xBlank to 1. If it's even' we reset xBlank to 0. This way each row shifts by one so that the tiles  	// are drawn in a checkered pattern rather than in columns.  	if (yBlank % 2 == 0) {  		xBlank = 0;  	} else {  		xBlank = 1;  	}  	// Reset woodPosition.X to zero so that we start drawing from the beginning of the next row.  	woodPosition.X = 0;  	// Increase the Y coord of where we'll draw the wood tile in order to progressively draw each  	// row of tiles.  	woodPosition.Y += checker.Height;  	// We draw so long as woodPosition.Y is less than our renderTarget's width  } while (woodPosition.Y < renderTarget.Height);  
Magic Number,RenderTarget2DSample,Game1,F:\newReposMay17\CartBlanche_MonoGame-Samples\RenderTarget2DSample\Game1.cs,Draw,The following statement contains a magic number: do {  	// We use the modulus operator to get the remainder of dividing xBlank by 2. If xBlank is odd' it'll  	// return 1 and the spriteBatch.Draw call gets skipped. If it's even' it'll return 0 so  	// spriteBatch.Draw will get called and it'll draw a tile there.  	if (xBlank % 2 == 0) {  		spriteBatch.Draw (checker' woodPosition' Color.White);  	}  	// Increment xBlank by one so that every other tile will get drawn.  	xBlank++;  	// Increase the X coordinate of where we'll draw the wood tile in order to progressively draw  	// each column of tiles.  	woodPosition.X += checker.Width;  	// We draw so long as woodPosition.X is less than our renderTarget's width  } while (woodPosition.X < renderTarget.Width);  
Magic Number,RenderTarget2DSample,Game1,F:\newReposMay17\CartBlanche_MonoGame-Samples\RenderTarget2DSample\Game1.cs,Draw,The following statement contains a magic number: if (xBlank % 2 == 0) {  	spriteBatch.Draw (checker' woodPosition' Color.White);  }  
Magic Number,RenderTarget2DSample,Game1,F:\newReposMay17\CartBlanche_MonoGame-Samples\RenderTarget2DSample\Game1.cs,Draw,The following statement contains a magic number: if (yBlank % 2 == 0) {  	xBlank = 0;  } else {  	xBlank = 1;  }  
Magic Number,RenderTarget2DSample,Game1,F:\newReposMay17\CartBlanche_MonoGame-Samples\RenderTarget2DSample\Game1.cs,Draw,The following statement contains a magic number: if (gameTime.TotalGameTime.TotalSeconds % 10 < 5.0) {  	// We're running on a ten second scale timer. For the first five second we scale down from 1f to  	// no less than 0.01f.  	scale = MathHelper.Clamp (1f - (((float)gameTime.TotalGameTime.TotalSeconds % 5) / 5f)' 0.01f' 1f);  } else {  	// For the second five seconds' we scale up from no less than 0.01f up to 1f.  	scale = MathHelper.Clamp (((float)gameTime.TotalGameTime.TotalSeconds % 5) / 5f' 0.01f' 1f);  }  
Magic Number,RenderTarget2DSample,Game1,F:\newReposMay17\CartBlanche_MonoGame-Samples\RenderTarget2DSample\Game1.cs,Draw,The following statement contains a magic number: if (gameTime.TotalGameTime.TotalSeconds % 10 < 5.0) {  	// We're running on a ten second scale timer. For the first five second we scale down from 1f to  	// no less than 0.01f.  	scale = MathHelper.Clamp (1f - (((float)gameTime.TotalGameTime.TotalSeconds % 5) / 5f)' 0.01f' 1f);  } else {  	// For the second five seconds' we scale up from no less than 0.01f up to 1f.  	scale = MathHelper.Clamp (((float)gameTime.TotalGameTime.TotalSeconds % 5) / 5f' 0.01f' 1f);  }  
Magic Number,RenderTarget2DSample,Game1,F:\newReposMay17\CartBlanche_MonoGame-Samples\RenderTarget2DSample\Game1.cs,Draw,The following statement contains a magic number: if (gameTime.TotalGameTime.TotalSeconds % 10 < 5.0) {  	// We're running on a ten second scale timer. For the first five second we scale down from 1f to  	// no less than 0.01f.  	scale = MathHelper.Clamp (1f - (((float)gameTime.TotalGameTime.TotalSeconds % 5) / 5f)' 0.01f' 1f);  } else {  	// For the second five seconds' we scale up from no less than 0.01f up to 1f.  	scale = MathHelper.Clamp (((float)gameTime.TotalGameTime.TotalSeconds % 5) / 5f' 0.01f' 1f);  }  
Magic Number,RenderTarget2DSample,Game1,F:\newReposMay17\CartBlanche_MonoGame-Samples\RenderTarget2DSample\Game1.cs,Draw,The following statement contains a magic number: if (gameTime.TotalGameTime.TotalSeconds % 10 < 5.0) {  	// We're running on a ten second scale timer. For the first five second we scale down from 1f to  	// no less than 0.01f.  	scale = MathHelper.Clamp (1f - (((float)gameTime.TotalGameTime.TotalSeconds % 5) / 5f)' 0.01f' 1f);  } else {  	// For the second five seconds' we scale up from no less than 0.01f up to 1f.  	scale = MathHelper.Clamp (((float)gameTime.TotalGameTime.TotalSeconds % 5) / 5f' 0.01f' 1f);  }  
Magic Number,RenderTarget2DSample,Game1,F:\newReposMay17\CartBlanche_MonoGame-Samples\RenderTarget2DSample\Game1.cs,Draw,The following statement contains a magic number: scale = MathHelper.Clamp (1f - (((float)gameTime.TotalGameTime.TotalSeconds % 5) / 5f)' 0.01f' 1f);  
Magic Number,RenderTarget2DSample,Game1,F:\newReposMay17\CartBlanche_MonoGame-Samples\RenderTarget2DSample\Game1.cs,Draw,The following statement contains a magic number: scale = MathHelper.Clamp (((float)gameTime.TotalGameTime.TotalSeconds % 5) / 5f' 0.01f' 1f);  
Magic Number,RenderTarget2DSample,Game1,F:\newReposMay17\CartBlanche_MonoGame-Samples\RenderTarget2DSample\Game1.cs,Draw,The following statement contains a magic number: spriteBatch.Draw (renderTarget' new Vector2 (GraphicsDevice.PresentationParameters.BackBufferWidth / 2' GraphicsDevice.PresentationParameters.BackBufferHeight / 2)' null' Color.White' 0f' new Vector2 (renderTarget.Width / 2' renderTarget.Height / 2)' scale' SpriteEffects.None' 0f);  
Magic Number,RenderTarget2DSample,Game1,F:\newReposMay17\CartBlanche_MonoGame-Samples\RenderTarget2DSample\Game1.cs,Draw,The following statement contains a magic number: spriteBatch.Draw (renderTarget' new Vector2 (GraphicsDevice.PresentationParameters.BackBufferWidth / 2' GraphicsDevice.PresentationParameters.BackBufferHeight / 2)' null' Color.White' 0f' new Vector2 (renderTarget.Width / 2' renderTarget.Height / 2)' scale' SpriteEffects.None' 0f);  
Magic Number,RenderTarget2DSample,Game1,F:\newReposMay17\CartBlanche_MonoGame-Samples\RenderTarget2DSample\Game1.cs,Draw,The following statement contains a magic number: spriteBatch.Draw (renderTarget' new Vector2 (GraphicsDevice.PresentationParameters.BackBufferWidth / 2' GraphicsDevice.PresentationParameters.BackBufferHeight / 2)' null' Color.White' 0f' new Vector2 (renderTarget.Width / 2' renderTarget.Height / 2)' scale' SpriteEffects.None' 0f);  
Magic Number,RenderTarget2DSample,Game1,F:\newReposMay17\CartBlanche_MonoGame-Samples\RenderTarget2DSample\Game1.cs,Draw,The following statement contains a magic number: spriteBatch.Draw (renderTarget' new Vector2 (GraphicsDevice.PresentationParameters.BackBufferWidth / 2' GraphicsDevice.PresentationParameters.BackBufferHeight / 2)' null' Color.White' 0f' new Vector2 (renderTarget.Width / 2' renderTarget.Height / 2)' scale' SpriteEffects.None' 0f);  
