Implementation smell,Namespace,Class,File,Method,Description
Long Method,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The method has 140 lines of code.
Long Method,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The method has 108 lines of code.
Complex Method,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,Cyclomatic complexity of the method is 21
Complex Method,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,Cyclomatic complexity of the method is 12
Complex Method,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,Cyclomatic complexity of the method is 44
Complex Method,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Move,Cyclomatic complexity of the method is 23
Complex Method,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIAttack,Cyclomatic complexity of the method is 16
Complex Method,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,FindDirection,Cyclomatic complexity of the method is 9
Complex Method,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,NextTile,Cyclomatic complexity of the method is 14
Complex Method,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,Cyclomatic complexity of the method is 24
Complex Method,XNAPacMan,Grid,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,Cyclomatic complexity of the method is 12
Complex Method,XNAPacMan,Menu,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Menu.cs,menuAction,Cyclomatic complexity of the method is 18
Complex Method,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoMove,Cyclomatic complexity of the method is 13
Complex Method,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,Cyclomatic complexity of the method is 24
Long Parameter List,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,RenderSprite,The method has 5 parameters.
Long Statement,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The length of the statement  "					if (ghosts_ [i].State == GhostState.Attack || ghosts_ [i].State == GhostState.Scatter || ghosts_ [i].State == GhostState.Blue) { " is 128.
Long Statement,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The length of the statement  "	if (bonusPresent_ && player_.Position.Tile.Y == 17 && ((player_.Position.Tile.X == 13 && player_.Position.DeltaPixel.X == 8) || (player_.Position.Tile.X == 14 && player_.Position.DeltaPixel.X == -8))) { " is 202.
Long Statement,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The length of the statement  "		Rectangle playerArea = new Rectangle ((player_.Position.Tile.X * 16) + player_.Position.DeltaPixel.X' (player_.Position.Tile.Y * 16) + player_.Position.DeltaPixel.Y' 26' 26); " is 174.
Long Statement,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The length of the statement  "		Rectangle ghostArea = new Rectangle ((ghost.Position.Tile.X * 16) + ghost.Position.DeltaPixel.X' (ghost.Position.Tile.Y * 16) + ghost.Position.DeltaPixel.Y' 22' 22); " is 165.
Long Statement,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The length of the statement  "	if ((Grid.NumCrumps == 180 || Grid.NumCrumps == 80) && bonusSpawned_ < 2 && !(player_.Position.Tile.Y == 17 && ((player_.Position.Tile.X == 13 && player_.Position.DeltaPixel.X == 8) || (player_.Position.Tile.X == 14 && player_.Position.DeltaPixel.X == -8)))) { " is 260.
Long Statement,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The length of the statement  "	Vector2 boardPosition = new Vector2 ((graphics_.PreferredBackBufferWidth / 2) - (board_.Width / 2)' (graphics_.PreferredBackBufferHeight / 2) - (board_.Height / 2)); " is 165.
Long Statement,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The length of the statement  "		spriteBatch_.Draw (((DateTime.Now.Second * 1000 + DateTime.Now.Millisecond) / 350) % 2 == 0 ? board_ : boardFlash_' boardPosition' Color.White); " is 144.
Long Statement,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The length of the statement  "		spriteBatch_.Draw (xlife_' new Vector2 (boardPosition.X + 10 + (20 * i)' board_.Height + boardPosition.Y + 10)' Color.White); " is 125.
Long Statement,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The length of the statement  "	spriteBatch_.DrawString (scoreFont_' Score.ToString ()' new Vector2 (boardPosition.X + 30' boardPosition.Y - 30)' Color.White); " is 127.
Long Statement,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The length of the statement  "	spriteBatch_.DrawString (scoreFont_' "LEVEL"' new Vector2 (boardPosition.X + board_.Width - 80' boardPosition.Y - 50)' Color.White); " is 132.
Long Statement,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The length of the statement  "	spriteBatch_.DrawString (scoreFont_' Constants.Level.ToString ()' new Vector2 (boardPosition.X + board_.Width - 80' boardPosition.Y - 30)' Color.White); " is 152.
Long Statement,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The length of the statement  "		spriteBatch_.Draw (bonus_ [Constants.BonusSprite ()]' new Vector2 (boardPosition.X + (13 * 16) + 2' boardPosition.Y + (17 * 16) - 8)' Color.White); " is 147.
Long Statement,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The length of the statement  "			spriteBatch_.Draw (bonus_ [kvp.Key]' new Vector2 (boardPosition.X + 10 + (22 * (k + i))' board_.Height + boardPosition.Y + 22)' Color.White); " is 141.
Long Statement,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The length of the statement  "		spriteBatch_.DrawString (scoreEventFont_' se.Score.ToString ()' new Vector2 (boardPosition.X + (se.Position.Tile.X * 16) + se.Position.DeltaPixel.X + 4' boardPosition.Y + (se.Position.Tile.Y * 16) + se.Position.DeltaPixel.Y + 4)' Color.White); " is 243.
Long Statement,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The length of the statement  "		spriteBatch_.DrawString (scoreFont_' "GET READY!"' new Vector2 (boardPosition.X + (board_.Width / 2) - 58' boardPosition.Y + 273)' Color.Yellow); " is 145.
Long Statement,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The length of the statement  "		else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) { " is 161.
Long Statement,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The length of the statement  "	if ((initialState != previousState_) || (Grid.NumCrumps == 199 && previousNumCrumps_ == 200) || (Grid.NumCrumps == 19 && previousNumCrumps_ == 20)) { " is 149.
Long Statement,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,UpdateSpeed,The length of the statement  "	else if (position_.Tile.Y == 14 && ((0 <= position_.Tile.X && position_.Tile.X <= 5) || (22 <= position_.Tile.X && position_.Tile.X <= 27))) { " is 142.
Long Statement,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIScatter,The length of the statement  "		orderedTiles.Sort ((a' b) => Vector2.Distance (new Vector2 (position_.Tile.X' position_.Tile.Y)' new Vector2 (a.X' a.Y)).CompareTo (Vector2.Distance (new Vector2 (position_.Tile.X' position_.Tile.Y)' new Vector2 (b.X' b.Y)))); " is 226.
Long Statement,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AttackAIInky,The length of the statement  "	Vector2 line = new Vector2 (blinky_.Position.Tile.X - nextNextTile.ToPoint.X' blinky_.Position.Tile.Y - nextNextTile.ToPoint.Y); " is 128.
Long Statement,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AttackAIClyde,The length of the statement  "	float distanceToPlayer = Vector2.Distance (new Vector2 (player_.Position.Tile.X' player_.Position.Tile.Y)' new Vector2 (position_.Tile.X' position_.Tile.Y)); " is 157.
Long Statement,XNAPacMan,HighScores,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\HighScores.cs,Draw,The length of the statement  "	Vector2 position = new Vector2 (graphics_.PreferredBackBufferWidth / 2 - 150' graphics_.PreferredBackBufferHeight / 2 - 200); " is 125.
Long Statement,XNAPacMan,HighScores,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\HighScores.cs,Draw,The length of the statement  "		spriteBatch_.DrawString (scoreFont_' (i + 1).ToString () + "."' new Vector2 (position.X' position.Y + (30 * i))' Color.White); " is 126.
Long Statement,XNAPacMan,Menu,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Menu.cs,Draw,The length of the statement  "	spriteBatch_.Draw (title_' new Vector2 ((graphics_.PreferredBackBufferWidth / 2) - (title_.Width / 2)' 75)' Color.White); " is 121.
Long Statement,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,TryMove,The length of the statement  "	else if ((position_.Tile == new Point (0' 14) && direction_ == Direction.Left) || (position_.Tile == new Point (27' 14) && direction_ == Direction.Right)) { " is 156.
Long Statement,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,TryMove,The length of the statement  "	else if ((direction_ == Direction.Up && Grid.TileGrid [position_.Tile.X' position_.Tile.Y - 1].Type == TileTypes.Open) || (direction_ == Direction.Down && Grid.TileGrid [position_.Tile.X' position_.Tile.Y + 1].Type == TileTypes.Open) || (direction_ == Direction.Left && Grid.TileGrid [position_.Tile.X - 1' position_.Tile.Y].Type == TileTypes.Open) || (direction_ == Direction.Right && Grid.TileGrid [position_.Tile.X + 1' position_.Tile.Y].Type == TileTypes.Open)) { " is 467.
Long Statement,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Draw,The length of the statement  "	position.Y = boardPosition.Y + (position_.Tile.Y * 16) + position_.DeltaPixel.Y - ((eatingFrames_ [0].Height - 16) / 2); " is 120.
Long Statement,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,TryTurn,The length of the statement  "		if ((direction_ == Direction.Up && input == Keys.Down) || (direction_ == Direction.Down && input == Keys.Up) || (direction_ == Direction.Left && input == Keys.Right) || (direction_ == Direction.Right && input == Keys.Left)) { " is 225.
Long Statement,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,TryTurn,The length of the statement  "	else if ((input == Keys.Up && Grid.TileGrid [position_.Tile.X' position_.Tile.Y - 1].Type == TileTypes.Open) || (input == Keys.Down && Grid.TileGrid [position_.Tile.X' position_.Tile.Y + 1].Type == TileTypes.Open) || (input == Keys.Left && Grid.TileGrid [position_.Tile.X - 1' position_.Tile.Y].Type == TileTypes.Open) || (input == Keys.Right && Grid.TileGrid [position_.Tile.X + 1' position_.Tile.Y].Type == TileTypes.Open)) { " is 427.
Complex Conditional,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The conditional expression  "bonusPresent_ && player_.Position.Tile.Y == 17 && ((player_.Position.Tile.X == 13 && player_.Position.DeltaPixel.X == 8) || (player_.Position.Tile.X == 14 && player_.Position.DeltaPixel.X == -8))"  is complex.
Complex Conditional,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The conditional expression  "(Grid.NumCrumps == 180 || Grid.NumCrumps == 80) && bonusSpawned_ < 2 && !(player_.Position.Tile.Y == 17 && ((player_.Position.Tile.X == 13 && player_.Position.DeltaPixel.X == 8) || (player_.Position.Tile.X == 14 && player_.Position.DeltaPixel.X == -8)))"  is complex.
Complex Conditional,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The conditional expression  "(position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))"  is complex.
Complex Conditional,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The conditional expression  "(initialState != previousState_) || (Grid.NumCrumps == 199 && previousNumCrumps_ == 200) || (Grid.NumCrumps == 19 && previousNumCrumps_ == 20)"  is complex.
Complex Conditional,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,UpdateSpeed,The conditional expression  "position_.Tile.Y == 14 && ((0 <= position_.Tile.X && position_.Tile.X <= 5) || (22 <= position_.Tile.X && position_.Tile.X <= 27))"  is complex.
Complex Conditional,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,TryMove,The conditional expression  "(position_.Tile == new Point (0' 14) && direction_ == Direction.Left) || (position_.Tile == new Point (27' 14) && direction_ == Direction.Right)"  is complex.
Complex Conditional,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,TryMove,The conditional expression  "(direction_ == Direction.Up && Grid.TileGrid [position_.Tile.X' position_.Tile.Y - 1].Type == TileTypes.Open) || (direction_ == Direction.Down && Grid.TileGrid [position_.Tile.X' position_.Tile.Y + 1].Type == TileTypes.Open) || (direction_ == Direction.Left && Grid.TileGrid [position_.Tile.X - 1' position_.Tile.Y].Type == TileTypes.Open) || (direction_ == Direction.Right && Grid.TileGrid [position_.Tile.X + 1' position_.Tile.Y].Type == TileTypes.Open)"  is complex.
Complex Conditional,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,TryTurn,The conditional expression  "(direction_ == Direction.Up && input == Keys.Down) || (direction_ == Direction.Down && input == Keys.Up) || (direction_ == Direction.Left && input == Keys.Right) || (direction_ == Direction.Right && input == Keys.Left)"  is complex.
Complex Conditional,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,TryTurn,The conditional expression  "(input == Keys.Left && position_.Tile.X == 0) || (input == Keys.Right && position_.Tile.X == 27)"  is complex.
Complex Conditional,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,TryTurn,The conditional expression  "(input == Keys.Up && Grid.TileGrid [position_.Tile.X' position_.Tile.Y - 1].Type == TileTypes.Open) || (input == Keys.Down && Grid.TileGrid [position_.Tile.X' position_.Tile.Y + 1].Type == TileTypes.Open) || (input == Keys.Left && Grid.TileGrid [position_.Tile.X - 1' position_.Tile.Y].Type == TileTypes.Open) || (input == Keys.Right && Grid.TileGrid [position_.Tile.X + 1' position_.Tile.Y].Type == TileTypes.Open)"  is complex.
Magic Number,XNAPacMan,Constants,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,InitialJumps,The following statement contains a magic number: if (newLevel) {  	switch (ghost) {  	case Ghosts.Inky:  		return (int)MathHelper.Clamp ((20 - Level) / 2' 0' 10);  	case Ghosts.Clyde:  		return InitialJumps (Ghosts.Inky' true) + 2;  	default:  		return 0;  	}  } else {  	switch (ghost) {  	case Ghosts.Inky:  		return 1;  	case Ghosts.Clyde:  		return 2;  	default:  		return 0;  	}  }  
Magic Number,XNAPacMan,Constants,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,InitialJumps,The following statement contains a magic number: if (newLevel) {  	switch (ghost) {  	case Ghosts.Inky:  		return (int)MathHelper.Clamp ((20 - Level) / 2' 0' 10);  	case Ghosts.Clyde:  		return InitialJumps (Ghosts.Inky' true) + 2;  	default:  		return 0;  	}  } else {  	switch (ghost) {  	case Ghosts.Inky:  		return 1;  	case Ghosts.Clyde:  		return 2;  	default:  		return 0;  	}  }  
Magic Number,XNAPacMan,Constants,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,InitialJumps,The following statement contains a magic number: if (newLevel) {  	switch (ghost) {  	case Ghosts.Inky:  		return (int)MathHelper.Clamp ((20 - Level) / 2' 0' 10);  	case Ghosts.Clyde:  		return InitialJumps (Ghosts.Inky' true) + 2;  	default:  		return 0;  	}  } else {  	switch (ghost) {  	case Ghosts.Inky:  		return 1;  	case Ghosts.Clyde:  		return 2;  	default:  		return 0;  	}  }  
Magic Number,XNAPacMan,Constants,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,InitialJumps,The following statement contains a magic number: if (newLevel) {  	switch (ghost) {  	case Ghosts.Inky:  		return (int)MathHelper.Clamp ((20 - Level) / 2' 0' 10);  	case Ghosts.Clyde:  		return InitialJumps (Ghosts.Inky' true) + 2;  	default:  		return 0;  	}  } else {  	switch (ghost) {  	case Ghosts.Inky:  		return 1;  	case Ghosts.Clyde:  		return 2;  	default:  		return 0;  	}  }  
Magic Number,XNAPacMan,Constants,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,InitialJumps,The following statement contains a magic number: if (newLevel) {  	switch (ghost) {  	case Ghosts.Inky:  		return (int)MathHelper.Clamp ((20 - Level) / 2' 0' 10);  	case Ghosts.Clyde:  		return InitialJumps (Ghosts.Inky' true) + 2;  	default:  		return 0;  	}  } else {  	switch (ghost) {  	case Ghosts.Inky:  		return 1;  	case Ghosts.Clyde:  		return 2;  	default:  		return 0;  	}  }  
Magic Number,XNAPacMan,Constants,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,InitialJumps,The following statement contains a magic number: switch (ghost) {  case Ghosts.Inky:  	return (int)MathHelper.Clamp ((20 - Level) / 2' 0' 10);  case Ghosts.Clyde:  	return InitialJumps (Ghosts.Inky' true) + 2;  default:  	return 0;  }  
Magic Number,XNAPacMan,Constants,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,InitialJumps,The following statement contains a magic number: switch (ghost) {  case Ghosts.Inky:  	return (int)MathHelper.Clamp ((20 - Level) / 2' 0' 10);  case Ghosts.Clyde:  	return InitialJumps (Ghosts.Inky' true) + 2;  default:  	return 0;  }  
Magic Number,XNAPacMan,Constants,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,InitialJumps,The following statement contains a magic number: switch (ghost) {  case Ghosts.Inky:  	return (int)MathHelper.Clamp ((20 - Level) / 2' 0' 10);  case Ghosts.Clyde:  	return InitialJumps (Ghosts.Inky' true) + 2;  default:  	return 0;  }  
Magic Number,XNAPacMan,Constants,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,InitialJumps,The following statement contains a magic number: switch (ghost) {  case Ghosts.Inky:  	return (int)MathHelper.Clamp ((20 - Level) / 2' 0' 10);  case Ghosts.Clyde:  	return InitialJumps (Ghosts.Inky' true) + 2;  default:  	return 0;  }  
Magic Number,XNAPacMan,Constants,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,InitialJumps,The following statement contains a magic number: return (int)MathHelper.Clamp ((20 - Level) / 2' 0' 10);  
Magic Number,XNAPacMan,Constants,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,InitialJumps,The following statement contains a magic number: return (int)MathHelper.Clamp ((20 - Level) / 2' 0' 10);  
Magic Number,XNAPacMan,Constants,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,InitialJumps,The following statement contains a magic number: return (int)MathHelper.Clamp ((20 - Level) / 2' 0' 10);  
Magic Number,XNAPacMan,Constants,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,InitialJumps,The following statement contains a magic number: return InitialJumps (Ghosts.Inky' true) + 2;  
Magic Number,XNAPacMan,Constants,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,InitialJumps,The following statement contains a magic number: switch (ghost) {  case Ghosts.Inky:  	return 1;  case Ghosts.Clyde:  	return 2;  default:  	return 0;  }  
Magic Number,XNAPacMan,Constants,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,InitialJumps,The following statement contains a magic number: return 2;  
Magic Number,XNAPacMan,Constants,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,CruiseElroyTimer,The following statement contains a magic number: if (Level >= 10) {  	return cruiseElroyTimers_ [9];  } else {  	return cruiseElroyTimers_ [Level - 1];  }  
Magic Number,XNAPacMan,Constants,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,CruiseElroyTimer,The following statement contains a magic number: if (Level >= 10) {  	return cruiseElroyTimers_ [9];  } else {  	return cruiseElroyTimers_ [Level - 1];  }  
Magic Number,XNAPacMan,Constants,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,CruiseElroyTimer,The following statement contains a magic number: return cruiseElroyTimers_ [9];  
Magic Number,XNAPacMan,Constants,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,BlueTime,The following statement contains a magic number: return Level > blueTimes_.Length - 2 ? 0 : blueTimes_ [Level - 1];  
Magic Number,XNAPacMan,Constants,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,BonusScores,The following statement contains a magic number: return Level > bonusScores_.Length - 2 ? 5000 : bonusScores_ [Level - 1];  
Magic Number,XNAPacMan,Constants,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,BonusScores,The following statement contains a magic number: return Level > bonusScores_.Length - 2 ? 5000 : bonusScores_ [Level - 1];  
Magic Number,XNAPacMan,Constants,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,BonusSprite,The following statement contains a magic number: return Level > bonusSprites_.Length - 2 ? "Key" : bonusSprites_ [Level - 1];  
Magic Number,XNAPacMan,Constants,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,PacManSpeed,The following statement contains a magic number: if (5 <= Level && Level <= 20) {  	return pacManSpeed_ [4];  } else if (5 > Level) {  	return pacManSpeed_ [Level - 1];  } else {  	return 10;  }  
Magic Number,XNAPacMan,Constants,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,PacManSpeed,The following statement contains a magic number: if (5 <= Level && Level <= 20) {  	return pacManSpeed_ [4];  } else if (5 > Level) {  	return pacManSpeed_ [Level - 1];  } else {  	return 10;  }  
Magic Number,XNAPacMan,Constants,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,PacManSpeed,The following statement contains a magic number: if (5 <= Level && Level <= 20) {  	return pacManSpeed_ [4];  } else if (5 > Level) {  	return pacManSpeed_ [Level - 1];  } else {  	return 10;  }  
Magic Number,XNAPacMan,Constants,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,PacManSpeed,The following statement contains a magic number: if (5 <= Level && Level <= 20) {  	return pacManSpeed_ [4];  } else if (5 > Level) {  	return pacManSpeed_ [Level - 1];  } else {  	return 10;  }  
Magic Number,XNAPacMan,Constants,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,PacManSpeed,The following statement contains a magic number: if (5 <= Level && Level <= 20) {  	return pacManSpeed_ [4];  } else if (5 > Level) {  	return pacManSpeed_ [Level - 1];  } else {  	return 10;  }  
Magic Number,XNAPacMan,Constants,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,PacManSpeed,The following statement contains a magic number: return pacManSpeed_ [4];  
Magic Number,XNAPacMan,Constants,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,PacManSpeed,The following statement contains a magic number: if (5 > Level) {  	return pacManSpeed_ [Level - 1];  } else {  	return 10;  }  
Magic Number,XNAPacMan,Constants,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,PacManSpeed,The following statement contains a magic number: if (5 > Level) {  	return pacManSpeed_ [Level - 1];  } else {  	return 10;  }  
Magic Number,XNAPacMan,Constants,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,PacManSpeed,The following statement contains a magic number: return 10;  
Magic Number,XNAPacMan,Constants,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,GhostSpeed,The following statement contains a magic number: return Level > 4 ? 11 : ghostSpeed_ [Level - 1];  
Magic Number,XNAPacMan,Constants,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,GhostSpeed,The following statement contains a magic number: return Level > 4 ? 11 : ghostSpeed_ [Level - 1];  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Initialize,The following statement contains a magic number: bonus_ = new Dictionary<string' Texture2D> (9);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Initialize,The following statement contains a magic number: scoreEvents_ = new List<ScoreEvent> (5);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Initialize,The following statement contains a magic number: xlives_ = 2;  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Initialize,The following statement contains a magic number: ghosts_ [2].SetBlinky (ghosts_ [0]);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Initialize,The following statement contains a magic number: LockTimer = TimeSpan.FromMilliseconds (4500);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: scoreEvents_.RemoveAll (i => DateTime.Now - i.When > TimeSpan.FromSeconds (5));  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: if (noCrumpsLeft ()) {  	if (Constants.Level < 21) {  		bonusSpawned_ = 0;  		Grid.Reset ();  		player_ = new Player (Game);  		ghosts_.ForEach (i => i.Reset (true' player_));  		soundBank_.PlayCue ("NewLevel");  		LockTimer = TimeSpan.FromSeconds (2);  		Constants.Level++;  		return;  	} else {  		// Game over' you win.  		Menu.SaveHighScore (Score);  		Game.Components.Add (new Menu (Game' null));  		Game.Components.Remove (this);  		GhostSoundsManager.StopLoops ();  		return;  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: if (noCrumpsLeft ()) {  	if (Constants.Level < 21) {  		bonusSpawned_ = 0;  		Grid.Reset ();  		player_ = new Player (Game);  		ghosts_.ForEach (i => i.Reset (true' player_));  		soundBank_.PlayCue ("NewLevel");  		LockTimer = TimeSpan.FromSeconds (2);  		Constants.Level++;  		return;  	} else {  		// Game over' you win.  		Menu.SaveHighScore (Score);  		Game.Components.Add (new Menu (Game' null));  		Game.Components.Remove (this);  		GhostSoundsManager.StopLoops ();  		return;  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: if (Constants.Level < 21) {  	bonusSpawned_ = 0;  	Grid.Reset ();  	player_ = new Player (Game);  	ghosts_.ForEach (i => i.Reset (true' player_));  	soundBank_.PlayCue ("NewLevel");  	LockTimer = TimeSpan.FromSeconds (2);  	Constants.Level++;  	return;  } else {  	// Game over' you win.  	Menu.SaveHighScore (Score);  	Game.Components.Add (new Menu (Game' null));  	Game.Components.Remove (this);  	GhostSoundsManager.StopLoops ();  	return;  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: if (Constants.Level < 21) {  	bonusSpawned_ = 0;  	Grid.Reset ();  	player_ = new Player (Game);  	ghosts_.ForEach (i => i.Reset (true' player_));  	soundBank_.PlayCue ("NewLevel");  	LockTimer = TimeSpan.FromSeconds (2);  	Constants.Level++;  	return;  } else {  	// Game over' you win.  	Menu.SaveHighScore (Score);  	Game.Components.Add (new Menu (Game' null));  	Game.Components.Remove (this);  	GhostSoundsManager.StopLoops ();  	return;  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: LockTimer = TimeSpan.FromSeconds (2);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: if (player_.Position.DeltaPixel == Point.Zero) {  	Point playerTile = player_.Position.Tile;  	if (Grid.TileGrid [playerTile.X' playerTile.Y].HasCrump) {  		soundBank_.PlayCue (paChomp_ ? "PacMAnEat1" : "PacManEat2");  		paChomp_ = !paChomp_;  		Score += 10;  		Grid.TileGrid [playerTile.X' playerTile.Y].HasCrump = false;  		if (Grid.TileGrid [playerTile.X' playerTile.Y].HasPowerPill) {  			Score += 40;  			eatenGhosts_ = 0;  			for (int i = 0; i < ghosts_.Count; i++) {  				if (ghosts_ [i].State == GhostState.Attack || ghosts_ [i].State == GhostState.Scatter || ghosts_ [i].State == GhostState.Blue) {  					ghosts_ [i].State = GhostState.Blue;  				}  			}  			Grid.TileGrid [playerTile.X' playerTile.Y].HasPowerPill = false;  		}  		// If that was the last crump' lock the game for a while  		if (noCrumpsLeft ()) {  			GhostSoundsManager.StopLoops ();  			LockTimer = TimeSpan.FromSeconds (2);  			return;  		}  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: if (player_.Position.DeltaPixel == Point.Zero) {  	Point playerTile = player_.Position.Tile;  	if (Grid.TileGrid [playerTile.X' playerTile.Y].HasCrump) {  		soundBank_.PlayCue (paChomp_ ? "PacMAnEat1" : "PacManEat2");  		paChomp_ = !paChomp_;  		Score += 10;  		Grid.TileGrid [playerTile.X' playerTile.Y].HasCrump = false;  		if (Grid.TileGrid [playerTile.X' playerTile.Y].HasPowerPill) {  			Score += 40;  			eatenGhosts_ = 0;  			for (int i = 0; i < ghosts_.Count; i++) {  				if (ghosts_ [i].State == GhostState.Attack || ghosts_ [i].State == GhostState.Scatter || ghosts_ [i].State == GhostState.Blue) {  					ghosts_ [i].State = GhostState.Blue;  				}  			}  			Grid.TileGrid [playerTile.X' playerTile.Y].HasPowerPill = false;  		}  		// If that was the last crump' lock the game for a while  		if (noCrumpsLeft ()) {  			GhostSoundsManager.StopLoops ();  			LockTimer = TimeSpan.FromSeconds (2);  			return;  		}  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: if (player_.Position.DeltaPixel == Point.Zero) {  	Point playerTile = player_.Position.Tile;  	if (Grid.TileGrid [playerTile.X' playerTile.Y].HasCrump) {  		soundBank_.PlayCue (paChomp_ ? "PacMAnEat1" : "PacManEat2");  		paChomp_ = !paChomp_;  		Score += 10;  		Grid.TileGrid [playerTile.X' playerTile.Y].HasCrump = false;  		if (Grid.TileGrid [playerTile.X' playerTile.Y].HasPowerPill) {  			Score += 40;  			eatenGhosts_ = 0;  			for (int i = 0; i < ghosts_.Count; i++) {  				if (ghosts_ [i].State == GhostState.Attack || ghosts_ [i].State == GhostState.Scatter || ghosts_ [i].State == GhostState.Blue) {  					ghosts_ [i].State = GhostState.Blue;  				}  			}  			Grid.TileGrid [playerTile.X' playerTile.Y].HasPowerPill = false;  		}  		// If that was the last crump' lock the game for a while  		if (noCrumpsLeft ()) {  			GhostSoundsManager.StopLoops ();  			LockTimer = TimeSpan.FromSeconds (2);  			return;  		}  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: if (Grid.TileGrid [playerTile.X' playerTile.Y].HasCrump) {  	soundBank_.PlayCue (paChomp_ ? "PacMAnEat1" : "PacManEat2");  	paChomp_ = !paChomp_;  	Score += 10;  	Grid.TileGrid [playerTile.X' playerTile.Y].HasCrump = false;  	if (Grid.TileGrid [playerTile.X' playerTile.Y].HasPowerPill) {  		Score += 40;  		eatenGhosts_ = 0;  		for (int i = 0; i < ghosts_.Count; i++) {  			if (ghosts_ [i].State == GhostState.Attack || ghosts_ [i].State == GhostState.Scatter || ghosts_ [i].State == GhostState.Blue) {  				ghosts_ [i].State = GhostState.Blue;  			}  		}  		Grid.TileGrid [playerTile.X' playerTile.Y].HasPowerPill = false;  	}  	// If that was the last crump' lock the game for a while  	if (noCrumpsLeft ()) {  		GhostSoundsManager.StopLoops ();  		LockTimer = TimeSpan.FromSeconds (2);  		return;  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: if (Grid.TileGrid [playerTile.X' playerTile.Y].HasCrump) {  	soundBank_.PlayCue (paChomp_ ? "PacMAnEat1" : "PacManEat2");  	paChomp_ = !paChomp_;  	Score += 10;  	Grid.TileGrid [playerTile.X' playerTile.Y].HasCrump = false;  	if (Grid.TileGrid [playerTile.X' playerTile.Y].HasPowerPill) {  		Score += 40;  		eatenGhosts_ = 0;  		for (int i = 0; i < ghosts_.Count; i++) {  			if (ghosts_ [i].State == GhostState.Attack || ghosts_ [i].State == GhostState.Scatter || ghosts_ [i].State == GhostState.Blue) {  				ghosts_ [i].State = GhostState.Blue;  			}  		}  		Grid.TileGrid [playerTile.X' playerTile.Y].HasPowerPill = false;  	}  	// If that was the last crump' lock the game for a while  	if (noCrumpsLeft ()) {  		GhostSoundsManager.StopLoops ();  		LockTimer = TimeSpan.FromSeconds (2);  		return;  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: if (Grid.TileGrid [playerTile.X' playerTile.Y].HasCrump) {  	soundBank_.PlayCue (paChomp_ ? "PacMAnEat1" : "PacManEat2");  	paChomp_ = !paChomp_;  	Score += 10;  	Grid.TileGrid [playerTile.X' playerTile.Y].HasCrump = false;  	if (Grid.TileGrid [playerTile.X' playerTile.Y].HasPowerPill) {  		Score += 40;  		eatenGhosts_ = 0;  		for (int i = 0; i < ghosts_.Count; i++) {  			if (ghosts_ [i].State == GhostState.Attack || ghosts_ [i].State == GhostState.Scatter || ghosts_ [i].State == GhostState.Blue) {  				ghosts_ [i].State = GhostState.Blue;  			}  		}  		Grid.TileGrid [playerTile.X' playerTile.Y].HasPowerPill = false;  	}  	// If that was the last crump' lock the game for a while  	if (noCrumpsLeft ()) {  		GhostSoundsManager.StopLoops ();  		LockTimer = TimeSpan.FromSeconds (2);  		return;  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: Score += 10;  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: if (Grid.TileGrid [playerTile.X' playerTile.Y].HasPowerPill) {  	Score += 40;  	eatenGhosts_ = 0;  	for (int i = 0; i < ghosts_.Count; i++) {  		if (ghosts_ [i].State == GhostState.Attack || ghosts_ [i].State == GhostState.Scatter || ghosts_ [i].State == GhostState.Blue) {  			ghosts_ [i].State = GhostState.Blue;  		}  	}  	Grid.TileGrid [playerTile.X' playerTile.Y].HasPowerPill = false;  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: Score += 40;  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: if (noCrumpsLeft ()) {  	GhostSoundsManager.StopLoops ();  	LockTimer = TimeSpan.FromSeconds (2);  	return;  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: LockTimer = TimeSpan.FromSeconds (2);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: if (bonusPresent_ && player_.Position.Tile.Y == 17 && ((player_.Position.Tile.X == 13 && player_.Position.DeltaPixel.X == 8) || (player_.Position.Tile.X == 14 && player_.Position.DeltaPixel.X == -8))) {  	LockTimer = TimeSpan.FromSeconds (1.5);  	Score += Constants.BonusScores ();  	scoreEvents_.Add (new ScoreEvent (player_.Position' DateTime.Now' Constants.BonusScores ()));  	soundBank_.PlayCue ("fruiteat");  	bonusPresent_ = false;  	if (bonusEaten_.ContainsKey (Constants.BonusSprite ())) {  		bonusEaten_ [Constants.BonusSprite ()]++;  	} else {  		bonusEaten_.Add (Constants.BonusSprite ()' 1);  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: if (bonusPresent_ && player_.Position.Tile.Y == 17 && ((player_.Position.Tile.X == 13 && player_.Position.DeltaPixel.X == 8) || (player_.Position.Tile.X == 14 && player_.Position.DeltaPixel.X == -8))) {  	LockTimer = TimeSpan.FromSeconds (1.5);  	Score += Constants.BonusScores ();  	scoreEvents_.Add (new ScoreEvent (player_.Position' DateTime.Now' Constants.BonusScores ()));  	soundBank_.PlayCue ("fruiteat");  	bonusPresent_ = false;  	if (bonusEaten_.ContainsKey (Constants.BonusSprite ())) {  		bonusEaten_ [Constants.BonusSprite ()]++;  	} else {  		bonusEaten_.Add (Constants.BonusSprite ()' 1);  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: if (bonusPresent_ && player_.Position.Tile.Y == 17 && ((player_.Position.Tile.X == 13 && player_.Position.DeltaPixel.X == 8) || (player_.Position.Tile.X == 14 && player_.Position.DeltaPixel.X == -8))) {  	LockTimer = TimeSpan.FromSeconds (1.5);  	Score += Constants.BonusScores ();  	scoreEvents_.Add (new ScoreEvent (player_.Position' DateTime.Now' Constants.BonusScores ()));  	soundBank_.PlayCue ("fruiteat");  	bonusPresent_ = false;  	if (bonusEaten_.ContainsKey (Constants.BonusSprite ())) {  		bonusEaten_ [Constants.BonusSprite ()]++;  	} else {  		bonusEaten_.Add (Constants.BonusSprite ()' 1);  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: if (bonusPresent_ && player_.Position.Tile.Y == 17 && ((player_.Position.Tile.X == 13 && player_.Position.DeltaPixel.X == 8) || (player_.Position.Tile.X == 14 && player_.Position.DeltaPixel.X == -8))) {  	LockTimer = TimeSpan.FromSeconds (1.5);  	Score += Constants.BonusScores ();  	scoreEvents_.Add (new ScoreEvent (player_.Position' DateTime.Now' Constants.BonusScores ()));  	soundBank_.PlayCue ("fruiteat");  	bonusPresent_ = false;  	if (bonusEaten_.ContainsKey (Constants.BonusSprite ())) {  		bonusEaten_ [Constants.BonusSprite ()]++;  	} else {  		bonusEaten_.Add (Constants.BonusSprite ()' 1);  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: if (bonusPresent_ && player_.Position.Tile.Y == 17 && ((player_.Position.Tile.X == 13 && player_.Position.DeltaPixel.X == 8) || (player_.Position.Tile.X == 14 && player_.Position.DeltaPixel.X == -8))) {  	LockTimer = TimeSpan.FromSeconds (1.5);  	Score += Constants.BonusScores ();  	scoreEvents_.Add (new ScoreEvent (player_.Position' DateTime.Now' Constants.BonusScores ()));  	soundBank_.PlayCue ("fruiteat");  	bonusPresent_ = false;  	if (bonusEaten_.ContainsKey (Constants.BonusSprite ())) {  		bonusEaten_ [Constants.BonusSprite ()]++;  	} else {  		bonusEaten_.Add (Constants.BonusSprite ()' 1);  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: if (bonusPresent_ && player_.Position.Tile.Y == 17 && ((player_.Position.Tile.X == 13 && player_.Position.DeltaPixel.X == 8) || (player_.Position.Tile.X == 14 && player_.Position.DeltaPixel.X == -8))) {  	LockTimer = TimeSpan.FromSeconds (1.5);  	Score += Constants.BonusScores ();  	scoreEvents_.Add (new ScoreEvent (player_.Position' DateTime.Now' Constants.BonusScores ()));  	soundBank_.PlayCue ("fruiteat");  	bonusPresent_ = false;  	if (bonusEaten_.ContainsKey (Constants.BonusSprite ())) {  		bonusEaten_ [Constants.BonusSprite ()]++;  	} else {  		bonusEaten_.Add (Constants.BonusSprite ()' 1);  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: LockTimer = TimeSpan.FromSeconds (1.5);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: if (bonusPresent_ && ((DateTime.Now - bonusSpawnedTime_) > TimeSpan.FromSeconds (10))) {  	bonusPresent_ = false;  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: foreach (Ghost ghost in ghosts_) {  	Rectangle playerArea = new Rectangle ((player_.Position.Tile.X * 16) + player_.Position.DeltaPixel.X' (player_.Position.Tile.Y * 16) + player_.Position.DeltaPixel.Y' 26' 26);  	Rectangle ghostArea = new Rectangle ((ghost.Position.Tile.X * 16) + ghost.Position.DeltaPixel.X' (ghost.Position.Tile.Y * 16) + ghost.Position.DeltaPixel.Y' 22' 22);  	if (!Rectangle.Intersect (playerArea' ghostArea).IsEmpty) {  		// If collision detected' either kill the ghost or kill the pac man' depending on state.  		if (ghost.State == GhostState.Blue) {  			GhostSoundsManager.StopLoops ();  			soundBank_.PlayCue ("EatGhost");  			ghost.State = GhostState.Dead;  			eatenGhosts_++;  			int bonus = (int)(100 * Math.Pow (2' eatenGhosts_));  			Score += bonus;  			scoreEvents_.Add (new ScoreEvent (ghost.Position' DateTime.Now' bonus));  			LockTimer = TimeSpan.FromMilliseconds (900);  			return;  		} else if (ghost.State != GhostState.Dead) {  			KillPacMan ();  			return;  		}  		// Otherwise ( = the ghost is dead)' don't do anything special.  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: foreach (Ghost ghost in ghosts_) {  	Rectangle playerArea = new Rectangle ((player_.Position.Tile.X * 16) + player_.Position.DeltaPixel.X' (player_.Position.Tile.Y * 16) + player_.Position.DeltaPixel.Y' 26' 26);  	Rectangle ghostArea = new Rectangle ((ghost.Position.Tile.X * 16) + ghost.Position.DeltaPixel.X' (ghost.Position.Tile.Y * 16) + ghost.Position.DeltaPixel.Y' 22' 22);  	if (!Rectangle.Intersect (playerArea' ghostArea).IsEmpty) {  		// If collision detected' either kill the ghost or kill the pac man' depending on state.  		if (ghost.State == GhostState.Blue) {  			GhostSoundsManager.StopLoops ();  			soundBank_.PlayCue ("EatGhost");  			ghost.State = GhostState.Dead;  			eatenGhosts_++;  			int bonus = (int)(100 * Math.Pow (2' eatenGhosts_));  			Score += bonus;  			scoreEvents_.Add (new ScoreEvent (ghost.Position' DateTime.Now' bonus));  			LockTimer = TimeSpan.FromMilliseconds (900);  			return;  		} else if (ghost.State != GhostState.Dead) {  			KillPacMan ();  			return;  		}  		// Otherwise ( = the ghost is dead)' don't do anything special.  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: foreach (Ghost ghost in ghosts_) {  	Rectangle playerArea = new Rectangle ((player_.Position.Tile.X * 16) + player_.Position.DeltaPixel.X' (player_.Position.Tile.Y * 16) + player_.Position.DeltaPixel.Y' 26' 26);  	Rectangle ghostArea = new Rectangle ((ghost.Position.Tile.X * 16) + ghost.Position.DeltaPixel.X' (ghost.Position.Tile.Y * 16) + ghost.Position.DeltaPixel.Y' 22' 22);  	if (!Rectangle.Intersect (playerArea' ghostArea).IsEmpty) {  		// If collision detected' either kill the ghost or kill the pac man' depending on state.  		if (ghost.State == GhostState.Blue) {  			GhostSoundsManager.StopLoops ();  			soundBank_.PlayCue ("EatGhost");  			ghost.State = GhostState.Dead;  			eatenGhosts_++;  			int bonus = (int)(100 * Math.Pow (2' eatenGhosts_));  			Score += bonus;  			scoreEvents_.Add (new ScoreEvent (ghost.Position' DateTime.Now' bonus));  			LockTimer = TimeSpan.FromMilliseconds (900);  			return;  		} else if (ghost.State != GhostState.Dead) {  			KillPacMan ();  			return;  		}  		// Otherwise ( = the ghost is dead)' don't do anything special.  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: foreach (Ghost ghost in ghosts_) {  	Rectangle playerArea = new Rectangle ((player_.Position.Tile.X * 16) + player_.Position.DeltaPixel.X' (player_.Position.Tile.Y * 16) + player_.Position.DeltaPixel.Y' 26' 26);  	Rectangle ghostArea = new Rectangle ((ghost.Position.Tile.X * 16) + ghost.Position.DeltaPixel.X' (ghost.Position.Tile.Y * 16) + ghost.Position.DeltaPixel.Y' 22' 22);  	if (!Rectangle.Intersect (playerArea' ghostArea).IsEmpty) {  		// If collision detected' either kill the ghost or kill the pac man' depending on state.  		if (ghost.State == GhostState.Blue) {  			GhostSoundsManager.StopLoops ();  			soundBank_.PlayCue ("EatGhost");  			ghost.State = GhostState.Dead;  			eatenGhosts_++;  			int bonus = (int)(100 * Math.Pow (2' eatenGhosts_));  			Score += bonus;  			scoreEvents_.Add (new ScoreEvent (ghost.Position' DateTime.Now' bonus));  			LockTimer = TimeSpan.FromMilliseconds (900);  			return;  		} else if (ghost.State != GhostState.Dead) {  			KillPacMan ();  			return;  		}  		// Otherwise ( = the ghost is dead)' don't do anything special.  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: foreach (Ghost ghost in ghosts_) {  	Rectangle playerArea = new Rectangle ((player_.Position.Tile.X * 16) + player_.Position.DeltaPixel.X' (player_.Position.Tile.Y * 16) + player_.Position.DeltaPixel.Y' 26' 26);  	Rectangle ghostArea = new Rectangle ((ghost.Position.Tile.X * 16) + ghost.Position.DeltaPixel.X' (ghost.Position.Tile.Y * 16) + ghost.Position.DeltaPixel.Y' 22' 22);  	if (!Rectangle.Intersect (playerArea' ghostArea).IsEmpty) {  		// If collision detected' either kill the ghost or kill the pac man' depending on state.  		if (ghost.State == GhostState.Blue) {  			GhostSoundsManager.StopLoops ();  			soundBank_.PlayCue ("EatGhost");  			ghost.State = GhostState.Dead;  			eatenGhosts_++;  			int bonus = (int)(100 * Math.Pow (2' eatenGhosts_));  			Score += bonus;  			scoreEvents_.Add (new ScoreEvent (ghost.Position' DateTime.Now' bonus));  			LockTimer = TimeSpan.FromMilliseconds (900);  			return;  		} else if (ghost.State != GhostState.Dead) {  			KillPacMan ();  			return;  		}  		// Otherwise ( = the ghost is dead)' don't do anything special.  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: foreach (Ghost ghost in ghosts_) {  	Rectangle playerArea = new Rectangle ((player_.Position.Tile.X * 16) + player_.Position.DeltaPixel.X' (player_.Position.Tile.Y * 16) + player_.Position.DeltaPixel.Y' 26' 26);  	Rectangle ghostArea = new Rectangle ((ghost.Position.Tile.X * 16) + ghost.Position.DeltaPixel.X' (ghost.Position.Tile.Y * 16) + ghost.Position.DeltaPixel.Y' 22' 22);  	if (!Rectangle.Intersect (playerArea' ghostArea).IsEmpty) {  		// If collision detected' either kill the ghost or kill the pac man' depending on state.  		if (ghost.State == GhostState.Blue) {  			GhostSoundsManager.StopLoops ();  			soundBank_.PlayCue ("EatGhost");  			ghost.State = GhostState.Dead;  			eatenGhosts_++;  			int bonus = (int)(100 * Math.Pow (2' eatenGhosts_));  			Score += bonus;  			scoreEvents_.Add (new ScoreEvent (ghost.Position' DateTime.Now' bonus));  			LockTimer = TimeSpan.FromMilliseconds (900);  			return;  		} else if (ghost.State != GhostState.Dead) {  			KillPacMan ();  			return;  		}  		// Otherwise ( = the ghost is dead)' don't do anything special.  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: foreach (Ghost ghost in ghosts_) {  	Rectangle playerArea = new Rectangle ((player_.Position.Tile.X * 16) + player_.Position.DeltaPixel.X' (player_.Position.Tile.Y * 16) + player_.Position.DeltaPixel.Y' 26' 26);  	Rectangle ghostArea = new Rectangle ((ghost.Position.Tile.X * 16) + ghost.Position.DeltaPixel.X' (ghost.Position.Tile.Y * 16) + ghost.Position.DeltaPixel.Y' 22' 22);  	if (!Rectangle.Intersect (playerArea' ghostArea).IsEmpty) {  		// If collision detected' either kill the ghost or kill the pac man' depending on state.  		if (ghost.State == GhostState.Blue) {  			GhostSoundsManager.StopLoops ();  			soundBank_.PlayCue ("EatGhost");  			ghost.State = GhostState.Dead;  			eatenGhosts_++;  			int bonus = (int)(100 * Math.Pow (2' eatenGhosts_));  			Score += bonus;  			scoreEvents_.Add (new ScoreEvent (ghost.Position' DateTime.Now' bonus));  			LockTimer = TimeSpan.FromMilliseconds (900);  			return;  		} else if (ghost.State != GhostState.Dead) {  			KillPacMan ();  			return;  		}  		// Otherwise ( = the ghost is dead)' don't do anything special.  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: foreach (Ghost ghost in ghosts_) {  	Rectangle playerArea = new Rectangle ((player_.Position.Tile.X * 16) + player_.Position.DeltaPixel.X' (player_.Position.Tile.Y * 16) + player_.Position.DeltaPixel.Y' 26' 26);  	Rectangle ghostArea = new Rectangle ((ghost.Position.Tile.X * 16) + ghost.Position.DeltaPixel.X' (ghost.Position.Tile.Y * 16) + ghost.Position.DeltaPixel.Y' 22' 22);  	if (!Rectangle.Intersect (playerArea' ghostArea).IsEmpty) {  		// If collision detected' either kill the ghost or kill the pac man' depending on state.  		if (ghost.State == GhostState.Blue) {  			GhostSoundsManager.StopLoops ();  			soundBank_.PlayCue ("EatGhost");  			ghost.State = GhostState.Dead;  			eatenGhosts_++;  			int bonus = (int)(100 * Math.Pow (2' eatenGhosts_));  			Score += bonus;  			scoreEvents_.Add (new ScoreEvent (ghost.Position' DateTime.Now' bonus));  			LockTimer = TimeSpan.FromMilliseconds (900);  			return;  		} else if (ghost.State != GhostState.Dead) {  			KillPacMan ();  			return;  		}  		// Otherwise ( = the ghost is dead)' don't do anything special.  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: foreach (Ghost ghost in ghosts_) {  	Rectangle playerArea = new Rectangle ((player_.Position.Tile.X * 16) + player_.Position.DeltaPixel.X' (player_.Position.Tile.Y * 16) + player_.Position.DeltaPixel.Y' 26' 26);  	Rectangle ghostArea = new Rectangle ((ghost.Position.Tile.X * 16) + ghost.Position.DeltaPixel.X' (ghost.Position.Tile.Y * 16) + ghost.Position.DeltaPixel.Y' 22' 22);  	if (!Rectangle.Intersect (playerArea' ghostArea).IsEmpty) {  		// If collision detected' either kill the ghost or kill the pac man' depending on state.  		if (ghost.State == GhostState.Blue) {  			GhostSoundsManager.StopLoops ();  			soundBank_.PlayCue ("EatGhost");  			ghost.State = GhostState.Dead;  			eatenGhosts_++;  			int bonus = (int)(100 * Math.Pow (2' eatenGhosts_));  			Score += bonus;  			scoreEvents_.Add (new ScoreEvent (ghost.Position' DateTime.Now' bonus));  			LockTimer = TimeSpan.FromMilliseconds (900);  			return;  		} else if (ghost.State != GhostState.Dead) {  			KillPacMan ();  			return;  		}  		// Otherwise ( = the ghost is dead)' don't do anything special.  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: foreach (Ghost ghost in ghosts_) {  	Rectangle playerArea = new Rectangle ((player_.Position.Tile.X * 16) + player_.Position.DeltaPixel.X' (player_.Position.Tile.Y * 16) + player_.Position.DeltaPixel.Y' 26' 26);  	Rectangle ghostArea = new Rectangle ((ghost.Position.Tile.X * 16) + ghost.Position.DeltaPixel.X' (ghost.Position.Tile.Y * 16) + ghost.Position.DeltaPixel.Y' 22' 22);  	if (!Rectangle.Intersect (playerArea' ghostArea).IsEmpty) {  		// If collision detected' either kill the ghost or kill the pac man' depending on state.  		if (ghost.State == GhostState.Blue) {  			GhostSoundsManager.StopLoops ();  			soundBank_.PlayCue ("EatGhost");  			ghost.State = GhostState.Dead;  			eatenGhosts_++;  			int bonus = (int)(100 * Math.Pow (2' eatenGhosts_));  			Score += bonus;  			scoreEvents_.Add (new ScoreEvent (ghost.Position' DateTime.Now' bonus));  			LockTimer = TimeSpan.FromMilliseconds (900);  			return;  		} else if (ghost.State != GhostState.Dead) {  			KillPacMan ();  			return;  		}  		// Otherwise ( = the ghost is dead)' don't do anything special.  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: foreach (Ghost ghost in ghosts_) {  	Rectangle playerArea = new Rectangle ((player_.Position.Tile.X * 16) + player_.Position.DeltaPixel.X' (player_.Position.Tile.Y * 16) + player_.Position.DeltaPixel.Y' 26' 26);  	Rectangle ghostArea = new Rectangle ((ghost.Position.Tile.X * 16) + ghost.Position.DeltaPixel.X' (ghost.Position.Tile.Y * 16) + ghost.Position.DeltaPixel.Y' 22' 22);  	if (!Rectangle.Intersect (playerArea' ghostArea).IsEmpty) {  		// If collision detected' either kill the ghost or kill the pac man' depending on state.  		if (ghost.State == GhostState.Blue) {  			GhostSoundsManager.StopLoops ();  			soundBank_.PlayCue ("EatGhost");  			ghost.State = GhostState.Dead;  			eatenGhosts_++;  			int bonus = (int)(100 * Math.Pow (2' eatenGhosts_));  			Score += bonus;  			scoreEvents_.Add (new ScoreEvent (ghost.Position' DateTime.Now' bonus));  			LockTimer = TimeSpan.FromMilliseconds (900);  			return;  		} else if (ghost.State != GhostState.Dead) {  			KillPacMan ();  			return;  		}  		// Otherwise ( = the ghost is dead)' don't do anything special.  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: if (!Rectangle.Intersect (playerArea' ghostArea).IsEmpty) {  	// If collision detected' either kill the ghost or kill the pac man' depending on state.  	if (ghost.State == GhostState.Blue) {  		GhostSoundsManager.StopLoops ();  		soundBank_.PlayCue ("EatGhost");  		ghost.State = GhostState.Dead;  		eatenGhosts_++;  		int bonus = (int)(100 * Math.Pow (2' eatenGhosts_));  		Score += bonus;  		scoreEvents_.Add (new ScoreEvent (ghost.Position' DateTime.Now' bonus));  		LockTimer = TimeSpan.FromMilliseconds (900);  		return;  	} else if (ghost.State != GhostState.Dead) {  		KillPacMan ();  		return;  	}  	// Otherwise ( = the ghost is dead)' don't do anything special.  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: if (!Rectangle.Intersect (playerArea' ghostArea).IsEmpty) {  	// If collision detected' either kill the ghost or kill the pac man' depending on state.  	if (ghost.State == GhostState.Blue) {  		GhostSoundsManager.StopLoops ();  		soundBank_.PlayCue ("EatGhost");  		ghost.State = GhostState.Dead;  		eatenGhosts_++;  		int bonus = (int)(100 * Math.Pow (2' eatenGhosts_));  		Score += bonus;  		scoreEvents_.Add (new ScoreEvent (ghost.Position' DateTime.Now' bonus));  		LockTimer = TimeSpan.FromMilliseconds (900);  		return;  	} else if (ghost.State != GhostState.Dead) {  		KillPacMan ();  		return;  	}  	// Otherwise ( = the ghost is dead)' don't do anything special.  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: if (!Rectangle.Intersect (playerArea' ghostArea).IsEmpty) {  	// If collision detected' either kill the ghost or kill the pac man' depending on state.  	if (ghost.State == GhostState.Blue) {  		GhostSoundsManager.StopLoops ();  		soundBank_.PlayCue ("EatGhost");  		ghost.State = GhostState.Dead;  		eatenGhosts_++;  		int bonus = (int)(100 * Math.Pow (2' eatenGhosts_));  		Score += bonus;  		scoreEvents_.Add (new ScoreEvent (ghost.Position' DateTime.Now' bonus));  		LockTimer = TimeSpan.FromMilliseconds (900);  		return;  	} else if (ghost.State != GhostState.Dead) {  		KillPacMan ();  		return;  	}  	// Otherwise ( = the ghost is dead)' don't do anything special.  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: if (ghost.State == GhostState.Blue) {  	GhostSoundsManager.StopLoops ();  	soundBank_.PlayCue ("EatGhost");  	ghost.State = GhostState.Dead;  	eatenGhosts_++;  	int bonus = (int)(100 * Math.Pow (2' eatenGhosts_));  	Score += bonus;  	scoreEvents_.Add (new ScoreEvent (ghost.Position' DateTime.Now' bonus));  	LockTimer = TimeSpan.FromMilliseconds (900);  	return;  } else if (ghost.State != GhostState.Dead) {  	KillPacMan ();  	return;  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: if (ghost.State == GhostState.Blue) {  	GhostSoundsManager.StopLoops ();  	soundBank_.PlayCue ("EatGhost");  	ghost.State = GhostState.Dead;  	eatenGhosts_++;  	int bonus = (int)(100 * Math.Pow (2' eatenGhosts_));  	Score += bonus;  	scoreEvents_.Add (new ScoreEvent (ghost.Position' DateTime.Now' bonus));  	LockTimer = TimeSpan.FromMilliseconds (900);  	return;  } else if (ghost.State != GhostState.Dead) {  	KillPacMan ();  	return;  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: if (ghost.State == GhostState.Blue) {  	GhostSoundsManager.StopLoops ();  	soundBank_.PlayCue ("EatGhost");  	ghost.State = GhostState.Dead;  	eatenGhosts_++;  	int bonus = (int)(100 * Math.Pow (2' eatenGhosts_));  	Score += bonus;  	scoreEvents_.Add (new ScoreEvent (ghost.Position' DateTime.Now' bonus));  	LockTimer = TimeSpan.FromMilliseconds (900);  	return;  } else if (ghost.State != GhostState.Dead) {  	KillPacMan ();  	return;  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: LockTimer = TimeSpan.FromMilliseconds (900);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: if ((Grid.NumCrumps == 180 || Grid.NumCrumps == 80) && bonusSpawned_ < 2 && !(player_.Position.Tile.Y == 17 && ((player_.Position.Tile.X == 13 && player_.Position.DeltaPixel.X == 8) || (player_.Position.Tile.X == 14 && player_.Position.DeltaPixel.X == -8)))) {  	bonusPresent_ = true;  	bonusSpawned_++;  	bonusSpawnedTime_ = DateTime.Now;  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: if ((Grid.NumCrumps == 180 || Grid.NumCrumps == 80) && bonusSpawned_ < 2 && !(player_.Position.Tile.Y == 17 && ((player_.Position.Tile.X == 13 && player_.Position.DeltaPixel.X == 8) || (player_.Position.Tile.X == 14 && player_.Position.DeltaPixel.X == -8)))) {  	bonusPresent_ = true;  	bonusSpawned_++;  	bonusSpawnedTime_ = DateTime.Now;  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: if ((Grid.NumCrumps == 180 || Grid.NumCrumps == 80) && bonusSpawned_ < 2 && !(player_.Position.Tile.Y == 17 && ((player_.Position.Tile.X == 13 && player_.Position.DeltaPixel.X == 8) || (player_.Position.Tile.X == 14 && player_.Position.DeltaPixel.X == -8)))) {  	bonusPresent_ = true;  	bonusSpawned_++;  	bonusSpawnedTime_ = DateTime.Now;  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: if ((Grid.NumCrumps == 180 || Grid.NumCrumps == 80) && bonusSpawned_ < 2 && !(player_.Position.Tile.Y == 17 && ((player_.Position.Tile.X == 13 && player_.Position.DeltaPixel.X == 8) || (player_.Position.Tile.X == 14 && player_.Position.DeltaPixel.X == -8)))) {  	bonusPresent_ = true;  	bonusSpawned_++;  	bonusSpawnedTime_ = DateTime.Now;  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: if ((Grid.NumCrumps == 180 || Grid.NumCrumps == 80) && bonusSpawned_ < 2 && !(player_.Position.Tile.Y == 17 && ((player_.Position.Tile.X == 13 && player_.Position.DeltaPixel.X == 8) || (player_.Position.Tile.X == 14 && player_.Position.DeltaPixel.X == -8)))) {  	bonusPresent_ = true;  	bonusSpawned_++;  	bonusSpawnedTime_ = DateTime.Now;  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: if ((Grid.NumCrumps == 180 || Grid.NumCrumps == 80) && bonusSpawned_ < 2 && !(player_.Position.Tile.Y == 17 && ((player_.Position.Tile.X == 13 && player_.Position.DeltaPixel.X == 8) || (player_.Position.Tile.X == 14 && player_.Position.DeltaPixel.X == -8)))) {  	bonusPresent_ = true;  	bonusSpawned_++;  	bonusSpawnedTime_ = DateTime.Now;  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: if ((Grid.NumCrumps == 180 || Grid.NumCrumps == 80) && bonusSpawned_ < 2 && !(player_.Position.Tile.Y == 17 && ((player_.Position.Tile.X == 13 && player_.Position.DeltaPixel.X == 8) || (player_.Position.Tile.X == 14 && player_.Position.DeltaPixel.X == -8)))) {  	bonusPresent_ = true;  	bonusSpawned_++;  	bonusSpawnedTime_ = DateTime.Now;  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: if ((Grid.NumCrumps == 180 || Grid.NumCrumps == 80) && bonusSpawned_ < 2 && !(player_.Position.Tile.Y == 17 && ((player_.Position.Tile.X == 13 && player_.Position.DeltaPixel.X == 8) || (player_.Position.Tile.X == 14 && player_.Position.DeltaPixel.X == -8)))) {  	bonusPresent_ = true;  	bonusSpawned_++;  	bonusSpawnedTime_ = DateTime.Now;  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,KillPacMan,The following statement contains a magic number: LockTimer = TimeSpan.FromMilliseconds (1811);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: if (noCrumpsLeft ()) {  	spriteBatch_.Draw (((DateTime.Now.Second * 1000 + DateTime.Now.Millisecond) / 350) % 2 == 0 ? board_ : boardFlash_' boardPosition' Color.White);  	player_.Draw (gameTime' boardPosition);  	spriteBatch_.End ();  	return;  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: if (noCrumpsLeft ()) {  	spriteBatch_.Draw (((DateTime.Now.Second * 1000 + DateTime.Now.Millisecond) / 350) % 2 == 0 ? board_ : boardFlash_' boardPosition' Color.White);  	player_.Draw (gameTime' boardPosition);  	spriteBatch_.End ();  	return;  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: if (noCrumpsLeft ()) {  	spriteBatch_.Draw (((DateTime.Now.Second * 1000 + DateTime.Now.Millisecond) / 350) % 2 == 0 ? board_ : boardFlash_' boardPosition' Color.White);  	player_.Draw (gameTime' boardPosition);  	spriteBatch_.End ();  	return;  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw (((DateTime.Now.Second * 1000 + DateTime.Now.Millisecond) / 350) % 2 == 0 ? board_ : boardFlash_' boardPosition' Color.White);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw (((DateTime.Now.Second * 1000 + DateTime.Now.Millisecond) / 350) % 2 == 0 ? board_ : boardFlash_' boardPosition' Color.White);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw (((DateTime.Now.Second * 1000 + DateTime.Now.Millisecond) / 350) % 2 == 0 ? board_ : boardFlash_' boardPosition' Color.White);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: for (int j = 0; j < Grid.Height; j++) {  	for (int i = 0; i < Grid.Width; i++) {  		if (tiles [i' j].HasPowerPill) {  			spriteBatch_.Draw (ppill_' new Vector2 (boardPosition.X + 3 + (i * 16)' boardPosition.Y + 3 + (j * 16))' Color.White);  		} else if (tiles [i' j].HasCrump) {  			spriteBatch_.Draw (crump_' new Vector2 (boardPosition.X + 5 + (i * 16)' boardPosition.Y + 5 + (j * 16))' Color.White);  		}  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: for (int j = 0; j < Grid.Height; j++) {  	for (int i = 0; i < Grid.Width; i++) {  		if (tiles [i' j].HasPowerPill) {  			spriteBatch_.Draw (ppill_' new Vector2 (boardPosition.X + 3 + (i * 16)' boardPosition.Y + 3 + (j * 16))' Color.White);  		} else if (tiles [i' j].HasCrump) {  			spriteBatch_.Draw (crump_' new Vector2 (boardPosition.X + 5 + (i * 16)' boardPosition.Y + 5 + (j * 16))' Color.White);  		}  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: for (int j = 0; j < Grid.Height; j++) {  	for (int i = 0; i < Grid.Width; i++) {  		if (tiles [i' j].HasPowerPill) {  			spriteBatch_.Draw (ppill_' new Vector2 (boardPosition.X + 3 + (i * 16)' boardPosition.Y + 3 + (j * 16))' Color.White);  		} else if (tiles [i' j].HasCrump) {  			spriteBatch_.Draw (crump_' new Vector2 (boardPosition.X + 5 + (i * 16)' boardPosition.Y + 5 + (j * 16))' Color.White);  		}  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: for (int j = 0; j < Grid.Height; j++) {  	for (int i = 0; i < Grid.Width; i++) {  		if (tiles [i' j].HasPowerPill) {  			spriteBatch_.Draw (ppill_' new Vector2 (boardPosition.X + 3 + (i * 16)' boardPosition.Y + 3 + (j * 16))' Color.White);  		} else if (tiles [i' j].HasCrump) {  			spriteBatch_.Draw (crump_' new Vector2 (boardPosition.X + 5 + (i * 16)' boardPosition.Y + 5 + (j * 16))' Color.White);  		}  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: for (int j = 0; j < Grid.Height; j++) {  	for (int i = 0; i < Grid.Width; i++) {  		if (tiles [i' j].HasPowerPill) {  			spriteBatch_.Draw (ppill_' new Vector2 (boardPosition.X + 3 + (i * 16)' boardPosition.Y + 3 + (j * 16))' Color.White);  		} else if (tiles [i' j].HasCrump) {  			spriteBatch_.Draw (crump_' new Vector2 (boardPosition.X + 5 + (i * 16)' boardPosition.Y + 5 + (j * 16))' Color.White);  		}  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: for (int j = 0; j < Grid.Height; j++) {  	for (int i = 0; i < Grid.Width; i++) {  		if (tiles [i' j].HasPowerPill) {  			spriteBatch_.Draw (ppill_' new Vector2 (boardPosition.X + 3 + (i * 16)' boardPosition.Y + 3 + (j * 16))' Color.White);  		} else if (tiles [i' j].HasCrump) {  			spriteBatch_.Draw (crump_' new Vector2 (boardPosition.X + 5 + (i * 16)' boardPosition.Y + 5 + (j * 16))' Color.White);  		}  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: for (int j = 0; j < Grid.Height; j++) {  	for (int i = 0; i < Grid.Width; i++) {  		if (tiles [i' j].HasPowerPill) {  			spriteBatch_.Draw (ppill_' new Vector2 (boardPosition.X + 3 + (i * 16)' boardPosition.Y + 3 + (j * 16))' Color.White);  		} else if (tiles [i' j].HasCrump) {  			spriteBatch_.Draw (crump_' new Vector2 (boardPosition.X + 5 + (i * 16)' boardPosition.Y + 5 + (j * 16))' Color.White);  		}  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: for (int j = 0; j < Grid.Height; j++) {  	for (int i = 0; i < Grid.Width; i++) {  		if (tiles [i' j].HasPowerPill) {  			spriteBatch_.Draw (ppill_' new Vector2 (boardPosition.X + 3 + (i * 16)' boardPosition.Y + 3 + (j * 16))' Color.White);  		} else if (tiles [i' j].HasCrump) {  			spriteBatch_.Draw (crump_' new Vector2 (boardPosition.X + 5 + (i * 16)' boardPosition.Y + 5 + (j * 16))' Color.White);  		}  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: for (int i = 0; i < Grid.Width; i++) {  	if (tiles [i' j].HasPowerPill) {  		spriteBatch_.Draw (ppill_' new Vector2 (boardPosition.X + 3 + (i * 16)' boardPosition.Y + 3 + (j * 16))' Color.White);  	} else if (tiles [i' j].HasCrump) {  		spriteBatch_.Draw (crump_' new Vector2 (boardPosition.X + 5 + (i * 16)' boardPosition.Y + 5 + (j * 16))' Color.White);  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: for (int i = 0; i < Grid.Width; i++) {  	if (tiles [i' j].HasPowerPill) {  		spriteBatch_.Draw (ppill_' new Vector2 (boardPosition.X + 3 + (i * 16)' boardPosition.Y + 3 + (j * 16))' Color.White);  	} else if (tiles [i' j].HasCrump) {  		spriteBatch_.Draw (crump_' new Vector2 (boardPosition.X + 5 + (i * 16)' boardPosition.Y + 5 + (j * 16))' Color.White);  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: for (int i = 0; i < Grid.Width; i++) {  	if (tiles [i' j].HasPowerPill) {  		spriteBatch_.Draw (ppill_' new Vector2 (boardPosition.X + 3 + (i * 16)' boardPosition.Y + 3 + (j * 16))' Color.White);  	} else if (tiles [i' j].HasCrump) {  		spriteBatch_.Draw (crump_' new Vector2 (boardPosition.X + 5 + (i * 16)' boardPosition.Y + 5 + (j * 16))' Color.White);  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: for (int i = 0; i < Grid.Width; i++) {  	if (tiles [i' j].HasPowerPill) {  		spriteBatch_.Draw (ppill_' new Vector2 (boardPosition.X + 3 + (i * 16)' boardPosition.Y + 3 + (j * 16))' Color.White);  	} else if (tiles [i' j].HasCrump) {  		spriteBatch_.Draw (crump_' new Vector2 (boardPosition.X + 5 + (i * 16)' boardPosition.Y + 5 + (j * 16))' Color.White);  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: for (int i = 0; i < Grid.Width; i++) {  	if (tiles [i' j].HasPowerPill) {  		spriteBatch_.Draw (ppill_' new Vector2 (boardPosition.X + 3 + (i * 16)' boardPosition.Y + 3 + (j * 16))' Color.White);  	} else if (tiles [i' j].HasCrump) {  		spriteBatch_.Draw (crump_' new Vector2 (boardPosition.X + 5 + (i * 16)' boardPosition.Y + 5 + (j * 16))' Color.White);  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: for (int i = 0; i < Grid.Width; i++) {  	if (tiles [i' j].HasPowerPill) {  		spriteBatch_.Draw (ppill_' new Vector2 (boardPosition.X + 3 + (i * 16)' boardPosition.Y + 3 + (j * 16))' Color.White);  	} else if (tiles [i' j].HasCrump) {  		spriteBatch_.Draw (crump_' new Vector2 (boardPosition.X + 5 + (i * 16)' boardPosition.Y + 5 + (j * 16))' Color.White);  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: for (int i = 0; i < Grid.Width; i++) {  	if (tiles [i' j].HasPowerPill) {  		spriteBatch_.Draw (ppill_' new Vector2 (boardPosition.X + 3 + (i * 16)' boardPosition.Y + 3 + (j * 16))' Color.White);  	} else if (tiles [i' j].HasCrump) {  		spriteBatch_.Draw (crump_' new Vector2 (boardPosition.X + 5 + (i * 16)' boardPosition.Y + 5 + (j * 16))' Color.White);  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: for (int i = 0; i < Grid.Width; i++) {  	if (tiles [i' j].HasPowerPill) {  		spriteBatch_.Draw (ppill_' new Vector2 (boardPosition.X + 3 + (i * 16)' boardPosition.Y + 3 + (j * 16))' Color.White);  	} else if (tiles [i' j].HasCrump) {  		spriteBatch_.Draw (crump_' new Vector2 (boardPosition.X + 5 + (i * 16)' boardPosition.Y + 5 + (j * 16))' Color.White);  	}  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: if (tiles [i' j].HasPowerPill) {  	spriteBatch_.Draw (ppill_' new Vector2 (boardPosition.X + 3 + (i * 16)' boardPosition.Y + 3 + (j * 16))' Color.White);  } else if (tiles [i' j].HasCrump) {  	spriteBatch_.Draw (crump_' new Vector2 (boardPosition.X + 5 + (i * 16)' boardPosition.Y + 5 + (j * 16))' Color.White);  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: if (tiles [i' j].HasPowerPill) {  	spriteBatch_.Draw (ppill_' new Vector2 (boardPosition.X + 3 + (i * 16)' boardPosition.Y + 3 + (j * 16))' Color.White);  } else if (tiles [i' j].HasCrump) {  	spriteBatch_.Draw (crump_' new Vector2 (boardPosition.X + 5 + (i * 16)' boardPosition.Y + 5 + (j * 16))' Color.White);  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: if (tiles [i' j].HasPowerPill) {  	spriteBatch_.Draw (ppill_' new Vector2 (boardPosition.X + 3 + (i * 16)' boardPosition.Y + 3 + (j * 16))' Color.White);  } else if (tiles [i' j].HasCrump) {  	spriteBatch_.Draw (crump_' new Vector2 (boardPosition.X + 5 + (i * 16)' boardPosition.Y + 5 + (j * 16))' Color.White);  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: if (tiles [i' j].HasPowerPill) {  	spriteBatch_.Draw (ppill_' new Vector2 (boardPosition.X + 3 + (i * 16)' boardPosition.Y + 3 + (j * 16))' Color.White);  } else if (tiles [i' j].HasCrump) {  	spriteBatch_.Draw (crump_' new Vector2 (boardPosition.X + 5 + (i * 16)' boardPosition.Y + 5 + (j * 16))' Color.White);  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: if (tiles [i' j].HasPowerPill) {  	spriteBatch_.Draw (ppill_' new Vector2 (boardPosition.X + 3 + (i * 16)' boardPosition.Y + 3 + (j * 16))' Color.White);  } else if (tiles [i' j].HasCrump) {  	spriteBatch_.Draw (crump_' new Vector2 (boardPosition.X + 5 + (i * 16)' boardPosition.Y + 5 + (j * 16))' Color.White);  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: if (tiles [i' j].HasPowerPill) {  	spriteBatch_.Draw (ppill_' new Vector2 (boardPosition.X + 3 + (i * 16)' boardPosition.Y + 3 + (j * 16))' Color.White);  } else if (tiles [i' j].HasCrump) {  	spriteBatch_.Draw (crump_' new Vector2 (boardPosition.X + 5 + (i * 16)' boardPosition.Y + 5 + (j * 16))' Color.White);  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: if (tiles [i' j].HasPowerPill) {  	spriteBatch_.Draw (ppill_' new Vector2 (boardPosition.X + 3 + (i * 16)' boardPosition.Y + 3 + (j * 16))' Color.White);  } else if (tiles [i' j].HasCrump) {  	spriteBatch_.Draw (crump_' new Vector2 (boardPosition.X + 5 + (i * 16)' boardPosition.Y + 5 + (j * 16))' Color.White);  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: if (tiles [i' j].HasPowerPill) {  	spriteBatch_.Draw (ppill_' new Vector2 (boardPosition.X + 3 + (i * 16)' boardPosition.Y + 3 + (j * 16))' Color.White);  } else if (tiles [i' j].HasCrump) {  	spriteBatch_.Draw (crump_' new Vector2 (boardPosition.X + 5 + (i * 16)' boardPosition.Y + 5 + (j * 16))' Color.White);  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw (ppill_' new Vector2 (boardPosition.X + 3 + (i * 16)' boardPosition.Y + 3 + (j * 16))' Color.White);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw (ppill_' new Vector2 (boardPosition.X + 3 + (i * 16)' boardPosition.Y + 3 + (j * 16))' Color.White);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw (ppill_' new Vector2 (boardPosition.X + 3 + (i * 16)' boardPosition.Y + 3 + (j * 16))' Color.White);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw (ppill_' new Vector2 (boardPosition.X + 3 + (i * 16)' boardPosition.Y + 3 + (j * 16))' Color.White);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: if (tiles [i' j].HasCrump) {  	spriteBatch_.Draw (crump_' new Vector2 (boardPosition.X + 5 + (i * 16)' boardPosition.Y + 5 + (j * 16))' Color.White);  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: if (tiles [i' j].HasCrump) {  	spriteBatch_.Draw (crump_' new Vector2 (boardPosition.X + 5 + (i * 16)' boardPosition.Y + 5 + (j * 16))' Color.White);  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: if (tiles [i' j].HasCrump) {  	spriteBatch_.Draw (crump_' new Vector2 (boardPosition.X + 5 + (i * 16)' boardPosition.Y + 5 + (j * 16))' Color.White);  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: if (tiles [i' j].HasCrump) {  	spriteBatch_.Draw (crump_' new Vector2 (boardPosition.X + 5 + (i * 16)' boardPosition.Y + 5 + (j * 16))' Color.White);  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw (crump_' new Vector2 (boardPosition.X + 5 + (i * 16)' boardPosition.Y + 5 + (j * 16))' Color.White);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw (crump_' new Vector2 (boardPosition.X + 5 + (i * 16)' boardPosition.Y + 5 + (j * 16))' Color.White);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw (crump_' new Vector2 (boardPosition.X + 5 + (i * 16)' boardPosition.Y + 5 + (j * 16))' Color.White);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw (crump_' new Vector2 (boardPosition.X + 5 + (i * 16)' boardPosition.Y + 5 + (j * 16))' Color.White);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: for (int i = 0; i < xlives_ && i < 20; i++) {  	spriteBatch_.Draw (xlife_' new Vector2 (boardPosition.X + 10 + (20 * i)' board_.Height + boardPosition.Y + 10)' Color.White);  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: for (int i = 0; i < xlives_ && i < 20; i++) {  	spriteBatch_.Draw (xlife_' new Vector2 (boardPosition.X + 10 + (20 * i)' board_.Height + boardPosition.Y + 10)' Color.White);  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: for (int i = 0; i < xlives_ && i < 20; i++) {  	spriteBatch_.Draw (xlife_' new Vector2 (boardPosition.X + 10 + (20 * i)' board_.Height + boardPosition.Y + 10)' Color.White);  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: for (int i = 0; i < xlives_ && i < 20; i++) {  	spriteBatch_.Draw (xlife_' new Vector2 (boardPosition.X + 10 + (20 * i)' board_.Height + boardPosition.Y + 10)' Color.White);  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw (xlife_' new Vector2 (boardPosition.X + 10 + (20 * i)' board_.Height + boardPosition.Y + 10)' Color.White);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw (xlife_' new Vector2 (boardPosition.X + 10 + (20 * i)' board_.Height + boardPosition.Y + 10)' Color.White);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw (xlife_' new Vector2 (boardPosition.X + 10 + (20 * i)' board_.Height + boardPosition.Y + 10)' Color.White);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.DrawString (scoreFont_' "SCORE"' new Vector2 (boardPosition.X + 30' boardPosition.Y - 50)' Color.White);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.DrawString (scoreFont_' "SCORE"' new Vector2 (boardPosition.X + 30' boardPosition.Y - 50)' Color.White);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.DrawString (scoreFont_' Score.ToString ()' new Vector2 (boardPosition.X + 30' boardPosition.Y - 30)' Color.White);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.DrawString (scoreFont_' Score.ToString ()' new Vector2 (boardPosition.X + 30' boardPosition.Y - 30)' Color.White);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.DrawString (scoreFont_' "LEVEL"' new Vector2 (boardPosition.X + board_.Width - 80' boardPosition.Y - 50)' Color.White);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.DrawString (scoreFont_' "LEVEL"' new Vector2 (boardPosition.X + board_.Width - 80' boardPosition.Y - 50)' Color.White);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.DrawString (scoreFont_' Constants.Level.ToString ()' new Vector2 (boardPosition.X + board_.Width - 80' boardPosition.Y - 30)' Color.White);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.DrawString (scoreFont_' Constants.Level.ToString ()' new Vector2 (boardPosition.X + board_.Width - 80' boardPosition.Y - 30)' Color.White);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: if (bonusPresent_) {  	spriteBatch_.Draw (bonus_ [Constants.BonusSprite ()]' new Vector2 (boardPosition.X + (13 * 16) + 2' boardPosition.Y + (17 * 16) - 8)' Color.White);  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: if (bonusPresent_) {  	spriteBatch_.Draw (bonus_ [Constants.BonusSprite ()]' new Vector2 (boardPosition.X + (13 * 16) + 2' boardPosition.Y + (17 * 16) - 8)' Color.White);  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: if (bonusPresent_) {  	spriteBatch_.Draw (bonus_ [Constants.BonusSprite ()]' new Vector2 (boardPosition.X + (13 * 16) + 2' boardPosition.Y + (17 * 16) - 8)' Color.White);  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: if (bonusPresent_) {  	spriteBatch_.Draw (bonus_ [Constants.BonusSprite ()]' new Vector2 (boardPosition.X + (13 * 16) + 2' boardPosition.Y + (17 * 16) - 8)' Color.White);  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: if (bonusPresent_) {  	spriteBatch_.Draw (bonus_ [Constants.BonusSprite ()]' new Vector2 (boardPosition.X + (13 * 16) + 2' boardPosition.Y + (17 * 16) - 8)' Color.White);  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: if (bonusPresent_) {  	spriteBatch_.Draw (bonus_ [Constants.BonusSprite ()]' new Vector2 (boardPosition.X + (13 * 16) + 2' boardPosition.Y + (17 * 16) - 8)' Color.White);  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw (bonus_ [Constants.BonusSprite ()]' new Vector2 (boardPosition.X + (13 * 16) + 2' boardPosition.Y + (17 * 16) - 8)' Color.White);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw (bonus_ [Constants.BonusSprite ()]' new Vector2 (boardPosition.X + (13 * 16) + 2' boardPosition.Y + (17 * 16) - 8)' Color.White);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw (bonus_ [Constants.BonusSprite ()]' new Vector2 (boardPosition.X + (13 * 16) + 2' boardPosition.Y + (17 * 16) - 8)' Color.White);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw (bonus_ [Constants.BonusSprite ()]' new Vector2 (boardPosition.X + (13 * 16) + 2' boardPosition.Y + (17 * 16) - 8)' Color.White);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw (bonus_ [Constants.BonusSprite ()]' new Vector2 (boardPosition.X + (13 * 16) + 2' boardPosition.Y + (17 * 16) - 8)' Color.White);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw (bonus_ [Constants.BonusSprite ()]' new Vector2 (boardPosition.X + (13 * 16) + 2' boardPosition.Y + (17 * 16) - 8)' Color.White);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: foreach (KeyValuePair<string' int> kvp in bonusEaten_) {  	for (int i = 0; i < kvp.Value; i++) {  		spriteBatch_.Draw (bonus_ [kvp.Key]' new Vector2 (boardPosition.X + 10 + (22 * (k + i))' board_.Height + boardPosition.Y + 22)' Color.White);  	}  	k += kvp.Value;  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: foreach (KeyValuePair<string' int> kvp in bonusEaten_) {  	for (int i = 0; i < kvp.Value; i++) {  		spriteBatch_.Draw (bonus_ [kvp.Key]' new Vector2 (boardPosition.X + 10 + (22 * (k + i))' board_.Height + boardPosition.Y + 22)' Color.White);  	}  	k += kvp.Value;  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: foreach (KeyValuePair<string' int> kvp in bonusEaten_) {  	for (int i = 0; i < kvp.Value; i++) {  		spriteBatch_.Draw (bonus_ [kvp.Key]' new Vector2 (boardPosition.X + 10 + (22 * (k + i))' board_.Height + boardPosition.Y + 22)' Color.White);  	}  	k += kvp.Value;  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: for (int i = 0; i < kvp.Value; i++) {  	spriteBatch_.Draw (bonus_ [kvp.Key]' new Vector2 (boardPosition.X + 10 + (22 * (k + i))' board_.Height + boardPosition.Y + 22)' Color.White);  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: for (int i = 0; i < kvp.Value; i++) {  	spriteBatch_.Draw (bonus_ [kvp.Key]' new Vector2 (boardPosition.X + 10 + (22 * (k + i))' board_.Height + boardPosition.Y + 22)' Color.White);  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: for (int i = 0; i < kvp.Value; i++) {  	spriteBatch_.Draw (bonus_ [kvp.Key]' new Vector2 (boardPosition.X + 10 + (22 * (k + i))' board_.Height + boardPosition.Y + 22)' Color.White);  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw (bonus_ [kvp.Key]' new Vector2 (boardPosition.X + 10 + (22 * (k + i))' board_.Height + boardPosition.Y + 22)' Color.White);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw (bonus_ [kvp.Key]' new Vector2 (boardPosition.X + 10 + (22 * (k + i))' board_.Height + boardPosition.Y + 22)' Color.White);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw (bonus_ [kvp.Key]' new Vector2 (boardPosition.X + 10 + (22 * (k + i))' board_.Height + boardPosition.Y + 22)' Color.White);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: foreach (ScoreEvent se in scoreEvents_) {  	spriteBatch_.DrawString (scoreEventFont_' se.Score.ToString ()' new Vector2 (boardPosition.X + (se.Position.Tile.X * 16) + se.Position.DeltaPixel.X + 4' boardPosition.Y + (se.Position.Tile.Y * 16) + se.Position.DeltaPixel.Y + 4)' Color.White);  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: foreach (ScoreEvent se in scoreEvents_) {  	spriteBatch_.DrawString (scoreEventFont_' se.Score.ToString ()' new Vector2 (boardPosition.X + (se.Position.Tile.X * 16) + se.Position.DeltaPixel.X + 4' boardPosition.Y + (se.Position.Tile.Y * 16) + se.Position.DeltaPixel.Y + 4)' Color.White);  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: foreach (ScoreEvent se in scoreEvents_) {  	spriteBatch_.DrawString (scoreEventFont_' se.Score.ToString ()' new Vector2 (boardPosition.X + (se.Position.Tile.X * 16) + se.Position.DeltaPixel.X + 4' boardPosition.Y + (se.Position.Tile.Y * 16) + se.Position.DeltaPixel.Y + 4)' Color.White);  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: foreach (ScoreEvent se in scoreEvents_) {  	spriteBatch_.DrawString (scoreEventFont_' se.Score.ToString ()' new Vector2 (boardPosition.X + (se.Position.Tile.X * 16) + se.Position.DeltaPixel.X + 4' boardPosition.Y + (se.Position.Tile.Y * 16) + se.Position.DeltaPixel.Y + 4)' Color.White);  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.DrawString (scoreEventFont_' se.Score.ToString ()' new Vector2 (boardPosition.X + (se.Position.Tile.X * 16) + se.Position.DeltaPixel.X + 4' boardPosition.Y + (se.Position.Tile.Y * 16) + se.Position.DeltaPixel.Y + 4)' Color.White);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.DrawString (scoreEventFont_' se.Score.ToString ()' new Vector2 (boardPosition.X + (se.Position.Tile.X * 16) + se.Position.DeltaPixel.X + 4' boardPosition.Y + (se.Position.Tile.Y * 16) + se.Position.DeltaPixel.Y + 4)' Color.White);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.DrawString (scoreEventFont_' se.Score.ToString ()' new Vector2 (boardPosition.X + (se.Position.Tile.X * 16) + se.Position.DeltaPixel.X + 4' boardPosition.Y + (se.Position.Tile.Y * 16) + se.Position.DeltaPixel.Y + 4)' Color.White);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.DrawString (scoreEventFont_' se.Score.ToString ()' new Vector2 (boardPosition.X + (se.Position.Tile.X * 16) + se.Position.DeltaPixel.X + 4' boardPosition.Y + (se.Position.Tile.Y * 16) + se.Position.DeltaPixel.Y + 4)' Color.White);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: if (player_.State == State.Start) {  	spriteBatch_.DrawString (scoreFont_' "GET READY!"' new Vector2 (boardPosition.X + (board_.Width / 2) - 58' boardPosition.Y + 273)' Color.Yellow);  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: if (player_.State == State.Start) {  	spriteBatch_.DrawString (scoreFont_' "GET READY!"' new Vector2 (boardPosition.X + (board_.Width / 2) - 58' boardPosition.Y + 273)' Color.Yellow);  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: if (player_.State == State.Start) {  	spriteBatch_.DrawString (scoreFont_' "GET READY!"' new Vector2 (boardPosition.X + (board_.Width / 2) - 58' boardPosition.Y + 273)' Color.Yellow);  }  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.DrawString (scoreFont_' "GET READY!"' new Vector2 (boardPosition.X + (board_.Width / 2) - 58' boardPosition.Y + 273)' Color.Yellow);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.DrawString (scoreFont_' "GET READY!"' new Vector2 (boardPosition.X + (board_.Width / 2) - 58' boardPosition.Y + 273)' Color.Yellow);  
Magic Number,XNAPacMan,GameLoop,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.DrawString (scoreFont_' "GET READY!"' new Vector2 (boardPosition.X + (board_.Width / 2) - 58' boardPosition.Y + 273)' Color.Yellow);  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Reset,The following statement contains a magic number: scatterModesLeft_ = 4;  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,PlaySound,The following statement contains a magic number: if (State == GhostState.Attack || State == GhostState.Scatter || State == GhostState.Home) {  	if (Grid.NumCrumps < 50) {  		GhostSoundsManager.playLoopAttackVeryFast ();  	} else if (Grid.NumCrumps < 120) {  		GhostSoundsManager.playLoopAttackFast ();  	} else {  		GhostSoundsManager.playLoopAttack ();  	}  } else if (State == GhostState.Blue) {  	GhostSoundsManager.playLoopBlue ();  } else if (State == GhostState.Dead) {  	GhostSoundsManager.playLoopDead ();  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,PlaySound,The following statement contains a magic number: if (State == GhostState.Attack || State == GhostState.Scatter || State == GhostState.Home) {  	if (Grid.NumCrumps < 50) {  		GhostSoundsManager.playLoopAttackVeryFast ();  	} else if (Grid.NumCrumps < 120) {  		GhostSoundsManager.playLoopAttackFast ();  	} else {  		GhostSoundsManager.playLoopAttack ();  	}  } else if (State == GhostState.Blue) {  	GhostSoundsManager.playLoopBlue ();  } else if (State == GhostState.Dead) {  	GhostSoundsManager.playLoopDead ();  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,PlaySound,The following statement contains a magic number: if (Grid.NumCrumps < 50) {  	GhostSoundsManager.playLoopAttackVeryFast ();  } else if (Grid.NumCrumps < 120) {  	GhostSoundsManager.playLoopAttackFast ();  } else {  	GhostSoundsManager.playLoopAttack ();  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,PlaySound,The following statement contains a magic number: if (Grid.NumCrumps < 50) {  	GhostSoundsManager.playLoopAttackVeryFast ();  } else if (Grid.NumCrumps < 120) {  	GhostSoundsManager.playLoopAttackFast ();  } else {  	GhostSoundsManager.playLoopAttack ();  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,PlaySound,The following statement contains a magic number: if (Grid.NumCrumps < 120) {  	GhostSoundsManager.playLoopAttackFast ();  } else {  	GhostSoundsManager.playLoopAttack ();  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: switch (State) {  case GhostState.Home:  	// Ghost exit the home state for the scatter state when they get to the row  	// above the home  	if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {  		// Select inital direction based on scatter tiles  		if (Constants.scatterTiles (identity_) [0].X < 13) {  			direction_ = Direction.Left;  		} else {  			direction_ = Direction.Right;  		}  		if (scatterModesLeft_ > 0) {  			State = GhostState.Scatter;  		} else {  			State = GhostState.Attack;  		}  		return;  	} // Ghosts move up when they are aligned with the entrance  	else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  		direction_ = Direction.Up;  	} // When on one side' move towards middle when on the bottom and time's up  	// If time's not up' keep bouncing up and down  	else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  		if (position_.Tile.Y == 14) {  			initialJumps_--;  			if (initialJumps_ == 0) {  				if (position_.Tile.X == 11) {  					direction_ = Direction.Right;  				} else {  					direction_ = Direction.Left;  				}  			} else {  				direction_ = Direction.Up;  			}  		} else if (position_.Tile.Y == 13) {  			direction_ = Direction.Down;  		}  	}  	break;  case GhostState.Scatter:  	// Attempt to reverse direction upon entering this state  	if (previousState_ == GhostState.Attack) {  		scatterModesLeft_--;  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	}  	AIScatter ();  	int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (timeInScatterMode)) {  		State = GhostState.Attack;  	}  	break;  case GhostState.Dead:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIDead ();  	}  	if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {  		if (position_.Tile.Y == 14) {  			State = GhostState.Home;  		}  	}  	break;  case GhostState.Attack:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIAttack ();  	}  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (20)) {  		State = GhostState.Scatter;  	}  	break;  case GhostState.Blue:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		// TODO : make special blue AI  		AIAttack ();  	}  	// When blue time is over' revert to attack mode.  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (Constants.BlueTime ())) {  		State = GhostState.Attack;  	}  	break;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: switch (State) {  case GhostState.Home:  	// Ghost exit the home state for the scatter state when they get to the row  	// above the home  	if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {  		// Select inital direction based on scatter tiles  		if (Constants.scatterTiles (identity_) [0].X < 13) {  			direction_ = Direction.Left;  		} else {  			direction_ = Direction.Right;  		}  		if (scatterModesLeft_ > 0) {  			State = GhostState.Scatter;  		} else {  			State = GhostState.Attack;  		}  		return;  	} // Ghosts move up when they are aligned with the entrance  	else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  		direction_ = Direction.Up;  	} // When on one side' move towards middle when on the bottom and time's up  	// If time's not up' keep bouncing up and down  	else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  		if (position_.Tile.Y == 14) {  			initialJumps_--;  			if (initialJumps_ == 0) {  				if (position_.Tile.X == 11) {  					direction_ = Direction.Right;  				} else {  					direction_ = Direction.Left;  				}  			} else {  				direction_ = Direction.Up;  			}  		} else if (position_.Tile.Y == 13) {  			direction_ = Direction.Down;  		}  	}  	break;  case GhostState.Scatter:  	// Attempt to reverse direction upon entering this state  	if (previousState_ == GhostState.Attack) {  		scatterModesLeft_--;  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	}  	AIScatter ();  	int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (timeInScatterMode)) {  		State = GhostState.Attack;  	}  	break;  case GhostState.Dead:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIDead ();  	}  	if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {  		if (position_.Tile.Y == 14) {  			State = GhostState.Home;  		}  	}  	break;  case GhostState.Attack:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIAttack ();  	}  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (20)) {  		State = GhostState.Scatter;  	}  	break;  case GhostState.Blue:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		// TODO : make special blue AI  		AIAttack ();  	}  	// When blue time is over' revert to attack mode.  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (Constants.BlueTime ())) {  		State = GhostState.Attack;  	}  	break;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: switch (State) {  case GhostState.Home:  	// Ghost exit the home state for the scatter state when they get to the row  	// above the home  	if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {  		// Select inital direction based on scatter tiles  		if (Constants.scatterTiles (identity_) [0].X < 13) {  			direction_ = Direction.Left;  		} else {  			direction_ = Direction.Right;  		}  		if (scatterModesLeft_ > 0) {  			State = GhostState.Scatter;  		} else {  			State = GhostState.Attack;  		}  		return;  	} // Ghosts move up when they are aligned with the entrance  	else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  		direction_ = Direction.Up;  	} // When on one side' move towards middle when on the bottom and time's up  	// If time's not up' keep bouncing up and down  	else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  		if (position_.Tile.Y == 14) {  			initialJumps_--;  			if (initialJumps_ == 0) {  				if (position_.Tile.X == 11) {  					direction_ = Direction.Right;  				} else {  					direction_ = Direction.Left;  				}  			} else {  				direction_ = Direction.Up;  			}  		} else if (position_.Tile.Y == 13) {  			direction_ = Direction.Down;  		}  	}  	break;  case GhostState.Scatter:  	// Attempt to reverse direction upon entering this state  	if (previousState_ == GhostState.Attack) {  		scatterModesLeft_--;  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	}  	AIScatter ();  	int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (timeInScatterMode)) {  		State = GhostState.Attack;  	}  	break;  case GhostState.Dead:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIDead ();  	}  	if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {  		if (position_.Tile.Y == 14) {  			State = GhostState.Home;  		}  	}  	break;  case GhostState.Attack:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIAttack ();  	}  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (20)) {  		State = GhostState.Scatter;  	}  	break;  case GhostState.Blue:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		// TODO : make special blue AI  		AIAttack ();  	}  	// When blue time is over' revert to attack mode.  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (Constants.BlueTime ())) {  		State = GhostState.Attack;  	}  	break;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: switch (State) {  case GhostState.Home:  	// Ghost exit the home state for the scatter state when they get to the row  	// above the home  	if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {  		// Select inital direction based on scatter tiles  		if (Constants.scatterTiles (identity_) [0].X < 13) {  			direction_ = Direction.Left;  		} else {  			direction_ = Direction.Right;  		}  		if (scatterModesLeft_ > 0) {  			State = GhostState.Scatter;  		} else {  			State = GhostState.Attack;  		}  		return;  	} // Ghosts move up when they are aligned with the entrance  	else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  		direction_ = Direction.Up;  	} // When on one side' move towards middle when on the bottom and time's up  	// If time's not up' keep bouncing up and down  	else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  		if (position_.Tile.Y == 14) {  			initialJumps_--;  			if (initialJumps_ == 0) {  				if (position_.Tile.X == 11) {  					direction_ = Direction.Right;  				} else {  					direction_ = Direction.Left;  				}  			} else {  				direction_ = Direction.Up;  			}  		} else if (position_.Tile.Y == 13) {  			direction_ = Direction.Down;  		}  	}  	break;  case GhostState.Scatter:  	// Attempt to reverse direction upon entering this state  	if (previousState_ == GhostState.Attack) {  		scatterModesLeft_--;  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	}  	AIScatter ();  	int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (timeInScatterMode)) {  		State = GhostState.Attack;  	}  	break;  case GhostState.Dead:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIDead ();  	}  	if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {  		if (position_.Tile.Y == 14) {  			State = GhostState.Home;  		}  	}  	break;  case GhostState.Attack:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIAttack ();  	}  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (20)) {  		State = GhostState.Scatter;  	}  	break;  case GhostState.Blue:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		// TODO : make special blue AI  		AIAttack ();  	}  	// When blue time is over' revert to attack mode.  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (Constants.BlueTime ())) {  		State = GhostState.Attack;  	}  	break;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: switch (State) {  case GhostState.Home:  	// Ghost exit the home state for the scatter state when they get to the row  	// above the home  	if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {  		// Select inital direction based on scatter tiles  		if (Constants.scatterTiles (identity_) [0].X < 13) {  			direction_ = Direction.Left;  		} else {  			direction_ = Direction.Right;  		}  		if (scatterModesLeft_ > 0) {  			State = GhostState.Scatter;  		} else {  			State = GhostState.Attack;  		}  		return;  	} // Ghosts move up when they are aligned with the entrance  	else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  		direction_ = Direction.Up;  	} // When on one side' move towards middle when on the bottom and time's up  	// If time's not up' keep bouncing up and down  	else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  		if (position_.Tile.Y == 14) {  			initialJumps_--;  			if (initialJumps_ == 0) {  				if (position_.Tile.X == 11) {  					direction_ = Direction.Right;  				} else {  					direction_ = Direction.Left;  				}  			} else {  				direction_ = Direction.Up;  			}  		} else if (position_.Tile.Y == 13) {  			direction_ = Direction.Down;  		}  	}  	break;  case GhostState.Scatter:  	// Attempt to reverse direction upon entering this state  	if (previousState_ == GhostState.Attack) {  		scatterModesLeft_--;  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	}  	AIScatter ();  	int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (timeInScatterMode)) {  		State = GhostState.Attack;  	}  	break;  case GhostState.Dead:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIDead ();  	}  	if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {  		if (position_.Tile.Y == 14) {  			State = GhostState.Home;  		}  	}  	break;  case GhostState.Attack:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIAttack ();  	}  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (20)) {  		State = GhostState.Scatter;  	}  	break;  case GhostState.Blue:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		// TODO : make special blue AI  		AIAttack ();  	}  	// When blue time is over' revert to attack mode.  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (Constants.BlueTime ())) {  		State = GhostState.Attack;  	}  	break;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: switch (State) {  case GhostState.Home:  	// Ghost exit the home state for the scatter state when they get to the row  	// above the home  	if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {  		// Select inital direction based on scatter tiles  		if (Constants.scatterTiles (identity_) [0].X < 13) {  			direction_ = Direction.Left;  		} else {  			direction_ = Direction.Right;  		}  		if (scatterModesLeft_ > 0) {  			State = GhostState.Scatter;  		} else {  			State = GhostState.Attack;  		}  		return;  	} // Ghosts move up when they are aligned with the entrance  	else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  		direction_ = Direction.Up;  	} // When on one side' move towards middle when on the bottom and time's up  	// If time's not up' keep bouncing up and down  	else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  		if (position_.Tile.Y == 14) {  			initialJumps_--;  			if (initialJumps_ == 0) {  				if (position_.Tile.X == 11) {  					direction_ = Direction.Right;  				} else {  					direction_ = Direction.Left;  				}  			} else {  				direction_ = Direction.Up;  			}  		} else if (position_.Tile.Y == 13) {  			direction_ = Direction.Down;  		}  	}  	break;  case GhostState.Scatter:  	// Attempt to reverse direction upon entering this state  	if (previousState_ == GhostState.Attack) {  		scatterModesLeft_--;  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	}  	AIScatter ();  	int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (timeInScatterMode)) {  		State = GhostState.Attack;  	}  	break;  case GhostState.Dead:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIDead ();  	}  	if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {  		if (position_.Tile.Y == 14) {  			State = GhostState.Home;  		}  	}  	break;  case GhostState.Attack:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIAttack ();  	}  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (20)) {  		State = GhostState.Scatter;  	}  	break;  case GhostState.Blue:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		// TODO : make special blue AI  		AIAttack ();  	}  	// When blue time is over' revert to attack mode.  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (Constants.BlueTime ())) {  		State = GhostState.Attack;  	}  	break;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: switch (State) {  case GhostState.Home:  	// Ghost exit the home state for the scatter state when they get to the row  	// above the home  	if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {  		// Select inital direction based on scatter tiles  		if (Constants.scatterTiles (identity_) [0].X < 13) {  			direction_ = Direction.Left;  		} else {  			direction_ = Direction.Right;  		}  		if (scatterModesLeft_ > 0) {  			State = GhostState.Scatter;  		} else {  			State = GhostState.Attack;  		}  		return;  	} // Ghosts move up when they are aligned with the entrance  	else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  		direction_ = Direction.Up;  	} // When on one side' move towards middle when on the bottom and time's up  	// If time's not up' keep bouncing up and down  	else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  		if (position_.Tile.Y == 14) {  			initialJumps_--;  			if (initialJumps_ == 0) {  				if (position_.Tile.X == 11) {  					direction_ = Direction.Right;  				} else {  					direction_ = Direction.Left;  				}  			} else {  				direction_ = Direction.Up;  			}  		} else if (position_.Tile.Y == 13) {  			direction_ = Direction.Down;  		}  	}  	break;  case GhostState.Scatter:  	// Attempt to reverse direction upon entering this state  	if (previousState_ == GhostState.Attack) {  		scatterModesLeft_--;  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	}  	AIScatter ();  	int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (timeInScatterMode)) {  		State = GhostState.Attack;  	}  	break;  case GhostState.Dead:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIDead ();  	}  	if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {  		if (position_.Tile.Y == 14) {  			State = GhostState.Home;  		}  	}  	break;  case GhostState.Attack:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIAttack ();  	}  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (20)) {  		State = GhostState.Scatter;  	}  	break;  case GhostState.Blue:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		// TODO : make special blue AI  		AIAttack ();  	}  	// When blue time is over' revert to attack mode.  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (Constants.BlueTime ())) {  		State = GhostState.Attack;  	}  	break;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: switch (State) {  case GhostState.Home:  	// Ghost exit the home state for the scatter state when they get to the row  	// above the home  	if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {  		// Select inital direction based on scatter tiles  		if (Constants.scatterTiles (identity_) [0].X < 13) {  			direction_ = Direction.Left;  		} else {  			direction_ = Direction.Right;  		}  		if (scatterModesLeft_ > 0) {  			State = GhostState.Scatter;  		} else {  			State = GhostState.Attack;  		}  		return;  	} // Ghosts move up when they are aligned with the entrance  	else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  		direction_ = Direction.Up;  	} // When on one side' move towards middle when on the bottom and time's up  	// If time's not up' keep bouncing up and down  	else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  		if (position_.Tile.Y == 14) {  			initialJumps_--;  			if (initialJumps_ == 0) {  				if (position_.Tile.X == 11) {  					direction_ = Direction.Right;  				} else {  					direction_ = Direction.Left;  				}  			} else {  				direction_ = Direction.Up;  			}  		} else if (position_.Tile.Y == 13) {  			direction_ = Direction.Down;  		}  	}  	break;  case GhostState.Scatter:  	// Attempt to reverse direction upon entering this state  	if (previousState_ == GhostState.Attack) {  		scatterModesLeft_--;  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	}  	AIScatter ();  	int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (timeInScatterMode)) {  		State = GhostState.Attack;  	}  	break;  case GhostState.Dead:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIDead ();  	}  	if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {  		if (position_.Tile.Y == 14) {  			State = GhostState.Home;  		}  	}  	break;  case GhostState.Attack:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIAttack ();  	}  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (20)) {  		State = GhostState.Scatter;  	}  	break;  case GhostState.Blue:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		// TODO : make special blue AI  		AIAttack ();  	}  	// When blue time is over' revert to attack mode.  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (Constants.BlueTime ())) {  		State = GhostState.Attack;  	}  	break;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: switch (State) {  case GhostState.Home:  	// Ghost exit the home state for the scatter state when they get to the row  	// above the home  	if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {  		// Select inital direction based on scatter tiles  		if (Constants.scatterTiles (identity_) [0].X < 13) {  			direction_ = Direction.Left;  		} else {  			direction_ = Direction.Right;  		}  		if (scatterModesLeft_ > 0) {  			State = GhostState.Scatter;  		} else {  			State = GhostState.Attack;  		}  		return;  	} // Ghosts move up when they are aligned with the entrance  	else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  		direction_ = Direction.Up;  	} // When on one side' move towards middle when on the bottom and time's up  	// If time's not up' keep bouncing up and down  	else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  		if (position_.Tile.Y == 14) {  			initialJumps_--;  			if (initialJumps_ == 0) {  				if (position_.Tile.X == 11) {  					direction_ = Direction.Right;  				} else {  					direction_ = Direction.Left;  				}  			} else {  				direction_ = Direction.Up;  			}  		} else if (position_.Tile.Y == 13) {  			direction_ = Direction.Down;  		}  	}  	break;  case GhostState.Scatter:  	// Attempt to reverse direction upon entering this state  	if (previousState_ == GhostState.Attack) {  		scatterModesLeft_--;  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	}  	AIScatter ();  	int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (timeInScatterMode)) {  		State = GhostState.Attack;  	}  	break;  case GhostState.Dead:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIDead ();  	}  	if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {  		if (position_.Tile.Y == 14) {  			State = GhostState.Home;  		}  	}  	break;  case GhostState.Attack:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIAttack ();  	}  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (20)) {  		State = GhostState.Scatter;  	}  	break;  case GhostState.Blue:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		// TODO : make special blue AI  		AIAttack ();  	}  	// When blue time is over' revert to attack mode.  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (Constants.BlueTime ())) {  		State = GhostState.Attack;  	}  	break;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: switch (State) {  case GhostState.Home:  	// Ghost exit the home state for the scatter state when they get to the row  	// above the home  	if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {  		// Select inital direction based on scatter tiles  		if (Constants.scatterTiles (identity_) [0].X < 13) {  			direction_ = Direction.Left;  		} else {  			direction_ = Direction.Right;  		}  		if (scatterModesLeft_ > 0) {  			State = GhostState.Scatter;  		} else {  			State = GhostState.Attack;  		}  		return;  	} // Ghosts move up when they are aligned with the entrance  	else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  		direction_ = Direction.Up;  	} // When on one side' move towards middle when on the bottom and time's up  	// If time's not up' keep bouncing up and down  	else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  		if (position_.Tile.Y == 14) {  			initialJumps_--;  			if (initialJumps_ == 0) {  				if (position_.Tile.X == 11) {  					direction_ = Direction.Right;  				} else {  					direction_ = Direction.Left;  				}  			} else {  				direction_ = Direction.Up;  			}  		} else if (position_.Tile.Y == 13) {  			direction_ = Direction.Down;  		}  	}  	break;  case GhostState.Scatter:  	// Attempt to reverse direction upon entering this state  	if (previousState_ == GhostState.Attack) {  		scatterModesLeft_--;  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	}  	AIScatter ();  	int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (timeInScatterMode)) {  		State = GhostState.Attack;  	}  	break;  case GhostState.Dead:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIDead ();  	}  	if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {  		if (position_.Tile.Y == 14) {  			State = GhostState.Home;  		}  	}  	break;  case GhostState.Attack:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIAttack ();  	}  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (20)) {  		State = GhostState.Scatter;  	}  	break;  case GhostState.Blue:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		// TODO : make special blue AI  		AIAttack ();  	}  	// When blue time is over' revert to attack mode.  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (Constants.BlueTime ())) {  		State = GhostState.Attack;  	}  	break;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: switch (State) {  case GhostState.Home:  	// Ghost exit the home state for the scatter state when they get to the row  	// above the home  	if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {  		// Select inital direction based on scatter tiles  		if (Constants.scatterTiles (identity_) [0].X < 13) {  			direction_ = Direction.Left;  		} else {  			direction_ = Direction.Right;  		}  		if (scatterModesLeft_ > 0) {  			State = GhostState.Scatter;  		} else {  			State = GhostState.Attack;  		}  		return;  	} // Ghosts move up when they are aligned with the entrance  	else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  		direction_ = Direction.Up;  	} // When on one side' move towards middle when on the bottom and time's up  	// If time's not up' keep bouncing up and down  	else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  		if (position_.Tile.Y == 14) {  			initialJumps_--;  			if (initialJumps_ == 0) {  				if (position_.Tile.X == 11) {  					direction_ = Direction.Right;  				} else {  					direction_ = Direction.Left;  				}  			} else {  				direction_ = Direction.Up;  			}  		} else if (position_.Tile.Y == 13) {  			direction_ = Direction.Down;  		}  	}  	break;  case GhostState.Scatter:  	// Attempt to reverse direction upon entering this state  	if (previousState_ == GhostState.Attack) {  		scatterModesLeft_--;  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	}  	AIScatter ();  	int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (timeInScatterMode)) {  		State = GhostState.Attack;  	}  	break;  case GhostState.Dead:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIDead ();  	}  	if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {  		if (position_.Tile.Y == 14) {  			State = GhostState.Home;  		}  	}  	break;  case GhostState.Attack:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIAttack ();  	}  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (20)) {  		State = GhostState.Scatter;  	}  	break;  case GhostState.Blue:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		// TODO : make special blue AI  		AIAttack ();  	}  	// When blue time is over' revert to attack mode.  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (Constants.BlueTime ())) {  		State = GhostState.Attack;  	}  	break;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: switch (State) {  case GhostState.Home:  	// Ghost exit the home state for the scatter state when they get to the row  	// above the home  	if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {  		// Select inital direction based on scatter tiles  		if (Constants.scatterTiles (identity_) [0].X < 13) {  			direction_ = Direction.Left;  		} else {  			direction_ = Direction.Right;  		}  		if (scatterModesLeft_ > 0) {  			State = GhostState.Scatter;  		} else {  			State = GhostState.Attack;  		}  		return;  	} // Ghosts move up when they are aligned with the entrance  	else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  		direction_ = Direction.Up;  	} // When on one side' move towards middle when on the bottom and time's up  	// If time's not up' keep bouncing up and down  	else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  		if (position_.Tile.Y == 14) {  			initialJumps_--;  			if (initialJumps_ == 0) {  				if (position_.Tile.X == 11) {  					direction_ = Direction.Right;  				} else {  					direction_ = Direction.Left;  				}  			} else {  				direction_ = Direction.Up;  			}  		} else if (position_.Tile.Y == 13) {  			direction_ = Direction.Down;  		}  	}  	break;  case GhostState.Scatter:  	// Attempt to reverse direction upon entering this state  	if (previousState_ == GhostState.Attack) {  		scatterModesLeft_--;  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	}  	AIScatter ();  	int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (timeInScatterMode)) {  		State = GhostState.Attack;  	}  	break;  case GhostState.Dead:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIDead ();  	}  	if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {  		if (position_.Tile.Y == 14) {  			State = GhostState.Home;  		}  	}  	break;  case GhostState.Attack:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIAttack ();  	}  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (20)) {  		State = GhostState.Scatter;  	}  	break;  case GhostState.Blue:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		// TODO : make special blue AI  		AIAttack ();  	}  	// When blue time is over' revert to attack mode.  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (Constants.BlueTime ())) {  		State = GhostState.Attack;  	}  	break;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: switch (State) {  case GhostState.Home:  	// Ghost exit the home state for the scatter state when they get to the row  	// above the home  	if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {  		// Select inital direction based on scatter tiles  		if (Constants.scatterTiles (identity_) [0].X < 13) {  			direction_ = Direction.Left;  		} else {  			direction_ = Direction.Right;  		}  		if (scatterModesLeft_ > 0) {  			State = GhostState.Scatter;  		} else {  			State = GhostState.Attack;  		}  		return;  	} // Ghosts move up when they are aligned with the entrance  	else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  		direction_ = Direction.Up;  	} // When on one side' move towards middle when on the bottom and time's up  	// If time's not up' keep bouncing up and down  	else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  		if (position_.Tile.Y == 14) {  			initialJumps_--;  			if (initialJumps_ == 0) {  				if (position_.Tile.X == 11) {  					direction_ = Direction.Right;  				} else {  					direction_ = Direction.Left;  				}  			} else {  				direction_ = Direction.Up;  			}  		} else if (position_.Tile.Y == 13) {  			direction_ = Direction.Down;  		}  	}  	break;  case GhostState.Scatter:  	// Attempt to reverse direction upon entering this state  	if (previousState_ == GhostState.Attack) {  		scatterModesLeft_--;  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	}  	AIScatter ();  	int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (timeInScatterMode)) {  		State = GhostState.Attack;  	}  	break;  case GhostState.Dead:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIDead ();  	}  	if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {  		if (position_.Tile.Y == 14) {  			State = GhostState.Home;  		}  	}  	break;  case GhostState.Attack:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIAttack ();  	}  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (20)) {  		State = GhostState.Scatter;  	}  	break;  case GhostState.Blue:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		// TODO : make special blue AI  		AIAttack ();  	}  	// When blue time is over' revert to attack mode.  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (Constants.BlueTime ())) {  		State = GhostState.Attack;  	}  	break;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: switch (State) {  case GhostState.Home:  	// Ghost exit the home state for the scatter state when they get to the row  	// above the home  	if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {  		// Select inital direction based on scatter tiles  		if (Constants.scatterTiles (identity_) [0].X < 13) {  			direction_ = Direction.Left;  		} else {  			direction_ = Direction.Right;  		}  		if (scatterModesLeft_ > 0) {  			State = GhostState.Scatter;  		} else {  			State = GhostState.Attack;  		}  		return;  	} // Ghosts move up when they are aligned with the entrance  	else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  		direction_ = Direction.Up;  	} // When on one side' move towards middle when on the bottom and time's up  	// If time's not up' keep bouncing up and down  	else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  		if (position_.Tile.Y == 14) {  			initialJumps_--;  			if (initialJumps_ == 0) {  				if (position_.Tile.X == 11) {  					direction_ = Direction.Right;  				} else {  					direction_ = Direction.Left;  				}  			} else {  				direction_ = Direction.Up;  			}  		} else if (position_.Tile.Y == 13) {  			direction_ = Direction.Down;  		}  	}  	break;  case GhostState.Scatter:  	// Attempt to reverse direction upon entering this state  	if (previousState_ == GhostState.Attack) {  		scatterModesLeft_--;  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	}  	AIScatter ();  	int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (timeInScatterMode)) {  		State = GhostState.Attack;  	}  	break;  case GhostState.Dead:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIDead ();  	}  	if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {  		if (position_.Tile.Y == 14) {  			State = GhostState.Home;  		}  	}  	break;  case GhostState.Attack:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIAttack ();  	}  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (20)) {  		State = GhostState.Scatter;  	}  	break;  case GhostState.Blue:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		// TODO : make special blue AI  		AIAttack ();  	}  	// When blue time is over' revert to attack mode.  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (Constants.BlueTime ())) {  		State = GhostState.Attack;  	}  	break;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: switch (State) {  case GhostState.Home:  	// Ghost exit the home state for the scatter state when they get to the row  	// above the home  	if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {  		// Select inital direction based on scatter tiles  		if (Constants.scatterTiles (identity_) [0].X < 13) {  			direction_ = Direction.Left;  		} else {  			direction_ = Direction.Right;  		}  		if (scatterModesLeft_ > 0) {  			State = GhostState.Scatter;  		} else {  			State = GhostState.Attack;  		}  		return;  	} // Ghosts move up when they are aligned with the entrance  	else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  		direction_ = Direction.Up;  	} // When on one side' move towards middle when on the bottom and time's up  	// If time's not up' keep bouncing up and down  	else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  		if (position_.Tile.Y == 14) {  			initialJumps_--;  			if (initialJumps_ == 0) {  				if (position_.Tile.X == 11) {  					direction_ = Direction.Right;  				} else {  					direction_ = Direction.Left;  				}  			} else {  				direction_ = Direction.Up;  			}  		} else if (position_.Tile.Y == 13) {  			direction_ = Direction.Down;  		}  	}  	break;  case GhostState.Scatter:  	// Attempt to reverse direction upon entering this state  	if (previousState_ == GhostState.Attack) {  		scatterModesLeft_--;  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	}  	AIScatter ();  	int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (timeInScatterMode)) {  		State = GhostState.Attack;  	}  	break;  case GhostState.Dead:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIDead ();  	}  	if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {  		if (position_.Tile.Y == 14) {  			State = GhostState.Home;  		}  	}  	break;  case GhostState.Attack:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIAttack ();  	}  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (20)) {  		State = GhostState.Scatter;  	}  	break;  case GhostState.Blue:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		// TODO : make special blue AI  		AIAttack ();  	}  	// When blue time is over' revert to attack mode.  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (Constants.BlueTime ())) {  		State = GhostState.Attack;  	}  	break;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: switch (State) {  case GhostState.Home:  	// Ghost exit the home state for the scatter state when they get to the row  	// above the home  	if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {  		// Select inital direction based on scatter tiles  		if (Constants.scatterTiles (identity_) [0].X < 13) {  			direction_ = Direction.Left;  		} else {  			direction_ = Direction.Right;  		}  		if (scatterModesLeft_ > 0) {  			State = GhostState.Scatter;  		} else {  			State = GhostState.Attack;  		}  		return;  	} // Ghosts move up when they are aligned with the entrance  	else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  		direction_ = Direction.Up;  	} // When on one side' move towards middle when on the bottom and time's up  	// If time's not up' keep bouncing up and down  	else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  		if (position_.Tile.Y == 14) {  			initialJumps_--;  			if (initialJumps_ == 0) {  				if (position_.Tile.X == 11) {  					direction_ = Direction.Right;  				} else {  					direction_ = Direction.Left;  				}  			} else {  				direction_ = Direction.Up;  			}  		} else if (position_.Tile.Y == 13) {  			direction_ = Direction.Down;  		}  	}  	break;  case GhostState.Scatter:  	// Attempt to reverse direction upon entering this state  	if (previousState_ == GhostState.Attack) {  		scatterModesLeft_--;  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	}  	AIScatter ();  	int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (timeInScatterMode)) {  		State = GhostState.Attack;  	}  	break;  case GhostState.Dead:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIDead ();  	}  	if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {  		if (position_.Tile.Y == 14) {  			State = GhostState.Home;  		}  	}  	break;  case GhostState.Attack:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIAttack ();  	}  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (20)) {  		State = GhostState.Scatter;  	}  	break;  case GhostState.Blue:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		// TODO : make special blue AI  		AIAttack ();  	}  	// When blue time is over' revert to attack mode.  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (Constants.BlueTime ())) {  		State = GhostState.Attack;  	}  	break;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: switch (State) {  case GhostState.Home:  	// Ghost exit the home state for the scatter state when they get to the row  	// above the home  	if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {  		// Select inital direction based on scatter tiles  		if (Constants.scatterTiles (identity_) [0].X < 13) {  			direction_ = Direction.Left;  		} else {  			direction_ = Direction.Right;  		}  		if (scatterModesLeft_ > 0) {  			State = GhostState.Scatter;  		} else {  			State = GhostState.Attack;  		}  		return;  	} // Ghosts move up when they are aligned with the entrance  	else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  		direction_ = Direction.Up;  	} // When on one side' move towards middle when on the bottom and time's up  	// If time's not up' keep bouncing up and down  	else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  		if (position_.Tile.Y == 14) {  			initialJumps_--;  			if (initialJumps_ == 0) {  				if (position_.Tile.X == 11) {  					direction_ = Direction.Right;  				} else {  					direction_ = Direction.Left;  				}  			} else {  				direction_ = Direction.Up;  			}  		} else if (position_.Tile.Y == 13) {  			direction_ = Direction.Down;  		}  	}  	break;  case GhostState.Scatter:  	// Attempt to reverse direction upon entering this state  	if (previousState_ == GhostState.Attack) {  		scatterModesLeft_--;  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	}  	AIScatter ();  	int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (timeInScatterMode)) {  		State = GhostState.Attack;  	}  	break;  case GhostState.Dead:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIDead ();  	}  	if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {  		if (position_.Tile.Y == 14) {  			State = GhostState.Home;  		}  	}  	break;  case GhostState.Attack:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIAttack ();  	}  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (20)) {  		State = GhostState.Scatter;  	}  	break;  case GhostState.Blue:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		// TODO : make special blue AI  		AIAttack ();  	}  	// When blue time is over' revert to attack mode.  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (Constants.BlueTime ())) {  		State = GhostState.Attack;  	}  	break;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: switch (State) {  case GhostState.Home:  	// Ghost exit the home state for the scatter state when they get to the row  	// above the home  	if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {  		// Select inital direction based on scatter tiles  		if (Constants.scatterTiles (identity_) [0].X < 13) {  			direction_ = Direction.Left;  		} else {  			direction_ = Direction.Right;  		}  		if (scatterModesLeft_ > 0) {  			State = GhostState.Scatter;  		} else {  			State = GhostState.Attack;  		}  		return;  	} // Ghosts move up when they are aligned with the entrance  	else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  		direction_ = Direction.Up;  	} // When on one side' move towards middle when on the bottom and time's up  	// If time's not up' keep bouncing up and down  	else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  		if (position_.Tile.Y == 14) {  			initialJumps_--;  			if (initialJumps_ == 0) {  				if (position_.Tile.X == 11) {  					direction_ = Direction.Right;  				} else {  					direction_ = Direction.Left;  				}  			} else {  				direction_ = Direction.Up;  			}  		} else if (position_.Tile.Y == 13) {  			direction_ = Direction.Down;  		}  	}  	break;  case GhostState.Scatter:  	// Attempt to reverse direction upon entering this state  	if (previousState_ == GhostState.Attack) {  		scatterModesLeft_--;  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	}  	AIScatter ();  	int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (timeInScatterMode)) {  		State = GhostState.Attack;  	}  	break;  case GhostState.Dead:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIDead ();  	}  	if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {  		if (position_.Tile.Y == 14) {  			State = GhostState.Home;  		}  	}  	break;  case GhostState.Attack:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIAttack ();  	}  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (20)) {  		State = GhostState.Scatter;  	}  	break;  case GhostState.Blue:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		// TODO : make special blue AI  		AIAttack ();  	}  	// When blue time is over' revert to attack mode.  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (Constants.BlueTime ())) {  		State = GhostState.Attack;  	}  	break;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: switch (State) {  case GhostState.Home:  	// Ghost exit the home state for the scatter state when they get to the row  	// above the home  	if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {  		// Select inital direction based on scatter tiles  		if (Constants.scatterTiles (identity_) [0].X < 13) {  			direction_ = Direction.Left;  		} else {  			direction_ = Direction.Right;  		}  		if (scatterModesLeft_ > 0) {  			State = GhostState.Scatter;  		} else {  			State = GhostState.Attack;  		}  		return;  	} // Ghosts move up when they are aligned with the entrance  	else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  		direction_ = Direction.Up;  	} // When on one side' move towards middle when on the bottom and time's up  	// If time's not up' keep bouncing up and down  	else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  		if (position_.Tile.Y == 14) {  			initialJumps_--;  			if (initialJumps_ == 0) {  				if (position_.Tile.X == 11) {  					direction_ = Direction.Right;  				} else {  					direction_ = Direction.Left;  				}  			} else {  				direction_ = Direction.Up;  			}  		} else if (position_.Tile.Y == 13) {  			direction_ = Direction.Down;  		}  	}  	break;  case GhostState.Scatter:  	// Attempt to reverse direction upon entering this state  	if (previousState_ == GhostState.Attack) {  		scatterModesLeft_--;  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	}  	AIScatter ();  	int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (timeInScatterMode)) {  		State = GhostState.Attack;  	}  	break;  case GhostState.Dead:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIDead ();  	}  	if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {  		if (position_.Tile.Y == 14) {  			State = GhostState.Home;  		}  	}  	break;  case GhostState.Attack:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIAttack ();  	}  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (20)) {  		State = GhostState.Scatter;  	}  	break;  case GhostState.Blue:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		// TODO : make special blue AI  		AIAttack ();  	}  	// When blue time is over' revert to attack mode.  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (Constants.BlueTime ())) {  		State = GhostState.Attack;  	}  	break;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {  	// Select inital direction based on scatter tiles  	if (Constants.scatterTiles (identity_) [0].X < 13) {  		direction_ = Direction.Left;  	} else {  		direction_ = Direction.Right;  	}  	if (scatterModesLeft_ > 0) {  		State = GhostState.Scatter;  	} else {  		State = GhostState.Attack;  	}  	return;  } // Ghosts move up when they are aligned with the entrance  else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  	direction_ = Direction.Up;  } // When on one side' move towards middle when on the bottom and time's up  // If time's not up' keep bouncing up and down  else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  	if (position_.Tile.Y == 14) {  		initialJumps_--;  		if (initialJumps_ == 0) {  			if (position_.Tile.X == 11) {  				direction_ = Direction.Right;  			} else {  				direction_ = Direction.Left;  			}  		} else {  			direction_ = Direction.Up;  		}  	} else if (position_.Tile.Y == 13) {  		direction_ = Direction.Down;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {  	// Select inital direction based on scatter tiles  	if (Constants.scatterTiles (identity_) [0].X < 13) {  		direction_ = Direction.Left;  	} else {  		direction_ = Direction.Right;  	}  	if (scatterModesLeft_ > 0) {  		State = GhostState.Scatter;  	} else {  		State = GhostState.Attack;  	}  	return;  } // Ghosts move up when they are aligned with the entrance  else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  	direction_ = Direction.Up;  } // When on one side' move towards middle when on the bottom and time's up  // If time's not up' keep bouncing up and down  else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  	if (position_.Tile.Y == 14) {  		initialJumps_--;  		if (initialJumps_ == 0) {  			if (position_.Tile.X == 11) {  				direction_ = Direction.Right;  			} else {  				direction_ = Direction.Left;  			}  		} else {  			direction_ = Direction.Up;  		}  	} else if (position_.Tile.Y == 13) {  		direction_ = Direction.Down;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {  	// Select inital direction based on scatter tiles  	if (Constants.scatterTiles (identity_) [0].X < 13) {  		direction_ = Direction.Left;  	} else {  		direction_ = Direction.Right;  	}  	if (scatterModesLeft_ > 0) {  		State = GhostState.Scatter;  	} else {  		State = GhostState.Attack;  	}  	return;  } // Ghosts move up when they are aligned with the entrance  else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  	direction_ = Direction.Up;  } // When on one side' move towards middle when on the bottom and time's up  // If time's not up' keep bouncing up and down  else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  	if (position_.Tile.Y == 14) {  		initialJumps_--;  		if (initialJumps_ == 0) {  			if (position_.Tile.X == 11) {  				direction_ = Direction.Right;  			} else {  				direction_ = Direction.Left;  			}  		} else {  			direction_ = Direction.Up;  		}  	} else if (position_.Tile.Y == 13) {  		direction_ = Direction.Down;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {  	// Select inital direction based on scatter tiles  	if (Constants.scatterTiles (identity_) [0].X < 13) {  		direction_ = Direction.Left;  	} else {  		direction_ = Direction.Right;  	}  	if (scatterModesLeft_ > 0) {  		State = GhostState.Scatter;  	} else {  		State = GhostState.Attack;  	}  	return;  } // Ghosts move up when they are aligned with the entrance  else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  	direction_ = Direction.Up;  } // When on one side' move towards middle when on the bottom and time's up  // If time's not up' keep bouncing up and down  else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  	if (position_.Tile.Y == 14) {  		initialJumps_--;  		if (initialJumps_ == 0) {  			if (position_.Tile.X == 11) {  				direction_ = Direction.Right;  			} else {  				direction_ = Direction.Left;  			}  		} else {  			direction_ = Direction.Up;  		}  	} else if (position_.Tile.Y == 13) {  		direction_ = Direction.Down;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {  	// Select inital direction based on scatter tiles  	if (Constants.scatterTiles (identity_) [0].X < 13) {  		direction_ = Direction.Left;  	} else {  		direction_ = Direction.Right;  	}  	if (scatterModesLeft_ > 0) {  		State = GhostState.Scatter;  	} else {  		State = GhostState.Attack;  	}  	return;  } // Ghosts move up when they are aligned with the entrance  else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  	direction_ = Direction.Up;  } // When on one side' move towards middle when on the bottom and time's up  // If time's not up' keep bouncing up and down  else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  	if (position_.Tile.Y == 14) {  		initialJumps_--;  		if (initialJumps_ == 0) {  			if (position_.Tile.X == 11) {  				direction_ = Direction.Right;  			} else {  				direction_ = Direction.Left;  			}  		} else {  			direction_ = Direction.Up;  		}  	} else if (position_.Tile.Y == 13) {  		direction_ = Direction.Down;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {  	// Select inital direction based on scatter tiles  	if (Constants.scatterTiles (identity_) [0].X < 13) {  		direction_ = Direction.Left;  	} else {  		direction_ = Direction.Right;  	}  	if (scatterModesLeft_ > 0) {  		State = GhostState.Scatter;  	} else {  		State = GhostState.Attack;  	}  	return;  } // Ghosts move up when they are aligned with the entrance  else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  	direction_ = Direction.Up;  } // When on one side' move towards middle when on the bottom and time's up  // If time's not up' keep bouncing up and down  else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  	if (position_.Tile.Y == 14) {  		initialJumps_--;  		if (initialJumps_ == 0) {  			if (position_.Tile.X == 11) {  				direction_ = Direction.Right;  			} else {  				direction_ = Direction.Left;  			}  		} else {  			direction_ = Direction.Up;  		}  	} else if (position_.Tile.Y == 13) {  		direction_ = Direction.Down;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {  	// Select inital direction based on scatter tiles  	if (Constants.scatterTiles (identity_) [0].X < 13) {  		direction_ = Direction.Left;  	} else {  		direction_ = Direction.Right;  	}  	if (scatterModesLeft_ > 0) {  		State = GhostState.Scatter;  	} else {  		State = GhostState.Attack;  	}  	return;  } // Ghosts move up when they are aligned with the entrance  else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  	direction_ = Direction.Up;  } // When on one side' move towards middle when on the bottom and time's up  // If time's not up' keep bouncing up and down  else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  	if (position_.Tile.Y == 14) {  		initialJumps_--;  		if (initialJumps_ == 0) {  			if (position_.Tile.X == 11) {  				direction_ = Direction.Right;  			} else {  				direction_ = Direction.Left;  			}  		} else {  			direction_ = Direction.Up;  		}  	} else if (position_.Tile.Y == 13) {  		direction_ = Direction.Down;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {  	// Select inital direction based on scatter tiles  	if (Constants.scatterTiles (identity_) [0].X < 13) {  		direction_ = Direction.Left;  	} else {  		direction_ = Direction.Right;  	}  	if (scatterModesLeft_ > 0) {  		State = GhostState.Scatter;  	} else {  		State = GhostState.Attack;  	}  	return;  } // Ghosts move up when they are aligned with the entrance  else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  	direction_ = Direction.Up;  } // When on one side' move towards middle when on the bottom and time's up  // If time's not up' keep bouncing up and down  else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  	if (position_.Tile.Y == 14) {  		initialJumps_--;  		if (initialJumps_ == 0) {  			if (position_.Tile.X == 11) {  				direction_ = Direction.Right;  			} else {  				direction_ = Direction.Left;  			}  		} else {  			direction_ = Direction.Up;  		}  	} else if (position_.Tile.Y == 13) {  		direction_ = Direction.Down;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {  	// Select inital direction based on scatter tiles  	if (Constants.scatterTiles (identity_) [0].X < 13) {  		direction_ = Direction.Left;  	} else {  		direction_ = Direction.Right;  	}  	if (scatterModesLeft_ > 0) {  		State = GhostState.Scatter;  	} else {  		State = GhostState.Attack;  	}  	return;  } // Ghosts move up when they are aligned with the entrance  else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  	direction_ = Direction.Up;  } // When on one side' move towards middle when on the bottom and time's up  // If time's not up' keep bouncing up and down  else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  	if (position_.Tile.Y == 14) {  		initialJumps_--;  		if (initialJumps_ == 0) {  			if (position_.Tile.X == 11) {  				direction_ = Direction.Right;  			} else {  				direction_ = Direction.Left;  			}  		} else {  			direction_ = Direction.Up;  		}  	} else if (position_.Tile.Y == 13) {  		direction_ = Direction.Down;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {  	// Select inital direction based on scatter tiles  	if (Constants.scatterTiles (identity_) [0].X < 13) {  		direction_ = Direction.Left;  	} else {  		direction_ = Direction.Right;  	}  	if (scatterModesLeft_ > 0) {  		State = GhostState.Scatter;  	} else {  		State = GhostState.Attack;  	}  	return;  } // Ghosts move up when they are aligned with the entrance  else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  	direction_ = Direction.Up;  } // When on one side' move towards middle when on the bottom and time's up  // If time's not up' keep bouncing up and down  else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  	if (position_.Tile.Y == 14) {  		initialJumps_--;  		if (initialJumps_ == 0) {  			if (position_.Tile.X == 11) {  				direction_ = Direction.Right;  			} else {  				direction_ = Direction.Left;  			}  		} else {  			direction_ = Direction.Up;  		}  	} else if (position_.Tile.Y == 13) {  		direction_ = Direction.Down;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {  	// Select inital direction based on scatter tiles  	if (Constants.scatterTiles (identity_) [0].X < 13) {  		direction_ = Direction.Left;  	} else {  		direction_ = Direction.Right;  	}  	if (scatterModesLeft_ > 0) {  		State = GhostState.Scatter;  	} else {  		State = GhostState.Attack;  	}  	return;  } // Ghosts move up when they are aligned with the entrance  else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  	direction_ = Direction.Up;  } // When on one side' move towards middle when on the bottom and time's up  // If time's not up' keep bouncing up and down  else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  	if (position_.Tile.Y == 14) {  		initialJumps_--;  		if (initialJumps_ == 0) {  			if (position_.Tile.X == 11) {  				direction_ = Direction.Right;  			} else {  				direction_ = Direction.Left;  			}  		} else {  			direction_ = Direction.Up;  		}  	} else if (position_.Tile.Y == 13) {  		direction_ = Direction.Down;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {  	// Select inital direction based on scatter tiles  	if (Constants.scatterTiles (identity_) [0].X < 13) {  		direction_ = Direction.Left;  	} else {  		direction_ = Direction.Right;  	}  	if (scatterModesLeft_ > 0) {  		State = GhostState.Scatter;  	} else {  		State = GhostState.Attack;  	}  	return;  } // Ghosts move up when they are aligned with the entrance  else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  	direction_ = Direction.Up;  } // When on one side' move towards middle when on the bottom and time's up  // If time's not up' keep bouncing up and down  else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  	if (position_.Tile.Y == 14) {  		initialJumps_--;  		if (initialJumps_ == 0) {  			if (position_.Tile.X == 11) {  				direction_ = Direction.Right;  			} else {  				direction_ = Direction.Left;  			}  		} else {  			direction_ = Direction.Up;  		}  	} else if (position_.Tile.Y == 13) {  		direction_ = Direction.Down;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if (Constants.scatterTiles (identity_) [0].X < 13) {  	direction_ = Direction.Left;  } else {  	direction_ = Direction.Right;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  	direction_ = Direction.Up;  } // When on one side' move towards middle when on the bottom and time's up  // If time's not up' keep bouncing up and down  else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  	if (position_.Tile.Y == 14) {  		initialJumps_--;  		if (initialJumps_ == 0) {  			if (position_.Tile.X == 11) {  				direction_ = Direction.Right;  			} else {  				direction_ = Direction.Left;  			}  		} else {  			direction_ = Direction.Up;  		}  	} else if (position_.Tile.Y == 13) {  		direction_ = Direction.Down;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  	direction_ = Direction.Up;  } // When on one side' move towards middle when on the bottom and time's up  // If time's not up' keep bouncing up and down  else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  	if (position_.Tile.Y == 14) {  		initialJumps_--;  		if (initialJumps_ == 0) {  			if (position_.Tile.X == 11) {  				direction_ = Direction.Right;  			} else {  				direction_ = Direction.Left;  			}  		} else {  			direction_ = Direction.Up;  		}  	} else if (position_.Tile.Y == 13) {  		direction_ = Direction.Down;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  	direction_ = Direction.Up;  } // When on one side' move towards middle when on the bottom and time's up  // If time's not up' keep bouncing up and down  else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  	if (position_.Tile.Y == 14) {  		initialJumps_--;  		if (initialJumps_ == 0) {  			if (position_.Tile.X == 11) {  				direction_ = Direction.Right;  			} else {  				direction_ = Direction.Left;  			}  		} else {  			direction_ = Direction.Up;  		}  	} else if (position_.Tile.Y == 13) {  		direction_ = Direction.Down;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  	direction_ = Direction.Up;  } // When on one side' move towards middle when on the bottom and time's up  // If time's not up' keep bouncing up and down  else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  	if (position_.Tile.Y == 14) {  		initialJumps_--;  		if (initialJumps_ == 0) {  			if (position_.Tile.X == 11) {  				direction_ = Direction.Right;  			} else {  				direction_ = Direction.Left;  			}  		} else {  			direction_ = Direction.Up;  		}  	} else if (position_.Tile.Y == 13) {  		direction_ = Direction.Down;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  	direction_ = Direction.Up;  } // When on one side' move towards middle when on the bottom and time's up  // If time's not up' keep bouncing up and down  else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  	if (position_.Tile.Y == 14) {  		initialJumps_--;  		if (initialJumps_ == 0) {  			if (position_.Tile.X == 11) {  				direction_ = Direction.Right;  			} else {  				direction_ = Direction.Left;  			}  		} else {  			direction_ = Direction.Up;  		}  	} else if (position_.Tile.Y == 13) {  		direction_ = Direction.Down;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  	direction_ = Direction.Up;  } // When on one side' move towards middle when on the bottom and time's up  // If time's not up' keep bouncing up and down  else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  	if (position_.Tile.Y == 14) {  		initialJumps_--;  		if (initialJumps_ == 0) {  			if (position_.Tile.X == 11) {  				direction_ = Direction.Right;  			} else {  				direction_ = Direction.Left;  			}  		} else {  			direction_ = Direction.Up;  		}  	} else if (position_.Tile.Y == 13) {  		direction_ = Direction.Down;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  	direction_ = Direction.Up;  } // When on one side' move towards middle when on the bottom and time's up  // If time's not up' keep bouncing up and down  else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  	if (position_.Tile.Y == 14) {  		initialJumps_--;  		if (initialJumps_ == 0) {  			if (position_.Tile.X == 11) {  				direction_ = Direction.Right;  			} else {  				direction_ = Direction.Left;  			}  		} else {  			direction_ = Direction.Up;  		}  	} else if (position_.Tile.Y == 13) {  		direction_ = Direction.Down;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  	direction_ = Direction.Up;  } // When on one side' move towards middle when on the bottom and time's up  // If time's not up' keep bouncing up and down  else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  	if (position_.Tile.Y == 14) {  		initialJumps_--;  		if (initialJumps_ == 0) {  			if (position_.Tile.X == 11) {  				direction_ = Direction.Right;  			} else {  				direction_ = Direction.Left;  			}  		} else {  			direction_ = Direction.Up;  		}  	} else if (position_.Tile.Y == 13) {  		direction_ = Direction.Down;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  	direction_ = Direction.Up;  } // When on one side' move towards middle when on the bottom and time's up  // If time's not up' keep bouncing up and down  else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  	if (position_.Tile.Y == 14) {  		initialJumps_--;  		if (initialJumps_ == 0) {  			if (position_.Tile.X == 11) {  				direction_ = Direction.Right;  			} else {  				direction_ = Direction.Left;  			}  		} else {  			direction_ = Direction.Up;  		}  	} else if (position_.Tile.Y == 13) {  		direction_ = Direction.Down;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  	direction_ = Direction.Up;  } // When on one side' move towards middle when on the bottom and time's up  // If time's not up' keep bouncing up and down  else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  	if (position_.Tile.Y == 14) {  		initialJumps_--;  		if (initialJumps_ == 0) {  			if (position_.Tile.X == 11) {  				direction_ = Direction.Right;  			} else {  				direction_ = Direction.Left;  			}  		} else {  			direction_ = Direction.Up;  		}  	} else if (position_.Tile.Y == 13) {  		direction_ = Direction.Down;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  	if (position_.Tile.Y == 14) {  		initialJumps_--;  		if (initialJumps_ == 0) {  			if (position_.Tile.X == 11) {  				direction_ = Direction.Right;  			} else {  				direction_ = Direction.Left;  			}  		} else {  			direction_ = Direction.Up;  		}  	} else if (position_.Tile.Y == 13) {  		direction_ = Direction.Down;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  	if (position_.Tile.Y == 14) {  		initialJumps_--;  		if (initialJumps_ == 0) {  			if (position_.Tile.X == 11) {  				direction_ = Direction.Right;  			} else {  				direction_ = Direction.Left;  			}  		} else {  			direction_ = Direction.Up;  		}  	} else if (position_.Tile.Y == 13) {  		direction_ = Direction.Down;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  	if (position_.Tile.Y == 14) {  		initialJumps_--;  		if (initialJumps_ == 0) {  			if (position_.Tile.X == 11) {  				direction_ = Direction.Right;  			} else {  				direction_ = Direction.Left;  			}  		} else {  			direction_ = Direction.Up;  		}  	} else if (position_.Tile.Y == 13) {  		direction_ = Direction.Down;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  	if (position_.Tile.Y == 14) {  		initialJumps_--;  		if (initialJumps_ == 0) {  			if (position_.Tile.X == 11) {  				direction_ = Direction.Right;  			} else {  				direction_ = Direction.Left;  			}  		} else {  			direction_ = Direction.Up;  		}  	} else if (position_.Tile.Y == 13) {  		direction_ = Direction.Down;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  	if (position_.Tile.Y == 14) {  		initialJumps_--;  		if (initialJumps_ == 0) {  			if (position_.Tile.X == 11) {  				direction_ = Direction.Right;  			} else {  				direction_ = Direction.Left;  			}  		} else {  			direction_ = Direction.Up;  		}  	} else if (position_.Tile.Y == 13) {  		direction_ = Direction.Down;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  	if (position_.Tile.Y == 14) {  		initialJumps_--;  		if (initialJumps_ == 0) {  			if (position_.Tile.X == 11) {  				direction_ = Direction.Right;  			} else {  				direction_ = Direction.Left;  			}  		} else {  			direction_ = Direction.Up;  		}  	} else if (position_.Tile.Y == 13) {  		direction_ = Direction.Down;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  	if (position_.Tile.Y == 14) {  		initialJumps_--;  		if (initialJumps_ == 0) {  			if (position_.Tile.X == 11) {  				direction_ = Direction.Right;  			} else {  				direction_ = Direction.Left;  			}  		} else {  			direction_ = Direction.Up;  		}  	} else if (position_.Tile.Y == 13) {  		direction_ = Direction.Down;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  	if (position_.Tile.Y == 14) {  		initialJumps_--;  		if (initialJumps_ == 0) {  			if (position_.Tile.X == 11) {  				direction_ = Direction.Right;  			} else {  				direction_ = Direction.Left;  			}  		} else {  			direction_ = Direction.Up;  		}  	} else if (position_.Tile.Y == 13) {  		direction_ = Direction.Down;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if (position_.Tile.Y == 14) {  	initialJumps_--;  	if (initialJumps_ == 0) {  		if (position_.Tile.X == 11) {  			direction_ = Direction.Right;  		} else {  			direction_ = Direction.Left;  		}  	} else {  		direction_ = Direction.Up;  	}  } else if (position_.Tile.Y == 13) {  	direction_ = Direction.Down;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if (position_.Tile.Y == 14) {  	initialJumps_--;  	if (initialJumps_ == 0) {  		if (position_.Tile.X == 11) {  			direction_ = Direction.Right;  		} else {  			direction_ = Direction.Left;  		}  	} else {  		direction_ = Direction.Up;  	}  } else if (position_.Tile.Y == 13) {  	direction_ = Direction.Down;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if (position_.Tile.Y == 14) {  	initialJumps_--;  	if (initialJumps_ == 0) {  		if (position_.Tile.X == 11) {  			direction_ = Direction.Right;  		} else {  			direction_ = Direction.Left;  		}  	} else {  		direction_ = Direction.Up;  	}  } else if (position_.Tile.Y == 13) {  	direction_ = Direction.Down;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if (initialJumps_ == 0) {  	if (position_.Tile.X == 11) {  		direction_ = Direction.Right;  	} else {  		direction_ = Direction.Left;  	}  } else {  	direction_ = Direction.Up;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if (position_.Tile.X == 11) {  	direction_ = Direction.Right;  } else {  	direction_ = Direction.Left;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if (position_.Tile.Y == 13) {  	direction_ = Direction.Down;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {  	if (position_.Tile.Y == 14) {  		State = GhostState.Home;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {  	if (position_.Tile.Y == 14) {  		State = GhostState.Home;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {  	if (position_.Tile.Y == 14) {  		State = GhostState.Home;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if (position_.Tile.Y == 14) {  	State = GhostState.Home;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (20)) {  	State = GhostState.Scatter;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if ((initialState != previousState_) || (Grid.NumCrumps == 199 && previousNumCrumps_ == 200) || (Grid.NumCrumps == 19 && previousNumCrumps_ == 20)) {  	PlaySound ();  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if ((initialState != previousState_) || (Grid.NumCrumps == 199 && previousNumCrumps_ == 200) || (Grid.NumCrumps == 19 && previousNumCrumps_ == 20)) {  	PlaySound ();  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if ((initialState != previousState_) || (Grid.NumCrumps == 199 && previousNumCrumps_ == 200) || (Grid.NumCrumps == 19 && previousNumCrumps_ == 20)) {  	PlaySound ();  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: if ((initialState != previousState_) || (Grid.NumCrumps == 199 && previousNumCrumps_ == 200) || (Grid.NumCrumps == 19 && previousNumCrumps_ == 20)) {  	PlaySound ();  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Move,The following statement contains a magic number: if (updateCount_ == 0) {  	// There is no point running the full AI each update' especially considering we  	// want this code to run at 1000 updates per second. We run it each time it moves by a pixel.  	scheduleStateEval_ = true;  	// Now is a nice time to evaluate whether our current speed is correct. This variable  	// may change under a wide array of circumstances' so by putting it here we probably generate  	// too many checks but we ensure correct behavior.  	UpdateSpeed ();  	switch (direction_) {  	case Direction.Up:  		position_.DeltaPixel.Y--;  		if (position_.DeltaPixel.Y < 0) {  			position_.DeltaPixel.Y = 15;  			position_.Tile.Y--;  		}  		break;  	case Direction.Down:  		position_.DeltaPixel.Y++;  		if (position_.DeltaPixel.Y > 15) {  			position_.DeltaPixel.Y = 0;  			position_.Tile.Y++;  		}  		break;  	case Direction.Left:  		position_.DeltaPixel.X--;  		if (position_.DeltaPixel.X < 0) {  			position_.DeltaPixel.X = 15;  			position_.Tile.X--;  			// Special case : the tunnel  			if (position_.Tile.X < 0) {  				position_.Tile.X = Grid.Width - 1;  			}  		}  		break;  	case Direction.Right:  		position_.DeltaPixel.X++;  		if (position_.DeltaPixel.X > 15) {  			position_.DeltaPixel.X = 0;  			position_.Tile.X++;  			// Special case : the tunnel  			if (position_.Tile.X > Grid.Width - 1) {  				position_.Tile.X = 0;  			}  		}  		break;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Move,The following statement contains a magic number: if (updateCount_ == 0) {  	// There is no point running the full AI each update' especially considering we  	// want this code to run at 1000 updates per second. We run it each time it moves by a pixel.  	scheduleStateEval_ = true;  	// Now is a nice time to evaluate whether our current speed is correct. This variable  	// may change under a wide array of circumstances' so by putting it here we probably generate  	// too many checks but we ensure correct behavior.  	UpdateSpeed ();  	switch (direction_) {  	case Direction.Up:  		position_.DeltaPixel.Y--;  		if (position_.DeltaPixel.Y < 0) {  			position_.DeltaPixel.Y = 15;  			position_.Tile.Y--;  		}  		break;  	case Direction.Down:  		position_.DeltaPixel.Y++;  		if (position_.DeltaPixel.Y > 15) {  			position_.DeltaPixel.Y = 0;  			position_.Tile.Y++;  		}  		break;  	case Direction.Left:  		position_.DeltaPixel.X--;  		if (position_.DeltaPixel.X < 0) {  			position_.DeltaPixel.X = 15;  			position_.Tile.X--;  			// Special case : the tunnel  			if (position_.Tile.X < 0) {  				position_.Tile.X = Grid.Width - 1;  			}  		}  		break;  	case Direction.Right:  		position_.DeltaPixel.X++;  		if (position_.DeltaPixel.X > 15) {  			position_.DeltaPixel.X = 0;  			position_.Tile.X++;  			// Special case : the tunnel  			if (position_.Tile.X > Grid.Width - 1) {  				position_.Tile.X = 0;  			}  		}  		break;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Move,The following statement contains a magic number: if (updateCount_ == 0) {  	// There is no point running the full AI each update' especially considering we  	// want this code to run at 1000 updates per second. We run it each time it moves by a pixel.  	scheduleStateEval_ = true;  	// Now is a nice time to evaluate whether our current speed is correct. This variable  	// may change under a wide array of circumstances' so by putting it here we probably generate  	// too many checks but we ensure correct behavior.  	UpdateSpeed ();  	switch (direction_) {  	case Direction.Up:  		position_.DeltaPixel.Y--;  		if (position_.DeltaPixel.Y < 0) {  			position_.DeltaPixel.Y = 15;  			position_.Tile.Y--;  		}  		break;  	case Direction.Down:  		position_.DeltaPixel.Y++;  		if (position_.DeltaPixel.Y > 15) {  			position_.DeltaPixel.Y = 0;  			position_.Tile.Y++;  		}  		break;  	case Direction.Left:  		position_.DeltaPixel.X--;  		if (position_.DeltaPixel.X < 0) {  			position_.DeltaPixel.X = 15;  			position_.Tile.X--;  			// Special case : the tunnel  			if (position_.Tile.X < 0) {  				position_.Tile.X = Grid.Width - 1;  			}  		}  		break;  	case Direction.Right:  		position_.DeltaPixel.X++;  		if (position_.DeltaPixel.X > 15) {  			position_.DeltaPixel.X = 0;  			position_.Tile.X++;  			// Special case : the tunnel  			if (position_.Tile.X > Grid.Width - 1) {  				position_.Tile.X = 0;  			}  		}  		break;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Move,The following statement contains a magic number: if (updateCount_ == 0) {  	// There is no point running the full AI each update' especially considering we  	// want this code to run at 1000 updates per second. We run it each time it moves by a pixel.  	scheduleStateEval_ = true;  	// Now is a nice time to evaluate whether our current speed is correct. This variable  	// may change under a wide array of circumstances' so by putting it here we probably generate  	// too many checks but we ensure correct behavior.  	UpdateSpeed ();  	switch (direction_) {  	case Direction.Up:  		position_.DeltaPixel.Y--;  		if (position_.DeltaPixel.Y < 0) {  			position_.DeltaPixel.Y = 15;  			position_.Tile.Y--;  		}  		break;  	case Direction.Down:  		position_.DeltaPixel.Y++;  		if (position_.DeltaPixel.Y > 15) {  			position_.DeltaPixel.Y = 0;  			position_.Tile.Y++;  		}  		break;  	case Direction.Left:  		position_.DeltaPixel.X--;  		if (position_.DeltaPixel.X < 0) {  			position_.DeltaPixel.X = 15;  			position_.Tile.X--;  			// Special case : the tunnel  			if (position_.Tile.X < 0) {  				position_.Tile.X = Grid.Width - 1;  			}  		}  		break;  	case Direction.Right:  		position_.DeltaPixel.X++;  		if (position_.DeltaPixel.X > 15) {  			position_.DeltaPixel.X = 0;  			position_.Tile.X++;  			// Special case : the tunnel  			if (position_.Tile.X > Grid.Width - 1) {  				position_.Tile.X = 0;  			}  		}  		break;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Move,The following statement contains a magic number: switch (direction_) {  case Direction.Up:  	position_.DeltaPixel.Y--;  	if (position_.DeltaPixel.Y < 0) {  		position_.DeltaPixel.Y = 15;  		position_.Tile.Y--;  	}  	break;  case Direction.Down:  	position_.DeltaPixel.Y++;  	if (position_.DeltaPixel.Y > 15) {  		position_.DeltaPixel.Y = 0;  		position_.Tile.Y++;  	}  	break;  case Direction.Left:  	position_.DeltaPixel.X--;  	if (position_.DeltaPixel.X < 0) {  		position_.DeltaPixel.X = 15;  		position_.Tile.X--;  		// Special case : the tunnel  		if (position_.Tile.X < 0) {  			position_.Tile.X = Grid.Width - 1;  		}  	}  	break;  case Direction.Right:  	position_.DeltaPixel.X++;  	if (position_.DeltaPixel.X > 15) {  		position_.DeltaPixel.X = 0;  		position_.Tile.X++;  		// Special case : the tunnel  		if (position_.Tile.X > Grid.Width - 1) {  			position_.Tile.X = 0;  		}  	}  	break;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Move,The following statement contains a magic number: switch (direction_) {  case Direction.Up:  	position_.DeltaPixel.Y--;  	if (position_.DeltaPixel.Y < 0) {  		position_.DeltaPixel.Y = 15;  		position_.Tile.Y--;  	}  	break;  case Direction.Down:  	position_.DeltaPixel.Y++;  	if (position_.DeltaPixel.Y > 15) {  		position_.DeltaPixel.Y = 0;  		position_.Tile.Y++;  	}  	break;  case Direction.Left:  	position_.DeltaPixel.X--;  	if (position_.DeltaPixel.X < 0) {  		position_.DeltaPixel.X = 15;  		position_.Tile.X--;  		// Special case : the tunnel  		if (position_.Tile.X < 0) {  			position_.Tile.X = Grid.Width - 1;  		}  	}  	break;  case Direction.Right:  	position_.DeltaPixel.X++;  	if (position_.DeltaPixel.X > 15) {  		position_.DeltaPixel.X = 0;  		position_.Tile.X++;  		// Special case : the tunnel  		if (position_.Tile.X > Grid.Width - 1) {  			position_.Tile.X = 0;  		}  	}  	break;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Move,The following statement contains a magic number: switch (direction_) {  case Direction.Up:  	position_.DeltaPixel.Y--;  	if (position_.DeltaPixel.Y < 0) {  		position_.DeltaPixel.Y = 15;  		position_.Tile.Y--;  	}  	break;  case Direction.Down:  	position_.DeltaPixel.Y++;  	if (position_.DeltaPixel.Y > 15) {  		position_.DeltaPixel.Y = 0;  		position_.Tile.Y++;  	}  	break;  case Direction.Left:  	position_.DeltaPixel.X--;  	if (position_.DeltaPixel.X < 0) {  		position_.DeltaPixel.X = 15;  		position_.Tile.X--;  		// Special case : the tunnel  		if (position_.Tile.X < 0) {  			position_.Tile.X = Grid.Width - 1;  		}  	}  	break;  case Direction.Right:  	position_.DeltaPixel.X++;  	if (position_.DeltaPixel.X > 15) {  		position_.DeltaPixel.X = 0;  		position_.Tile.X++;  		// Special case : the tunnel  		if (position_.Tile.X > Grid.Width - 1) {  			position_.Tile.X = 0;  		}  	}  	break;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Move,The following statement contains a magic number: switch (direction_) {  case Direction.Up:  	position_.DeltaPixel.Y--;  	if (position_.DeltaPixel.Y < 0) {  		position_.DeltaPixel.Y = 15;  		position_.Tile.Y--;  	}  	break;  case Direction.Down:  	position_.DeltaPixel.Y++;  	if (position_.DeltaPixel.Y > 15) {  		position_.DeltaPixel.Y = 0;  		position_.Tile.Y++;  	}  	break;  case Direction.Left:  	position_.DeltaPixel.X--;  	if (position_.DeltaPixel.X < 0) {  		position_.DeltaPixel.X = 15;  		position_.Tile.X--;  		// Special case : the tunnel  		if (position_.Tile.X < 0) {  			position_.Tile.X = Grid.Width - 1;  		}  	}  	break;  case Direction.Right:  	position_.DeltaPixel.X++;  	if (position_.DeltaPixel.X > 15) {  		position_.DeltaPixel.X = 0;  		position_.Tile.X++;  		// Special case : the tunnel  		if (position_.Tile.X > Grid.Width - 1) {  			position_.Tile.X = 0;  		}  	}  	break;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Move,The following statement contains a magic number: if (position_.DeltaPixel.Y < 0) {  	position_.DeltaPixel.Y = 15;  	position_.Tile.Y--;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Move,The following statement contains a magic number: position_.DeltaPixel.Y = 15;  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Move,The following statement contains a magic number: if (position_.DeltaPixel.Y > 15) {  	position_.DeltaPixel.Y = 0;  	position_.Tile.Y++;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Move,The following statement contains a magic number: if (position_.DeltaPixel.X < 0) {  	position_.DeltaPixel.X = 15;  	position_.Tile.X--;  	// Special case : the tunnel  	if (position_.Tile.X < 0) {  		position_.Tile.X = Grid.Width - 1;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Move,The following statement contains a magic number: position_.DeltaPixel.X = 15;  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Move,The following statement contains a magic number: if (position_.DeltaPixel.X > 15) {  	position_.DeltaPixel.X = 0;  	position_.Tile.X++;  	// Special case : the tunnel  	if (position_.Tile.X > Grid.Width - 1) {  		position_.Tile.X = 0;  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,UpdateSpeed,The following statement contains a magic number: if (State == GhostState.Home) {  	updatesPerPixel_ = baseSpeed * 2;  } else if (State == GhostState.Blue) {  	updatesPerPixel_ = (int)(baseSpeed * 1.5);  } else if (identity_ == Ghosts.Blinky && Grid.NumCrumps <= Constants.CruiseElroyTimer ()) {  	updatesPerPixel_ = baseSpeed - 1;  } // If in the tunnel' reduce speed  else if (position_.Tile.Y == 14 && ((0 <= position_.Tile.X && position_.Tile.X <= 5) || (22 <= position_.Tile.X && position_.Tile.X <= 27))) {  	updatesPerPixel_ = baseSpeed + 5;  } else {  	updatesPerPixel_ = baseSpeed;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,UpdateSpeed,The following statement contains a magic number: if (State == GhostState.Home) {  	updatesPerPixel_ = baseSpeed * 2;  } else if (State == GhostState.Blue) {  	updatesPerPixel_ = (int)(baseSpeed * 1.5);  } else if (identity_ == Ghosts.Blinky && Grid.NumCrumps <= Constants.CruiseElroyTimer ()) {  	updatesPerPixel_ = baseSpeed - 1;  } // If in the tunnel' reduce speed  else if (position_.Tile.Y == 14 && ((0 <= position_.Tile.X && position_.Tile.X <= 5) || (22 <= position_.Tile.X && position_.Tile.X <= 27))) {  	updatesPerPixel_ = baseSpeed + 5;  } else {  	updatesPerPixel_ = baseSpeed;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,UpdateSpeed,The following statement contains a magic number: if (State == GhostState.Home) {  	updatesPerPixel_ = baseSpeed * 2;  } else if (State == GhostState.Blue) {  	updatesPerPixel_ = (int)(baseSpeed * 1.5);  } else if (identity_ == Ghosts.Blinky && Grid.NumCrumps <= Constants.CruiseElroyTimer ()) {  	updatesPerPixel_ = baseSpeed - 1;  } // If in the tunnel' reduce speed  else if (position_.Tile.Y == 14 && ((0 <= position_.Tile.X && position_.Tile.X <= 5) || (22 <= position_.Tile.X && position_.Tile.X <= 27))) {  	updatesPerPixel_ = baseSpeed + 5;  } else {  	updatesPerPixel_ = baseSpeed;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,UpdateSpeed,The following statement contains a magic number: if (State == GhostState.Home) {  	updatesPerPixel_ = baseSpeed * 2;  } else if (State == GhostState.Blue) {  	updatesPerPixel_ = (int)(baseSpeed * 1.5);  } else if (identity_ == Ghosts.Blinky && Grid.NumCrumps <= Constants.CruiseElroyTimer ()) {  	updatesPerPixel_ = baseSpeed - 1;  } // If in the tunnel' reduce speed  else if (position_.Tile.Y == 14 && ((0 <= position_.Tile.X && position_.Tile.X <= 5) || (22 <= position_.Tile.X && position_.Tile.X <= 27))) {  	updatesPerPixel_ = baseSpeed + 5;  } else {  	updatesPerPixel_ = baseSpeed;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,UpdateSpeed,The following statement contains a magic number: if (State == GhostState.Home) {  	updatesPerPixel_ = baseSpeed * 2;  } else if (State == GhostState.Blue) {  	updatesPerPixel_ = (int)(baseSpeed * 1.5);  } else if (identity_ == Ghosts.Blinky && Grid.NumCrumps <= Constants.CruiseElroyTimer ()) {  	updatesPerPixel_ = baseSpeed - 1;  } // If in the tunnel' reduce speed  else if (position_.Tile.Y == 14 && ((0 <= position_.Tile.X && position_.Tile.X <= 5) || (22 <= position_.Tile.X && position_.Tile.X <= 27))) {  	updatesPerPixel_ = baseSpeed + 5;  } else {  	updatesPerPixel_ = baseSpeed;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,UpdateSpeed,The following statement contains a magic number: if (State == GhostState.Home) {  	updatesPerPixel_ = baseSpeed * 2;  } else if (State == GhostState.Blue) {  	updatesPerPixel_ = (int)(baseSpeed * 1.5);  } else if (identity_ == Ghosts.Blinky && Grid.NumCrumps <= Constants.CruiseElroyTimer ()) {  	updatesPerPixel_ = baseSpeed - 1;  } // If in the tunnel' reduce speed  else if (position_.Tile.Y == 14 && ((0 <= position_.Tile.X && position_.Tile.X <= 5) || (22 <= position_.Tile.X && position_.Tile.X <= 27))) {  	updatesPerPixel_ = baseSpeed + 5;  } else {  	updatesPerPixel_ = baseSpeed;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,UpdateSpeed,The following statement contains a magic number: if (State == GhostState.Home) {  	updatesPerPixel_ = baseSpeed * 2;  } else if (State == GhostState.Blue) {  	updatesPerPixel_ = (int)(baseSpeed * 1.5);  } else if (identity_ == Ghosts.Blinky && Grid.NumCrumps <= Constants.CruiseElroyTimer ()) {  	updatesPerPixel_ = baseSpeed - 1;  } // If in the tunnel' reduce speed  else if (position_.Tile.Y == 14 && ((0 <= position_.Tile.X && position_.Tile.X <= 5) || (22 <= position_.Tile.X && position_.Tile.X <= 27))) {  	updatesPerPixel_ = baseSpeed + 5;  } else {  	updatesPerPixel_ = baseSpeed;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,UpdateSpeed,The following statement contains a magic number: updatesPerPixel_ = baseSpeed * 2;  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,UpdateSpeed,The following statement contains a magic number: if (State == GhostState.Blue) {  	updatesPerPixel_ = (int)(baseSpeed * 1.5);  } else if (identity_ == Ghosts.Blinky && Grid.NumCrumps <= Constants.CruiseElroyTimer ()) {  	updatesPerPixel_ = baseSpeed - 1;  } // If in the tunnel' reduce speed  else if (position_.Tile.Y == 14 && ((0 <= position_.Tile.X && position_.Tile.X <= 5) || (22 <= position_.Tile.X && position_.Tile.X <= 27))) {  	updatesPerPixel_ = baseSpeed + 5;  } else {  	updatesPerPixel_ = baseSpeed;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,UpdateSpeed,The following statement contains a magic number: if (State == GhostState.Blue) {  	updatesPerPixel_ = (int)(baseSpeed * 1.5);  } else if (identity_ == Ghosts.Blinky && Grid.NumCrumps <= Constants.CruiseElroyTimer ()) {  	updatesPerPixel_ = baseSpeed - 1;  } // If in the tunnel' reduce speed  else if (position_.Tile.Y == 14 && ((0 <= position_.Tile.X && position_.Tile.X <= 5) || (22 <= position_.Tile.X && position_.Tile.X <= 27))) {  	updatesPerPixel_ = baseSpeed + 5;  } else {  	updatesPerPixel_ = baseSpeed;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,UpdateSpeed,The following statement contains a magic number: if (State == GhostState.Blue) {  	updatesPerPixel_ = (int)(baseSpeed * 1.5);  } else if (identity_ == Ghosts.Blinky && Grid.NumCrumps <= Constants.CruiseElroyTimer ()) {  	updatesPerPixel_ = baseSpeed - 1;  } // If in the tunnel' reduce speed  else if (position_.Tile.Y == 14 && ((0 <= position_.Tile.X && position_.Tile.X <= 5) || (22 <= position_.Tile.X && position_.Tile.X <= 27))) {  	updatesPerPixel_ = baseSpeed + 5;  } else {  	updatesPerPixel_ = baseSpeed;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,UpdateSpeed,The following statement contains a magic number: if (State == GhostState.Blue) {  	updatesPerPixel_ = (int)(baseSpeed * 1.5);  } else if (identity_ == Ghosts.Blinky && Grid.NumCrumps <= Constants.CruiseElroyTimer ()) {  	updatesPerPixel_ = baseSpeed - 1;  } // If in the tunnel' reduce speed  else if (position_.Tile.Y == 14 && ((0 <= position_.Tile.X && position_.Tile.X <= 5) || (22 <= position_.Tile.X && position_.Tile.X <= 27))) {  	updatesPerPixel_ = baseSpeed + 5;  } else {  	updatesPerPixel_ = baseSpeed;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,UpdateSpeed,The following statement contains a magic number: if (State == GhostState.Blue) {  	updatesPerPixel_ = (int)(baseSpeed * 1.5);  } else if (identity_ == Ghosts.Blinky && Grid.NumCrumps <= Constants.CruiseElroyTimer ()) {  	updatesPerPixel_ = baseSpeed - 1;  } // If in the tunnel' reduce speed  else if (position_.Tile.Y == 14 && ((0 <= position_.Tile.X && position_.Tile.X <= 5) || (22 <= position_.Tile.X && position_.Tile.X <= 27))) {  	updatesPerPixel_ = baseSpeed + 5;  } else {  	updatesPerPixel_ = baseSpeed;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,UpdateSpeed,The following statement contains a magic number: if (State == GhostState.Blue) {  	updatesPerPixel_ = (int)(baseSpeed * 1.5);  } else if (identity_ == Ghosts.Blinky && Grid.NumCrumps <= Constants.CruiseElroyTimer ()) {  	updatesPerPixel_ = baseSpeed - 1;  } // If in the tunnel' reduce speed  else if (position_.Tile.Y == 14 && ((0 <= position_.Tile.X && position_.Tile.X <= 5) || (22 <= position_.Tile.X && position_.Tile.X <= 27))) {  	updatesPerPixel_ = baseSpeed + 5;  } else {  	updatesPerPixel_ = baseSpeed;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,UpdateSpeed,The following statement contains a magic number: updatesPerPixel_ = (int)(baseSpeed * 1.5);  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,UpdateSpeed,The following statement contains a magic number: if (identity_ == Ghosts.Blinky && Grid.NumCrumps <= Constants.CruiseElroyTimer ()) {  	updatesPerPixel_ = baseSpeed - 1;  } // If in the tunnel' reduce speed  else if (position_.Tile.Y == 14 && ((0 <= position_.Tile.X && position_.Tile.X <= 5) || (22 <= position_.Tile.X && position_.Tile.X <= 27))) {  	updatesPerPixel_ = baseSpeed + 5;  } else {  	updatesPerPixel_ = baseSpeed;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,UpdateSpeed,The following statement contains a magic number: if (identity_ == Ghosts.Blinky && Grid.NumCrumps <= Constants.CruiseElroyTimer ()) {  	updatesPerPixel_ = baseSpeed - 1;  } // If in the tunnel' reduce speed  else if (position_.Tile.Y == 14 && ((0 <= position_.Tile.X && position_.Tile.X <= 5) || (22 <= position_.Tile.X && position_.Tile.X <= 27))) {  	updatesPerPixel_ = baseSpeed + 5;  } else {  	updatesPerPixel_ = baseSpeed;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,UpdateSpeed,The following statement contains a magic number: if (identity_ == Ghosts.Blinky && Grid.NumCrumps <= Constants.CruiseElroyTimer ()) {  	updatesPerPixel_ = baseSpeed - 1;  } // If in the tunnel' reduce speed  else if (position_.Tile.Y == 14 && ((0 <= position_.Tile.X && position_.Tile.X <= 5) || (22 <= position_.Tile.X && position_.Tile.X <= 27))) {  	updatesPerPixel_ = baseSpeed + 5;  } else {  	updatesPerPixel_ = baseSpeed;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,UpdateSpeed,The following statement contains a magic number: if (identity_ == Ghosts.Blinky && Grid.NumCrumps <= Constants.CruiseElroyTimer ()) {  	updatesPerPixel_ = baseSpeed - 1;  } // If in the tunnel' reduce speed  else if (position_.Tile.Y == 14 && ((0 <= position_.Tile.X && position_.Tile.X <= 5) || (22 <= position_.Tile.X && position_.Tile.X <= 27))) {  	updatesPerPixel_ = baseSpeed + 5;  } else {  	updatesPerPixel_ = baseSpeed;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,UpdateSpeed,The following statement contains a magic number: if (identity_ == Ghosts.Blinky && Grid.NumCrumps <= Constants.CruiseElroyTimer ()) {  	updatesPerPixel_ = baseSpeed - 1;  } // If in the tunnel' reduce speed  else if (position_.Tile.Y == 14 && ((0 <= position_.Tile.X && position_.Tile.X <= 5) || (22 <= position_.Tile.X && position_.Tile.X <= 27))) {  	updatesPerPixel_ = baseSpeed + 5;  } else {  	updatesPerPixel_ = baseSpeed;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,UpdateSpeed,The following statement contains a magic number: if (position_.Tile.Y == 14 && ((0 <= position_.Tile.X && position_.Tile.X <= 5) || (22 <= position_.Tile.X && position_.Tile.X <= 27))) {  	updatesPerPixel_ = baseSpeed + 5;  } else {  	updatesPerPixel_ = baseSpeed;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,UpdateSpeed,The following statement contains a magic number: if (position_.Tile.Y == 14 && ((0 <= position_.Tile.X && position_.Tile.X <= 5) || (22 <= position_.Tile.X && position_.Tile.X <= 27))) {  	updatesPerPixel_ = baseSpeed + 5;  } else {  	updatesPerPixel_ = baseSpeed;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,UpdateSpeed,The following statement contains a magic number: if (position_.Tile.Y == 14 && ((0 <= position_.Tile.X && position_.Tile.X <= 5) || (22 <= position_.Tile.X && position_.Tile.X <= 27))) {  	updatesPerPixel_ = baseSpeed + 5;  } else {  	updatesPerPixel_ = baseSpeed;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,UpdateSpeed,The following statement contains a magic number: if (position_.Tile.Y == 14 && ((0 <= position_.Tile.X && position_.Tile.X <= 5) || (22 <= position_.Tile.X && position_.Tile.X <= 27))) {  	updatesPerPixel_ = baseSpeed + 5;  } else {  	updatesPerPixel_ = baseSpeed;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,UpdateSpeed,The following statement contains a magic number: if (position_.Tile.Y == 14 && ((0 <= position_.Tile.X && position_.Tile.X <= 5) || (22 <= position_.Tile.X && position_.Tile.X <= 27))) {  	updatesPerPixel_ = baseSpeed + 5;  } else {  	updatesPerPixel_ = baseSpeed;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,UpdateSpeed,The following statement contains a magic number: updatesPerPixel_ = baseSpeed + 5;  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.Tile.Y == 11 && position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  	direction_ = Direction.Down;  } // Otherwise' only change direction if the ghost is exactly on a tile  else if (position_.DeltaPixel == Point.Zero) {  	// We direct the ghost towards one of the two squares above the home. When he reaches one'  	// he still has to move slightly right or left in order to align with the entrance.  	if (position_.Tile.X == 13 && position_.Tile.Y == 11) {  		direction_ = Direction.Right;  	} else if (position_.Tile.X == 14 && position_.Tile.Y == 11) {  		direction_ = Direction.Left;  	} // Otherwise' when at a junction' head for the square above home closest to us.  	else if (IsAJunction (position_.Tile)) {  		if (position_.Tile.X > 13) {  			direction_ = FindDirection (new Point (14' 11));  		} else {  			direction_ = FindDirection (new Point (13' 11));  		}  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.Tile.Y == 11 && position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  	direction_ = Direction.Down;  } // Otherwise' only change direction if the ghost is exactly on a tile  else if (position_.DeltaPixel == Point.Zero) {  	// We direct the ghost towards one of the two squares above the home. When he reaches one'  	// he still has to move slightly right or left in order to align with the entrance.  	if (position_.Tile.X == 13 && position_.Tile.Y == 11) {  		direction_ = Direction.Right;  	} else if (position_.Tile.X == 14 && position_.Tile.Y == 11) {  		direction_ = Direction.Left;  	} // Otherwise' when at a junction' head for the square above home closest to us.  	else if (IsAJunction (position_.Tile)) {  		if (position_.Tile.X > 13) {  			direction_ = FindDirection (new Point (14' 11));  		} else {  			direction_ = FindDirection (new Point (13' 11));  		}  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.Tile.Y == 11 && position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  	direction_ = Direction.Down;  } // Otherwise' only change direction if the ghost is exactly on a tile  else if (position_.DeltaPixel == Point.Zero) {  	// We direct the ghost towards one of the two squares above the home. When he reaches one'  	// he still has to move slightly right or left in order to align with the entrance.  	if (position_.Tile.X == 13 && position_.Tile.Y == 11) {  		direction_ = Direction.Right;  	} else if (position_.Tile.X == 14 && position_.Tile.Y == 11) {  		direction_ = Direction.Left;  	} // Otherwise' when at a junction' head for the square above home closest to us.  	else if (IsAJunction (position_.Tile)) {  		if (position_.Tile.X > 13) {  			direction_ = FindDirection (new Point (14' 11));  		} else {  			direction_ = FindDirection (new Point (13' 11));  		}  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.Tile.Y == 11 && position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  	direction_ = Direction.Down;  } // Otherwise' only change direction if the ghost is exactly on a tile  else if (position_.DeltaPixel == Point.Zero) {  	// We direct the ghost towards one of the two squares above the home. When he reaches one'  	// he still has to move slightly right or left in order to align with the entrance.  	if (position_.Tile.X == 13 && position_.Tile.Y == 11) {  		direction_ = Direction.Right;  	} else if (position_.Tile.X == 14 && position_.Tile.Y == 11) {  		direction_ = Direction.Left;  	} // Otherwise' when at a junction' head for the square above home closest to us.  	else if (IsAJunction (position_.Tile)) {  		if (position_.Tile.X > 13) {  			direction_ = FindDirection (new Point (14' 11));  		} else {  			direction_ = FindDirection (new Point (13' 11));  		}  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.Tile.Y == 11 && position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  	direction_ = Direction.Down;  } // Otherwise' only change direction if the ghost is exactly on a tile  else if (position_.DeltaPixel == Point.Zero) {  	// We direct the ghost towards one of the two squares above the home. When he reaches one'  	// he still has to move slightly right or left in order to align with the entrance.  	if (position_.Tile.X == 13 && position_.Tile.Y == 11) {  		direction_ = Direction.Right;  	} else if (position_.Tile.X == 14 && position_.Tile.Y == 11) {  		direction_ = Direction.Left;  	} // Otherwise' when at a junction' head for the square above home closest to us.  	else if (IsAJunction (position_.Tile)) {  		if (position_.Tile.X > 13) {  			direction_ = FindDirection (new Point (14' 11));  		} else {  			direction_ = FindDirection (new Point (13' 11));  		}  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.Tile.Y == 11 && position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  	direction_ = Direction.Down;  } // Otherwise' only change direction if the ghost is exactly on a tile  else if (position_.DeltaPixel == Point.Zero) {  	// We direct the ghost towards one of the two squares above the home. When he reaches one'  	// he still has to move slightly right or left in order to align with the entrance.  	if (position_.Tile.X == 13 && position_.Tile.Y == 11) {  		direction_ = Direction.Right;  	} else if (position_.Tile.X == 14 && position_.Tile.Y == 11) {  		direction_ = Direction.Left;  	} // Otherwise' when at a junction' head for the square above home closest to us.  	else if (IsAJunction (position_.Tile)) {  		if (position_.Tile.X > 13) {  			direction_ = FindDirection (new Point (14' 11));  		} else {  			direction_ = FindDirection (new Point (13' 11));  		}  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.Tile.Y == 11 && position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  	direction_ = Direction.Down;  } // Otherwise' only change direction if the ghost is exactly on a tile  else if (position_.DeltaPixel == Point.Zero) {  	// We direct the ghost towards one of the two squares above the home. When he reaches one'  	// he still has to move slightly right or left in order to align with the entrance.  	if (position_.Tile.X == 13 && position_.Tile.Y == 11) {  		direction_ = Direction.Right;  	} else if (position_.Tile.X == 14 && position_.Tile.Y == 11) {  		direction_ = Direction.Left;  	} // Otherwise' when at a junction' head for the square above home closest to us.  	else if (IsAJunction (position_.Tile)) {  		if (position_.Tile.X > 13) {  			direction_ = FindDirection (new Point (14' 11));  		} else {  			direction_ = FindDirection (new Point (13' 11));  		}  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.Tile.Y == 11 && position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  	direction_ = Direction.Down;  } // Otherwise' only change direction if the ghost is exactly on a tile  else if (position_.DeltaPixel == Point.Zero) {  	// We direct the ghost towards one of the two squares above the home. When he reaches one'  	// he still has to move slightly right or left in order to align with the entrance.  	if (position_.Tile.X == 13 && position_.Tile.Y == 11) {  		direction_ = Direction.Right;  	} else if (position_.Tile.X == 14 && position_.Tile.Y == 11) {  		direction_ = Direction.Left;  	} // Otherwise' when at a junction' head for the square above home closest to us.  	else if (IsAJunction (position_.Tile)) {  		if (position_.Tile.X > 13) {  			direction_ = FindDirection (new Point (14' 11));  		} else {  			direction_ = FindDirection (new Point (13' 11));  		}  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.Tile.Y == 11 && position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  	direction_ = Direction.Down;  } // Otherwise' only change direction if the ghost is exactly on a tile  else if (position_.DeltaPixel == Point.Zero) {  	// We direct the ghost towards one of the two squares above the home. When he reaches one'  	// he still has to move slightly right or left in order to align with the entrance.  	if (position_.Tile.X == 13 && position_.Tile.Y == 11) {  		direction_ = Direction.Right;  	} else if (position_.Tile.X == 14 && position_.Tile.Y == 11) {  		direction_ = Direction.Left;  	} // Otherwise' when at a junction' head for the square above home closest to us.  	else if (IsAJunction (position_.Tile)) {  		if (position_.Tile.X > 13) {  			direction_ = FindDirection (new Point (14' 11));  		} else {  			direction_ = FindDirection (new Point (13' 11));  		}  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.Tile.Y == 11 && position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  	direction_ = Direction.Down;  } // Otherwise' only change direction if the ghost is exactly on a tile  else if (position_.DeltaPixel == Point.Zero) {  	// We direct the ghost towards one of the two squares above the home. When he reaches one'  	// he still has to move slightly right or left in order to align with the entrance.  	if (position_.Tile.X == 13 && position_.Tile.Y == 11) {  		direction_ = Direction.Right;  	} else if (position_.Tile.X == 14 && position_.Tile.Y == 11) {  		direction_ = Direction.Left;  	} // Otherwise' when at a junction' head for the square above home closest to us.  	else if (IsAJunction (position_.Tile)) {  		if (position_.Tile.X > 13) {  			direction_ = FindDirection (new Point (14' 11));  		} else {  			direction_ = FindDirection (new Point (13' 11));  		}  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.Tile.Y == 11 && position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  	direction_ = Direction.Down;  } // Otherwise' only change direction if the ghost is exactly on a tile  else if (position_.DeltaPixel == Point.Zero) {  	// We direct the ghost towards one of the two squares above the home. When he reaches one'  	// he still has to move slightly right or left in order to align with the entrance.  	if (position_.Tile.X == 13 && position_.Tile.Y == 11) {  		direction_ = Direction.Right;  	} else if (position_.Tile.X == 14 && position_.Tile.Y == 11) {  		direction_ = Direction.Left;  	} // Otherwise' when at a junction' head for the square above home closest to us.  	else if (IsAJunction (position_.Tile)) {  		if (position_.Tile.X > 13) {  			direction_ = FindDirection (new Point (14' 11));  		} else {  			direction_ = FindDirection (new Point (13' 11));  		}  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.Tile.Y == 11 && position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  	direction_ = Direction.Down;  } // Otherwise' only change direction if the ghost is exactly on a tile  else if (position_.DeltaPixel == Point.Zero) {  	// We direct the ghost towards one of the two squares above the home. When he reaches one'  	// he still has to move slightly right or left in order to align with the entrance.  	if (position_.Tile.X == 13 && position_.Tile.Y == 11) {  		direction_ = Direction.Right;  	} else if (position_.Tile.X == 14 && position_.Tile.Y == 11) {  		direction_ = Direction.Left;  	} // Otherwise' when at a junction' head for the square above home closest to us.  	else if (IsAJunction (position_.Tile)) {  		if (position_.Tile.X > 13) {  			direction_ = FindDirection (new Point (14' 11));  		} else {  			direction_ = FindDirection (new Point (13' 11));  		}  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.DeltaPixel == Point.Zero) {  	// We direct the ghost towards one of the two squares above the home. When he reaches one'  	// he still has to move slightly right or left in order to align with the entrance.  	if (position_.Tile.X == 13 && position_.Tile.Y == 11) {  		direction_ = Direction.Right;  	} else if (position_.Tile.X == 14 && position_.Tile.Y == 11) {  		direction_ = Direction.Left;  	} // Otherwise' when at a junction' head for the square above home closest to us.  	else if (IsAJunction (position_.Tile)) {  		if (position_.Tile.X > 13) {  			direction_ = FindDirection (new Point (14' 11));  		} else {  			direction_ = FindDirection (new Point (13' 11));  		}  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.DeltaPixel == Point.Zero) {  	// We direct the ghost towards one of the two squares above the home. When he reaches one'  	// he still has to move slightly right or left in order to align with the entrance.  	if (position_.Tile.X == 13 && position_.Tile.Y == 11) {  		direction_ = Direction.Right;  	} else if (position_.Tile.X == 14 && position_.Tile.Y == 11) {  		direction_ = Direction.Left;  	} // Otherwise' when at a junction' head for the square above home closest to us.  	else if (IsAJunction (position_.Tile)) {  		if (position_.Tile.X > 13) {  			direction_ = FindDirection (new Point (14' 11));  		} else {  			direction_ = FindDirection (new Point (13' 11));  		}  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.DeltaPixel == Point.Zero) {  	// We direct the ghost towards one of the two squares above the home. When he reaches one'  	// he still has to move slightly right or left in order to align with the entrance.  	if (position_.Tile.X == 13 && position_.Tile.Y == 11) {  		direction_ = Direction.Right;  	} else if (position_.Tile.X == 14 && position_.Tile.Y == 11) {  		direction_ = Direction.Left;  	} // Otherwise' when at a junction' head for the square above home closest to us.  	else if (IsAJunction (position_.Tile)) {  		if (position_.Tile.X > 13) {  			direction_ = FindDirection (new Point (14' 11));  		} else {  			direction_ = FindDirection (new Point (13' 11));  		}  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.DeltaPixel == Point.Zero) {  	// We direct the ghost towards one of the two squares above the home. When he reaches one'  	// he still has to move slightly right or left in order to align with the entrance.  	if (position_.Tile.X == 13 && position_.Tile.Y == 11) {  		direction_ = Direction.Right;  	} else if (position_.Tile.X == 14 && position_.Tile.Y == 11) {  		direction_ = Direction.Left;  	} // Otherwise' when at a junction' head for the square above home closest to us.  	else if (IsAJunction (position_.Tile)) {  		if (position_.Tile.X > 13) {  			direction_ = FindDirection (new Point (14' 11));  		} else {  			direction_ = FindDirection (new Point (13' 11));  		}  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.DeltaPixel == Point.Zero) {  	// We direct the ghost towards one of the two squares above the home. When he reaches one'  	// he still has to move slightly right or left in order to align with the entrance.  	if (position_.Tile.X == 13 && position_.Tile.Y == 11) {  		direction_ = Direction.Right;  	} else if (position_.Tile.X == 14 && position_.Tile.Y == 11) {  		direction_ = Direction.Left;  	} // Otherwise' when at a junction' head for the square above home closest to us.  	else if (IsAJunction (position_.Tile)) {  		if (position_.Tile.X > 13) {  			direction_ = FindDirection (new Point (14' 11));  		} else {  			direction_ = FindDirection (new Point (13' 11));  		}  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.DeltaPixel == Point.Zero) {  	// We direct the ghost towards one of the two squares above the home. When he reaches one'  	// he still has to move slightly right or left in order to align with the entrance.  	if (position_.Tile.X == 13 && position_.Tile.Y == 11) {  		direction_ = Direction.Right;  	} else if (position_.Tile.X == 14 && position_.Tile.Y == 11) {  		direction_ = Direction.Left;  	} // Otherwise' when at a junction' head for the square above home closest to us.  	else if (IsAJunction (position_.Tile)) {  		if (position_.Tile.X > 13) {  			direction_ = FindDirection (new Point (14' 11));  		} else {  			direction_ = FindDirection (new Point (13' 11));  		}  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.DeltaPixel == Point.Zero) {  	// We direct the ghost towards one of the two squares above the home. When he reaches one'  	// he still has to move slightly right or left in order to align with the entrance.  	if (position_.Tile.X == 13 && position_.Tile.Y == 11) {  		direction_ = Direction.Right;  	} else if (position_.Tile.X == 14 && position_.Tile.Y == 11) {  		direction_ = Direction.Left;  	} // Otherwise' when at a junction' head for the square above home closest to us.  	else if (IsAJunction (position_.Tile)) {  		if (position_.Tile.X > 13) {  			direction_ = FindDirection (new Point (14' 11));  		} else {  			direction_ = FindDirection (new Point (13' 11));  		}  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.DeltaPixel == Point.Zero) {  	// We direct the ghost towards one of the two squares above the home. When he reaches one'  	// he still has to move slightly right or left in order to align with the entrance.  	if (position_.Tile.X == 13 && position_.Tile.Y == 11) {  		direction_ = Direction.Right;  	} else if (position_.Tile.X == 14 && position_.Tile.Y == 11) {  		direction_ = Direction.Left;  	} // Otherwise' when at a junction' head for the square above home closest to us.  	else if (IsAJunction (position_.Tile)) {  		if (position_.Tile.X > 13) {  			direction_ = FindDirection (new Point (14' 11));  		} else {  			direction_ = FindDirection (new Point (13' 11));  		}  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.DeltaPixel == Point.Zero) {  	// We direct the ghost towards one of the two squares above the home. When he reaches one'  	// he still has to move slightly right or left in order to align with the entrance.  	if (position_.Tile.X == 13 && position_.Tile.Y == 11) {  		direction_ = Direction.Right;  	} else if (position_.Tile.X == 14 && position_.Tile.Y == 11) {  		direction_ = Direction.Left;  	} // Otherwise' when at a junction' head for the square above home closest to us.  	else if (IsAJunction (position_.Tile)) {  		if (position_.Tile.X > 13) {  			direction_ = FindDirection (new Point (14' 11));  		} else {  			direction_ = FindDirection (new Point (13' 11));  		}  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.Tile.X == 13 && position_.Tile.Y == 11) {  	direction_ = Direction.Right;  } else if (position_.Tile.X == 14 && position_.Tile.Y == 11) {  	direction_ = Direction.Left;  } // Otherwise' when at a junction' head for the square above home closest to us.  else if (IsAJunction (position_.Tile)) {  	if (position_.Tile.X > 13) {  		direction_ = FindDirection (new Point (14' 11));  	} else {  		direction_ = FindDirection (new Point (13' 11));  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.Tile.X == 13 && position_.Tile.Y == 11) {  	direction_ = Direction.Right;  } else if (position_.Tile.X == 14 && position_.Tile.Y == 11) {  	direction_ = Direction.Left;  } // Otherwise' when at a junction' head for the square above home closest to us.  else if (IsAJunction (position_.Tile)) {  	if (position_.Tile.X > 13) {  		direction_ = FindDirection (new Point (14' 11));  	} else {  		direction_ = FindDirection (new Point (13' 11));  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.Tile.X == 13 && position_.Tile.Y == 11) {  	direction_ = Direction.Right;  } else if (position_.Tile.X == 14 && position_.Tile.Y == 11) {  	direction_ = Direction.Left;  } // Otherwise' when at a junction' head for the square above home closest to us.  else if (IsAJunction (position_.Tile)) {  	if (position_.Tile.X > 13) {  		direction_ = FindDirection (new Point (14' 11));  	} else {  		direction_ = FindDirection (new Point (13' 11));  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.Tile.X == 13 && position_.Tile.Y == 11) {  	direction_ = Direction.Right;  } else if (position_.Tile.X == 14 && position_.Tile.Y == 11) {  	direction_ = Direction.Left;  } // Otherwise' when at a junction' head for the square above home closest to us.  else if (IsAJunction (position_.Tile)) {  	if (position_.Tile.X > 13) {  		direction_ = FindDirection (new Point (14' 11));  	} else {  		direction_ = FindDirection (new Point (13' 11));  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.Tile.X == 13 && position_.Tile.Y == 11) {  	direction_ = Direction.Right;  } else if (position_.Tile.X == 14 && position_.Tile.Y == 11) {  	direction_ = Direction.Left;  } // Otherwise' when at a junction' head for the square above home closest to us.  else if (IsAJunction (position_.Tile)) {  	if (position_.Tile.X > 13) {  		direction_ = FindDirection (new Point (14' 11));  	} else {  		direction_ = FindDirection (new Point (13' 11));  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.Tile.X == 13 && position_.Tile.Y == 11) {  	direction_ = Direction.Right;  } else if (position_.Tile.X == 14 && position_.Tile.Y == 11) {  	direction_ = Direction.Left;  } // Otherwise' when at a junction' head for the square above home closest to us.  else if (IsAJunction (position_.Tile)) {  	if (position_.Tile.X > 13) {  		direction_ = FindDirection (new Point (14' 11));  	} else {  		direction_ = FindDirection (new Point (13' 11));  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.Tile.X == 13 && position_.Tile.Y == 11) {  	direction_ = Direction.Right;  } else if (position_.Tile.X == 14 && position_.Tile.Y == 11) {  	direction_ = Direction.Left;  } // Otherwise' when at a junction' head for the square above home closest to us.  else if (IsAJunction (position_.Tile)) {  	if (position_.Tile.X > 13) {  		direction_ = FindDirection (new Point (14' 11));  	} else {  		direction_ = FindDirection (new Point (13' 11));  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.Tile.X == 13 && position_.Tile.Y == 11) {  	direction_ = Direction.Right;  } else if (position_.Tile.X == 14 && position_.Tile.Y == 11) {  	direction_ = Direction.Left;  } // Otherwise' when at a junction' head for the square above home closest to us.  else if (IsAJunction (position_.Tile)) {  	if (position_.Tile.X > 13) {  		direction_ = FindDirection (new Point (14' 11));  	} else {  		direction_ = FindDirection (new Point (13' 11));  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.Tile.X == 13 && position_.Tile.Y == 11) {  	direction_ = Direction.Right;  } else if (position_.Tile.X == 14 && position_.Tile.Y == 11) {  	direction_ = Direction.Left;  } // Otherwise' when at a junction' head for the square above home closest to us.  else if (IsAJunction (position_.Tile)) {  	if (position_.Tile.X > 13) {  		direction_ = FindDirection (new Point (14' 11));  	} else {  		direction_ = FindDirection (new Point (13' 11));  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.Tile.X == 14 && position_.Tile.Y == 11) {  	direction_ = Direction.Left;  } // Otherwise' when at a junction' head for the square above home closest to us.  else if (IsAJunction (position_.Tile)) {  	if (position_.Tile.X > 13) {  		direction_ = FindDirection (new Point (14' 11));  	} else {  		direction_ = FindDirection (new Point (13' 11));  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.Tile.X == 14 && position_.Tile.Y == 11) {  	direction_ = Direction.Left;  } // Otherwise' when at a junction' head for the square above home closest to us.  else if (IsAJunction (position_.Tile)) {  	if (position_.Tile.X > 13) {  		direction_ = FindDirection (new Point (14' 11));  	} else {  		direction_ = FindDirection (new Point (13' 11));  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.Tile.X == 14 && position_.Tile.Y == 11) {  	direction_ = Direction.Left;  } // Otherwise' when at a junction' head for the square above home closest to us.  else if (IsAJunction (position_.Tile)) {  	if (position_.Tile.X > 13) {  		direction_ = FindDirection (new Point (14' 11));  	} else {  		direction_ = FindDirection (new Point (13' 11));  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.Tile.X == 14 && position_.Tile.Y == 11) {  	direction_ = Direction.Left;  } // Otherwise' when at a junction' head for the square above home closest to us.  else if (IsAJunction (position_.Tile)) {  	if (position_.Tile.X > 13) {  		direction_ = FindDirection (new Point (14' 11));  	} else {  		direction_ = FindDirection (new Point (13' 11));  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.Tile.X == 14 && position_.Tile.Y == 11) {  	direction_ = Direction.Left;  } // Otherwise' when at a junction' head for the square above home closest to us.  else if (IsAJunction (position_.Tile)) {  	if (position_.Tile.X > 13) {  		direction_ = FindDirection (new Point (14' 11));  	} else {  		direction_ = FindDirection (new Point (13' 11));  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.Tile.X == 14 && position_.Tile.Y == 11) {  	direction_ = Direction.Left;  } // Otherwise' when at a junction' head for the square above home closest to us.  else if (IsAJunction (position_.Tile)) {  	if (position_.Tile.X > 13) {  		direction_ = FindDirection (new Point (14' 11));  	} else {  		direction_ = FindDirection (new Point (13' 11));  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.Tile.X == 14 && position_.Tile.Y == 11) {  	direction_ = Direction.Left;  } // Otherwise' when at a junction' head for the square above home closest to us.  else if (IsAJunction (position_.Tile)) {  	if (position_.Tile.X > 13) {  		direction_ = FindDirection (new Point (14' 11));  	} else {  		direction_ = FindDirection (new Point (13' 11));  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (IsAJunction (position_.Tile)) {  	if (position_.Tile.X > 13) {  		direction_ = FindDirection (new Point (14' 11));  	} else {  		direction_ = FindDirection (new Point (13' 11));  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (IsAJunction (position_.Tile)) {  	if (position_.Tile.X > 13) {  		direction_ = FindDirection (new Point (14' 11));  	} else {  		direction_ = FindDirection (new Point (13' 11));  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (IsAJunction (position_.Tile)) {  	if (position_.Tile.X > 13) {  		direction_ = FindDirection (new Point (14' 11));  	} else {  		direction_ = FindDirection (new Point (13' 11));  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (IsAJunction (position_.Tile)) {  	if (position_.Tile.X > 13) {  		direction_ = FindDirection (new Point (14' 11));  	} else {  		direction_ = FindDirection (new Point (13' 11));  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (IsAJunction (position_.Tile)) {  	if (position_.Tile.X > 13) {  		direction_ = FindDirection (new Point (14' 11));  	} else {  		direction_ = FindDirection (new Point (13' 11));  	}  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.Tile.X > 13) {  	direction_ = FindDirection (new Point (14' 11));  } else {  	direction_ = FindDirection (new Point (13' 11));  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.Tile.X > 13) {  	direction_ = FindDirection (new Point (14' 11));  } else {  	direction_ = FindDirection (new Point (13' 11));  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.Tile.X > 13) {  	direction_ = FindDirection (new Point (14' 11));  } else {  	direction_ = FindDirection (new Point (13' 11));  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.Tile.X > 13) {  	direction_ = FindDirection (new Point (14' 11));  } else {  	direction_ = FindDirection (new Point (13' 11));  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: if (position_.Tile.X > 13) {  	direction_ = FindDirection (new Point (14' 11));  } else {  	direction_ = FindDirection (new Point (13' 11));  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: direction_ = FindDirection (new Point (14' 11));  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: direction_ = FindDirection (new Point (14' 11));  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: direction_ = FindDirection (new Point (13' 11));  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: direction_ = FindDirection (new Point (13' 11));  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AttackAIInky,The following statement contains a magic number: line *= 2;  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AttackAIClyde,The following statement contains a magic number: if (distanceToPlayer >= 8) {  	AttackAIBlinky ();  } else {  	AIScatter ();  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIOverride,The following statement contains a magic number: if (position_.Tile.Y == 11 && (position_.Tile.X == 12 || position_.Tile.X == 15)) {  	return (direction_ == Direction.Right || direction_ == Direction.Left);  } else if (position_.Tile.Y == 20 && (position_.Tile.X == 9 || position_.Tile.X == 18)) {  	return (direction_ == Direction.Right || direction_ == Direction.Left);  } else {  	return false;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIOverride,The following statement contains a magic number: if (position_.Tile.Y == 11 && (position_.Tile.X == 12 || position_.Tile.X == 15)) {  	return (direction_ == Direction.Right || direction_ == Direction.Left);  } else if (position_.Tile.Y == 20 && (position_.Tile.X == 9 || position_.Tile.X == 18)) {  	return (direction_ == Direction.Right || direction_ == Direction.Left);  } else {  	return false;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIOverride,The following statement contains a magic number: if (position_.Tile.Y == 11 && (position_.Tile.X == 12 || position_.Tile.X == 15)) {  	return (direction_ == Direction.Right || direction_ == Direction.Left);  } else if (position_.Tile.Y == 20 && (position_.Tile.X == 9 || position_.Tile.X == 18)) {  	return (direction_ == Direction.Right || direction_ == Direction.Left);  } else {  	return false;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIOverride,The following statement contains a magic number: if (position_.Tile.Y == 11 && (position_.Tile.X == 12 || position_.Tile.X == 15)) {  	return (direction_ == Direction.Right || direction_ == Direction.Left);  } else if (position_.Tile.Y == 20 && (position_.Tile.X == 9 || position_.Tile.X == 18)) {  	return (direction_ == Direction.Right || direction_ == Direction.Left);  } else {  	return false;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIOverride,The following statement contains a magic number: if (position_.Tile.Y == 11 && (position_.Tile.X == 12 || position_.Tile.X == 15)) {  	return (direction_ == Direction.Right || direction_ == Direction.Left);  } else if (position_.Tile.Y == 20 && (position_.Tile.X == 9 || position_.Tile.X == 18)) {  	return (direction_ == Direction.Right || direction_ == Direction.Left);  } else {  	return false;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIOverride,The following statement contains a magic number: if (position_.Tile.Y == 11 && (position_.Tile.X == 12 || position_.Tile.X == 15)) {  	return (direction_ == Direction.Right || direction_ == Direction.Left);  } else if (position_.Tile.Y == 20 && (position_.Tile.X == 9 || position_.Tile.X == 18)) {  	return (direction_ == Direction.Right || direction_ == Direction.Left);  } else {  	return false;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIOverride,The following statement contains a magic number: if (position_.Tile.Y == 20 && (position_.Tile.X == 9 || position_.Tile.X == 18)) {  	return (direction_ == Direction.Right || direction_ == Direction.Left);  } else {  	return false;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIOverride,The following statement contains a magic number: if (position_.Tile.Y == 20 && (position_.Tile.X == 9 || position_.Tile.X == 18)) {  	return (direction_ == Direction.Right || direction_ == Direction.Left);  } else {  	return false;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIOverride,The following statement contains a magic number: if (position_.Tile.Y == 20 && (position_.Tile.X == 9 || position_.Tile.X == 18)) {  	return (direction_ == Direction.Right || direction_ == Direction.Left);  } else {  	return false;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: if (((DateTime.Now.Millisecond / 125) % 2) == 0 ^ wiggle_) {  	wiggle_ = !wiggle_;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: if (((DateTime.Now.Millisecond / 125) % 2) == 0 ^ wiggle_) {  	wiggle_ = !wiggle_;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: position.X = boardPosition.X + (position_.Tile.X * 16) + (position_.DeltaPixel.X) - 6;  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: position.X = boardPosition.X + (position_.Tile.X * 16) + (position_.DeltaPixel.X) - 6;  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: position.Y = boardPosition.Y + (position_.Tile.Y * 16) + (position_.DeltaPixel.Y) - 6;  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: position.Y = boardPosition.Y + (position_.Tile.Y * 16) + (position_.DeltaPixel.Y) - 6;  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: eyesBasePosition.X = position.X + 4;  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: eyesBasePosition.Y = position.Y + 6;  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: switch (direction_) {  case Direction.Up:  	eyesBasePosition.Y -= 2;  	eyesCenterPosition.X = eyesBasePosition.X + 2;  	eyesCenterPosition.Y = eyesBasePosition.Y;  	break;  case Direction.Down:  	eyesBasePosition.Y += 2;  	eyesCenterPosition.X = eyesBasePosition.X + 2;  	eyesCenterPosition.Y = eyesBasePosition.Y + 6;  	break;  case Direction.Left:  	eyesBasePosition.X -= 2;  	eyesCenterPosition.X = eyesBasePosition.X;  	eyesCenterPosition.Y = eyesBasePosition.Y + 3;  	break;  case Direction.Right:  	eyesBasePosition.X += 2;  	eyesCenterPosition.X = eyesBasePosition.X + 4;  	eyesCenterPosition.Y = eyesBasePosition.Y + 3;  	break;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: switch (direction_) {  case Direction.Up:  	eyesBasePosition.Y -= 2;  	eyesCenterPosition.X = eyesBasePosition.X + 2;  	eyesCenterPosition.Y = eyesBasePosition.Y;  	break;  case Direction.Down:  	eyesBasePosition.Y += 2;  	eyesCenterPosition.X = eyesBasePosition.X + 2;  	eyesCenterPosition.Y = eyesBasePosition.Y + 6;  	break;  case Direction.Left:  	eyesBasePosition.X -= 2;  	eyesCenterPosition.X = eyesBasePosition.X;  	eyesCenterPosition.Y = eyesBasePosition.Y + 3;  	break;  case Direction.Right:  	eyesBasePosition.X += 2;  	eyesCenterPosition.X = eyesBasePosition.X + 4;  	eyesCenterPosition.Y = eyesBasePosition.Y + 3;  	break;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: switch (direction_) {  case Direction.Up:  	eyesBasePosition.Y -= 2;  	eyesCenterPosition.X = eyesBasePosition.X + 2;  	eyesCenterPosition.Y = eyesBasePosition.Y;  	break;  case Direction.Down:  	eyesBasePosition.Y += 2;  	eyesCenterPosition.X = eyesBasePosition.X + 2;  	eyesCenterPosition.Y = eyesBasePosition.Y + 6;  	break;  case Direction.Left:  	eyesBasePosition.X -= 2;  	eyesCenterPosition.X = eyesBasePosition.X;  	eyesCenterPosition.Y = eyesBasePosition.Y + 3;  	break;  case Direction.Right:  	eyesBasePosition.X += 2;  	eyesCenterPosition.X = eyesBasePosition.X + 4;  	eyesCenterPosition.Y = eyesBasePosition.Y + 3;  	break;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: switch (direction_) {  case Direction.Up:  	eyesBasePosition.Y -= 2;  	eyesCenterPosition.X = eyesBasePosition.X + 2;  	eyesCenterPosition.Y = eyesBasePosition.Y;  	break;  case Direction.Down:  	eyesBasePosition.Y += 2;  	eyesCenterPosition.X = eyesBasePosition.X + 2;  	eyesCenterPosition.Y = eyesBasePosition.Y + 6;  	break;  case Direction.Left:  	eyesBasePosition.X -= 2;  	eyesCenterPosition.X = eyesBasePosition.X;  	eyesCenterPosition.Y = eyesBasePosition.Y + 3;  	break;  case Direction.Right:  	eyesBasePosition.X += 2;  	eyesCenterPosition.X = eyesBasePosition.X + 4;  	eyesCenterPosition.Y = eyesBasePosition.Y + 3;  	break;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: switch (direction_) {  case Direction.Up:  	eyesBasePosition.Y -= 2;  	eyesCenterPosition.X = eyesBasePosition.X + 2;  	eyesCenterPosition.Y = eyesBasePosition.Y;  	break;  case Direction.Down:  	eyesBasePosition.Y += 2;  	eyesCenterPosition.X = eyesBasePosition.X + 2;  	eyesCenterPosition.Y = eyesBasePosition.Y + 6;  	break;  case Direction.Left:  	eyesBasePosition.X -= 2;  	eyesCenterPosition.X = eyesBasePosition.X;  	eyesCenterPosition.Y = eyesBasePosition.Y + 3;  	break;  case Direction.Right:  	eyesBasePosition.X += 2;  	eyesCenterPosition.X = eyesBasePosition.X + 4;  	eyesCenterPosition.Y = eyesBasePosition.Y + 3;  	break;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: switch (direction_) {  case Direction.Up:  	eyesBasePosition.Y -= 2;  	eyesCenterPosition.X = eyesBasePosition.X + 2;  	eyesCenterPosition.Y = eyesBasePosition.Y;  	break;  case Direction.Down:  	eyesBasePosition.Y += 2;  	eyesCenterPosition.X = eyesBasePosition.X + 2;  	eyesCenterPosition.Y = eyesBasePosition.Y + 6;  	break;  case Direction.Left:  	eyesBasePosition.X -= 2;  	eyesCenterPosition.X = eyesBasePosition.X;  	eyesCenterPosition.Y = eyesBasePosition.Y + 3;  	break;  case Direction.Right:  	eyesBasePosition.X += 2;  	eyesCenterPosition.X = eyesBasePosition.X + 4;  	eyesCenterPosition.Y = eyesBasePosition.Y + 3;  	break;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: switch (direction_) {  case Direction.Up:  	eyesBasePosition.Y -= 2;  	eyesCenterPosition.X = eyesBasePosition.X + 2;  	eyesCenterPosition.Y = eyesBasePosition.Y;  	break;  case Direction.Down:  	eyesBasePosition.Y += 2;  	eyesCenterPosition.X = eyesBasePosition.X + 2;  	eyesCenterPosition.Y = eyesBasePosition.Y + 6;  	break;  case Direction.Left:  	eyesBasePosition.X -= 2;  	eyesCenterPosition.X = eyesBasePosition.X;  	eyesCenterPosition.Y = eyesBasePosition.Y + 3;  	break;  case Direction.Right:  	eyesBasePosition.X += 2;  	eyesCenterPosition.X = eyesBasePosition.X + 4;  	eyesCenterPosition.Y = eyesBasePosition.Y + 3;  	break;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: switch (direction_) {  case Direction.Up:  	eyesBasePosition.Y -= 2;  	eyesCenterPosition.X = eyesBasePosition.X + 2;  	eyesCenterPosition.Y = eyesBasePosition.Y;  	break;  case Direction.Down:  	eyesBasePosition.Y += 2;  	eyesCenterPosition.X = eyesBasePosition.X + 2;  	eyesCenterPosition.Y = eyesBasePosition.Y + 6;  	break;  case Direction.Left:  	eyesBasePosition.X -= 2;  	eyesCenterPosition.X = eyesBasePosition.X;  	eyesCenterPosition.Y = eyesBasePosition.Y + 3;  	break;  case Direction.Right:  	eyesBasePosition.X += 2;  	eyesCenterPosition.X = eyesBasePosition.X + 4;  	eyesCenterPosition.Y = eyesBasePosition.Y + 3;  	break;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: switch (direction_) {  case Direction.Up:  	eyesBasePosition.Y -= 2;  	eyesCenterPosition.X = eyesBasePosition.X + 2;  	eyesCenterPosition.Y = eyesBasePosition.Y;  	break;  case Direction.Down:  	eyesBasePosition.Y += 2;  	eyesCenterPosition.X = eyesBasePosition.X + 2;  	eyesCenterPosition.Y = eyesBasePosition.Y + 6;  	break;  case Direction.Left:  	eyesBasePosition.X -= 2;  	eyesCenterPosition.X = eyesBasePosition.X;  	eyesCenterPosition.Y = eyesBasePosition.Y + 3;  	break;  case Direction.Right:  	eyesBasePosition.X += 2;  	eyesCenterPosition.X = eyesBasePosition.X + 4;  	eyesCenterPosition.Y = eyesBasePosition.Y + 3;  	break;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: switch (direction_) {  case Direction.Up:  	eyesBasePosition.Y -= 2;  	eyesCenterPosition.X = eyesBasePosition.X + 2;  	eyesCenterPosition.Y = eyesBasePosition.Y;  	break;  case Direction.Down:  	eyesBasePosition.Y += 2;  	eyesCenterPosition.X = eyesBasePosition.X + 2;  	eyesCenterPosition.Y = eyesBasePosition.Y + 6;  	break;  case Direction.Left:  	eyesBasePosition.X -= 2;  	eyesCenterPosition.X = eyesBasePosition.X;  	eyesCenterPosition.Y = eyesBasePosition.Y + 3;  	break;  case Direction.Right:  	eyesBasePosition.X += 2;  	eyesCenterPosition.X = eyesBasePosition.X + 4;  	eyesCenterPosition.Y = eyesBasePosition.Y + 3;  	break;  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: eyesBasePosition.Y -= 2;  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: eyesCenterPosition.X = eyesBasePosition.X + 2;  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: eyesBasePosition.Y += 2;  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: eyesCenterPosition.X = eyesBasePosition.X + 2;  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: eyesCenterPosition.Y = eyesBasePosition.Y + 6;  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: eyesBasePosition.X -= 2;  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: eyesCenterPosition.Y = eyesBasePosition.Y + 3;  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: eyesBasePosition.X += 2;  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: eyesCenterPosition.X = eyesBasePosition.X + 4;  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: eyesCenterPosition.Y = eyesBasePosition.Y + 3;  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: if (State == GhostState.Blue) {  	if (((DateTime.Now - timeInCurrentState).Seconds < 0.5 * Constants.BlueTime ())) {  		RenderSprite (wiggle_ ? ghostBase1_ : ghostBase2_' null' boardPosition' position' Color.Blue);  		RenderSprite (ghostChased_' null' boardPosition' position' Color.White);  	} else {  		bool flash = (DateTime.Now.Second + DateTime.Now.Millisecond / 200) % 2 == 0;  		RenderSprite (wiggle_ ? ghostBase1_ : ghostBase2_' null' boardPosition' position' flash ? Color.Blue : Color.White);  		RenderSprite (ghostChased_' null' boardPosition' position' flash ? Color.White : Color.Blue);  	}  } else if (State == GhostState.Dead) {  	RenderSprite (eyesBase_' null' boardPosition' eyesBasePosition' Color.White);  	RenderSprite (eyesCenter_' null' boardPosition' eyesCenterPosition' Color.White);  } else {  	RenderSprite (wiggle_ ? ghostBase1_ : ghostBase2_' null' boardPosition' position' colorBase_);  	RenderSprite (eyesBase_' null' boardPosition' eyesBasePosition' Color.White);  	RenderSprite (eyesCenter_' null' boardPosition' eyesCenterPosition' Color.White);  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: if (State == GhostState.Blue) {  	if (((DateTime.Now - timeInCurrentState).Seconds < 0.5 * Constants.BlueTime ())) {  		RenderSprite (wiggle_ ? ghostBase1_ : ghostBase2_' null' boardPosition' position' Color.Blue);  		RenderSprite (ghostChased_' null' boardPosition' position' Color.White);  	} else {  		bool flash = (DateTime.Now.Second + DateTime.Now.Millisecond / 200) % 2 == 0;  		RenderSprite (wiggle_ ? ghostBase1_ : ghostBase2_' null' boardPosition' position' flash ? Color.Blue : Color.White);  		RenderSprite (ghostChased_' null' boardPosition' position' flash ? Color.White : Color.Blue);  	}  } else if (State == GhostState.Dead) {  	RenderSprite (eyesBase_' null' boardPosition' eyesBasePosition' Color.White);  	RenderSprite (eyesCenter_' null' boardPosition' eyesCenterPosition' Color.White);  } else {  	RenderSprite (wiggle_ ? ghostBase1_ : ghostBase2_' null' boardPosition' position' colorBase_);  	RenderSprite (eyesBase_' null' boardPosition' eyesBasePosition' Color.White);  	RenderSprite (eyesCenter_' null' boardPosition' eyesCenterPosition' Color.White);  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: if (State == GhostState.Blue) {  	if (((DateTime.Now - timeInCurrentState).Seconds < 0.5 * Constants.BlueTime ())) {  		RenderSprite (wiggle_ ? ghostBase1_ : ghostBase2_' null' boardPosition' position' Color.Blue);  		RenderSprite (ghostChased_' null' boardPosition' position' Color.White);  	} else {  		bool flash = (DateTime.Now.Second + DateTime.Now.Millisecond / 200) % 2 == 0;  		RenderSprite (wiggle_ ? ghostBase1_ : ghostBase2_' null' boardPosition' position' flash ? Color.Blue : Color.White);  		RenderSprite (ghostChased_' null' boardPosition' position' flash ? Color.White : Color.Blue);  	}  } else if (State == GhostState.Dead) {  	RenderSprite (eyesBase_' null' boardPosition' eyesBasePosition' Color.White);  	RenderSprite (eyesCenter_' null' boardPosition' eyesCenterPosition' Color.White);  } else {  	RenderSprite (wiggle_ ? ghostBase1_ : ghostBase2_' null' boardPosition' position' colorBase_);  	RenderSprite (eyesBase_' null' boardPosition' eyesBasePosition' Color.White);  	RenderSprite (eyesCenter_' null' boardPosition' eyesCenterPosition' Color.White);  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: if (((DateTime.Now - timeInCurrentState).Seconds < 0.5 * Constants.BlueTime ())) {  	RenderSprite (wiggle_ ? ghostBase1_ : ghostBase2_' null' boardPosition' position' Color.Blue);  	RenderSprite (ghostChased_' null' boardPosition' position' Color.White);  } else {  	bool flash = (DateTime.Now.Second + DateTime.Now.Millisecond / 200) % 2 == 0;  	RenderSprite (wiggle_ ? ghostBase1_ : ghostBase2_' null' boardPosition' position' flash ? Color.Blue : Color.White);  	RenderSprite (ghostChased_' null' boardPosition' position' flash ? Color.White : Color.Blue);  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: if (((DateTime.Now - timeInCurrentState).Seconds < 0.5 * Constants.BlueTime ())) {  	RenderSprite (wiggle_ ? ghostBase1_ : ghostBase2_' null' boardPosition' position' Color.Blue);  	RenderSprite (ghostChased_' null' boardPosition' position' Color.White);  } else {  	bool flash = (DateTime.Now.Second + DateTime.Now.Millisecond / 200) % 2 == 0;  	RenderSprite (wiggle_ ? ghostBase1_ : ghostBase2_' null' boardPosition' position' flash ? Color.Blue : Color.White);  	RenderSprite (ghostChased_' null' boardPosition' position' flash ? Color.White : Color.Blue);  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: if (((DateTime.Now - timeInCurrentState).Seconds < 0.5 * Constants.BlueTime ())) {  	RenderSprite (wiggle_ ? ghostBase1_ : ghostBase2_' null' boardPosition' position' Color.Blue);  	RenderSprite (ghostChased_' null' boardPosition' position' Color.White);  } else {  	bool flash = (DateTime.Now.Second + DateTime.Now.Millisecond / 200) % 2 == 0;  	RenderSprite (wiggle_ ? ghostBase1_ : ghostBase2_' null' boardPosition' position' flash ? Color.Blue : Color.White);  	RenderSprite (ghostChased_' null' boardPosition' position' flash ? Color.White : Color.Blue);  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,RenderSprite,The following statement contains a magic number: if (position.X < boardPosition.X) {  	int deltaPixel = (int)(boardPosition.X - position.X);  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + deltaPixel' rect.Y' textureWidth - deltaPixel' textureHeight);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' deltaPixel' textureHeight);  	var rightPortionPosition = new Vector2 (boardPosition.X + (16 * 28) - deltaPixel' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' color);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' color);  } // Next' to the right  else if (position.X > (boardPosition.X + (16 * 28) - textureWidth)) {  	int deltaPixel = (int)((position.X + textureWidth) - (boardPosition.X + (16 * 28)));  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + textureWidth - deltaPixel' rect.Y' deltaPixel' textureHeight);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' textureWidth - deltaPixel' textureHeight);  	var rightPortionPosition = new Vector2 (position.X' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' color);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' color);  } // Draw normally - in one piece  else {  	spriteBatch_.Draw (spriteSheet' position' rect' color);  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,RenderSprite,The following statement contains a magic number: if (position.X < boardPosition.X) {  	int deltaPixel = (int)(boardPosition.X - position.X);  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + deltaPixel' rect.Y' textureWidth - deltaPixel' textureHeight);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' deltaPixel' textureHeight);  	var rightPortionPosition = new Vector2 (boardPosition.X + (16 * 28) - deltaPixel' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' color);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' color);  } // Next' to the right  else if (position.X > (boardPosition.X + (16 * 28) - textureWidth)) {  	int deltaPixel = (int)((position.X + textureWidth) - (boardPosition.X + (16 * 28)));  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + textureWidth - deltaPixel' rect.Y' deltaPixel' textureHeight);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' textureWidth - deltaPixel' textureHeight);  	var rightPortionPosition = new Vector2 (position.X' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' color);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' color);  } // Draw normally - in one piece  else {  	spriteBatch_.Draw (spriteSheet' position' rect' color);  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,RenderSprite,The following statement contains a magic number: if (position.X < boardPosition.X) {  	int deltaPixel = (int)(boardPosition.X - position.X);  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + deltaPixel' rect.Y' textureWidth - deltaPixel' textureHeight);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' deltaPixel' textureHeight);  	var rightPortionPosition = new Vector2 (boardPosition.X + (16 * 28) - deltaPixel' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' color);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' color);  } // Next' to the right  else if (position.X > (boardPosition.X + (16 * 28) - textureWidth)) {  	int deltaPixel = (int)((position.X + textureWidth) - (boardPosition.X + (16 * 28)));  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + textureWidth - deltaPixel' rect.Y' deltaPixel' textureHeight);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' textureWidth - deltaPixel' textureHeight);  	var rightPortionPosition = new Vector2 (position.X' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' color);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' color);  } // Draw normally - in one piece  else {  	spriteBatch_.Draw (spriteSheet' position' rect' color);  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,RenderSprite,The following statement contains a magic number: if (position.X < boardPosition.X) {  	int deltaPixel = (int)(boardPosition.X - position.X);  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + deltaPixel' rect.Y' textureWidth - deltaPixel' textureHeight);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' deltaPixel' textureHeight);  	var rightPortionPosition = new Vector2 (boardPosition.X + (16 * 28) - deltaPixel' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' color);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' color);  } // Next' to the right  else if (position.X > (boardPosition.X + (16 * 28) - textureWidth)) {  	int deltaPixel = (int)((position.X + textureWidth) - (boardPosition.X + (16 * 28)));  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + textureWidth - deltaPixel' rect.Y' deltaPixel' textureHeight);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' textureWidth - deltaPixel' textureHeight);  	var rightPortionPosition = new Vector2 (position.X' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' color);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' color);  } // Draw normally - in one piece  else {  	spriteBatch_.Draw (spriteSheet' position' rect' color);  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,RenderSprite,The following statement contains a magic number: if (position.X < boardPosition.X) {  	int deltaPixel = (int)(boardPosition.X - position.X);  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + deltaPixel' rect.Y' textureWidth - deltaPixel' textureHeight);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' deltaPixel' textureHeight);  	var rightPortionPosition = new Vector2 (boardPosition.X + (16 * 28) - deltaPixel' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' color);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' color);  } // Next' to the right  else if (position.X > (boardPosition.X + (16 * 28) - textureWidth)) {  	int deltaPixel = (int)((position.X + textureWidth) - (boardPosition.X + (16 * 28)));  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + textureWidth - deltaPixel' rect.Y' deltaPixel' textureHeight);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' textureWidth - deltaPixel' textureHeight);  	var rightPortionPosition = new Vector2 (position.X' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' color);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' color);  } // Draw normally - in one piece  else {  	spriteBatch_.Draw (spriteSheet' position' rect' color);  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,RenderSprite,The following statement contains a magic number: if (position.X < boardPosition.X) {  	int deltaPixel = (int)(boardPosition.X - position.X);  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + deltaPixel' rect.Y' textureWidth - deltaPixel' textureHeight);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' deltaPixel' textureHeight);  	var rightPortionPosition = new Vector2 (boardPosition.X + (16 * 28) - deltaPixel' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' color);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' color);  } // Next' to the right  else if (position.X > (boardPosition.X + (16 * 28) - textureWidth)) {  	int deltaPixel = (int)((position.X + textureWidth) - (boardPosition.X + (16 * 28)));  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + textureWidth - deltaPixel' rect.Y' deltaPixel' textureHeight);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' textureWidth - deltaPixel' textureHeight);  	var rightPortionPosition = new Vector2 (position.X' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' color);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' color);  } // Draw normally - in one piece  else {  	spriteBatch_.Draw (spriteSheet' position' rect' color);  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,RenderSprite,The following statement contains a magic number: if (position.X > (boardPosition.X + (16 * 28) - textureWidth)) {  	int deltaPixel = (int)((position.X + textureWidth) - (boardPosition.X + (16 * 28)));  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + textureWidth - deltaPixel' rect.Y' deltaPixel' textureHeight);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' textureWidth - deltaPixel' textureHeight);  	var rightPortionPosition = new Vector2 (position.X' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' color);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' color);  } // Draw normally - in one piece  else {  	spriteBatch_.Draw (spriteSheet' position' rect' color);  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,RenderSprite,The following statement contains a magic number: if (position.X > (boardPosition.X + (16 * 28) - textureWidth)) {  	int deltaPixel = (int)((position.X + textureWidth) - (boardPosition.X + (16 * 28)));  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + textureWidth - deltaPixel' rect.Y' deltaPixel' textureHeight);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' textureWidth - deltaPixel' textureHeight);  	var rightPortionPosition = new Vector2 (position.X' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' color);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' color);  } // Draw normally - in one piece  else {  	spriteBatch_.Draw (spriteSheet' position' rect' color);  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,RenderSprite,The following statement contains a magic number: if (position.X > (boardPosition.X + (16 * 28) - textureWidth)) {  	int deltaPixel = (int)((position.X + textureWidth) - (boardPosition.X + (16 * 28)));  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + textureWidth - deltaPixel' rect.Y' deltaPixel' textureHeight);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' textureWidth - deltaPixel' textureHeight);  	var rightPortionPosition = new Vector2 (position.X' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' color);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' color);  } // Draw normally - in one piece  else {  	spriteBatch_.Draw (spriteSheet' position' rect' color);  }  
Magic Number,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,RenderSprite,The following statement contains a magic number: if (position.X > (boardPosition.X + (16 * 28) - textureWidth)) {  	int deltaPixel = (int)((position.X + textureWidth) - (boardPosition.X + (16 * 28)));  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + textureWidth - deltaPixel' rect.Y' deltaPixel' textureHeight);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' textureWidth - deltaPixel' textureHeight);  	var rightPortionPosition = new Vector2 (position.X' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' color);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' color);  } // Draw normally - in one piece  else {  	spriteBatch_.Draw (spriteSheet' position' rect' color);  }  
Magic Number,XNAPacMan,Grid,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: for (int i = 0; i < 28; i++) {  	if (i != 6 && i != 21) {  		TileGrid [i' 14].HasCrump = false;  	}  }  
Magic Number,XNAPacMan,Grid,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: for (int i = 0; i < 28; i++) {  	if (i != 6 && i != 21) {  		TileGrid [i' 14].HasCrump = false;  	}  }  
Magic Number,XNAPacMan,Grid,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: for (int i = 0; i < 28; i++) {  	if (i != 6 && i != 21) {  		TileGrid [i' 14].HasCrump = false;  	}  }  
Magic Number,XNAPacMan,Grid,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: for (int i = 0; i < 28; i++) {  	if (i != 6 && i != 21) {  		TileGrid [i' 14].HasCrump = false;  	}  }  
Magic Number,XNAPacMan,Grid,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: if (i != 6 && i != 21) {  	TileGrid [i' 14].HasCrump = false;  }  
Magic Number,XNAPacMan,Grid,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: if (i != 6 && i != 21) {  	TileGrid [i' 14].HasCrump = false;  }  
Magic Number,XNAPacMan,Grid,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: if (i != 6 && i != 21) {  	TileGrid [i' 14].HasCrump = false;  }  
Magic Number,XNAPacMan,Grid,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: TileGrid [i' 14].HasCrump = false;  
Magic Number,XNAPacMan,Grid,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: for (int j = 11; j < 20; j++) {  	TileGrid [9' j].HasCrump = false;  	TileGrid [18' j].HasCrump = false;  }  
Magic Number,XNAPacMan,Grid,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: for (int j = 11; j < 20; j++) {  	TileGrid [9' j].HasCrump = false;  	TileGrid [18' j].HasCrump = false;  }  
Magic Number,XNAPacMan,Grid,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: for (int j = 11; j < 20; j++) {  	TileGrid [9' j].HasCrump = false;  	TileGrid [18' j].HasCrump = false;  }  
Magic Number,XNAPacMan,Grid,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: for (int j = 11; j < 20; j++) {  	TileGrid [9' j].HasCrump = false;  	TileGrid [18' j].HasCrump = false;  }  
Magic Number,XNAPacMan,Grid,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: TileGrid [9' j].HasCrump = false;  
Magic Number,XNAPacMan,Grid,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: TileGrid [18' j].HasCrump = false;  
Magic Number,XNAPacMan,Grid,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: for (int i = 10; i < 18; i++) {  	TileGrid [i' 11].HasCrump = false;  	TileGrid [i' 17].HasCrump = false;  }  
Magic Number,XNAPacMan,Grid,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: for (int i = 10; i < 18; i++) {  	TileGrid [i' 11].HasCrump = false;  	TileGrid [i' 17].HasCrump = false;  }  
Magic Number,XNAPacMan,Grid,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: for (int i = 10; i < 18; i++) {  	TileGrid [i' 11].HasCrump = false;  	TileGrid [i' 17].HasCrump = false;  }  
Magic Number,XNAPacMan,Grid,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: for (int i = 10; i < 18; i++) {  	TileGrid [i' 11].HasCrump = false;  	TileGrid [i' 17].HasCrump = false;  }  
Magic Number,XNAPacMan,Grid,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: TileGrid [i' 11].HasCrump = false;  
Magic Number,XNAPacMan,Grid,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: TileGrid [i' 17].HasCrump = false;  
Magic Number,XNAPacMan,Grid,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: TileGrid [12' 9].HasCrump = false;  
Magic Number,XNAPacMan,Grid,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: TileGrid [12' 9].HasCrump = false;  
Magic Number,XNAPacMan,Grid,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: TileGrid [15' 9].HasCrump = false;  
Magic Number,XNAPacMan,Grid,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: TileGrid [15' 9].HasCrump = false;  
Magic Number,XNAPacMan,Grid,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: TileGrid [12' 10].HasCrump = false;  
Magic Number,XNAPacMan,Grid,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: TileGrid [12' 10].HasCrump = false;  
Magic Number,XNAPacMan,Grid,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: TileGrid [15' 10].HasCrump = false;  
Magic Number,XNAPacMan,Grid,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: TileGrid [15' 10].HasCrump = false;  
Magic Number,XNAPacMan,Grid,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: TileGrid [13' 23].HasCrump = false;  
Magic Number,XNAPacMan,Grid,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: TileGrid [13' 23].HasCrump = false;  
Magic Number,XNAPacMan,Grid,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: TileGrid [14' 23].HasCrump = false;  
Magic Number,XNAPacMan,Grid,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: TileGrid [14' 23].HasCrump = false;  
Magic Number,XNAPacMan,HighScores,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\HighScores.cs,Initialize,The following statement contains a magic number: scores_ = new List<string> (10);  
Magic Number,XNAPacMan,HighScores,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\HighScores.cs,Draw,The following statement contains a magic number: for (int i = 0; i < 10; i++) {  	spriteBatch_.DrawString (scoreFont_' (i + 1).ToString () + "."' new Vector2 (position.X' position.Y + (30 * i))' Color.White);  	if (i < scores_.Count) {  		spriteBatch_.DrawString (scoreFont_' scores_ [i]' new Vector2 (position.X + 50' position.Y + (30 * i))' Color.White);  	}  }  
Magic Number,XNAPacMan,HighScores,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\HighScores.cs,Draw,The following statement contains a magic number: for (int i = 0; i < 10; i++) {  	spriteBatch_.DrawString (scoreFont_' (i + 1).ToString () + "."' new Vector2 (position.X' position.Y + (30 * i))' Color.White);  	if (i < scores_.Count) {  		spriteBatch_.DrawString (scoreFont_' scores_ [i]' new Vector2 (position.X + 50' position.Y + (30 * i))' Color.White);  	}  }  
Magic Number,XNAPacMan,HighScores,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\HighScores.cs,Draw,The following statement contains a magic number: for (int i = 0; i < 10; i++) {  	spriteBatch_.DrawString (scoreFont_' (i + 1).ToString () + "."' new Vector2 (position.X' position.Y + (30 * i))' Color.White);  	if (i < scores_.Count) {  		spriteBatch_.DrawString (scoreFont_' scores_ [i]' new Vector2 (position.X + 50' position.Y + (30 * i))' Color.White);  	}  }  
Magic Number,XNAPacMan,HighScores,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\HighScores.cs,Draw,The following statement contains a magic number: for (int i = 0; i < 10; i++) {  	spriteBatch_.DrawString (scoreFont_' (i + 1).ToString () + "."' new Vector2 (position.X' position.Y + (30 * i))' Color.White);  	if (i < scores_.Count) {  		spriteBatch_.DrawString (scoreFont_' scores_ [i]' new Vector2 (position.X + 50' position.Y + (30 * i))' Color.White);  	}  }  
Magic Number,XNAPacMan,HighScores,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\HighScores.cs,Draw,The following statement contains a magic number: spriteBatch_.DrawString (scoreFont_' (i + 1).ToString () + "."' new Vector2 (position.X' position.Y + (30 * i))' Color.White);  
Magic Number,XNAPacMan,HighScores,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\HighScores.cs,Draw,The following statement contains a magic number: if (i < scores_.Count) {  	spriteBatch_.DrawString (scoreFont_' scores_ [i]' new Vector2 (position.X + 50' position.Y + (30 * i))' Color.White);  }  
Magic Number,XNAPacMan,HighScores,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\HighScores.cs,Draw,The following statement contains a magic number: if (i < scores_.Count) {  	spriteBatch_.DrawString (scoreFont_' scores_ [i]' new Vector2 (position.X + 50' position.Y + (30 * i))' Color.White);  }  
Magic Number,XNAPacMan,HighScores,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\HighScores.cs,Draw,The following statement contains a magic number: spriteBatch_.DrawString (scoreFont_' scores_ [i]' new Vector2 (position.X + 50' position.Y + (30 * i))' Color.White);  
Magic Number,XNAPacMan,HighScores,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\HighScores.cs,Draw,The following statement contains a magic number: spriteBatch_.DrawString (scoreFont_' scores_ [i]' new Vector2 (position.X + 50' position.Y + (30 * i))' Color.White);  
Magic Number,XNAPacMan,HighScores,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\HighScores.cs,Draw,The following statement contains a magic number: itemPosition.X = (graphics_.PreferredBackBufferWidth / 2) - 100;  
Magic Number,XNAPacMan,HighScores,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\HighScores.cs,Draw,The following statement contains a magic number: itemPosition.X = (graphics_.PreferredBackBufferWidth / 2) - 100;  
Magic Number,XNAPacMan,HighScores,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\HighScores.cs,Draw,The following statement contains a magic number: itemPosition.Y = (graphics_.PreferredBackBufferHeight / 2) + 200;  
Magic Number,XNAPacMan,HighScores,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\HighScores.cs,Draw,The following statement contains a magic number: itemPosition.Y = (graphics_.PreferredBackBufferHeight / 2) + 200;  
Magic Number,XNAPacMan,HighScores,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\HighScores.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw (selectionArrow_' new Vector2 (itemPosition.X - 50' itemPosition.Y)' Color.White);  
Magic Number,XNAPacMan,Menu,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Menu.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw (title_' new Vector2 ((graphics_.PreferredBackBufferWidth / 2) - (title_.Width / 2)' 75)' Color.White);  
Magic Number,XNAPacMan,Menu,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Menu.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw (title_' new Vector2 ((graphics_.PreferredBackBufferWidth / 2) - (title_.Width / 2)' 75)' Color.White);  
Magic Number,XNAPacMan,Menu,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Menu.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw (title_' new Vector2 ((graphics_.PreferredBackBufferWidth / 2) - (title_.Width / 2)' 75)' Color.White);  
Magic Number,XNAPacMan,Menu,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Menu.cs,Draw,The following statement contains a magic number: itemPosition.X = (graphics_.PreferredBackBufferWidth / 2) - 100;  
Magic Number,XNAPacMan,Menu,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Menu.cs,Draw,The following statement contains a magic number: itemPosition.X = (graphics_.PreferredBackBufferWidth / 2) - 100;  
Magic Number,XNAPacMan,Menu,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Menu.cs,Draw,The following statement contains a magic number: for (int i = 0; i < items_.Length; i++) {  	itemPosition.Y = (graphics_.PreferredBackBufferHeight / 2) - 60 + (60 * i);  	if (i == selection_) {  		spriteBatch_.Draw (selectionArrow_' new Vector2 (itemPosition.X - 50' itemPosition.Y)' Color.White);  	}  	spriteBatch_.DrawString (menuItem_' items_ [i]' itemPosition' Color.Yellow);  }  
Magic Number,XNAPacMan,Menu,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Menu.cs,Draw,The following statement contains a magic number: for (int i = 0; i < items_.Length; i++) {  	itemPosition.Y = (graphics_.PreferredBackBufferHeight / 2) - 60 + (60 * i);  	if (i == selection_) {  		spriteBatch_.Draw (selectionArrow_' new Vector2 (itemPosition.X - 50' itemPosition.Y)' Color.White);  	}  	spriteBatch_.DrawString (menuItem_' items_ [i]' itemPosition' Color.Yellow);  }  
Magic Number,XNAPacMan,Menu,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Menu.cs,Draw,The following statement contains a magic number: for (int i = 0; i < items_.Length; i++) {  	itemPosition.Y = (graphics_.PreferredBackBufferHeight / 2) - 60 + (60 * i);  	if (i == selection_) {  		spriteBatch_.Draw (selectionArrow_' new Vector2 (itemPosition.X - 50' itemPosition.Y)' Color.White);  	}  	spriteBatch_.DrawString (menuItem_' items_ [i]' itemPosition' Color.Yellow);  }  
Magic Number,XNAPacMan,Menu,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Menu.cs,Draw,The following statement contains a magic number: for (int i = 0; i < items_.Length; i++) {  	itemPosition.Y = (graphics_.PreferredBackBufferHeight / 2) - 60 + (60 * i);  	if (i == selection_) {  		spriteBatch_.Draw (selectionArrow_' new Vector2 (itemPosition.X - 50' itemPosition.Y)' Color.White);  	}  	spriteBatch_.DrawString (menuItem_' items_ [i]' itemPosition' Color.Yellow);  }  
Magic Number,XNAPacMan,Menu,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Menu.cs,Draw,The following statement contains a magic number: itemPosition.Y = (graphics_.PreferredBackBufferHeight / 2) - 60 + (60 * i);  
Magic Number,XNAPacMan,Menu,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Menu.cs,Draw,The following statement contains a magic number: itemPosition.Y = (graphics_.PreferredBackBufferHeight / 2) - 60 + (60 * i);  
Magic Number,XNAPacMan,Menu,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Menu.cs,Draw,The following statement contains a magic number: itemPosition.Y = (graphics_.PreferredBackBufferHeight / 2) - 60 + (60 * i);  
Magic Number,XNAPacMan,Menu,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Menu.cs,Draw,The following statement contains a magic number: if (i == selection_) {  	spriteBatch_.Draw (selectionArrow_' new Vector2 (itemPosition.X - 50' itemPosition.Y)' Color.White);  }  
Magic Number,XNAPacMan,Menu,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Menu.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw (selectionArrow_' new Vector2 (itemPosition.X - 50' itemPosition.Y)' Color.White);  
Magic Number,XNAPacMan,Menu,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Menu.cs,SaveHighScore,The following statement contains a magic number: if (!File.Exists (fileName)) {  	File.WriteAllLines (fileName' new string[] {  		highScore.ToString ()  	});  } else {  	List<string> contents = File.ReadAllLines (fileName).ToList<string> ();  	contents.Add (highScore.ToString ());  	if (contents.Count >= 10) {  		contents.Sort ((a' b) => Convert.ToInt32 (a).CompareTo (Convert.ToInt32 (b)));  		while (contents.Count > 10) {  			contents.RemoveAt (0);  		}  	}  	File.WriteAllLines (fileName' contents.ToArray ());  }  
Magic Number,XNAPacMan,Menu,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Menu.cs,SaveHighScore,The following statement contains a magic number: if (!File.Exists (fileName)) {  	File.WriteAllLines (fileName' new string[] {  		highScore.ToString ()  	});  } else {  	List<string> contents = File.ReadAllLines (fileName).ToList<string> ();  	contents.Add (highScore.ToString ());  	if (contents.Count >= 10) {  		contents.Sort ((a' b) => Convert.ToInt32 (a).CompareTo (Convert.ToInt32 (b)));  		while (contents.Count > 10) {  			contents.RemoveAt (0);  		}  	}  	File.WriteAllLines (fileName' contents.ToArray ());  }  
Magic Number,XNAPacMan,Menu,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Menu.cs,SaveHighScore,The following statement contains a magic number: if (contents.Count >= 10) {  	contents.Sort ((a' b) => Convert.ToInt32 (a).CompareTo (Convert.ToInt32 (b)));  	while (contents.Count > 10) {  		contents.RemoveAt (0);  	}  }  
Magic Number,XNAPacMan,Menu,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Menu.cs,SaveHighScore,The following statement contains a magic number: if (contents.Count >= 10) {  	contents.Sort ((a' b) => Convert.ToInt32 (a).CompareTo (Convert.ToInt32 (b)));  	while (contents.Count > 10) {  		contents.RemoveAt (0);  	}  }  
Magic Number,XNAPacMan,Menu,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Menu.cs,SaveHighScore,The following statement contains a magic number: while (contents.Count > 10) {  	contents.RemoveAt (0);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,TryMove,The following statement contains a magic number: if (position_.DeltaPixel != Point.Zero) {  	DoMove ();  } // Special case : the tunnel.  else if ((position_.Tile == new Point (0' 14) && direction_ == Direction.Left) || (position_.Tile == new Point (27' 14) && direction_ == Direction.Right)) {  	DoMove ();  } // If on a tile' we only move if the next tile in our direction is open  else if ((direction_ == Direction.Up && Grid.TileGrid [position_.Tile.X' position_.Tile.Y - 1].Type == TileTypes.Open) || (direction_ == Direction.Down && Grid.TileGrid [position_.Tile.X' position_.Tile.Y + 1].Type == TileTypes.Open) || (direction_ == Direction.Left && Grid.TileGrid [position_.Tile.X - 1' position_.Tile.Y].Type == TileTypes.Open) || (direction_ == Direction.Right && Grid.TileGrid [position_.Tile.X + 1' position_.Tile.Y].Type == TileTypes.Open)) {  	DoMove ();  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,TryMove,The following statement contains a magic number: if (position_.DeltaPixel != Point.Zero) {  	DoMove ();  } // Special case : the tunnel.  else if ((position_.Tile == new Point (0' 14) && direction_ == Direction.Left) || (position_.Tile == new Point (27' 14) && direction_ == Direction.Right)) {  	DoMove ();  } // If on a tile' we only move if the next tile in our direction is open  else if ((direction_ == Direction.Up && Grid.TileGrid [position_.Tile.X' position_.Tile.Y - 1].Type == TileTypes.Open) || (direction_ == Direction.Down && Grid.TileGrid [position_.Tile.X' position_.Tile.Y + 1].Type == TileTypes.Open) || (direction_ == Direction.Left && Grid.TileGrid [position_.Tile.X - 1' position_.Tile.Y].Type == TileTypes.Open) || (direction_ == Direction.Right && Grid.TileGrid [position_.Tile.X + 1' position_.Tile.Y].Type == TileTypes.Open)) {  	DoMove ();  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,TryMove,The following statement contains a magic number: if (position_.DeltaPixel != Point.Zero) {  	DoMove ();  } // Special case : the tunnel.  else if ((position_.Tile == new Point (0' 14) && direction_ == Direction.Left) || (position_.Tile == new Point (27' 14) && direction_ == Direction.Right)) {  	DoMove ();  } // If on a tile' we only move if the next tile in our direction is open  else if ((direction_ == Direction.Up && Grid.TileGrid [position_.Tile.X' position_.Tile.Y - 1].Type == TileTypes.Open) || (direction_ == Direction.Down && Grid.TileGrid [position_.Tile.X' position_.Tile.Y + 1].Type == TileTypes.Open) || (direction_ == Direction.Left && Grid.TileGrid [position_.Tile.X - 1' position_.Tile.Y].Type == TileTypes.Open) || (direction_ == Direction.Right && Grid.TileGrid [position_.Tile.X + 1' position_.Tile.Y].Type == TileTypes.Open)) {  	DoMove ();  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,TryMove,The following statement contains a magic number: if ((position_.Tile == new Point (0' 14) && direction_ == Direction.Left) || (position_.Tile == new Point (27' 14) && direction_ == Direction.Right)) {  	DoMove ();  } // If on a tile' we only move if the next tile in our direction is open  else if ((direction_ == Direction.Up && Grid.TileGrid [position_.Tile.X' position_.Tile.Y - 1].Type == TileTypes.Open) || (direction_ == Direction.Down && Grid.TileGrid [position_.Tile.X' position_.Tile.Y + 1].Type == TileTypes.Open) || (direction_ == Direction.Left && Grid.TileGrid [position_.Tile.X - 1' position_.Tile.Y].Type == TileTypes.Open) || (direction_ == Direction.Right && Grid.TileGrid [position_.Tile.X + 1' position_.Tile.Y].Type == TileTypes.Open)) {  	DoMove ();  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,TryMove,The following statement contains a magic number: if ((position_.Tile == new Point (0' 14) && direction_ == Direction.Left) || (position_.Tile == new Point (27' 14) && direction_ == Direction.Right)) {  	DoMove ();  } // If on a tile' we only move if the next tile in our direction is open  else if ((direction_ == Direction.Up && Grid.TileGrid [position_.Tile.X' position_.Tile.Y - 1].Type == TileTypes.Open) || (direction_ == Direction.Down && Grid.TileGrid [position_.Tile.X' position_.Tile.Y + 1].Type == TileTypes.Open) || (direction_ == Direction.Left && Grid.TileGrid [position_.Tile.X - 1' position_.Tile.Y].Type == TileTypes.Open) || (direction_ == Direction.Right && Grid.TileGrid [position_.Tile.X + 1' position_.Tile.Y].Type == TileTypes.Open)) {  	DoMove ();  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,TryMove,The following statement contains a magic number: if ((position_.Tile == new Point (0' 14) && direction_ == Direction.Left) || (position_.Tile == new Point (27' 14) && direction_ == Direction.Right)) {  	DoMove ();  } // If on a tile' we only move if the next tile in our direction is open  else if ((direction_ == Direction.Up && Grid.TileGrid [position_.Tile.X' position_.Tile.Y - 1].Type == TileTypes.Open) || (direction_ == Direction.Down && Grid.TileGrid [position_.Tile.X' position_.Tile.Y + 1].Type == TileTypes.Open) || (direction_ == Direction.Left && Grid.TileGrid [position_.Tile.X - 1' position_.Tile.Y].Type == TileTypes.Open) || (direction_ == Direction.Right && Grid.TileGrid [position_.Tile.X + 1' position_.Tile.Y].Type == TileTypes.Open)) {  	DoMove ();  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoMove,The following statement contains a magic number: if (updateCount_ == 0) {  	// Now is a nice time to update our speed' like we do for the ghosts.  	if (Ghost.NextTile (direction_' position_).HasCrump) {  		updatesPerPixel_ = Constants.PacManSpeed () + 2;  	} else {  		updatesPerPixel_ = Constants.PacManSpeed ();  	}  	// Move one pixel in the desired direction  	if (direction_ == Direction.Up) {  		position_.DeltaPixel.Y--;  	} else if (direction_ == Direction.Down) {  		position_.DeltaPixel.Y++;  	} else if (direction_ == Direction.Left) {  		position_.DeltaPixel.X--;  	} else if (direction_ == Direction.Right) {  		position_.DeltaPixel.X++;  	}  	// By moving one pixel we might have moved to another tile completely  	if (position_.DeltaPixel.X == 16) {  		// Special case : the tunnel  		if (position_.Tile.X == 27) {  			position_.Tile.X = 0;  		} else {  			position_.Tile.X++;  		}  		position_.DeltaPixel.X = 0;  	} else if (position_.DeltaPixel.X == -16) {  		// Special case : the tunnel  		if (position_.Tile.X == 0) {  			position_.Tile.X = 27;  		} else {  			position_.Tile.X--;  		}  		position_.DeltaPixel.X = 0;  	} else if (position_.DeltaPixel.Y == 16) {  		position_.Tile.Y++;  		position_.DeltaPixel.Y = 0;  	} else if (position_.DeltaPixel.Y == -16) {  		position_.Tile.Y--;  		position_.DeltaPixel.Y = 0;  	}  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoMove,The following statement contains a magic number: if (updateCount_ == 0) {  	// Now is a nice time to update our speed' like we do for the ghosts.  	if (Ghost.NextTile (direction_' position_).HasCrump) {  		updatesPerPixel_ = Constants.PacManSpeed () + 2;  	} else {  		updatesPerPixel_ = Constants.PacManSpeed ();  	}  	// Move one pixel in the desired direction  	if (direction_ == Direction.Up) {  		position_.DeltaPixel.Y--;  	} else if (direction_ == Direction.Down) {  		position_.DeltaPixel.Y++;  	} else if (direction_ == Direction.Left) {  		position_.DeltaPixel.X--;  	} else if (direction_ == Direction.Right) {  		position_.DeltaPixel.X++;  	}  	// By moving one pixel we might have moved to another tile completely  	if (position_.DeltaPixel.X == 16) {  		// Special case : the tunnel  		if (position_.Tile.X == 27) {  			position_.Tile.X = 0;  		} else {  			position_.Tile.X++;  		}  		position_.DeltaPixel.X = 0;  	} else if (position_.DeltaPixel.X == -16) {  		// Special case : the tunnel  		if (position_.Tile.X == 0) {  			position_.Tile.X = 27;  		} else {  			position_.Tile.X--;  		}  		position_.DeltaPixel.X = 0;  	} else if (position_.DeltaPixel.Y == 16) {  		position_.Tile.Y++;  		position_.DeltaPixel.Y = 0;  	} else if (position_.DeltaPixel.Y == -16) {  		position_.Tile.Y--;  		position_.DeltaPixel.Y = 0;  	}  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoMove,The following statement contains a magic number: if (updateCount_ == 0) {  	// Now is a nice time to update our speed' like we do for the ghosts.  	if (Ghost.NextTile (direction_' position_).HasCrump) {  		updatesPerPixel_ = Constants.PacManSpeed () + 2;  	} else {  		updatesPerPixel_ = Constants.PacManSpeed ();  	}  	// Move one pixel in the desired direction  	if (direction_ == Direction.Up) {  		position_.DeltaPixel.Y--;  	} else if (direction_ == Direction.Down) {  		position_.DeltaPixel.Y++;  	} else if (direction_ == Direction.Left) {  		position_.DeltaPixel.X--;  	} else if (direction_ == Direction.Right) {  		position_.DeltaPixel.X++;  	}  	// By moving one pixel we might have moved to another tile completely  	if (position_.DeltaPixel.X == 16) {  		// Special case : the tunnel  		if (position_.Tile.X == 27) {  			position_.Tile.X = 0;  		} else {  			position_.Tile.X++;  		}  		position_.DeltaPixel.X = 0;  	} else if (position_.DeltaPixel.X == -16) {  		// Special case : the tunnel  		if (position_.Tile.X == 0) {  			position_.Tile.X = 27;  		} else {  			position_.Tile.X--;  		}  		position_.DeltaPixel.X = 0;  	} else if (position_.DeltaPixel.Y == 16) {  		position_.Tile.Y++;  		position_.DeltaPixel.Y = 0;  	} else if (position_.DeltaPixel.Y == -16) {  		position_.Tile.Y--;  		position_.DeltaPixel.Y = 0;  	}  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoMove,The following statement contains a magic number: if (updateCount_ == 0) {  	// Now is a nice time to update our speed' like we do for the ghosts.  	if (Ghost.NextTile (direction_' position_).HasCrump) {  		updatesPerPixel_ = Constants.PacManSpeed () + 2;  	} else {  		updatesPerPixel_ = Constants.PacManSpeed ();  	}  	// Move one pixel in the desired direction  	if (direction_ == Direction.Up) {  		position_.DeltaPixel.Y--;  	} else if (direction_ == Direction.Down) {  		position_.DeltaPixel.Y++;  	} else if (direction_ == Direction.Left) {  		position_.DeltaPixel.X--;  	} else if (direction_ == Direction.Right) {  		position_.DeltaPixel.X++;  	}  	// By moving one pixel we might have moved to another tile completely  	if (position_.DeltaPixel.X == 16) {  		// Special case : the tunnel  		if (position_.Tile.X == 27) {  			position_.Tile.X = 0;  		} else {  			position_.Tile.X++;  		}  		position_.DeltaPixel.X = 0;  	} else if (position_.DeltaPixel.X == -16) {  		// Special case : the tunnel  		if (position_.Tile.X == 0) {  			position_.Tile.X = 27;  		} else {  			position_.Tile.X--;  		}  		position_.DeltaPixel.X = 0;  	} else if (position_.DeltaPixel.Y == 16) {  		position_.Tile.Y++;  		position_.DeltaPixel.Y = 0;  	} else if (position_.DeltaPixel.Y == -16) {  		position_.Tile.Y--;  		position_.DeltaPixel.Y = 0;  	}  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoMove,The following statement contains a magic number: if (updateCount_ == 0) {  	// Now is a nice time to update our speed' like we do for the ghosts.  	if (Ghost.NextTile (direction_' position_).HasCrump) {  		updatesPerPixel_ = Constants.PacManSpeed () + 2;  	} else {  		updatesPerPixel_ = Constants.PacManSpeed ();  	}  	// Move one pixel in the desired direction  	if (direction_ == Direction.Up) {  		position_.DeltaPixel.Y--;  	} else if (direction_ == Direction.Down) {  		position_.DeltaPixel.Y++;  	} else if (direction_ == Direction.Left) {  		position_.DeltaPixel.X--;  	} else if (direction_ == Direction.Right) {  		position_.DeltaPixel.X++;  	}  	// By moving one pixel we might have moved to another tile completely  	if (position_.DeltaPixel.X == 16) {  		// Special case : the tunnel  		if (position_.Tile.X == 27) {  			position_.Tile.X = 0;  		} else {  			position_.Tile.X++;  		}  		position_.DeltaPixel.X = 0;  	} else if (position_.DeltaPixel.X == -16) {  		// Special case : the tunnel  		if (position_.Tile.X == 0) {  			position_.Tile.X = 27;  		} else {  			position_.Tile.X--;  		}  		position_.DeltaPixel.X = 0;  	} else if (position_.DeltaPixel.Y == 16) {  		position_.Tile.Y++;  		position_.DeltaPixel.Y = 0;  	} else if (position_.DeltaPixel.Y == -16) {  		position_.Tile.Y--;  		position_.DeltaPixel.Y = 0;  	}  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoMove,The following statement contains a magic number: if (updateCount_ == 0) {  	// Now is a nice time to update our speed' like we do for the ghosts.  	if (Ghost.NextTile (direction_' position_).HasCrump) {  		updatesPerPixel_ = Constants.PacManSpeed () + 2;  	} else {  		updatesPerPixel_ = Constants.PacManSpeed ();  	}  	// Move one pixel in the desired direction  	if (direction_ == Direction.Up) {  		position_.DeltaPixel.Y--;  	} else if (direction_ == Direction.Down) {  		position_.DeltaPixel.Y++;  	} else if (direction_ == Direction.Left) {  		position_.DeltaPixel.X--;  	} else if (direction_ == Direction.Right) {  		position_.DeltaPixel.X++;  	}  	// By moving one pixel we might have moved to another tile completely  	if (position_.DeltaPixel.X == 16) {  		// Special case : the tunnel  		if (position_.Tile.X == 27) {  			position_.Tile.X = 0;  		} else {  			position_.Tile.X++;  		}  		position_.DeltaPixel.X = 0;  	} else if (position_.DeltaPixel.X == -16) {  		// Special case : the tunnel  		if (position_.Tile.X == 0) {  			position_.Tile.X = 27;  		} else {  			position_.Tile.X--;  		}  		position_.DeltaPixel.X = 0;  	} else if (position_.DeltaPixel.Y == 16) {  		position_.Tile.Y++;  		position_.DeltaPixel.Y = 0;  	} else if (position_.DeltaPixel.Y == -16) {  		position_.Tile.Y--;  		position_.DeltaPixel.Y = 0;  	}  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoMove,The following statement contains a magic number: if (updateCount_ == 0) {  	// Now is a nice time to update our speed' like we do for the ghosts.  	if (Ghost.NextTile (direction_' position_).HasCrump) {  		updatesPerPixel_ = Constants.PacManSpeed () + 2;  	} else {  		updatesPerPixel_ = Constants.PacManSpeed ();  	}  	// Move one pixel in the desired direction  	if (direction_ == Direction.Up) {  		position_.DeltaPixel.Y--;  	} else if (direction_ == Direction.Down) {  		position_.DeltaPixel.Y++;  	} else if (direction_ == Direction.Left) {  		position_.DeltaPixel.X--;  	} else if (direction_ == Direction.Right) {  		position_.DeltaPixel.X++;  	}  	// By moving one pixel we might have moved to another tile completely  	if (position_.DeltaPixel.X == 16) {  		// Special case : the tunnel  		if (position_.Tile.X == 27) {  			position_.Tile.X = 0;  		} else {  			position_.Tile.X++;  		}  		position_.DeltaPixel.X = 0;  	} else if (position_.DeltaPixel.X == -16) {  		// Special case : the tunnel  		if (position_.Tile.X == 0) {  			position_.Tile.X = 27;  		} else {  			position_.Tile.X--;  		}  		position_.DeltaPixel.X = 0;  	} else if (position_.DeltaPixel.Y == 16) {  		position_.Tile.Y++;  		position_.DeltaPixel.Y = 0;  	} else if (position_.DeltaPixel.Y == -16) {  		position_.Tile.Y--;  		position_.DeltaPixel.Y = 0;  	}  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoMove,The following statement contains a magic number: if (Ghost.NextTile (direction_' position_).HasCrump) {  	updatesPerPixel_ = Constants.PacManSpeed () + 2;  } else {  	updatesPerPixel_ = Constants.PacManSpeed ();  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoMove,The following statement contains a magic number: updatesPerPixel_ = Constants.PacManSpeed () + 2;  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoMove,The following statement contains a magic number: if (position_.DeltaPixel.X == 16) {  	// Special case : the tunnel  	if (position_.Tile.X == 27) {  		position_.Tile.X = 0;  	} else {  		position_.Tile.X++;  	}  	position_.DeltaPixel.X = 0;  } else if (position_.DeltaPixel.X == -16) {  	// Special case : the tunnel  	if (position_.Tile.X == 0) {  		position_.Tile.X = 27;  	} else {  		position_.Tile.X--;  	}  	position_.DeltaPixel.X = 0;  } else if (position_.DeltaPixel.Y == 16) {  	position_.Tile.Y++;  	position_.DeltaPixel.Y = 0;  } else if (position_.DeltaPixel.Y == -16) {  	position_.Tile.Y--;  	position_.DeltaPixel.Y = 0;  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoMove,The following statement contains a magic number: if (position_.DeltaPixel.X == 16) {  	// Special case : the tunnel  	if (position_.Tile.X == 27) {  		position_.Tile.X = 0;  	} else {  		position_.Tile.X++;  	}  	position_.DeltaPixel.X = 0;  } else if (position_.DeltaPixel.X == -16) {  	// Special case : the tunnel  	if (position_.Tile.X == 0) {  		position_.Tile.X = 27;  	} else {  		position_.Tile.X--;  	}  	position_.DeltaPixel.X = 0;  } else if (position_.DeltaPixel.Y == 16) {  	position_.Tile.Y++;  	position_.DeltaPixel.Y = 0;  } else if (position_.DeltaPixel.Y == -16) {  	position_.Tile.Y--;  	position_.DeltaPixel.Y = 0;  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoMove,The following statement contains a magic number: if (position_.DeltaPixel.X == 16) {  	// Special case : the tunnel  	if (position_.Tile.X == 27) {  		position_.Tile.X = 0;  	} else {  		position_.Tile.X++;  	}  	position_.DeltaPixel.X = 0;  } else if (position_.DeltaPixel.X == -16) {  	// Special case : the tunnel  	if (position_.Tile.X == 0) {  		position_.Tile.X = 27;  	} else {  		position_.Tile.X--;  	}  	position_.DeltaPixel.X = 0;  } else if (position_.DeltaPixel.Y == 16) {  	position_.Tile.Y++;  	position_.DeltaPixel.Y = 0;  } else if (position_.DeltaPixel.Y == -16) {  	position_.Tile.Y--;  	position_.DeltaPixel.Y = 0;  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoMove,The following statement contains a magic number: if (position_.DeltaPixel.X == 16) {  	// Special case : the tunnel  	if (position_.Tile.X == 27) {  		position_.Tile.X = 0;  	} else {  		position_.Tile.X++;  	}  	position_.DeltaPixel.X = 0;  } else if (position_.DeltaPixel.X == -16) {  	// Special case : the tunnel  	if (position_.Tile.X == 0) {  		position_.Tile.X = 27;  	} else {  		position_.Tile.X--;  	}  	position_.DeltaPixel.X = 0;  } else if (position_.DeltaPixel.Y == 16) {  	position_.Tile.Y++;  	position_.DeltaPixel.Y = 0;  } else if (position_.DeltaPixel.Y == -16) {  	position_.Tile.Y--;  	position_.DeltaPixel.Y = 0;  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoMove,The following statement contains a magic number: if (position_.DeltaPixel.X == 16) {  	// Special case : the tunnel  	if (position_.Tile.X == 27) {  		position_.Tile.X = 0;  	} else {  		position_.Tile.X++;  	}  	position_.DeltaPixel.X = 0;  } else if (position_.DeltaPixel.X == -16) {  	// Special case : the tunnel  	if (position_.Tile.X == 0) {  		position_.Tile.X = 27;  	} else {  		position_.Tile.X--;  	}  	position_.DeltaPixel.X = 0;  } else if (position_.DeltaPixel.Y == 16) {  	position_.Tile.Y++;  	position_.DeltaPixel.Y = 0;  } else if (position_.DeltaPixel.Y == -16) {  	position_.Tile.Y--;  	position_.DeltaPixel.Y = 0;  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoMove,The following statement contains a magic number: if (position_.DeltaPixel.X == 16) {  	// Special case : the tunnel  	if (position_.Tile.X == 27) {  		position_.Tile.X = 0;  	} else {  		position_.Tile.X++;  	}  	position_.DeltaPixel.X = 0;  } else if (position_.DeltaPixel.X == -16) {  	// Special case : the tunnel  	if (position_.Tile.X == 0) {  		position_.Tile.X = 27;  	} else {  		position_.Tile.X--;  	}  	position_.DeltaPixel.X = 0;  } else if (position_.DeltaPixel.Y == 16) {  	position_.Tile.Y++;  	position_.DeltaPixel.Y = 0;  } else if (position_.DeltaPixel.Y == -16) {  	position_.Tile.Y--;  	position_.DeltaPixel.Y = 0;  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoMove,The following statement contains a magic number: if (position_.Tile.X == 27) {  	position_.Tile.X = 0;  } else {  	position_.Tile.X++;  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoMove,The following statement contains a magic number: if (position_.DeltaPixel.X == -16) {  	// Special case : the tunnel  	if (position_.Tile.X == 0) {  		position_.Tile.X = 27;  	} else {  		position_.Tile.X--;  	}  	position_.DeltaPixel.X = 0;  } else if (position_.DeltaPixel.Y == 16) {  	position_.Tile.Y++;  	position_.DeltaPixel.Y = 0;  } else if (position_.DeltaPixel.Y == -16) {  	position_.Tile.Y--;  	position_.DeltaPixel.Y = 0;  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoMove,The following statement contains a magic number: if (position_.DeltaPixel.X == -16) {  	// Special case : the tunnel  	if (position_.Tile.X == 0) {  		position_.Tile.X = 27;  	} else {  		position_.Tile.X--;  	}  	position_.DeltaPixel.X = 0;  } else if (position_.DeltaPixel.Y == 16) {  	position_.Tile.Y++;  	position_.DeltaPixel.Y = 0;  } else if (position_.DeltaPixel.Y == -16) {  	position_.Tile.Y--;  	position_.DeltaPixel.Y = 0;  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoMove,The following statement contains a magic number: if (position_.DeltaPixel.X == -16) {  	// Special case : the tunnel  	if (position_.Tile.X == 0) {  		position_.Tile.X = 27;  	} else {  		position_.Tile.X--;  	}  	position_.DeltaPixel.X = 0;  } else if (position_.DeltaPixel.Y == 16) {  	position_.Tile.Y++;  	position_.DeltaPixel.Y = 0;  } else if (position_.DeltaPixel.Y == -16) {  	position_.Tile.Y--;  	position_.DeltaPixel.Y = 0;  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoMove,The following statement contains a magic number: if (position_.DeltaPixel.X == -16) {  	// Special case : the tunnel  	if (position_.Tile.X == 0) {  		position_.Tile.X = 27;  	} else {  		position_.Tile.X--;  	}  	position_.DeltaPixel.X = 0;  } else if (position_.DeltaPixel.Y == 16) {  	position_.Tile.Y++;  	position_.DeltaPixel.Y = 0;  } else if (position_.DeltaPixel.Y == -16) {  	position_.Tile.Y--;  	position_.DeltaPixel.Y = 0;  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoMove,The following statement contains a magic number: if (position_.Tile.X == 0) {  	position_.Tile.X = 27;  } else {  	position_.Tile.X--;  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoMove,The following statement contains a magic number: position_.Tile.X = 27;  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoMove,The following statement contains a magic number: if (position_.DeltaPixel.Y == 16) {  	position_.Tile.Y++;  	position_.DeltaPixel.Y = 0;  } else if (position_.DeltaPixel.Y == -16) {  	position_.Tile.Y--;  	position_.DeltaPixel.Y = 0;  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoMove,The following statement contains a magic number: if (position_.DeltaPixel.Y == 16) {  	position_.Tile.Y++;  	position_.DeltaPixel.Y = 0;  } else if (position_.DeltaPixel.Y == -16) {  	position_.Tile.Y--;  	position_.DeltaPixel.Y = 0;  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoMove,The following statement contains a magic number: if (position_.DeltaPixel.Y == -16) {  	position_.Tile.Y--;  	position_.DeltaPixel.Y = 0;  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Draw,The following statement contains a magic number: position.X = boardPosition.X + (position_.Tile.X * 16) + position_.DeltaPixel.X - ((eatingFrames_ [0].Width - 16) / 2);  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Draw,The following statement contains a magic number: position.X = boardPosition.X + (position_.Tile.X * 16) + position_.DeltaPixel.X - ((eatingFrames_ [0].Width - 16) / 2);  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Draw,The following statement contains a magic number: position.X = boardPosition.X + (position_.Tile.X * 16) + position_.DeltaPixel.X - ((eatingFrames_ [0].Width - 16) / 2);  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Draw,The following statement contains a magic number: position.Y = boardPosition.Y + (position_.Tile.Y * 16) + position_.DeltaPixel.Y - ((eatingFrames_ [0].Height - 16) / 2);  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Draw,The following statement contains a magic number: position.Y = boardPosition.Y + (position_.Tile.Y * 16) + position_.DeltaPixel.Y - ((eatingFrames_ [0].Height - 16) / 2);  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Draw,The following statement contains a magic number: position.Y = boardPosition.Y + (position_.Tile.Y * 16) + position_.DeltaPixel.Y - ((eatingFrames_ [0].Height - 16) / 2);  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Draw,The following statement contains a magic number: if (state_ == State.Start) {  	spriteBatch_.Draw (eatingFrames_ [0]' position' Color.White);  } else if (state_ == State.Normal) {  	// The frame index is taken as a function of how much the pac man is off from a tile' the size of  	// a tile (always 16 pixels)' and how many frames we use for the animation.  	int frame = Math.Abs (position_.DeltaPixel.X + position_.DeltaPixel.Y) / (16 / usedFramesIndex_.Length);  	frame = (int)MathHelper.Clamp (frame' 0' usedFramesIndex_.Length - 1);  	RenderSprite (eatingFrames_ [usedFramesIndex_ [frame]]' null' boardPosition' position);  } else if (state_ == State.Dying) {  	int timeBetweenFrames = 90;  	// Sound "Death" is 1811 milliseconds long' we have 20 frames to go through.  	//timer_ += gameTime.ElapsedRealTime;  	timer_ += gameTime.ElapsedGameTime;  	int index = (timer_.Seconds * 1000 + timer_.Milliseconds) / timeBetweenFrames;  	if (index > 19) {  		return;  	}  	RenderSprite (dyingFrames_' new Rectangle (26 * index' 0' 26' 26)' boardPosition' position);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Draw,The following statement contains a magic number: if (state_ == State.Start) {  	spriteBatch_.Draw (eatingFrames_ [0]' position' Color.White);  } else if (state_ == State.Normal) {  	// The frame index is taken as a function of how much the pac man is off from a tile' the size of  	// a tile (always 16 pixels)' and how many frames we use for the animation.  	int frame = Math.Abs (position_.DeltaPixel.X + position_.DeltaPixel.Y) / (16 / usedFramesIndex_.Length);  	frame = (int)MathHelper.Clamp (frame' 0' usedFramesIndex_.Length - 1);  	RenderSprite (eatingFrames_ [usedFramesIndex_ [frame]]' null' boardPosition' position);  } else if (state_ == State.Dying) {  	int timeBetweenFrames = 90;  	// Sound "Death" is 1811 milliseconds long' we have 20 frames to go through.  	//timer_ += gameTime.ElapsedRealTime;  	timer_ += gameTime.ElapsedGameTime;  	int index = (timer_.Seconds * 1000 + timer_.Milliseconds) / timeBetweenFrames;  	if (index > 19) {  		return;  	}  	RenderSprite (dyingFrames_' new Rectangle (26 * index' 0' 26' 26)' boardPosition' position);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Draw,The following statement contains a magic number: if (state_ == State.Start) {  	spriteBatch_.Draw (eatingFrames_ [0]' position' Color.White);  } else if (state_ == State.Normal) {  	// The frame index is taken as a function of how much the pac man is off from a tile' the size of  	// a tile (always 16 pixels)' and how many frames we use for the animation.  	int frame = Math.Abs (position_.DeltaPixel.X + position_.DeltaPixel.Y) / (16 / usedFramesIndex_.Length);  	frame = (int)MathHelper.Clamp (frame' 0' usedFramesIndex_.Length - 1);  	RenderSprite (eatingFrames_ [usedFramesIndex_ [frame]]' null' boardPosition' position);  } else if (state_ == State.Dying) {  	int timeBetweenFrames = 90;  	// Sound "Death" is 1811 milliseconds long' we have 20 frames to go through.  	//timer_ += gameTime.ElapsedRealTime;  	timer_ += gameTime.ElapsedGameTime;  	int index = (timer_.Seconds * 1000 + timer_.Milliseconds) / timeBetweenFrames;  	if (index > 19) {  		return;  	}  	RenderSprite (dyingFrames_' new Rectangle (26 * index' 0' 26' 26)' boardPosition' position);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Draw,The following statement contains a magic number: if (state_ == State.Start) {  	spriteBatch_.Draw (eatingFrames_ [0]' position' Color.White);  } else if (state_ == State.Normal) {  	// The frame index is taken as a function of how much the pac man is off from a tile' the size of  	// a tile (always 16 pixels)' and how many frames we use for the animation.  	int frame = Math.Abs (position_.DeltaPixel.X + position_.DeltaPixel.Y) / (16 / usedFramesIndex_.Length);  	frame = (int)MathHelper.Clamp (frame' 0' usedFramesIndex_.Length - 1);  	RenderSprite (eatingFrames_ [usedFramesIndex_ [frame]]' null' boardPosition' position);  } else if (state_ == State.Dying) {  	int timeBetweenFrames = 90;  	// Sound "Death" is 1811 milliseconds long' we have 20 frames to go through.  	//timer_ += gameTime.ElapsedRealTime;  	timer_ += gameTime.ElapsedGameTime;  	int index = (timer_.Seconds * 1000 + timer_.Milliseconds) / timeBetweenFrames;  	if (index > 19) {  		return;  	}  	RenderSprite (dyingFrames_' new Rectangle (26 * index' 0' 26' 26)' boardPosition' position);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Draw,The following statement contains a magic number: if (state_ == State.Start) {  	spriteBatch_.Draw (eatingFrames_ [0]' position' Color.White);  } else if (state_ == State.Normal) {  	// The frame index is taken as a function of how much the pac man is off from a tile' the size of  	// a tile (always 16 pixels)' and how many frames we use for the animation.  	int frame = Math.Abs (position_.DeltaPixel.X + position_.DeltaPixel.Y) / (16 / usedFramesIndex_.Length);  	frame = (int)MathHelper.Clamp (frame' 0' usedFramesIndex_.Length - 1);  	RenderSprite (eatingFrames_ [usedFramesIndex_ [frame]]' null' boardPosition' position);  } else if (state_ == State.Dying) {  	int timeBetweenFrames = 90;  	// Sound "Death" is 1811 milliseconds long' we have 20 frames to go through.  	//timer_ += gameTime.ElapsedRealTime;  	timer_ += gameTime.ElapsedGameTime;  	int index = (timer_.Seconds * 1000 + timer_.Milliseconds) / timeBetweenFrames;  	if (index > 19) {  		return;  	}  	RenderSprite (dyingFrames_' new Rectangle (26 * index' 0' 26' 26)' boardPosition' position);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Draw,The following statement contains a magic number: if (state_ == State.Start) {  	spriteBatch_.Draw (eatingFrames_ [0]' position' Color.White);  } else if (state_ == State.Normal) {  	// The frame index is taken as a function of how much the pac man is off from a tile' the size of  	// a tile (always 16 pixels)' and how many frames we use for the animation.  	int frame = Math.Abs (position_.DeltaPixel.X + position_.DeltaPixel.Y) / (16 / usedFramesIndex_.Length);  	frame = (int)MathHelper.Clamp (frame' 0' usedFramesIndex_.Length - 1);  	RenderSprite (eatingFrames_ [usedFramesIndex_ [frame]]' null' boardPosition' position);  } else if (state_ == State.Dying) {  	int timeBetweenFrames = 90;  	// Sound "Death" is 1811 milliseconds long' we have 20 frames to go through.  	//timer_ += gameTime.ElapsedRealTime;  	timer_ += gameTime.ElapsedGameTime;  	int index = (timer_.Seconds * 1000 + timer_.Milliseconds) / timeBetweenFrames;  	if (index > 19) {  		return;  	}  	RenderSprite (dyingFrames_' new Rectangle (26 * index' 0' 26' 26)' boardPosition' position);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Draw,The following statement contains a magic number: if (state_ == State.Start) {  	spriteBatch_.Draw (eatingFrames_ [0]' position' Color.White);  } else if (state_ == State.Normal) {  	// The frame index is taken as a function of how much the pac man is off from a tile' the size of  	// a tile (always 16 pixels)' and how many frames we use for the animation.  	int frame = Math.Abs (position_.DeltaPixel.X + position_.DeltaPixel.Y) / (16 / usedFramesIndex_.Length);  	frame = (int)MathHelper.Clamp (frame' 0' usedFramesIndex_.Length - 1);  	RenderSprite (eatingFrames_ [usedFramesIndex_ [frame]]' null' boardPosition' position);  } else if (state_ == State.Dying) {  	int timeBetweenFrames = 90;  	// Sound "Death" is 1811 milliseconds long' we have 20 frames to go through.  	//timer_ += gameTime.ElapsedRealTime;  	timer_ += gameTime.ElapsedGameTime;  	int index = (timer_.Seconds * 1000 + timer_.Milliseconds) / timeBetweenFrames;  	if (index > 19) {  		return;  	}  	RenderSprite (dyingFrames_' new Rectangle (26 * index' 0' 26' 26)' boardPosition' position);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Draw,The following statement contains a magic number: if (state_ == State.Normal) {  	// The frame index is taken as a function of how much the pac man is off from a tile' the size of  	// a tile (always 16 pixels)' and how many frames we use for the animation.  	int frame = Math.Abs (position_.DeltaPixel.X + position_.DeltaPixel.Y) / (16 / usedFramesIndex_.Length);  	frame = (int)MathHelper.Clamp (frame' 0' usedFramesIndex_.Length - 1);  	RenderSprite (eatingFrames_ [usedFramesIndex_ [frame]]' null' boardPosition' position);  } else if (state_ == State.Dying) {  	int timeBetweenFrames = 90;  	// Sound "Death" is 1811 milliseconds long' we have 20 frames to go through.  	//timer_ += gameTime.ElapsedRealTime;  	timer_ += gameTime.ElapsedGameTime;  	int index = (timer_.Seconds * 1000 + timer_.Milliseconds) / timeBetweenFrames;  	if (index > 19) {  		return;  	}  	RenderSprite (dyingFrames_' new Rectangle (26 * index' 0' 26' 26)' boardPosition' position);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Draw,The following statement contains a magic number: if (state_ == State.Normal) {  	// The frame index is taken as a function of how much the pac man is off from a tile' the size of  	// a tile (always 16 pixels)' and how many frames we use for the animation.  	int frame = Math.Abs (position_.DeltaPixel.X + position_.DeltaPixel.Y) / (16 / usedFramesIndex_.Length);  	frame = (int)MathHelper.Clamp (frame' 0' usedFramesIndex_.Length - 1);  	RenderSprite (eatingFrames_ [usedFramesIndex_ [frame]]' null' boardPosition' position);  } else if (state_ == State.Dying) {  	int timeBetweenFrames = 90;  	// Sound "Death" is 1811 milliseconds long' we have 20 frames to go through.  	//timer_ += gameTime.ElapsedRealTime;  	timer_ += gameTime.ElapsedGameTime;  	int index = (timer_.Seconds * 1000 + timer_.Milliseconds) / timeBetweenFrames;  	if (index > 19) {  		return;  	}  	RenderSprite (dyingFrames_' new Rectangle (26 * index' 0' 26' 26)' boardPosition' position);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Draw,The following statement contains a magic number: if (state_ == State.Normal) {  	// The frame index is taken as a function of how much the pac man is off from a tile' the size of  	// a tile (always 16 pixels)' and how many frames we use for the animation.  	int frame = Math.Abs (position_.DeltaPixel.X + position_.DeltaPixel.Y) / (16 / usedFramesIndex_.Length);  	frame = (int)MathHelper.Clamp (frame' 0' usedFramesIndex_.Length - 1);  	RenderSprite (eatingFrames_ [usedFramesIndex_ [frame]]' null' boardPosition' position);  } else if (state_ == State.Dying) {  	int timeBetweenFrames = 90;  	// Sound "Death" is 1811 milliseconds long' we have 20 frames to go through.  	//timer_ += gameTime.ElapsedRealTime;  	timer_ += gameTime.ElapsedGameTime;  	int index = (timer_.Seconds * 1000 + timer_.Milliseconds) / timeBetweenFrames;  	if (index > 19) {  		return;  	}  	RenderSprite (dyingFrames_' new Rectangle (26 * index' 0' 26' 26)' boardPosition' position);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Draw,The following statement contains a magic number: if (state_ == State.Normal) {  	// The frame index is taken as a function of how much the pac man is off from a tile' the size of  	// a tile (always 16 pixels)' and how many frames we use for the animation.  	int frame = Math.Abs (position_.DeltaPixel.X + position_.DeltaPixel.Y) / (16 / usedFramesIndex_.Length);  	frame = (int)MathHelper.Clamp (frame' 0' usedFramesIndex_.Length - 1);  	RenderSprite (eatingFrames_ [usedFramesIndex_ [frame]]' null' boardPosition' position);  } else if (state_ == State.Dying) {  	int timeBetweenFrames = 90;  	// Sound "Death" is 1811 milliseconds long' we have 20 frames to go through.  	//timer_ += gameTime.ElapsedRealTime;  	timer_ += gameTime.ElapsedGameTime;  	int index = (timer_.Seconds * 1000 + timer_.Milliseconds) / timeBetweenFrames;  	if (index > 19) {  		return;  	}  	RenderSprite (dyingFrames_' new Rectangle (26 * index' 0' 26' 26)' boardPosition' position);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Draw,The following statement contains a magic number: if (state_ == State.Normal) {  	// The frame index is taken as a function of how much the pac man is off from a tile' the size of  	// a tile (always 16 pixels)' and how many frames we use for the animation.  	int frame = Math.Abs (position_.DeltaPixel.X + position_.DeltaPixel.Y) / (16 / usedFramesIndex_.Length);  	frame = (int)MathHelper.Clamp (frame' 0' usedFramesIndex_.Length - 1);  	RenderSprite (eatingFrames_ [usedFramesIndex_ [frame]]' null' boardPosition' position);  } else if (state_ == State.Dying) {  	int timeBetweenFrames = 90;  	// Sound "Death" is 1811 milliseconds long' we have 20 frames to go through.  	//timer_ += gameTime.ElapsedRealTime;  	timer_ += gameTime.ElapsedGameTime;  	int index = (timer_.Seconds * 1000 + timer_.Milliseconds) / timeBetweenFrames;  	if (index > 19) {  		return;  	}  	RenderSprite (dyingFrames_' new Rectangle (26 * index' 0' 26' 26)' boardPosition' position);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Draw,The following statement contains a magic number: if (state_ == State.Normal) {  	// The frame index is taken as a function of how much the pac man is off from a tile' the size of  	// a tile (always 16 pixels)' and how many frames we use for the animation.  	int frame = Math.Abs (position_.DeltaPixel.X + position_.DeltaPixel.Y) / (16 / usedFramesIndex_.Length);  	frame = (int)MathHelper.Clamp (frame' 0' usedFramesIndex_.Length - 1);  	RenderSprite (eatingFrames_ [usedFramesIndex_ [frame]]' null' boardPosition' position);  } else if (state_ == State.Dying) {  	int timeBetweenFrames = 90;  	// Sound "Death" is 1811 milliseconds long' we have 20 frames to go through.  	//timer_ += gameTime.ElapsedRealTime;  	timer_ += gameTime.ElapsedGameTime;  	int index = (timer_.Seconds * 1000 + timer_.Milliseconds) / timeBetweenFrames;  	if (index > 19) {  		return;  	}  	RenderSprite (dyingFrames_' new Rectangle (26 * index' 0' 26' 26)' boardPosition' position);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Draw,The following statement contains a magic number: if (state_ == State.Normal) {  	// The frame index is taken as a function of how much the pac man is off from a tile' the size of  	// a tile (always 16 pixels)' and how many frames we use for the animation.  	int frame = Math.Abs (position_.DeltaPixel.X + position_.DeltaPixel.Y) / (16 / usedFramesIndex_.Length);  	frame = (int)MathHelper.Clamp (frame' 0' usedFramesIndex_.Length - 1);  	RenderSprite (eatingFrames_ [usedFramesIndex_ [frame]]' null' boardPosition' position);  } else if (state_ == State.Dying) {  	int timeBetweenFrames = 90;  	// Sound "Death" is 1811 milliseconds long' we have 20 frames to go through.  	//timer_ += gameTime.ElapsedRealTime;  	timer_ += gameTime.ElapsedGameTime;  	int index = (timer_.Seconds * 1000 + timer_.Milliseconds) / timeBetweenFrames;  	if (index > 19) {  		return;  	}  	RenderSprite (dyingFrames_' new Rectangle (26 * index' 0' 26' 26)' boardPosition' position);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Draw,The following statement contains a magic number: if (state_ == State.Dying) {  	int timeBetweenFrames = 90;  	// Sound "Death" is 1811 milliseconds long' we have 20 frames to go through.  	//timer_ += gameTime.ElapsedRealTime;  	timer_ += gameTime.ElapsedGameTime;  	int index = (timer_.Seconds * 1000 + timer_.Milliseconds) / timeBetweenFrames;  	if (index > 19) {  		return;  	}  	RenderSprite (dyingFrames_' new Rectangle (26 * index' 0' 26' 26)' boardPosition' position);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Draw,The following statement contains a magic number: if (state_ == State.Dying) {  	int timeBetweenFrames = 90;  	// Sound "Death" is 1811 milliseconds long' we have 20 frames to go through.  	//timer_ += gameTime.ElapsedRealTime;  	timer_ += gameTime.ElapsedGameTime;  	int index = (timer_.Seconds * 1000 + timer_.Milliseconds) / timeBetweenFrames;  	if (index > 19) {  		return;  	}  	RenderSprite (dyingFrames_' new Rectangle (26 * index' 0' 26' 26)' boardPosition' position);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Draw,The following statement contains a magic number: if (state_ == State.Dying) {  	int timeBetweenFrames = 90;  	// Sound "Death" is 1811 milliseconds long' we have 20 frames to go through.  	//timer_ += gameTime.ElapsedRealTime;  	timer_ += gameTime.ElapsedGameTime;  	int index = (timer_.Seconds * 1000 + timer_.Milliseconds) / timeBetweenFrames;  	if (index > 19) {  		return;  	}  	RenderSprite (dyingFrames_' new Rectangle (26 * index' 0' 26' 26)' boardPosition' position);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Draw,The following statement contains a magic number: if (state_ == State.Dying) {  	int timeBetweenFrames = 90;  	// Sound "Death" is 1811 milliseconds long' we have 20 frames to go through.  	//timer_ += gameTime.ElapsedRealTime;  	timer_ += gameTime.ElapsedGameTime;  	int index = (timer_.Seconds * 1000 + timer_.Milliseconds) / timeBetweenFrames;  	if (index > 19) {  		return;  	}  	RenderSprite (dyingFrames_' new Rectangle (26 * index' 0' 26' 26)' boardPosition' position);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Draw,The following statement contains a magic number: if (state_ == State.Dying) {  	int timeBetweenFrames = 90;  	// Sound "Death" is 1811 milliseconds long' we have 20 frames to go through.  	//timer_ += gameTime.ElapsedRealTime;  	timer_ += gameTime.ElapsedGameTime;  	int index = (timer_.Seconds * 1000 + timer_.Milliseconds) / timeBetweenFrames;  	if (index > 19) {  		return;  	}  	RenderSprite (dyingFrames_' new Rectangle (26 * index' 0' 26' 26)' boardPosition' position);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Draw,The following statement contains a magic number: if (state_ == State.Dying) {  	int timeBetweenFrames = 90;  	// Sound "Death" is 1811 milliseconds long' we have 20 frames to go through.  	//timer_ += gameTime.ElapsedRealTime;  	timer_ += gameTime.ElapsedGameTime;  	int index = (timer_.Seconds * 1000 + timer_.Milliseconds) / timeBetweenFrames;  	if (index > 19) {  		return;  	}  	RenderSprite (dyingFrames_' new Rectangle (26 * index' 0' 26' 26)' boardPosition' position);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Draw,The following statement contains a magic number: if (index > 19) {  	return;  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Draw,The following statement contains a magic number: RenderSprite (dyingFrames_' new Rectangle (26 * index' 0' 26' 26)' boardPosition' position);  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Draw,The following statement contains a magic number: RenderSprite (dyingFrames_' new Rectangle (26 * index' 0' 26' 26)' boardPosition' position);  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Draw,The following statement contains a magic number: RenderSprite (dyingFrames_' new Rectangle (26 * index' 0' 26' 26)' boardPosition' position);  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,RenderSprite,The following statement contains a magic number: if (position.X < boardPosition.X) {  	int deltaPixel = (int)(boardPosition.X - position.X);  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + deltaPixel' rect.Y' 26 - deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' deltaPixel' 26);  	var rightPortionPosition = new Vector2 (boardPosition.X + (16 * 28) - deltaPixel' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Next' to the right  else if (position.X > (boardPosition.X + (16 * 28) - 26)) {  	int deltaPixel = (int)((position.X + 26) - (boardPosition.X + (16 * 28)));  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + 26 - deltaPixel' rect.Y' deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' 26 - deltaPixel' 26);  	var rightPortionPosition = new Vector2 (position.X' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Draw normally - in one piece  else {  	spriteBatch_.Draw (spriteSheet' position' rect' Color.White);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,RenderSprite,The following statement contains a magic number: if (position.X < boardPosition.X) {  	int deltaPixel = (int)(boardPosition.X - position.X);  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + deltaPixel' rect.Y' 26 - deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' deltaPixel' 26);  	var rightPortionPosition = new Vector2 (boardPosition.X + (16 * 28) - deltaPixel' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Next' to the right  else if (position.X > (boardPosition.X + (16 * 28) - 26)) {  	int deltaPixel = (int)((position.X + 26) - (boardPosition.X + (16 * 28)));  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + 26 - deltaPixel' rect.Y' deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' 26 - deltaPixel' 26);  	var rightPortionPosition = new Vector2 (position.X' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Draw normally - in one piece  else {  	spriteBatch_.Draw (spriteSheet' position' rect' Color.White);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,RenderSprite,The following statement contains a magic number: if (position.X < boardPosition.X) {  	int deltaPixel = (int)(boardPosition.X - position.X);  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + deltaPixel' rect.Y' 26 - deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' deltaPixel' 26);  	var rightPortionPosition = new Vector2 (boardPosition.X + (16 * 28) - deltaPixel' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Next' to the right  else if (position.X > (boardPosition.X + (16 * 28) - 26)) {  	int deltaPixel = (int)((position.X + 26) - (boardPosition.X + (16 * 28)));  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + 26 - deltaPixel' rect.Y' deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' 26 - deltaPixel' 26);  	var rightPortionPosition = new Vector2 (position.X' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Draw normally - in one piece  else {  	spriteBatch_.Draw (spriteSheet' position' rect' Color.White);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,RenderSprite,The following statement contains a magic number: if (position.X < boardPosition.X) {  	int deltaPixel = (int)(boardPosition.X - position.X);  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + deltaPixel' rect.Y' 26 - deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' deltaPixel' 26);  	var rightPortionPosition = new Vector2 (boardPosition.X + (16 * 28) - deltaPixel' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Next' to the right  else if (position.X > (boardPosition.X + (16 * 28) - 26)) {  	int deltaPixel = (int)((position.X + 26) - (boardPosition.X + (16 * 28)));  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + 26 - deltaPixel' rect.Y' deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' 26 - deltaPixel' 26);  	var rightPortionPosition = new Vector2 (position.X' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Draw normally - in one piece  else {  	spriteBatch_.Draw (spriteSheet' position' rect' Color.White);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,RenderSprite,The following statement contains a magic number: if (position.X < boardPosition.X) {  	int deltaPixel = (int)(boardPosition.X - position.X);  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + deltaPixel' rect.Y' 26 - deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' deltaPixel' 26);  	var rightPortionPosition = new Vector2 (boardPosition.X + (16 * 28) - deltaPixel' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Next' to the right  else if (position.X > (boardPosition.X + (16 * 28) - 26)) {  	int deltaPixel = (int)((position.X + 26) - (boardPosition.X + (16 * 28)));  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + 26 - deltaPixel' rect.Y' deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' 26 - deltaPixel' 26);  	var rightPortionPosition = new Vector2 (position.X' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Draw normally - in one piece  else {  	spriteBatch_.Draw (spriteSheet' position' rect' Color.White);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,RenderSprite,The following statement contains a magic number: if (position.X < boardPosition.X) {  	int deltaPixel = (int)(boardPosition.X - position.X);  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + deltaPixel' rect.Y' 26 - deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' deltaPixel' 26);  	var rightPortionPosition = new Vector2 (boardPosition.X + (16 * 28) - deltaPixel' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Next' to the right  else if (position.X > (boardPosition.X + (16 * 28) - 26)) {  	int deltaPixel = (int)((position.X + 26) - (boardPosition.X + (16 * 28)));  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + 26 - deltaPixel' rect.Y' deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' 26 - deltaPixel' 26);  	var rightPortionPosition = new Vector2 (position.X' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Draw normally - in one piece  else {  	spriteBatch_.Draw (spriteSheet' position' rect' Color.White);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,RenderSprite,The following statement contains a magic number: if (position.X < boardPosition.X) {  	int deltaPixel = (int)(boardPosition.X - position.X);  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + deltaPixel' rect.Y' 26 - deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' deltaPixel' 26);  	var rightPortionPosition = new Vector2 (boardPosition.X + (16 * 28) - deltaPixel' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Next' to the right  else if (position.X > (boardPosition.X + (16 * 28) - 26)) {  	int deltaPixel = (int)((position.X + 26) - (boardPosition.X + (16 * 28)));  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + 26 - deltaPixel' rect.Y' deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' 26 - deltaPixel' 26);  	var rightPortionPosition = new Vector2 (position.X' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Draw normally - in one piece  else {  	spriteBatch_.Draw (spriteSheet' position' rect' Color.White);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,RenderSprite,The following statement contains a magic number: if (position.X < boardPosition.X) {  	int deltaPixel = (int)(boardPosition.X - position.X);  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + deltaPixel' rect.Y' 26 - deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' deltaPixel' 26);  	var rightPortionPosition = new Vector2 (boardPosition.X + (16 * 28) - deltaPixel' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Next' to the right  else if (position.X > (boardPosition.X + (16 * 28) - 26)) {  	int deltaPixel = (int)((position.X + 26) - (boardPosition.X + (16 * 28)));  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + 26 - deltaPixel' rect.Y' deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' 26 - deltaPixel' 26);  	var rightPortionPosition = new Vector2 (position.X' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Draw normally - in one piece  else {  	spriteBatch_.Draw (spriteSheet' position' rect' Color.White);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,RenderSprite,The following statement contains a magic number: if (position.X < boardPosition.X) {  	int deltaPixel = (int)(boardPosition.X - position.X);  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + deltaPixel' rect.Y' 26 - deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' deltaPixel' 26);  	var rightPortionPosition = new Vector2 (boardPosition.X + (16 * 28) - deltaPixel' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Next' to the right  else if (position.X > (boardPosition.X + (16 * 28) - 26)) {  	int deltaPixel = (int)((position.X + 26) - (boardPosition.X + (16 * 28)));  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + 26 - deltaPixel' rect.Y' deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' 26 - deltaPixel' 26);  	var rightPortionPosition = new Vector2 (position.X' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Draw normally - in one piece  else {  	spriteBatch_.Draw (spriteSheet' position' rect' Color.White);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,RenderSprite,The following statement contains a magic number: if (position.X < boardPosition.X) {  	int deltaPixel = (int)(boardPosition.X - position.X);  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + deltaPixel' rect.Y' 26 - deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' deltaPixel' 26);  	var rightPortionPosition = new Vector2 (boardPosition.X + (16 * 28) - deltaPixel' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Next' to the right  else if (position.X > (boardPosition.X + (16 * 28) - 26)) {  	int deltaPixel = (int)((position.X + 26) - (boardPosition.X + (16 * 28)));  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + 26 - deltaPixel' rect.Y' deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' 26 - deltaPixel' 26);  	var rightPortionPosition = new Vector2 (position.X' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Draw normally - in one piece  else {  	spriteBatch_.Draw (spriteSheet' position' rect' Color.White);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,RenderSprite,The following statement contains a magic number: if (position.X < boardPosition.X) {  	int deltaPixel = (int)(boardPosition.X - position.X);  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + deltaPixel' rect.Y' 26 - deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' deltaPixel' 26);  	var rightPortionPosition = new Vector2 (boardPosition.X + (16 * 28) - deltaPixel' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Next' to the right  else if (position.X > (boardPosition.X + (16 * 28) - 26)) {  	int deltaPixel = (int)((position.X + 26) - (boardPosition.X + (16 * 28)));  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + 26 - deltaPixel' rect.Y' deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' 26 - deltaPixel' 26);  	var rightPortionPosition = new Vector2 (position.X' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Draw normally - in one piece  else {  	spriteBatch_.Draw (spriteSheet' position' rect' Color.White);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,RenderSprite,The following statement contains a magic number: if (position.X < boardPosition.X) {  	int deltaPixel = (int)(boardPosition.X - position.X);  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + deltaPixel' rect.Y' 26 - deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' deltaPixel' 26);  	var rightPortionPosition = new Vector2 (boardPosition.X + (16 * 28) - deltaPixel' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Next' to the right  else if (position.X > (boardPosition.X + (16 * 28) - 26)) {  	int deltaPixel = (int)((position.X + 26) - (boardPosition.X + (16 * 28)));  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + 26 - deltaPixel' rect.Y' deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' 26 - deltaPixel' 26);  	var rightPortionPosition = new Vector2 (position.X' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Draw normally - in one piece  else {  	spriteBatch_.Draw (spriteSheet' position' rect' Color.White);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,RenderSprite,The following statement contains a magic number: if (position.X < boardPosition.X) {  	int deltaPixel = (int)(boardPosition.X - position.X);  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + deltaPixel' rect.Y' 26 - deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' deltaPixel' 26);  	var rightPortionPosition = new Vector2 (boardPosition.X + (16 * 28) - deltaPixel' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Next' to the right  else if (position.X > (boardPosition.X + (16 * 28) - 26)) {  	int deltaPixel = (int)((position.X + 26) - (boardPosition.X + (16 * 28)));  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + 26 - deltaPixel' rect.Y' deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' 26 - deltaPixel' 26);  	var rightPortionPosition = new Vector2 (position.X' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Draw normally - in one piece  else {  	spriteBatch_.Draw (spriteSheet' position' rect' Color.White);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,RenderSprite,The following statement contains a magic number: if (position.X < boardPosition.X) {  	int deltaPixel = (int)(boardPosition.X - position.X);  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + deltaPixel' rect.Y' 26 - deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' deltaPixel' 26);  	var rightPortionPosition = new Vector2 (boardPosition.X + (16 * 28) - deltaPixel' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Next' to the right  else if (position.X > (boardPosition.X + (16 * 28) - 26)) {  	int deltaPixel = (int)((position.X + 26) - (boardPosition.X + (16 * 28)));  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + 26 - deltaPixel' rect.Y' deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' 26 - deltaPixel' 26);  	var rightPortionPosition = new Vector2 (position.X' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Draw normally - in one piece  else {  	spriteBatch_.Draw (spriteSheet' position' rect' Color.White);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,RenderSprite,The following statement contains a magic number: if (position.X < boardPosition.X) {  	int deltaPixel = (int)(boardPosition.X - position.X);  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + deltaPixel' rect.Y' 26 - deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' deltaPixel' 26);  	var rightPortionPosition = new Vector2 (boardPosition.X + (16 * 28) - deltaPixel' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Next' to the right  else if (position.X > (boardPosition.X + (16 * 28) - 26)) {  	int deltaPixel = (int)((position.X + 26) - (boardPosition.X + (16 * 28)));  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + 26 - deltaPixel' rect.Y' deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' 26 - deltaPixel' 26);  	var rightPortionPosition = new Vector2 (position.X' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Draw normally - in one piece  else {  	spriteBatch_.Draw (spriteSheet' position' rect' Color.White);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,RenderSprite,The following statement contains a magic number: if (position.X > (boardPosition.X + (16 * 28) - 26)) {  	int deltaPixel = (int)((position.X + 26) - (boardPosition.X + (16 * 28)));  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + 26 - deltaPixel' rect.Y' deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' 26 - deltaPixel' 26);  	var rightPortionPosition = new Vector2 (position.X' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Draw normally - in one piece  else {  	spriteBatch_.Draw (spriteSheet' position' rect' Color.White);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,RenderSprite,The following statement contains a magic number: if (position.X > (boardPosition.X + (16 * 28) - 26)) {  	int deltaPixel = (int)((position.X + 26) - (boardPosition.X + (16 * 28)));  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + 26 - deltaPixel' rect.Y' deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' 26 - deltaPixel' 26);  	var rightPortionPosition = new Vector2 (position.X' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Draw normally - in one piece  else {  	spriteBatch_.Draw (spriteSheet' position' rect' Color.White);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,RenderSprite,The following statement contains a magic number: if (position.X > (boardPosition.X + (16 * 28) - 26)) {  	int deltaPixel = (int)((position.X + 26) - (boardPosition.X + (16 * 28)));  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + 26 - deltaPixel' rect.Y' deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' 26 - deltaPixel' 26);  	var rightPortionPosition = new Vector2 (position.X' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Draw normally - in one piece  else {  	spriteBatch_.Draw (spriteSheet' position' rect' Color.White);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,RenderSprite,The following statement contains a magic number: if (position.X > (boardPosition.X + (16 * 28) - 26)) {  	int deltaPixel = (int)((position.X + 26) - (boardPosition.X + (16 * 28)));  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + 26 - deltaPixel' rect.Y' deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' 26 - deltaPixel' 26);  	var rightPortionPosition = new Vector2 (position.X' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Draw normally - in one piece  else {  	spriteBatch_.Draw (spriteSheet' position' rect' Color.White);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,RenderSprite,The following statement contains a magic number: if (position.X > (boardPosition.X + (16 * 28) - 26)) {  	int deltaPixel = (int)((position.X + 26) - (boardPosition.X + (16 * 28)));  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + 26 - deltaPixel' rect.Y' deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' 26 - deltaPixel' 26);  	var rightPortionPosition = new Vector2 (position.X' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Draw normally - in one piece  else {  	spriteBatch_.Draw (spriteSheet' position' rect' Color.White);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,RenderSprite,The following statement contains a magic number: if (position.X > (boardPosition.X + (16 * 28) - 26)) {  	int deltaPixel = (int)((position.X + 26) - (boardPosition.X + (16 * 28)));  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + 26 - deltaPixel' rect.Y' deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' 26 - deltaPixel' 26);  	var rightPortionPosition = new Vector2 (position.X' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Draw normally - in one piece  else {  	spriteBatch_.Draw (spriteSheet' position' rect' Color.White);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,RenderSprite,The following statement contains a magic number: if (position.X > (boardPosition.X + (16 * 28) - 26)) {  	int deltaPixel = (int)((position.X + 26) - (boardPosition.X + (16 * 28)));  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + 26 - deltaPixel' rect.Y' deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' 26 - deltaPixel' 26);  	var rightPortionPosition = new Vector2 (position.X' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Draw normally - in one piece  else {  	spriteBatch_.Draw (spriteSheet' position' rect' Color.White);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,RenderSprite,The following statement contains a magic number: if (position.X > (boardPosition.X + (16 * 28) - 26)) {  	int deltaPixel = (int)((position.X + 26) - (boardPosition.X + (16 * 28)));  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + 26 - deltaPixel' rect.Y' deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' 26 - deltaPixel' 26);  	var rightPortionPosition = new Vector2 (position.X' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Draw normally - in one piece  else {  	spriteBatch_.Draw (spriteSheet' position' rect' Color.White);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,RenderSprite,The following statement contains a magic number: if (position.X > (boardPosition.X + (16 * 28) - 26)) {  	int deltaPixel = (int)((position.X + 26) - (boardPosition.X + (16 * 28)));  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + 26 - deltaPixel' rect.Y' deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' 26 - deltaPixel' 26);  	var rightPortionPosition = new Vector2 (position.X' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Draw normally - in one piece  else {  	spriteBatch_.Draw (spriteSheet' position' rect' Color.White);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,RenderSprite,The following statement contains a magic number: if (position.X > (boardPosition.X + (16 * 28) - 26)) {  	int deltaPixel = (int)((position.X + 26) - (boardPosition.X + (16 * 28)));  	// Number of pixels off the board  	var leftPortion = new Rectangle (rect.X + 26 - deltaPixel' rect.Y' deltaPixel' 26);  	var leftPortionPosition = new Vector2 (boardPosition.X' position.Y);  	var rightPortion = new Rectangle (rect.X' rect.Y' 26 - deltaPixel' 26);  	var rightPortionPosition = new Vector2 (position.X' position.Y);  	spriteBatch_.Draw (spriteSheet' leftPortionPosition' leftPortion' Color.White);  	spriteBatch_.Draw (spriteSheet' rightPortionPosition' rightPortion' Color.White);  } // Draw normally - in one piece  else {  	spriteBatch_.Draw (spriteSheet' position' rect' Color.White);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Reset,The following statement contains a magic number: usedFramesIndex_ = new int[] {  	0'  	1'  	2  };  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Reset,The following statement contains a magic number: position_ = new Position {  	Tile = new Point (13' 23)'  	DeltaPixel = new Point (8' 0)  };  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Reset,The following statement contains a magic number: position_ = new Position {  	Tile = new Point (13' 23)'  	DeltaPixel = new Point (8' 0)  };  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Reset,The following statement contains a magic number: position_ = new Position {  	Tile = new Point (13' 23)'  	DeltaPixel = new Point (8' 0)  };  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,TryTurn,The following statement contains a magic number: if (position_.DeltaPixel != Point.Zero) {  	if ((direction_ == Direction.Up && input == Keys.Down) || (direction_ == Direction.Down && input == Keys.Up) || (direction_ == Direction.Left && input == Keys.Right) || (direction_ == Direction.Right && input == Keys.Left)) {  		// Turning 180 between two tiles implies destination tile is open'   		// no other validation to be done  		DoTurn (input);  	}  } // Special case : the tunnel.  else if ((input == Keys.Left && position_.Tile.X == 0) || (input == Keys.Right && position_.Tile.X == 27)) {  	DoTurn (input);  } // We're exactly on a tile; this is the "general" case  // Do turn if the destination tile is open  else if ((input == Keys.Up && Grid.TileGrid [position_.Tile.X' position_.Tile.Y - 1].Type == TileTypes.Open) || (input == Keys.Down && Grid.TileGrid [position_.Tile.X' position_.Tile.Y + 1].Type == TileTypes.Open) || (input == Keys.Left && Grid.TileGrid [position_.Tile.X - 1' position_.Tile.Y].Type == TileTypes.Open) || (input == Keys.Right && Grid.TileGrid [position_.Tile.X + 1' position_.Tile.Y].Type == TileTypes.Open)) {  	DoTurn (input);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,TryTurn,The following statement contains a magic number: if ((input == Keys.Left && position_.Tile.X == 0) || (input == Keys.Right && position_.Tile.X == 27)) {  	DoTurn (input);  } // We're exactly on a tile; this is the "general" case  // Do turn if the destination tile is open  else if ((input == Keys.Up && Grid.TileGrid [position_.Tile.X' position_.Tile.Y - 1].Type == TileTypes.Open) || (input == Keys.Down && Grid.TileGrid [position_.Tile.X' position_.Tile.Y + 1].Type == TileTypes.Open) || (input == Keys.Left && Grid.TileGrid [position_.Tile.X - 1' position_.Tile.Y].Type == TileTypes.Open) || (input == Keys.Right && Grid.TileGrid [position_.Tile.X + 1' position_.Tile.Y].Type == TileTypes.Open)) {  	DoTurn (input);  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following statement contains a magic number: switch (newDirection) {  case Keys.Up:  	direction_ = Direction.Up;  	usedFramesIndex_ = new int[] {  		0'  		7'  		8  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.Y += 1;  		position_.DeltaPixel.Y -= 16;  	}  	break;  case Keys.Down:  	direction_ = Direction.Down;  	usedFramesIndex_ = new int[] {  		0'  		3'  		4  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.Y -= 1;  		position_.DeltaPixel.Y += 16;  	}  	break;  case Keys.Left:  	direction_ = Direction.Left;  	usedFramesIndex_ = new int[] {  		0'  		5'  		6  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.X += 1;  		position_.DeltaPixel.X -= 16;  	}  	break;  case Keys.Right:  	direction_ = Direction.Right;  	usedFramesIndex_ = new int[] {  		0'  		1'  		2  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.X -= 1;  		position_.DeltaPixel.X += 16;  	}  	break;  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following statement contains a magic number: switch (newDirection) {  case Keys.Up:  	direction_ = Direction.Up;  	usedFramesIndex_ = new int[] {  		0'  		7'  		8  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.Y += 1;  		position_.DeltaPixel.Y -= 16;  	}  	break;  case Keys.Down:  	direction_ = Direction.Down;  	usedFramesIndex_ = new int[] {  		0'  		3'  		4  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.Y -= 1;  		position_.DeltaPixel.Y += 16;  	}  	break;  case Keys.Left:  	direction_ = Direction.Left;  	usedFramesIndex_ = new int[] {  		0'  		5'  		6  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.X += 1;  		position_.DeltaPixel.X -= 16;  	}  	break;  case Keys.Right:  	direction_ = Direction.Right;  	usedFramesIndex_ = new int[] {  		0'  		1'  		2  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.X -= 1;  		position_.DeltaPixel.X += 16;  	}  	break;  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following statement contains a magic number: switch (newDirection) {  case Keys.Up:  	direction_ = Direction.Up;  	usedFramesIndex_ = new int[] {  		0'  		7'  		8  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.Y += 1;  		position_.DeltaPixel.Y -= 16;  	}  	break;  case Keys.Down:  	direction_ = Direction.Down;  	usedFramesIndex_ = new int[] {  		0'  		3'  		4  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.Y -= 1;  		position_.DeltaPixel.Y += 16;  	}  	break;  case Keys.Left:  	direction_ = Direction.Left;  	usedFramesIndex_ = new int[] {  		0'  		5'  		6  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.X += 1;  		position_.DeltaPixel.X -= 16;  	}  	break;  case Keys.Right:  	direction_ = Direction.Right;  	usedFramesIndex_ = new int[] {  		0'  		1'  		2  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.X -= 1;  		position_.DeltaPixel.X += 16;  	}  	break;  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following statement contains a magic number: switch (newDirection) {  case Keys.Up:  	direction_ = Direction.Up;  	usedFramesIndex_ = new int[] {  		0'  		7'  		8  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.Y += 1;  		position_.DeltaPixel.Y -= 16;  	}  	break;  case Keys.Down:  	direction_ = Direction.Down;  	usedFramesIndex_ = new int[] {  		0'  		3'  		4  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.Y -= 1;  		position_.DeltaPixel.Y += 16;  	}  	break;  case Keys.Left:  	direction_ = Direction.Left;  	usedFramesIndex_ = new int[] {  		0'  		5'  		6  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.X += 1;  		position_.DeltaPixel.X -= 16;  	}  	break;  case Keys.Right:  	direction_ = Direction.Right;  	usedFramesIndex_ = new int[] {  		0'  		1'  		2  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.X -= 1;  		position_.DeltaPixel.X += 16;  	}  	break;  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following statement contains a magic number: switch (newDirection) {  case Keys.Up:  	direction_ = Direction.Up;  	usedFramesIndex_ = new int[] {  		0'  		7'  		8  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.Y += 1;  		position_.DeltaPixel.Y -= 16;  	}  	break;  case Keys.Down:  	direction_ = Direction.Down;  	usedFramesIndex_ = new int[] {  		0'  		3'  		4  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.Y -= 1;  		position_.DeltaPixel.Y += 16;  	}  	break;  case Keys.Left:  	direction_ = Direction.Left;  	usedFramesIndex_ = new int[] {  		0'  		5'  		6  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.X += 1;  		position_.DeltaPixel.X -= 16;  	}  	break;  case Keys.Right:  	direction_ = Direction.Right;  	usedFramesIndex_ = new int[] {  		0'  		1'  		2  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.X -= 1;  		position_.DeltaPixel.X += 16;  	}  	break;  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following statement contains a magic number: switch (newDirection) {  case Keys.Up:  	direction_ = Direction.Up;  	usedFramesIndex_ = new int[] {  		0'  		7'  		8  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.Y += 1;  		position_.DeltaPixel.Y -= 16;  	}  	break;  case Keys.Down:  	direction_ = Direction.Down;  	usedFramesIndex_ = new int[] {  		0'  		3'  		4  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.Y -= 1;  		position_.DeltaPixel.Y += 16;  	}  	break;  case Keys.Left:  	direction_ = Direction.Left;  	usedFramesIndex_ = new int[] {  		0'  		5'  		6  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.X += 1;  		position_.DeltaPixel.X -= 16;  	}  	break;  case Keys.Right:  	direction_ = Direction.Right;  	usedFramesIndex_ = new int[] {  		0'  		1'  		2  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.X -= 1;  		position_.DeltaPixel.X += 16;  	}  	break;  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following statement contains a magic number: switch (newDirection) {  case Keys.Up:  	direction_ = Direction.Up;  	usedFramesIndex_ = new int[] {  		0'  		7'  		8  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.Y += 1;  		position_.DeltaPixel.Y -= 16;  	}  	break;  case Keys.Down:  	direction_ = Direction.Down;  	usedFramesIndex_ = new int[] {  		0'  		3'  		4  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.Y -= 1;  		position_.DeltaPixel.Y += 16;  	}  	break;  case Keys.Left:  	direction_ = Direction.Left;  	usedFramesIndex_ = new int[] {  		0'  		5'  		6  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.X += 1;  		position_.DeltaPixel.X -= 16;  	}  	break;  case Keys.Right:  	direction_ = Direction.Right;  	usedFramesIndex_ = new int[] {  		0'  		1'  		2  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.X -= 1;  		position_.DeltaPixel.X += 16;  	}  	break;  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following statement contains a magic number: switch (newDirection) {  case Keys.Up:  	direction_ = Direction.Up;  	usedFramesIndex_ = new int[] {  		0'  		7'  		8  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.Y += 1;  		position_.DeltaPixel.Y -= 16;  	}  	break;  case Keys.Down:  	direction_ = Direction.Down;  	usedFramesIndex_ = new int[] {  		0'  		3'  		4  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.Y -= 1;  		position_.DeltaPixel.Y += 16;  	}  	break;  case Keys.Left:  	direction_ = Direction.Left;  	usedFramesIndex_ = new int[] {  		0'  		5'  		6  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.X += 1;  		position_.DeltaPixel.X -= 16;  	}  	break;  case Keys.Right:  	direction_ = Direction.Right;  	usedFramesIndex_ = new int[] {  		0'  		1'  		2  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.X -= 1;  		position_.DeltaPixel.X += 16;  	}  	break;  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following statement contains a magic number: switch (newDirection) {  case Keys.Up:  	direction_ = Direction.Up;  	usedFramesIndex_ = new int[] {  		0'  		7'  		8  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.Y += 1;  		position_.DeltaPixel.Y -= 16;  	}  	break;  case Keys.Down:  	direction_ = Direction.Down;  	usedFramesIndex_ = new int[] {  		0'  		3'  		4  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.Y -= 1;  		position_.DeltaPixel.Y += 16;  	}  	break;  case Keys.Left:  	direction_ = Direction.Left;  	usedFramesIndex_ = new int[] {  		0'  		5'  		6  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.X += 1;  		position_.DeltaPixel.X -= 16;  	}  	break;  case Keys.Right:  	direction_ = Direction.Right;  	usedFramesIndex_ = new int[] {  		0'  		1'  		2  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.X -= 1;  		position_.DeltaPixel.X += 16;  	}  	break;  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following statement contains a magic number: switch (newDirection) {  case Keys.Up:  	direction_ = Direction.Up;  	usedFramesIndex_ = new int[] {  		0'  		7'  		8  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.Y += 1;  		position_.DeltaPixel.Y -= 16;  	}  	break;  case Keys.Down:  	direction_ = Direction.Down;  	usedFramesIndex_ = new int[] {  		0'  		3'  		4  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.Y -= 1;  		position_.DeltaPixel.Y += 16;  	}  	break;  case Keys.Left:  	direction_ = Direction.Left;  	usedFramesIndex_ = new int[] {  		0'  		5'  		6  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.X += 1;  		position_.DeltaPixel.X -= 16;  	}  	break;  case Keys.Right:  	direction_ = Direction.Right;  	usedFramesIndex_ = new int[] {  		0'  		1'  		2  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.X -= 1;  		position_.DeltaPixel.X += 16;  	}  	break;  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following statement contains a magic number: switch (newDirection) {  case Keys.Up:  	direction_ = Direction.Up;  	usedFramesIndex_ = new int[] {  		0'  		7'  		8  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.Y += 1;  		position_.DeltaPixel.Y -= 16;  	}  	break;  case Keys.Down:  	direction_ = Direction.Down;  	usedFramesIndex_ = new int[] {  		0'  		3'  		4  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.Y -= 1;  		position_.DeltaPixel.Y += 16;  	}  	break;  case Keys.Left:  	direction_ = Direction.Left;  	usedFramesIndex_ = new int[] {  		0'  		5'  		6  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.X += 1;  		position_.DeltaPixel.X -= 16;  	}  	break;  case Keys.Right:  	direction_ = Direction.Right;  	usedFramesIndex_ = new int[] {  		0'  		1'  		2  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.X -= 1;  		position_.DeltaPixel.X += 16;  	}  	break;  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following statement contains a magic number: usedFramesIndex_ = new int[] {  	0'  	7'  	8  };  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following statement contains a magic number: usedFramesIndex_ = new int[] {  	0'  	7'  	8  };  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following statement contains a magic number: if (position_.DeltaPixel != Point.Zero) {  	position_.Tile.Y += 1;  	position_.DeltaPixel.Y -= 16;  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following statement contains a magic number: position_.DeltaPixel.Y -= 16;  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following statement contains a magic number: usedFramesIndex_ = new int[] {  	0'  	3'  	4  };  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following statement contains a magic number: usedFramesIndex_ = new int[] {  	0'  	3'  	4  };  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following statement contains a magic number: if (position_.DeltaPixel != Point.Zero) {  	position_.Tile.Y -= 1;  	position_.DeltaPixel.Y += 16;  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following statement contains a magic number: position_.DeltaPixel.Y += 16;  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following statement contains a magic number: usedFramesIndex_ = new int[] {  	0'  	5'  	6  };  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following statement contains a magic number: usedFramesIndex_ = new int[] {  	0'  	5'  	6  };  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following statement contains a magic number: if (position_.DeltaPixel != Point.Zero) {  	position_.Tile.X += 1;  	position_.DeltaPixel.X -= 16;  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following statement contains a magic number: position_.DeltaPixel.X -= 16;  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following statement contains a magic number: usedFramesIndex_ = new int[] {  	0'  	1'  	2  };  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following statement contains a magic number: if (position_.DeltaPixel != Point.Zero) {  	position_.Tile.X -= 1;  	position_.DeltaPixel.X += 16;  }  
Magic Number,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following statement contains a magic number: position_.DeltaPixel.X += 16;  
Magic Number,XNAPacMan,XNAPacMan,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\XNAPacMan.cs,XNAPacMan,The following statement contains a magic number: graphics_.PreferredBackBufferHeight = 720;  
Magic Number,XNAPacMan,XNAPacMan,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\XNAPacMan.cs,XNAPacMan,The following statement contains a magic number: graphics_.PreferredBackBufferWidth = 640;  
Missing Default,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following switch statement is missing a default case: switch (State) {  case GhostState.Home:  	// Ghost exit the home state for the scatter state when they get to the row  	// above the home  	if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {  		// Select inital direction based on scatter tiles  		if (Constants.scatterTiles (identity_) [0].X < 13) {  			direction_ = Direction.Left;  		} else {  			direction_ = Direction.Right;  		}  		if (scatterModesLeft_ > 0) {  			State = GhostState.Scatter;  		} else {  			State = GhostState.Attack;  		}  		return;  	} // Ghosts move up when they are aligned with the entrance  	else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {  		direction_ = Direction.Up;  	} // When on one side' move towards middle when on the bottom and time's up  	// If time's not up' keep bouncing up and down  	else if ((position_.DeltaPixel.Y == 8) && ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) || (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {  		if (position_.Tile.Y == 14) {  			initialJumps_--;  			if (initialJumps_ == 0) {  				if (position_.Tile.X == 11) {  					direction_ = Direction.Right;  				} else {  					direction_ = Direction.Left;  				}  			} else {  				direction_ = Direction.Up;  			}  		} else if (position_.Tile.Y == 13) {  			direction_ = Direction.Down;  		}  	}  	break;  case GhostState.Scatter:  	// Attempt to reverse direction upon entering this state  	if (previousState_ == GhostState.Attack) {  		scatterModesLeft_--;  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	}  	AIScatter ();  	int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (timeInScatterMode)) {  		State = GhostState.Attack;  	}  	break;  case GhostState.Dead:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIDead ();  	}  	if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {  		if (position_.Tile.Y == 14) {  			State = GhostState.Home;  		}  	}  	break;  case GhostState.Attack:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		AIAttack ();  	}  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (20)) {  		State = GhostState.Scatter;  	}  	break;  case GhostState.Blue:  	// Attempt to reverse direction upon entering this state  	if (previousState_ != GhostState.Blue) {  		if (NextTile (OppositeDirection (direction_)).IsOpen) {  			direction_ = OppositeDirection (direction_);  		}  	} else {  		// TODO : make special blue AI  		AIAttack ();  	}  	// When blue time is over' revert to attack mode.  	if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds (Constants.BlueTime ())) {  		State = GhostState.Attack;  	}  	break;  }  
Missing Default,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Move,The following switch statement is missing a default case: switch (direction_) {  case Direction.Up:  	position_.DeltaPixel.Y--;  	if (position_.DeltaPixel.Y < 0) {  		position_.DeltaPixel.Y = 15;  		position_.Tile.Y--;  	}  	break;  case Direction.Down:  	position_.DeltaPixel.Y++;  	if (position_.DeltaPixel.Y > 15) {  		position_.DeltaPixel.Y = 0;  		position_.Tile.Y++;  	}  	break;  case Direction.Left:  	position_.DeltaPixel.X--;  	if (position_.DeltaPixel.X < 0) {  		position_.DeltaPixel.X = 15;  		position_.Tile.X--;  		// Special case : the tunnel  		if (position_.Tile.X < 0) {  			position_.Tile.X = Grid.Width - 1;  		}  	}  	break;  case Direction.Right:  	position_.DeltaPixel.X++;  	if (position_.DeltaPixel.X > 15) {  		position_.DeltaPixel.X = 0;  		position_.Tile.X++;  		// Special case : the tunnel  		if (position_.Tile.X > Grid.Width - 1) {  			position_.Tile.X = 0;  		}  	}  	break;  }  
Missing Default,XNAPacMan,Ghost,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following switch statement is missing a default case: switch (direction_) {  case Direction.Up:  	eyesBasePosition.Y -= 2;  	eyesCenterPosition.X = eyesBasePosition.X + 2;  	eyesCenterPosition.Y = eyesBasePosition.Y;  	break;  case Direction.Down:  	eyesBasePosition.Y += 2;  	eyesCenterPosition.X = eyesBasePosition.X + 2;  	eyesCenterPosition.Y = eyesBasePosition.Y + 6;  	break;  case Direction.Left:  	eyesBasePosition.X -= 2;  	eyesCenterPosition.X = eyesBasePosition.X;  	eyesCenterPosition.Y = eyesBasePosition.Y + 3;  	break;  case Direction.Right:  	eyesBasePosition.X += 2;  	eyesCenterPosition.X = eyesBasePosition.X + 4;  	eyesCenterPosition.Y = eyesBasePosition.Y + 3;  	break;  }  
Missing Default,XNAPacMan,Player,F:\newReposMay17\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following switch statement is missing a default case: switch (newDirection) {  case Keys.Up:  	direction_ = Direction.Up;  	usedFramesIndex_ = new int[] {  		0'  		7'  		8  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.Y += 1;  		position_.DeltaPixel.Y -= 16;  	}  	break;  case Keys.Down:  	direction_ = Direction.Down;  	usedFramesIndex_ = new int[] {  		0'  		3'  		4  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.Y -= 1;  		position_.DeltaPixel.Y += 16;  	}  	break;  case Keys.Left:  	direction_ = Direction.Left;  	usedFramesIndex_ = new int[] {  		0'  		5'  		6  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.X += 1;  		position_.DeltaPixel.X -= 16;  	}  	break;  case Keys.Right:  	direction_ = Direction.Right;  	usedFramesIndex_ = new int[] {  		0'  		1'  		2  	};  	if (position_.DeltaPixel != Point.Zero) {  		position_.Tile.X -= 1;  		position_.DeltaPixel.X += 16;  	}  	break;  }  
