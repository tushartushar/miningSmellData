Implementation smell,Namespace,Class,File,Method,Description
Long Method,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The method has 153 lines of code.
Long Method,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The method has 114 lines of code.
Complex Method,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,Cyclomatic complexity of the method is 21
Complex Method,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,Cyclomatic complexity of the method is 12
Complex Method,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,Cyclomatic complexity of the method is 28
Complex Method,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Move,Cyclomatic complexity of the method is 11
Complex Method,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,FindDirection,Cyclomatic complexity of the method is 9
Complex Method,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,NextTile,Cyclomatic complexity of the method is 9
Complex Method,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,Cyclomatic complexity of the method is 8
Complex Method,XNAPacMan,Grid,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,Cyclomatic complexity of the method is 12
Complex Method,XNAPacMan,Player,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoMove,Cyclomatic complexity of the method is 13
Complex Method,XNAPacMan,Player,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,Cyclomatic complexity of the method is 8
Long Parameter List,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,RenderSprite,The method has 5 parameters. Parameters: spriteSheet' rectangle' boardPosition' position' color
Long Statement,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The length of the statement  "                spriteBatch_.Draw(((DateTime.Now.Second * 1000 + DateTime.Now.Millisecond) / 350) % 2 == 0 ? board_ : boardFlash_' boardPosition' Color.White); " is 143.
Long Statement,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The length of the statement  "                spriteBatch_.Draw(xlife_' new Vector2(boardPosition.X + 10 + (20 * i)' board_.Height + boardPosition.Y + 10)' Color.White); " is 123.
Long Statement,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The length of the statement  "            spriteBatch_.DrawString(scoreFont_' Score.ToString()' new Vector2(boardPosition.X + 30' boardPosition.Y - 30)' Color.White); " is 124.
Long Statement,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The length of the statement  "            spriteBatch_.DrawString(scoreFont_' "LEVEL"' new Vector2(boardPosition.X + board_.Width - 80' boardPosition.Y - 50)' Color.White); " is 130.
Long Statement,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The length of the statement  "            spriteBatch_.DrawString(scoreFont_' Constants.Level.ToString()' new Vector2(boardPosition.X + board_.Width - 80' boardPosition.Y - 30)' Color.White); " is 149.
Long Statement,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The length of the statement  "                spriteBatch_.Draw(bonus_[Constants.BonusSprite()]' new Vector2(boardPosition.X + (13 * 16) + 2' boardPosition.Y + (17 * 16) - 8)' Color.White); " is 143.
Long Statement,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The length of the statement  "                    spriteBatch_.Draw(bonus_[kvp.Key]' new Vector2(boardPosition.X + 10 + (22 * (k + i))' board_.Height + boardPosition.Y + 22)' Color.White); " is 138.
Long Statement,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The length of the statement  "                spriteBatch_.DrawString(scoreEventFont_' se.Score.ToString()' new Vector2(boardPosition.X + (se.Position.Tile.X * 16) + se.Position.DeltaPixel.X + 4' " is 149.
Long Statement,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The length of the statement  "                spriteBatch_.DrawString(scoreFont_' "GET READY!"' new Vector2(boardPosition.X + (board_.Width / 2) - 58' boardPosition.Y + 273)' Color.Yellow); " is 143.
Long Statement,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AttackAIInky,The length of the statement  "            Vector2 line = new Vector2(blinky_.Position.Tile.X - nextNextTile.ToPoint.X' blinky_.Position.Tile.Y - nextNextTile.ToPoint.Y); " is 127.
Long Statement,XNAPacMan,HighScores,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\HighScores.cs,Draw,The length of the statement  "            Vector2 position = new Vector2(graphics_.PreferredBackBufferWidth / 2 - 150' graphics_.PreferredBackBufferHeight / 2 - 200); " is 124.
Long Statement,XNAPacMan,HighScores,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\HighScores.cs,Draw,The length of the statement  "                spriteBatch_.DrawString(scoreFont_' (i + 1).ToString() + "."' new Vector2(position.X' position.Y + (30 * i))' Color.White); " is 123.
Long Statement,XNAPacMan,Player,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,TryMove,The length of the statement  "            else if ((direction_ == Direction.Up && Grid.TileGrid[position_.Tile.X' position_.Tile.Y - 1].Type == TileTypes.Open) || " is 120.
Complex Conditional,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The conditional expression  "bonusPresent_ && player_.Position.Tile.Y == 17 &&                  ((player_.Position.Tile.X == 13 && player_.Position.DeltaPixel.X == 8) ||                    (player_.Position.Tile.X == 14 && player_.Position.DeltaPixel.X == -8))"  is complex.
Complex Conditional,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The conditional expression  "(Grid.NumCrumps == 180 || Grid.NumCrumps == 80) && bonusSpawned_ < 2 &&                  ! (player_.Position.Tile.Y == 17 &&                      ((player_.Position.Tile.X == 13 && player_.Position.DeltaPixel.X == 8) ||                      (player_.Position.Tile.X == 14 && player_.Position.DeltaPixel.X == -8)))"  is complex.
Complex Conditional,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The conditional expression  "(position_.DeltaPixel.Y == 8) &&                              ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) ||                               (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))"  is complex.
Complex Conditional,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The conditional expression  "(initialState != previousState_) ||                  (Grid.NumCrumps == 199 && previousNumCrumps_ == 200) ||                  (Grid.NumCrumps == 19 && previousNumCrumps_ == 20)"  is complex.
Complex Conditional,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,UpdateSpeed,The conditional expression  "position_.Tile.Y == 14 &&                    ((0 <= position_.Tile.X && position_.Tile.X <= 5) ||                      (22 <= position_.Tile.X && position_.Tile.X <= 27))"  is complex.
Complex Conditional,XNAPacMan,Player,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,TryMove,The conditional expression  "(position_.Tile == new Point(0' 14) && direction_ == Direction.Left) ||                       (position_.Tile == new Point(27' 14) && direction_ == Direction.Right)"  is complex.
Complex Conditional,XNAPacMan,Player,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,TryMove,The conditional expression  "(direction_ == Direction.Up && Grid.TileGrid[position_.Tile.X' position_.Tile.Y - 1].Type == TileTypes.Open) ||                        (direction_ == Direction.Down && Grid.TileGrid[position_.Tile.X' position_.Tile.Y + 1].Type == TileTypes.Open) ||                        (direction_ == Direction.Left && Grid.TileGrid[position_.Tile.X - 1' position_.Tile.Y].Type == TileTypes.Open) ||                        (direction_ == Direction.Right && Grid.TileGrid[position_.Tile.X + 1' position_.Tile.Y].Type == TileTypes.Open)"  is complex.
Complex Conditional,XNAPacMan,Player,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,TryTurn,The conditional expression  "(direction_ == Direction.Up && input == Keys.Down) ||                      (direction_ == Direction.Down && input == Keys.Up) ||                      (direction_ == Direction.Left && input == Keys.Right) ||                      (direction_ == Direction.Right && input == Keys.Left)"  is complex.
Complex Conditional,XNAPacMan,Player,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,TryTurn,The conditional expression  "(input == Keys.Left && position_.Tile.X == 0) ||                        (input == Keys.Right && position_.Tile.X == 27)"  is complex.
Complex Conditional,XNAPacMan,Player,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,TryTurn,The conditional expression  "(input == Keys.Up && Grid.TileGrid[position_.Tile.X' position_.Tile.Y - 1].Type == TileTypes.Open) ||                        (input == Keys.Down && Grid.TileGrid[position_.Tile.X' position_.Tile.Y + 1].Type == TileTypes.Open) ||                        (input == Keys.Left && Grid.TileGrid[position_.Tile.X - 1' position_.Tile.Y].Type == TileTypes.Open) ||                        (input == Keys.Right && Grid.TileGrid[position_.Tile.X + 1' position_.Tile.Y].Type == TileTypes.Open)"  is complex.
Magic Number,XNAPacMan,Constants,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,InitialJumps,The following statement contains a magic number: switch (ghost) {                      case Ghosts.Inky:                          return (int)MathHelper.Clamp((20 - Level) / 2' 0' 10);                      case Ghosts.Clyde:                          return InitialJumps(Ghosts.Inky' true) + 2;                      default:                          return 0;                  }
Magic Number,XNAPacMan,Constants,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,InitialJumps,The following statement contains a magic number: switch (ghost) {                      case Ghosts.Inky:                          return (int)MathHelper.Clamp((20 - Level) / 2' 0' 10);                      case Ghosts.Clyde:                          return InitialJumps(Ghosts.Inky' true) + 2;                      default:                          return 0;                  }
Magic Number,XNAPacMan,Constants,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,InitialJumps,The following statement contains a magic number: switch (ghost) {                      case Ghosts.Inky:                          return (int)MathHelper.Clamp((20 - Level) / 2' 0' 10);                      case Ghosts.Clyde:                          return InitialJumps(Ghosts.Inky' true) + 2;                      default:                          return 0;                  }
Magic Number,XNAPacMan,Constants,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,InitialJumps,The following statement contains a magic number: switch (ghost) {                      case Ghosts.Inky:                          return (int)MathHelper.Clamp((20 - Level) / 2' 0' 10);                      case Ghosts.Clyde:                          return InitialJumps(Ghosts.Inky' true) + 2;                      default:                          return 0;                  }
Magic Number,XNAPacMan,Constants,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,CruiseElroyTimer,The following statement contains a magic number: return cruiseElroyTimers_[9];
Magic Number,XNAPacMan,Constants,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,CruiseElroyTimer,The following statement contains a magic number: Level >= 10
Magic Number,XNAPacMan,Constants,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,BlueTime,The following statement contains a magic number: return Level > blueTimes_.Length - 2 ? 0 : blueTimes_[Level - 1];
Magic Number,XNAPacMan,Constants,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,BonusScores,The following statement contains a magic number: return Level > bonusScores_.Length - 2 ? 5000 : bonusScores_[Level - 1];
Magic Number,XNAPacMan,Constants,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,BonusScores,The following statement contains a magic number: return Level > bonusScores_.Length - 2 ? 5000 : bonusScores_[Level - 1];
Magic Number,XNAPacMan,Constants,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,BonusSprite,The following statement contains a magic number: return Level > bonusSprites_.Length - 2 ? "Key" : bonusSprites_[Level - 1];
Magic Number,XNAPacMan,Constants,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,PacManSpeed,The following statement contains a magic number: return pacManSpeed_[4];
Magic Number,XNAPacMan,Constants,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,PacManSpeed,The following statement contains a magic number: 5 <= Level && Level <= 20
Magic Number,XNAPacMan,Constants,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,PacManSpeed,The following statement contains a magic number: 5 <= Level && Level <= 20
Magic Number,XNAPacMan,Constants,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,GhostSpeed,The following statement contains a magic number: return Level > 4 ? 11 : ghostSpeed_[Level - 1];
Magic Number,XNAPacMan,Constants,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Constants.cs,GhostSpeed,The following statement contains a magic number: return Level > 4 ? 11 : ghostSpeed_[Level - 1];
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Initialize,The following statement contains a magic number: bonus_ = new Dictionary<string' Texture2D>(9);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Initialize,The following statement contains a magic number: scoreEvents_ = new List<ScoreEvent>(5);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Initialize,The following statement contains a magic number: xlives_ = 2;
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Initialize,The following statement contains a magic number: ghosts_[2].SetBlinky(ghosts_[0]);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Initialize,The following statement contains a magic number: LockTimer = TimeSpan.FromMilliseconds(4500);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: scoreEvents_.RemoveAll(i => DateTime.Now - i.When > TimeSpan.FromSeconds(5));
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: LockTimer = TimeSpan.FromSeconds(2);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: Constants.Level < 21
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: Score += 10;
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: Score += 40;
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: LockTimer = TimeSpan.FromSeconds(2);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: LockTimer = TimeSpan.FromSeconds(1.5);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: bonusPresent_ && player_.Position.Tile.Y == 17 &&                  ((player_.Position.Tile.X == 13 && player_.Position.DeltaPixel.X == 8) ||                    (player_.Position.Tile.X == 14 && player_.Position.DeltaPixel.X == -8))
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: bonusPresent_ && player_.Position.Tile.Y == 17 &&                  ((player_.Position.Tile.X == 13 && player_.Position.DeltaPixel.X == 8) ||                    (player_.Position.Tile.X == 14 && player_.Position.DeltaPixel.X == -8))
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: bonusPresent_ && player_.Position.Tile.Y == 17 &&                  ((player_.Position.Tile.X == 13 && player_.Position.DeltaPixel.X == 8) ||                    (player_.Position.Tile.X == 14 && player_.Position.DeltaPixel.X == -8))
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: bonusPresent_ && player_.Position.Tile.Y == 17 &&                  ((player_.Position.Tile.X == 13 && player_.Position.DeltaPixel.X == 8) ||                    (player_.Position.Tile.X == 14 && player_.Position.DeltaPixel.X == -8))
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: bonusPresent_ && player_.Position.Tile.Y == 17 &&                  ((player_.Position.Tile.X == 13 && player_.Position.DeltaPixel.X == 8) ||                    (player_.Position.Tile.X == 14 && player_.Position.DeltaPixel.X == -8))
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: bonusPresent_ && ((DateTime.Now - bonusSpawnedTime_) > TimeSpan.FromSeconds(10))
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: Rectangle playerArea = new Rectangle((player_.Position.Tile.X * 16) + player_.Position.DeltaPixel.X'                                                       (player_.Position.Tile.Y * 16) + player_.Position.DeltaPixel.Y'                                                        26'                                                        26);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: Rectangle playerArea = new Rectangle((player_.Position.Tile.X * 16) + player_.Position.DeltaPixel.X'                                                       (player_.Position.Tile.Y * 16) + player_.Position.DeltaPixel.Y'                                                        26'                                                        26);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: Rectangle playerArea = new Rectangle((player_.Position.Tile.X * 16) + player_.Position.DeltaPixel.X'                                                       (player_.Position.Tile.Y * 16) + player_.Position.DeltaPixel.Y'                                                        26'                                                        26);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: Rectangle playerArea = new Rectangle((player_.Position.Tile.X * 16) + player_.Position.DeltaPixel.X'                                                       (player_.Position.Tile.Y * 16) + player_.Position.DeltaPixel.Y'                                                        26'                                                        26);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: Rectangle ghostArea = new Rectangle((ghost.Position.Tile.X * 16) + ghost.Position.DeltaPixel.X'                                                      (ghost.Position.Tile.Y * 16) + ghost.Position.DeltaPixel.Y'                                                      22'                                                      22);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: Rectangle ghostArea = new Rectangle((ghost.Position.Tile.X * 16) + ghost.Position.DeltaPixel.X'                                                      (ghost.Position.Tile.Y * 16) + ghost.Position.DeltaPixel.Y'                                                      22'                                                      22);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: Rectangle ghostArea = new Rectangle((ghost.Position.Tile.X * 16) + ghost.Position.DeltaPixel.X'                                                      (ghost.Position.Tile.Y * 16) + ghost.Position.DeltaPixel.Y'                                                      22'                                                      22);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: Rectangle ghostArea = new Rectangle((ghost.Position.Tile.X * 16) + ghost.Position.DeltaPixel.X'                                                      (ghost.Position.Tile.Y * 16) + ghost.Position.DeltaPixel.Y'                                                      22'                                                      22);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: int bonus = (int)(100 * Math.Pow(2' eatenGhosts_));
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: int bonus = (int)(100 * Math.Pow(2' eatenGhosts_));
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: LockTimer = TimeSpan.FromMilliseconds(900);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: (Grid.NumCrumps == 180 || Grid.NumCrumps == 80) && bonusSpawned_ < 2 &&                  ! (player_.Position.Tile.Y == 17 &&                      ((player_.Position.Tile.X == 13 && player_.Position.DeltaPixel.X == 8) ||                      (player_.Position.Tile.X == 14 && player_.Position.DeltaPixel.X == -8)))
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: (Grid.NumCrumps == 180 || Grid.NumCrumps == 80) && bonusSpawned_ < 2 &&                  ! (player_.Position.Tile.Y == 17 &&                      ((player_.Position.Tile.X == 13 && player_.Position.DeltaPixel.X == 8) ||                      (player_.Position.Tile.X == 14 && player_.Position.DeltaPixel.X == -8)))
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: (Grid.NumCrumps == 180 || Grid.NumCrumps == 80) && bonusSpawned_ < 2 &&                  ! (player_.Position.Tile.Y == 17 &&                      ((player_.Position.Tile.X == 13 && player_.Position.DeltaPixel.X == 8) ||                      (player_.Position.Tile.X == 14 && player_.Position.DeltaPixel.X == -8)))
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: (Grid.NumCrumps == 180 || Grid.NumCrumps == 80) && bonusSpawned_ < 2 &&                  ! (player_.Position.Tile.Y == 17 &&                      ((player_.Position.Tile.X == 13 && player_.Position.DeltaPixel.X == 8) ||                      (player_.Position.Tile.X == 14 && player_.Position.DeltaPixel.X == -8)))
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: (Grid.NumCrumps == 180 || Grid.NumCrumps == 80) && bonusSpawned_ < 2 &&                  ! (player_.Position.Tile.Y == 17 &&                      ((player_.Position.Tile.X == 13 && player_.Position.DeltaPixel.X == 8) ||                      (player_.Position.Tile.X == 14 && player_.Position.DeltaPixel.X == -8)))
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: (Grid.NumCrumps == 180 || Grid.NumCrumps == 80) && bonusSpawned_ < 2 &&                  ! (player_.Position.Tile.Y == 17 &&                      ((player_.Position.Tile.X == 13 && player_.Position.DeltaPixel.X == 8) ||                      (player_.Position.Tile.X == 14 && player_.Position.DeltaPixel.X == -8)))
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: (Grid.NumCrumps == 180 || Grid.NumCrumps == 80) && bonusSpawned_ < 2 &&                  ! (player_.Position.Tile.Y == 17 &&                      ((player_.Position.Tile.X == 13 && player_.Position.DeltaPixel.X == 8) ||                      (player_.Position.Tile.X == 14 && player_.Position.DeltaPixel.X == -8)))
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Update,The following statement contains a magic number: (Grid.NumCrumps == 180 || Grid.NumCrumps == 80) && bonusSpawned_ < 2 &&                  ! (player_.Position.Tile.Y == 17 &&                      ((player_.Position.Tile.X == 13 && player_.Position.DeltaPixel.X == 8) ||                      (player_.Position.Tile.X == 14 && player_.Position.DeltaPixel.X == -8)))
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,KillPacMan,The following statement contains a magic number: LockTimer = TimeSpan.FromMilliseconds(1811);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: Vector2 boardPosition = new Vector2(                  (graphics_.PreferredBackBufferWidth / 2) - (board_.Width / 2)'                  (graphics_.PreferredBackBufferHeight / 2) - (board_.Height / 2)                  );
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: Vector2 boardPosition = new Vector2(                  (graphics_.PreferredBackBufferWidth / 2) - (board_.Width / 2)'                  (graphics_.PreferredBackBufferHeight / 2) - (board_.Height / 2)                  );
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: Vector2 boardPosition = new Vector2(                  (graphics_.PreferredBackBufferWidth / 2) - (board_.Width / 2)'                  (graphics_.PreferredBackBufferHeight / 2) - (board_.Height / 2)                  );
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: Vector2 boardPosition = new Vector2(                  (graphics_.PreferredBackBufferWidth / 2) - (board_.Width / 2)'                  (graphics_.PreferredBackBufferHeight / 2) - (board_.Height / 2)                  );
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw(((DateTime.Now.Second * 1000 + DateTime.Now.Millisecond) / 350) % 2 == 0 ? board_ : boardFlash_' boardPosition' Color.White);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw(((DateTime.Now.Second * 1000 + DateTime.Now.Millisecond) / 350) % 2 == 0 ? board_ : boardFlash_' boardPosition' Color.White);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw(((DateTime.Now.Second * 1000 + DateTime.Now.Millisecond) / 350) % 2 == 0 ? board_ : boardFlash_' boardPosition' Color.White);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw(ppill_' new Vector2(                              boardPosition.X + 3 + (i * 16)'                              boardPosition.Y + 3 + (j * 16))'                              Color.White);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw(ppill_' new Vector2(                              boardPosition.X + 3 + (i * 16)'                              boardPosition.Y + 3 + (j * 16))'                              Color.White);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw(ppill_' new Vector2(                              boardPosition.X + 3 + (i * 16)'                              boardPosition.Y + 3 + (j * 16))'                              Color.White);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw(ppill_' new Vector2(                              boardPosition.X + 3 + (i * 16)'                              boardPosition.Y + 3 + (j * 16))'                              Color.White);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw(xlife_' new Vector2(boardPosition.X + 10 + (20 * i)' board_.Height + boardPosition.Y + 10)' Color.White);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw(xlife_' new Vector2(boardPosition.X + 10 + (20 * i)' board_.Height + boardPosition.Y + 10)' Color.White);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw(xlife_' new Vector2(boardPosition.X + 10 + (20 * i)' board_.Height + boardPosition.Y + 10)' Color.White);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: i < xlives_ && i < 20
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.DrawString(scoreFont_' "SCORE"' new Vector2(boardPosition.X + 30' boardPosition.Y - 50)' Color.White);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.DrawString(scoreFont_' "SCORE"' new Vector2(boardPosition.X + 30' boardPosition.Y - 50)' Color.White);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.DrawString(scoreFont_' Score.ToString()' new Vector2(boardPosition.X + 30' boardPosition.Y - 30)' Color.White);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.DrawString(scoreFont_' Score.ToString()' new Vector2(boardPosition.X + 30' boardPosition.Y - 30)' Color.White);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.DrawString(scoreFont_' "LEVEL"' new Vector2(boardPosition.X + board_.Width - 80' boardPosition.Y - 50)' Color.White);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.DrawString(scoreFont_' "LEVEL"' new Vector2(boardPosition.X + board_.Width - 80' boardPosition.Y - 50)' Color.White);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.DrawString(scoreFont_' Constants.Level.ToString()' new Vector2(boardPosition.X + board_.Width - 80' boardPosition.Y - 30)' Color.White);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.DrawString(scoreFont_' Constants.Level.ToString()' new Vector2(boardPosition.X + board_.Width - 80' boardPosition.Y - 30)' Color.White);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw(bonus_[Constants.BonusSprite()]' new Vector2(boardPosition.X + (13 * 16) + 2' boardPosition.Y + (17 * 16) - 8)' Color.White);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw(bonus_[Constants.BonusSprite()]' new Vector2(boardPosition.X + (13 * 16) + 2' boardPosition.Y + (17 * 16) - 8)' Color.White);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw(bonus_[Constants.BonusSprite()]' new Vector2(boardPosition.X + (13 * 16) + 2' boardPosition.Y + (17 * 16) - 8)' Color.White);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw(bonus_[Constants.BonusSprite()]' new Vector2(boardPosition.X + (13 * 16) + 2' boardPosition.Y + (17 * 16) - 8)' Color.White);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw(bonus_[Constants.BonusSprite()]' new Vector2(boardPosition.X + (13 * 16) + 2' boardPosition.Y + (17 * 16) - 8)' Color.White);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw(bonus_[Constants.BonusSprite()]' new Vector2(boardPosition.X + (13 * 16) + 2' boardPosition.Y + (17 * 16) - 8)' Color.White);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw(bonus_[kvp.Key]' new Vector2(boardPosition.X + 10 + (22 * (k + i))' board_.Height + boardPosition.Y + 22)' Color.White);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw(bonus_[kvp.Key]' new Vector2(boardPosition.X + 10 + (22 * (k + i))' board_.Height + boardPosition.Y + 22)' Color.White);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw(bonus_[kvp.Key]' new Vector2(boardPosition.X + 10 + (22 * (k + i))' board_.Height + boardPosition.Y + 22)' Color.White);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.DrawString(scoreEventFont_' se.Score.ToString()' new Vector2(boardPosition.X + (se.Position.Tile.X * 16) + se.Position.DeltaPixel.X + 4'                                                                                             boardPosition.Y + (se.Position.Tile.Y * 16) + se.Position.DeltaPixel.Y + 4)' Color.White);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.DrawString(scoreEventFont_' se.Score.ToString()' new Vector2(boardPosition.X + (se.Position.Tile.X * 16) + se.Position.DeltaPixel.X + 4'                                                                                             boardPosition.Y + (se.Position.Tile.Y * 16) + se.Position.DeltaPixel.Y + 4)' Color.White);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.DrawString(scoreEventFont_' se.Score.ToString()' new Vector2(boardPosition.X + (se.Position.Tile.X * 16) + se.Position.DeltaPixel.X + 4'                                                                                             boardPosition.Y + (se.Position.Tile.Y * 16) + se.Position.DeltaPixel.Y + 4)' Color.White);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.DrawString(scoreEventFont_' se.Score.ToString()' new Vector2(boardPosition.X + (se.Position.Tile.X * 16) + se.Position.DeltaPixel.X + 4'                                                                                             boardPosition.Y + (se.Position.Tile.Y * 16) + se.Position.DeltaPixel.Y + 4)' Color.White);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.DrawString(scoreFont_' "GET READY!"' new Vector2(boardPosition.X + (board_.Width / 2) - 58' boardPosition.Y + 273)' Color.Yellow);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.DrawString(scoreFont_' "GET READY!"' new Vector2(boardPosition.X + (board_.Width / 2) - 58' boardPosition.Y + 273)' Color.Yellow);
Magic Number,XNAPacMan,GameLoop,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\GameLoop.cs,Draw,The following statement contains a magic number: spriteBatch_.DrawString(scoreFont_' "GET READY!"' new Vector2(boardPosition.X + (board_.Width / 2) - 58' boardPosition.Y + 273)' Color.Yellow);
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Reset,The following statement contains a magic number: scatterModesLeft_ = 4;
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,PlaySound,The following statement contains a magic number: Grid.NumCrumps < 50
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: switch (State) {                  case GhostState.Home:                      // Ghost exit the home state for the scatter state when they get to the row                      // above the home                      if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {                          // Select inital direction based on scatter tiles                          if (Constants.scatterTiles(identity_)[0].X < 13) {                              direction_ = Direction.Left;                          } else {                              direction_ = Direction.Right;                          }                          if (scatterModesLeft_ > 0) {                              State = GhostState.Scatter;                          } else {                              State = GhostState.Attack;                          }                          return;                      }                          // Ghosts move up when they are aligned with the entrance                      else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {                          direction_ = Direction.Up;                      }                          // When on one side' move towards middle when on the bottom and time's up                          // If time's not up' keep bouncing up and down                      else if ((position_.DeltaPixel.Y == 8) &&                              ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) ||                               (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {                          if (position_.Tile.Y == 14) {                              initialJumps_--;                              if (initialJumps_ == 0) {                                  if (position_.Tile.X == 11) {                                      direction_ = Direction.Right;                                  } else {                                      direction_ = Direction.Left;                                  }                              } else {                                  direction_ = Direction.Up;                              }                          } else if (position_.Tile.Y == 13) {                              direction_ = Direction.Down;                          }                      }                      break;                  case GhostState.Scatter:                      // Attempt to reverse direction upon entering this state                      if (previousState_ == GhostState.Attack) {                          scatterModesLeft_--;                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      }                      AIScatter();                      int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(timeInScatterMode)) {                          State = GhostState.Attack;                      }                      break;                  case GhostState.Dead:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIDead();                      }                      if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {                          if (position_.Tile.Y == 14) {                              State = GhostState.Home;                          }                      }                      break;                  case GhostState.Attack:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIAttack();                      }                        if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(20)) {                          State = GhostState.Scatter;                      }                      break;                  case GhostState.Blue:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          // TODO : make special blue AI                          AIAttack();                      }                        // When blue time is over' revert to attack mode.                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(Constants.BlueTime())) {                          State = GhostState.Attack;                      }                      break;              }
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: switch (State) {                  case GhostState.Home:                      // Ghost exit the home state for the scatter state when they get to the row                      // above the home                      if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {                          // Select inital direction based on scatter tiles                          if (Constants.scatterTiles(identity_)[0].X < 13) {                              direction_ = Direction.Left;                          } else {                              direction_ = Direction.Right;                          }                          if (scatterModesLeft_ > 0) {                              State = GhostState.Scatter;                          } else {                              State = GhostState.Attack;                          }                          return;                      }                          // Ghosts move up when they are aligned with the entrance                      else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {                          direction_ = Direction.Up;                      }                          // When on one side' move towards middle when on the bottom and time's up                          // If time's not up' keep bouncing up and down                      else if ((position_.DeltaPixel.Y == 8) &&                              ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) ||                               (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {                          if (position_.Tile.Y == 14) {                              initialJumps_--;                              if (initialJumps_ == 0) {                                  if (position_.Tile.X == 11) {                                      direction_ = Direction.Right;                                  } else {                                      direction_ = Direction.Left;                                  }                              } else {                                  direction_ = Direction.Up;                              }                          } else if (position_.Tile.Y == 13) {                              direction_ = Direction.Down;                          }                      }                      break;                  case GhostState.Scatter:                      // Attempt to reverse direction upon entering this state                      if (previousState_ == GhostState.Attack) {                          scatterModesLeft_--;                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      }                      AIScatter();                      int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(timeInScatterMode)) {                          State = GhostState.Attack;                      }                      break;                  case GhostState.Dead:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIDead();                      }                      if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {                          if (position_.Tile.Y == 14) {                              State = GhostState.Home;                          }                      }                      break;                  case GhostState.Attack:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIAttack();                      }                        if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(20)) {                          State = GhostState.Scatter;                      }                      break;                  case GhostState.Blue:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          // TODO : make special blue AI                          AIAttack();                      }                        // When blue time is over' revert to attack mode.                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(Constants.BlueTime())) {                          State = GhostState.Attack;                      }                      break;              }
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: switch (State) {                  case GhostState.Home:                      // Ghost exit the home state for the scatter state when they get to the row                      // above the home                      if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {                          // Select inital direction based on scatter tiles                          if (Constants.scatterTiles(identity_)[0].X < 13) {                              direction_ = Direction.Left;                          } else {                              direction_ = Direction.Right;                          }                          if (scatterModesLeft_ > 0) {                              State = GhostState.Scatter;                          } else {                              State = GhostState.Attack;                          }                          return;                      }                          // Ghosts move up when they are aligned with the entrance                      else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {                          direction_ = Direction.Up;                      }                          // When on one side' move towards middle when on the bottom and time's up                          // If time's not up' keep bouncing up and down                      else if ((position_.DeltaPixel.Y == 8) &&                              ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) ||                               (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {                          if (position_.Tile.Y == 14) {                              initialJumps_--;                              if (initialJumps_ == 0) {                                  if (position_.Tile.X == 11) {                                      direction_ = Direction.Right;                                  } else {                                      direction_ = Direction.Left;                                  }                              } else {                                  direction_ = Direction.Up;                              }                          } else if (position_.Tile.Y == 13) {                              direction_ = Direction.Down;                          }                      }                      break;                  case GhostState.Scatter:                      // Attempt to reverse direction upon entering this state                      if (previousState_ == GhostState.Attack) {                          scatterModesLeft_--;                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      }                      AIScatter();                      int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(timeInScatterMode)) {                          State = GhostState.Attack;                      }                      break;                  case GhostState.Dead:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIDead();                      }                      if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {                          if (position_.Tile.Y == 14) {                              State = GhostState.Home;                          }                      }                      break;                  case GhostState.Attack:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIAttack();                      }                        if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(20)) {                          State = GhostState.Scatter;                      }                      break;                  case GhostState.Blue:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          // TODO : make special blue AI                          AIAttack();                      }                        // When blue time is over' revert to attack mode.                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(Constants.BlueTime())) {                          State = GhostState.Attack;                      }                      break;              }
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: switch (State) {                  case GhostState.Home:                      // Ghost exit the home state for the scatter state when they get to the row                      // above the home                      if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {                          // Select inital direction based on scatter tiles                          if (Constants.scatterTiles(identity_)[0].X < 13) {                              direction_ = Direction.Left;                          } else {                              direction_ = Direction.Right;                          }                          if (scatterModesLeft_ > 0) {                              State = GhostState.Scatter;                          } else {                              State = GhostState.Attack;                          }                          return;                      }                          // Ghosts move up when they are aligned with the entrance                      else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {                          direction_ = Direction.Up;                      }                          // When on one side' move towards middle when on the bottom and time's up                          // If time's not up' keep bouncing up and down                      else if ((position_.DeltaPixel.Y == 8) &&                              ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) ||                               (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {                          if (position_.Tile.Y == 14) {                              initialJumps_--;                              if (initialJumps_ == 0) {                                  if (position_.Tile.X == 11) {                                      direction_ = Direction.Right;                                  } else {                                      direction_ = Direction.Left;                                  }                              } else {                                  direction_ = Direction.Up;                              }                          } else if (position_.Tile.Y == 13) {                              direction_ = Direction.Down;                          }                      }                      break;                  case GhostState.Scatter:                      // Attempt to reverse direction upon entering this state                      if (previousState_ == GhostState.Attack) {                          scatterModesLeft_--;                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      }                      AIScatter();                      int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(timeInScatterMode)) {                          State = GhostState.Attack;                      }                      break;                  case GhostState.Dead:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIDead();                      }                      if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {                          if (position_.Tile.Y == 14) {                              State = GhostState.Home;                          }                      }                      break;                  case GhostState.Attack:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIAttack();                      }                        if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(20)) {                          State = GhostState.Scatter;                      }                      break;                  case GhostState.Blue:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          // TODO : make special blue AI                          AIAttack();                      }                        // When blue time is over' revert to attack mode.                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(Constants.BlueTime())) {                          State = GhostState.Attack;                      }                      break;              }
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: switch (State) {                  case GhostState.Home:                      // Ghost exit the home state for the scatter state when they get to the row                      // above the home                      if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {                          // Select inital direction based on scatter tiles                          if (Constants.scatterTiles(identity_)[0].X < 13) {                              direction_ = Direction.Left;                          } else {                              direction_ = Direction.Right;                          }                          if (scatterModesLeft_ > 0) {                              State = GhostState.Scatter;                          } else {                              State = GhostState.Attack;                          }                          return;                      }                          // Ghosts move up when they are aligned with the entrance                      else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {                          direction_ = Direction.Up;                      }                          // When on one side' move towards middle when on the bottom and time's up                          // If time's not up' keep bouncing up and down                      else if ((position_.DeltaPixel.Y == 8) &&                              ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) ||                               (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {                          if (position_.Tile.Y == 14) {                              initialJumps_--;                              if (initialJumps_ == 0) {                                  if (position_.Tile.X == 11) {                                      direction_ = Direction.Right;                                  } else {                                      direction_ = Direction.Left;                                  }                              } else {                                  direction_ = Direction.Up;                              }                          } else if (position_.Tile.Y == 13) {                              direction_ = Direction.Down;                          }                      }                      break;                  case GhostState.Scatter:                      // Attempt to reverse direction upon entering this state                      if (previousState_ == GhostState.Attack) {                          scatterModesLeft_--;                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      }                      AIScatter();                      int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(timeInScatterMode)) {                          State = GhostState.Attack;                      }                      break;                  case GhostState.Dead:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIDead();                      }                      if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {                          if (position_.Tile.Y == 14) {                              State = GhostState.Home;                          }                      }                      break;                  case GhostState.Attack:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIAttack();                      }                        if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(20)) {                          State = GhostState.Scatter;                      }                      break;                  case GhostState.Blue:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          // TODO : make special blue AI                          AIAttack();                      }                        // When blue time is over' revert to attack mode.                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(Constants.BlueTime())) {                          State = GhostState.Attack;                      }                      break;              }
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: switch (State) {                  case GhostState.Home:                      // Ghost exit the home state for the scatter state when they get to the row                      // above the home                      if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {                          // Select inital direction based on scatter tiles                          if (Constants.scatterTiles(identity_)[0].X < 13) {                              direction_ = Direction.Left;                          } else {                              direction_ = Direction.Right;                          }                          if (scatterModesLeft_ > 0) {                              State = GhostState.Scatter;                          } else {                              State = GhostState.Attack;                          }                          return;                      }                          // Ghosts move up when they are aligned with the entrance                      else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {                          direction_ = Direction.Up;                      }                          // When on one side' move towards middle when on the bottom and time's up                          // If time's not up' keep bouncing up and down                      else if ((position_.DeltaPixel.Y == 8) &&                              ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) ||                               (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {                          if (position_.Tile.Y == 14) {                              initialJumps_--;                              if (initialJumps_ == 0) {                                  if (position_.Tile.X == 11) {                                      direction_ = Direction.Right;                                  } else {                                      direction_ = Direction.Left;                                  }                              } else {                                  direction_ = Direction.Up;                              }                          } else if (position_.Tile.Y == 13) {                              direction_ = Direction.Down;                          }                      }                      break;                  case GhostState.Scatter:                      // Attempt to reverse direction upon entering this state                      if (previousState_ == GhostState.Attack) {                          scatterModesLeft_--;                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      }                      AIScatter();                      int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(timeInScatterMode)) {                          State = GhostState.Attack;                      }                      break;                  case GhostState.Dead:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIDead();                      }                      if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {                          if (position_.Tile.Y == 14) {                              State = GhostState.Home;                          }                      }                      break;                  case GhostState.Attack:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIAttack();                      }                        if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(20)) {                          State = GhostState.Scatter;                      }                      break;                  case GhostState.Blue:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          // TODO : make special blue AI                          AIAttack();                      }                        // When blue time is over' revert to attack mode.                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(Constants.BlueTime())) {                          State = GhostState.Attack;                      }                      break;              }
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: switch (State) {                  case GhostState.Home:                      // Ghost exit the home state for the scatter state when they get to the row                      // above the home                      if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {                          // Select inital direction based on scatter tiles                          if (Constants.scatterTiles(identity_)[0].X < 13) {                              direction_ = Direction.Left;                          } else {                              direction_ = Direction.Right;                          }                          if (scatterModesLeft_ > 0) {                              State = GhostState.Scatter;                          } else {                              State = GhostState.Attack;                          }                          return;                      }                          // Ghosts move up when they are aligned with the entrance                      else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {                          direction_ = Direction.Up;                      }                          // When on one side' move towards middle when on the bottom and time's up                          // If time's not up' keep bouncing up and down                      else if ((position_.DeltaPixel.Y == 8) &&                              ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) ||                               (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {                          if (position_.Tile.Y == 14) {                              initialJumps_--;                              if (initialJumps_ == 0) {                                  if (position_.Tile.X == 11) {                                      direction_ = Direction.Right;                                  } else {                                      direction_ = Direction.Left;                                  }                              } else {                                  direction_ = Direction.Up;                              }                          } else if (position_.Tile.Y == 13) {                              direction_ = Direction.Down;                          }                      }                      break;                  case GhostState.Scatter:                      // Attempt to reverse direction upon entering this state                      if (previousState_ == GhostState.Attack) {                          scatterModesLeft_--;                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      }                      AIScatter();                      int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(timeInScatterMode)) {                          State = GhostState.Attack;                      }                      break;                  case GhostState.Dead:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIDead();                      }                      if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {                          if (position_.Tile.Y == 14) {                              State = GhostState.Home;                          }                      }                      break;                  case GhostState.Attack:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIAttack();                      }                        if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(20)) {                          State = GhostState.Scatter;                      }                      break;                  case GhostState.Blue:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          // TODO : make special blue AI                          AIAttack();                      }                        // When blue time is over' revert to attack mode.                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(Constants.BlueTime())) {                          State = GhostState.Attack;                      }                      break;              }
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: switch (State) {                  case GhostState.Home:                      // Ghost exit the home state for the scatter state when they get to the row                      // above the home                      if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {                          // Select inital direction based on scatter tiles                          if (Constants.scatterTiles(identity_)[0].X < 13) {                              direction_ = Direction.Left;                          } else {                              direction_ = Direction.Right;                          }                          if (scatterModesLeft_ > 0) {                              State = GhostState.Scatter;                          } else {                              State = GhostState.Attack;                          }                          return;                      }                          // Ghosts move up when they are aligned with the entrance                      else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {                          direction_ = Direction.Up;                      }                          // When on one side' move towards middle when on the bottom and time's up                          // If time's not up' keep bouncing up and down                      else if ((position_.DeltaPixel.Y == 8) &&                              ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) ||                               (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {                          if (position_.Tile.Y == 14) {                              initialJumps_--;                              if (initialJumps_ == 0) {                                  if (position_.Tile.X == 11) {                                      direction_ = Direction.Right;                                  } else {                                      direction_ = Direction.Left;                                  }                              } else {                                  direction_ = Direction.Up;                              }                          } else if (position_.Tile.Y == 13) {                              direction_ = Direction.Down;                          }                      }                      break;                  case GhostState.Scatter:                      // Attempt to reverse direction upon entering this state                      if (previousState_ == GhostState.Attack) {                          scatterModesLeft_--;                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      }                      AIScatter();                      int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(timeInScatterMode)) {                          State = GhostState.Attack;                      }                      break;                  case GhostState.Dead:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIDead();                      }                      if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {                          if (position_.Tile.Y == 14) {                              State = GhostState.Home;                          }                      }                      break;                  case GhostState.Attack:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIAttack();                      }                        if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(20)) {                          State = GhostState.Scatter;                      }                      break;                  case GhostState.Blue:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          // TODO : make special blue AI                          AIAttack();                      }                        // When blue time is over' revert to attack mode.                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(Constants.BlueTime())) {                          State = GhostState.Attack;                      }                      break;              }
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: switch (State) {                  case GhostState.Home:                      // Ghost exit the home state for the scatter state when they get to the row                      // above the home                      if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {                          // Select inital direction based on scatter tiles                          if (Constants.scatterTiles(identity_)[0].X < 13) {                              direction_ = Direction.Left;                          } else {                              direction_ = Direction.Right;                          }                          if (scatterModesLeft_ > 0) {                              State = GhostState.Scatter;                          } else {                              State = GhostState.Attack;                          }                          return;                      }                          // Ghosts move up when they are aligned with the entrance                      else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {                          direction_ = Direction.Up;                      }                          // When on one side' move towards middle when on the bottom and time's up                          // If time's not up' keep bouncing up and down                      else if ((position_.DeltaPixel.Y == 8) &&                              ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) ||                               (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {                          if (position_.Tile.Y == 14) {                              initialJumps_--;                              if (initialJumps_ == 0) {                                  if (position_.Tile.X == 11) {                                      direction_ = Direction.Right;                                  } else {                                      direction_ = Direction.Left;                                  }                              } else {                                  direction_ = Direction.Up;                              }                          } else if (position_.Tile.Y == 13) {                              direction_ = Direction.Down;                          }                      }                      break;                  case GhostState.Scatter:                      // Attempt to reverse direction upon entering this state                      if (previousState_ == GhostState.Attack) {                          scatterModesLeft_--;                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      }                      AIScatter();                      int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(timeInScatterMode)) {                          State = GhostState.Attack;                      }                      break;                  case GhostState.Dead:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIDead();                      }                      if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {                          if (position_.Tile.Y == 14) {                              State = GhostState.Home;                          }                      }                      break;                  case GhostState.Attack:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIAttack();                      }                        if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(20)) {                          State = GhostState.Scatter;                      }                      break;                  case GhostState.Blue:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          // TODO : make special blue AI                          AIAttack();                      }                        // When blue time is over' revert to attack mode.                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(Constants.BlueTime())) {                          State = GhostState.Attack;                      }                      break;              }
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: switch (State) {                  case GhostState.Home:                      // Ghost exit the home state for the scatter state when they get to the row                      // above the home                      if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {                          // Select inital direction based on scatter tiles                          if (Constants.scatterTiles(identity_)[0].X < 13) {                              direction_ = Direction.Left;                          } else {                              direction_ = Direction.Right;                          }                          if (scatterModesLeft_ > 0) {                              State = GhostState.Scatter;                          } else {                              State = GhostState.Attack;                          }                          return;                      }                          // Ghosts move up when they are aligned with the entrance                      else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {                          direction_ = Direction.Up;                      }                          // When on one side' move towards middle when on the bottom and time's up                          // If time's not up' keep bouncing up and down                      else if ((position_.DeltaPixel.Y == 8) &&                              ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) ||                               (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {                          if (position_.Tile.Y == 14) {                              initialJumps_--;                              if (initialJumps_ == 0) {                                  if (position_.Tile.X == 11) {                                      direction_ = Direction.Right;                                  } else {                                      direction_ = Direction.Left;                                  }                              } else {                                  direction_ = Direction.Up;                              }                          } else if (position_.Tile.Y == 13) {                              direction_ = Direction.Down;                          }                      }                      break;                  case GhostState.Scatter:                      // Attempt to reverse direction upon entering this state                      if (previousState_ == GhostState.Attack) {                          scatterModesLeft_--;                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      }                      AIScatter();                      int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(timeInScatterMode)) {                          State = GhostState.Attack;                      }                      break;                  case GhostState.Dead:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIDead();                      }                      if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {                          if (position_.Tile.Y == 14) {                              State = GhostState.Home;                          }                      }                      break;                  case GhostState.Attack:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIAttack();                      }                        if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(20)) {                          State = GhostState.Scatter;                      }                      break;                  case GhostState.Blue:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          // TODO : make special blue AI                          AIAttack();                      }                        // When blue time is over' revert to attack mode.                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(Constants.BlueTime())) {                          State = GhostState.Attack;                      }                      break;              }
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: switch (State) {                  case GhostState.Home:                      // Ghost exit the home state for the scatter state when they get to the row                      // above the home                      if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {                          // Select inital direction based on scatter tiles                          if (Constants.scatterTiles(identity_)[0].X < 13) {                              direction_ = Direction.Left;                          } else {                              direction_ = Direction.Right;                          }                          if (scatterModesLeft_ > 0) {                              State = GhostState.Scatter;                          } else {                              State = GhostState.Attack;                          }                          return;                      }                          // Ghosts move up when they are aligned with the entrance                      else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {                          direction_ = Direction.Up;                      }                          // When on one side' move towards middle when on the bottom and time's up                          // If time's not up' keep bouncing up and down                      else if ((position_.DeltaPixel.Y == 8) &&                              ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) ||                               (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {                          if (position_.Tile.Y == 14) {                              initialJumps_--;                              if (initialJumps_ == 0) {                                  if (position_.Tile.X == 11) {                                      direction_ = Direction.Right;                                  } else {                                      direction_ = Direction.Left;                                  }                              } else {                                  direction_ = Direction.Up;                              }                          } else if (position_.Tile.Y == 13) {                              direction_ = Direction.Down;                          }                      }                      break;                  case GhostState.Scatter:                      // Attempt to reverse direction upon entering this state                      if (previousState_ == GhostState.Attack) {                          scatterModesLeft_--;                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      }                      AIScatter();                      int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(timeInScatterMode)) {                          State = GhostState.Attack;                      }                      break;                  case GhostState.Dead:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIDead();                      }                      if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {                          if (position_.Tile.Y == 14) {                              State = GhostState.Home;                          }                      }                      break;                  case GhostState.Attack:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIAttack();                      }                        if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(20)) {                          State = GhostState.Scatter;                      }                      break;                  case GhostState.Blue:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          // TODO : make special blue AI                          AIAttack();                      }                        // When blue time is over' revert to attack mode.                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(Constants.BlueTime())) {                          State = GhostState.Attack;                      }                      break;              }
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: switch (State) {                  case GhostState.Home:                      // Ghost exit the home state for the scatter state when they get to the row                      // above the home                      if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {                          // Select inital direction based on scatter tiles                          if (Constants.scatterTiles(identity_)[0].X < 13) {                              direction_ = Direction.Left;                          } else {                              direction_ = Direction.Right;                          }                          if (scatterModesLeft_ > 0) {                              State = GhostState.Scatter;                          } else {                              State = GhostState.Attack;                          }                          return;                      }                          // Ghosts move up when they are aligned with the entrance                      else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {                          direction_ = Direction.Up;                      }                          // When on one side' move towards middle when on the bottom and time's up                          // If time's not up' keep bouncing up and down                      else if ((position_.DeltaPixel.Y == 8) &&                              ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) ||                               (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {                          if (position_.Tile.Y == 14) {                              initialJumps_--;                              if (initialJumps_ == 0) {                                  if (position_.Tile.X == 11) {                                      direction_ = Direction.Right;                                  } else {                                      direction_ = Direction.Left;                                  }                              } else {                                  direction_ = Direction.Up;                              }                          } else if (position_.Tile.Y == 13) {                              direction_ = Direction.Down;                          }                      }                      break;                  case GhostState.Scatter:                      // Attempt to reverse direction upon entering this state                      if (previousState_ == GhostState.Attack) {                          scatterModesLeft_--;                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      }                      AIScatter();                      int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(timeInScatterMode)) {                          State = GhostState.Attack;                      }                      break;                  case GhostState.Dead:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIDead();                      }                      if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {                          if (position_.Tile.Y == 14) {                              State = GhostState.Home;                          }                      }                      break;                  case GhostState.Attack:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIAttack();                      }                        if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(20)) {                          State = GhostState.Scatter;                      }                      break;                  case GhostState.Blue:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          // TODO : make special blue AI                          AIAttack();                      }                        // When blue time is over' revert to attack mode.                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(Constants.BlueTime())) {                          State = GhostState.Attack;                      }                      break;              }
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: switch (State) {                  case GhostState.Home:                      // Ghost exit the home state for the scatter state when they get to the row                      // above the home                      if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {                          // Select inital direction based on scatter tiles                          if (Constants.scatterTiles(identity_)[0].X < 13) {                              direction_ = Direction.Left;                          } else {                              direction_ = Direction.Right;                          }                          if (scatterModesLeft_ > 0) {                              State = GhostState.Scatter;                          } else {                              State = GhostState.Attack;                          }                          return;                      }                          // Ghosts move up when they are aligned with the entrance                      else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {                          direction_ = Direction.Up;                      }                          // When on one side' move towards middle when on the bottom and time's up                          // If time's not up' keep bouncing up and down                      else if ((position_.DeltaPixel.Y == 8) &&                              ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) ||                               (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {                          if (position_.Tile.Y == 14) {                              initialJumps_--;                              if (initialJumps_ == 0) {                                  if (position_.Tile.X == 11) {                                      direction_ = Direction.Right;                                  } else {                                      direction_ = Direction.Left;                                  }                              } else {                                  direction_ = Direction.Up;                              }                          } else if (position_.Tile.Y == 13) {                              direction_ = Direction.Down;                          }                      }                      break;                  case GhostState.Scatter:                      // Attempt to reverse direction upon entering this state                      if (previousState_ == GhostState.Attack) {                          scatterModesLeft_--;                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      }                      AIScatter();                      int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(timeInScatterMode)) {                          State = GhostState.Attack;                      }                      break;                  case GhostState.Dead:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIDead();                      }                      if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {                          if (position_.Tile.Y == 14) {                              State = GhostState.Home;                          }                      }                      break;                  case GhostState.Attack:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIAttack();                      }                        if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(20)) {                          State = GhostState.Scatter;                      }                      break;                  case GhostState.Blue:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          // TODO : make special blue AI                          AIAttack();                      }                        // When blue time is over' revert to attack mode.                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(Constants.BlueTime())) {                          State = GhostState.Attack;                      }                      break;              }
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: switch (State) {                  case GhostState.Home:                      // Ghost exit the home state for the scatter state when they get to the row                      // above the home                      if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {                          // Select inital direction based on scatter tiles                          if (Constants.scatterTiles(identity_)[0].X < 13) {                              direction_ = Direction.Left;                          } else {                              direction_ = Direction.Right;                          }                          if (scatterModesLeft_ > 0) {                              State = GhostState.Scatter;                          } else {                              State = GhostState.Attack;                          }                          return;                      }                          // Ghosts move up when they are aligned with the entrance                      else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {                          direction_ = Direction.Up;                      }                          // When on one side' move towards middle when on the bottom and time's up                          // If time's not up' keep bouncing up and down                      else if ((position_.DeltaPixel.Y == 8) &&                              ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) ||                               (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {                          if (position_.Tile.Y == 14) {                              initialJumps_--;                              if (initialJumps_ == 0) {                                  if (position_.Tile.X == 11) {                                      direction_ = Direction.Right;                                  } else {                                      direction_ = Direction.Left;                                  }                              } else {                                  direction_ = Direction.Up;                              }                          } else if (position_.Tile.Y == 13) {                              direction_ = Direction.Down;                          }                      }                      break;                  case GhostState.Scatter:                      // Attempt to reverse direction upon entering this state                      if (previousState_ == GhostState.Attack) {                          scatterModesLeft_--;                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      }                      AIScatter();                      int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(timeInScatterMode)) {                          State = GhostState.Attack;                      }                      break;                  case GhostState.Dead:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIDead();                      }                      if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {                          if (position_.Tile.Y == 14) {                              State = GhostState.Home;                          }                      }                      break;                  case GhostState.Attack:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIAttack();                      }                        if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(20)) {                          State = GhostState.Scatter;                      }                      break;                  case GhostState.Blue:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          // TODO : make special blue AI                          AIAttack();                      }                        // When blue time is over' revert to attack mode.                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(Constants.BlueTime())) {                          State = GhostState.Attack;                      }                      break;              }
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: switch (State) {                  case GhostState.Home:                      // Ghost exit the home state for the scatter state when they get to the row                      // above the home                      if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {                          // Select inital direction based on scatter tiles                          if (Constants.scatterTiles(identity_)[0].X < 13) {                              direction_ = Direction.Left;                          } else {                              direction_ = Direction.Right;                          }                          if (scatterModesLeft_ > 0) {                              State = GhostState.Scatter;                          } else {                              State = GhostState.Attack;                          }                          return;                      }                          // Ghosts move up when they are aligned with the entrance                      else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {                          direction_ = Direction.Up;                      }                          // When on one side' move towards middle when on the bottom and time's up                          // If time's not up' keep bouncing up and down                      else if ((position_.DeltaPixel.Y == 8) &&                              ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) ||                               (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {                          if (position_.Tile.Y == 14) {                              initialJumps_--;                              if (initialJumps_ == 0) {                                  if (position_.Tile.X == 11) {                                      direction_ = Direction.Right;                                  } else {                                      direction_ = Direction.Left;                                  }                              } else {                                  direction_ = Direction.Up;                              }                          } else if (position_.Tile.Y == 13) {                              direction_ = Direction.Down;                          }                      }                      break;                  case GhostState.Scatter:                      // Attempt to reverse direction upon entering this state                      if (previousState_ == GhostState.Attack) {                          scatterModesLeft_--;                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      }                      AIScatter();                      int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(timeInScatterMode)) {                          State = GhostState.Attack;                      }                      break;                  case GhostState.Dead:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIDead();                      }                      if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {                          if (position_.Tile.Y == 14) {                              State = GhostState.Home;                          }                      }                      break;                  case GhostState.Attack:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIAttack();                      }                        if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(20)) {                          State = GhostState.Scatter;                      }                      break;                  case GhostState.Blue:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          // TODO : make special blue AI                          AIAttack();                      }                        // When blue time is over' revert to attack mode.                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(Constants.BlueTime())) {                          State = GhostState.Attack;                      }                      break;              }
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: switch (State) {                  case GhostState.Home:                      // Ghost exit the home state for the scatter state when they get to the row                      // above the home                      if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {                          // Select inital direction based on scatter tiles                          if (Constants.scatterTiles(identity_)[0].X < 13) {                              direction_ = Direction.Left;                          } else {                              direction_ = Direction.Right;                          }                          if (scatterModesLeft_ > 0) {                              State = GhostState.Scatter;                          } else {                              State = GhostState.Attack;                          }                          return;                      }                          // Ghosts move up when they are aligned with the entrance                      else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {                          direction_ = Direction.Up;                      }                          // When on one side' move towards middle when on the bottom and time's up                          // If time's not up' keep bouncing up and down                      else if ((position_.DeltaPixel.Y == 8) &&                              ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) ||                               (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {                          if (position_.Tile.Y == 14) {                              initialJumps_--;                              if (initialJumps_ == 0) {                                  if (position_.Tile.X == 11) {                                      direction_ = Direction.Right;                                  } else {                                      direction_ = Direction.Left;                                  }                              } else {                                  direction_ = Direction.Up;                              }                          } else if (position_.Tile.Y == 13) {                              direction_ = Direction.Down;                          }                      }                      break;                  case GhostState.Scatter:                      // Attempt to reverse direction upon entering this state                      if (previousState_ == GhostState.Attack) {                          scatterModesLeft_--;                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      }                      AIScatter();                      int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(timeInScatterMode)) {                          State = GhostState.Attack;                      }                      break;                  case GhostState.Dead:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIDead();                      }                      if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {                          if (position_.Tile.Y == 14) {                              State = GhostState.Home;                          }                      }                      break;                  case GhostState.Attack:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIAttack();                      }                        if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(20)) {                          State = GhostState.Scatter;                      }                      break;                  case GhostState.Blue:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          // TODO : make special blue AI                          AIAttack();                      }                        // When blue time is over' revert to attack mode.                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(Constants.BlueTime())) {                          State = GhostState.Attack;                      }                      break;              }
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: switch (State) {                  case GhostState.Home:                      // Ghost exit the home state for the scatter state when they get to the row                      // above the home                      if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {                          // Select inital direction based on scatter tiles                          if (Constants.scatterTiles(identity_)[0].X < 13) {                              direction_ = Direction.Left;                          } else {                              direction_ = Direction.Right;                          }                          if (scatterModesLeft_ > 0) {                              State = GhostState.Scatter;                          } else {                              State = GhostState.Attack;                          }                          return;                      }                          // Ghosts move up when they are aligned with the entrance                      else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {                          direction_ = Direction.Up;                      }                          // When on one side' move towards middle when on the bottom and time's up                          // If time's not up' keep bouncing up and down                      else if ((position_.DeltaPixel.Y == 8) &&                              ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) ||                               (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {                          if (position_.Tile.Y == 14) {                              initialJumps_--;                              if (initialJumps_ == 0) {                                  if (position_.Tile.X == 11) {                                      direction_ = Direction.Right;                                  } else {                                      direction_ = Direction.Left;                                  }                              } else {                                  direction_ = Direction.Up;                              }                          } else if (position_.Tile.Y == 13) {                              direction_ = Direction.Down;                          }                      }                      break;                  case GhostState.Scatter:                      // Attempt to reverse direction upon entering this state                      if (previousState_ == GhostState.Attack) {                          scatterModesLeft_--;                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      }                      AIScatter();                      int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(timeInScatterMode)) {                          State = GhostState.Attack;                      }                      break;                  case GhostState.Dead:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIDead();                      }                      if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {                          if (position_.Tile.Y == 14) {                              State = GhostState.Home;                          }                      }                      break;                  case GhostState.Attack:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIAttack();                      }                        if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(20)) {                          State = GhostState.Scatter;                      }                      break;                  case GhostState.Blue:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          // TODO : make special blue AI                          AIAttack();                      }                        // When blue time is over' revert to attack mode.                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(Constants.BlueTime())) {                          State = GhostState.Attack;                      }                      break;              }
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: switch (State) {                  case GhostState.Home:                      // Ghost exit the home state for the scatter state when they get to the row                      // above the home                      if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {                          // Select inital direction based on scatter tiles                          if (Constants.scatterTiles(identity_)[0].X < 13) {                              direction_ = Direction.Left;                          } else {                              direction_ = Direction.Right;                          }                          if (scatterModesLeft_ > 0) {                              State = GhostState.Scatter;                          } else {                              State = GhostState.Attack;                          }                          return;                      }                          // Ghosts move up when they are aligned with the entrance                      else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {                          direction_ = Direction.Up;                      }                          // When on one side' move towards middle when on the bottom and time's up                          // If time's not up' keep bouncing up and down                      else if ((position_.DeltaPixel.Y == 8) &&                              ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) ||                               (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {                          if (position_.Tile.Y == 14) {                              initialJumps_--;                              if (initialJumps_ == 0) {                                  if (position_.Tile.X == 11) {                                      direction_ = Direction.Right;                                  } else {                                      direction_ = Direction.Left;                                  }                              } else {                                  direction_ = Direction.Up;                              }                          } else if (position_.Tile.Y == 13) {                              direction_ = Direction.Down;                          }                      }                      break;                  case GhostState.Scatter:                      // Attempt to reverse direction upon entering this state                      if (previousState_ == GhostState.Attack) {                          scatterModesLeft_--;                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      }                      AIScatter();                      int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(timeInScatterMode)) {                          State = GhostState.Attack;                      }                      break;                  case GhostState.Dead:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIDead();                      }                      if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {                          if (position_.Tile.Y == 14) {                              State = GhostState.Home;                          }                      }                      break;                  case GhostState.Attack:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIAttack();                      }                        if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(20)) {                          State = GhostState.Scatter;                      }                      break;                  case GhostState.Blue:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          // TODO : make special blue AI                          AIAttack();                      }                        // When blue time is over' revert to attack mode.                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(Constants.BlueTime())) {                          State = GhostState.Attack;                      }                      break;              }
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: switch (State) {                  case GhostState.Home:                      // Ghost exit the home state for the scatter state when they get to the row                      // above the home                      if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {                          // Select inital direction based on scatter tiles                          if (Constants.scatterTiles(identity_)[0].X < 13) {                              direction_ = Direction.Left;                          } else {                              direction_ = Direction.Right;                          }                          if (scatterModesLeft_ > 0) {                              State = GhostState.Scatter;                          } else {                              State = GhostState.Attack;                          }                          return;                      }                          // Ghosts move up when they are aligned with the entrance                      else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {                          direction_ = Direction.Up;                      }                          // When on one side' move towards middle when on the bottom and time's up                          // If time's not up' keep bouncing up and down                      else if ((position_.DeltaPixel.Y == 8) &&                              ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) ||                               (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {                          if (position_.Tile.Y == 14) {                              initialJumps_--;                              if (initialJumps_ == 0) {                                  if (position_.Tile.X == 11) {                                      direction_ = Direction.Right;                                  } else {                                      direction_ = Direction.Left;                                  }                              } else {                                  direction_ = Direction.Up;                              }                          } else if (position_.Tile.Y == 13) {                              direction_ = Direction.Down;                          }                      }                      break;                  case GhostState.Scatter:                      // Attempt to reverse direction upon entering this state                      if (previousState_ == GhostState.Attack) {                          scatterModesLeft_--;                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      }                      AIScatter();                      int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(timeInScatterMode)) {                          State = GhostState.Attack;                      }                      break;                  case GhostState.Dead:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIDead();                      }                      if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {                          if (position_.Tile.Y == 14) {                              State = GhostState.Home;                          }                      }                      break;                  case GhostState.Attack:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIAttack();                      }                        if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(20)) {                          State = GhostState.Scatter;                      }                      break;                  case GhostState.Blue:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          // TODO : make special blue AI                          AIAttack();                      }                        // When blue time is over' revert to attack mode.                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(Constants.BlueTime())) {                          State = GhostState.Attack;                      }                      break;              }
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: (initialState != previousState_) ||                  (Grid.NumCrumps == 199 && previousNumCrumps_ == 200) ||                  (Grid.NumCrumps == 19 && previousNumCrumps_ == 20)
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: (initialState != previousState_) ||                  (Grid.NumCrumps == 199 && previousNumCrumps_ == 200) ||                  (Grid.NumCrumps == 19 && previousNumCrumps_ == 20)
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: (initialState != previousState_) ||                  (Grid.NumCrumps == 199 && previousNumCrumps_ == 200) ||                  (Grid.NumCrumps == 19 && previousNumCrumps_ == 20)
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following statement contains a magic number: (initialState != previousState_) ||                  (Grid.NumCrumps == 199 && previousNumCrumps_ == 200) ||                  (Grid.NumCrumps == 19 && previousNumCrumps_ == 20)
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Move,The following statement contains a magic number: switch (direction_) {                      case Direction.Up:                          position_.DeltaPixel.Y--;                          if (position_.DeltaPixel.Y < 0) {                              position_.DeltaPixel.Y = 15;                              position_.Tile.Y--;                          }                          break;                      case Direction.Down:                          position_.DeltaPixel.Y++;                          if (position_.DeltaPixel.Y > 15) {                              position_.DeltaPixel.Y = 0;                              position_.Tile.Y++;                          }                          break;                      case Direction.Left:                          position_.DeltaPixel.X--;                          if (position_.DeltaPixel.X < 0) {                              position_.DeltaPixel.X = 15;                              position_.Tile.X--;                              // Special case : the tunnel                              if (position_.Tile.X < 0) {                                  position_.Tile.X = Grid.Width - 1;                              }                          }                          break;                      case Direction.Right:                          position_.DeltaPixel.X++;                          if (position_.DeltaPixel.X > 15) {                              position_.DeltaPixel.X = 0;                              position_.Tile.X++;                              // Special case : the tunnel                              if (position_.Tile.X > Grid.Width - 1) {                                  position_.Tile.X = 0;                              }                          }                          break;                  }
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Move,The following statement contains a magic number: switch (direction_) {                      case Direction.Up:                          position_.DeltaPixel.Y--;                          if (position_.DeltaPixel.Y < 0) {                              position_.DeltaPixel.Y = 15;                              position_.Tile.Y--;                          }                          break;                      case Direction.Down:                          position_.DeltaPixel.Y++;                          if (position_.DeltaPixel.Y > 15) {                              position_.DeltaPixel.Y = 0;                              position_.Tile.Y++;                          }                          break;                      case Direction.Left:                          position_.DeltaPixel.X--;                          if (position_.DeltaPixel.X < 0) {                              position_.DeltaPixel.X = 15;                              position_.Tile.X--;                              // Special case : the tunnel                              if (position_.Tile.X < 0) {                                  position_.Tile.X = Grid.Width - 1;                              }                          }                          break;                      case Direction.Right:                          position_.DeltaPixel.X++;                          if (position_.DeltaPixel.X > 15) {                              position_.DeltaPixel.X = 0;                              position_.Tile.X++;                              // Special case : the tunnel                              if (position_.Tile.X > Grid.Width - 1) {                                  position_.Tile.X = 0;                              }                          }                          break;                  }
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Move,The following statement contains a magic number: switch (direction_) {                      case Direction.Up:                          position_.DeltaPixel.Y--;                          if (position_.DeltaPixel.Y < 0) {                              position_.DeltaPixel.Y = 15;                              position_.Tile.Y--;                          }                          break;                      case Direction.Down:                          position_.DeltaPixel.Y++;                          if (position_.DeltaPixel.Y > 15) {                              position_.DeltaPixel.Y = 0;                              position_.Tile.Y++;                          }                          break;                      case Direction.Left:                          position_.DeltaPixel.X--;                          if (position_.DeltaPixel.X < 0) {                              position_.DeltaPixel.X = 15;                              position_.Tile.X--;                              // Special case : the tunnel                              if (position_.Tile.X < 0) {                                  position_.Tile.X = Grid.Width - 1;                              }                          }                          break;                      case Direction.Right:                          position_.DeltaPixel.X++;                          if (position_.DeltaPixel.X > 15) {                              position_.DeltaPixel.X = 0;                              position_.Tile.X++;                              // Special case : the tunnel                              if (position_.Tile.X > Grid.Width - 1) {                                  position_.Tile.X = 0;                              }                          }                          break;                  }
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Move,The following statement contains a magic number: switch (direction_) {                      case Direction.Up:                          position_.DeltaPixel.Y--;                          if (position_.DeltaPixel.Y < 0) {                              position_.DeltaPixel.Y = 15;                              position_.Tile.Y--;                          }                          break;                      case Direction.Down:                          position_.DeltaPixel.Y++;                          if (position_.DeltaPixel.Y > 15) {                              position_.DeltaPixel.Y = 0;                              position_.Tile.Y++;                          }                          break;                      case Direction.Left:                          position_.DeltaPixel.X--;                          if (position_.DeltaPixel.X < 0) {                              position_.DeltaPixel.X = 15;                              position_.Tile.X--;                              // Special case : the tunnel                              if (position_.Tile.X < 0) {                                  position_.Tile.X = Grid.Width - 1;                              }                          }                          break;                      case Direction.Right:                          position_.DeltaPixel.X++;                          if (position_.DeltaPixel.X > 15) {                              position_.DeltaPixel.X = 0;                              position_.Tile.X++;                              // Special case : the tunnel                              if (position_.Tile.X > Grid.Width - 1) {                                  position_.Tile.X = 0;                              }                          }                          break;                  }
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,UpdateSpeed,The following statement contains a magic number: updatesPerPixel_ = baseSpeed * 2;
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: position_.Tile.Y == 11 && position_.Tile.X == 13 && position_.DeltaPixel.X == 8
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: position_.Tile.Y == 11 && position_.Tile.X == 13 && position_.DeltaPixel.X == 8
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIDead,The following statement contains a magic number: position_.Tile.Y == 11 && position_.Tile.X == 13 && position_.DeltaPixel.X == 8
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AttackAIInky,The following statement contains a magic number: line *= 2;
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AttackAIClyde,The following statement contains a magic number: distanceToPlayer >= 8
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIOverride,The following statement contains a magic number: position_.Tile.Y == 11 && (position_.Tile.X == 12 || position_.Tile.X == 15)
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIOverride,The following statement contains a magic number: position_.Tile.Y == 11 && (position_.Tile.X == 12 || position_.Tile.X == 15)
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,AIOverride,The following statement contains a magic number: position_.Tile.Y == 11 && (position_.Tile.X == 12 || position_.Tile.X == 15)
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,FindDirection,The following statement contains a magic number: var directions = new List<Direction>(4);
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: ((DateTime.Now.Millisecond / 125) % 2) == 0 ^ wiggle_
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: ((DateTime.Now.Millisecond / 125) % 2) == 0 ^ wiggle_
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: position.X = boardPosition.X + (position_.Tile.X * 16) + (position_.DeltaPixel.X) - 6;
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: position.X = boardPosition.X + (position_.Tile.X * 16) + (position_.DeltaPixel.X) - 6;
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: position.Y = boardPosition.Y + (position_.Tile.Y * 16) + (position_.DeltaPixel.Y) - 6;
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: position.Y = boardPosition.Y + (position_.Tile.Y * 16) + (position_.DeltaPixel.Y) - 6;
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: eyesBasePosition.X = position.X + 4;
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: eyesBasePosition.Y = position.Y + 6;
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: switch (direction_) {                  case Direction.Up:                      eyesBasePosition.Y -= 2;                      eyesCenterPosition.X = eyesBasePosition.X + 2;                      eyesCenterPosition.Y = eyesBasePosition.Y;                      break;                  case Direction.Down:                      eyesBasePosition.Y += 2;                      eyesCenterPosition.X = eyesBasePosition.X + 2;                      eyesCenterPosition.Y = eyesBasePosition.Y + 6;                      break;                  case Direction.Left:                      eyesBasePosition.X -= 2;                      eyesCenterPosition.X = eyesBasePosition.X;                      eyesCenterPosition.Y = eyesBasePosition.Y + 3;                      break;                  case Direction.Right:                      eyesBasePosition.X += 2;                      eyesCenterPosition.X = eyesBasePosition.X + 4;                      eyesCenterPosition.Y = eyesBasePosition.Y + 3;                      break;              }
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: switch (direction_) {                  case Direction.Up:                      eyesBasePosition.Y -= 2;                      eyesCenterPosition.X = eyesBasePosition.X + 2;                      eyesCenterPosition.Y = eyesBasePosition.Y;                      break;                  case Direction.Down:                      eyesBasePosition.Y += 2;                      eyesCenterPosition.X = eyesBasePosition.X + 2;                      eyesCenterPosition.Y = eyesBasePosition.Y + 6;                      break;                  case Direction.Left:                      eyesBasePosition.X -= 2;                      eyesCenterPosition.X = eyesBasePosition.X;                      eyesCenterPosition.Y = eyesBasePosition.Y + 3;                      break;                  case Direction.Right:                      eyesBasePosition.X += 2;                      eyesCenterPosition.X = eyesBasePosition.X + 4;                      eyesCenterPosition.Y = eyesBasePosition.Y + 3;                      break;              }
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: switch (direction_) {                  case Direction.Up:                      eyesBasePosition.Y -= 2;                      eyesCenterPosition.X = eyesBasePosition.X + 2;                      eyesCenterPosition.Y = eyesBasePosition.Y;                      break;                  case Direction.Down:                      eyesBasePosition.Y += 2;                      eyesCenterPosition.X = eyesBasePosition.X + 2;                      eyesCenterPosition.Y = eyesBasePosition.Y + 6;                      break;                  case Direction.Left:                      eyesBasePosition.X -= 2;                      eyesCenterPosition.X = eyesBasePosition.X;                      eyesCenterPosition.Y = eyesBasePosition.Y + 3;                      break;                  case Direction.Right:                      eyesBasePosition.X += 2;                      eyesCenterPosition.X = eyesBasePosition.X + 4;                      eyesCenterPosition.Y = eyesBasePosition.Y + 3;                      break;              }
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: switch (direction_) {                  case Direction.Up:                      eyesBasePosition.Y -= 2;                      eyesCenterPosition.X = eyesBasePosition.X + 2;                      eyesCenterPosition.Y = eyesBasePosition.Y;                      break;                  case Direction.Down:                      eyesBasePosition.Y += 2;                      eyesCenterPosition.X = eyesBasePosition.X + 2;                      eyesCenterPosition.Y = eyesBasePosition.Y + 6;                      break;                  case Direction.Left:                      eyesBasePosition.X -= 2;                      eyesCenterPosition.X = eyesBasePosition.X;                      eyesCenterPosition.Y = eyesBasePosition.Y + 3;                      break;                  case Direction.Right:                      eyesBasePosition.X += 2;                      eyesCenterPosition.X = eyesBasePosition.X + 4;                      eyesCenterPosition.Y = eyesBasePosition.Y + 3;                      break;              }
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: switch (direction_) {                  case Direction.Up:                      eyesBasePosition.Y -= 2;                      eyesCenterPosition.X = eyesBasePosition.X + 2;                      eyesCenterPosition.Y = eyesBasePosition.Y;                      break;                  case Direction.Down:                      eyesBasePosition.Y += 2;                      eyesCenterPosition.X = eyesBasePosition.X + 2;                      eyesCenterPosition.Y = eyesBasePosition.Y + 6;                      break;                  case Direction.Left:                      eyesBasePosition.X -= 2;                      eyesCenterPosition.X = eyesBasePosition.X;                      eyesCenterPosition.Y = eyesBasePosition.Y + 3;                      break;                  case Direction.Right:                      eyesBasePosition.X += 2;                      eyesCenterPosition.X = eyesBasePosition.X + 4;                      eyesCenterPosition.Y = eyesBasePosition.Y + 3;                      break;              }
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: switch (direction_) {                  case Direction.Up:                      eyesBasePosition.Y -= 2;                      eyesCenterPosition.X = eyesBasePosition.X + 2;                      eyesCenterPosition.Y = eyesBasePosition.Y;                      break;                  case Direction.Down:                      eyesBasePosition.Y += 2;                      eyesCenterPosition.X = eyesBasePosition.X + 2;                      eyesCenterPosition.Y = eyesBasePosition.Y + 6;                      break;                  case Direction.Left:                      eyesBasePosition.X -= 2;                      eyesCenterPosition.X = eyesBasePosition.X;                      eyesCenterPosition.Y = eyesBasePosition.Y + 3;                      break;                  case Direction.Right:                      eyesBasePosition.X += 2;                      eyesCenterPosition.X = eyesBasePosition.X + 4;                      eyesCenterPosition.Y = eyesBasePosition.Y + 3;                      break;              }
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: switch (direction_) {                  case Direction.Up:                      eyesBasePosition.Y -= 2;                      eyesCenterPosition.X = eyesBasePosition.X + 2;                      eyesCenterPosition.Y = eyesBasePosition.Y;                      break;                  case Direction.Down:                      eyesBasePosition.Y += 2;                      eyesCenterPosition.X = eyesBasePosition.X + 2;                      eyesCenterPosition.Y = eyesBasePosition.Y + 6;                      break;                  case Direction.Left:                      eyesBasePosition.X -= 2;                      eyesCenterPosition.X = eyesBasePosition.X;                      eyesCenterPosition.Y = eyesBasePosition.Y + 3;                      break;                  case Direction.Right:                      eyesBasePosition.X += 2;                      eyesCenterPosition.X = eyesBasePosition.X + 4;                      eyesCenterPosition.Y = eyesBasePosition.Y + 3;                      break;              }
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: switch (direction_) {                  case Direction.Up:                      eyesBasePosition.Y -= 2;                      eyesCenterPosition.X = eyesBasePosition.X + 2;                      eyesCenterPosition.Y = eyesBasePosition.Y;                      break;                  case Direction.Down:                      eyesBasePosition.Y += 2;                      eyesCenterPosition.X = eyesBasePosition.X + 2;                      eyesCenterPosition.Y = eyesBasePosition.Y + 6;                      break;                  case Direction.Left:                      eyesBasePosition.X -= 2;                      eyesCenterPosition.X = eyesBasePosition.X;                      eyesCenterPosition.Y = eyesBasePosition.Y + 3;                      break;                  case Direction.Right:                      eyesBasePosition.X += 2;                      eyesCenterPosition.X = eyesBasePosition.X + 4;                      eyesCenterPosition.Y = eyesBasePosition.Y + 3;                      break;              }
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: switch (direction_) {                  case Direction.Up:                      eyesBasePosition.Y -= 2;                      eyesCenterPosition.X = eyesBasePosition.X + 2;                      eyesCenterPosition.Y = eyesBasePosition.Y;                      break;                  case Direction.Down:                      eyesBasePosition.Y += 2;                      eyesCenterPosition.X = eyesBasePosition.X + 2;                      eyesCenterPosition.Y = eyesBasePosition.Y + 6;                      break;                  case Direction.Left:                      eyesBasePosition.X -= 2;                      eyesCenterPosition.X = eyesBasePosition.X;                      eyesCenterPosition.Y = eyesBasePosition.Y + 3;                      break;                  case Direction.Right:                      eyesBasePosition.X += 2;                      eyesCenterPosition.X = eyesBasePosition.X + 4;                      eyesCenterPosition.Y = eyesBasePosition.Y + 3;                      break;              }
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: switch (direction_) {                  case Direction.Up:                      eyesBasePosition.Y -= 2;                      eyesCenterPosition.X = eyesBasePosition.X + 2;                      eyesCenterPosition.Y = eyesBasePosition.Y;                      break;                  case Direction.Down:                      eyesBasePosition.Y += 2;                      eyesCenterPosition.X = eyesBasePosition.X + 2;                      eyesCenterPosition.Y = eyesBasePosition.Y + 6;                      break;                  case Direction.Left:                      eyesBasePosition.X -= 2;                      eyesCenterPosition.X = eyesBasePosition.X;                      eyesCenterPosition.Y = eyesBasePosition.Y + 3;                      break;                  case Direction.Right:                      eyesBasePosition.X += 2;                      eyesCenterPosition.X = eyesBasePosition.X + 4;                      eyesCenterPosition.Y = eyesBasePosition.Y + 3;                      break;              }
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following statement contains a magic number: ((DateTime.Now - timeInCurrentState).Seconds < 0.5 * Constants.BlueTime())
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,RenderSprite,The following statement contains a magic number: var rightPortionPosition = new Vector2(boardPosition.X + (16 * 28) - deltaPixel' position.Y);
Magic Number,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,RenderSprite,The following statement contains a magic number: var rightPortionPosition = new Vector2(boardPosition.X + (16 * 28) - deltaPixel' position.Y);
Magic Number,XNAPacMan,Grid,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: TileGrid[i' 14].HasCrump = false;
Magic Number,XNAPacMan,Grid,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: i != 6 && i != 21
Magic Number,XNAPacMan,Grid,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: i != 6 && i != 21
Magic Number,XNAPacMan,Grid,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: i < 28
Magic Number,XNAPacMan,Grid,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: TileGrid[9' j].HasCrump = false;
Magic Number,XNAPacMan,Grid,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: TileGrid[18' j].HasCrump = false;
Magic Number,XNAPacMan,Grid,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: j < 20
Magic Number,XNAPacMan,Grid,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: TileGrid[i' 11].HasCrump = false;
Magic Number,XNAPacMan,Grid,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: TileGrid[i' 17].HasCrump = false;
Magic Number,XNAPacMan,Grid,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: i < 18
Magic Number,XNAPacMan,Grid,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: TileGrid[12' 9].HasCrump = false;
Magic Number,XNAPacMan,Grid,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: TileGrid[12' 9].HasCrump = false;
Magic Number,XNAPacMan,Grid,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: TileGrid[15' 9].HasCrump = false;
Magic Number,XNAPacMan,Grid,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: TileGrid[15' 9].HasCrump = false;
Magic Number,XNAPacMan,Grid,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: TileGrid[12' 10].HasCrump = false;
Magic Number,XNAPacMan,Grid,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: TileGrid[12' 10].HasCrump = false;
Magic Number,XNAPacMan,Grid,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: TileGrid[15' 10].HasCrump = false;
Magic Number,XNAPacMan,Grid,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: TileGrid[15' 10].HasCrump = false;
Magic Number,XNAPacMan,Grid,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: TileGrid[13' 23].HasCrump = false;
Magic Number,XNAPacMan,Grid,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: TileGrid[13' 23].HasCrump = false;
Magic Number,XNAPacMan,Grid,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: TileGrid[14' 23].HasCrump = false;
Magic Number,XNAPacMan,Grid,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Grid.cs,initializeFromFile,The following statement contains a magic number: TileGrid[14' 23].HasCrump = false;
Magic Number,XNAPacMan,HighScores,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\HighScores.cs,Initialize,The following statement contains a magic number: scores_ = new List<string>(10);
Magic Number,XNAPacMan,HighScores,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\HighScores.cs,Draw,The following statement contains a magic number: Vector2 position = new Vector2(graphics_.PreferredBackBufferWidth / 2 - 150' graphics_.PreferredBackBufferHeight / 2 - 200);
Magic Number,XNAPacMan,HighScores,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\HighScores.cs,Draw,The following statement contains a magic number: Vector2 position = new Vector2(graphics_.PreferredBackBufferWidth / 2 - 150' graphics_.PreferredBackBufferHeight / 2 - 200);
Magic Number,XNAPacMan,HighScores,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\HighScores.cs,Draw,The following statement contains a magic number: Vector2 position = new Vector2(graphics_.PreferredBackBufferWidth / 2 - 150' graphics_.PreferredBackBufferHeight / 2 - 200);
Magic Number,XNAPacMan,HighScores,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\HighScores.cs,Draw,The following statement contains a magic number: Vector2 position = new Vector2(graphics_.PreferredBackBufferWidth / 2 - 150' graphics_.PreferredBackBufferHeight / 2 - 200);
Magic Number,XNAPacMan,HighScores,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\HighScores.cs,Draw,The following statement contains a magic number: spriteBatch_.DrawString(scoreFont_' (i + 1).ToString() + "."' new Vector2(position.X' position.Y + (30 * i))' Color.White);
Magic Number,XNAPacMan,HighScores,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\HighScores.cs,Draw,The following statement contains a magic number: spriteBatch_.DrawString(scoreFont_' scores_[i]' new Vector2(position.X + 50' position.Y + (30 * i))' Color.White);
Magic Number,XNAPacMan,HighScores,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\HighScores.cs,Draw,The following statement contains a magic number: spriteBatch_.DrawString(scoreFont_' scores_[i]' new Vector2(position.X + 50' position.Y + (30 * i))' Color.White);
Magic Number,XNAPacMan,HighScores,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\HighScores.cs,Draw,The following statement contains a magic number: i < 10
Magic Number,XNAPacMan,HighScores,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\HighScores.cs,Draw,The following statement contains a magic number: itemPosition.X = (graphics_.PreferredBackBufferWidth / 2) - 100;
Magic Number,XNAPacMan,HighScores,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\HighScores.cs,Draw,The following statement contains a magic number: itemPosition.X = (graphics_.PreferredBackBufferWidth / 2) - 100;
Magic Number,XNAPacMan,HighScores,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\HighScores.cs,Draw,The following statement contains a magic number: itemPosition.Y = (graphics_.PreferredBackBufferHeight / 2) + 200;
Magic Number,XNAPacMan,HighScores,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\HighScores.cs,Draw,The following statement contains a magic number: itemPosition.Y = (graphics_.PreferredBackBufferHeight / 2) + 200;
Magic Number,XNAPacMan,HighScores,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\HighScores.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw(selectionArrow_' new Vector2(itemPosition.X - 50' itemPosition.Y)' Color.White);
Magic Number,XNAPacMan,Menu,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Menu.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw(title_' new Vector2((graphics_.PreferredBackBufferWidth / 2) - (title_.Width / 2)' 75)' Color.White);
Magic Number,XNAPacMan,Menu,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Menu.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw(title_' new Vector2((graphics_.PreferredBackBufferWidth / 2) - (title_.Width / 2)' 75)' Color.White);
Magic Number,XNAPacMan,Menu,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Menu.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw(title_' new Vector2((graphics_.PreferredBackBufferWidth / 2) - (title_.Width / 2)' 75)' Color.White);
Magic Number,XNAPacMan,Menu,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Menu.cs,Draw,The following statement contains a magic number: itemPosition.X = (graphics_.PreferredBackBufferWidth / 2) - 100;
Magic Number,XNAPacMan,Menu,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Menu.cs,Draw,The following statement contains a magic number: itemPosition.X = (graphics_.PreferredBackBufferWidth / 2) - 100;
Magic Number,XNAPacMan,Menu,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Menu.cs,Draw,The following statement contains a magic number: itemPosition.Y = (graphics_.PreferredBackBufferHeight / 2) - 60 + (60 * i);
Magic Number,XNAPacMan,Menu,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Menu.cs,Draw,The following statement contains a magic number: itemPosition.Y = (graphics_.PreferredBackBufferHeight / 2) - 60 + (60 * i);
Magic Number,XNAPacMan,Menu,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Menu.cs,Draw,The following statement contains a magic number: itemPosition.Y = (graphics_.PreferredBackBufferHeight / 2) - 60 + (60 * i);
Magic Number,XNAPacMan,Menu,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Menu.cs,Draw,The following statement contains a magic number: spriteBatch_.Draw(selectionArrow_' new Vector2(itemPosition.X - 50' itemPosition.Y)' Color.White);
Magic Number,XNAPacMan,Player,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoMove,The following statement contains a magic number: updatesPerPixel_ = Constants.PacManSpeed() + 2;
Magic Number,XNAPacMan,Player,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoMove,The following statement contains a magic number: position_.Tile.X == 27
Magic Number,XNAPacMan,Player,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoMove,The following statement contains a magic number: position_.DeltaPixel.X == 16
Magic Number,XNAPacMan,Player,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Draw,The following statement contains a magic number: position.X = boardPosition.X + (position_.Tile.X * 16) + position_.DeltaPixel.X - ((eatingFrames_[0].Width - 16) / 2);
Magic Number,XNAPacMan,Player,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Draw,The following statement contains a magic number: position.X = boardPosition.X + (position_.Tile.X * 16) + position_.DeltaPixel.X - ((eatingFrames_[0].Width - 16) / 2);
Magic Number,XNAPacMan,Player,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Draw,The following statement contains a magic number: position.X = boardPosition.X + (position_.Tile.X * 16) + position_.DeltaPixel.X - ((eatingFrames_[0].Width - 16) / 2);
Magic Number,XNAPacMan,Player,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Draw,The following statement contains a magic number: position.Y = boardPosition.Y + (position_.Tile.Y * 16) + position_.DeltaPixel.Y - ((eatingFrames_[0].Height - 16) / 2);
Magic Number,XNAPacMan,Player,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Draw,The following statement contains a magic number: position.Y = boardPosition.Y + (position_.Tile.Y * 16) + position_.DeltaPixel.Y - ((eatingFrames_[0].Height - 16) / 2);
Magic Number,XNAPacMan,Player,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Draw,The following statement contains a magic number: position.Y = boardPosition.Y + (position_.Tile.Y * 16) + position_.DeltaPixel.Y - ((eatingFrames_[0].Height - 16) / 2);
Magic Number,XNAPacMan,Player,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,RenderSprite,The following statement contains a magic number: var leftPortion = new Rectangle(rect.X + deltaPixel' rect.Y' 26 - deltaPixel' 26);
Magic Number,XNAPacMan,Player,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,RenderSprite,The following statement contains a magic number: var leftPortion = new Rectangle(rect.X + deltaPixel' rect.Y' 26 - deltaPixel' 26);
Magic Number,XNAPacMan,Player,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,RenderSprite,The following statement contains a magic number: var rightPortion = new Rectangle(rect.X' rect.Y' deltaPixel' 26);
Magic Number,XNAPacMan,Player,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,RenderSprite,The following statement contains a magic number: var rightPortionPosition = new Vector2(boardPosition.X + (16 * 28) - deltaPixel' position.Y);
Magic Number,XNAPacMan,Player,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,RenderSprite,The following statement contains a magic number: var rightPortionPosition = new Vector2(boardPosition.X + (16 * 28) - deltaPixel' position.Y);
Magic Number,XNAPacMan,Player,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Reset,The following statement contains a magic number: usedFramesIndex_ = new int[] { 0' 1' 2 };
Magic Number,XNAPacMan,Player,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Reset,The following statement contains a magic number: position_ = new Position { Tile = new Point(13' 23)' DeltaPixel = new Point(8' 0) };
Magic Number,XNAPacMan,Player,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Reset,The following statement contains a magic number: position_ = new Position { Tile = new Point(13' 23)' DeltaPixel = new Point(8' 0) };
Magic Number,XNAPacMan,Player,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,Reset,The following statement contains a magic number: position_ = new Position { Tile = new Point(13' 23)' DeltaPixel = new Point(8' 0) };
Magic Number,XNAPacMan,Player,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following statement contains a magic number: switch (newDirection) {                  case Keys.Up:                      direction_ = Direction.Up;                      usedFramesIndex_ = new int[] { 0' 7' 8 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.Y += 1;                          position_.DeltaPixel.Y -= 16;                      }                      break;                  case Keys.Down:                      direction_ = Direction.Down;                      usedFramesIndex_ = new int[] { 0' 3' 4 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.Y -= 1;                          position_.DeltaPixel.Y += 16;                      }                      break;                  case Keys.Left:                      direction_ = Direction.Left;                      usedFramesIndex_ = new int[] { 0' 5' 6 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.X += 1;                          position_.DeltaPixel.X -= 16;                      }                      break;                  case Keys.Right:                      direction_ = Direction.Right;                      usedFramesIndex_ = new int[] { 0' 1' 2 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.X -= 1;                          position_.DeltaPixel.X += 16;                      }                      break;              }
Magic Number,XNAPacMan,Player,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following statement contains a magic number: switch (newDirection) {                  case Keys.Up:                      direction_ = Direction.Up;                      usedFramesIndex_ = new int[] { 0' 7' 8 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.Y += 1;                          position_.DeltaPixel.Y -= 16;                      }                      break;                  case Keys.Down:                      direction_ = Direction.Down;                      usedFramesIndex_ = new int[] { 0' 3' 4 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.Y -= 1;                          position_.DeltaPixel.Y += 16;                      }                      break;                  case Keys.Left:                      direction_ = Direction.Left;                      usedFramesIndex_ = new int[] { 0' 5' 6 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.X += 1;                          position_.DeltaPixel.X -= 16;                      }                      break;                  case Keys.Right:                      direction_ = Direction.Right;                      usedFramesIndex_ = new int[] { 0' 1' 2 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.X -= 1;                          position_.DeltaPixel.X += 16;                      }                      break;              }
Magic Number,XNAPacMan,Player,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following statement contains a magic number: switch (newDirection) {                  case Keys.Up:                      direction_ = Direction.Up;                      usedFramesIndex_ = new int[] { 0' 7' 8 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.Y += 1;                          position_.DeltaPixel.Y -= 16;                      }                      break;                  case Keys.Down:                      direction_ = Direction.Down;                      usedFramesIndex_ = new int[] { 0' 3' 4 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.Y -= 1;                          position_.DeltaPixel.Y += 16;                      }                      break;                  case Keys.Left:                      direction_ = Direction.Left;                      usedFramesIndex_ = new int[] { 0' 5' 6 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.X += 1;                          position_.DeltaPixel.X -= 16;                      }                      break;                  case Keys.Right:                      direction_ = Direction.Right;                      usedFramesIndex_ = new int[] { 0' 1' 2 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.X -= 1;                          position_.DeltaPixel.X += 16;                      }                      break;              }
Magic Number,XNAPacMan,Player,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following statement contains a magic number: switch (newDirection) {                  case Keys.Up:                      direction_ = Direction.Up;                      usedFramesIndex_ = new int[] { 0' 7' 8 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.Y += 1;                          position_.DeltaPixel.Y -= 16;                      }                      break;                  case Keys.Down:                      direction_ = Direction.Down;                      usedFramesIndex_ = new int[] { 0' 3' 4 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.Y -= 1;                          position_.DeltaPixel.Y += 16;                      }                      break;                  case Keys.Left:                      direction_ = Direction.Left;                      usedFramesIndex_ = new int[] { 0' 5' 6 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.X += 1;                          position_.DeltaPixel.X -= 16;                      }                      break;                  case Keys.Right:                      direction_ = Direction.Right;                      usedFramesIndex_ = new int[] { 0' 1' 2 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.X -= 1;                          position_.DeltaPixel.X += 16;                      }                      break;              }
Magic Number,XNAPacMan,Player,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following statement contains a magic number: switch (newDirection) {                  case Keys.Up:                      direction_ = Direction.Up;                      usedFramesIndex_ = new int[] { 0' 7' 8 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.Y += 1;                          position_.DeltaPixel.Y -= 16;                      }                      break;                  case Keys.Down:                      direction_ = Direction.Down;                      usedFramesIndex_ = new int[] { 0' 3' 4 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.Y -= 1;                          position_.DeltaPixel.Y += 16;                      }                      break;                  case Keys.Left:                      direction_ = Direction.Left;                      usedFramesIndex_ = new int[] { 0' 5' 6 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.X += 1;                          position_.DeltaPixel.X -= 16;                      }                      break;                  case Keys.Right:                      direction_ = Direction.Right;                      usedFramesIndex_ = new int[] { 0' 1' 2 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.X -= 1;                          position_.DeltaPixel.X += 16;                      }                      break;              }
Magic Number,XNAPacMan,Player,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following statement contains a magic number: switch (newDirection) {                  case Keys.Up:                      direction_ = Direction.Up;                      usedFramesIndex_ = new int[] { 0' 7' 8 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.Y += 1;                          position_.DeltaPixel.Y -= 16;                      }                      break;                  case Keys.Down:                      direction_ = Direction.Down;                      usedFramesIndex_ = new int[] { 0' 3' 4 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.Y -= 1;                          position_.DeltaPixel.Y += 16;                      }                      break;                  case Keys.Left:                      direction_ = Direction.Left;                      usedFramesIndex_ = new int[] { 0' 5' 6 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.X += 1;                          position_.DeltaPixel.X -= 16;                      }                      break;                  case Keys.Right:                      direction_ = Direction.Right;                      usedFramesIndex_ = new int[] { 0' 1' 2 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.X -= 1;                          position_.DeltaPixel.X += 16;                      }                      break;              }
Magic Number,XNAPacMan,Player,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following statement contains a magic number: switch (newDirection) {                  case Keys.Up:                      direction_ = Direction.Up;                      usedFramesIndex_ = new int[] { 0' 7' 8 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.Y += 1;                          position_.DeltaPixel.Y -= 16;                      }                      break;                  case Keys.Down:                      direction_ = Direction.Down;                      usedFramesIndex_ = new int[] { 0' 3' 4 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.Y -= 1;                          position_.DeltaPixel.Y += 16;                      }                      break;                  case Keys.Left:                      direction_ = Direction.Left;                      usedFramesIndex_ = new int[] { 0' 5' 6 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.X += 1;                          position_.DeltaPixel.X -= 16;                      }                      break;                  case Keys.Right:                      direction_ = Direction.Right;                      usedFramesIndex_ = new int[] { 0' 1' 2 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.X -= 1;                          position_.DeltaPixel.X += 16;                      }                      break;              }
Magic Number,XNAPacMan,Player,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following statement contains a magic number: switch (newDirection) {                  case Keys.Up:                      direction_ = Direction.Up;                      usedFramesIndex_ = new int[] { 0' 7' 8 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.Y += 1;                          position_.DeltaPixel.Y -= 16;                      }                      break;                  case Keys.Down:                      direction_ = Direction.Down;                      usedFramesIndex_ = new int[] { 0' 3' 4 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.Y -= 1;                          position_.DeltaPixel.Y += 16;                      }                      break;                  case Keys.Left:                      direction_ = Direction.Left;                      usedFramesIndex_ = new int[] { 0' 5' 6 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.X += 1;                          position_.DeltaPixel.X -= 16;                      }                      break;                  case Keys.Right:                      direction_ = Direction.Right;                      usedFramesIndex_ = new int[] { 0' 1' 2 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.X -= 1;                          position_.DeltaPixel.X += 16;                      }                      break;              }
Magic Number,XNAPacMan,Player,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following statement contains a magic number: switch (newDirection) {                  case Keys.Up:                      direction_ = Direction.Up;                      usedFramesIndex_ = new int[] { 0' 7' 8 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.Y += 1;                          position_.DeltaPixel.Y -= 16;                      }                      break;                  case Keys.Down:                      direction_ = Direction.Down;                      usedFramesIndex_ = new int[] { 0' 3' 4 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.Y -= 1;                          position_.DeltaPixel.Y += 16;                      }                      break;                  case Keys.Left:                      direction_ = Direction.Left;                      usedFramesIndex_ = new int[] { 0' 5' 6 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.X += 1;                          position_.DeltaPixel.X -= 16;                      }                      break;                  case Keys.Right:                      direction_ = Direction.Right;                      usedFramesIndex_ = new int[] { 0' 1' 2 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.X -= 1;                          position_.DeltaPixel.X += 16;                      }                      break;              }
Magic Number,XNAPacMan,Player,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following statement contains a magic number: switch (newDirection) {                  case Keys.Up:                      direction_ = Direction.Up;                      usedFramesIndex_ = new int[] { 0' 7' 8 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.Y += 1;                          position_.DeltaPixel.Y -= 16;                      }                      break;                  case Keys.Down:                      direction_ = Direction.Down;                      usedFramesIndex_ = new int[] { 0' 3' 4 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.Y -= 1;                          position_.DeltaPixel.Y += 16;                      }                      break;                  case Keys.Left:                      direction_ = Direction.Left;                      usedFramesIndex_ = new int[] { 0' 5' 6 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.X += 1;                          position_.DeltaPixel.X -= 16;                      }                      break;                  case Keys.Right:                      direction_ = Direction.Right;                      usedFramesIndex_ = new int[] { 0' 1' 2 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.X -= 1;                          position_.DeltaPixel.X += 16;                      }                      break;              }
Magic Number,XNAPacMan,Player,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following statement contains a magic number: switch (newDirection) {                  case Keys.Up:                      direction_ = Direction.Up;                      usedFramesIndex_ = new int[] { 0' 7' 8 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.Y += 1;                          position_.DeltaPixel.Y -= 16;                      }                      break;                  case Keys.Down:                      direction_ = Direction.Down;                      usedFramesIndex_ = new int[] { 0' 3' 4 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.Y -= 1;                          position_.DeltaPixel.Y += 16;                      }                      break;                  case Keys.Left:                      direction_ = Direction.Left;                      usedFramesIndex_ = new int[] { 0' 5' 6 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.X += 1;                          position_.DeltaPixel.X -= 16;                      }                      break;                  case Keys.Right:                      direction_ = Direction.Right;                      usedFramesIndex_ = new int[] { 0' 1' 2 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.X -= 1;                          position_.DeltaPixel.X += 16;                      }                      break;              }
Magic Number,XNAPacMan,XNAPacMan,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\XNAPacMan.cs,XNAPacMan,The following statement contains a magic number: graphics_.PreferredBackBufferHeight = 720;
Magic Number,XNAPacMan,XNAPacMan,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\XNAPacMan.cs,XNAPacMan,The following statement contains a magic number: graphics_.PreferredBackBufferWidth = 640;
Missing Default,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,StateEval,The following switch statement is missing a default case: switch (State) {                  case GhostState.Home:                      // Ghost exit the home state for the scatter state when they get to the row                      // above the home                      if (position_.Tile.Y == 11 && position_.DeltaPixel.Y == 0) {                          // Select inital direction based on scatter tiles                          if (Constants.scatterTiles(identity_)[0].X < 13) {                              direction_ = Direction.Left;                          } else {                              direction_ = Direction.Right;                          }                          if (scatterModesLeft_ > 0) {                              State = GhostState.Scatter;                          } else {                              State = GhostState.Attack;                          }                          return;                      }                          // Ghosts move up when they are aligned with the entrance                      else if (position_.Tile.X == 13 && position_.DeltaPixel.X == 8) {                          direction_ = Direction.Up;                      }                          // When on one side' move towards middle when on the bottom and time's up                          // If time's not up' keep bouncing up and down                      else if ((position_.DeltaPixel.Y == 8) &&                              ((position_.Tile.X == 11 && position_.DeltaPixel.X == 8) ||                               (position_.Tile.X == 15 && position_.DeltaPixel.X == 8))) {                          if (position_.Tile.Y == 14) {                              initialJumps_--;                              if (initialJumps_ == 0) {                                  if (position_.Tile.X == 11) {                                      direction_ = Direction.Right;                                  } else {                                      direction_ = Direction.Left;                                  }                              } else {                                  direction_ = Direction.Up;                              }                          } else if (position_.Tile.Y == 13) {                              direction_ = Direction.Down;                          }                      }                      break;                  case GhostState.Scatter:                      // Attempt to reverse direction upon entering this state                      if (previousState_ == GhostState.Attack) {                          scatterModesLeft_--;                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      }                      AIScatter();                      int timeInScatterMode = scatterModesLeft_ <= 2 ? 5 : 7;                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(timeInScatterMode)) {                          State = GhostState.Attack;                      }                      break;                  case GhostState.Dead:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Dead && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIDead();                      }                      if (position_.DeltaPixel.X == 8 && position_.DeltaPixel.Y == 8) {                          if (position_.Tile.Y == 14) {                              State = GhostState.Home;                          }                      }                      break;                  case GhostState.Attack:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Attack && previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          AIAttack();                      }                        if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(20)) {                          State = GhostState.Scatter;                      }                      break;                  case GhostState.Blue:                      // Attempt to reverse direction upon entering this state                      if (previousState_ != GhostState.Blue) {                          if (NextTile(OppositeDirection(direction_)).IsOpen) {                              direction_ = OppositeDirection(direction_);                          }                      } else {                          // TODO : make special blue AI                          AIAttack();                      }                        // When blue time is over' revert to attack mode.                      if ((DateTime.Now - timeInCurrentState) > TimeSpan.FromSeconds(Constants.BlueTime())) {                          State = GhostState.Attack;                      }                      break;              }
Missing Default,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Move,The following switch statement is missing a default case: switch (direction_) {                      case Direction.Up:                          position_.DeltaPixel.Y--;                          if (position_.DeltaPixel.Y < 0) {                              position_.DeltaPixel.Y = 15;                              position_.Tile.Y--;                          }                          break;                      case Direction.Down:                          position_.DeltaPixel.Y++;                          if (position_.DeltaPixel.Y > 15) {                              position_.DeltaPixel.Y = 0;                              position_.Tile.Y++;                          }                          break;                      case Direction.Left:                          position_.DeltaPixel.X--;                          if (position_.DeltaPixel.X < 0) {                              position_.DeltaPixel.X = 15;                              position_.Tile.X--;                              // Special case : the tunnel                              if (position_.Tile.X < 0) {                                  position_.Tile.X = Grid.Width - 1;                              }                          }                          break;                      case Direction.Right:                          position_.DeltaPixel.X++;                          if (position_.DeltaPixel.X > 15) {                              position_.DeltaPixel.X = 0;                              position_.Tile.X++;                              // Special case : the tunnel                              if (position_.Tile.X > Grid.Width - 1) {                                  position_.Tile.X = 0;                              }                          }                          break;                  }
Missing Default,XNAPacMan,Ghost,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Ghost.cs,Draw,The following switch statement is missing a default case: switch (direction_) {                  case Direction.Up:                      eyesBasePosition.Y -= 2;                      eyesCenterPosition.X = eyesBasePosition.X + 2;                      eyesCenterPosition.Y = eyesBasePosition.Y;                      break;                  case Direction.Down:                      eyesBasePosition.Y += 2;                      eyesCenterPosition.X = eyesBasePosition.X + 2;                      eyesCenterPosition.Y = eyesBasePosition.Y + 6;                      break;                  case Direction.Left:                      eyesBasePosition.X -= 2;                      eyesCenterPosition.X = eyesBasePosition.X;                      eyesCenterPosition.Y = eyesBasePosition.Y + 3;                      break;                  case Direction.Right:                      eyesBasePosition.X += 2;                      eyesCenterPosition.X = eyesBasePosition.X + 4;                      eyesCenterPosition.Y = eyesBasePosition.Y + 3;                      break;              }
Missing Default,XNAPacMan,Player,D:\research\architectureSmells\repos\CartBlanche_MonoGame-Samples\XNAPacMan\Player.cs,DoTurn,The following switch statement is missing a default case: switch (newDirection) {                  case Keys.Up:                      direction_ = Direction.Up;                      usedFramesIndex_ = new int[] { 0' 7' 8 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.Y += 1;                          position_.DeltaPixel.Y -= 16;                      }                      break;                  case Keys.Down:                      direction_ = Direction.Down;                      usedFramesIndex_ = new int[] { 0' 3' 4 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.Y -= 1;                          position_.DeltaPixel.Y += 16;                      }                      break;                  case Keys.Left:                      direction_ = Direction.Left;                      usedFramesIndex_ = new int[] { 0' 5' 6 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.X += 1;                          position_.DeltaPixel.X -= 16;                      }                      break;                  case Keys.Right:                      direction_ = Direction.Right;                      usedFramesIndex_ = new int[] { 0' 1' 2 };                      if (position_.DeltaPixel != Point.Zero) {                          position_.Tile.X -= 1;                          position_.DeltaPixel.X += 16;                      }                      break;              }
