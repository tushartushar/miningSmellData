Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Particle3DSample,Particle3DSampleGame,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\Game.cs,UpdateCamera,Cyclomatic complexity of the method is 10
Complex Conditional,Particle3DSample,Particle3DSampleGame,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\Game.cs,HandleInput,The conditional expression  "((currentKeyboardState.IsKeyDown (Keys.Space) &&   		(lastKeyboardState.IsKeyUp (Keys.Space))) ||   		((currentGamePadState.Buttons.A == ButtonState.Pressed)) &&   		(lastGamePadState.Buttons.A == ButtonState.Released))"  is complex.
Magic Number,Particle3DSample,Particle3DSampleGame,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\Game.cs,Particle3DSampleGame,The following statement contains a magic number: smokePlumeParticles.DrawOrder = 100;
Magic Number,Particle3DSample,Particle3DSampleGame,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\Game.cs,Particle3DSampleGame,The following statement contains a magic number: explosionSmokeParticles.DrawOrder = 200;
Magic Number,Particle3DSample,Particle3DSampleGame,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\Game.cs,Particle3DSampleGame,The following statement contains a magic number: projectileTrailParticles.DrawOrder = 300;
Magic Number,Particle3DSample,Particle3DSampleGame,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\Game.cs,Particle3DSampleGame,The following statement contains a magic number: explosionParticles.DrawOrder = 400;
Magic Number,Particle3DSample,Particle3DSampleGame,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\Game.cs,Particle3DSampleGame,The following statement contains a magic number: fireParticles.DrawOrder = 500;
Magic Number,Particle3DSample,Particle3DSampleGame,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\Game.cs,UpdateFire,The following statement contains a magic number: const  			int fireParticlesPerFrame = 20 ;
Magic Number,Particle3DSample,Particle3DSampleGame,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\Game.cs,RandomPointOnCircle,The following statement contains a magic number: const  			float radius = 30 ;
Magic Number,Particle3DSample,Particle3DSampleGame,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\Game.cs,RandomPointOnCircle,The following statement contains a magic number: const  			float height = 40 ;
Magic Number,Particle3DSample,Particle3DSampleGame,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\Game.cs,RandomPointOnCircle,The following statement contains a magic number: double angle = random.NextDouble () * Math.PI * 2;
Magic Number,Particle3DSample,Particle3DSampleGame,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\Game.cs,Draw,The following statement contains a magic number: Matrix view = Matrix.CreateTranslation (0' -25' 0) *   			Matrix.CreateRotationY (MathHelper.ToRadians (cameraRotation)) *   			Matrix.CreateRotationX (MathHelper.ToRadians (cameraArc)) *   			Matrix.CreateLookAt (new Vector3 (0' 0' -cameraDistance)'   						new Vector3 (0' 0' 0)' Vector3.Up);
Magic Number,Particle3DSample,Particle3DSampleGame,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\Game.cs,Draw,The following statement contains a magic number: Matrix projection = Matrix.CreatePerspectiveFieldOfView (MathHelper.PiOver4'   								aspectRatio'   								1' 10000);
Magic Number,Particle3DSample,Particle3DSampleGame,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\Game.cs,DrawMessage,The following statement contains a magic number: spriteBatch.DrawString (font' message' new Vector2 (50' 50)' Color.White);
Magic Number,Particle3DSample,Particle3DSampleGame,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\Game.cs,DrawMessage,The following statement contains a magic number: spriteBatch.DrawString (font' message' new Vector2 (50' 50)' Color.White);
Magic Number,Particle3DSample,Particle3DSampleGame,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\Game.cs,UpdateCamera,The following statement contains a magic number: if (cameraDistance > 500)  				cameraDistance = 500;  			else if (cameraDistance < 10)  				cameraDistance = 10;
Magic Number,Particle3DSample,Particle3DSampleGame,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\Game.cs,UpdateCamera,The following statement contains a magic number: if (cameraDistance > 500)  				cameraDistance = 500;  			else if (cameraDistance < 10)  				cameraDistance = 10;
Magic Number,Particle3DSample,Particle3DSampleGame,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\Game.cs,UpdateCamera,The following statement contains a magic number: if (cameraDistance > 500)  				cameraDistance = 500;  			else if (cameraDistance < 10)  				cameraDistance = 10;
Magic Number,Particle3DSample,Particle3DSampleGame,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\Game.cs,UpdateCamera,The following statement contains a magic number: if (cameraDistance > 500)  				cameraDistance = 500;  			else if (cameraDistance < 10)  				cameraDistance = 10;
Magic Number,Particle3DSample,Particle3DSampleGame,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\Game.cs,UpdateCamera,The following statement contains a magic number: if (currentGamePadState.Buttons.RightStick == ButtonState.Pressed ||   		currentKeyboardState.IsKeyDown (Keys.R)) {  				cameraArc = -5;  				cameraRotation = 0;  				cameraDistance = 200;  			}
Magic Number,Particle3DSample,Particle3DSampleGame,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\Game.cs,UpdateCamera,The following statement contains a magic number: if (currentGamePadState.Buttons.RightStick == ButtonState.Pressed ||   		currentKeyboardState.IsKeyDown (Keys.R)) {  				cameraArc = -5;  				cameraRotation = 0;  				cameraDistance = 200;  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,LoadContent,The following statement contains a magic number: particles = new ParticleVertex[settings.MaxParticles * 4];
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < settings.MaxParticles; i++) {  				particles [i * 4 + 0].Corner = new Short2 (-1' -1);  				particles [i * 4 + 1].Corner = new Short2 (1' -1);  				particles [i * 4 + 2].Corner = new Short2 (1' 1);  				particles [i * 4 + 3].Corner = new Short2 (-1' 1);  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < settings.MaxParticles; i++) {  				particles [i * 4 + 0].Corner = new Short2 (-1' -1);  				particles [i * 4 + 1].Corner = new Short2 (1' -1);  				particles [i * 4 + 2].Corner = new Short2 (1' 1);  				particles [i * 4 + 3].Corner = new Short2 (-1' 1);  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < settings.MaxParticles; i++) {  				particles [i * 4 + 0].Corner = new Short2 (-1' -1);  				particles [i * 4 + 1].Corner = new Short2 (1' -1);  				particles [i * 4 + 2].Corner = new Short2 (1' 1);  				particles [i * 4 + 3].Corner = new Short2 (-1' 1);  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < settings.MaxParticles; i++) {  				particles [i * 4 + 0].Corner = new Short2 (-1' -1);  				particles [i * 4 + 1].Corner = new Short2 (1' -1);  				particles [i * 4 + 2].Corner = new Short2 (1' 1);  				particles [i * 4 + 3].Corner = new Short2 (-1' 1);  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < settings.MaxParticles; i++) {  				particles [i * 4 + 0].Corner = new Short2 (-1' -1);  				particles [i * 4 + 1].Corner = new Short2 (1' -1);  				particles [i * 4 + 2].Corner = new Short2 (1' 1);  				particles [i * 4 + 3].Corner = new Short2 (-1' 1);  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < settings.MaxParticles; i++) {  				particles [i * 4 + 0].Corner = new Short2 (-1' -1);  				particles [i * 4 + 1].Corner = new Short2 (1' -1);  				particles [i * 4 + 2].Corner = new Short2 (1' 1);  				particles [i * 4 + 3].Corner = new Short2 (-1' 1);  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,LoadContent,The following statement contains a magic number: vertexBuffer = new DynamicVertexBuffer (GraphicsDevice' ParticleVertex.VertexDeclaration'  						settings.MaxParticles * 4' BufferUsage.WriteOnly);
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,LoadContent,The following statement contains a magic number: ushort[] indices = new ushort[settings.MaxParticles * 6];
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < settings.MaxParticles; i++) {  				indices [i * 6 + 0] = (ushort)(i * 4 + 0);  				indices [i * 6 + 1] = (ushort)(i * 4 + 1);  				indices [i * 6 + 2] = (ushort)(i * 4 + 2);    				indices [i * 6 + 3] = (ushort)(i * 4 + 0);  				indices [i * 6 + 4] = (ushort)(i * 4 + 2);  				indices [i * 6 + 5] = (ushort)(i * 4 + 3);  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < settings.MaxParticles; i++) {  				indices [i * 6 + 0] = (ushort)(i * 4 + 0);  				indices [i * 6 + 1] = (ushort)(i * 4 + 1);  				indices [i * 6 + 2] = (ushort)(i * 4 + 2);    				indices [i * 6 + 3] = (ushort)(i * 4 + 0);  				indices [i * 6 + 4] = (ushort)(i * 4 + 2);  				indices [i * 6 + 5] = (ushort)(i * 4 + 3);  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < settings.MaxParticles; i++) {  				indices [i * 6 + 0] = (ushort)(i * 4 + 0);  				indices [i * 6 + 1] = (ushort)(i * 4 + 1);  				indices [i * 6 + 2] = (ushort)(i * 4 + 2);    				indices [i * 6 + 3] = (ushort)(i * 4 + 0);  				indices [i * 6 + 4] = (ushort)(i * 4 + 2);  				indices [i * 6 + 5] = (ushort)(i * 4 + 3);  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < settings.MaxParticles; i++) {  				indices [i * 6 + 0] = (ushort)(i * 4 + 0);  				indices [i * 6 + 1] = (ushort)(i * 4 + 1);  				indices [i * 6 + 2] = (ushort)(i * 4 + 2);    				indices [i * 6 + 3] = (ushort)(i * 4 + 0);  				indices [i * 6 + 4] = (ushort)(i * 4 + 2);  				indices [i * 6 + 5] = (ushort)(i * 4 + 3);  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < settings.MaxParticles; i++) {  				indices [i * 6 + 0] = (ushort)(i * 4 + 0);  				indices [i * 6 + 1] = (ushort)(i * 4 + 1);  				indices [i * 6 + 2] = (ushort)(i * 4 + 2);    				indices [i * 6 + 3] = (ushort)(i * 4 + 0);  				indices [i * 6 + 4] = (ushort)(i * 4 + 2);  				indices [i * 6 + 5] = (ushort)(i * 4 + 3);  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < settings.MaxParticles; i++) {  				indices [i * 6 + 0] = (ushort)(i * 4 + 0);  				indices [i * 6 + 1] = (ushort)(i * 4 + 1);  				indices [i * 6 + 2] = (ushort)(i * 4 + 2);    				indices [i * 6 + 3] = (ushort)(i * 4 + 0);  				indices [i * 6 + 4] = (ushort)(i * 4 + 2);  				indices [i * 6 + 5] = (ushort)(i * 4 + 3);  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < settings.MaxParticles; i++) {  				indices [i * 6 + 0] = (ushort)(i * 4 + 0);  				indices [i * 6 + 1] = (ushort)(i * 4 + 1);  				indices [i * 6 + 2] = (ushort)(i * 4 + 2);    				indices [i * 6 + 3] = (ushort)(i * 4 + 0);  				indices [i * 6 + 4] = (ushort)(i * 4 + 2);  				indices [i * 6 + 5] = (ushort)(i * 4 + 3);  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < settings.MaxParticles; i++) {  				indices [i * 6 + 0] = (ushort)(i * 4 + 0);  				indices [i * 6 + 1] = (ushort)(i * 4 + 1);  				indices [i * 6 + 2] = (ushort)(i * 4 + 2);    				indices [i * 6 + 3] = (ushort)(i * 4 + 0);  				indices [i * 6 + 4] = (ushort)(i * 4 + 2);  				indices [i * 6 + 5] = (ushort)(i * 4 + 3);  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < settings.MaxParticles; i++) {  				indices [i * 6 + 0] = (ushort)(i * 4 + 0);  				indices [i * 6 + 1] = (ushort)(i * 4 + 1);  				indices [i * 6 + 2] = (ushort)(i * 4 + 2);    				indices [i * 6 + 3] = (ushort)(i * 4 + 0);  				indices [i * 6 + 4] = (ushort)(i * 4 + 2);  				indices [i * 6 + 5] = (ushort)(i * 4 + 3);  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < settings.MaxParticles; i++) {  				indices [i * 6 + 0] = (ushort)(i * 4 + 0);  				indices [i * 6 + 1] = (ushort)(i * 4 + 1);  				indices [i * 6 + 2] = (ushort)(i * 4 + 2);    				indices [i * 6 + 3] = (ushort)(i * 4 + 0);  				indices [i * 6 + 4] = (ushort)(i * 4 + 2);  				indices [i * 6 + 5] = (ushort)(i * 4 + 3);  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < settings.MaxParticles; i++) {  				indices [i * 6 + 0] = (ushort)(i * 4 + 0);  				indices [i * 6 + 1] = (ushort)(i * 4 + 1);  				indices [i * 6 + 2] = (ushort)(i * 4 + 2);    				indices [i * 6 + 3] = (ushort)(i * 4 + 0);  				indices [i * 6 + 4] = (ushort)(i * 4 + 2);  				indices [i * 6 + 5] = (ushort)(i * 4 + 3);  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < settings.MaxParticles; i++) {  				indices [i * 6 + 0] = (ushort)(i * 4 + 0);  				indices [i * 6 + 1] = (ushort)(i * 4 + 1);  				indices [i * 6 + 2] = (ushort)(i * 4 + 2);    				indices [i * 6 + 3] = (ushort)(i * 4 + 0);  				indices [i * 6 + 4] = (ushort)(i * 4 + 2);  				indices [i * 6 + 5] = (ushort)(i * 4 + 3);  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < settings.MaxParticles; i++) {  				indices [i * 6 + 0] = (ushort)(i * 4 + 0);  				indices [i * 6 + 1] = (ushort)(i * 4 + 1);  				indices [i * 6 + 2] = (ushort)(i * 4 + 2);    				indices [i * 6 + 3] = (ushort)(i * 4 + 0);  				indices [i * 6 + 4] = (ushort)(i * 4 + 2);  				indices [i * 6 + 5] = (ushort)(i * 4 + 3);  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < settings.MaxParticles; i++) {  				indices [i * 6 + 0] = (ushort)(i * 4 + 0);  				indices [i * 6 + 1] = (ushort)(i * 4 + 1);  				indices [i * 6 + 2] = (ushort)(i * 4 + 2);    				indices [i * 6 + 3] = (ushort)(i * 4 + 0);  				indices [i * 6 + 4] = (ushort)(i * 4 + 2);  				indices [i * 6 + 5] = (ushort)(i * 4 + 3);  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < settings.MaxParticles; i++) {  				indices [i * 6 + 0] = (ushort)(i * 4 + 0);  				indices [i * 6 + 1] = (ushort)(i * 4 + 1);  				indices [i * 6 + 2] = (ushort)(i * 4 + 2);    				indices [i * 6 + 3] = (ushort)(i * 4 + 0);  				indices [i * 6 + 4] = (ushort)(i * 4 + 2);  				indices [i * 6 + 5] = (ushort)(i * 4 + 3);  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < settings.MaxParticles; i++) {  				indices [i * 6 + 0] = (ushort)(i * 4 + 0);  				indices [i * 6 + 1] = (ushort)(i * 4 + 1);  				indices [i * 6 + 2] = (ushort)(i * 4 + 2);    				indices [i * 6 + 3] = (ushort)(i * 4 + 0);  				indices [i * 6 + 4] = (ushort)(i * 4 + 2);  				indices [i * 6 + 5] = (ushort)(i * 4 + 3);  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < settings.MaxParticles; i++) {  				indices [i * 6 + 0] = (ushort)(i * 4 + 0);  				indices [i * 6 + 1] = (ushort)(i * 4 + 1);  				indices [i * 6 + 2] = (ushort)(i * 4 + 2);    				indices [i * 6 + 3] = (ushort)(i * 4 + 0);  				indices [i * 6 + 4] = (ushort)(i * 4 + 2);  				indices [i * 6 + 5] = (ushort)(i * 4 + 3);  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < settings.MaxParticles; i++) {  				indices [i * 6 + 0] = (ushort)(i * 4 + 0);  				indices [i * 6 + 1] = (ushort)(i * 4 + 1);  				indices [i * 6 + 2] = (ushort)(i * 4 + 2);    				indices [i * 6 + 3] = (ushort)(i * 4 + 0);  				indices [i * 6 + 4] = (ushort)(i * 4 + 2);  				indices [i * 6 + 5] = (ushort)(i * 4 + 3);  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,LoadContent,The following statement contains a magic number: for (int i = 0; i < settings.MaxParticles; i++) {  				indices [i * 6 + 0] = (ushort)(i * 4 + 0);  				indices [i * 6 + 1] = (ushort)(i * 4 + 1);  				indices [i * 6 + 2] = (ushort)(i * 4 + 2);    				indices [i * 6 + 3] = (ushort)(i * 4 + 0);  				indices [i * 6 + 4] = (ushort)(i * 4 + 2);  				indices [i * 6 + 5] = (ushort)(i * 4 + 3);  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,RetireActiveParticles,The following statement contains a magic number: while (firstActiveParticle != firstNewParticle) {  				// Is this particle old enough to retire?  				// We multiply the active particle index by four' because each  				// particle consists of a quad that is made up of four vertices.  				float particleAge = currentTime - particles [firstActiveParticle * 4].Time;    				if (particleAge < particleDuration)  					break;    				// Remember the time at which we retired this particle.  				particles [firstActiveParticle * 4].Time = drawCounter;    				// Move the particle from the active to the retired queue.  				firstActiveParticle++;    				if (firstActiveParticle >= settings.MaxParticles)  					firstActiveParticle = 0;  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,RetireActiveParticles,The following statement contains a magic number: while (firstActiveParticle != firstNewParticle) {  				// Is this particle old enough to retire?  				// We multiply the active particle index by four' because each  				// particle consists of a quad that is made up of four vertices.  				float particleAge = currentTime - particles [firstActiveParticle * 4].Time;    				if (particleAge < particleDuration)  					break;    				// Remember the time at which we retired this particle.  				particles [firstActiveParticle * 4].Time = drawCounter;    				// Move the particle from the active to the retired queue.  				firstActiveParticle++;    				if (firstActiveParticle >= settings.MaxParticles)  					firstActiveParticle = 0;  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,FreeRetiredParticles,The following statement contains a magic number: while (firstRetiredParticle != firstActiveParticle) {  				// Has this particle been unused long enough that  				// the GPU is sure to be finished with it?  				// We multiply the retired particle index by four' because each  				// particle consists of a quad that is made up of four vertices.  				int age = drawCounter - (int)particles [firstRetiredParticle * 4].Time;    				// The GPU is never supposed to get more than 2 frames behind the CPU.  				// We add 1 to that' just to be safe in case of buggy drivers that  				// might bend the rules and let the GPU get further behind.  				if (age < 3)  					break;    				// Move the particle from the retired to the free queue.  				firstRetiredParticle++;    				if (firstRetiredParticle >= settings.MaxParticles)  					firstRetiredParticle = 0;  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,FreeRetiredParticles,The following statement contains a magic number: while (firstRetiredParticle != firstActiveParticle) {  				// Has this particle been unused long enough that  				// the GPU is sure to be finished with it?  				// We multiply the retired particle index by four' because each  				// particle consists of a quad that is made up of four vertices.  				int age = drawCounter - (int)particles [firstRetiredParticle * 4].Time;    				// The GPU is never supposed to get more than 2 frames behind the CPU.  				// We add 1 to that' just to be safe in case of buggy drivers that  				// might bend the rules and let the GPU get further behind.  				if (age < 3)  					break;    				// Move the particle from the retired to the free queue.  				firstRetiredParticle++;    				if (firstRetiredParticle >= settings.MaxParticles)  					firstRetiredParticle = 0;  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,Draw,The following statement contains a magic number: if (firstActiveParticle != firstFreeParticle) {  				device.BlendState = settings.BlendState;  				device.DepthStencilState = DepthStencilState.DepthRead;    				// Set an effect parameter describing the viewport size. This is  				// needed to convert particle sizes into screen space point sizes.  				effectViewportScaleParameter.SetValue (new Vector2 (0.5f / device.Viewport.AspectRatio' -0.5f));    				// Set an effect parameter describing the current time. All the vertex  				// shader particle animation is keyed off this value.  				effectTimeParameter.SetValue (currentTime);    				// Set the particle vertex and index buffer.  				device.SetVertexBuffer (vertexBuffer);  				device.Indices = indexBuffer;    				// Activate the particle effect.  				foreach (EffectPass pass in particleEffect.CurrentTechnique.Passes) {  					pass.Apply ();    					if (firstActiveParticle < firstFreeParticle) {  						// If the active particles are all in one consecutive range'  						// we can draw them all in a single call.  						device.DrawIndexedPrimitives (PrimitiveType.TriangleList' 0'   						firstActiveParticle * 4' (firstFreeParticle - firstActiveParticle) * 4'   						firstActiveParticle * 6' (firstFreeParticle - firstActiveParticle) * 2);  					} else {  						// If the active particle range wraps past the end of the queue  						// back to the start' we must split them over two draw calls.  						device.DrawIndexedPrimitives (PrimitiveType.TriangleList' 0'   						firstActiveParticle * 4' (settings.MaxParticles - firstActiveParticle) * 4'   						firstActiveParticle * 6' (settings.MaxParticles - firstActiveParticle) * 2);    						if (firstFreeParticle > 0) {  							device.DrawIndexedPrimitives (PrimitiveType.TriangleList' 0'   							0' firstFreeParticle * 4'   							0' firstFreeParticle * 2);  						}  					}  				}    				// Reset some of the renderstates that we changed'  				// so as not to mess up any other subsequent drawing.  				device.DepthStencilState = DepthStencilState.Default;  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,Draw,The following statement contains a magic number: if (firstActiveParticle != firstFreeParticle) {  				device.BlendState = settings.BlendState;  				device.DepthStencilState = DepthStencilState.DepthRead;    				// Set an effect parameter describing the viewport size. This is  				// needed to convert particle sizes into screen space point sizes.  				effectViewportScaleParameter.SetValue (new Vector2 (0.5f / device.Viewport.AspectRatio' -0.5f));    				// Set an effect parameter describing the current time. All the vertex  				// shader particle animation is keyed off this value.  				effectTimeParameter.SetValue (currentTime);    				// Set the particle vertex and index buffer.  				device.SetVertexBuffer (vertexBuffer);  				device.Indices = indexBuffer;    				// Activate the particle effect.  				foreach (EffectPass pass in particleEffect.CurrentTechnique.Passes) {  					pass.Apply ();    					if (firstActiveParticle < firstFreeParticle) {  						// If the active particles are all in one consecutive range'  						// we can draw them all in a single call.  						device.DrawIndexedPrimitives (PrimitiveType.TriangleList' 0'   						firstActiveParticle * 4' (firstFreeParticle - firstActiveParticle) * 4'   						firstActiveParticle * 6' (firstFreeParticle - firstActiveParticle) * 2);  					} else {  						// If the active particle range wraps past the end of the queue  						// back to the start' we must split them over two draw calls.  						device.DrawIndexedPrimitives (PrimitiveType.TriangleList' 0'   						firstActiveParticle * 4' (settings.MaxParticles - firstActiveParticle) * 4'   						firstActiveParticle * 6' (settings.MaxParticles - firstActiveParticle) * 2);    						if (firstFreeParticle > 0) {  							device.DrawIndexedPrimitives (PrimitiveType.TriangleList' 0'   							0' firstFreeParticle * 4'   							0' firstFreeParticle * 2);  						}  					}  				}    				// Reset some of the renderstates that we changed'  				// so as not to mess up any other subsequent drawing.  				device.DepthStencilState = DepthStencilState.Default;  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,Draw,The following statement contains a magic number: if (firstActiveParticle != firstFreeParticle) {  				device.BlendState = settings.BlendState;  				device.DepthStencilState = DepthStencilState.DepthRead;    				// Set an effect parameter describing the viewport size. This is  				// needed to convert particle sizes into screen space point sizes.  				effectViewportScaleParameter.SetValue (new Vector2 (0.5f / device.Viewport.AspectRatio' -0.5f));    				// Set an effect parameter describing the current time. All the vertex  				// shader particle animation is keyed off this value.  				effectTimeParameter.SetValue (currentTime);    				// Set the particle vertex and index buffer.  				device.SetVertexBuffer (vertexBuffer);  				device.Indices = indexBuffer;    				// Activate the particle effect.  				foreach (EffectPass pass in particleEffect.CurrentTechnique.Passes) {  					pass.Apply ();    					if (firstActiveParticle < firstFreeParticle) {  						// If the active particles are all in one consecutive range'  						// we can draw them all in a single call.  						device.DrawIndexedPrimitives (PrimitiveType.TriangleList' 0'   						firstActiveParticle * 4' (firstFreeParticle - firstActiveParticle) * 4'   						firstActiveParticle * 6' (firstFreeParticle - firstActiveParticle) * 2);  					} else {  						// If the active particle range wraps past the end of the queue  						// back to the start' we must split them over two draw calls.  						device.DrawIndexedPrimitives (PrimitiveType.TriangleList' 0'   						firstActiveParticle * 4' (settings.MaxParticles - firstActiveParticle) * 4'   						firstActiveParticle * 6' (settings.MaxParticles - firstActiveParticle) * 2);    						if (firstFreeParticle > 0) {  							device.DrawIndexedPrimitives (PrimitiveType.TriangleList' 0'   							0' firstFreeParticle * 4'   							0' firstFreeParticle * 2);  						}  					}  				}    				// Reset some of the renderstates that we changed'  				// so as not to mess up any other subsequent drawing.  				device.DepthStencilState = DepthStencilState.Default;  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,Draw,The following statement contains a magic number: if (firstActiveParticle != firstFreeParticle) {  				device.BlendState = settings.BlendState;  				device.DepthStencilState = DepthStencilState.DepthRead;    				// Set an effect parameter describing the viewport size. This is  				// needed to convert particle sizes into screen space point sizes.  				effectViewportScaleParameter.SetValue (new Vector2 (0.5f / device.Viewport.AspectRatio' -0.5f));    				// Set an effect parameter describing the current time. All the vertex  				// shader particle animation is keyed off this value.  				effectTimeParameter.SetValue (currentTime);    				// Set the particle vertex and index buffer.  				device.SetVertexBuffer (vertexBuffer);  				device.Indices = indexBuffer;    				// Activate the particle effect.  				foreach (EffectPass pass in particleEffect.CurrentTechnique.Passes) {  					pass.Apply ();    					if (firstActiveParticle < firstFreeParticle) {  						// If the active particles are all in one consecutive range'  						// we can draw them all in a single call.  						device.DrawIndexedPrimitives (PrimitiveType.TriangleList' 0'   						firstActiveParticle * 4' (firstFreeParticle - firstActiveParticle) * 4'   						firstActiveParticle * 6' (firstFreeParticle - firstActiveParticle) * 2);  					} else {  						// If the active particle range wraps past the end of the queue  						// back to the start' we must split them over two draw calls.  						device.DrawIndexedPrimitives (PrimitiveType.TriangleList' 0'   						firstActiveParticle * 4' (settings.MaxParticles - firstActiveParticle) * 4'   						firstActiveParticle * 6' (settings.MaxParticles - firstActiveParticle) * 2);    						if (firstFreeParticle > 0) {  							device.DrawIndexedPrimitives (PrimitiveType.TriangleList' 0'   							0' firstFreeParticle * 4'   							0' firstFreeParticle * 2);  						}  					}  				}    				// Reset some of the renderstates that we changed'  				// so as not to mess up any other subsequent drawing.  				device.DepthStencilState = DepthStencilState.Default;  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,Draw,The following statement contains a magic number: if (firstActiveParticle != firstFreeParticle) {  				device.BlendState = settings.BlendState;  				device.DepthStencilState = DepthStencilState.DepthRead;    				// Set an effect parameter describing the viewport size. This is  				// needed to convert particle sizes into screen space point sizes.  				effectViewportScaleParameter.SetValue (new Vector2 (0.5f / device.Viewport.AspectRatio' -0.5f));    				// Set an effect parameter describing the current time. All the vertex  				// shader particle animation is keyed off this value.  				effectTimeParameter.SetValue (currentTime);    				// Set the particle vertex and index buffer.  				device.SetVertexBuffer (vertexBuffer);  				device.Indices = indexBuffer;    				// Activate the particle effect.  				foreach (EffectPass pass in particleEffect.CurrentTechnique.Passes) {  					pass.Apply ();    					if (firstActiveParticle < firstFreeParticle) {  						// If the active particles are all in one consecutive range'  						// we can draw them all in a single call.  						device.DrawIndexedPrimitives (PrimitiveType.TriangleList' 0'   						firstActiveParticle * 4' (firstFreeParticle - firstActiveParticle) * 4'   						firstActiveParticle * 6' (firstFreeParticle - firstActiveParticle) * 2);  					} else {  						// If the active particle range wraps past the end of the queue  						// back to the start' we must split them over two draw calls.  						device.DrawIndexedPrimitives (PrimitiveType.TriangleList' 0'   						firstActiveParticle * 4' (settings.MaxParticles - firstActiveParticle) * 4'   						firstActiveParticle * 6' (settings.MaxParticles - firstActiveParticle) * 2);    						if (firstFreeParticle > 0) {  							device.DrawIndexedPrimitives (PrimitiveType.TriangleList' 0'   							0' firstFreeParticle * 4'   							0' firstFreeParticle * 2);  						}  					}  				}    				// Reset some of the renderstates that we changed'  				// so as not to mess up any other subsequent drawing.  				device.DepthStencilState = DepthStencilState.Default;  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,Draw,The following statement contains a magic number: if (firstActiveParticle != firstFreeParticle) {  				device.BlendState = settings.BlendState;  				device.DepthStencilState = DepthStencilState.DepthRead;    				// Set an effect parameter describing the viewport size. This is  				// needed to convert particle sizes into screen space point sizes.  				effectViewportScaleParameter.SetValue (new Vector2 (0.5f / device.Viewport.AspectRatio' -0.5f));    				// Set an effect parameter describing the current time. All the vertex  				// shader particle animation is keyed off this value.  				effectTimeParameter.SetValue (currentTime);    				// Set the particle vertex and index buffer.  				device.SetVertexBuffer (vertexBuffer);  				device.Indices = indexBuffer;    				// Activate the particle effect.  				foreach (EffectPass pass in particleEffect.CurrentTechnique.Passes) {  					pass.Apply ();    					if (firstActiveParticle < firstFreeParticle) {  						// If the active particles are all in one consecutive range'  						// we can draw them all in a single call.  						device.DrawIndexedPrimitives (PrimitiveType.TriangleList' 0'   						firstActiveParticle * 4' (firstFreeParticle - firstActiveParticle) * 4'   						firstActiveParticle * 6' (firstFreeParticle - firstActiveParticle) * 2);  					} else {  						// If the active particle range wraps past the end of the queue  						// back to the start' we must split them over two draw calls.  						device.DrawIndexedPrimitives (PrimitiveType.TriangleList' 0'   						firstActiveParticle * 4' (settings.MaxParticles - firstActiveParticle) * 4'   						firstActiveParticle * 6' (settings.MaxParticles - firstActiveParticle) * 2);    						if (firstFreeParticle > 0) {  							device.DrawIndexedPrimitives (PrimitiveType.TriangleList' 0'   							0' firstFreeParticle * 4'   							0' firstFreeParticle * 2);  						}  					}  				}    				// Reset some of the renderstates that we changed'  				// so as not to mess up any other subsequent drawing.  				device.DepthStencilState = DepthStencilState.Default;  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,Draw,The following statement contains a magic number: if (firstActiveParticle != firstFreeParticle) {  				device.BlendState = settings.BlendState;  				device.DepthStencilState = DepthStencilState.DepthRead;    				// Set an effect parameter describing the viewport size. This is  				// needed to convert particle sizes into screen space point sizes.  				effectViewportScaleParameter.SetValue (new Vector2 (0.5f / device.Viewport.AspectRatio' -0.5f));    				// Set an effect parameter describing the current time. All the vertex  				// shader particle animation is keyed off this value.  				effectTimeParameter.SetValue (currentTime);    				// Set the particle vertex and index buffer.  				device.SetVertexBuffer (vertexBuffer);  				device.Indices = indexBuffer;    				// Activate the particle effect.  				foreach (EffectPass pass in particleEffect.CurrentTechnique.Passes) {  					pass.Apply ();    					if (firstActiveParticle < firstFreeParticle) {  						// If the active particles are all in one consecutive range'  						// we can draw them all in a single call.  						device.DrawIndexedPrimitives (PrimitiveType.TriangleList' 0'   						firstActiveParticle * 4' (firstFreeParticle - firstActiveParticle) * 4'   						firstActiveParticle * 6' (firstFreeParticle - firstActiveParticle) * 2);  					} else {  						// If the active particle range wraps past the end of the queue  						// back to the start' we must split them over two draw calls.  						device.DrawIndexedPrimitives (PrimitiveType.TriangleList' 0'   						firstActiveParticle * 4' (settings.MaxParticles - firstActiveParticle) * 4'   						firstActiveParticle * 6' (settings.MaxParticles - firstActiveParticle) * 2);    						if (firstFreeParticle > 0) {  							device.DrawIndexedPrimitives (PrimitiveType.TriangleList' 0'   							0' firstFreeParticle * 4'   							0' firstFreeParticle * 2);  						}  					}  				}    				// Reset some of the renderstates that we changed'  				// so as not to mess up any other subsequent drawing.  				device.DepthStencilState = DepthStencilState.Default;  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,Draw,The following statement contains a magic number: if (firstActiveParticle != firstFreeParticle) {  				device.BlendState = settings.BlendState;  				device.DepthStencilState = DepthStencilState.DepthRead;    				// Set an effect parameter describing the viewport size. This is  				// needed to convert particle sizes into screen space point sizes.  				effectViewportScaleParameter.SetValue (new Vector2 (0.5f / device.Viewport.AspectRatio' -0.5f));    				// Set an effect parameter describing the current time. All the vertex  				// shader particle animation is keyed off this value.  				effectTimeParameter.SetValue (currentTime);    				// Set the particle vertex and index buffer.  				device.SetVertexBuffer (vertexBuffer);  				device.Indices = indexBuffer;    				// Activate the particle effect.  				foreach (EffectPass pass in particleEffect.CurrentTechnique.Passes) {  					pass.Apply ();    					if (firstActiveParticle < firstFreeParticle) {  						// If the active particles are all in one consecutive range'  						// we can draw them all in a single call.  						device.DrawIndexedPrimitives (PrimitiveType.TriangleList' 0'   						firstActiveParticle * 4' (firstFreeParticle - firstActiveParticle) * 4'   						firstActiveParticle * 6' (firstFreeParticle - firstActiveParticle) * 2);  					} else {  						// If the active particle range wraps past the end of the queue  						// back to the start' we must split them over two draw calls.  						device.DrawIndexedPrimitives (PrimitiveType.TriangleList' 0'   						firstActiveParticle * 4' (settings.MaxParticles - firstActiveParticle) * 4'   						firstActiveParticle * 6' (settings.MaxParticles - firstActiveParticle) * 2);    						if (firstFreeParticle > 0) {  							device.DrawIndexedPrimitives (PrimitiveType.TriangleList' 0'   							0' firstFreeParticle * 4'   							0' firstFreeParticle * 2);  						}  					}  				}    				// Reset some of the renderstates that we changed'  				// so as not to mess up any other subsequent drawing.  				device.DepthStencilState = DepthStencilState.Default;  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,Draw,The following statement contains a magic number: if (firstActiveParticle != firstFreeParticle) {  				device.BlendState = settings.BlendState;  				device.DepthStencilState = DepthStencilState.DepthRead;    				// Set an effect parameter describing the viewport size. This is  				// needed to convert particle sizes into screen space point sizes.  				effectViewportScaleParameter.SetValue (new Vector2 (0.5f / device.Viewport.AspectRatio' -0.5f));    				// Set an effect parameter describing the current time. All the vertex  				// shader particle animation is keyed off this value.  				effectTimeParameter.SetValue (currentTime);    				// Set the particle vertex and index buffer.  				device.SetVertexBuffer (vertexBuffer);  				device.Indices = indexBuffer;    				// Activate the particle effect.  				foreach (EffectPass pass in particleEffect.CurrentTechnique.Passes) {  					pass.Apply ();    					if (firstActiveParticle < firstFreeParticle) {  						// If the active particles are all in one consecutive range'  						// we can draw them all in a single call.  						device.DrawIndexedPrimitives (PrimitiveType.TriangleList' 0'   						firstActiveParticle * 4' (firstFreeParticle - firstActiveParticle) * 4'   						firstActiveParticle * 6' (firstFreeParticle - firstActiveParticle) * 2);  					} else {  						// If the active particle range wraps past the end of the queue  						// back to the start' we must split them over two draw calls.  						device.DrawIndexedPrimitives (PrimitiveType.TriangleList' 0'   						firstActiveParticle * 4' (settings.MaxParticles - firstActiveParticle) * 4'   						firstActiveParticle * 6' (settings.MaxParticles - firstActiveParticle) * 2);    						if (firstFreeParticle > 0) {  							device.DrawIndexedPrimitives (PrimitiveType.TriangleList' 0'   							0' firstFreeParticle * 4'   							0' firstFreeParticle * 2);  						}  					}  				}    				// Reset some of the renderstates that we changed'  				// so as not to mess up any other subsequent drawing.  				device.DepthStencilState = DepthStencilState.Default;  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,Draw,The following statement contains a magic number: if (firstActiveParticle != firstFreeParticle) {  				device.BlendState = settings.BlendState;  				device.DepthStencilState = DepthStencilState.DepthRead;    				// Set an effect parameter describing the viewport size. This is  				// needed to convert particle sizes into screen space point sizes.  				effectViewportScaleParameter.SetValue (new Vector2 (0.5f / device.Viewport.AspectRatio' -0.5f));    				// Set an effect parameter describing the current time. All the vertex  				// shader particle animation is keyed off this value.  				effectTimeParameter.SetValue (currentTime);    				// Set the particle vertex and index buffer.  				device.SetVertexBuffer (vertexBuffer);  				device.Indices = indexBuffer;    				// Activate the particle effect.  				foreach (EffectPass pass in particleEffect.CurrentTechnique.Passes) {  					pass.Apply ();    					if (firstActiveParticle < firstFreeParticle) {  						// If the active particles are all in one consecutive range'  						// we can draw them all in a single call.  						device.DrawIndexedPrimitives (PrimitiveType.TriangleList' 0'   						firstActiveParticle * 4' (firstFreeParticle - firstActiveParticle) * 4'   						firstActiveParticle * 6' (firstFreeParticle - firstActiveParticle) * 2);  					} else {  						// If the active particle range wraps past the end of the queue  						// back to the start' we must split them over two draw calls.  						device.DrawIndexedPrimitives (PrimitiveType.TriangleList' 0'   						firstActiveParticle * 4' (settings.MaxParticles - firstActiveParticle) * 4'   						firstActiveParticle * 6' (settings.MaxParticles - firstActiveParticle) * 2);    						if (firstFreeParticle > 0) {  							device.DrawIndexedPrimitives (PrimitiveType.TriangleList' 0'   							0' firstFreeParticle * 4'   							0' firstFreeParticle * 2);  						}  					}  				}    				// Reset some of the renderstates that we changed'  				// so as not to mess up any other subsequent drawing.  				device.DepthStencilState = DepthStencilState.Default;  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,AddParticle,The following statement contains a magic number: Color randomValues = new Color ((byte)random.Next (255)'  					(byte)random.Next (255)'  					(byte)random.Next (255)'  					(byte)random.Next (255));
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,AddParticle,The following statement contains a magic number: Color randomValues = new Color ((byte)random.Next (255)'  					(byte)random.Next (255)'  					(byte)random.Next (255)'  					(byte)random.Next (255));
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,AddParticle,The following statement contains a magic number: Color randomValues = new Color ((byte)random.Next (255)'  					(byte)random.Next (255)'  					(byte)random.Next (255)'  					(byte)random.Next (255));
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,AddParticle,The following statement contains a magic number: Color randomValues = new Color ((byte)random.Next (255)'  					(byte)random.Next (255)'  					(byte)random.Next (255)'  					(byte)random.Next (255));
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,AddParticle,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  				particles [firstFreeParticle * 4 + i].Position = position;  				particles [firstFreeParticle * 4 + i].Velocity = velocity;  				particles [firstFreeParticle * 4 + i].Random = randomValues;  				particles [firstFreeParticle * 4 + i].Time = currentTime;  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,AddParticle,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  				particles [firstFreeParticle * 4 + i].Position = position;  				particles [firstFreeParticle * 4 + i].Velocity = velocity;  				particles [firstFreeParticle * 4 + i].Random = randomValues;  				particles [firstFreeParticle * 4 + i].Time = currentTime;  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,AddParticle,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  				particles [firstFreeParticle * 4 + i].Position = position;  				particles [firstFreeParticle * 4 + i].Velocity = velocity;  				particles [firstFreeParticle * 4 + i].Random = randomValues;  				particles [firstFreeParticle * 4 + i].Time = currentTime;  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,AddParticle,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  				particles [firstFreeParticle * 4 + i].Position = position;  				particles [firstFreeParticle * 4 + i].Velocity = velocity;  				particles [firstFreeParticle * 4 + i].Random = randomValues;  				particles [firstFreeParticle * 4 + i].Time = currentTime;  			}
Magic Number,Particle3DSample,ParticleSystem,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\ParticleSystem.cs,AddParticle,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  				particles [firstFreeParticle * 4 + i].Position = position;  				particles [firstFreeParticle * 4 + i].Velocity = velocity;  				particles [firstFreeParticle * 4 + i].Random = randomValues;  				particles [firstFreeParticle * 4 + i].Time = currentTime;  			}
Magic Number,Particle3DSample,Projectile,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\Projectile.cs,Projectile,The following statement contains a magic number: velocity.X = (float)(random.NextDouble() - 0.5) * sidewaysVelocityRange;
Magic Number,Particle3DSample,Projectile,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\Projectile.cs,Projectile,The following statement contains a magic number: velocity.Y = (float)(random.NextDouble() + 0.5) * verticalVelocityRange;
Magic Number,Particle3DSample,Projectile,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\Projectile.cs,Projectile,The following statement contains a magic number: velocity.Z = (float)(random.NextDouble() - 0.5) * sidewaysVelocityRange;
Missing Default,Particle3DSample,Particle3DSampleGame,C:\repos\CartBlanche_MonoGame-Samples\Particle3DSample\Game.cs,Update,The following switch statement is missing a default case: switch (currentState) {  			case ParticleState.Explosions:  				UpdateExplosions (gameTime);  				break;    			case ParticleState.SmokePlume:  				UpdateSmokePlume ();  				break;    			case ParticleState.RingOfFire:  				UpdateFire ();  				break;  			}
