Implementation smell,Namespace,Class,File,Method,Description
Long Method,Magnum.Collections,Algorithms,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Algorithms.cs,SortInPlace,The method has 141 lines of code.
Long Method,Magnum.Collections,Algorithms,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Algorithms.cs,StableSortInPlace,The method has 173 lines of code.
Long Method,Magnum.Collections,RedBlackTree<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\RedBlack.cs,DeleteItemFromRange,The method has 191 lines of code.
Long Method,Magnum.Collections,RedBlackTree<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\RedBlack.cs,Insert,The method has 116 lines of code.
Complex Method,Magnum.Extensions,ExtensionsToTimeSpan,C:\repos\phatboyg_Magnum\src\Magnum\Extensions\ExtensionsToTimeSpan.cs,ToFriendlyString,Cyclomatic complexity of the method is 13
Complex Method,Magnum.Binding,InstanceBinderContext,C:\repos\phatboyg_Magnum\src\Magnum\Binding\InstanceBinderContext.cs,CreateBinderFor,Cyclomatic complexity of the method is 8
Complex Method,Magnum.Collections,Algorithms,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Algorithms.cs,RemoveDuplicatesInPlace,Cyclomatic complexity of the method is 11
Complex Method,Magnum.Collections,Algorithms,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Algorithms.cs,FirstConsecutiveEqual,Cyclomatic complexity of the method is 9
Complex Method,Magnum.Collections,Algorithms,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Algorithms.cs,FirstConsecutiveWhere,Cyclomatic complexity of the method is 9
Complex Method,Magnum.Collections,Algorithms,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Algorithms.cs,SearchForSubsequence,Cyclomatic complexity of the method is 9
Complex Method,Magnum.Collections,Algorithms,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Algorithms.cs,ToString,Cyclomatic complexity of the method is 8
Complex Method,Magnum.Collections,Algorithms,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Algorithms.cs,RandomSubset,Cyclomatic complexity of the method is 9
Complex Method,Magnum.Collections,Algorithms,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Algorithms.cs,GenerateSortedPermutations,Cyclomatic complexity of the method is 10
Complex Method,Magnum.Collections,Algorithms,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Algorithms.cs,SortInPlace,Cyclomatic complexity of the method is 8
Complex Method,Magnum.Collections,Algorithms,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Algorithms.cs,StableSortInPlace,Cyclomatic complexity of the method is 9
Complex Method,Magnum.Collections,Algorithms,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Algorithms.cs,MergeSorted,Cyclomatic complexity of the method is 10
Complex Method,Magnum.Collections,Algorithms,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Algorithms.cs,RemoveWhere,Cyclomatic complexity of the method is 11
Complex Method,Magnum.Collections,Algorithms,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Algorithms.cs,Partition,Cyclomatic complexity of the method is 9
Complex Method,Magnum.Collections,Algorithms,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Algorithms.cs,StablePartition,Cyclomatic complexity of the method is 10
Complex Method,Magnum.Collections,Algorithms,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Algorithms.cs,Copy,Cyclomatic complexity of the method is 10
Complex Method,Magnum.Collections,Algorithms,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Algorithms.cs,Copy,Cyclomatic complexity of the method is 8
Complex Method,Magnum.Collections,Algorithms,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Algorithms.cs,RotateInPlace,Cyclomatic complexity of the method is 10
Complex Method,Magnum.Collections,BigList<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\BigList.cs,Rebalance,Cyclomatic complexity of the method is 8
Complex Method,Magnum.Collections,BigList<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\BigList.cs,GetEnumerator,Cyclomatic complexity of the method is 14
Complex Method,Magnum.Collections,BigList<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\BigList.cs,NCopiesOfNode,Cyclomatic complexity of the method is 8
Complex Method,Magnum.Collections,BigList<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\BigList.cs,AddBalancedNodeToRebalanceArray,Cyclomatic complexity of the method is 10
Complex Method,Magnum.Collections,CollectionBase<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\CollectionBase.cs,CopyTo,Cyclomatic complexity of the method is 8
Complex Method,Magnum.Collections,Deque<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Deque.cs,Insert,Cyclomatic complexity of the method is 9
Complex Method,Magnum.Collections,Deque<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Deque.cs,InsertRange,Cyclomatic complexity of the method is 15
Complex Method,Magnum.Collections,Deque<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Deque.cs,RemoveRange,Cyclomatic complexity of the method is 14
Complex Method,Magnum.Collections,MultiDictionaryBase<TKey;TValue>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\MultiDictionaryBase.cs,DebuggerDisplayString,Cyclomatic complexity of the method is 8
Complex Method,Magnum.Collections,EnumerableValuesCollection,C:\repos\phatboyg_Magnum\src\Magnum\Collections\MultiDictionaryBase.cs,Contains,Cyclomatic complexity of the method is 9
Complex Method,Magnum.Collections,EnumerableValuesCollection,C:\repos\phatboyg_Magnum\src\Magnum\Collections\MultiDictionaryBase.cs,Contains,Cyclomatic complexity of the method is 9
Complex Method,Magnum.Collections,ReadOnlyCollectionBase<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\ReadOnlyCollectionBase.cs,CopyTo,Cyclomatic complexity of the method is 8
Complex Method,Magnum.Collections,ReadOnlyCollectionBase<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\ReadOnlyCollectionBase.cs,CopyTo,Cyclomatic complexity of the method is 8
Complex Method,Magnum.Collections,ReadOnlyMultiDictionaryBase<TKey;TValue>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\ReadOnlyMultiDictionaryBase.cs,DebuggerDisplayString,Cyclomatic complexity of the method is 8
Complex Method,Magnum.Collections,RedBlackTree<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\RedBlack.cs,DeleteItemFromRange,Cyclomatic complexity of the method is 10
Complex Method,Magnum.Collections,RedBlackTree<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\RedBlack.cs,Insert,Cyclomatic complexity of the method is 15
Complex Method,Magnum.Collections,RedBlackTree<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\RedBlack.cs,ValidateSubTree,Cyclomatic complexity of the method is 8
Complex Method,Magnum.Reflection,ExtensionsForArgumentMatching,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\ExtensionsForArgumentMatching.cs,RateParameterTypeCompatibility,Cyclomatic complexity of the method is 8
Complex Method,Magnum.Reflection,ExtensionsForGenericArguments,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\ExtensionsForGenericArguments.cs,GetDeclaredGenericArguments,Cyclomatic complexity of the method is 9
Complex Method,Magnum.Parsers,ExtensionsToRangeParser,C:\repos\phatboyg_Magnum\src\Magnum\Parsers\ExtensionsToRangeParser.cs,CombineOverlappingRanges,Cyclomatic complexity of the method is 12
Complex Method,Magnum.Parsers,ExtensionsToRangeParser,C:\repos\phatboyg_Magnum\src\Magnum\Parsers\ExtensionsToRangeParser.cs,RestrictTo,Cyclomatic complexity of the method is 8
Complex Method,Magnum.Serialization.FastText,FastTextParser,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\FastText\FastTextParser.cs,ReadMapValue,Cyclomatic complexity of the method is 8
Complex Method,Magnum.Validation,DateTimeExtensions,C:\repos\phatboyg_Magnum\src\Magnum\Validation\DateTimeExtensions.cs,ToFriendlyString,Cyclomatic complexity of the method is 9
Long Parameter List,Magnum,Range<T>,C:\repos\phatboyg_Magnum\src\Magnum\Range.cs,Range,The method has 5 parameters. Parameters: lowerBound' upperBound' includeLowerBound' includeUpperBound' comparer
Long Parameter List,Magnum.Extensions,ExtensionsToDateTime,C:\repos\phatboyg_Magnum\src\Magnum\Extensions\ExtensionsToDateTime.cs,SetTime,The method has 5 parameters. Parameters: value' hour' minute' second' millisecond
Long Parameter List,Magnum.Collections,Algorithms,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Algorithms.cs,ToString,The method has 5 parameters. Parameters: collection' recursive' start' separator' end
Long Parameter List,Magnum.Collections,Algorithms,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Algorithms.cs,Copy,The method has 5 parameters. Parameters: source' sourceIndex' dest' destIndex' count
Long Parameter List,Magnum.Collections,Algorithms,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Algorithms.cs,Copy,The method has 5 parameters. Parameters: source' sourceIndex' dest' destIndex' count
Long Parameter List,Magnum.Collections,MultiDictionary<TKey;TValue>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\MultiDictionary.cs,MultiDictionary,The method has 5 parameters. Parameters: allowDuplicateValues' keyEqualityComparer' valueEqualityComparer' equalityComparer' hash
Long Parameter List,Magnum.Collections,OrderedMultiDictionary<TKey;TValue>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\OrderedMultiDictionary.cs,OrderedMultiDictionary,The method has 6 parameters. Parameters: allowDuplicateValues' keyCount' keyComparer' valueComparer' comparer' tree
Long Parameter List,Magnum.Collections,RedBlackTree<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\RedBlack.cs,InsertSplit,The method has 5 parameters. Parameters: ggparent' gparent' parent' node' rotated
Long Parameter List,Magnum.Metrics.Monitor,SuccessRateMonitor,C:\repos\phatboyg_Magnum\src\Magnum\Metrics\Monitor\SuccessRateMonitor.cs,SuccessRateMonitor,The method has 5 parameters. Parameters: monitorType' name' monitor' itemThreshold' timeThreshold
Long Identifier,Magnum.Reflection,InterfaceImplementationBuilder,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\InterfaceImplementationBuilder.cs,,The length of the parameter PropertyAccessMethodAttributes is 30.
Long Identifier,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,,The length of the parameter DateTimeShortMillisecondsFormat is 31.
Long Statement,Magnum,Range<T>,C:\repos\phatboyg_Magnum\src\Magnum\Range.cs,Equals,The length of the statement  "	        return obj._includeLowerBound.Equals(_includeLowerBound) && obj._includeUpperBound.Equals(_includeUpperBound) && Equals(obj._lowerBound' _lowerBound) && Equals(obj._upperBound' _upperBound); " is 190.
Long Statement,Magnum.Extensions,ExtensionsToDateTime,C:\repos\phatboyg_Magnum\src\Magnum\Extensions\ExtensionsToDateTime.cs,ForceUtc,The length of the statement  "			return new DateTime(value.Year' value.Month' value.Day' value.Hour' value.Minute' value.Second' value.Millisecond' DateTimeKind.Utc); " is 133.
Long Statement,Magnum.Collections,BigList<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\BigList.cs,CheckBalance,The length of the statement  "			    (root.Depth > BALANCEFACTOR && !(root.Depth - BALANCEFACTOR <= MAXFIB && Count >= FIBONACCI[root.Depth - BALANCEFACTOR]))) " is 122.
Long Statement,Magnum.Collections,ConcatNode,C:\repos\phatboyg_Magnum\src\Magnum\Collections\BigList.cs,Print,The length of the statement  "				Console.WriteLine("{0}CONCAT {1} {2} count={3} depth={4}"' prefixNode' shared ? "S" : " "' IsBalanced() ? "B" : (IsAlmostBalanced() ? "A" : " ")' count' depth); " is 160.
Long Statement,Magnum.Collections,Hash<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Hash.cs,PrintStats,The length of the statement  "			Console.WriteLine("loadFactor={0}  thresholdGrow={1}  thresholdShrink={2}"' loadFactor' thresholdGrow' thresholdShrink); " is 120.
Long Statement,Magnum.Collections,MultiDictionary<TKey;TValue>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\MultiDictionary.cs,Clone,The length of the statement  "			return new MultiDictionary<TKey' TValue>(allowDuplicateValues' keyEqualityComparer' valueEqualityComparer' equalityComparer' " is 124.
Long Statement,Magnum.Collections,MultiDictionary<TKey;TValue>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\MultiDictionary.cs,CloneContents,The length of the statement  "			MultiDictionary<TKey' TValue> newDict = new MultiDictionary<TKey' TValue>(allowDuplicateValues' keyEqualityComparer' valueEqualityComparer); " is 140.
Long Statement,Magnum.Collections,ObjectToDictionaryConverter,C:\repos\phatboyg_Magnum\src\Magnum\Collections\ObjectToDictionary.cs,CreateObjectToDictionaryConverter,The length of the statement  "			return (Func<object' IDictionary<string' object>>) dm.CreateDelegate(typeof (Func<object' IDictionary<string' object>>)); " is 121.
Long Statement,Magnum.Collections,OrderedDictionary<TKey;TValue>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\OrderedDictionary.cs,Range,The length of the statement  "			return new View(this' tree.DoubleBoundedRangeTester(NewPair(from)' fromInclusive' NewPair(to)' toInclusive)' false' false); " is 123.
Long Statement,Magnum.Collections,OrderedMultiDictionary<TKey;TValue>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\OrderedMultiDictionary.cs,Clone,The length of the statement  "			OrderedMultiDictionary<TKey' TValue> newDict = new OrderedMultiDictionary<TKey' TValue>(allowDuplicateValues' keyCount' keyComparer' valueComparer' comparer' tree.Clone()); " is 172.
Long Statement,Magnum.Collections,OrderedMultiDictionary<TKey;TValue>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\OrderedMultiDictionary.cs,CloneContents,The length of the statement  "			OrderedMultiDictionary<TKey' TValue> newDict = new OrderedMultiDictionary<TKey' TValue>(allowDuplicateValues' keyComparer' valueComparer); " is 138.
Long Statement,Magnum.Collections,Pair,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Pair.cs,ToString,The length of the statement  "			return string.Format("First: {0}' Second: {1}"' (First == null) ? "null" : First.ToString()' (Second == null) ? "null" : Second.ToString()); " is 140.
Long Statement,Magnum.CommandLineParser,ExtensionForCommandLineElementParsers,C:\repos\phatboyg_Magnum\src\Magnum\CommandLineParser\ExtensionForCommandLineElementParsers.cs,Optional,The length of the statement  "						return new Result<IEnumerable<ICommandLineElement>' ISwitchElement>(query.First() as ISwitchElement' input.Except(query)); " is 122.
Long Statement,Magnum.CommandLineParser,ExtensionForCommandLineElementParsers,C:\repos\phatboyg_Magnum\src\Magnum\CommandLineParser\ExtensionForCommandLineElementParsers.cs,Optional,The length of the statement  "						return new Result<IEnumerable<ICommandLineElement>' IDefinitionElement>(query.First() as IDefinitionElement' input.Except(query)); " is 130.
Long Statement,Magnum.CommandLineParser,ExtensionForCommandLineElementParsers,C:\repos\phatboyg_Magnum\src\Magnum\CommandLineParser\ExtensionForCommandLineElementParsers.cs,Optional,The length of the statement  "					return new Result<IEnumerable<ICommandLineElement>' IDefinitionElement>(new DefinitionElement(key' defaultValue)' input); " is 121.
Long Statement,Magnum.Cryptography.PKI,RsaCryptographyService,C:\repos\phatboyg_Magnum\src\Magnum\Cryptography\PKI\RsaCryptographyService.cs,Encrypt,The length of the statement  "            // If Length of PlainText > (Modulus Size - 11)' then PlainText will need to be broken into segments of size (Modulus Size - 11) " is 128.
Long Statement,Magnum.Cryptography.PKI,RsaCryptographyService,C:\repos\phatboyg_Magnum\src\Magnum\Cryptography\PKI\RsaCryptographyService.cs,Encrypt,The length of the statement  "            // When decrypting' if the EncryptedText string > Modulus size' it will be split into segments of size equal to Modulus Size " is 124.
Long Statement,Magnum.Cryptography.PKI,RsaCryptographyService,C:\repos\phatboyg_Magnum\src\Magnum\Cryptography\PKI\RsaCryptographyService.cs,Encrypt,The length of the statement  "            // Each of these EncryptedText segments will be decrypted individually with the resulting PlainText segments re-assembled. " is 122.
Long Statement,Magnum.Reflection,FastCollection,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\FastCollection.cs,InitializeAdd,The length of the statement  "            AddDelegate = Expression.Lambda<Action<object' object>>(Expression.Call(instance' addMethod' value)' new[] { instance' value }).Compile(); " is 138.
Long Statement,Magnum.Reflection,FastCollection,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\FastCollection.cs,InitializeRemove,The length of the statement  "            RemoveDelegate = Expression.Lambda<Action<object' object>>(Expression.Call(instance' removeMethod' value)' new[] { instance' value }).Compile(); " is 144.
Long Statement,Magnum.Reflection,FastCollection<TCollection>,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\FastCollection.cs,InitializeAdd,The length of the statement  "            AddDelegate = Expression.Lambda<Action<TCollection' object>>(Expression.Call(instance' addMethod' value)' new[] { instance' value }).Compile(); " is 143.
Long Statement,Magnum.Reflection,FastCollection<TCollection>,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\FastCollection.cs,InitializeRemove,The length of the statement  "            RemoveDelegate = Expression.Lambda<Action<TCollection' object>>(Expression.Call(instance' removeMethod' value)' new[] { instance' value }).Compile(); " is 149.
Long Statement,Magnum.Reflection,FastCollection<TCollection;TElement>,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\FastCollection.cs,InitializeAdd,The length of the statement  "            AddDelegate = Expression.Lambda<Action<TCollection' TElement>>(Expression.Call(instance' addMethod' value)' new[] { instance' value }).Compile(); " is 145.
Long Statement,Magnum.Reflection,FastCollection<TCollection;TElement>,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\FastCollection.cs,InitializeRemove,The length of the statement  "            RemoveDelegate = Expression.Lambda<Action<TCollection' TElement>>(Expression.Call(instance' removeMethod' value)' new[] { instance' value }).Compile(); " is 151.
Long Statement,Magnum.Parsers,RangeElement,C:\repos\phatboyg_Magnum\src\Magnum\Parsers\RangeElement.cs,Union,The length of the statement  "				combined = new RangeElement((Begin.Begin.CompareTo(other.Begin.Begin) <= 0) ? Begin.Begin : other.Begin.Begin' End.End); " is 120.
Long Statement,Magnum.Policies,CircuitBreaker,C:\repos\phatboyg_Magnum\src\Magnum\Policies\CircuitBreaker.cs,Reset,The length of the statement  "			_lastException = new InvalidOperationException("This is the default exception for the circuit breaker' no exception has been thrown."); " is 135.
Long Statement,Magnum.Policies,RetryPolicy,C:\repos\phatboyg_Magnum\src\Magnum\Policies\RetryPolicy.cs,Retry,The length of the statement  "			return new ExceptionPolicy(action => ImplementPolicy(action' RetryImmediately(builder.Condition' retryCount' retryAction))); " is 124.
Long Statement,Magnum.Policies,RetryPolicy,C:\repos\phatboyg_Magnum\src\Magnum\Policies\RetryPolicy.cs,Retry,The length of the statement  "			return new ExceptionPolicy(action => ImplementPolicy(action' RetryInterval(builder.Condition' intervals' retryAction))); " is 120.
Long Statement,Magnum.StateMachine,StateMachine<T>,C:\repos\phatboyg_Magnum\src\Magnum\StateMachine\StateMachine.cs,InitializeEvents,The length of the statement  "			foreach (PropertyInfo propertyInfo in machineType.GetProperties(BindingFlags.Static | BindingFlags.Public | BindingFlags.FlattenHierarchy)) " is 139.
Long Statement,Magnum.StateMachine,StateMachine<T>,C:\repos\phatboyg_Magnum\src\Magnum\StateMachine\StateMachine.cs,InitializeStates,The length of the statement  "            foreach (PropertyInfo propertyInfo in machineType.GetProperties(BindingFlags.Static | BindingFlags.Public | BindingFlags.FlattenHierarchy)) " is 139.
Long Statement,Magnum.StateMachine,StateMachine<T>,C:\repos\phatboyg_Magnum\src\Magnum\StateMachine\StateMachine.cs,SetPropertyValue,The length of the statement  "			var action = Expression.Lambda<Action<object>>(Expression.Call(propertyInfo.GetSetMethod()' valueCast)' new[] {value}).Compile(); " is 129.
Long Statement,Magnum.StateMachine,StateMachine<T>,C:\repos\phatboyg_Magnum\src\Magnum\StateMachine\StateMachine.cs,SetPropertyValue,The length of the statement  "			var action = Expression.Lambda<Action<TValue>>(Expression.Call(propertyInfo.GetSetMethod()' value)' new[] {value}).Compile(); " is 125.
Complex Conditional,Magnum.Collections,Algorithms,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Algorithms.cs,Range,The conditional expression  "start < 0 || start > list.Count || (start == list.Count && count != 0)"  is complex.
Complex Conditional,Magnum.Collections,Algorithms,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Algorithms.cs,Range,The conditional expression  "start < 0 || start > array.Length || (start == array.Length && count != 0)"  is complex.
Complex Conditional,Magnum.Collections,BigList<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\BigList.cs,Range,The conditional expression  "index < 0 || index > this.Count || (index == this.Count && count != 0)"  is complex.
Complex Conditional,Magnum.Collections,BigList<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\BigList.cs,CheckBalance,The conditional expression  "root != null &&  			    (root.Depth > BALANCEFACTOR && !(root.Depth - BALANCEFACTOR <= MAXFIB && Count >= FIBONACCI[root.Depth - BALANCEFACTOR]))"  is complex.
Complex Conditional,Magnum.Collections,RedBlackTree<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\RedBlack.cs,DeleteItemFromRange,The conditional expression  "(node.left == null || !node.left.IsRed) && (node.right == null || !node.right.IsRed)"  is complex.
Complex Conditional,Magnum.Collections,RedBlackTree<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\RedBlack.cs,DeleteItemFromRange,The conditional expression  "(sib.left == null || !sib.left.IsRed) && (sib.right == null || !sib.right.IsRed)"  is complex.
Complex Conditional,Magnum.Collections,RedBlackTree<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\RedBlack.cs,Insert,The conditional expression  "node.left != null && node.left.IsRed && node.right != null && node.right.IsRed"  is complex.
Complex Conditional,Magnum.Metrics.Monitor,SuccessRateMonitor,C:\repos\phatboyg_Magnum\src\Magnum\Metrics\Monitor\SuccessRateMonitor.cs,GetCurrentSuccessRate,The conditional expression  "completed < 0 || failed < 0 || justCompleted < 0 || justFailed < 0"  is complex.
Virtual Method Call from Constructor,Magnum.Reflection,SafePropertyVisitor,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\SafePropertyVisitor.cs,SafePropertyVisitor,The constructor "SafePropertyVisitor" calls a virtual method "Visit".
Empty Catch Block,Magnum.TypeScanning,Scanner,C:\repos\phatboyg_Magnum\src\Magnum\TypeScanning\Scanner.cs,GetAssembliesFromPath,The method has an empty catch block.
Magic Number,Magnum,CombGuid,C:\repos\phatboyg_Magnum\src\Magnum\CombGuid.cs,Generate,The following statement contains a magic number: byte[] msecsArray = BitConverter.GetBytes((long)(msecs.TotalMilliseconds/3.333333));
Magic Number,Magnum,CombGuid,C:\repos\phatboyg_Magnum\src\Magnum\CombGuid.cs,Generate,The following statement contains a magic number: Array.Copy(daysArray' daysArray.Length - 2' guidArray' guidArray.Length - 6' 2);
Magic Number,Magnum,CombGuid,C:\repos\phatboyg_Magnum\src\Magnum\CombGuid.cs,Generate,The following statement contains a magic number: Array.Copy(daysArray' daysArray.Length - 2' guidArray' guidArray.Length - 6' 2);
Magic Number,Magnum,CombGuid,C:\repos\phatboyg_Magnum\src\Magnum\CombGuid.cs,Generate,The following statement contains a magic number: Array.Copy(daysArray' daysArray.Length - 2' guidArray' guidArray.Length - 6' 2);
Magic Number,Magnum,CombGuid,C:\repos\phatboyg_Magnum\src\Magnum\CombGuid.cs,Generate,The following statement contains a magic number: Array.Copy(msecsArray' msecsArray.Length - 4' guidArray' guidArray.Length - 4' 4);
Magic Number,Magnum,CombGuid,C:\repos\phatboyg_Magnum\src\Magnum\CombGuid.cs,Generate,The following statement contains a magic number: Array.Copy(msecsArray' msecsArray.Length - 4' guidArray' guidArray.Length - 4' 4);
Magic Number,Magnum,CombGuid,C:\repos\phatboyg_Magnum\src\Magnum\CombGuid.cs,Generate,The following statement contains a magic number: Array.Copy(msecsArray' msecsArray.Length - 4' guidArray' guidArray.Length - 4' 4);
Magic Number,Magnum,Range<T>,C:\repos\phatboyg_Magnum\src\Magnum\Range.cs,GetHashCode,The following statement contains a magic number: unchecked  	        {  	            int result = _includeLowerBound.GetHashCode();  	            result = (result*397) ^ _includeUpperBound.GetHashCode();  	            result = (result*397) ^ _lowerBound.GetHashCode();  	            result = (result*397) ^ _upperBound.GetHashCode();  	            return result;  	        }
Magic Number,Magnum,Range<T>,C:\repos\phatboyg_Magnum\src\Magnum\Range.cs,GetHashCode,The following statement contains a magic number: unchecked  	        {  	            int result = _includeLowerBound.GetHashCode();  	            result = (result*397) ^ _includeUpperBound.GetHashCode();  	            result = (result*397) ^ _lowerBound.GetHashCode();  	            result = (result*397) ^ _upperBound.GetHashCode();  	            return result;  	        }
Magic Number,Magnum,Range<T>,C:\repos\phatboyg_Magnum\src\Magnum\Range.cs,GetHashCode,The following statement contains a magic number: unchecked  	        {  	            int result = _includeLowerBound.GetHashCode();  	            result = (result*397) ^ _includeUpperBound.GetHashCode();  	            result = (result*397) ^ _lowerBound.GetHashCode();  	            result = (result*397) ^ _upperBound.GetHashCode();  	            return result;  	        }
Magic Number,Magnum,FunctionTimer,C:\repos\phatboyg_Magnum\src\Magnum\FunctionTimer.cs,ToString,The following statement contains a magic number: var sb = new StringBuilder(256);
Magic Number,Magnum.Extensions,ExtensionsToDateTime,C:\repos\phatboyg_Magnum\src\Magnum\Extensions\ExtensionsToDateTime.cs,Next,The following statement contains a magic number: if (offsetDays <= 0)  				offsetDays += 7;
Magic Number,Magnum.Extensions,ExtensionsToDateTime,C:\repos\phatboyg_Magnum\src\Magnum\Extensions\ExtensionsToDateTime.cs,Noon,The following statement contains a magic number: return new DateTime(value.Year' value.Month' value.Day' 12' 0' 0);
Magic Number,Magnum.Extensions,ExtensionsToTimeSpan,C:\repos\phatboyg_Magnum\src\Magnum\Extensions\ExtensionsToTimeSpan.cs,Weeks,The following statement contains a magic number: return TimeSpan.FromDays(value*7);
Magic Number,Magnum.Extensions,ExtensionsToTimeSpan,C:\repos\phatboyg_Magnum\src\Magnum\Extensions\ExtensionsToTimeSpan.cs,ToFriendlyString,The following statement contains a magic number: int years = ts.Days/365;
Magic Number,Magnum.Extensions,ExtensionsToTimeSpan,C:\repos\phatboyg_Magnum\src\Magnum\Extensions\ExtensionsToTimeSpan.cs,ToFriendlyString,The following statement contains a magic number: int months = (ts.Days%365)/30;
Magic Number,Magnum.Extensions,ExtensionsToTimeSpan,C:\repos\phatboyg_Magnum\src\Magnum\Extensions\ExtensionsToTimeSpan.cs,ToFriendlyString,The following statement contains a magic number: int months = (ts.Days%365)/30;
Magic Number,Magnum.Extensions,ExtensionsToTimeSpan,C:\repos\phatboyg_Magnum\src\Magnum\Extensions\ExtensionsToTimeSpan.cs,ToFriendlyString,The following statement contains a magic number: int weeks = ((ts.Days%365)%30)/7;
Magic Number,Magnum.Extensions,ExtensionsToTimeSpan,C:\repos\phatboyg_Magnum\src\Magnum\Extensions\ExtensionsToTimeSpan.cs,ToFriendlyString,The following statement contains a magic number: int weeks = ((ts.Days%365)%30)/7;
Magic Number,Magnum.Extensions,ExtensionsToTimeSpan,C:\repos\phatboyg_Magnum\src\Magnum\Extensions\ExtensionsToTimeSpan.cs,ToFriendlyString,The following statement contains a magic number: int weeks = ((ts.Days%365)%30)/7;
Magic Number,Magnum.Extensions,ExtensionsToTimeSpan,C:\repos\phatboyg_Magnum\src\Magnum\Extensions\ExtensionsToTimeSpan.cs,ToFriendlyString,The following statement contains a magic number: int days = (((ts.Days%365)%30)%7);
Magic Number,Magnum.Extensions,ExtensionsToTimeSpan,C:\repos\phatboyg_Magnum\src\Magnum\Extensions\ExtensionsToTimeSpan.cs,ToFriendlyString,The following statement contains a magic number: int days = (((ts.Days%365)%30)%7);
Magic Number,Magnum.Extensions,ExtensionsToTimeSpan,C:\repos\phatboyg_Magnum\src\Magnum\Extensions\ExtensionsToTimeSpan.cs,ToFriendlyString,The following statement contains a magic number: int days = (((ts.Days%365)%30)%7);
Magic Number,Magnum.Extensions,ExtensionsToStream,C:\repos\phatboyg_Magnum\src\Magnum\Extensions\ExtensionsToStream.cs,ReadToEnd,The following statement contains a magic number: using (var content = new MemoryStream())  			{  				var buffer = new byte[4096];    				int read = stream.Read(buffer' 0' 4096);  				while (read > 0)  				{  					content.Write(buffer' 0' read);    					read = stream.Read(buffer' 0' 4096);  				}    				return content.ToArray();  			}
Magic Number,Magnum.Extensions,ExtensionsToStream,C:\repos\phatboyg_Magnum\src\Magnum\Extensions\ExtensionsToStream.cs,ReadToEnd,The following statement contains a magic number: using (var content = new MemoryStream())  			{  				var buffer = new byte[4096];    				int read = stream.Read(buffer' 0' 4096);  				while (read > 0)  				{  					content.Write(buffer' 0' read);    					read = stream.Read(buffer' 0' 4096);  				}    				return content.ToArray();  			}
Magic Number,Magnum.Extensions,ExtensionsToStream,C:\repos\phatboyg_Magnum\src\Magnum\Extensions\ExtensionsToStream.cs,ReadToEnd,The following statement contains a magic number: using (var content = new MemoryStream())  			{  				var buffer = new byte[4096];    				int read = stream.Read(buffer' 0' 4096);  				while (read > 0)  				{  					content.Write(buffer' 0' read);    					read = stream.Read(buffer' 0' 4096);  				}    				return content.ToArray();  			}
Magic Number,Magnum.Cryptography,DpapiCryptographyService,C:\repos\phatboyg_Magnum\src\Magnum\Cryptography\DpapiCryptographyService.cs,GenerateIv,The following statement contains a magic number: using (var c = new RijndaelManaged                                 {                                     KeySize = 256'                                     // defaults to 256' it's better to be explicit.                                     BlockSize = 256'                                     // defaults to 128 bits' so let's set this to 256 for better security                                     Mode = CipherMode.CBC'                                     Padding = PaddingMode.ISO10126'                                     // adds random padding bytes which reduces the predictability of the plain text                                 })              {                  c.GenerateIV();                  return c.IV;              }
Magic Number,Magnum.Cryptography,DpapiCryptographyService,C:\repos\phatboyg_Magnum\src\Magnum\Cryptography\DpapiCryptographyService.cs,GenerateIv,The following statement contains a magic number: using (var c = new RijndaelManaged                                 {                                     KeySize = 256'                                     // defaults to 256' it's better to be explicit.                                     BlockSize = 256'                                     // defaults to 128 bits' so let's set this to 256 for better security                                     Mode = CipherMode.CBC'                                     Padding = PaddingMode.ISO10126'                                     // adds random padding bytes which reduces the predictability of the plain text                                 })              {                  c.GenerateIV();                  return c.IV;              }
Magic Number,Magnum.Cryptography,RijndaelCryptographyService,C:\repos\phatboyg_Magnum\src\Magnum\Cryptography\RijndaelCryptographyService.cs,RijndaelCryptographyService,The following statement contains a magic number: _cipher = new RijndaelManaged                            {                                KeySize = 256'                                // defaults to 256' it's better to be explicit.                                BlockSize = 256'                                // defaults to 128 bits' so let's set this to 256 for better security                                Mode = CipherMode.CBC'                                Padding = PaddingMode.ISO10126'                                // adds random padding bytes which reduces the predictability of the plain text                            };
Magic Number,Magnum.Cryptography,RijndaelCryptographyService,C:\repos\phatboyg_Magnum\src\Magnum\Cryptography\RijndaelCryptographyService.cs,RijndaelCryptographyService,The following statement contains a magic number: _cipher = new RijndaelManaged                            {                                KeySize = 256'                                // defaults to 256' it's better to be explicit.                                BlockSize = 256'                                // defaults to 128 bits' so let's set this to 256 for better security                                Mode = CipherMode.CBC'                                Padding = PaddingMode.ISO10126'                                // adds random padding bytes which reduces the predictability of the plain text                            };
Magic Number,Magnum.Concurrency,MultipleElementImmutableQueue<T>,C:\repos\phatboyg_Magnum\src\Magnum\Concurrency\MultipleElementImmutableQueue.cs,RemoveFirst,The following statement contains a magic number: if (Count == 2)  				return new SingleElementImmutableQueue<T>(_output.Tail.Head);
Magic Number,Magnum.Concurrency,MultipleElementImmutableQueue<T>,C:\repos\phatboyg_Magnum\src\Magnum\Concurrency\MultipleElementImmutableQueue.cs,RemoveFirst,The following statement contains a magic number: if (_output.Count > 2)  				return new MultipleElementImmutableQueue<T>(_output.Tail' _input);
Magic Number,Magnum.Calendar,DaySpecs,C:\repos\phatboyg_Magnum\src\Magnum\Calendar\DefaultCalendar.cs,NthDayOfMonth,The following statement contains a magic number: _checks.Add(d=> d.Day >= (1+7*(nTh-1)));
Magic Number,Magnum.Calendar.Holidays,ChristmasDayCheck,C:\repos\phatboyg_Magnum\src\Magnum\Calendar\Holidays\ChristmasDayCheck.cs,Check,The following statement contains a magic number: return CheckMonth(dateToCheck' Months.December) &&                     dateToCheck.Day.Equals(25) &&                     IsWeekday(dateToCheck);
Magic Number,Magnum.Calendar.Holidays,ChristmasDayObserved,C:\repos\phatboyg_Magnum\src\Magnum\Calendar\Holidays\ChristmasDayObserved.cs,Check,The following statement contains a magic number: return CheckMonth(dateToCheck' Months.December) &&                     IsMonday(dateToCheck) &&                     dateToCheck.Day.Equals(26);
Magic Number,Magnum.Calendar.Holidays,ColumbusDayObserved,C:\repos\phatboyg_Magnum\src\Magnum\Calendar\Holidays\ColumbusDayObserved.cs,Check,The following statement contains a magic number: return CheckMonth(dateToCheck' Months.October) &&                     GetWeekNumberInYear(dateToCheck).Equals(2) &&                     IsMonday(dateToCheck) &&                     WhatIsThisChecking(dateToCheck);
Magic Number,Magnum.Calendar.Holidays,ColumbusDayObserved,C:\repos\phatboyg_Magnum\src\Magnum\Calendar\Holidays\ColumbusDayObserved.cs,WhatIsThisChecking,The following statement contains a magic number: return ((dateToCheck.Day - 1)/7) == 1;
Magic Number,Magnum.Calendar.Holidays,IndependenceDayCheck,C:\repos\phatboyg_Magnum\src\Magnum\Calendar\Holidays\IndependenceDayCheck.cs,Check,The following statement contains a magic number: return CheckMonth(dateToCheck' Months.July) &&                     dateToCheck.Day.Equals(4);
Magic Number,Magnum.Calendar.Holidays,IndependenceDayObservedCheck,C:\repos\phatboyg_Magnum\src\Magnum\Calendar\Holidays\IndependenceDayObservedCheck.cs,Check,The following statement contains a magic number: return CheckMonth(dateToCheck' Months.July) &&                     IsMonday(dateToCheck) &&                     dateToCheck.Day.Equals(5);
Magic Number,Magnum.Calendar.Holidays,EasterCheck,C:\repos\phatboyg_Magnum\src\Magnum\Calendar\Holidays\EasterCheck.cs,getEasterWestern,The following statement contains a magic number: int g = year % 19;
Magic Number,Magnum.Calendar.Holidays,EasterCheck,C:\repos\phatboyg_Magnum\src\Magnum\Calendar\Holidays\EasterCheck.cs,getEasterWestern,The following statement contains a magic number: int c = intDiv(year' 100);
Magic Number,Magnum.Calendar.Holidays,EasterCheck,C:\repos\phatboyg_Magnum\src\Magnum\Calendar\Holidays\EasterCheck.cs,getEasterWestern,The following statement contains a magic number: int h = (c - intDiv(c' 4) - intDiv(8 * c + 13' 25) + 19 * g + 15) % 30;
Magic Number,Magnum.Calendar.Holidays,EasterCheck,C:\repos\phatboyg_Magnum\src\Magnum\Calendar\Holidays\EasterCheck.cs,getEasterWestern,The following statement contains a magic number: int h = (c - intDiv(c' 4) - intDiv(8 * c + 13' 25) + 19 * g + 15) % 30;
Magic Number,Magnum.Calendar.Holidays,EasterCheck,C:\repos\phatboyg_Magnum\src\Magnum\Calendar\Holidays\EasterCheck.cs,getEasterWestern,The following statement contains a magic number: int h = (c - intDiv(c' 4) - intDiv(8 * c + 13' 25) + 19 * g + 15) % 30;
Magic Number,Magnum.Calendar.Holidays,EasterCheck,C:\repos\phatboyg_Magnum\src\Magnum\Calendar\Holidays\EasterCheck.cs,getEasterWestern,The following statement contains a magic number: int h = (c - intDiv(c' 4) - intDiv(8 * c + 13' 25) + 19 * g + 15) % 30;
Magic Number,Magnum.Calendar.Holidays,EasterCheck,C:\repos\phatboyg_Magnum\src\Magnum\Calendar\Holidays\EasterCheck.cs,getEasterWestern,The following statement contains a magic number: int h = (c - intDiv(c' 4) - intDiv(8 * c + 13' 25) + 19 * g + 15) % 30;
Magic Number,Magnum.Calendar.Holidays,EasterCheck,C:\repos\phatboyg_Magnum\src\Magnum\Calendar\Holidays\EasterCheck.cs,getEasterWestern,The following statement contains a magic number: int h = (c - intDiv(c' 4) - intDiv(8 * c + 13' 25) + 19 * g + 15) % 30;
Magic Number,Magnum.Calendar.Holidays,EasterCheck,C:\repos\phatboyg_Magnum\src\Magnum\Calendar\Holidays\EasterCheck.cs,getEasterWestern,The following statement contains a magic number: int h = (c - intDiv(c' 4) - intDiv(8 * c + 13' 25) + 19 * g + 15) % 30;
Magic Number,Magnum.Calendar.Holidays,EasterCheck,C:\repos\phatboyg_Magnum\src\Magnum\Calendar\Holidays\EasterCheck.cs,getEasterWestern,The following statement contains a magic number: int i = h - intDiv(h' 28) * (1 - intDiv(h' 28)                                               * intDiv(29' h + 1) * intDiv(21 - g' 11));
Magic Number,Magnum.Calendar.Holidays,EasterCheck,C:\repos\phatboyg_Magnum\src\Magnum\Calendar\Holidays\EasterCheck.cs,getEasterWestern,The following statement contains a magic number: int i = h - intDiv(h' 28) * (1 - intDiv(h' 28)                                               * intDiv(29' h + 1) * intDiv(21 - g' 11));
Magic Number,Magnum.Calendar.Holidays,EasterCheck,C:\repos\phatboyg_Magnum\src\Magnum\Calendar\Holidays\EasterCheck.cs,getEasterWestern,The following statement contains a magic number: int i = h - intDiv(h' 28) * (1 - intDiv(h' 28)                                               * intDiv(29' h + 1) * intDiv(21 - g' 11));
Magic Number,Magnum.Calendar.Holidays,EasterCheck,C:\repos\phatboyg_Magnum\src\Magnum\Calendar\Holidays\EasterCheck.cs,getEasterWestern,The following statement contains a magic number: int i = h - intDiv(h' 28) * (1 - intDiv(h' 28)                                               * intDiv(29' h + 1) * intDiv(21 - g' 11));
Magic Number,Magnum.Calendar.Holidays,EasterCheck,C:\repos\phatboyg_Magnum\src\Magnum\Calendar\Holidays\EasterCheck.cs,getEasterWestern,The following statement contains a magic number: int i = h - intDiv(h' 28) * (1 - intDiv(h' 28)                                               * intDiv(29' h + 1) * intDiv(21 - g' 11));
Magic Number,Magnum.Calendar.Holidays,EasterCheck,C:\repos\phatboyg_Magnum\src\Magnum\Calendar\Holidays\EasterCheck.cs,getEasterWestern,The following statement contains a magic number: int j = (year + intDiv(year' 4) + i + 2 - c + intDiv(c' 4)) % 7;
Magic Number,Magnum.Calendar.Holidays,EasterCheck,C:\repos\phatboyg_Magnum\src\Magnum\Calendar\Holidays\EasterCheck.cs,getEasterWestern,The following statement contains a magic number: int j = (year + intDiv(year' 4) + i + 2 - c + intDiv(c' 4)) % 7;
Magic Number,Magnum.Calendar.Holidays,EasterCheck,C:\repos\phatboyg_Magnum\src\Magnum\Calendar\Holidays\EasterCheck.cs,getEasterWestern,The following statement contains a magic number: int j = (year + intDiv(year' 4) + i + 2 - c + intDiv(c' 4)) % 7;
Magic Number,Magnum.Calendar.Holidays,EasterCheck,C:\repos\phatboyg_Magnum\src\Magnum\Calendar\Holidays\EasterCheck.cs,getEasterWestern,The following statement contains a magic number: int j = (year + intDiv(year' 4) + i + 2 - c + intDiv(c' 4)) % 7;
Magic Number,Magnum.Calendar.Holidays,EasterCheck,C:\repos\phatboyg_Magnum\src\Magnum\Calendar\Holidays\EasterCheck.cs,getEasterWestern,The following statement contains a magic number: int p = i - j + 28;
Magic Number,Magnum.Calendar.Holidays,EasterCheck,C:\repos\phatboyg_Magnum\src\Magnum\Calendar\Holidays\EasterCheck.cs,getEasterWestern,The following statement contains a magic number: int month = 4;
Magic Number,Magnum.Calendar.Holidays,EasterCheck,C:\repos\phatboyg_Magnum\src\Magnum\Calendar\Holidays\EasterCheck.cs,getEasterWestern,The following statement contains a magic number: if (p > 31)                  day = p - 31;              else                  month = 3;
Magic Number,Magnum.Calendar.Holidays,EasterCheck,C:\repos\phatboyg_Magnum\src\Magnum\Calendar\Holidays\EasterCheck.cs,getEasterWestern,The following statement contains a magic number: if (p > 31)                  day = p - 31;              else                  month = 3;
Magic Number,Magnum.Calendar.Holidays,EasterCheck,C:\repos\phatboyg_Magnum\src\Magnum\Calendar\Holidays\EasterCheck.cs,getEasterWestern,The following statement contains a magic number: if (p > 31)                  day = p - 31;              else                  month = 3;
Magic Number,Magnum.Calendar.Holidays,EasterCheck,C:\repos\phatboyg_Magnum\src\Magnum\Calendar\Holidays\EasterCheck.cs,intDiv,The following statement contains a magic number: if (dvsr == 0)              {                  return -99999;              }
Magic Number,Magnum.Calendar.Holidays,FlagDayCheck,C:\repos\phatboyg_Magnum\src\Magnum\Calendar\Holidays\FlagDayCheck.cs,Check,The following statement contains a magic number: return CheckMonth(dateToCheck' Months.June) &&                     dateToCheck.Day.Equals(14);
Magic Number,Magnum.Calendar.Holidays,FlagDayObservedCheck,C:\repos\phatboyg_Magnum\src\Magnum\Calendar\Holidays\FlagDayObservedCheck.cs,Check,The following statement contains a magic number: return CheckMonth(dateToCheck' Months.June) &&                     IsMonday(dateToCheck) &&                     dateToCheck.Day.Equals(15);
Magic Number,Magnum.Calendar.Holidays,LaborDayCheck,C:\repos\phatboyg_Magnum\src\Magnum\Calendar\Holidays\LaborDayCheck.cs,Check,The following statement contains a magic number: return GetWeekNumberInYear(dateToCheck).Equals(2)                     && ((dateToCheck.Day - 1)/7) == 0;
Magic Number,Magnum.Calendar.Holidays,LaborDayCheck,C:\repos\phatboyg_Magnum\src\Magnum\Calendar\Holidays\LaborDayCheck.cs,Check,The following statement contains a magic number: return GetWeekNumberInYear(dateToCheck).Equals(2)                     && ((dateToCheck.Day - 1)/7) == 0;
Magic Number,Magnum.Calendar.Holidays,MartinLutherKingDayCheck,C:\repos\phatboyg_Magnum\src\Magnum\Calendar\Holidays\MartinLutherKingDayCheck.cs,Check,The following statement contains a magic number: return dateToCheck.Month == 1 &&                     IsMonday(dateToCheck) &&                     ((dateToCheck.DayOfYear - 1)/7) == 2;
Magic Number,Magnum.Calendar.Holidays,MartinLutherKingDayCheck,C:\repos\phatboyg_Magnum\src\Magnum\Calendar\Holidays\MartinLutherKingDayCheck.cs,Check,The following statement contains a magic number: return dateToCheck.Month == 1 &&                     IsMonday(dateToCheck) &&                     ((dateToCheck.DayOfYear - 1)/7) == 2;
Magic Number,Magnum.Collections,Algorithms,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Algorithms.cs,GenerateSortedPermutations,The following statement contains a magic number: for (;;)  			{  				// Find the key point -- where array[key]<array[key+1]. Everything after the  				// key is the tail.  				key = length - 2;  				while (comparer.Compare(array[key]' array[key + 1]) >= 0)  				{  					--key;  					if (key < 0)  						yield break;  				}    				// Find the last item in the tail less than key.  				swap = length - 1;  				while (comparer.Compare(array[swap]' array[key]) <= 0)  					--swap;    				// Swap it with the key.  				temp = array[key];  				array[key] = array[swap];  				array[swap] = temp;    				// Reverse the tail.  				i = key + 1;  				j = length - 1;  				while (i < j)  				{  					temp = array[i];  					array[i] = array[j];  					array[j] = temp;  					++i;  					--j;  				}    				yield return array;  			}
Magic Number,Magnum.Collections,Algorithms,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Algorithms.cs,SortInPlace,The following statement contains a magic number: int[] leftStack = new int[32]' rightStack = new int[32];
Magic Number,Magnum.Collections,Algorithms,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Algorithms.cs,SortInPlace,The following statement contains a magic number: int[] leftStack = new int[32]' rightStack = new int[32];
Magic Number,Magnum.Collections,Algorithms,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Algorithms.cs,SortInPlace,The following statement contains a magic number: for (;;)  			{  				if (l == r - 1)  				{  					// We have exactly 2 elements to sort. Compare them and swap if needed.  					T e1' e2;  					e1 = list[l];  					e2 = list[r];  					if (comparer.Compare(e1' e2) > 0)  					{  						list[r] = e1;  						list[l] = e2;  					}  					l = r; // sort complete' find other work from the stack.  				}  				else if (l < r)  				{  					// Sort the items in the inclusive range l .. r    					// Get the left' middle' and right-most elements and sort them' yielding e1=smallest' e2=median' e3=largest  					int m = l + (r - l)/2;  					T e1 = list[l]' e2 = list[m]' e3 = list[r]' temp;  					if (comparer.Compare(e1' e2) > 0)  					{  						temp = e1;  						e1 = e2;  						e2 = temp;  					}  					if (comparer.Compare(e1' e3) > 0)  					{  						temp = e3;  						e3 = e2;  						e2 = e1;  						e1 = temp;  					}  					else if (comparer.Compare(e2' e3) > 0)  					{  						temp = e2;  						e2 = e3;  						e3 = temp;  					}    					if (l == r - 2)  					{  						// We have exactly 3 elements to sort' and we've done that. Store back and we're done.  						list[l] = e1;  						list[m] = e2;  						list[r] = e3;  						l = r; // sort complete' find other work from the stack.  					}  					else  					{  						// Put the smallest at the left' largest in the middle' and the median at the right (which is the partitioning value)  						list[l] = e1;  						list[m] = e3;  						list[r] = partition = e2;    						// Partition into three parts' items <= partition' items == partition' and items >= partition  						int i = l' j = r;  						T item_i' item_j;  						for (;;)  						{  							do  							{  								++i;  								item_i = list[i];  							} while (comparer.Compare(item_i' partition) < 0);    							do  							{  								--j;  								item_j = list[j];  							} while (comparer.Compare(item_j' partition) > 0);    							if (j < i)  								break;    							list[i] = item_j;  							list[j] = item_i; // swap items to continue the partition.  						}    						// Move the partition value into place.  						list[r] = item_i;  						list[i] = partition;  						++i;    						// We have partitioned the list.   						//    Items in the inclusive range l .. j are <= partition.  						//    Items in the inclusive range i .. r are >= partition.  						//    Items in the inclusive range j+1 .. i - 1 are == partition (and in the correct final position).  						// We now need to sort l .. j and i .. r.  						// To do this' we stack one of the lists for later processing' and change l and r to the other list.  						// If we always stack the larger of the two sub-parts' the stack cannot get greater  						// than log2(Count) in size; i.e.' a 32-element stack is enough for the maximum list size.  						if ((j - l) > (r - i))  						{  							// The right partition is smaller. Stack the left' and get ready to sort the right.  							leftStack[stackPtr] = l;  							rightStack[stackPtr] = j;  							l = i;  						}  						else  						{  							// The left partition is smaller. Stack the right' and get ready to sort the left.  							leftStack[stackPtr] = i;  							rightStack[stackPtr] = r;  							r = j;  						}  						++stackPtr;  					}  				}  				else if (stackPtr > 0)  				{  					// We have a stacked sub-list to sort. Pop it off and sort it.  					--stackPtr;  					l = leftStack[stackPtr];  					r = rightStack[stackPtr];  				}  				else  				{  					// We have nothing left to sort.  					break;  				}  			}
Magic Number,Magnum.Collections,Algorithms,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Algorithms.cs,SortInPlace,The following statement contains a magic number: for (;;)  			{  				if (l == r - 1)  				{  					// We have exactly 2 elements to sort. Compare them and swap if needed.  					T e1' e2;  					e1 = list[l];  					e2 = list[r];  					if (comparer.Compare(e1' e2) > 0)  					{  						list[r] = e1;  						list[l] = e2;  					}  					l = r; // sort complete' find other work from the stack.  				}  				else if (l < r)  				{  					// Sort the items in the inclusive range l .. r    					// Get the left' middle' and right-most elements and sort them' yielding e1=smallest' e2=median' e3=largest  					int m = l + (r - l)/2;  					T e1 = list[l]' e2 = list[m]' e3 = list[r]' temp;  					if (comparer.Compare(e1' e2) > 0)  					{  						temp = e1;  						e1 = e2;  						e2 = temp;  					}  					if (comparer.Compare(e1' e3) > 0)  					{  						temp = e3;  						e3 = e2;  						e2 = e1;  						e1 = temp;  					}  					else if (comparer.Compare(e2' e3) > 0)  					{  						temp = e2;  						e2 = e3;  						e3 = temp;  					}    					if (l == r - 2)  					{  						// We have exactly 3 elements to sort' and we've done that. Store back and we're done.  						list[l] = e1;  						list[m] = e2;  						list[r] = e3;  						l = r; // sort complete' find other work from the stack.  					}  					else  					{  						// Put the smallest at the left' largest in the middle' and the median at the right (which is the partitioning value)  						list[l] = e1;  						list[m] = e3;  						list[r] = partition = e2;    						// Partition into three parts' items <= partition' items == partition' and items >= partition  						int i = l' j = r;  						T item_i' item_j;  						for (;;)  						{  							do  							{  								++i;  								item_i = list[i];  							} while (comparer.Compare(item_i' partition) < 0);    							do  							{  								--j;  								item_j = list[j];  							} while (comparer.Compare(item_j' partition) > 0);    							if (j < i)  								break;    							list[i] = item_j;  							list[j] = item_i; // swap items to continue the partition.  						}    						// Move the partition value into place.  						list[r] = item_i;  						list[i] = partition;  						++i;    						// We have partitioned the list.   						//    Items in the inclusive range l .. j are <= partition.  						//    Items in the inclusive range i .. r are >= partition.  						//    Items in the inclusive range j+1 .. i - 1 are == partition (and in the correct final position).  						// We now need to sort l .. j and i .. r.  						// To do this' we stack one of the lists for later processing' and change l and r to the other list.  						// If we always stack the larger of the two sub-parts' the stack cannot get greater  						// than log2(Count) in size; i.e.' a 32-element stack is enough for the maximum list size.  						if ((j - l) > (r - i))  						{  							// The right partition is smaller. Stack the left' and get ready to sort the right.  							leftStack[stackPtr] = l;  							rightStack[stackPtr] = j;  							l = i;  						}  						else  						{  							// The left partition is smaller. Stack the right' and get ready to sort the left.  							leftStack[stackPtr] = i;  							rightStack[stackPtr] = r;  							r = j;  						}  						++stackPtr;  					}  				}  				else if (stackPtr > 0)  				{  					// We have a stacked sub-list to sort. Pop it off and sort it.  					--stackPtr;  					l = leftStack[stackPtr];  					r = rightStack[stackPtr];  				}  				else  				{  					// We have nothing left to sort.  					break;  				}  			}
Magic Number,Magnum.Collections,Algorithms,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Algorithms.cs,StableSortInPlace,The following statement contains a magic number: int[] leftStack = new int[32]' rightStack = new int[32];
Magic Number,Magnum.Collections,Algorithms,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Algorithms.cs,StableSortInPlace,The following statement contains a magic number: int[] leftStack = new int[32]' rightStack = new int[32];
Magic Number,Magnum.Collections,Algorithms,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Algorithms.cs,StableSortInPlace,The following statement contains a magic number: for (;;)  			{  				if (l == r - 1)  				{  					// We have exactly 2 elements to sort. Compare them and swap if needed.  					T e1' e2;  					int o1' o2;  					e1 = list[l];  					o1 = order[l];  					e2 = list[r];  					o2 = order[r];  					if ((c = comparer.Compare(e1' e2)) > 0 || (c == 0 && o1 > o2))  					{  						list[r] = e1;  						order[r] = o1;  						list[l] = e2;  						order[l] = o2;  					}  					l = r; // sort complete' find other work from the stack.  				}  				else if (l < r)  				{  					// Sort the items in the inclusive range l .. r    					// Get the left' middle' and right-most elements and sort them' yielding e1=smallest' e2=median' e3=largest  					int m = l + (r - l)/2;  					T e1 = list[l]' e2 = list[m]' e3 = list[r]' temp;  					int o1 = order[l]' o2 = order[m]' o3 = order[r]' otemp;  					if ((c = comparer.Compare(e1' e2)) > 0 || (c == 0 && o1 > o2))  					{  						temp = e1;  						e1 = e2;  						e2 = temp;  						otemp = o1;  						o1 = o2;  						o2 = otemp;  					}  					if ((c = comparer.Compare(e1' e3)) > 0 || (c == 0 && o1 > o3))  					{  						temp = e3;  						e3 = e2;  						e2 = e1;  						e1 = temp;  						otemp = o3;  						o3 = o2;  						o2 = o1;  						o1 = otemp;  					}  					else if ((c = comparer.Compare(e2' e3)) > 0 || (c == 0 && o2 > o3))  					{  						temp = e2;  						e2 = e3;  						e3 = temp;  						otemp = o2;  						o2 = o3;  						o3 = otemp;  					}    					if (l == r - 2)  					{  						// We have exactly 3 elements to sort' and we've done that. Store back and we're done.  						list[l] = e1;  						list[m] = e2;  						list[r] = e3;  						order[l] = o1;  						order[m] = o2;  						order[r] = o3;  						l = r; // sort complete' find other work from the stack.  					}  					else  					{  						// Put the smallest at the left' largest in the middle' and the median at the right (which is the partitioning value)  						list[l] = e1;  						order[l] = o1;  						list[m] = e3;  						order[m] = o3;  						list[r] = partition = e2;  						order[r] = order_partition = o2;    						// Partition into three parts' items <= partition' items == partition' and items >= partition  						int i = l' j = r;  						T item_i' item_j;  						int order_i' order_j;  						for (;;)  						{  							do  							{  								++i;  								item_i = list[i];  								order_i = order[i];  							} while ((c = comparer.Compare(item_i' partition)) < 0 || (c == 0 && order_i < order_partition));    							do  							{  								--j;  								item_j = list[j];  								order_j = order[j];  							} while ((c = comparer.Compare(item_j' partition)) > 0 || (c == 0 && order_j > order_partition));    							if (j < i)  								break;    							list[i] = item_j;  							list[j] = item_i; // swap items to continue the partition.  							order[i] = order_j;  							order[j] = order_i;  						}    						// Move the partition value into place.  						list[r] = item_i;  						order[r] = order_i;  						list[i] = partition;  						order[i] = order_partition;  						++i;    						// We have partitioned the list.   						//    Items in the inclusive range l .. j are <= partition.  						//    Items in the inclusive range i .. r are >= partition.  						//    Items in the inclusive range j+1 .. i - 1 are == partition (and in the correct final position).  						// We now need to sort l .. j and i .. r.  						// To do this' we stack one of the lists for later processing' and change l and r to the other list.  						// If we always stack the larger of the two sub-parts' the stack cannot get greater  						// than log2(Count) in size; i.e.' a 32-element stack is enough for the maximum list size.  						if ((j - l) > (r - i))  						{  							// The right partition is smaller. Stack the left' and get ready to sort the right.  							leftStack[stackPtr] = l;  							rightStack[stackPtr] = j;  							l = i;  						}  						else  						{  							// The left partition is smaller. Stack the right' and get ready to sort the left.  							leftStack[stackPtr] = i;  							rightStack[stackPtr] = r;  							r = j;  						}  						++stackPtr;  					}  				}  				else if (stackPtr > 0)  				{  					// We have a stacked sub-list to sort. Pop it off and sort it.  					--stackPtr;  					l = leftStack[stackPtr];  					r = rightStack[stackPtr];  				}  				else  				{  					// We have nothing left to sort.  					break;  				}  			}
Magic Number,Magnum.Collections,Algorithms,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Algorithms.cs,StableSortInPlace,The following statement contains a magic number: for (;;)  			{  				if (l == r - 1)  				{  					// We have exactly 2 elements to sort. Compare them and swap if needed.  					T e1' e2;  					int o1' o2;  					e1 = list[l];  					o1 = order[l];  					e2 = list[r];  					o2 = order[r];  					if ((c = comparer.Compare(e1' e2)) > 0 || (c == 0 && o1 > o2))  					{  						list[r] = e1;  						order[r] = o1;  						list[l] = e2;  						order[l] = o2;  					}  					l = r; // sort complete' find other work from the stack.  				}  				else if (l < r)  				{  					// Sort the items in the inclusive range l .. r    					// Get the left' middle' and right-most elements and sort them' yielding e1=smallest' e2=median' e3=largest  					int m = l + (r - l)/2;  					T e1 = list[l]' e2 = list[m]' e3 = list[r]' temp;  					int o1 = order[l]' o2 = order[m]' o3 = order[r]' otemp;  					if ((c = comparer.Compare(e1' e2)) > 0 || (c == 0 && o1 > o2))  					{  						temp = e1;  						e1 = e2;  						e2 = temp;  						otemp = o1;  						o1 = o2;  						o2 = otemp;  					}  					if ((c = comparer.Compare(e1' e3)) > 0 || (c == 0 && o1 > o3))  					{  						temp = e3;  						e3 = e2;  						e2 = e1;  						e1 = temp;  						otemp = o3;  						o3 = o2;  						o2 = o1;  						o1 = otemp;  					}  					else if ((c = comparer.Compare(e2' e3)) > 0 || (c == 0 && o2 > o3))  					{  						temp = e2;  						e2 = e3;  						e3 = temp;  						otemp = o2;  						o2 = o3;  						o3 = otemp;  					}    					if (l == r - 2)  					{  						// We have exactly 3 elements to sort' and we've done that. Store back and we're done.  						list[l] = e1;  						list[m] = e2;  						list[r] = e3;  						order[l] = o1;  						order[m] = o2;  						order[r] = o3;  						l = r; // sort complete' find other work from the stack.  					}  					else  					{  						// Put the smallest at the left' largest in the middle' and the median at the right (which is the partitioning value)  						list[l] = e1;  						order[l] = o1;  						list[m] = e3;  						order[m] = o3;  						list[r] = partition = e2;  						order[r] = order_partition = o2;    						// Partition into three parts' items <= partition' items == partition' and items >= partition  						int i = l' j = r;  						T item_i' item_j;  						int order_i' order_j;  						for (;;)  						{  							do  							{  								++i;  								item_i = list[i];  								order_i = order[i];  							} while ((c = comparer.Compare(item_i' partition)) < 0 || (c == 0 && order_i < order_partition));    							do  							{  								--j;  								item_j = list[j];  								order_j = order[j];  							} while ((c = comparer.Compare(item_j' partition)) > 0 || (c == 0 && order_j > order_partition));    							if (j < i)  								break;    							list[i] = item_j;  							list[j] = item_i; // swap items to continue the partition.  							order[i] = order_j;  							order[j] = order_i;  						}    						// Move the partition value into place.  						list[r] = item_i;  						order[r] = order_i;  						list[i] = partition;  						order[i] = order_partition;  						++i;    						// We have partitioned the list.   						//    Items in the inclusive range l .. j are <= partition.  						//    Items in the inclusive range i .. r are >= partition.  						//    Items in the inclusive range j+1 .. i - 1 are == partition (and in the correct final position).  						// We now need to sort l .. j and i .. r.  						// To do this' we stack one of the lists for later processing' and change l and r to the other list.  						// If we always stack the larger of the two sub-parts' the stack cannot get greater  						// than log2(Count) in size; i.e.' a 32-element stack is enough for the maximum list size.  						if ((j - l) > (r - i))  						{  							// The right partition is smaller. Stack the left' and get ready to sort the right.  							leftStack[stackPtr] = l;  							rightStack[stackPtr] = j;  							l = i;  						}  						else  						{  							// The left partition is smaller. Stack the right' and get ready to sort the left.  							leftStack[stackPtr] = i;  							rightStack[stackPtr] = r;  							r = j;  						}  						++stackPtr;  					}  				}  				else if (stackPtr > 0)  				{  					// We have a stacked sub-list to sort. Pop it off and sort it.  					--stackPtr;  					l = leftStack[stackPtr];  					r = rightStack[stackPtr];  				}  				else  				{  					// We have nothing left to sort.  					break;  				}  			}
Magic Number,Magnum.Collections,Algorithms,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Algorithms.cs,BinarySearch,The following statement contains a magic number: while (r > l)  			{  				int m = l + (r - l)/2;  				T middleItem = list[m];  				int comp = comparer.Compare(middleItem' item);  				if (comp < 0)  				{  					// middleItem < item  					l = m + 1;  				}  				else if (comp > 0)  				{  					r = m;  				}  				else  				{  					// Found something equal to item at m. Now we need to find the start and end of this run of equal items.  					int lFound = l' rFound = r' found = m;    					// Find the start of the run.  					l = lFound;  					r = found;  					while (r > l)  					{  						m = l + (r - l)/2;  						middleItem = list[m];  						comp = comparer.Compare(middleItem' item);  						if (comp < 0)  						{  							// middleItem < item  							l = m + 1;  						}  						else  						{  							r = m;  						}  					}  					Debug.Assert(l == r' "Left and Right were not equal");  					index = l;    					// Find the end of the run.  					l = found;  					r = rFound;  					while (r > l)  					{  						m = l + (r - l)/2;  						middleItem = list[m];  						comp = comparer.Compare(middleItem' item);  						if (comp <= 0)  						{  							// middleItem <= item  							l = m + 1;  						}  						else  						{  							r = m;  						}  					}  					Debug.Assert(l == r' "Left and Right were not equal");  					return l - index;  				}  			}
Magic Number,Magnum.Collections,Algorithms,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Algorithms.cs,BinarySearch,The following statement contains a magic number: while (r > l)  			{  				int m = l + (r - l)/2;  				T middleItem = list[m];  				int comp = comparer.Compare(middleItem' item);  				if (comp < 0)  				{  					// middleItem < item  					l = m + 1;  				}  				else if (comp > 0)  				{  					r = m;  				}  				else  				{  					// Found something equal to item at m. Now we need to find the start and end of this run of equal items.  					int lFound = l' rFound = r' found = m;    					// Find the start of the run.  					l = lFound;  					r = found;  					while (r > l)  					{  						m = l + (r - l)/2;  						middleItem = list[m];  						comp = comparer.Compare(middleItem' item);  						if (comp < 0)  						{  							// middleItem < item  							l = m + 1;  						}  						else  						{  							r = m;  						}  					}  					Debug.Assert(l == r' "Left and Right were not equal");  					index = l;    					// Find the end of the run.  					l = found;  					r = rFound;  					while (r > l)  					{  						m = l + (r - l)/2;  						middleItem = list[m];  						comp = comparer.Compare(middleItem' item);  						if (comp <= 0)  						{  							// middleItem <= item  							l = m + 1;  						}  						else  						{  							r = m;  						}  					}  					Debug.Assert(l == r' "Left and Right were not equal");  					return l - index;  				}  			}
Magic Number,Magnum.Collections,Algorithms,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Algorithms.cs,BinarySearch,The following statement contains a magic number: while (r > l)  			{  				int m = l + (r - l)/2;  				T middleItem = list[m];  				int comp = comparer.Compare(middleItem' item);  				if (comp < 0)  				{  					// middleItem < item  					l = m + 1;  				}  				else if (comp > 0)  				{  					r = m;  				}  				else  				{  					// Found something equal to item at m. Now we need to find the start and end of this run of equal items.  					int lFound = l' rFound = r' found = m;    					// Find the start of the run.  					l = lFound;  					r = found;  					while (r > l)  					{  						m = l + (r - l)/2;  						middleItem = list[m];  						comp = comparer.Compare(middleItem' item);  						if (comp < 0)  						{  							// middleItem < item  							l = m + 1;  						}  						else  						{  							r = m;  						}  					}  					Debug.Assert(l == r' "Left and Right were not equal");  					index = l;    					// Find the end of the run.  					l = found;  					r = rFound;  					while (r > l)  					{  						m = l + (r - l)/2;  						middleItem = list[m];  						comp = comparer.Compare(middleItem' item);  						if (comp <= 0)  						{  							// middleItem <= item  							l = m + 1;  						}  						else  						{  							r = m;  						}  					}  					Debug.Assert(l == r' "Left and Right were not equal");  					return l - index;  				}  			}
Magic Number,Magnum.Collections,CollectionEqualityComparer<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Algorithms.cs,GetHashCode,The following statement contains a magic number: foreach (T t in obj)  				{  					int itemHash = Util.GetHashCode(t' equalityComparer);  					hash += itemHash;  					hash = (hash << 9) | (hash >> 23);  				}
Magic Number,Magnum.Collections,CollectionEqualityComparer<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Algorithms.cs,GetHashCode,The following statement contains a magic number: foreach (T t in obj)  				{  					int itemHash = Util.GetHashCode(t' equalityComparer);  					hash += itemHash;  					hash = (hash << 9) | (hash >> 23);  				}
Magic Number,Magnum.Collections,BigList<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\BigList.cs,Rebalance,The following statement contains a magic number: if (root.Depth <= 1 || (root.Depth - 2 <= MAXFIB && Count >= FIBONACCI[root.Depth - 2]))  				return;
Magic Number,Magnum.Collections,BigList<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\BigList.cs,Rebalance,The following statement contains a magic number: if (root.Depth <= 1 || (root.Depth - 2 <= MAXFIB && Count >= FIBONACCI[root.Depth - 2]))  				return;
Magic Number,Magnum.Collections,BigList<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\BigList.cs,Rebalance,The following statement contains a magic number: Debug.Assert(root.Depth <= 1 || (root.Depth - 2 <= MAXFIB && Count >= FIBONACCI[root.Depth - 2]));
Magic Number,Magnum.Collections,BigList<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\BigList.cs,Rebalance,The following statement contains a magic number: Debug.Assert(root.Depth <= 1 || (root.Depth - 2 <= MAXFIB && Count >= FIBONACCI[root.Depth - 2]));
Magic Number,Magnum.Collections,BigList<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\BigList.cs,NCopiesOfNode,The following statement contains a magic number: while (copies > 0)  			{  				power.MarkShared();    				if ((copies & n) != 0)  				{  					// This power of two is used in the final result.  					copies -= n;  					if (builder == null)  						builder = power;  					else  						builder = builder.Append(power' false);  				}    				n *= 2;  				power = power.Append(power' false);  			}
Magic Number,Magnum.Collections,CollectionBase<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\CollectionBase.cs,DebuggerDisplayString,The following statement contains a magic number: const int MAXLENGTH = 250;
Magic Number,Magnum.Collections,Deque<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Deque.cs,Insert,The following statement contains a magic number: if (index < count/2)  			{  				// Inserting into the first half of the list. Move items with  				// lower index down in the buffer.  				start -= 1;  				if (start < 0)  					start += length;  				i = index + start;  				if (i >= length)  				{  					i -= length;  					if (length - 1 > start)  						Array.Copy(buffer' start + 1' buffer' start' length - 1 - start);  					buffer[length - 1] = buffer[0]; // unneeded if end == 0' but doesn't hurt  					if (i > 0)  						Array.Copy(buffer' 1' buffer' 0' i);  				}  				else  				{  					if (i > start)  						Array.Copy(buffer' start + 1' buffer' start' i - start);  				}  			}  			else  			{  				// Inserting into the last half of the list. Move items with higher  				// index up in the buffer.  				i = index + start;  				if (i >= length)  					i -= length;  				if (i <= end)  				{  					if (end > i)  						Array.Copy(buffer' i' buffer' i + 1' end - i);  					end += 1;  					if (end >= length)  						end -= length;  				}  				else  				{  					if (end > 0)  						Array.Copy(buffer' 0' buffer' 1' end);  					buffer[0] = buffer[length - 1];  					if (length - 1 > i)  						Array.Copy(buffer' i' buffer' i + 1' length - 1 - i);  					end += 1;  				}  			}
Magic Number,Magnum.Collections,Deque<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Deque.cs,InsertRange,The following statement contains a magic number: if (index < count/2)  			{  				// Inserting into the first half of the list. Move items with  				// lower index down in the buffer.  				s = start;  				d = s - coll.Count;  				if (d < 0)  					d += length;  				start = d;  				int c = index;    				while (c > 0)  				{  					int chunk = c;  					if (length - d < chunk)  						chunk = length - d;  					if (length - s < chunk)  						chunk = length - s;  					Array.Copy(buffer' s' buffer' d' chunk);  					c -= chunk;  					if ((d += chunk) >= length)  						d -= length;  					if ((s += chunk) >= length)  						s -= length;  				}  			}  			else  			{  				// Inserting into the last half of the list. Move items with higher  				// index up in the buffer.  				s = end;  				d = s + coll.Count;  				if (d >= length)  					d -= length;  				end = d;  				int move = count - index; // number of items at end to move    				int c = move;  				while (c > 0)  				{  					int chunk = c;  					if (d > 0 && d < chunk)  						chunk = d;  					if (s > 0 && s < chunk)  						chunk = s;  					if ((d -= chunk) < 0)  						d += length;  					if ((s -= chunk) < 0)  						s += length;  					Array.Copy(buffer' s' buffer' d' chunk);  					c -= chunk;  				}    				d -= coll.Count;  				if (d < 0)  					d += length;  			}
Magic Number,Magnum.Collections,Deque<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Deque.cs,RemoveAt,The following statement contains a magic number: if (index < count/2)  			{  				// Removing in the first half of the list. Move items with  				// lower index up in the buffer.  				i = index + start;    				if (i >= length)  				{  					i -= length;    					if (i > 0)  						Array.Copy(buffer' 0' buffer' 1' i);  					buffer[0] = buffer[length - 1];  					if (length - 1 > start)  						Array.Copy(buffer' start' buffer' start + 1' length - 1 - start);  				}  				else  				{  					if (i > start)  						Array.Copy(buffer' start' buffer' start + 1' i - start);  				}    				buffer[start] = default(T);  				start += 1;  				if (start >= length)  					start -= length;  			}  			else  			{  				// Removing in the second half of the list. Move items with  				// higher indexes down in the buffer.  				i = index + start;  				if (i >= length)  					i -= length;  				end -= 1;  				if (end < 0)  					end = length - 1;    				if (i <= end)  				{  					if (end > i)  						Array.Copy(buffer' i + 1' buffer' i' end - i);  				}  				else  				{  					if (length - 1 > i)  						Array.Copy(buffer' i + 1' buffer' i' length - 1 - i);  					buffer[length - 1] = buffer[0];  					if (end > 0)  						Array.Copy(buffer' 1' buffer' 0' end);  				}    				buffer[end] = default(T);  			}
Magic Number,Magnum.Collections,Deque<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Deque.cs,RemoveRange,The following statement contains a magic number: if (index < dequeCount/2)  			{  				// Removing in the first half of the list. Move items with  				// lower index up in the buffer.  				s = start + index;  				if (s >= length)  					s -= length;  				d = s + count;  				if (d >= length)  					d -= length;    				int c = index;  				while (c > 0)  				{  					int chunk = c;  					if (d > 0 && d < chunk)  						chunk = d;  					if (s > 0 && s < chunk)  						chunk = s;  					if ((d -= chunk) < 0)  						d += length;  					if ((s -= chunk) < 0)  						s += length;  					Array.Copy(buffer' s' buffer' d' chunk);  					c -= chunk;  				}    				// At this point' s == start  				for (c = 0; c < count; ++c)  				{  					buffer[s] = default(T);  					if (++s >= length)  						s -= length;  				}  				start = s;  			}  			else  			{  				// Removing in the second half of the list. Move items with  				// higher indexes down in the buffer.  				int move = dequeCount - index - count;  				s = end - move;  				if (s < 0)  					s += length;  				d = s - count;  				if (d < 0)  					d += length;    				int c = move;  				while (c > 0)  				{  					int chunk = c;  					if (length - d < chunk)  						chunk = length - d;  					if (length - s < chunk)  						chunk = length - s;  					Array.Copy(buffer' s' buffer' d' chunk);  					c -= chunk;  					if ((d += chunk) >= length)  						d -= length;  					if ((s += chunk) >= length)  						s -= length;  				}    				// At this point' s == end.  				for (c = 0; c < count; ++c)  				{  					if (--s < 0)  						s += length;  					buffer[s] = default(T);  				}  				end = s;  			}
Magic Number,Magnum.Collections,Deque<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Deque.cs,IncreaseBuffer,The following statement contains a magic number: T[] newBuffer = new T[length*2];
Magic Number,Magnum.Collections,DictionaryBase<TKey;TValue>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\DictionaryBase.cs,DebuggerDisplayString,The following statement contains a magic number: const int MAXLENGTH = 250;
Magic Number,Magnum.Collections,Hash<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Hash.cs,Validate,The following statement contains a magic number: if (thresholdShrink > 1)  				Debug.Assert(thresholdGrow / 3 == thresholdShrink);  			else  				Debug.Assert(thresholdGrow / 3 <= MINSIZE);
Magic Number,Magnum.Collections,Hash<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Hash.cs,Validate,The following statement contains a magic number: if (thresholdShrink > 1)  				Debug.Assert(thresholdGrow / 3 == thresholdShrink);  			else  				Debug.Assert(thresholdGrow / 3 <= MINSIZE);
Magic Number,Magnum.Collections,Hash<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Hash.cs,GetFullHash,The following statement contains a magic number: hash += ~(hash << 15);
Magic Number,Magnum.Collections,Hash<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Hash.cs,GetFullHash,The following statement contains a magic number: hash ^= (hash >> 10);
Magic Number,Magnum.Collections,Hash<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Hash.cs,GetFullHash,The following statement contains a magic number: hash += (hash << 3);
Magic Number,Magnum.Collections,Hash<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Hash.cs,GetFullHash,The following statement contains a magic number: hash ^= (hash >> 6);
Magic Number,Magnum.Collections,Hash<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Hash.cs,GetFullHash,The following statement contains a magic number: hash += ~(hash << 11);
Magic Number,Magnum.Collections,Hash<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Hash.cs,GetFullHash,The following statement contains a magic number: hash ^= (hash >> 16);
Magic Number,Magnum.Collections,Hash<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Hash.cs,EnsureEnoughSlots,The following statement contains a magic number: if (usedSlots + additionalItems > thresholdGrow)  			{  				// We need to expand the table. Figure out to what size.  				int newSize;    				newSize = Math.Max(totalSlots' MINSIZE);  				while ((int)(newSize * loadFactor) < usedSlots + additionalItems)  				{  					newSize *= 2;  					if (newSize <= 0)  					{  						// Must have overflowed the size of an int. Hard to believe we didn't run out of memory first.  						throw new InvalidOperationException(Strings.CollectionTooLarge);  					}  				}    				ResizeTable(newSize);  			}
Magic Number,Magnum.Collections,Hash<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Hash.cs,ShrinkIfNeeded,The following statement contains a magic number: if (count < thresholdShrink)  			{  				int newSize;    				if (count > 0)  				{  					newSize = MINSIZE;  					while ((int)(newSize * loadFactor) < count)  						newSize *= 2;  				}  				else  				{  					// We've removed all the elements. Shrink to zero.  					newSize = 0;  				}    				ResizeTable(newSize);  			}
Magic Number,Magnum.Collections,Hash<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Hash.cs,ResizeTable,The following statement contains a magic number: thresholdShrink = thresholdGrow / 3;
Magic Number,Magnum.Collections,Hash<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\Hash.cs,GetSecondaryShift,The following statement contains a magic number: int x = newSize - 2;
Magic Number,Magnum.Collections,MultiDictionary<TKey;TValue>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\MultiDictionary.cs,Add,The following statement contains a magic number: if (hash.Find(keyValues' false' out existing))  			{  				// There already is an item in the hash table equal to this key. Add the new value'  				// taking into account duplicates if needed.  				int existingCount = existing.Count;  				if (!allowDuplicateValues)  				{  					int valueHash = Util.GetHashCode(value' valueEqualityComparer);  					for (int i = 0; i < existingCount; ++i)  					{  						if (Util.GetHashCode(existing.Values[i]' valueEqualityComparer) == valueHash &&  						    valueEqualityComparer.Equals(existing.Values[i]' value))  						{  							// Found an equal existing value. Replace it and we're done.  							existing.Values[i] = value;  							return;  						}  					}  				}    				// Add a new value to an existing key.  				if (existingCount == existing.Values.Length)  				{  					// Grow the array to make room.  					TValue[] newValues = new TValue[existingCount*2];  					Array.Copy(existing.Values' newValues' existingCount);  					existing.Values = newValues;  				}  				existing.Values[existingCount] = value;  				existing.Count = existingCount + 1;    				// Update the hash table.  				hash.Find(existing' true' out keyValues);  				return;  			}  			else  			{  				// No item with this key. Add it.  				keyValues.Count = 1;  				keyValues.Values = new TValue[1] {value};  				hash.Insert(keyValues' true' out existing);  				return;  			}
Magic Number,Magnum.Collections,MultiDictionaryBase<TKey;TValue>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\MultiDictionaryBase.cs,DebuggerDisplayString,The following statement contains a magic number: const int MAXLENGTH = 250;
Magic Number,Magnum.Collections,ReadOnlyCollectionBase<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\ReadOnlyCollectionBase.cs,DebuggerDisplayString,The following statement contains a magic number: const int MAXLENGTH = 250;
Magic Number,Magnum.Collections,ReadOnlyDictionaryBase<TKey;TValue>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\ReadOnlyDictionaryBase.cs,DebuggerDisplayString,The following statement contains a magic number: const int MAXLENGTH = 250;
Magic Number,Magnum.Collections,ReadOnlyMultiDictionaryBase<TKey;TValue>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\ReadOnlyMultiDictionaryBase.cs,DebuggerDisplayString,The following statement contains a magic number: const int MAXLENGTH = 250;
Magic Number,Magnum.Collections,RedBlackTree<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\RedBlack.cs,Insert,The following statement contains a magic number: while (node != null)  			{  				// If we find a node with two red children' split it so it doesn't cause problems  				// when inserting a node.  				if (node.left != null && node.left.IsRed && node.right != null && node.right.IsRed)  				{  					node = InsertSplit(ggparent' gparent' parent' node' out rotated);    					if (needStack && rotated)  					{  						nodeStackPtr -= 2;  						if (nodeStackPtr < 0)  							nodeStackPtr = 0;  					}  				}    				// Keep track of parent' grandparent' great-grand parent.  				ggparent = gparent;  				gparent = parent;  				parent = node;    				// Compare the key and the node.   				int compare = comparer.Compare(item' node.item);    				if (compare == 0)  				{  					// Found a node with the data already. Check duplicate policy.  					if (dupPolicy == DuplicatePolicy.DoNothing)  					{  						previous = node.item;    						// Didn't insert after all. Return counts back to their previous value.  						for (int i = 0; i < nodeStackPtr; ++i)  							nodeStack[i].DecrementCount();    						return false;  					}  					else if (dupPolicy == DuplicatePolicy.InsertFirst || dupPolicy == DuplicatePolicy.ReplaceFirst)  					{  						// Insert first by treating the key as less than nodes in the tree.  						duplicateFound = node;  						compare = -1;  					}  					else  					{  						Debug.Assert(dupPolicy == DuplicatePolicy.InsertLast || dupPolicy == DuplicatePolicy.ReplaceLast);  						// Insert last by treating the key as greater than nodes in the tree.  						duplicateFound = node;  						compare = 1;  					}  				}    				Debug.Assert(compare != 0);    				node.IncrementCount();  				if (needStack)  					nodeStack[nodeStackPtr++] = node;    				// Move to the left or right as needed to find the insertion point.  				if (compare < 0)  				{  					node = node.left;  					wentLeft = true;  					wentRight = false;  				}  				else  				{  					node = node.right;  					wentRight = true;  					wentLeft = false;  				}  			}
Magic Number,Magnum.Collections,RedBlackTree<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\RedBlack.cs,GetNodeStack,The following statement contains a magic number: if (count < 0x400)  				maxDepth = 21;  			else if (count < 0x10000)  				maxDepth = 41;  			else  				maxDepth = 65;
Magic Number,Magnum.Collections,RedBlackTree<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\RedBlack.cs,GetNodeStack,The following statement contains a magic number: if (count < 0x400)  				maxDepth = 21;  			else if (count < 0x10000)  				maxDepth = 41;  			else  				maxDepth = 65;
Magic Number,Magnum.Collections,RedBlackTree<T>,C:\repos\phatboyg_Magnum\src\Magnum\Collections\RedBlack.cs,GetNodeStack,The following statement contains a magic number: if (count < 0x400)  				maxDepth = 21;  			else if (count < 0x10000)  				maxDepth = 41;  			else  				maxDepth = 65;
Magic Number,Magnum.CommandLineParser,SwitchElement,C:\repos\phatboyg_Magnum\src\Magnum\CommandLineParser\SwitchElement.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				return ((Key != null ? Key.GetHashCode() : 0)*397) ^ Value.GetHashCode();  			}
Magic Number,Magnum.CommandLineParser,DefinitionElement,C:\repos\phatboyg_Magnum\src\Magnum\CommandLineParser\DefinitionElement.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				return ((Key != null ? Key.GetHashCode() : 0)*397) ^ (Value != null ? Value.GetHashCode() : 0);  			}
Magic Number,Magnum.Cryptography.PKI,RsaCryptographyService,C:\repos\phatboyg_Magnum\src\Magnum\Cryptography\PKI\RsaCryptographyService.cs,Encrypt,The following statement contains a magic number: var blockSize = GetModulusSize() - 11;
Magic Number,Magnum.Cryptography.PKI,RsaCryptographyService,C:\repos\phatboyg_Magnum\src\Magnum\Cryptography\PKI\RsaCryptographyService.cs,GetModulusSize,The following statement contains a magic number: return (int)Math.Round(_rsaCryptoServiceProvider.KeySize / 8.0);
Magic Number,Magnum.Reflection,ExtensionsForArgumentMatching,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\ExtensionsForArgumentMatching.cs,MatchesArguments,The following statement contains a magic number: return args.Length == 2  			       && args[0].ParameterType.RateParameterTypeCompatibility(typeof (TArg0)) > 0  			       && args[1].ParameterType.RateParameterTypeCompatibility(typeof (TArg1)) > 0;
Magic Number,Magnum.Reflection,ExtensionsForArgumentMatching,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\ExtensionsForArgumentMatching.cs,MatchesArguments,The following statement contains a magic number: if (parameterInfos.Length == 0)  				return 23;
Magic Number,Magnum.Reflection,ExtensionsForArgumentMatching,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\ExtensionsForArgumentMatching.cs,RateParameterTypeCompatibility,The following statement contains a magic number: if (argType == parameterType)  				return 22;
Magic Number,Magnum.Reflection,ExtensionsForArgumentMatching,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\ExtensionsForArgumentMatching.cs,RateParameterTypeCompatibility,The following statement contains a magic number: if (parameterType.IsGenericParameter)  				return argType.MeetsGenericConstraints(parameterType) ? 21 : 0;
Magic Number,Magnum.Reflection,ExtensionsForArgumentMatching,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\ExtensionsForArgumentMatching.cs,RateParameterTypeCompatibility,The following statement contains a magic number: if (parameterType.IsGenericType)  			{  				Type definition = parameterType.GetGenericTypeDefinition();    				if (argType.IsGenericType)  				{  					int matchDepth = parameterType.GetMatchDepth(argType);  					if (matchDepth > 0)  						return matchDepth + 5;  				}    				if (argType.Implements(definition))  					return parameterType.IsInterface ? 4 : 5;  			}
Magic Number,Magnum.Reflection,ExtensionsForArgumentMatching,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\ExtensionsForArgumentMatching.cs,RateParameterTypeCompatibility,The following statement contains a magic number: if (parameterType.IsGenericType)  			{  				Type definition = parameterType.GetGenericTypeDefinition();    				if (argType.IsGenericType)  				{  					int matchDepth = parameterType.GetMatchDepth(argType);  					if (matchDepth > 0)  						return matchDepth + 5;  				}    				if (argType.Implements(definition))  					return parameterType.IsInterface ? 4 : 5;  			}
Magic Number,Magnum.Reflection,ExtensionsForArgumentMatching,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\ExtensionsForArgumentMatching.cs,RateParameterTypeCompatibility,The following statement contains a magic number: if (parameterType.IsGenericType)  			{  				Type definition = parameterType.GetGenericTypeDefinition();    				if (argType.IsGenericType)  				{  					int matchDepth = parameterType.GetMatchDepth(argType);  					if (matchDepth > 0)  						return matchDepth + 5;  				}    				if (argType.Implements(definition))  					return parameterType.IsInterface ? 4 : 5;  			}
Magic Number,Magnum.Reflection,ExtensionsForArgumentMatching,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\ExtensionsForArgumentMatching.cs,RateParameterTypeCompatibility,The following statement contains a magic number: if (parameterType.IsAssignableFrom(argType))  			{  				// favor base class over interface  				return parameterType.IsInterface ? 2 : 3;  			}
Magic Number,Magnum.Reflection,ExtensionsForArgumentMatching,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\ExtensionsForArgumentMatching.cs,RateParameterTypeCompatibility,The following statement contains a magic number: if (parameterType.IsAssignableFrom(argType))  			{  				// favor base class over interface  				return parameterType.IsInterface ? 2 : 3;  			}
Magic Number,Magnum.Reflection,FastInvoker<T>,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\FastInvoker.1.cs,GetInvoker,The following statement contains a magic number: int key = 97*methodName.GetHashCode();
Magic Number,Magnum.Reflection,FastInvoker<T>,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\FastInvoker.1.cs,GetInvoker,The following statement contains a magic number: int key = GetArgumentHashCode(97*methodName.GetHashCode()' args);
Magic Number,Magnum.Reflection,FastInvoker<T>,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\FastInvoker.1.cs,FastInvoke,The following statement contains a magic number: int key = GetArgumentHashCode(97*methodName.GetHashCode()' genericTypes);
Magic Number,Magnum.Reflection,FastInvoker<T>,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\FastInvoker.1.cs,FastInvoke,The following statement contains a magic number: int key = GetArgumentHashCode(97*methodName.GetHashCode()' genericTypes' args);
Magic Number,Magnum.Reflection,FastInvoker<T>,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\FastInvoker.1.cs,FastInvoke,The following statement contains a magic number: int key = 61*call.Method.GetHashCode();
Magic Number,Magnum.Reflection,FastInvoker<T>,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\FastInvoker.1.cs,FastInvoke,The following statement contains a magic number: int key = GetArgumentHashCode(61*method.GetHashCode()' args);
Magic Number,Magnum.Reflection,FastInvoker<T>,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\FastInvoker.1.cs,FastInvoke,The following statement contains a magic number: int key = GetArgumentHashCode(61*method.GetHashCode()' genericTypes);
Magic Number,Magnum.Reflection,FastInvoker<T>,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\FastInvoker.1.cs,FastInvoke,The following statement contains a magic number: int key = GetArgumentHashCode(61*method.GetHashCode()' genericTypes' args);
Magic Number,Magnum.Reflection,FastInvokerBase,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\FastInvokerBase.cs,GetArgumentHashCode,The following statement contains a magic number: for (int i = 0; i < args.Length; i++)  				key ^= args[i] == null ? 31*i : args[i].GetType().GetHashCode() << i;
Magic Number,Magnum.Reflection,FastInvokerBase,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\FastInvokerBase.cs,GetArgumentHashCode,The following statement contains a magic number: for (int i = 0; i < genericTypes.Length; i++)  				key ^= genericTypes[i] == null ? 27*i : genericTypes[i].GetHashCode()*101 << i;
Magic Number,Magnum.Reflection,FastInvokerBase,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\FastInvokerBase.cs,GetArgumentHashCode,The following statement contains a magic number: for (int i = 0; i < genericTypes.Length; i++)  				key ^= genericTypes[i] == null ? 27*i : genericTypes[i].GetHashCode()*101 << i;
Magic Number,Magnum.Reflection,FastInvokerBase,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\FastInvokerBase.cs,GetArgumentHashCode,The following statement contains a magic number: for (int i = 0; i < genericTypes.Length; i++)  				key ^= genericTypes[i] == null ? 27*i : genericTypes[i].GetHashCode()*101 << i;
Magic Number,Magnum.Reflection,FastInvokerBase,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\FastInvokerBase.cs,GetArgumentHashCode,The following statement contains a magic number: for (int i = 0; i < genericTypes.Length; i++)  				key ^= genericTypes[i] == null ? 27*i : genericTypes[i].GetHashCode()*101 << i;
Magic Number,Magnum.Reflection,FastInvokerBase,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\FastInvokerBase.cs,GetArgumentHashCode,The following statement contains a magic number: for (int i = 0; i < args.Length; i++)  				key ^= args[i] == null ? 31*i : args[i].GetType().GetHashCode() << i;
Magic Number,Magnum.Reflection,FastInvoker<T;TResult>,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\FastInvoker.2.cs,FastInvoke,The following statement contains a magic number: int key = 97*methodName.GetHashCode();
Magic Number,Magnum.Reflection,FastInvoker<T;TResult>,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\FastInvoker.2.cs,FastInvoke,The following statement contains a magic number: int key = GetArgumentHashCode(97*methodName.GetHashCode()' args);
Magic Number,Magnum.Reflection,FastInvoker<T;TResult>,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\FastInvoker.2.cs,FastInvoke,The following statement contains a magic number: int key = GetArgumentHashCode(97*methodName.GetHashCode()' genericTypes);
Magic Number,Magnum.Reflection,FastInvoker<T;TResult>,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\FastInvoker.2.cs,FastInvoke,The following statement contains a magic number: int key = GetArgumentHashCode(97*methodName.GetHashCode()' genericTypes' args);
Magic Number,Magnum.Reflection,FastInvoker<T;TResult>,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\FastInvoker.2.cs,FastInvoke,The following statement contains a magic number: int key = 61*call.Method.GetHashCode();
Magic Number,Magnum.Reflection,FastInvoker<T;TResult>,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\FastInvoker.2.cs,FastInvoke,The following statement contains a magic number: int key = GetArgumentHashCode(61*method.GetHashCode()' args);
Magic Number,Magnum.Reflection,FastInvoker<T;TResult>,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\FastInvoker.2.cs,FastInvoke,The following statement contains a magic number: int key = GetArgumentHashCode(61*method.GetHashCode()' genericTypes);
Magic Number,Magnum.Reflection,FastInvoker<T;TResult>,C:\repos\phatboyg_Magnum\src\Magnum\Reflection\FastInvoker.2.cs,FastInvoke,The following statement contains a magic number: int key = GetArgumentHashCode(61*method.GetHashCode()' genericTypes' args);
Magic Number,Magnum.Metrics.Monitor,SuccessRateMonitor,C:\repos\phatboyg_Magnum\src\Magnum\Metrics\Monitor\SuccessRateMonitor.cs,GetCurrentSuccessRate,The following statement contains a magic number: try  			{  				long justCompleted = completed - _previousCompleted;  				long justFailed = failed - _previousFailed;    				if (completed < 0 || failed < 0 || justCompleted < 0 || justFailed < 0)  					return -1;    				if (justCompleted + justFailed == 0)  					return 100;    				return CalculateSuccessRate(justCompleted' justFailed);  			}  			catch  			{  				return -1;  			}
Magic Number,Magnum.Metrics.Monitor,SuccessRateMonitor,C:\repos\phatboyg_Magnum\src\Magnum\Metrics\Monitor\SuccessRateMonitor.cs,CalculateSuccessRate,The following statement contains a magic number: return (long) Math.Round(100 - (100*(double) failed)/(completed + failed));
Magic Number,Magnum.Metrics.Monitor,SuccessRateMonitor,C:\repos\phatboyg_Magnum\src\Magnum\Metrics\Monitor\SuccessRateMonitor.cs,CalculateSuccessRate,The following statement contains a magic number: return (long) Math.Round(100 - (100*(double) failed)/(completed + failed));
Magic Number,Magnum.Parsers,RangeElement,C:\repos\phatboyg_Magnum\src\Magnum\Parsers\RangeElement.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				return ((Begin != null ? Begin.GetHashCode() : 0)*397) ^ (End != null ? End.GetHashCode() : 0);  			}
Magic Number,Magnum.Parsers,LessThanElement,C:\repos\phatboyg_Magnum\src\Magnum\Parsers\LessThanElement.cs,GetEndForQuery,The following statement contains a magic number: return End + new string('z'' 64);
Magic Number,Magnum.Serialization.FastText,FastTextParser,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\FastText\FastTextParser.cs,RemoveListChars,The following statement contains a magic number: return value[0] == ListStart ? value.Substring(1' value.Length - 2) : value;
Magic Number,Magnum.Serialization.FastText,FastTextObjectSerializer<T>,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\FastText\FastTextObjectSerializer.cs,StringToInstance,The following statement contains a magic number: if (text[0] != MapStart)  			{  				string message =  					string.Format("Types should start with a '{0}'' expecting serialized type '{1}'' got string starting with: {2}"'  					              MapStart' typeof (T).Name'  					              text.Substring(0' text.Length < 50 ? text.Length : 50));  				throw new SerializationException(message);  			}
Magic Number,Magnum.Serialization.FastText,FastTextObjectSerializer<T>,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\FastText\FastTextObjectSerializer.cs,StringToInstance,The following statement contains a magic number: if (text[0] != MapStart)  			{  				string message =  					string.Format("Types should start with a '{0}'' expecting serialized type '{1}'' got string starting with: {2}"'  					              MapStart' typeof (T).Name'  					              text.Substring(0' text.Length < 50 ? text.Length : 50));  				throw new SerializationException(message);  			}
Magic Number,Magnum.Serialization.FastText,FastTextStringSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\FastText\FastTextStringSerializer.cs,GetReader,The following statement contains a magic number: return value =>  				{  					if (string.IsNullOrEmpty(value))  						return value;    					if (value[0] != Quote)  						return value;    					return value.Substring(1' value.Length - 2)  						.Replace(DoubleQuoteString' QuoteString);  				};
Magic Number,Magnum.Serialization,FastTextSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\FastTextSerializer.cs,Serialize,The following statement contains a magic number: var sb = new StringBuilder(4096);
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,FormatDateTimeMs,The following statement contains a magic number: var chars = new char[24];
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,FormatDateTimeMs,The following statement contains a magic number: chars[4] = '-';
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,FormatDateTimeMs,The following statement contains a magic number: Write2Chars(chars' 5' dt.Month);
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,FormatDateTimeMs,The following statement contains a magic number: chars[7] = '-';
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,FormatDateTimeMs,The following statement contains a magic number: Write2Chars(chars' 8' dt.Day);
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,FormatDateTimeMs,The following statement contains a magic number: chars[10] = 'T';
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,FormatDateTimeMs,The following statement contains a magic number: Write2Chars(chars' 11' dt.Hour);
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,FormatDateTimeMs,The following statement contains a magic number: chars[13] = ':';
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,FormatDateTimeMs,The following statement contains a magic number: Write2Chars(chars' 14' dt.Minute);
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,FormatDateTimeMs,The following statement contains a magic number: chars[16] = ':';
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,FormatDateTimeMs,The following statement contains a magic number: Write2Chars(chars' 17' dt.Second);
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,FormatDateTimeMs,The following statement contains a magic number: chars[19] = '.';
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,FormatDateTimeMs,The following statement contains a magic number: Write3Chars(chars' 20' dt.Millisecond);
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,FormatDateTimeMs,The following statement contains a magic number: chars[23] = 'Z';
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,FormatDateTime,The following statement contains a magic number: var chars = new char[20];
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,FormatDateTime,The following statement contains a magic number: chars[4] = '-';
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,FormatDateTime,The following statement contains a magic number: Write2Chars(chars' 5' dt.Month);
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,FormatDateTime,The following statement contains a magic number: chars[7] = '-';
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,FormatDateTime,The following statement contains a magic number: Write2Chars(chars' 8' dt.Day);
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,FormatDateTime,The following statement contains a magic number: chars[10] = 'T';
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,FormatDateTime,The following statement contains a magic number: Write2Chars(chars' 11' dt.Hour);
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,FormatDateTime,The following statement contains a magic number: chars[13] = ':';
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,FormatDateTime,The following statement contains a magic number: Write2Chars(chars' 14' dt.Minute);
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,FormatDateTime,The following statement contains a magic number: chars[16] = ':';
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,FormatDateTime,The following statement contains a magic number: Write2Chars(chars' 17' dt.Second);
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,FormatDateTime,The following statement contains a magic number: chars[19] = 'Z';
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,FormatDate,The following statement contains a magic number: var chars = new char[10];
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,FormatDate,The following statement contains a magic number: chars[4] = '-';
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,FormatDate,The following statement contains a magic number: Write2Chars(chars' 5' dt.Month);
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,FormatDate,The following statement contains a magic number: chars[7] = '-';
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,FormatDate,The following statement contains a magic number: Write2Chars(chars' 8' dt.Day);
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,Write2Chars,The following statement contains a magic number: chars[offset++] = (char) (value/10 + '0');
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,Write2Chars,The following statement contains a magic number: chars[offset] = (char) (value%10 + '0');
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,Write3Chars,The following statement contains a magic number: chars[offset++] = (char)('0' + (value / 100));
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,Write3Chars,The following statement contains a magic number: chars[offset++] = (char)('0' + ((value / 10) % 10));
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,Write3Chars,The following statement contains a magic number: chars[offset++] = (char)('0' + ((value / 10) % 10));
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,Write3Chars,The following statement contains a magic number: chars[offset] = (char)('0' + (value % 10));
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,Write4Chars,The following statement contains a magic number: chars[offset++] = (char)('0' + (value / 1000 % 10));
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,Write4Chars,The following statement contains a magic number: chars[offset++] = (char)('0' + (value / 1000 % 10));
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,Write4Chars,The following statement contains a magic number: chars[offset++] = (char)('0' + (value / 100 % 10));
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,Write4Chars,The following statement contains a magic number: chars[offset++] = (char)('0' + (value / 100 % 10));
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,Write4Chars,The following statement contains a magic number: chars[offset++] = (char)('0' + ((value / 10) % 10));
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,Write4Chars,The following statement contains a magic number: chars[offset++] = (char)('0' + ((value / 10) % 10));
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,Write4Chars,The following statement contains a magic number: chars[offset] = (char)('0' + (value % 10));
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,ParseShortestXsdDateTime,The following statement contains a magic number: return new DateTime(  				int.Parse(text.Substring(0' 4))'  				int.Parse(text.Substring(5' 2))'  				int.Parse(text.Substring(8' 2))'  				0' 0' 0'  				DateTimeKind.Utc);
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,ParseShortestXsdDateTime,The following statement contains a magic number: return new DateTime(  				int.Parse(text.Substring(0' 4))'  				int.Parse(text.Substring(5' 2))'  				int.Parse(text.Substring(8' 2))'  				0' 0' 0'  				DateTimeKind.Utc);
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,ParseShortestXsdDateTime,The following statement contains a magic number: return new DateTime(  				int.Parse(text.Substring(0' 4))'  				int.Parse(text.Substring(5' 2))'  				int.Parse(text.Substring(8' 2))'  				0' 0' 0'  				DateTimeKind.Utc);
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,ParseShortestXsdDateTime,The following statement contains a magic number: return new DateTime(  				int.Parse(text.Substring(0' 4))'  				int.Parse(text.Substring(5' 2))'  				int.Parse(text.Substring(8' 2))'  				0' 0' 0'  				DateTimeKind.Utc);
Magic Number,Magnum.Serialization.TypeSerializers,DateTimeSerializer,C:\repos\phatboyg_Magnum\src\Magnum\Serialization\TypeSerializers\DateTimeSerializer.cs,ParseShortestXsdDateTime,The following statement contains a magic number: return new DateTime(  				int.Parse(text.Substring(0' 4))'  				int.Parse(text.Substring(5' 2))'  				int.Parse(text.Substring(8' 2))'  				0' 0' 0'  				DateTimeKind.Utc);
Magic Number,Magnum.StateMachine,EventCombiner<T>,C:\repos\phatboyg_Magnum\src\Magnum\StateMachine\EventCombiner.cs,Into,The following statement contains a magic number: if(_sources.Count > 31) 				throw new InvalidOperationException("More more than 31 events can be combined into an event with an integer property");
Magic Number,Magnum.Validation,DateTimeExtensions,C:\repos\phatboyg_Magnum\src\Magnum\Validation\DateTimeExtensions.cs,ToFriendlyString,The following statement contains a magic number: if (ts.Equals(TimeSpan.FromDays(30)))  				return "month";
Magic Number,Magnum.Validation,DateTimeExtensions,C:\repos\phatboyg_Magnum\src\Magnum\Validation\DateTimeExtensions.cs,ToFriendlyString,The following statement contains a magic number: if (ts.Equals(TimeSpan.FromDays(365)))  				return "year";
Magic Number,Magnum.Validation,DateTimeExtensions,C:\repos\phatboyg_Magnum\src\Magnum\Validation\DateTimeExtensions.cs,ToFriendlyString,The following statement contains a magic number: int years = ts.Days/365;
Magic Number,Magnum.Validation,DateTimeExtensions,C:\repos\phatboyg_Magnum\src\Magnum\Validation\DateTimeExtensions.cs,ToFriendlyString,The following statement contains a magic number: int months = (ts.Days%365)/30;
Magic Number,Magnum.Validation,DateTimeExtensions,C:\repos\phatboyg_Magnum\src\Magnum\Validation\DateTimeExtensions.cs,ToFriendlyString,The following statement contains a magic number: int months = (ts.Days%365)/30;
Magic Number,Magnum.Validation,DateTimeExtensions,C:\repos\phatboyg_Magnum\src\Magnum\Validation\DateTimeExtensions.cs,ToFriendlyString,The following statement contains a magic number: int weeks = ((ts.Days%365)%30)/7;
Magic Number,Magnum.Validation,DateTimeExtensions,C:\repos\phatboyg_Magnum\src\Magnum\Validation\DateTimeExtensions.cs,ToFriendlyString,The following statement contains a magic number: int weeks = ((ts.Days%365)%30)/7;
Magic Number,Magnum.Validation,DateTimeExtensions,C:\repos\phatboyg_Magnum\src\Magnum\Validation\DateTimeExtensions.cs,ToFriendlyString,The following statement contains a magic number: int weeks = ((ts.Days%365)%30)/7;
Magic Number,Magnum.Validation,DateTimeExtensions,C:\repos\phatboyg_Magnum\src\Magnum\Validation\DateTimeExtensions.cs,ToFriendlyString,The following statement contains a magic number: int days = (((ts.Days%365)%30)%7);
Magic Number,Magnum.Validation,DateTimeExtensions,C:\repos\phatboyg_Magnum\src\Magnum\Validation\DateTimeExtensions.cs,ToFriendlyString,The following statement contains a magic number: int days = (((ts.Days%365)%30)%7);
Magic Number,Magnum.Validation,DateTimeExtensions,C:\repos\phatboyg_Magnum\src\Magnum\Validation\DateTimeExtensions.cs,ToFriendlyString,The following statement contains a magic number: int days = (((ts.Days%365)%30)%7);
Magic Number,Magnum.ValueProviders,ValueProviderDecorator,C:\repos\phatboyg_Magnum\src\Magnum\ValueProviders\ValueProviderDecorator.cs,ObscureValueIfNecessary,The following statement contains a magic number: if (text.Length > 100)  				return text.Substring(0' 100) + "... (" + text.Length + " bytes)";
Magic Number,Magnum.ValueProviders,ValueProviderDecorator,C:\repos\phatboyg_Magnum\src\Magnum\ValueProviders\ValueProviderDecorator.cs,ObscureValueIfNecessary,The following statement contains a magic number: if (text.Length > 100)  				return text.Substring(0' 100) + "... (" + text.Length + " bytes)";
Missing Default,Magnum.StateMachine,StateMachine<T>,C:\repos\phatboyg_Magnum\src\Magnum\StateMachine\StateMachine.cs,InitializeStates,The following switch statement is missing a default case: switch (state.Name)  				{  					case InitialStateName:  						_initialState = state;  						break;  					case CompletedStateName:  						_completedState = state;  						break;  				}
