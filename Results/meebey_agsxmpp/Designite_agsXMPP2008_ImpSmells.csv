Implementation smell,Namespace,Class,File,Method,Description
Long Method,agsXMPP.Idn,IDNA,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\IDNA.cs,ToASCII,The method has 67 lines of code.
Long Method,agsXMPP.Idn,Punycode,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\Punycode.cs,Encode,The method has 69 lines of code.
Long Method,agsXMPP.Net,BoshClientSocket,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\BoshClientSocket.cs,RequestBoshSession,The method has 65 lines of code.
Long Method,agsXMPP.Net,BoshClientSocket,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\BoshClientSocket.cs,OnGetResponse,The method has 83 lines of code.
Long Method,agsXMPP.Net,PollClientSocket,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\PollClientSocket.cs,PollThread,The method has 178 lines of code.
Long Method,agsXMPP.Factory,ElementFactory,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Factory\ElementFactory.cs,ElementFactory,The method has 222 lines of code.
Long Method,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,DeflateFast,The method has 61 lines of code.
Long Method,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,DeflateSlow,The method has 77 lines of code.
Long Method,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The method has 109 lines of code.
Long Method,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The method has 62 lines of code.
Long Method,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The method has 64 lines of code.
Long Method,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeHuffman,The method has 73 lines of code.
Long Method,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,Decode,The method has 96 lines of code.
Long Method,agsXMPP,XmppClientConnection,D:\newReposJune17\meebey_agsxmpp\agsxmpp\XmppClientConnection.cs,StreamParserOnStreamElement,The method has 89 lines of code.
Long Method,agsXMPP.Sasl,SaslHandler,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\SaslHandler.cs,OnStreamElement,The method has 87 lines of code.
Long Method,agsXMPP.Sasl.DigestMD5,Step2,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\DigestMD5\Step2.cs,GenerateResponse,The method has 88 lines of code.
Long Method,agsXMPP.Xml,StreamParser,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\StreamParser.cs,Push,The method has 93 lines of code.
Long Method,agsXMPP.Xml,StreamParser,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\StreamParser.cs,StartTag,The method has 60 lines of code.
Long Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The method has 121 lines of code.
Long Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeCdataSection,The method has 60 lines of code.
Long Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanEndTag,The method has 87 lines of code.
Long Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanHexCharRef,The method has 79 lines of code.
Long Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanRef,The method has 73 lines of code.
Long Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The method has 212 lines of code.
Long Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The method has 138 lines of code.
Long Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeContent,The method has 63 lines of code.
Long Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPercent,The method has 75 lines of code.
Long Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPoundName,The method has 74 lines of code.
Long Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The method has 232 lines of code.
Long Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeAttributeValue,The method has 64 lines of code.
Long Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeEntityValue,The method has 60 lines of code.
Long Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,skipIgnoreSect,The method has 66 lines of code.
Complex Method,agsXMPP.Idn,IDNA,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\IDNA.cs,ToASCII,Cyclomatic complexity of the method is 15
Complex Method,agsXMPP.Idn,IDNA,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\IDNA.cs,ToUnicode,Cyclomatic complexity of the method is 9
Complex Method,agsXMPP.Idn,NFKC,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\NFKC.cs,NormalizeNFKC,Cyclomatic complexity of the method is 9
Complex Method,agsXMPP.Idn,NFKC,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\NFKC.cs,canonicalOrdering,Cyclomatic complexity of the method is 7
Complex Method,agsXMPP.Idn,NFKC,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\NFKC.cs,compose,Cyclomatic complexity of the method is 9
Complex Method,agsXMPP.Idn,Punycode,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\Punycode.cs,Encode,Cyclomatic complexity of the method is 16
Complex Method,agsXMPP.Idn,Punycode,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\Punycode.cs,Decode,Cyclomatic complexity of the method is 12
Complex Method,agsXMPP.Idn,Stringprep,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\Stringprep.cs,NamePrep,Cyclomatic complexity of the method is 7
Complex Method,agsXMPP.Idn,Stringprep,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\Stringprep.cs,NodePrep,Cyclomatic complexity of the method is 7
Complex Method,agsXMPP.Idn,Stringprep,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\Stringprep.cs,ResourcePrep,Cyclomatic complexity of the method is 7
Complex Method,agsXMPP.Idn,Stringprep,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\Stringprep.cs,Contains,Cyclomatic complexity of the method is 8
Complex Method,agsXMPP.Idn,Stringprep,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\Stringprep.cs,Filter,Cyclomatic complexity of the method is 8
Complex Method,agsXMPP.Net,BoshClientSocket,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\BoshClientSocket.cs,OnGetResponse,Cyclomatic complexity of the method is 14
Complex Method,agsXMPP.Net,PollClientSocket,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\PollClientSocket.cs,PollThread,Cyclomatic complexity of the method is 20
Complex Method,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,SetLevel,Cyclomatic complexity of the method is 18
Complex Method,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,FindLongestMatch,Cyclomatic complexity of the method is 9
Complex Method,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,DeflateFast,Cyclomatic complexity of the method is 11
Complex Method,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,DeflateSlow,Cyclomatic complexity of the method is 15
Complex Method,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,Deflate,Cyclomatic complexity of the method is 12
Complex Method,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,FlushBlock,Cyclomatic complexity of the method is 8
Complex Method,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,Cyclomatic complexity of the method is 53
Complex Method,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,Cyclomatic complexity of the method is 7
Complex Method,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,Cyclomatic complexity of the method is 12
Complex Method,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,Cyclomatic complexity of the method is 15
Complex Method,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeHuffman,Cyclomatic complexity of the method is 32
Complex Method,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,Decode,Cyclomatic complexity of the method is 40
Complex Method,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,Inflate,Cyclomatic complexity of the method is 7
Complex Method,agsXMPP.IO.Compression.Streams,StreamManipulator,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Streams\StreamManipulator.cs,CopyBytes,Cyclomatic complexity of the method is 7
Complex Method,agsXMPP,Jid,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Jid.cs,Parse,Cyclomatic complexity of the method is 9
Complex Method,agsXMPP,Jid,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Jid.cs,EscapeNode,Cyclomatic complexity of the method is 34
Complex Method,agsXMPP,Jid,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Jid.cs,UnescapeNode,Cyclomatic complexity of the method is 31
Complex Method,agsXMPP,XmppClientConnection,D:\newReposJune17\meebey_agsxmpp\agsxmpp\XmppClientConnection.cs,PickSRVRecord,Cyclomatic complexity of the method is 11
Complex Method,agsXMPP,XmppClientConnection,D:\newReposJune17\meebey_agsxmpp\agsxmpp\XmppClientConnection.cs,OnRegisterResult,Cyclomatic complexity of the method is 7
Complex Method,agsXMPP,XmppClientConnection,D:\newReposJune17\meebey_agsxmpp\agsxmpp\XmppClientConnection.cs,OnRosterIQ,Cyclomatic complexity of the method is 7
Complex Method,agsXMPP,XmppClientConnection,D:\newReposJune17\meebey_agsxmpp\agsxmpp\XmppClientConnection.cs,StreamParserOnStreamElement,Cyclomatic complexity of the method is 21
Complex Method,agsXMPP,XmppComponentConnection,D:\newReposJune17\meebey_agsxmpp\agsxmpp\XmppComponentConnection.cs,StreamParserOnStreamElement,Cyclomatic complexity of the method is 21
Complex Method,agsXMPP.protocol.extensions.caps,Capabilities,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\caps\Capabilities.cs,BuildCapsVersion,Cyclomatic complexity of the method is 9
Complex Method,agsXMPP.protocol.sasl,Mechanism,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\sasl\Mechanism.cs,GetMechanismType,Cyclomatic complexity of the method is 7
Complex Method,agsXMPP.protocol.sasl,Mechanism,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\sasl\Mechanism.cs,GetMechanismName,Cyclomatic complexity of the method is 26
Complex Method,agsXMPP.Net.Dns,Response,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\Dns\Response.cs,Response,Cyclomatic complexity of the method is 7
Complex Method,agsXMPP.protocol.iq.rpc,MethodResponse,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\iq\rpc\MethodResponse.cs,ParseValue,Cyclomatic complexity of the method is 12
Complex Method,agsXMPP.Sasl,SaslHandler,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\SaslHandler.cs,OnStreamElement,Cyclomatic complexity of the method is 20
Complex Method,agsXMPP.Sasl.DigestMD5,Step1,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\DigestMD5\Step1.cs,ParsePair,Cyclomatic complexity of the method is 20
Complex Method,agsXMPP.Xml.Dom,Element,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Dom\Element.cs,StartTag,Cyclomatic complexity of the method is 9
Complex Method,agsXMPP.Xml.Dom,Element,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Dom\Element.cs,_SelectElement,Cyclomatic complexity of the method is 7
Complex Method,agsXMPP.Xml.Dom,Element,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Dom\Element.cs,_SelectElement,Cyclomatic complexity of the method is 7
Complex Method,agsXMPP.Xml.Dom,Element,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Dom\Element.cs,_SelectElement,Cyclomatic complexity of the method is 8
Complex Method,agsXMPP.Xml.Dom,Element,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Dom\Element.cs,_SelectElement,Cyclomatic complexity of the method is 7
Complex Method,agsXMPP.Xml.Dom,Node,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Dom\Node.cs,WriteTree,Cyclomatic complexity of the method is 17
Complex Method,agsXMPP.Xml,StreamParser,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\StreamParser.cs,Push,Cyclomatic complexity of the method is 43
Complex Method,agsXMPP.Xml,StreamParser,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\StreamParser.cs,StartTag,Cyclomatic complexity of the method is 10
Complex Method,agsXMPP.Xml,StreamParser,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\StreamParser.cs,NormalizeAttributeValue,Cyclomatic complexity of the method is 18
Complex Method,agsXMPP.Xml,StreamParser,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\StreamParser.cs,AddText,Cyclomatic complexity of the method is 8
Complex Method,agsXMPP.Xml.Xpnet,BufferAggregate,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\BufferAggregate.cs,Clear,Cyclomatic complexity of the method is 7
Complex Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanComment,Cyclomatic complexity of the method is 33
Complex Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanDecl,Cyclomatic complexity of the method is 23
Complex Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,targetIsXml,Cyclomatic complexity of the method is 17
Complex Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,Cyclomatic complexity of the method is 70
Complex Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeCdataSection,Cyclomatic complexity of the method is 47
Complex Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,extendCdata,Cyclomatic complexity of the method is 24
Complex Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanEndTag,Cyclomatic complexity of the method is 72
Complex Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanHexCharRef,Cyclomatic complexity of the method is 64
Complex Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanCharRef,Cyclomatic complexity of the method is 33
Complex Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,Cyclomatic complexity of the method is 17
Complex Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanRef,Cyclomatic complexity of the method is 59
Complex Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,Cyclomatic complexity of the method is 153
Complex Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,Cyclomatic complexity of the method is 109
Complex Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeContent,Cyclomatic complexity of the method is 49
Complex Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,extendData,Cyclomatic complexity of the method is 26
Complex Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPercent,Cyclomatic complexity of the method is 63
Complex Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPoundName,Cyclomatic complexity of the method is 63
Complex Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLit,Cyclomatic complexity of the method is 33
Complex Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,getInitialEncoding,Cyclomatic complexity of the method is 10
Complex Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,Cyclomatic complexity of the method is 135
Complex Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeAttributeValue,Cyclomatic complexity of the method is 40
Complex Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeEntityValue,Cyclomatic complexity of the method is 37
Complex Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,skipIgnoreSect,Cyclomatic complexity of the method is 54
Complex Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,getPublicId,Cyclomatic complexity of the method is 35
Complex Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,skipS,Cyclomatic complexity of the method is 8
Complex Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,setCharType,Cyclomatic complexity of the method is 7
Complex Method,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,Encoding,Cyclomatic complexity of the method is 14
Complex Method,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,check3,Cyclomatic complexity of the method is 7
Complex Method,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,check4,Cyclomatic complexity of the method is 8
Complex Method,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,convert,Cyclomatic complexity of the method is 20
Complex Method,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,movePosition,Cyclomatic complexity of the method is 26
Complex Method,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,extendData,Cyclomatic complexity of the method is 10
Long Parameter List,agsXMPP.Net,BaseSocket,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\BaseSocket.cs,FireOnValidateCertificate,The method has 4 parameters.
Long Parameter List,agsXMPP.Net,ClientSocket,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\ClientSocket.cs,ValidateCertificate,The method has 4 parameters.
Long Parameter List,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,FlushStoredBlock,The method has 4 parameters.
Long Parameter List,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,FlushBlock,The method has 4 parameters.
Long Parameter List,agsXMPP,MessageGrabber,D:\newReposJune17\meebey_agsxmpp\agsxmpp\MessageGrabber.cs,Add,The method has 4 parameters.
Long Parameter List,agsXMPP,PresenceGrabber,D:\newReposJune17\meebey_agsxmpp\agsxmpp\PresenceGrabber.cs,Add,The method has 4 parameters.
Long Parameter List,agsXMPP,XmppClientConnection,D:\newReposJune17\meebey_agsxmpp\agsxmpp\XmppClientConnection.cs,Open,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.client,Message,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\client\Message.cs,Message,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.client,Message,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\client\Message.cs,Message,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.client,Message,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\client\Message.cs,Message,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.client,Message,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\client\Message.cs,Message,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.client,Message,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\client\Message.cs,Message,The method has 5 parameters.
Long Parameter List,agsXMPP.protocol.client,Message,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\client\Message.cs,Message,The method has 5 parameters.
Long Parameter List,agsXMPP.protocol.client,Message,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\client\Message.cs,Message,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.client,Message,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\client\Message.cs,Message,The method has 5 parameters.
Long Parameter List,agsXMPP.protocol.client,Message,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\client\Message.cs,Message,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.client,Message,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\client\Message.cs,Message,The method has 5 parameters.
Long Parameter List,agsXMPP.protocol.client,Message,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\client\Message.cs,Message,The method has 6 parameters.
Long Parameter List,agsXMPP.protocol.component,Message,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\component\Message.cs,Message,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.component,Message,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\component\Message.cs,Message,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.component,Message,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\component\Message.cs,Message,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.component,Message,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\component\Message.cs,Message,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.component,Message,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\component\Message.cs,Message,The method has 5 parameters.
Long Parameter List,agsXMPP.protocol.component,Message,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\component\Message.cs,Message,The method has 5 parameters.
Long Parameter List,agsXMPP.protocol.component,Message,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\component\Message.cs,Message,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.component,Message,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\component\Message.cs,Message,The method has 5 parameters.
Long Parameter List,agsXMPP.protocol.component,Message,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\component\Message.cs,Message,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.component,Message,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\component\Message.cs,Message,The method has 5 parameters.
Long Parameter List,agsXMPP.protocol.component,Message,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\component\Message.cs,Message,The method has 6 parameters.
Long Parameter List,agsXMPP.protocol.component,Route,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\component\Route.cs,Route,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.extensions.bookmarks,Conference,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\bookmarks\Conference.cs,Conference,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.extensions.bookmarks,Conference,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\bookmarks\Conference.cs,Conference,The method has 5 parameters.
Long Parameter List,agsXMPP.protocol.extensions.bookmarks,RosterNote,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\bookmarks\RosterNote.cs,RosterNote,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.extensions.bookmarks,RosterNotes,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\bookmarks\RosterNotes.cs,AddNote,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.extensions.bookmarks,Storage,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\bookmarks\Storage.cs,AddConference,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.extensions.bookmarks,Storage,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\bookmarks\Storage.cs,AddConference,The method has 5 parameters.
Long Parameter List,agsXMPP.protocol.extensions.bytestreams,ByteStream,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\bytestreams\ByteStream.cs,AddStreamHost,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.extensions.bytestreams,ByteStreamIq,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\bytestreams\ByteStreamIq.cs,ByteStreamIq,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.extensions.bytestreams,StreamHost,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\bytestreams\StreamHost.cs,StreamHost,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.iq.disco,DiscoManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\iq\disco\DiscoManager.cs,DiscoverInformation,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.iq.disco,DiscoManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\iq\disco\DiscoManager.cs,DiscoverItems,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.x.muc,MucManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\x\muc\MucManager.cs,Invite,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.x.muc,MucManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\x\muc\MucManager.cs,Invite,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.x.muc,MucManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\x\muc\MucManager.cs,JoinRoom,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.x.muc,MucManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\x\muc\MucManager.cs,KickOccupant,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.x.muc,MucManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\x\muc\MucManager.cs,GrantVoice,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.x.muc,MucManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\x\muc\MucManager.cs,RevokeVoice,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.x.muc,MucManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\x\muc\MucManager.cs,BanUser,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.x.muc,MucManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\x\muc\MucManager.cs,GrantMembership,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.x.muc,MucManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\x\muc\MucManager.cs,GrantMembership,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.x.muc,MucManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\x\muc\MucManager.cs,RevokeMembership,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.x.muc,MucManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\x\muc\MucManager.cs,GrantModeratorPrivileges,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.x.muc,MucManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\x\muc\MucManager.cs,RevokeModerator,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.x.muc,MucManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\x\muc\MucManager.cs,DestroyRoom,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.x.muc,MucManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\x\muc\MucManager.cs,ChangeRole,The method has 5 parameters.
Long Parameter List,agsXMPP.protocol.x.muc,MucManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\x\muc\MucManager.cs,ChangeAffiliation,The method has 5 parameters.
Long Parameter List,agsXMPP.protocol.x.muc,MucManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\x\muc\MucManager.cs,ChangeAffiliation,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.x.muc,MucManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\x\muc\MucManager.cs,ChangeAffiliation,The method has 6 parameters.
Long Parameter List,agsXMPP.protocol.iq.privacy,Item,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\iq\privacy\Item.cs,Item,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.iq.privacy,Item,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\iq\privacy\Item.cs,Item,The method has 5 parameters.
Long Parameter List,agsXMPP.protocol.extensions.commands,Command,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\commands\Command.cs,Command,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,Subscription,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\Subscription.cs,Subscription,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,CreateNode,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,CreateNode,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,CreateNode,The method has 5 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,CreateCollectionNode,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,CreateCollectionNode,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,CreateCollectionNode,The method has 5 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,DeleteNode,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,PurgeNode,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,PublishItem,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,PublishItem,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,PublishItem,The method has 5 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,RetractItem,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,RetractItem,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,RetractItem,The method has 5 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,Subscribe,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,Subscribe,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,Subscribe,The method has 5 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,Unsubscribe,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,Unsubscribe,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,Unsubscribe,The method has 5 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,Unsubscribe,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,Unsubscribe,The method has 5 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,Unsubscribe,The method has 5 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,Unsubscribe,The method has 6 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,RequestSubscriptionOptions,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,RequestSubscriptionOptions,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,RequestSubscriptionOptions,The method has 5 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,OwnerRequestSubscribers,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,OwnerModifySubscriptionState,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,OwnerModifySubscriptionState,The method has 5 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,OwnerModifySubscriptionState,The method has 5 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,OwnerModifySubscriptionState,The method has 6 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,OwnerModifySubscriptionStates,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,OwnerModifySubscriptionStates,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,OwnerModifySubscriptionStates,The method has 5 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,OwnerRequestAffiliations,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,OwnerModifyAffiliation,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,OwnerModifyAffiliation,The method has 5 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,OwnerModifyAffiliation,The method has 5 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,OwnerModifyAffiliation,The method has 6 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,OwnerModifyAffiliations,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,OwnerModifyAffiliations,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.extensions.pubsub,PubSubManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\pubsub\PubSubManager.cs,OwnerModifyAffiliations,The method has 5 parameters.
Long Parameter List,agsXMPP.protocol.extensions.jivesoftware.phone,PhoneEvent,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\jivesoftware\phone\PhoneEvent.cs,PhoneEvent,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.iq.vcard,Address,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\iq\vcard\Address.cs,Address,The method has 8 parameters.
Long Parameter List,agsXMPP.protocol.iq.vcard,VcardIq,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\iq\vcard\VcardIq.cs,VcardIq,The method has 4 parameters.
Long Parameter List,agsXMPP.protocol.x.muc.iq.admin,Item,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\x\muc\iq\admin\Item.cs,Item,The method has 4 parameters.
Long Parameter List,agsXMPP.Sasl.Gssapi,SSPIHelper,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\Gssapi\SSPIHelper.cs,AcquireCredentialsHandle,The method has 9 parameters.
Long Parameter List,agsXMPP.Sasl.Gssapi,SSPIHelper,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\Gssapi\SSPIHelper.cs,InitializeSecurityContext,The method has 12 parameters.
Long Parameter List,agsXMPP.Sasl.Gssapi,SSPIHelper,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\Gssapi\SSPIHelper.cs,InitializeSecurityContext,The method has 12 parameters.
Long Parameter List,agsXMPP.Sasl.Gssapi,SSPIHelper,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\Gssapi\SSPIHelper.cs,EncryptMessage,The method has 4 parameters.
Long Parameter List,agsXMPP.Sasl.Gssapi,SSPIHelper,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\Gssapi\SSPIHelper.cs,DecryptMessage,The method has 4 parameters.
Long Parameter List,agsXMPP.Sasl.DigestMD5,Step2,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\DigestMD5\Step2.cs,Step2,The method has 4 parameters.
Long Parameter List,agsXMPP.Xml.Dom,Element,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Dom\Element.cs,_SelectElements,The method has 4 parameters.
Long Parameter List,agsXMPP.Xml.Dom,Element,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Dom\Element.cs,_SelectElement,The method has 4 parameters.
Long Parameter List,agsXMPP.Xml.Dom,Element,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Dom\Element.cs,_SelectElement,The method has 4 parameters.
Long Parameter List,agsXMPP.Xml.Dom,Element,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Dom\Element.cs,_SelectElements,The method has 4 parameters.
Long Parameter List,agsXMPP.Xml.Dom,Node,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Dom\Node.cs,BuildXml,The method has 4 parameters.
Long Parameter List,agsXMPP.Xml,StreamParser,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\StreamParser.cs,StartTag,The method has 4 parameters.
Long Parameter List,agsXMPP.Xml,StreamParser,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\StreamParser.cs,EndTag,The method has 4 parameters.
Long Parameter List,agsXMPP.Xml.Xpnet,ContentToken,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\ContentToken.cs,appendAttribute,The method has 5 parameters.
Long Parameter List,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,convert,The method has 5 parameters.
Long Parameter List,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,movePosition,The method has 4 parameters.
Long Parameter List,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanComment,The method has 4 parameters.
Long Parameter List,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanDecl,The method has 4 parameters.
Long Parameter List,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The method has 4 parameters.
Long Parameter List,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanCdataSection,The method has 4 parameters.
Long Parameter List,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeCdataSection,The method has 4 parameters.
Long Parameter List,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanEndTag,The method has 4 parameters.
Long Parameter List,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanHexCharRef,The method has 4 parameters.
Long Parameter List,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanCharRef,The method has 4 parameters.
Long Parameter List,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The method has 4 parameters.
Long Parameter List,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanRef,The method has 4 parameters.
Long Parameter List,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The method has 5 parameters.
Long Parameter List,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The method has 4 parameters.
Long Parameter List,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeContent,The method has 4 parameters.
Long Parameter List,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPercent,The method has 4 parameters.
Long Parameter List,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPoundName,The method has 4 parameters.
Long Parameter List,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLit,The method has 5 parameters.
Long Parameter List,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,getInitialEncoding,The method has 4 parameters.
Long Parameter List,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The method has 4 parameters.
Long Parameter List,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeAttributeValue,The method has 4 parameters.
Long Parameter List,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeEntityValue,The method has 4 parameters.
Long Parameter List,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,matchesXMLstring,The method has 4 parameters.
Long Parameter List,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,convert,The method has 5 parameters.
Long Parameter List,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,movePosition,The method has 4 parameters.
Long Identifier,agsXMPP.Sasl.Scram,ScramSha1Mechanism,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\Scram\ScramSha1Mechanism.cs,GenerateFinalClientMessage,The length of the parameter clientFinalMessageWithoutProof is 30.
Long Statement,agsXMPP.Idn,IDNA,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\IDNA.cs,ToASCII,The length of the statement  "			if ((c <= 0x2c) || (c >= 0x2e && c <= 0x2f) || (c >= 0x3a && c <= 0x40) || (c >= 0x5b && c <= 0x60) || (c >= 0x7b && c <= 0x7f)) { " is 130.
Long Statement,agsXMPP.Idn,NFKC,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\NFKC.cs,compose,The length of the statement  "	if (ai >= 0 && ai < Composition.multiSecondStart && bi >= Composition.multiSecondStart && bi < Composition.singleFirstStart) { " is 126.
Long Statement,agsXMPP.Idn,Stringprep,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\Stringprep.cs,NamePrep,The length of the statement  "	if (Contains (s' RFC3454.C12) || Contains (s' RFC3454.C22) || Contains (s' RFC3454.C3) || Contains (s' RFC3454.C4) || Contains (s' RFC3454.C5) || Contains (s' RFC3454.C6) || Contains (s' RFC3454.C7) || Contains (s' RFC3454.C8)) { " is 229.
Long Statement,agsXMPP.Idn,Stringprep,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\Stringprep.cs,NodePrep,The length of the statement  "	if (Contains (s' RFC3454.C11) || Contains (s' RFC3454.C12) || Contains (s' RFC3454.C21) || Contains (s' RFC3454.C22) || Contains (s' RFC3454.C3) || Contains (s' RFC3454.C4) || Contains (s' RFC3454.C5) || Contains (s' RFC3454.C6) || Contains (s' RFC3454.C7) || Contains (s' RFC3454.C8) || Contains (s' RFC3920_NODEPREP_PROHIBIT)) { " is 330.
Long Statement,agsXMPP.Idn,Stringprep,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\Stringprep.cs,ResourcePrep,The length of the statement  "	if (Contains (s' RFC3454.C12) || Contains (s' RFC3454.C21) || Contains (s' RFC3454.C22) || Contains (s' RFC3454.C3) || Contains (s' RFC3454.C4) || Contains (s' RFC3454.C5) || Contains (s' RFC3454.C6) || Contains (s' RFC3454.C7) || Contains (s' RFC3454.C8)) { " is 258.
Long Statement,agsXMPP.Net,BoshClientSocket,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\BoshClientSocket.cs,GenerateKeys,The length of the statement  "            Prior to requesting a new session' the client MUST select an unpredictable counter ("n") and an unpredictable value ("seed")." is 125.
Long Statement,agsXMPP.Net,BoshClientSocket,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\BoshClientSocket.cs,GenerateKeys,The length of the statement  "            The client then processes the "seed" through a cryptographic hash and converts the resulting 160 bits to a hexadecimal string K(1)." is 131.
Long Statement,agsXMPP.Net,ClientSocket,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\ClientSocket.cs,DisplayCertificateInformation,The length of the statement  "		Console.WriteLine ("Remote cert was issued to {0} and is valid from {1} until {2}."' remoteCertificate.Subject' remoteCertificate.GetEffectiveDateString ()' remoteCertificate.GetExpirationDateString ()); " is 203.
Long Statement,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,FindLongestMatch,The length of the statement  "*/if (window [curMatch + best_len] != scan_end || window [curMatch + best_len - 1] != scan_end1 || window [curMatch] != window [scan] || window [curMatch + 1] != window [scan + 1]) { " is 182.
Long Statement,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,FindLongestMatch,The length of the statement  "				*/while (window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && scan < strend) " is 335.
Long Statement,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,DeflateStored,The length of the statement  "	if ((storedLen >= DeflaterConstants.MAX_BLOCK_SIZE) || /* Block is full */(blockStart < WSIZE && storedLen >= MAX_DIST) || /* Block may move out of window */flush) { " is 165.
Long Statement,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,DeflateFast,The length of the statement  "		if (lookahead >= MIN_MATCH && (hashHead = InsertString ()) != 0 && strategy != DeflateStrategy.HuffmanOnly && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) { " is 175.
Long Statement,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,DeflateSlow,The length of the statement  "			if (strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) { " is 129.
Long Statement,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,DeflateSlow,The length of the statement  "				/* longestMatch sets matchStart and matchLen *//* Discard match if too small and too far away */if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TOO_FAR))) { " is 220.
Long Statement,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,BitReverse,The length of the statement  "	return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]); " is 172.
Long Statement,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,FlushBlock,The length of the statement  "	int opt_len = 14 + blTreeCodes * 3 + blTree.GetEncodedLength () + literalTree.GetEncodedLength () + distTree.GetEncodedLength () + extra_bits; " is 142.
Long Statement,agsXMPP.IO.Compression.Streams,StreamManipulator,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Streams\StreamManipulator.cs,CopyBytes,The length of the statement  "		/* bits_in_buffer may only be 0 or a multiple of 8 */throw new InvalidOperationException ("Bit buffer is not byte aligned!"); " is 125.
Long Statement,agsXMPP.IO.Compression.Streams,StreamManipulator,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Streams\StreamManipulator.cs,SetInput,The length of the statement  "		/* We always want an even number of bytes in input' see peekBits */buffer |= (uint)((buf [off++] & 0xff) << bits_in_buffer); " is 124.
Long Statement,agsXMPP,XmppClientConnection,D:\newReposJune17\meebey_agsxmpp\agsxmpp\XmppClientConnection.cs,SocketOnError,The length of the statement  "	if ((ex.GetType () == typeof(ConnectTimeoutException) || (ex.GetType () == typeof(SocketException) && ((SocketException)ex).ErrorCode == 10061)) && _SRVRecords != null && _SRVRecords.Length > 1) { " is 196.
Long Statement,agsXMPP,XmppClientConnection,D:\newReposJune17\meebey_agsxmpp\agsxmpp\XmppClientConnection.cs,SendStreamHeader,The length of the statement  "	// xml:lang="en"<stream:stream to="coversant.net" xmlns="jabber:client" xmlns:stream="http://etherx.jabber.org/streams"  xml:lang="en" version="1.0" > " is 150.
Long Statement,agsXMPP,XmppClientConnection,D:\newReposJune17\meebey_agsxmpp\agsxmpp\XmppClientConnection.cs,OnGetAuthInfo,The length of the statement  "	// Recv:<iq type="result" id="MX_7"><query xmlns="jabber:iq:auth"><username>gnauck</username><password/><digest/><resource/></query></iq> " is 137.
Long Statement,agsXMPP,XmppClientConnection,D:\newReposJune17\meebey_agsxmpp\agsxmpp\XmppClientConnection.cs,OnGetAuthInfo,The length of the statement  "	//			<query xmlns='jabber:iq:auth'><username>gnauck</username><digest>27c05d464e3f908db3b2ca1729674bfddb28daf2</digest><resource>Office</resource></query> " is 154.
Long Statement,agsXMPP.protocol.extensions.caps,Capabilities,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\extensions\caps\Capabilities.cs,BuildCapsVersion,The length of the statement  "                2. Sort the service discovery identities by category and then by type (if it exists)' formatted as 'category' '/' 'type'." is 121.
Long Statement,agsXMPP.Net.Dns,SRVRecord,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\Dns\SRVRecord.cs,ToString,The length of the statement  "	return string.Format ("\n   priority   = {0}\n   weight     = {1}\n   port       = {2}\n   target     = {3}"' m_Priority' m_Weight' m_Port' m_Target); " is 150.
Long Statement,agsXMPP.protocol.iq.privacy,PrivacyManager,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\iq\privacy\PrivacyManager.cs,ChangeActiveList,The length of the statement  "                If the user attempts to set an active list but a list by that name does not exist' the server MUST return an <item-not-found/> stanza error to the user:" is 152.
Long Statement,agsXMPP.protocol.iq.vcard,Photo,D:\newReposJune17\meebey_agsxmpp\agsxmpp\protocol\iq\vcard\Photo.cs,SetImage,The length of the statement  "	g.DrawImage (image' new Rectangle (0' 0' temp.Width' temp.Height)' new Rectangle (0' 0' image.Width' image.Height)' GraphicsUnit.Pixel); " is 136.
Long Statement,agsXMPP.Sasl.Gssapi,SSPIHelper,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\Gssapi\SSPIHelper.cs,InitializeClient,The length of the statement  "		uint returnValue = AcquireCredentialsHandle (null' "Kerberos"' SECPKG_CRED_OUTBOUND' IntPtr.Zero' IntPtr.Zero' IntPtr.Zero' IntPtr.Zero' ref _hOutboundCred' ref ClientLifeTime); " is 177.
Long Statement,agsXMPP.Sasl.Gssapi,SSPIHelper,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\Gssapi\SSPIHelper.cs,InitializeClient,The length of the statement  "			ss = InitializeSecurityContext (ref _hOutboundCred' IntPtr.Zero' _sRemotePrincipal' STANDARD_CONTEXT_ATTRIBUTES' 0' SECURITY_NETWORK_DREP' IntPtr.Zero' 0' out _hClientContext' out ClientToken' out ContextAttributes' out ClientLifeTime); " is 236.
Long Statement,agsXMPP.Sasl.Gssapi,SSPIHelper,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\Gssapi\SSPIHelper.cs,InitializeClient,The length of the statement  "				ss = InitializeSecurityContext (ref _hOutboundCred' ref _hClientContext' _sRemotePrincipal' STANDARD_CONTEXT_ATTRIBUTES' 0' SECURITY_NETWORK_DREP' ref ServerToken' 0' out _hClientContext' out ClientToken' out ContextAttributes' out ClientLifeTime); " is 248.
Long Statement,agsXMPP.Sasl,SaslHandler,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\SaslHandler.cs,OnStreamElement,The length of the statement  "	if (m_XmppClient.XmppConnectionState == XmppConnectionState.Securing || m_XmppClient.XmppConnectionState == XmppConnectionState.StartCompression) " is 145.
Long Statement,agsXMPP.Sasl,SaslHandler,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\SaslHandler.cs,OnStreamElement,The length of the statement  "					if (m_XmppClient.UseStartTLS == false && m_XmppClient.UseSSL == false && f.Mechanisms.SupportsMechanism (MechanismType.X_GOOGLE_TOKEN)) { " is 137.
Long Statement,agsXMPP.Sasl,SaslHandler,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\SaslHandler.cs,OnStreamElement,The length of the statement  "				BindIq bIq = string.IsNullOrEmpty (m_XmppClient.Resource) ? new BindIq (IqType.set) : new BindIq (IqType.set' m_XmppClient.Resource); " is 133.
Long Statement,agsXMPP.Sasl,SaslHandler,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\SaslHandler.cs,DoBind,The length of the statement  "	BindIq bIq = string.IsNullOrEmpty (m_XmppClient.Resource) ? new BindIq (IqType.set) : new BindIq (IqType.set' m_XmppClient.Resource); " is 133.
Long Statement,agsXMPP.Sasl.DigestMD5,DigestMD5Mechanism,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\DigestMD5\DigestMD5Mechanism.cs,Parse,The length of the statement  "			//response xmlns="urn:ietf:params:xml:ns:xmpp-sasl">dXNlcm5hbWU9ImduYXVjayIscmVhbG09IiIsbm9uY2U9IjM4MDQzMjI1MSIsY25vbmNlPSIxNDE4N2MxMDUyODk3N2RiMjZjOWJhNDE2ZDgwNDI4MSIsbmM9MDAwMDAwMDEscW9wPWF1dGgsZGlnZXN0LXVyaT0ieG1wcC9qYWJiZXIucnUiLGNoYXJzZXQ9dXRmLTgscmVzcG9uc2U9NDcwMTI5NDU4Y2EwOGVjYjhhYTIxY2UzMDhhM2U5Nzc " is 307.
Long Statement,agsXMPP.Util,Time,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Util\Date.cs,Date,The length of the statement  "		DateTime dt = new DateTime (int.Parse (date.Substring (0' 4))' int.Parse (date.Substring (4' 2))' int.Parse (date.Substring (6' 2))' int.Parse (date.Substring (9' 2))' int.Parse (date.Substring (12' 2))' int.Parse (date.Substring (15' 2))); " is 240.
Long Statement,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The length of the statement  "			if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) { " is 162.
Long Statement,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The length of the statement  "		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) { " is 202.
Long Statement,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The length of the statement  "					if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open)))) " is 180.
Complex Conditional,agsXMPP.Idn,IDNA,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\IDNA.cs,ToASCII,The conditional expression  "c == '.' || c == '\u3002' || c == '\uff0e' || c == '\uff61'"  is complex.
Complex Conditional,agsXMPP.Idn,IDNA,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\IDNA.cs,ToASCII,The conditional expression  "(c <= 0x2c) || (c >= 0x2e && c <= 0x2f) || (c >= 0x3a && c <= 0x40) || (c >= 0x5b && c <= 0x60) || (c >= 0x7b && c <= 0x7f)"  is complex.
Complex Conditional,agsXMPP.Idn,IDNA,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\IDNA.cs,ToUnicode,The conditional expression  "c == '.' || c == '\u3002' || c == '\uff0e' || c == '\uff61'"  is complex.
Complex Conditional,agsXMPP.Idn,NFKC,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\NFKC.cs,compose,The conditional expression  "ai >= 0 && ai < Composition.multiSecondStart && bi >= Composition.multiSecondStart && bi < Composition.singleFirstStart"  is complex.
Complex Conditional,agsXMPP.Idn,Stringprep,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\Stringprep.cs,NamePrep,The conditional expression  "Contains (s' RFC3454.C12) || Contains (s' RFC3454.C22) || Contains (s' RFC3454.C3) || Contains (s' RFC3454.C4) || Contains (s' RFC3454.C5) || Contains (s' RFC3454.C6) || Contains (s' RFC3454.C7) || Contains (s' RFC3454.C8)"  is complex.
Complex Conditional,agsXMPP.Idn,Stringprep,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\Stringprep.cs,NodePrep,The conditional expression  "Contains (s' RFC3454.C11) || Contains (s' RFC3454.C12) || Contains (s' RFC3454.C21) || Contains (s' RFC3454.C22) || Contains (s' RFC3454.C3) || Contains (s' RFC3454.C4) || Contains (s' RFC3454.C5) || Contains (s' RFC3454.C6) || Contains (s' RFC3454.C7) || Contains (s' RFC3454.C8) || Contains (s' RFC3920_NODEPREP_PROHIBIT)"  is complex.
Complex Conditional,agsXMPP.Idn,Stringprep,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\Stringprep.cs,ResourcePrep,The conditional expression  "Contains (s' RFC3454.C12) || Contains (s' RFC3454.C21) || Contains (s' RFC3454.C22) || Contains (s' RFC3454.C3) || Contains (s' RFC3454.C4) || Contains (s' RFC3454.C5) || Contains (s' RFC3454.C6) || Contains (s' RFC3454.C7) || Contains (s' RFC3454.C8)"  is complex.
Complex Conditional,agsXMPP.Net,BoshClientSocket,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\BoshClientSocket.cs,OnGetResponse,The conditional expression  "(activeRequests == 0 && !terminated) || (activeRequests == 1 && m_SendQueue.Count > 0)"  is complex.
Complex Conditional,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,FindLongestMatch,The conditional expression  "window [curMatch + best_len] != scan_end || window [curMatch + best_len - 1] != scan_end1 || window [curMatch] != window [scan] || window [curMatch + 1] != window [scan + 1]"  is complex.
Complex Conditional,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,DeflateStored,The conditional expression  "(storedLen >= DeflaterConstants.MAX_BLOCK_SIZE) || /* Block is full */(blockStart < WSIZE && storedLen >= MAX_DIST) || /* Block may move out of window */flush"  is complex.
Complex Conditional,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,DeflateFast,The conditional expression  "lookahead >= MIN_MATCH && (hashHead = InsertString ()) != 0 && strategy != DeflateStrategy.HuffmanOnly && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)"  is complex.
Complex Conditional,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,DeflateSlow,The conditional expression  "strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)"  is complex.
Complex Conditional,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,DeflateSlow,The conditional expression  "matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TOO_FAR))"  is complex.
Complex Conditional,agsXMPP,XmppClientConnection,D:\newReposJune17\meebey_agsxmpp\agsxmpp\XmppClientConnection.cs,SocketOnError,The conditional expression  "(ex.GetType () == typeof(ConnectTimeoutException) || (ex.GetType () == typeof(SocketException) && ((SocketException)ex).ErrorCode == 10061)) && _SRVRecords != null && _SRVRecords.Length > 1"  is complex.
Complex Conditional,agsXMPP.Xml.Dom,Node,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Dom\Node.cs,WriteTree,The conditional expression  "(parent == null || parent.Namespace != el.Namespace) && el.Namespace != null && el.Namespace.Length != 0"  is complex.
Complex Conditional,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The conditional expression  "end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')"  is complex.
Complex Conditional,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The conditional expression  "end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')"  is complex.
Complex Conditional,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The conditional expression  "normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open)))"  is complex.
Empty Catch Block,agsXMPP.Net,BoshClientSocket,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\BoshClientSocket.cs,RequestBoshSession,The method has an empty catch block.
Empty Catch Block,agsXMPP.Net,BoshClientSocket,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\BoshClientSocket.cs,StartWebRequest,The method has an empty catch block.
Empty Catch Block,agsXMPP.Net,BoshClientSocket,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\BoshClientSocket.cs,OnEndWrite,The method has an empty catch block.
Empty Catch Block,agsXMPP.Net,BoshClientSocket,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\BoshClientSocket.cs,OnGetResponse,The method has an empty catch block.
Empty Catch Block,agsXMPP.Net,ClientSocket,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\ClientSocket.cs,Disconnect,The method has an empty catch block.
Empty Catch Block,agsXMPP.Net,ClientSocket,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\ClientSocket.cs,Send,The method has an empty catch block.
Empty Catch Block,agsXMPP.Xml,StreamParser,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\StreamParser.cs,Push,The method has an empty catch block.
Empty Catch Block,agsXMPP.Xml,StreamParser,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\StreamParser.cs,Push,The method has an empty catch block.
Empty Catch Block,agsXMPP.Xml,StreamParser,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\StreamParser.cs,NormalizeAttributeValue,The method has an empty catch block.
Empty Catch Block,agsXMPP.Xml,StreamParser,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\StreamParser.cs,NormalizeAttributeValue,The method has an empty catch block.
Magic Number,agsXMPP.Idn,IDNA,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\IDNA.cs,ToASCII,The following statement contains a magic number: if (output.Length < 1 || output.Length > 63) {  	throw new IDNAException (IDNAException.TOO_LONG);  }  
Magic Number,agsXMPP.Idn,NFKC,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\NFKC.cs,decomposeIndex,The following statement contains a magic number: while (true) {  	int half = (start + end) / 2;  	int code = DecompositionKeys.k [half * 2];  	if (c == code) {  		return DecompositionKeys.k [half * 2 + 1];  	}  	if (half == start) {  		// Character not found  		return -1;  	} else if (c > code) {  		start = half;  	} else {  		end = half;  	}  }  
Magic Number,agsXMPP.Idn,NFKC,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\NFKC.cs,decomposeIndex,The following statement contains a magic number: while (true) {  	int half = (start + end) / 2;  	int code = DecompositionKeys.k [half * 2];  	if (c == code) {  		return DecompositionKeys.k [half * 2 + 1];  	}  	if (half == start) {  		// Character not found  		return -1;  	} else if (c > code) {  		start = half;  	} else {  		end = half;  	}  }  
Magic Number,agsXMPP.Idn,NFKC,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\NFKC.cs,decomposeIndex,The following statement contains a magic number: while (true) {  	int half = (start + end) / 2;  	int code = DecompositionKeys.k [half * 2];  	if (c == code) {  		return DecompositionKeys.k [half * 2 + 1];  	}  	if (half == start) {  		// Character not found  		return -1;  	} else if (c > code) {  		start = half;  	} else {  		end = half;  	}  }  
Magic Number,agsXMPP.Idn,NFKC,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\NFKC.cs,decomposeIndex,The following statement contains a magic number: if (c == code) {  	return DecompositionKeys.k [half * 2 + 1];  }  
Magic Number,agsXMPP.Idn,NFKC,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\NFKC.cs,decomposeIndex,The following statement contains a magic number: return DecompositionKeys.k [half * 2 + 1];  
Magic Number,agsXMPP.Idn,NFKC,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\NFKC.cs,composeIndex,The following statement contains a magic number: if (a >> 8 >= Composition.composePage.Length) {  	return -1;  }  
Magic Number,agsXMPP.Idn,Punycode,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\Punycode.cs,Adapt,The following statement contains a magic number: if (first) {  	delta = delta / DAMP;  } else {  	delta = delta / 2;  }  
Magic Number,agsXMPP.Idn,Punycode,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\Punycode.cs,Adapt,The following statement contains a magic number: delta = delta / 2;  
Magic Number,agsXMPP.Idn,Punycode,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\Punycode.cs,Adapt,The following statement contains a magic number: while (delta > ((BASE - TMIN) * TMAX) / 2) {  	delta = delta / (BASE - TMIN);  	k = k + BASE;  }  
Magic Number,agsXMPP.Idn,Punycode,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\Punycode.cs,Digit2Codepoint,The following statement contains a magic number: if (d < 26) {  	// 0..25 : 'a'..'z'  	return d + 'a';  } else if (d < 36) {  	// 26..35 : '0'..'9';  	return d - 26 + '0';  } else {  	throw new PunycodeException (PunycodeException.BAD_INPUT);  }  
Magic Number,agsXMPP.Idn,Punycode,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\Punycode.cs,Digit2Codepoint,The following statement contains a magic number: if (d < 26) {  	// 0..25 : 'a'..'z'  	return d + 'a';  } else if (d < 36) {  	// 26..35 : '0'..'9';  	return d - 26 + '0';  } else {  	throw new PunycodeException (PunycodeException.BAD_INPUT);  }  
Magic Number,agsXMPP.Idn,Punycode,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\Punycode.cs,Digit2Codepoint,The following statement contains a magic number: if (d < 26) {  	// 0..25 : 'a'..'z'  	return d + 'a';  } else if (d < 36) {  	// 26..35 : '0'..'9';  	return d - 26 + '0';  } else {  	throw new PunycodeException (PunycodeException.BAD_INPUT);  }  
Magic Number,agsXMPP.Idn,Punycode,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\Punycode.cs,Digit2Codepoint,The following statement contains a magic number: if (d < 36) {  	// 26..35 : '0'..'9';  	return d - 26 + '0';  } else {  	throw new PunycodeException (PunycodeException.BAD_INPUT);  }  
Magic Number,agsXMPP.Idn,Punycode,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\Punycode.cs,Digit2Codepoint,The following statement contains a magic number: if (d < 36) {  	// 26..35 : '0'..'9';  	return d - 26 + '0';  } else {  	throw new PunycodeException (PunycodeException.BAD_INPUT);  }  
Magic Number,agsXMPP.Idn,Punycode,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\Punycode.cs,Digit2Codepoint,The following statement contains a magic number: return d - 26 + '0';  
Magic Number,agsXMPP.Idn,Punycode,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\Punycode.cs,Codepoint2Digit,The following statement contains a magic number: if (c - '0' < 10) {  	// '0'..'9' : 26..35  	return c - '0' + 26;  } else if (c - 'a' < 26) {  	// 'a'..'z' : 0..25  	return c - 'a';  } else {  	throw new PunycodeException (PunycodeException.BAD_INPUT);  }  
Magic Number,agsXMPP.Idn,Punycode,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\Punycode.cs,Codepoint2Digit,The following statement contains a magic number: if (c - '0' < 10) {  	// '0'..'9' : 26..35  	return c - '0' + 26;  } else if (c - 'a' < 26) {  	// 'a'..'z' : 0..25  	return c - 'a';  } else {  	throw new PunycodeException (PunycodeException.BAD_INPUT);  }  
Magic Number,agsXMPP.Idn,Punycode,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\Punycode.cs,Codepoint2Digit,The following statement contains a magic number: if (c - '0' < 10) {  	// '0'..'9' : 26..35  	return c - '0' + 26;  } else if (c - 'a' < 26) {  	// 'a'..'z' : 0..25  	return c - 'a';  } else {  	throw new PunycodeException (PunycodeException.BAD_INPUT);  }  
Magic Number,agsXMPP.Idn,Punycode,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\Punycode.cs,Codepoint2Digit,The following statement contains a magic number: return c - '0' + 26;  
Magic Number,agsXMPP.Idn,Punycode,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\Punycode.cs,Codepoint2Digit,The following statement contains a magic number: if (c - 'a' < 26) {  	// 'a'..'z' : 0..25  	return c - 'a';  } else {  	throw new PunycodeException (PunycodeException.BAD_INPUT);  }  
Magic Number,agsXMPP.Idn,Stringprep,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\Stringprep.cs,Contains,The following statement contains a magic number: for (int i = 0; i < p.Length; i++) {  	char[] r = p [i];  	if (1 == r.Length) {  		char c = r [0];  		for (int j = 0; j < s.Length; j++) {  			if (c == s [j]) {  				return true;  			}  		}  	} else if (2 == r.Length) {  		char f = r [0];  		char t = r [1];  		for (int j = 0; j < s.Length; j++) {  			if (f <= s [j] && t >= s [j]) {  				return true;  			}  		}  	}  }  
Magic Number,agsXMPP.Idn,Stringprep,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\Stringprep.cs,Contains,The following statement contains a magic number: if (1 == r.Length) {  	char c = r [0];  	for (int j = 0; j < s.Length; j++) {  		if (c == s [j]) {  			return true;  		}  	}  } else if (2 == r.Length) {  	char f = r [0];  	char t = r [1];  	for (int j = 0; j < s.Length; j++) {  		if (f <= s [j] && t >= s [j]) {  			return true;  		}  	}  }  
Magic Number,agsXMPP.Idn,Stringprep,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\Stringprep.cs,Contains,The following statement contains a magic number: if (2 == r.Length) {  	char f = r [0];  	char t = r [1];  	for (int j = 0; j < s.Length; j++) {  		if (f <= s [j] && t >= s [j]) {  			return true;  		}  	}  }  
Magic Number,agsXMPP.Idn,Stringprep,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\Stringprep.cs,Contains,The following statement contains a magic number: for (int i = 0; i < p.Length; i++) {  	char[] r = p [i];  	if (1 == r.Length) {  		if (c == r [0]) {  			return true;  		}  	} else if (2 == r.Length) {  		char f = r [0];  		char t = r [1];  		if (f <= c && t >= c) {  			return true;  		}  	}  }  
Magic Number,agsXMPP.Idn,Stringprep,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\Stringprep.cs,Contains,The following statement contains a magic number: if (1 == r.Length) {  	if (c == r [0]) {  		return true;  	}  } else if (2 == r.Length) {  	char f = r [0];  	char t = r [1];  	if (f <= c && t >= c) {  		return true;  	}  }  
Magic Number,agsXMPP.Idn,Stringprep,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\Stringprep.cs,Contains,The following statement contains a magic number: if (2 == r.Length) {  	char f = r [0];  	char t = r [1];  	if (f <= c && t >= c) {  		return true;  	}  }  
Magic Number,agsXMPP.Idn,Stringprep,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\Stringprep.cs,Filter,The following statement contains a magic number: for (int i = 0; i < f.Length; i++) {  	char[] r = f [i];  	if (1 == r.Length) {  		char c = r [0];  		int j = 0;  		while (j < s.Length) {  			if (c == s [j]) {  				//s.deleteCharAt(j);  				s.Remove (j' 1);  			} else {  				j++;  			}  		}  	} else if (2 == r.Length) {  		char from = r [0];  		char to = r [1];  		int j = 0;  		while (j < s.Length) {  			if (from <= s [j] && to >= s [j]) {  				//s.deleteCharAt(j);  				s.Remove (j' 1);  			} else {  				j++;  			}  		}  	}  }  
Magic Number,agsXMPP.Idn,Stringprep,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\Stringprep.cs,Filter,The following statement contains a magic number: if (1 == r.Length) {  	char c = r [0];  	int j = 0;  	while (j < s.Length) {  		if (c == s [j]) {  			//s.deleteCharAt(j);  			s.Remove (j' 1);  		} else {  			j++;  		}  	}  } else if (2 == r.Length) {  	char from = r [0];  	char to = r [1];  	int j = 0;  	while (j < s.Length) {  		if (from <= s [j] && to >= s [j]) {  			//s.deleteCharAt(j);  			s.Remove (j' 1);  		} else {  			j++;  		}  	}  }  
Magic Number,agsXMPP.Idn,Stringprep,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Idn\Stringprep.cs,Filter,The following statement contains a magic number: if (2 == r.Length) {  	char from = r [0];  	char to = r [1];  	int j = 0;  	while (j < s.Length) {  		if (from <= s [j] && to >= s [j]) {  			//s.deleteCharAt(j);  			s.Remove (j' 1);  		} else {  			j++;  		}  	}  }  
Magic Number,agsXMPP.Net,BoshClientSocket,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\BoshClientSocket.cs,RequestBoshSession,The following statement contains a magic number: req.Timeout = m_Wait * 1000;  
Magic Number,agsXMPP.Net,BoshClientSocket,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\BoshClientSocket.cs,Request,The following statement contains a magic number: if (activeRequests < 2)  	StartWebRequest ();  
Magic Number,agsXMPP.Net,BoshClientSocket,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\BoshClientSocket.cs,StartWebRequest,The following statement contains a magic number: req.Timeout = m_Wait * 1000;  
Magic Number,agsXMPP.Net,BoshClientSocket,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\BoshClientSocket.cs,OnGetResponse,The following statement contains a magic number: try {  	requestIsTerminating = true;  	// grab the custom state object  	WebRequestState state = (WebRequestState)ar.AsyncState;  	HttpWebRequest request = (HttpWebRequest)state.WebRequest;  	HttpWebResponse resp = null;  	if (request.HaveResponse) {  		// TODO' its crashing mostly here  		// get the Response  		try {  			resp = (HttpWebResponse)request.EndGetResponse (ar);  		} catch (WebException ex) {  			activeRequests--;  			requestIsTerminating = false;  			if (ex.Response == null) {  				StartWebRequest ();  			} else {  				HttpWebResponse res = ex.Response as HttpWebResponse;  				if (res.StatusCode == HttpStatusCode.NotFound) {  					TerminateBoshSession ();  				}  			}  			return;  		}  		// The server must always return a 200 response code'  		// sending any session errors as specially-formatted identifiers.  		if (resp.StatusCode != HttpStatusCode.OK) {  			activeRequests--;  			requestIsTerminating = false;  			if (resp.StatusCode == HttpStatusCode.NotFound) {  				//Console.WriteLine("Not Found");  				TerminateBoshSession ();  			}  			return;  		}  	} else {  		//Console.WriteLine("No response");  	}  	Stream rs = resp.GetResponseStream ();  	int readlen;  	byte[] readbuf = new byte[1024];  	MemoryStream ms = new MemoryStream ();  	while ((readlen = rs.Read (readbuf' 0' readbuf.Length)) > 0) {  		ms.Write (readbuf' 0' readlen);  	}  	byte[] recv = ms.ToArray ();  	if (recv.Length > 0) {  		string sbody = null;  		string stanzas = null;  		ParseResponse (Encoding.UTF8.GetString (recv' 0' recv.Length)' ref sbody' ref stanzas);  		if (stanzas != null) {  			byte[] bStanzas = Encoding.UTF8.GetBytes (stanzas);  			base.FireOnReceive (bStanzas' bStanzas.Length);  		} else {  			if (sbody != null) {  				var doc = new Document ();  				doc.LoadXml (sbody);  				if (doc.RootElement != null) {  					var body = doc.RootElement as Body;  					if (body.Type == BoshType.terminate)  						TerminateBoshSession ();  				}  			}  			if (terminate && !terminated) {  				// empty teminate response  				TerminateBoshSession ();  			}  		}  	}  	// cleanup webrequest resources  	ms.Close ();  	rs.Close ();  	resp.Close ();  	activeRequests--;  	requestIsTerminating = false;  	//if (activeRequests == 0 && !terminated)  	if ((activeRequests == 0 && !terminated) || (activeRequests == 1 && m_SendQueue.Count > 0)) {  		StartWebRequest ();  	}  } catch (Exception ex) {  }  
Magic Number,agsXMPP.Net,ClientSocket,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\ClientSocket.cs,Connect,The following statement contains a magic number: try {  	_socket = new TcpClient ();  	_socket.NoDelay = true;  	_socket.Client.SetSocketOption (SocketOptionLevel.Socket' SocketOptionName.KeepAlive' 1);  	// set timeout' after this the connection will be aborted  	_socket.ReceiveTimeout = 600 * 1000;  	_socket.SendTimeout = 600 * 1000;  	if (Proxy != null) {  		_socket.Connect (Proxy.ProxyHost' Proxy.ProxyPort);  		Proxy.TcpClient = _socket;  		Proxy.CreateConnection (Address' Port);  	} else {  		_socket.Connect (Address' Port);  	}  	m_Stream = _socket.GetStream ();  	m_NetworkStream = m_Stream;  	#if SSL  	if (m_SSL)  		InitSSL ();  	#endif  	FireOnConnect ();  	// Setup Receive Callback  	this.Receive ();  } catch (Exception ex) {  	base.FireOnError (ex);  }  
Magic Number,agsXMPP.Net,ClientSocket,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\ClientSocket.cs,Connect,The following statement contains a magic number: try {  	_socket = new TcpClient ();  	_socket.NoDelay = true;  	_socket.Client.SetSocketOption (SocketOptionLevel.Socket' SocketOptionName.KeepAlive' 1);  	// set timeout' after this the connection will be aborted  	_socket.ReceiveTimeout = 600 * 1000;  	_socket.SendTimeout = 600 * 1000;  	if (Proxy != null) {  		_socket.Connect (Proxy.ProxyHost' Proxy.ProxyPort);  		Proxy.TcpClient = _socket;  		Proxy.CreateConnection (Address' Port);  	} else {  		_socket.Connect (Address' Port);  	}  	m_Stream = _socket.GetStream ();  	m_NetworkStream = m_Stream;  	#if SSL  	if (m_SSL)  		InitSSL ();  	#endif  	FireOnConnect ();  	// Setup Receive Callback  	this.Receive ();  } catch (Exception ex) {  	base.FireOnError (ex);  }  
Magic Number,agsXMPP.Net,ClientSocket,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\ClientSocket.cs,Connect,The following statement contains a magic number: try {  	_socket = new TcpClient ();  	_socket.NoDelay = true;  	_socket.Client.SetSocketOption (SocketOptionLevel.Socket' SocketOptionName.KeepAlive' 1);  	// set timeout' after this the connection will be aborted  	_socket.ReceiveTimeout = 600 * 1000;  	_socket.SendTimeout = 600 * 1000;  	if (Proxy != null) {  		_socket.Connect (Proxy.ProxyHost' Proxy.ProxyPort);  		Proxy.TcpClient = _socket;  		Proxy.CreateConnection (Address' Port);  	} else {  		_socket.Connect (Address' Port);  	}  	m_Stream = _socket.GetStream ();  	m_NetworkStream = m_Stream;  	#if SSL  	if (m_SSL)  		InitSSL ();  	#endif  	FireOnConnect ();  	// Setup Receive Callback  	this.Receive ();  } catch (Exception ex) {  	base.FireOnError (ex);  }  
Magic Number,agsXMPP.Net,ClientSocket,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\ClientSocket.cs,Connect,The following statement contains a magic number: try {  	_socket = new TcpClient ();  	_socket.NoDelay = true;  	_socket.Client.SetSocketOption (SocketOptionLevel.Socket' SocketOptionName.KeepAlive' 1);  	// set timeout' after this the connection will be aborted  	_socket.ReceiveTimeout = 600 * 1000;  	_socket.SendTimeout = 600 * 1000;  	if (Proxy != null) {  		_socket.Connect (Proxy.ProxyHost' Proxy.ProxyPort);  		Proxy.TcpClient = _socket;  		Proxy.CreateConnection (Address' Port);  	} else {  		_socket.Connect (Address' Port);  	}  	m_Stream = _socket.GetStream ();  	m_NetworkStream = m_Stream;  	#if SSL  	if (m_SSL)  		InitSSL ();  	#endif  	FireOnConnect ();  	// Setup Receive Callback  	this.Receive ();  } catch (Exception ex) {  	base.FireOnError (ex);  }  
Magic Number,agsXMPP.Net,ClientSocket,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\ClientSocket.cs,Connect,The following statement contains a magic number: _socket.ReceiveTimeout = 600 * 1000;  
Magic Number,agsXMPP.Net,ClientSocket,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\ClientSocket.cs,Connect,The following statement contains a magic number: _socket.ReceiveTimeout = 600 * 1000;  
Magic Number,agsXMPP.Net,ClientSocket,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\ClientSocket.cs,Connect,The following statement contains a magic number: _socket.SendTimeout = 600 * 1000;  
Magic Number,agsXMPP.Net,ClientSocket,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\ClientSocket.cs,Connect,The following statement contains a magic number: _socket.SendTimeout = 600 * 1000;  
Magic Number,agsXMPP.Net,PollClientSocket,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\PollClientSocket.cs,PollThread,The following statement contains a magic number: while (m_Connected) {  	string content;  	string data;  	//				lock(m_lock)  	//				{  	if (m_SendQueue.Count > 0)  		data = m_SendQueue.Dequeue () as string;  	else  		data = "";  	//				}  	if (m_ID == null) {  		GenerateKeys ();  		content = string.Format ("{0};{1}'{2}"' "0"' m_Keys [m_CurrentKeyIdx]' data);  	} else {  		if (m_CurrentKeyIdx == 0) {  			// only 1 Key left  			string key = m_Keys [0];  			// generate new keys  			GenerateKeys ();  			/* 						Example 9. Changing key  						POST /wc12/webclient HTTP/1.1 						Content-Type: application/x-www-form-urlencoded 						Host: webim.jabber.com  						7776:2054;C+7Hteo/D9vJXQ3UfzxbwnXaijM=;Tr697Eff02+32FZp38Xaq2+3Bv4='<presence/>     						*/content = string.Format ("{0};{1};{2}'{3}"' m_ID' key' m_Keys [m_CurrentKeyIdx]' data);  		} else {  			// m_CurrentKey = CreateNextKey(m_CurrentKey);  			content = string.Format ("{0};{1}'{2}"' m_ID' m_Keys [m_CurrentKeyIdx]' data);  		}  	}  	//Console.WriteLine("used Key index: " + m_CurrentKeyIdx.ToString());  	m_CurrentKeyIdx--;  	byte[] bytes = Encoding.UTF8.GetBytes (content);  	FireOnSend (bytes' bytes.Length);  	HttpWebRequest req = (HttpWebRequest)WebRequest.Create (Address);  	// Set Proxy Information  	if (m_Proxy != null)  		req.Proxy = m_Proxy;  	req.Method = METHOD;  	//req.KeepAlive		= true;  	req.ContentType = CONTENT_TYPE;  	req.ContentLength = bytes.Length;  	req.Timeout = 5000;  	Stream outputStream;  	try {  		outputStream = req.GetRequestStream ();  	} catch (Exception ex) {  		base.FireOnError (ex);  		Disconnect ();  		return;  	}  	outputStream.Write (bytes' 0' bytes.Length);  	outputStream.Close ();  	// This does the Webrequest. So catch errors here  	HttpWebResponse resp;  	try {  		resp = (HttpWebResponse)req.GetResponse ();  	} catch (Exception ex) {  		FireOnError (ex);  		return;  	}  	// The server must always return a 200 response code'  	// sending any session errors as specially-formatted identifiers.  	if (resp.StatusCode != HttpStatusCode.OK) {  		FireOnError (new PollSocketException ("unexpected status code " + resp.StatusCode.ToString ()));  		return;  	}  	Stream rs = resp.GetResponseStream ();  	int readlen;  	byte[] readbuf = new byte[1024];  	MemoryStream ms = new MemoryStream ();  	while ((readlen = rs.Read (readbuf' 0' readbuf.Length)) > 0) {  		ms.Write (readbuf' 0' readlen);  	}  	byte[] recv = ms.ToArray ();  	// Read Cookies from Header  	// Set-Cookie: ID=7776:2054; path=/webclient/; expires=-1  	WebHeaderCollection headers = resp.Headers;  	// Check for any cookies  	// Didnt get the .NET CookieCollection classes working correct  	// So read it by hand' i cookie is only another simple header  	if (headers ["Set-Cookie"] != null) {  		string header = headers ["Set-Cookie"];  		string[] cookies = header.Split ((char)';');  		Hashtable htCookies = new Hashtable ();  		foreach (string cookie in cookies) {  			string[] vals = cookie.Split ((char)'=');  			if (vals.Length == 2)  				htCookies.Add (vals [0]' vals [1]);  		}  		if (htCookies.ContainsKey ("ID")) {  			string id = htCookies ["ID"] as string;  			// if ID ends with its an error message  			if (!id.EndsWith (":0")) {  				// if me dont have the ID yet cache it  				if (m_ID == null)  					m_ID = id;  			} else {  				// Handle Errors  				switch (id) {  				case "0:0":  					// 3.1.1 Unknown Error  					// Server returns ID=0:0.  					// The response body can contain a textual error message.									  					return;  				case "-1:0":  					// 3.1.2 Server Error  					// Server returns ID=-1:0  					return;  				case "-2:0":  					// 3.1.3 Bad Request  					// Server returns ID=-2:0  					return;  				case "-3:0":  					// 3.1.4 Key Sequence Error  					// Server returns ID=-3:0  					return;  				}  			}  		}  	}  	// cleanup webrequest resources  	ms.Close ();  	rs.Close ();  	resp.Close ();  	if (recv.Length > 0) {  		//Console.WriteLine("RECV: " + Encoding.UTF8.GetString(recv));  		FireOnReceive (recv' recv.Length);  	} else {  		// We received nothing in the response'   		// so sleep until next poll  		#if CF || CF_2  							if (m_SendQueue.Count == 0) 					{							 						m_WaitUntil = DateTime.Now.AddMilliseconds(m_Interval); 						while (m_SendQueue.Count == 0 && DateTime.Compare(m_WaitUntil' DateTime.Now) > 0) 						{							 							Thread.Sleep(100); 						} 					}					 #else  		lock (m_Lock) {  			if (m_SendQueue.Count == 0) {  				// Left for debugging  				//Console.WriteLine("Start Wait: " + m_Interval.ToString());							  				Monitor.Wait (m_Lock' m_Interval);  				//Console.WriteLine("End Wait:");  			}  		}  		#endif  	}  }  
Magic Number,agsXMPP.Net,PollClientSocket,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\PollClientSocket.cs,PollThread,The following statement contains a magic number: while (m_Connected) {  	string content;  	string data;  	//				lock(m_lock)  	//				{  	if (m_SendQueue.Count > 0)  		data = m_SendQueue.Dequeue () as string;  	else  		data = "";  	//				}  	if (m_ID == null) {  		GenerateKeys ();  		content = string.Format ("{0};{1}'{2}"' "0"' m_Keys [m_CurrentKeyIdx]' data);  	} else {  		if (m_CurrentKeyIdx == 0) {  			// only 1 Key left  			string key = m_Keys [0];  			// generate new keys  			GenerateKeys ();  			/* 						Example 9. Changing key  						POST /wc12/webclient HTTP/1.1 						Content-Type: application/x-www-form-urlencoded 						Host: webim.jabber.com  						7776:2054;C+7Hteo/D9vJXQ3UfzxbwnXaijM=;Tr697Eff02+32FZp38Xaq2+3Bv4='<presence/>     						*/content = string.Format ("{0};{1};{2}'{3}"' m_ID' key' m_Keys [m_CurrentKeyIdx]' data);  		} else {  			// m_CurrentKey = CreateNextKey(m_CurrentKey);  			content = string.Format ("{0};{1}'{2}"' m_ID' m_Keys [m_CurrentKeyIdx]' data);  		}  	}  	//Console.WriteLine("used Key index: " + m_CurrentKeyIdx.ToString());  	m_CurrentKeyIdx--;  	byte[] bytes = Encoding.UTF8.GetBytes (content);  	FireOnSend (bytes' bytes.Length);  	HttpWebRequest req = (HttpWebRequest)WebRequest.Create (Address);  	// Set Proxy Information  	if (m_Proxy != null)  		req.Proxy = m_Proxy;  	req.Method = METHOD;  	//req.KeepAlive		= true;  	req.ContentType = CONTENT_TYPE;  	req.ContentLength = bytes.Length;  	req.Timeout = 5000;  	Stream outputStream;  	try {  		outputStream = req.GetRequestStream ();  	} catch (Exception ex) {  		base.FireOnError (ex);  		Disconnect ();  		return;  	}  	outputStream.Write (bytes' 0' bytes.Length);  	outputStream.Close ();  	// This does the Webrequest. So catch errors here  	HttpWebResponse resp;  	try {  		resp = (HttpWebResponse)req.GetResponse ();  	} catch (Exception ex) {  		FireOnError (ex);  		return;  	}  	// The server must always return a 200 response code'  	// sending any session errors as specially-formatted identifiers.  	if (resp.StatusCode != HttpStatusCode.OK) {  		FireOnError (new PollSocketException ("unexpected status code " + resp.StatusCode.ToString ()));  		return;  	}  	Stream rs = resp.GetResponseStream ();  	int readlen;  	byte[] readbuf = new byte[1024];  	MemoryStream ms = new MemoryStream ();  	while ((readlen = rs.Read (readbuf' 0' readbuf.Length)) > 0) {  		ms.Write (readbuf' 0' readlen);  	}  	byte[] recv = ms.ToArray ();  	// Read Cookies from Header  	// Set-Cookie: ID=7776:2054; path=/webclient/; expires=-1  	WebHeaderCollection headers = resp.Headers;  	// Check for any cookies  	// Didnt get the .NET CookieCollection classes working correct  	// So read it by hand' i cookie is only another simple header  	if (headers ["Set-Cookie"] != null) {  		string header = headers ["Set-Cookie"];  		string[] cookies = header.Split ((char)';');  		Hashtable htCookies = new Hashtable ();  		foreach (string cookie in cookies) {  			string[] vals = cookie.Split ((char)'=');  			if (vals.Length == 2)  				htCookies.Add (vals [0]' vals [1]);  		}  		if (htCookies.ContainsKey ("ID")) {  			string id = htCookies ["ID"] as string;  			// if ID ends with its an error message  			if (!id.EndsWith (":0")) {  				// if me dont have the ID yet cache it  				if (m_ID == null)  					m_ID = id;  			} else {  				// Handle Errors  				switch (id) {  				case "0:0":  					// 3.1.1 Unknown Error  					// Server returns ID=0:0.  					// The response body can contain a textual error message.									  					return;  				case "-1:0":  					// 3.1.2 Server Error  					// Server returns ID=-1:0  					return;  				case "-2:0":  					// 3.1.3 Bad Request  					// Server returns ID=-2:0  					return;  				case "-3:0":  					// 3.1.4 Key Sequence Error  					// Server returns ID=-3:0  					return;  				}  			}  		}  	}  	// cleanup webrequest resources  	ms.Close ();  	rs.Close ();  	resp.Close ();  	if (recv.Length > 0) {  		//Console.WriteLine("RECV: " + Encoding.UTF8.GetString(recv));  		FireOnReceive (recv' recv.Length);  	} else {  		// We received nothing in the response'   		// so sleep until next poll  		#if CF || CF_2  							if (m_SendQueue.Count == 0) 					{							 						m_WaitUntil = DateTime.Now.AddMilliseconds(m_Interval); 						while (m_SendQueue.Count == 0 && DateTime.Compare(m_WaitUntil' DateTime.Now) > 0) 						{							 							Thread.Sleep(100); 						} 					}					 #else  		lock (m_Lock) {  			if (m_SendQueue.Count == 0) {  				// Left for debugging  				//Console.WriteLine("Start Wait: " + m_Interval.ToString());							  				Monitor.Wait (m_Lock' m_Interval);  				//Console.WriteLine("End Wait:");  			}  		}  		#endif  	}  }  
Magic Number,agsXMPP.Net,PollClientSocket,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\PollClientSocket.cs,PollThread,The following statement contains a magic number: while (m_Connected) {  	string content;  	string data;  	//				lock(m_lock)  	//				{  	if (m_SendQueue.Count > 0)  		data = m_SendQueue.Dequeue () as string;  	else  		data = "";  	//				}  	if (m_ID == null) {  		GenerateKeys ();  		content = string.Format ("{0};{1}'{2}"' "0"' m_Keys [m_CurrentKeyIdx]' data);  	} else {  		if (m_CurrentKeyIdx == 0) {  			// only 1 Key left  			string key = m_Keys [0];  			// generate new keys  			GenerateKeys ();  			/* 						Example 9. Changing key  						POST /wc12/webclient HTTP/1.1 						Content-Type: application/x-www-form-urlencoded 						Host: webim.jabber.com  						7776:2054;C+7Hteo/D9vJXQ3UfzxbwnXaijM=;Tr697Eff02+32FZp38Xaq2+3Bv4='<presence/>     						*/content = string.Format ("{0};{1};{2}'{3}"' m_ID' key' m_Keys [m_CurrentKeyIdx]' data);  		} else {  			// m_CurrentKey = CreateNextKey(m_CurrentKey);  			content = string.Format ("{0};{1}'{2}"' m_ID' m_Keys [m_CurrentKeyIdx]' data);  		}  	}  	//Console.WriteLine("used Key index: " + m_CurrentKeyIdx.ToString());  	m_CurrentKeyIdx--;  	byte[] bytes = Encoding.UTF8.GetBytes (content);  	FireOnSend (bytes' bytes.Length);  	HttpWebRequest req = (HttpWebRequest)WebRequest.Create (Address);  	// Set Proxy Information  	if (m_Proxy != null)  		req.Proxy = m_Proxy;  	req.Method = METHOD;  	//req.KeepAlive		= true;  	req.ContentType = CONTENT_TYPE;  	req.ContentLength = bytes.Length;  	req.Timeout = 5000;  	Stream outputStream;  	try {  		outputStream = req.GetRequestStream ();  	} catch (Exception ex) {  		base.FireOnError (ex);  		Disconnect ();  		return;  	}  	outputStream.Write (bytes' 0' bytes.Length);  	outputStream.Close ();  	// This does the Webrequest. So catch errors here  	HttpWebResponse resp;  	try {  		resp = (HttpWebResponse)req.GetResponse ();  	} catch (Exception ex) {  		FireOnError (ex);  		return;  	}  	// The server must always return a 200 response code'  	// sending any session errors as specially-formatted identifiers.  	if (resp.StatusCode != HttpStatusCode.OK) {  		FireOnError (new PollSocketException ("unexpected status code " + resp.StatusCode.ToString ()));  		return;  	}  	Stream rs = resp.GetResponseStream ();  	int readlen;  	byte[] readbuf = new byte[1024];  	MemoryStream ms = new MemoryStream ();  	while ((readlen = rs.Read (readbuf' 0' readbuf.Length)) > 0) {  		ms.Write (readbuf' 0' readlen);  	}  	byte[] recv = ms.ToArray ();  	// Read Cookies from Header  	// Set-Cookie: ID=7776:2054; path=/webclient/; expires=-1  	WebHeaderCollection headers = resp.Headers;  	// Check for any cookies  	// Didnt get the .NET CookieCollection classes working correct  	// So read it by hand' i cookie is only another simple header  	if (headers ["Set-Cookie"] != null) {  		string header = headers ["Set-Cookie"];  		string[] cookies = header.Split ((char)';');  		Hashtable htCookies = new Hashtable ();  		foreach (string cookie in cookies) {  			string[] vals = cookie.Split ((char)'=');  			if (vals.Length == 2)  				htCookies.Add (vals [0]' vals [1]);  		}  		if (htCookies.ContainsKey ("ID")) {  			string id = htCookies ["ID"] as string;  			// if ID ends with its an error message  			if (!id.EndsWith (":0")) {  				// if me dont have the ID yet cache it  				if (m_ID == null)  					m_ID = id;  			} else {  				// Handle Errors  				switch (id) {  				case "0:0":  					// 3.1.1 Unknown Error  					// Server returns ID=0:0.  					// The response body can contain a textual error message.									  					return;  				case "-1:0":  					// 3.1.2 Server Error  					// Server returns ID=-1:0  					return;  				case "-2:0":  					// 3.1.3 Bad Request  					// Server returns ID=-2:0  					return;  				case "-3:0":  					// 3.1.4 Key Sequence Error  					// Server returns ID=-3:0  					return;  				}  			}  		}  	}  	// cleanup webrequest resources  	ms.Close ();  	rs.Close ();  	resp.Close ();  	if (recv.Length > 0) {  		//Console.WriteLine("RECV: " + Encoding.UTF8.GetString(recv));  		FireOnReceive (recv' recv.Length);  	} else {  		// We received nothing in the response'   		// so sleep until next poll  		#if CF || CF_2  							if (m_SendQueue.Count == 0) 					{							 						m_WaitUntil = DateTime.Now.AddMilliseconds(m_Interval); 						while (m_SendQueue.Count == 0 && DateTime.Compare(m_WaitUntil' DateTime.Now) > 0) 						{							 							Thread.Sleep(100); 						} 					}					 #else  		lock (m_Lock) {  			if (m_SendQueue.Count == 0) {  				// Left for debugging  				//Console.WriteLine("Start Wait: " + m_Interval.ToString());							  				Monitor.Wait (m_Lock' m_Interval);  				//Console.WriteLine("End Wait:");  			}  		}  		#endif  	}  }  
Magic Number,agsXMPP.Net,PollClientSocket,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\PollClientSocket.cs,PollThread,The following statement contains a magic number: req.Timeout = 5000;  
Magic Number,agsXMPP.Net,PollClientSocket,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\PollClientSocket.cs,PollThread,The following statement contains a magic number: if (headers ["Set-Cookie"] != null) {  	string header = headers ["Set-Cookie"];  	string[] cookies = header.Split ((char)';');  	Hashtable htCookies = new Hashtable ();  	foreach (string cookie in cookies) {  		string[] vals = cookie.Split ((char)'=');  		if (vals.Length == 2)  			htCookies.Add (vals [0]' vals [1]);  	}  	if (htCookies.ContainsKey ("ID")) {  		string id = htCookies ["ID"] as string;  		// if ID ends with its an error message  		if (!id.EndsWith (":0")) {  			// if me dont have the ID yet cache it  			if (m_ID == null)  				m_ID = id;  		} else {  			// Handle Errors  			switch (id) {  			case "0:0":  				// 3.1.1 Unknown Error  				// Server returns ID=0:0.  				// The response body can contain a textual error message.									  				return;  			case "-1:0":  				// 3.1.2 Server Error  				// Server returns ID=-1:0  				return;  			case "-2:0":  				// 3.1.3 Bad Request  				// Server returns ID=-2:0  				return;  			case "-3:0":  				// 3.1.4 Key Sequence Error  				// Server returns ID=-3:0  				return;  			}  		}  	}  }  
Magic Number,agsXMPP.Net,PollClientSocket,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\PollClientSocket.cs,PollThread,The following statement contains a magic number: foreach (string cookie in cookies) {  	string[] vals = cookie.Split ((char)'=');  	if (vals.Length == 2)  		htCookies.Add (vals [0]' vals [1]);  }  
Magic Number,agsXMPP.Net,PollClientSocket,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\PollClientSocket.cs,PollThread,The following statement contains a magic number: if (vals.Length == 2)  	htCookies.Add (vals [0]' vals [1]);  
Magic Number,agsXMPP.IO.Compression.Checksums,Adler32,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Checksums\Adler32.cs,Update,The following statement contains a magic number: checksum = (s2 << 16) + s1;  
Magic Number,agsXMPP.IO.Compression.Checksums,Adler32,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Checksums\Adler32.cs,Update,The following statement contains a magic number: while (len > 0) {  	// We can defer the modulo operation:  	// s1 maximally grows from 65521 to 65521 + 255 * 3800  	// s2 maximally grows by 3800 * median(s1) = 2090079800 < 2^31  	int n = 3800;  	if (n > len) {  		n = len;  	}  	len -= n;  	while (--n >= 0) {  		s1 = s1 + (uint)(buf [off++] & 0xFF);  		s2 = s2 + s1;  	}  	s1 %= BASE;  	s2 %= BASE;  }  
Magic Number,agsXMPP.IO.Compression.Checksums,Adler32,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Checksums\Adler32.cs,Update,The following statement contains a magic number: checksum = (s2 << 16) | s1;  
Magic Number,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,DeflaterEngine,The following statement contains a magic number: window = new byte[2 * WSIZE];  
Magic Number,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,FillWindow,The following statement contains a magic number: while (lookahead < DeflaterConstants.MIN_LOOKAHEAD && inputOff < inputEnd) {  	int more = 2 * WSIZE - lookahead - strstart;  	if (more > inputEnd - inputOff) {  		more = inputEnd - inputOff;  	}  	System.Array.Copy (inputBuf' inputOff' window' strstart + lookahead' more);  	adler.Update (inputBuf' inputOff' more);  	inputOff += more;  	totalIn += more;  	lookahead += more;  }  
Magic Number,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: if (best_len >= this.goodLength) {  	chainLength >>= 2;  }  
Magic Number,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: chainLength >>= 2;  
Magic Number,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: do {  	/* 				if (DeflaterConstants.DEBUGGING && curMatch >= strstart) { 					throw new InvalidOperationException("future match"); 				} */if (window [curMatch + best_len] != scan_end || window [curMatch + best_len - 1] != scan_end1 || window [curMatch] != window [scan] || window [curMatch + 1] != window [scan + 1]) {  		continue;  	}  	match = curMatch + 2;  	scan += 2;  	/* We check for insufficient lookahead only every 8th comparison; 				* the 256th check will be made at strstart + 258. 				*/while (window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && scan < strend)  		;  	if (scan > best_end) {  		/* 					if (DeflaterConstants.DEBUGGING && ins_h == 0) 						System.err.println("Found match: "+curMatch+"-"+(scan-strstart)); */matchStart = curMatch;  		best_end = scan;  		best_len = scan - strstart;  		if (best_len >= niceLength) {  			break;  		}  		scan_end1 = window [best_end - 1];  		scan_end = window [best_end];  	}  	scan = strstart;  } while ((curMatch = (prev [curMatch & WMASK] & 0xffff)) > limit && --chainLength != 0);  
Magic Number,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: do {  	/* 				if (DeflaterConstants.DEBUGGING && curMatch >= strstart) { 					throw new InvalidOperationException("future match"); 				} */if (window [curMatch + best_len] != scan_end || window [curMatch + best_len - 1] != scan_end1 || window [curMatch] != window [scan] || window [curMatch + 1] != window [scan + 1]) {  		continue;  	}  	match = curMatch + 2;  	scan += 2;  	/* We check for insufficient lookahead only every 8th comparison; 				* the 256th check will be made at strstart + 258. 				*/while (window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && scan < strend)  		;  	if (scan > best_end) {  		/* 					if (DeflaterConstants.DEBUGGING && ins_h == 0) 						System.err.println("Found match: "+curMatch+"-"+(scan-strstart)); */matchStart = curMatch;  		best_end = scan;  		best_len = scan - strstart;  		if (best_len >= niceLength) {  			break;  		}  		scan_end1 = window [best_end - 1];  		scan_end = window [best_end];  	}  	scan = strstart;  } while ((curMatch = (prev [curMatch & WMASK] & 0xffff)) > limit && --chainLength != 0);  
Magic Number,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: match = curMatch + 2;  
Magic Number,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: scan += 2;  
Magic Number,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,SetDictionary,The following statement contains a magic number: strstart += 2;  
Magic Number,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,DeflateFast,The following statement contains a magic number: while (lookahead >= MIN_LOOKAHEAD || flush) {  	if (lookahead == 0) {  		/* We are flushing everything */huffman.FlushBlock (window' blockStart' strstart - blockStart' finish);  		blockStart = strstart;  		return false;  	}  	if (strstart > 2 * WSIZE - MIN_LOOKAHEAD) {  		/* slide window' as findLongestMatch needs this. 					 * This should only happen when flushing and the window 					 * is almost full. 					 */SlideWindow ();  	}  	int hashHead;  	if (lookahead >= MIN_MATCH && (hashHead = InsertString ()) != 0 && strategy != DeflateStrategy.HuffmanOnly && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) {  		/* longestMatch sets matchStart and matchLen *//* 					if (DeflaterConstants.DEBUGGING) { 						for (int i = 0 ; i < matchLen; i++) { 							if (window[strstart+i] != window[matchStart + i]) { 								throw new SharpZipBaseException("Match failure"); 							} 						} 					} */// -jr- Hak hak hak this stops problems with fast/low compression and index out of range  		if (huffman.TallyDist (strstart - matchStart' matchLen)) {  			bool lastBlock = finish && lookahead == 0;  			huffman.FlushBlock (window' blockStart' strstart - blockStart' lastBlock);  			blockStart = strstart;  		}  		lookahead -= matchLen;  		if (matchLen <= max_lazy && lookahead >= MIN_MATCH) {  			while (--matchLen > 0) {  				++strstart;  				InsertString ();  			}  			++strstart;  		} else {  			strstart += matchLen;  			if (lookahead >= MIN_MATCH - 1) {  				UpdateHash ();  			}  		}  		matchLen = MIN_MATCH - 1;  		continue;  	} else {  		/* No match found */huffman.TallyLit (window [strstart] & 0xff);  		++strstart;  		--lookahead;  	}  	if (huffman.IsFull ()) {  		bool lastBlock = finish && lookahead == 0;  		huffman.FlushBlock (window' blockStart' strstart - blockStart' lastBlock);  		blockStart = strstart;  		return !lastBlock;  	}  }  
Magic Number,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,DeflateFast,The following statement contains a magic number: if (strstart > 2 * WSIZE - MIN_LOOKAHEAD) {  	/* slide window' as findLongestMatch needs this. 					 * This should only happen when flushing and the window 					 * is almost full. 					 */SlideWindow ();  }  
Magic Number,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: while (lookahead >= MIN_LOOKAHEAD || flush) {  	if (lookahead == 0) {  		if (prevAvailable) {  			huffman.TallyLit (window [strstart - 1] & 0xff);  		}  		prevAvailable = false;  		// We are flushing everything  		/* 					if (DeflaterConstants.DEBUGGING && !flush) { 						throw new SharpZipBaseException("Not flushing' but no lookahead"); 					} */huffman.FlushBlock (window' blockStart' strstart - blockStart' finish);  		blockStart = strstart;  		return false;  	}  	if (strstart >= 2 * WSIZE - MIN_LOOKAHEAD) {  		/* slide window' as findLongestMatch need this. 					 * This should only happen when flushing and the window 					 * is almost full. 					 */SlideWindow ();  	}  	int prevMatch = matchStart;  	int prevLen = matchLen;  	if (lookahead >= MIN_MATCH) {  		int hashHead = InsertString ();  		if (strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) {  			/* longestMatch sets matchStart and matchLen *//* Discard match if too small and too far away */if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TOO_FAR))) {  				matchLen = MIN_MATCH - 1;  			}  		}  	}  	/* previous match was better */if (prevLen >= MIN_MATCH && matchLen <= prevLen) {  		/* 					if (DeflaterConstants.DEBUGGING) { 					   for (int i = 0 ; i < matchLen; i++) { 					      if (window[strstart-1+i] != window[prevMatch + i]) 					         throw new SharpZipBaseException(); 						} 					} */huffman.TallyDist (strstart - 1 - prevMatch' prevLen);  		prevLen -= 2;  		do {  			strstart++;  			lookahead--;  			if (lookahead >= MIN_MATCH) {  				InsertString ();  			}  		} while (--prevLen > 0);  		strstart++;  		lookahead--;  		prevAvailable = false;  		matchLen = MIN_MATCH - 1;  	} else {  		if (prevAvailable) {  			huffman.TallyLit (window [strstart - 1] & 0xff);  		}  		prevAvailable = true;  		strstart++;  		lookahead--;  	}  	if (huffman.IsFull ()) {  		int len = strstart - blockStart;  		if (prevAvailable) {  			len--;  		}  		bool lastBlock = (finish && lookahead == 0 && !prevAvailable);  		huffman.FlushBlock (window' blockStart' len' lastBlock);  		blockStart += len;  		return !lastBlock;  	}  }  
Magic Number,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: while (lookahead >= MIN_LOOKAHEAD || flush) {  	if (lookahead == 0) {  		if (prevAvailable) {  			huffman.TallyLit (window [strstart - 1] & 0xff);  		}  		prevAvailable = false;  		// We are flushing everything  		/* 					if (DeflaterConstants.DEBUGGING && !flush) { 						throw new SharpZipBaseException("Not flushing' but no lookahead"); 					} */huffman.FlushBlock (window' blockStart' strstart - blockStart' finish);  		blockStart = strstart;  		return false;  	}  	if (strstart >= 2 * WSIZE - MIN_LOOKAHEAD) {  		/* slide window' as findLongestMatch need this. 					 * This should only happen when flushing and the window 					 * is almost full. 					 */SlideWindow ();  	}  	int prevMatch = matchStart;  	int prevLen = matchLen;  	if (lookahead >= MIN_MATCH) {  		int hashHead = InsertString ();  		if (strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) {  			/* longestMatch sets matchStart and matchLen *//* Discard match if too small and too far away */if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TOO_FAR))) {  				matchLen = MIN_MATCH - 1;  			}  		}  	}  	/* previous match was better */if (prevLen >= MIN_MATCH && matchLen <= prevLen) {  		/* 					if (DeflaterConstants.DEBUGGING) { 					   for (int i = 0 ; i < matchLen; i++) { 					      if (window[strstart-1+i] != window[prevMatch + i]) 					         throw new SharpZipBaseException(); 						} 					} */huffman.TallyDist (strstart - 1 - prevMatch' prevLen);  		prevLen -= 2;  		do {  			strstart++;  			lookahead--;  			if (lookahead >= MIN_MATCH) {  				InsertString ();  			}  		} while (--prevLen > 0);  		strstart++;  		lookahead--;  		prevAvailable = false;  		matchLen = MIN_MATCH - 1;  	} else {  		if (prevAvailable) {  			huffman.TallyLit (window [strstart - 1] & 0xff);  		}  		prevAvailable = true;  		strstart++;  		lookahead--;  	}  	if (huffman.IsFull ()) {  		int len = strstart - blockStart;  		if (prevAvailable) {  			len--;  		}  		bool lastBlock = (finish && lookahead == 0 && !prevAvailable);  		huffman.FlushBlock (window' blockStart' len' lastBlock);  		blockStart += len;  		return !lastBlock;  	}  }  
Magic Number,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: while (lookahead >= MIN_LOOKAHEAD || flush) {  	if (lookahead == 0) {  		if (prevAvailable) {  			huffman.TallyLit (window [strstart - 1] & 0xff);  		}  		prevAvailable = false;  		// We are flushing everything  		/* 					if (DeflaterConstants.DEBUGGING && !flush) { 						throw new SharpZipBaseException("Not flushing' but no lookahead"); 					} */huffman.FlushBlock (window' blockStart' strstart - blockStart' finish);  		blockStart = strstart;  		return false;  	}  	if (strstart >= 2 * WSIZE - MIN_LOOKAHEAD) {  		/* slide window' as findLongestMatch need this. 					 * This should only happen when flushing and the window 					 * is almost full. 					 */SlideWindow ();  	}  	int prevMatch = matchStart;  	int prevLen = matchLen;  	if (lookahead >= MIN_MATCH) {  		int hashHead = InsertString ();  		if (strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) {  			/* longestMatch sets matchStart and matchLen *//* Discard match if too small and too far away */if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TOO_FAR))) {  				matchLen = MIN_MATCH - 1;  			}  		}  	}  	/* previous match was better */if (prevLen >= MIN_MATCH && matchLen <= prevLen) {  		/* 					if (DeflaterConstants.DEBUGGING) { 					   for (int i = 0 ; i < matchLen; i++) { 					      if (window[strstart-1+i] != window[prevMatch + i]) 					         throw new SharpZipBaseException(); 						} 					} */huffman.TallyDist (strstart - 1 - prevMatch' prevLen);  		prevLen -= 2;  		do {  			strstart++;  			lookahead--;  			if (lookahead >= MIN_MATCH) {  				InsertString ();  			}  		} while (--prevLen > 0);  		strstart++;  		lookahead--;  		prevAvailable = false;  		matchLen = MIN_MATCH - 1;  	} else {  		if (prevAvailable) {  			huffman.TallyLit (window [strstart - 1] & 0xff);  		}  		prevAvailable = true;  		strstart++;  		lookahead--;  	}  	if (huffman.IsFull ()) {  		int len = strstart - blockStart;  		if (prevAvailable) {  			len--;  		}  		bool lastBlock = (finish && lookahead == 0 && !prevAvailable);  		huffman.FlushBlock (window' blockStart' len' lastBlock);  		blockStart += len;  		return !lastBlock;  	}  }  
Magic Number,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: if (strstart >= 2 * WSIZE - MIN_LOOKAHEAD) {  	/* slide window' as findLongestMatch need this. 					 * This should only happen when flushing and the window 					 * is almost full. 					 */SlideWindow ();  }  
Magic Number,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: if (lookahead >= MIN_MATCH) {  	int hashHead = InsertString ();  	if (strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) {  		/* longestMatch sets matchStart and matchLen *//* Discard match if too small and too far away */if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TOO_FAR))) {  			matchLen = MIN_MATCH - 1;  		}  	}  }  
Magic Number,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: if (strategy != DeflateStrategy.HuffmanOnly && hashHead != 0 && strstart - hashHead <= MAX_DIST && FindLongestMatch (hashHead)) {  	/* longestMatch sets matchStart and matchLen *//* Discard match if too small and too far away */if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TOO_FAR))) {  		matchLen = MIN_MATCH - 1;  	}  }  
Magic Number,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TOO_FAR))) {  	matchLen = MIN_MATCH - 1;  }  
Magic Number,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: if (prevLen >= MIN_MATCH && matchLen <= prevLen) {  	/* 					if (DeflaterConstants.DEBUGGING) { 					   for (int i = 0 ; i < matchLen; i++) { 					      if (window[strstart-1+i] != window[prevMatch + i]) 					         throw new SharpZipBaseException(); 						} 					} */huffman.TallyDist (strstart - 1 - prevMatch' prevLen);  	prevLen -= 2;  	do {  		strstart++;  		lookahead--;  		if (lookahead >= MIN_MATCH) {  			InsertString ();  		}  	} while (--prevLen > 0);  	strstart++;  	lookahead--;  	prevAvailable = false;  	matchLen = MIN_MATCH - 1;  } else {  	if (prevAvailable) {  		huffman.TallyLit (window [strstart - 1] & 0xff);  	}  	prevAvailable = true;  	strstart++;  	lookahead--;  }  
Magic Number,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: prevLen -= 2;  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short)(bit4Reverse [toReverse & 0xF] << 12 | bit4Reverse [(toReverse >> 4) & 0xF] << 8 | bit4Reverse [(toReverse >> 8) & 0xF] << 4 | bit4Reverse [toReverse >> 12]);  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 144) {  	staticLCodes [i] = BitReverse ((0x030 + i) << 8);  	staticLLength [i++] = 8;  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 144) {  	staticLCodes [i] = BitReverse ((0x030 + i) << 8);  	staticLLength [i++] = 8;  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 144) {  	staticLCodes [i] = BitReverse ((0x030 + i) << 8);  	staticLLength [i++] = 8;  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x030 + i) << 8);  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLLength [i++] = 8;  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256) {  	staticLCodes [i] = BitReverse ((0x190 - 144 + i) << 7);  	staticLLength [i++] = 9;  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256) {  	staticLCodes [i] = BitReverse ((0x190 - 144 + i) << 7);  	staticLLength [i++] = 9;  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256) {  	staticLCodes [i] = BitReverse ((0x190 - 144 + i) << 7);  	staticLLength [i++] = 9;  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256) {  	staticLCodes [i] = BitReverse ((0x190 - 144 + i) << 7);  	staticLLength [i++] = 9;  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x190 - 144 + i) << 7);  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x190 - 144 + i) << 7);  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLLength [i++] = 9;  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280) {  	staticLCodes [i] = BitReverse ((0x000 - 256 + i) << 9);  	staticLLength [i++] = 7;  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280) {  	staticLCodes [i] = BitReverse ((0x000 - 256 + i) << 9);  	staticLLength [i++] = 7;  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280) {  	staticLCodes [i] = BitReverse ((0x000 - 256 + i) << 9);  	staticLLength [i++] = 7;  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280) {  	staticLCodes [i] = BitReverse ((0x000 - 256 + i) << 9);  	staticLLength [i++] = 7;  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x000 - 256 + i) << 9);  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x000 - 256 + i) << 9);  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLLength [i++] = 7;  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < LITERAL_NUM) {  	staticLCodes [i] = BitReverse ((0x0c0 - 280 + i) << 8);  	staticLLength [i++] = 8;  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < LITERAL_NUM) {  	staticLCodes [i] = BitReverse ((0x0c0 - 280 + i) << 8);  	staticLLength [i++] = 8;  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < LITERAL_NUM) {  	staticLCodes [i] = BitReverse ((0x0c0 - 280 + i) << 8);  	staticLLength [i++] = 8;  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x0c0 - 280 + i) << 8);  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLCodes [i] = BitReverse ((0x0c0 - 280 + i) << 8);  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticLLength [i++] = 8;  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: for (i = 0; i < DIST_NUM; i++) {  	staticDCodes [i] = BitReverse (i << 11);  	staticDLength [i] = 5;  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: for (i = 0; i < DIST_NUM; i++) {  	staticDCodes [i] = BitReverse (i << 11);  	staticDLength [i] = 5;  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticDCodes [i] = BitReverse (i << 11);  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: staticDLength [i] = 5;  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: literalTree = new Tree (this' LITERAL_NUM' 257' 15);  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: literalTree = new Tree (this' LITERAL_NUM' 257' 15);  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: distTree = new Tree (this' DIST_NUM' 1' 15);  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: blTree = new Tree (this' BITLEN_NUM' 4' 7);  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: blTree = new Tree (this' BITLEN_NUM' 4' 7);  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: if (len == 255) {  	return 285;  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: if (len == 255) {  	return 285;  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: return 285;  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: while (len >= 8) {  	code += 4;  	len >>= 1;  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: while (len >= 8) {  	code += 4;  	len >>= 1;  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: code += 4;  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,Dcode,The following statement contains a magic number: while (distance >= 4) {  	code += 2;  	distance >>= 1;  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,Dcode,The following statement contains a magic number: while (distance >= 4) {  	code += 2;  	distance >>= 1;  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,Dcode,The following statement contains a magic number: code += 2;  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits (literalTree.numCodes - 257' 5);  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits (literalTree.numCodes - 257' 5);  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits (distTree.numCodes - 1' 5);  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits (blTreeCodes - 4' 4);  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits (blTreeCodes - 4' 4);  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: for (int rank = 0; rank < blTreeCodes; rank++) {  	pending.WriteBits (blTree.length [BL_ORDER [rank]]' 3);  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits (blTree.length [BL_ORDER [rank]]' 3);  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++) {  	int litlen = l_buf [i] & 0xff;  	int dist = d_buf [i];  	if (dist-- != 0) {  		//					if (DeflaterConstants.DEBUGGING) {  		//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  		//					}  		int lc = Lcode (litlen);  		literalTree.WriteSymbol (lc);  		int bits = (lc - 261) / 4;  		if (bits > 0 && bits <= 5) {  			pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  		}  		int dc = Dcode (dist);  		distTree.WriteSymbol (dc);  		bits = dc / 2 - 1;  		if (bits > 0) {  			pending.WriteBits (dist & ((1 << bits) - 1)' bits);  		}  	} else {  		//					if (DeflaterConstants.DEBUGGING) {  		//						if (litlen > 32 && litlen < 127) {  		//							Console.Write("("+(char)litlen+"): ");  		//						} else {  		//							Console.Write("{"+litlen+"}: ");  		//						}  		//					}  		literalTree.WriteSymbol (litlen);  	}  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++) {  	int litlen = l_buf [i] & 0xff;  	int dist = d_buf [i];  	if (dist-- != 0) {  		//					if (DeflaterConstants.DEBUGGING) {  		//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  		//					}  		int lc = Lcode (litlen);  		literalTree.WriteSymbol (lc);  		int bits = (lc - 261) / 4;  		if (bits > 0 && bits <= 5) {  			pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  		}  		int dc = Dcode (dist);  		distTree.WriteSymbol (dc);  		bits = dc / 2 - 1;  		if (bits > 0) {  			pending.WriteBits (dist & ((1 << bits) - 1)' bits);  		}  	} else {  		//					if (DeflaterConstants.DEBUGGING) {  		//						if (litlen > 32 && litlen < 127) {  		//							Console.Write("("+(char)litlen+"): ");  		//						} else {  		//							Console.Write("{"+litlen+"}: ");  		//						}  		//					}  		literalTree.WriteSymbol (litlen);  	}  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++) {  	int litlen = l_buf [i] & 0xff;  	int dist = d_buf [i];  	if (dist-- != 0) {  		//					if (DeflaterConstants.DEBUGGING) {  		//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  		//					}  		int lc = Lcode (litlen);  		literalTree.WriteSymbol (lc);  		int bits = (lc - 261) / 4;  		if (bits > 0 && bits <= 5) {  			pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  		}  		int dc = Dcode (dist);  		distTree.WriteSymbol (dc);  		bits = dc / 2 - 1;  		if (bits > 0) {  			pending.WriteBits (dist & ((1 << bits) - 1)' bits);  		}  	} else {  		//					if (DeflaterConstants.DEBUGGING) {  		//						if (litlen > 32 && litlen < 127) {  		//							Console.Write("("+(char)litlen+"): ");  		//						} else {  		//							Console.Write("{"+litlen+"}: ");  		//						}  		//					}  		literalTree.WriteSymbol (litlen);  	}  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++) {  	int litlen = l_buf [i] & 0xff;  	int dist = d_buf [i];  	if (dist-- != 0) {  		//					if (DeflaterConstants.DEBUGGING) {  		//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  		//					}  		int lc = Lcode (litlen);  		literalTree.WriteSymbol (lc);  		int bits = (lc - 261) / 4;  		if (bits > 0 && bits <= 5) {  			pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  		}  		int dc = Dcode (dist);  		distTree.WriteSymbol (dc);  		bits = dc / 2 - 1;  		if (bits > 0) {  			pending.WriteBits (dist & ((1 << bits) - 1)' bits);  		}  	} else {  		//					if (DeflaterConstants.DEBUGGING) {  		//						if (litlen > 32 && litlen < 127) {  		//							Console.Write("("+(char)litlen+"): ");  		//						} else {  		//							Console.Write("{"+litlen+"}: ");  		//						}  		//					}  		literalTree.WriteSymbol (litlen);  	}  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: if (dist-- != 0) {  	//					if (DeflaterConstants.DEBUGGING) {  	//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  	//					}  	int lc = Lcode (litlen);  	literalTree.WriteSymbol (lc);  	int bits = (lc - 261) / 4;  	if (bits > 0 && bits <= 5) {  		pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  	}  	int dc = Dcode (dist);  	distTree.WriteSymbol (dc);  	bits = dc / 2 - 1;  	if (bits > 0) {  		pending.WriteBits (dist & ((1 << bits) - 1)' bits);  	}  } else {  	//					if (DeflaterConstants.DEBUGGING) {  	//						if (litlen > 32 && litlen < 127) {  	//							Console.Write("("+(char)litlen+"): ");  	//						} else {  	//							Console.Write("{"+litlen+"}: ");  	//						}  	//					}  	literalTree.WriteSymbol (litlen);  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: if (dist-- != 0) {  	//					if (DeflaterConstants.DEBUGGING) {  	//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  	//					}  	int lc = Lcode (litlen);  	literalTree.WriteSymbol (lc);  	int bits = (lc - 261) / 4;  	if (bits > 0 && bits <= 5) {  		pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  	}  	int dc = Dcode (dist);  	distTree.WriteSymbol (dc);  	bits = dc / 2 - 1;  	if (bits > 0) {  		pending.WriteBits (dist & ((1 << bits) - 1)' bits);  	}  } else {  	//					if (DeflaterConstants.DEBUGGING) {  	//						if (litlen > 32 && litlen < 127) {  	//							Console.Write("("+(char)litlen+"): ");  	//						} else {  	//							Console.Write("{"+litlen+"}: ");  	//						}  	//					}  	literalTree.WriteSymbol (litlen);  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: if (dist-- != 0) {  	//					if (DeflaterConstants.DEBUGGING) {  	//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  	//					}  	int lc = Lcode (litlen);  	literalTree.WriteSymbol (lc);  	int bits = (lc - 261) / 4;  	if (bits > 0 && bits <= 5) {  		pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  	}  	int dc = Dcode (dist);  	distTree.WriteSymbol (dc);  	bits = dc / 2 - 1;  	if (bits > 0) {  		pending.WriteBits (dist & ((1 << bits) - 1)' bits);  	}  } else {  	//					if (DeflaterConstants.DEBUGGING) {  	//						if (litlen > 32 && litlen < 127) {  	//							Console.Write("("+(char)litlen+"): ");  	//						} else {  	//							Console.Write("{"+litlen+"}: ");  	//						}  	//					}  	literalTree.WriteSymbol (litlen);  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: if (dist-- != 0) {  	//					if (DeflaterConstants.DEBUGGING) {  	//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  	//					}  	int lc = Lcode (litlen);  	literalTree.WriteSymbol (lc);  	int bits = (lc - 261) / 4;  	if (bits > 0 && bits <= 5) {  		pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  	}  	int dc = Dcode (dist);  	distTree.WriteSymbol (dc);  	bits = dc / 2 - 1;  	if (bits > 0) {  		pending.WriteBits (dist & ((1 << bits) - 1)' bits);  	}  } else {  	//					if (DeflaterConstants.DEBUGGING) {  	//						if (litlen > 32 && litlen < 127) {  	//							Console.Write("("+(char)litlen+"): ");  	//						} else {  	//							Console.Write("{"+litlen+"}: ");  	//						}  	//					}  	literalTree.WriteSymbol (litlen);  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: if (bits > 0 && bits <= 5) {  	pending.WriteBits (litlen & ((1 << bits) - 1)' bits);  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: bits = dc / 2 - 1;  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,FlushStoredBlock,The following statement contains a magic number: pending.WriteBits ((DeflaterConstants.STORED_BLOCK << 1) + (lastBlock ? 1 : 0)' 3);  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: for (int i = 18; i > blTreeCodes; i--) {  	if (blTree.length [BL_ORDER [i]] > 0) {  		blTreeCodes = i + 1;  	}  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && (storedLength + 4 < (opt_len >> 3))) {  	/* Store Block *///				if (DeflaterConstants.DEBUGGING) {  	//					//Console.WriteLine("Storing' since " + storedLength + " < " + opt_len  	//					                  + " <= " + static_len);  	//				}  	FlushStoredBlock (stored' storedOffset' storedLength' lastBlock);  } else if (opt_len == static_len) {  	/* Encode with static tree */pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	literalTree.SetStaticCodes (staticLCodes' staticLLength);  	distTree.SetStaticCodes (staticDCodes' staticDLength);  	CompressBlock ();  	Reset ();  } else {  	/* Encode with dynamic tree */pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	SendAllTrees (blTreeCodes);  	CompressBlock ();  	Reset ();  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && (storedLength + 4 < (opt_len >> 3))) {  	/* Store Block *///				if (DeflaterConstants.DEBUGGING) {  	//					//Console.WriteLine("Storing' since " + storedLength + " < " + opt_len  	//					                  + " <= " + static_len);  	//				}  	FlushStoredBlock (stored' storedOffset' storedLength' lastBlock);  } else if (opt_len == static_len) {  	/* Encode with static tree */pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	literalTree.SetStaticCodes (staticLCodes' staticLLength);  	distTree.SetStaticCodes (staticDCodes' staticDLength);  	CompressBlock ();  	Reset ();  } else {  	/* Encode with dynamic tree */pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	SendAllTrees (blTreeCodes);  	CompressBlock ();  	Reset ();  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && (storedLength + 4 < (opt_len >> 3))) {  	/* Store Block *///				if (DeflaterConstants.DEBUGGING) {  	//					//Console.WriteLine("Storing' since " + storedLength + " < " + opt_len  	//					                  + " <= " + static_len);  	//				}  	FlushStoredBlock (stored' storedOffset' storedLength' lastBlock);  } else if (opt_len == static_len) {  	/* Encode with static tree */pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	literalTree.SetStaticCodes (staticLCodes' staticLLength);  	distTree.SetStaticCodes (staticDCodes' staticDLength);  	CompressBlock ();  	Reset ();  } else {  	/* Encode with dynamic tree */pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	SendAllTrees (blTreeCodes);  	CompressBlock ();  	Reset ();  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && (storedLength + 4 < (opt_len >> 3))) {  	/* Store Block *///				if (DeflaterConstants.DEBUGGING) {  	//					//Console.WriteLine("Storing' since " + storedLength + " < " + opt_len  	//					                  + " <= " + static_len);  	//				}  	FlushStoredBlock (stored' storedOffset' storedLength' lastBlock);  } else if (opt_len == static_len) {  	/* Encode with static tree */pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	literalTree.SetStaticCodes (staticLCodes' staticLLength);  	distTree.SetStaticCodes (staticDCodes' staticDLength);  	CompressBlock ();  	Reset ();  } else {  	/* Encode with dynamic tree */pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	SendAllTrees (blTreeCodes);  	CompressBlock ();  	Reset ();  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (opt_len == static_len) {  	/* Encode with static tree */pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	literalTree.SetStaticCodes (staticLCodes' staticLLength);  	distTree.SetStaticCodes (staticDCodes' staticDLength);  	CompressBlock ();  	Reset ();  } else {  	/* Encode with dynamic tree */pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	SendAllTrees (blTreeCodes);  	CompressBlock ();  	Reset ();  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (opt_len == static_len) {  	/* Encode with static tree */pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	literalTree.SetStaticCodes (staticLCodes' staticLLength);  	distTree.SetStaticCodes (staticDCodes' staticDLength);  	CompressBlock ();  	Reset ();  } else {  	/* Encode with dynamic tree */pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  	SendAllTrees (blTreeCodes);  	CompressBlock ();  	Reset ();  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: pending.WriteBits ((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: pending.WriteBits ((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: l_buf [last_lit++] = (byte)(len - 3);  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285) {  	extra_bits += (lc - 261) / 4;  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285) {  	extra_bits += (lc - 261) / 4;  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285) {  	extra_bits += (lc - 261) / 4;  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285) {  	extra_bits += (lc - 261) / 4;  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: extra_bits += (lc - 261) / 4;  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: extra_bits += (lc - 261) / 4;  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (dc >= 4) {  	extra_bits += dc / 2 - 1;  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (dc >= 4) {  	extra_bits += dc / 2 - 1;  }  
Magic Number,agsXMPP.IO.Compression,DeflaterHuffman,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: extra_bits += dc / 2 - 1;  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			} else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			} else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			} else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			} else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			} else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			} else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			} else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			} else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			} else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			} else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			} else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			} else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			} else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: for (; ;) {  	switch (mode) {  	case LNUM:  		lnum = input.PeekBits (5);  		if (lnum < 0) {  			return false;  		}  		lnum += 257;  		input.DropBits (5);  		//  	    System.err.println("LNUM: "+lnum);  		mode = DNUM;  		goto case DNUM;  	// fall through  	case DNUM:  		dnum = input.PeekBits (5);  		if (dnum < 0) {  			return false;  		}  		dnum++;  		input.DropBits (5);  		//  	    System.err.println("DNUM: "+dnum);  		num = lnum + dnum;  		litdistLens = new byte[num];  		mode = BLNUM;  		goto case BLNUM;  	// fall through  	case BLNUM:  		blnum = input.PeekBits (4);  		if (blnum < 0) {  			return false;  		}  		blnum += 4;  		input.DropBits (4);  		blLens = new byte[19];  		ptr = 0;  		//  	    System.err.println("BLNUM: "+blnum);  		mode = BLLENS;  		goto case BLLENS;  	// fall through  	case BLLENS:  		while (ptr < blnum) {  			int len = input.PeekBits (3);  			if (len < 0) {  				return false;  			}  			input.DropBits (3);  			//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  			blLens [BL_ORDER [ptr]] = (byte)len;  			ptr++;  		}  		blTree = new InflaterHuffmanTree (blLens);  		blLens = null;  		ptr = 0;  		mode = LENS;  		goto case LENS;  	// fall through  	case LENS:  		{  			int symbol;  			while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  				/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  				litdistLens [ptr++] = lastLen = (byte)symbol;  				if (ptr == num) {  					/* Finished */return true;  				}  			}  			/* need more input ? */if (symbol < 0) {  				return false;  			}  			/* otherwise repeat code */if (symbol >= 17) {  				/* repeat zero *///  		  System.err.println("repeating zero");  				lastLen = 0;  			} else {  				if (ptr == 0) {  					throw new SharpZipBaseException ();  				}  			}  			repSymbol = symbol - 16;  		}  		mode = REPS;  		goto case REPS;  	// fall through  	case REPS:  		{  			int bits = repBits [repSymbol];  			int count = input.PeekBits (bits);  			if (count < 0) {  				return false;  			}  			input.DropBits (bits);  			count += repMin [repSymbol];  			//  	      System.err.println("litdistLens repeated: "+count);  			if (ptr + count > num) {  				throw new SharpZipBaseException ();  			}  			while (count-- > 0) {  				litdistLens [ptr++] = lastLen;  			}  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		mode = LENS;  		goto decode_loop;  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		} else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		} else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		} else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		} else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		} else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		} else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		} else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		} else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		} else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		} else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		} else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		} else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		} else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		} else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: lnum = input.PeekBits (5);  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: lnum += 257;  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: input.DropBits (5);  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: dnum = input.PeekBits (5);  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: input.DropBits (5);  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: blnum = input.PeekBits (4);  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: blnum += 4;  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: input.DropBits (4);  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: blLens = new byte[19];  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: while (ptr < blnum) {  	int len = input.PeekBits (3);  	if (len < 0) {  		return false;  	}  	input.DropBits (3);  	//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  	blLens [BL_ORDER [ptr]] = (byte)len;  	ptr++;  }  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: while (ptr < blnum) {  	int len = input.PeekBits (3);  	if (len < 0) {  		return false;  	}  	input.DropBits (3);  	//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  	blLens [BL_ORDER [ptr]] = (byte)len;  	ptr++;  }  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: input.DropBits (3);  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  	/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  	litdistLens [ptr++] = lastLen = (byte)symbol;  	if (ptr == num) {  		/* Finished */return true;  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: if (symbol >= 17) {  	/* repeat zero *///  		  System.err.println("repeating zero");  	lastLen = 0;  } else {  	if (ptr == 0) {  		throw new SharpZipBaseException ();  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: repSymbol = symbol - 16;  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  } catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  } catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  } catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  } catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  } catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  } catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  } catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  } catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  } catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  } catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  } catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  	byte[] codeLengths = new byte[288];  	int i = 0;  	while (i < 144) {  		codeLengths [i++] = 8;  	}  	while (i < 256) {  		codeLengths [i++] = 9;  	}  	while (i < 280) {  		codeLengths [i++] = 7;  	}  	while (i < 288) {  		codeLengths [i++] = 8;  	}  	defLitLenTree = new InflaterHuffmanTree (codeLengths);  	codeLengths = new byte[32];  	i = 0;  	while (i < 32) {  		codeLengths [i++] = 5;  	}  	defDistTree = new InflaterHuffmanTree (codeLengths);  } catch (Exception) {  	throw new SharpZipBaseException ("InflaterHuffmanTree: static tree length illegal");  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 144) {  	codeLengths [i++] = 8;  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 144) {  	codeLengths [i++] = 8;  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths [i++] = 8;  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 256) {  	codeLengths [i++] = 9;  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 256) {  	codeLengths [i++] = 9;  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths [i++] = 9;  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 280) {  	codeLengths [i++] = 7;  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 280) {  	codeLengths [i++] = 7;  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths [i++] = 7;  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 288) {  	codeLengths [i++] = 8;  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 288) {  	codeLengths [i++] = 8;  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths [i++] = 8;  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths = new byte[32];  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 32) {  	codeLengths [i++] = 5;  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: while (i < 32) {  	codeLengths [i++] = 5;  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: codeLengths [i++] = 5;  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++) {  	nextCode [bits] = code;  	code += blCount [bits] << (16 - bits);  	if (bits >= 10) {  		/* We need an extra table for bit lengths >= 10. */int start = nextCode [bits] & 0x1ff80;  		int end = code & 0x1ff80;  		treeSize += (end - start) >> (16 - bits);  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++) {  	nextCode [bits] = code;  	code += blCount [bits] << (16 - bits);  	if (bits >= 10) {  		/* We need an extra table for bit lengths >= 10. */int start = nextCode [bits] & 0x1ff80;  		int end = code & 0x1ff80;  		treeSize += (end - start) >> (16 - bits);  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++) {  	nextCode [bits] = code;  	code += blCount [bits] << (16 - bits);  	if (bits >= 10) {  		/* We need an extra table for bit lengths >= 10. */int start = nextCode [bits] & 0x1ff80;  		int end = code & 0x1ff80;  		treeSize += (end - start) >> (16 - bits);  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: code += blCount [bits] << (16 - bits);  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits >= 10) {  	/* We need an extra table for bit lengths >= 10. */int start = nextCode [bits] & 0x1ff80;  	int end = code & 0x1ff80;  	treeSize += (end - start) >> (16 - bits);  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits >= 10) {  	/* We need an extra table for bit lengths >= 10. */int start = nextCode [bits] & 0x1ff80;  	int end = code & 0x1ff80;  	treeSize += (end - start) >> (16 - bits);  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: treeSize += (end - start) >> (16 - bits);  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  	int end = code & 0x1ff80;  	code -= blCount [bits] << (16 - bits);  	int start = code & 0x1ff80;  	for (int i = start; i < end; i += 1 << 7) {  		tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  		treePtr += 1 << (bits - 9);  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  	int end = code & 0x1ff80;  	code -= blCount [bits] << (16 - bits);  	int start = code & 0x1ff80;  	for (int i = start; i < end; i += 1 << 7) {  		tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  		treePtr += 1 << (bits - 9);  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  	int end = code & 0x1ff80;  	code -= blCount [bits] << (16 - bits);  	int start = code & 0x1ff80;  	for (int i = start; i < end; i += 1 << 7) {  		tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  		treePtr += 1 << (bits - 9);  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  	int end = code & 0x1ff80;  	code -= blCount [bits] << (16 - bits);  	int start = code & 0x1ff80;  	for (int i = start; i < end; i += 1 << 7) {  		tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  		treePtr += 1 << (bits - 9);  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  	int end = code & 0x1ff80;  	code -= blCount [bits] << (16 - bits);  	int start = code & 0x1ff80;  	for (int i = start; i < end; i += 1 << 7) {  		tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  		treePtr += 1 << (bits - 9);  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: code -= blCount [bits] << (16 - bits);  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = start; i < end; i += 1 << 7) {  	tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  	treePtr += 1 << (bits - 9);  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = start; i < end; i += 1 << 7) {  	tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  	treePtr += 1 << (bits - 9);  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = start; i < end; i += 1 << 7) {  	tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  	treePtr += 1 << (bits - 9);  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: i += 1 << 7
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: tree [DeflaterHuffman.BitReverse (i)] = (short)((-treePtr << 4) | bits);  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: treePtr += 1 << (bits - 9);  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		} while (revcode < 512);  	} else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		} while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		} while (revcode < 512);  	} else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		} while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		} while (revcode < 512);  	} else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		} while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		} while (revcode < 512);  	} else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		} while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		} while (revcode < 512);  	} else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		} while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		} while (revcode < 512);  	} else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		} while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		} while (revcode < 512);  	} else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		} while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		} while (revcode < 512);  	} else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		} while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  	int bits = codeLengths [i];  	if (bits == 0) {  		continue;  	}  	code = nextCode [bits];  	int revcode = DeflaterHuffman.BitReverse (code);  	if (bits <= 9) {  		do {  			tree [revcode] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		} while (revcode < 512);  	} else {  		int subTree = tree [revcode & 511];  		int treeLen = 1 << (subTree & 15);  		subTree = -(subTree >> 4);  		do {  			tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  			revcode += 1 << bits;  		} while (revcode < treeLen);  	}  	nextCode [bits] = code + (1 << (16 - bits));  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	} while (revcode < 512);  } else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	} while (revcode < treeLen);  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	} while (revcode < 512);  } else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	} while (revcode < treeLen);  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	} while (revcode < 512);  } else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	} while (revcode < treeLen);  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	} while (revcode < 512);  } else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	} while (revcode < treeLen);  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	} while (revcode < 512);  } else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	} while (revcode < treeLen);  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	} while (revcode < 512);  } else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	} while (revcode < treeLen);  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	} while (revcode < 512);  } else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	} while (revcode < treeLen);  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: if (bits <= 9) {  	do {  		tree [revcode] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	} while (revcode < 512);  } else {  	int subTree = tree [revcode & 511];  	int treeLen = 1 << (subTree & 15);  	subTree = -(subTree >> 4);  	do {  		tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  		revcode += 1 << bits;  	} while (revcode < treeLen);  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: do {  	tree [revcode] = (short)((i << 4) | bits);  	revcode += 1 << bits;  } while (revcode < 512);  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: do {  	tree [revcode] = (short)((i << 4) | bits);  	revcode += 1 << bits;  } while (revcode < 512);  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: tree [revcode] = (short)((i << 4) | bits);  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: subTree = -(subTree >> 4);  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: do {  	tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  	revcode += 1 << bits;  } while (revcode < treeLen);  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: do {  	tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  	revcode += 1 << bits;  } while (revcode < treeLen);  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: tree [subTree | (revcode >> 9)] = (short)((i << 4) | bits);  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: nextCode [bits] = code + (1 << (16 - bits));  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		} else {  			return -1;  		}  	}  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		} else {  			return -1;  		}  	}  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		} else {  			return -1;  		}  	}  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		} else {  			return -1;  		}  	}  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		} else {  			return -1;  		}  	}  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		} else {  			return -1;  		}  	}  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		} else {  			return -1;  		}  	}  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		} else {  			return -1;  		}  	}  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		} else {  			return -1;  		}  	}  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		} else {  			return -1;  		}  	}  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		} else {  			return -1;  		}  	}  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		} else {  			return -1;  		}  	}  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		} else {  			return -1;  		}  	}  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		} else {  			return -1;  		}  	}  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (9)) >= 0) {  	if ((symbol = tree [lookahead]) >= 0) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	}  	int subtree = -(symbol >> 4);  	int bitlen = symbol & 15;  	if ((lookahead = input.PeekBits (bitlen)) >= 0) {  		symbol = tree [subtree | (lookahead >> 9)];  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		int bits = input.AvailableBits;  		lookahead = input.PeekBits (bits);  		symbol = tree [subtree | (lookahead >> 9)];  		if ((symbol & 15) <= bits) {  			input.DropBits (symbol & 15);  			return symbol >> 4;  		} else {  			return -1;  		}  	}  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [lookahead];  	if (symbol >= 0 && (symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((symbol = tree [lookahead]) >= 0) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((symbol = tree [lookahead]) >= 0) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: input.DropBits (symbol & 15);  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: return symbol >> 4;  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits (bitlen)) >= 0) {  	symbol = tree [subtree | (lookahead >> 9)];  	input.DropBits (symbol & 15);  	return symbol >> 4;  } else {  	int bits = input.AvailableBits;  	lookahead = input.PeekBits (bits);  	symbol = tree [subtree | (lookahead >> 9)];  	if ((symbol & 15) <= bits) {  		input.DropBits (symbol & 15);  		return symbol >> 4;  	} else {  		return -1;  	}  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: symbol = tree [subtree | (lookahead >> 9)];  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: input.DropBits (symbol & 15);  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: return symbol >> 4;  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: symbol = tree [subtree | (lookahead >> 9)];  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  } else {  	return -1;  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  } else {  	return -1;  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  } else {  	return -1;  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: input.DropBits (symbol & 15);  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: return symbol >> 4;  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if (symbol >= 0 && (symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  } else {  	return -1;  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if (symbol >= 0 && (symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  } else {  	return -1;  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if (symbol >= 0 && (symbol & 15) <= bits) {  	input.DropBits (symbol & 15);  	return symbol >> 4;  } else {  	return -1;  }  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: input.DropBits (symbol & 15);  
Magic Number,agsXMPP.IO.Compression,InflaterHuffmanTree,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: return symbol >> 4;  
Magic Number,agsXMPP.IO.Compression,PendingBuffer,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\PendingBuffer.cs,WriteShort,The following statement contains a magic number: buf [end++] = (byte)(s >> 8);  
Magic Number,agsXMPP.IO.Compression,PendingBuffer,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\PendingBuffer.cs,WriteInt,The following statement contains a magic number: buf [end++] = (byte)(s >> 8);  
Magic Number,agsXMPP.IO.Compression,PendingBuffer,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\PendingBuffer.cs,WriteInt,The following statement contains a magic number: buf [end++] = (byte)(s >> 16);  
Magic Number,agsXMPP.IO.Compression,PendingBuffer,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\PendingBuffer.cs,WriteInt,The following statement contains a magic number: buf [end++] = (byte)(s >> 24);  
Magic Number,agsXMPP.IO.Compression,PendingBuffer,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\PendingBuffer.cs,AlignToByte,The following statement contains a magic number: if (bitCount > 0) {  	buf [end++] = (byte)bits;  	if (bitCount > 8) {  		buf [end++] = (byte)(bits >> 8);  	}  }  
Magic Number,agsXMPP.IO.Compression,PendingBuffer,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\PendingBuffer.cs,AlignToByte,The following statement contains a magic number: if (bitCount > 0) {  	buf [end++] = (byte)bits;  	if (bitCount > 8) {  		buf [end++] = (byte)(bits >> 8);  	}  }  
Magic Number,agsXMPP.IO.Compression,PendingBuffer,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\PendingBuffer.cs,AlignToByte,The following statement contains a magic number: if (bitCount > 8) {  	buf [end++] = (byte)(bits >> 8);  }  
Magic Number,agsXMPP.IO.Compression,PendingBuffer,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\PendingBuffer.cs,AlignToByte,The following statement contains a magic number: if (bitCount > 8) {  	buf [end++] = (byte)(bits >> 8);  }  
Magic Number,agsXMPP.IO.Compression,PendingBuffer,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\PendingBuffer.cs,AlignToByte,The following statement contains a magic number: buf [end++] = (byte)(bits >> 8);  
Magic Number,agsXMPP.IO.Compression,PendingBuffer,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16) {  	buf [end++] = (byte)bits;  	buf [end++] = (byte)(bits >> 8);  	bits >>= 16;  	bitCount -= 16;  }  
Magic Number,agsXMPP.IO.Compression,PendingBuffer,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16) {  	buf [end++] = (byte)bits;  	buf [end++] = (byte)(bits >> 8);  	bits >>= 16;  	bitCount -= 16;  }  
Magic Number,agsXMPP.IO.Compression,PendingBuffer,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16) {  	buf [end++] = (byte)bits;  	buf [end++] = (byte)(bits >> 8);  	bits >>= 16;  	bitCount -= 16;  }  
Magic Number,agsXMPP.IO.Compression,PendingBuffer,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16) {  	buf [end++] = (byte)bits;  	buf [end++] = (byte)(bits >> 8);  	bits >>= 16;  	bitCount -= 16;  }  
Magic Number,agsXMPP.IO.Compression,PendingBuffer,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: buf [end++] = (byte)(bits >> 8);  
Magic Number,agsXMPP.IO.Compression,PendingBuffer,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: bits >>= 16;  
Magic Number,agsXMPP.IO.Compression,PendingBuffer,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: bitCount -= 16;  
Magic Number,agsXMPP.IO.Compression,PendingBuffer,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\PendingBuffer.cs,WriteShortMSB,The following statement contains a magic number: buf [end++] = (byte)(s >> 8);  
Magic Number,agsXMPP.IO.Compression,PendingBuffer,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: if (bitCount >= 8) {  	buf [end++] = (byte)bits;  	bits >>= 8;  	bitCount -= 8;  }  
Magic Number,agsXMPP.IO.Compression,PendingBuffer,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: if (bitCount >= 8) {  	buf [end++] = (byte)bits;  	bits >>= 8;  	bitCount -= 8;  }  
Magic Number,agsXMPP.IO.Compression,PendingBuffer,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: if (bitCount >= 8) {  	buf [end++] = (byte)bits;  	bits >>= 8;  	bitCount -= 8;  }  
Magic Number,agsXMPP.IO.Compression,PendingBuffer,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: bits >>= 8;  
Magic Number,agsXMPP.IO.Compression,PendingBuffer,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: bitCount -= 8;  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflater,The following statement contains a magic number: if (level == DEFAULT_COMPRESSION) {  	level = 6;  } else if (level < NO_COMPRESSION || level > BEST_COMPRESSION) {  	throw new ArgumentOutOfRangeException ("level");  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflater,The following statement contains a magic number: level = 6;  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,SetLevel,The following statement contains a magic number: if (lvl == DEFAULT_COMPRESSION) {  	lvl = 6;  } else if (lvl < NO_COMPRESSION || lvl > BEST_COMPRESSION) {  	throw new ArgumentOutOfRangeException ("lvl");  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,SetLevel,The following statement contains a magic number: lvl = 6;  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	/* output header */int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		/* Dictionary was set */header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	/* output header */int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		/* Dictionary was set */header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	/* output header */int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		/* Dictionary was set */header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	/* output header */int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		/* Dictionary was set */header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	/* output header */int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		/* Dictionary was set */header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	/* output header */int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		/* Dictionary was set */header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	/* output header */int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		/* Dictionary was set */header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	/* output header */int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		/* Dictionary was set */header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  	/* output header */int header = (DEFLATED + ((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  	int level_flags = (level - 1) >> 1;  	if (level_flags < 0 || level_flags > 3) {  		level_flags = 3;  	}  	header |= level_flags << 6;  	if ((state & IS_SETDICT) != 0) {  		/* Dictionary was set */header |= DeflaterConstants.PRESET_DICT;  	}  	header += 31 - (header % 31);  	pending.WriteShortMSB (header);  	if ((state & IS_SETDICT) != 0) {  		int chksum = engine.Adler;  		engine.ResetAdler ();  		pending.WriteShortMSB (chksum >> 16);  		pending.WriteShortMSB (chksum & 0xffff);  	}  	state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level_flags < 0 || level_flags > 3) {  	level_flags = 3;  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level_flags < 0 || level_flags > 3) {  	level_flags = 3;  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: level_flags = 3;  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: header |= level_flags << 6;  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: header += 31 - (header % 31);  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: header += 31 - (header % 31);  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if ((state & IS_SETDICT) != 0) {  	int chksum = engine.Adler;  	engine.ResetAdler ();  	pending.WriteShortMSB (chksum >> 16);  	pending.WriteShortMSB (chksum & 0xffff);  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: pending.WriteShortMSB (chksum >> 16);  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (; ;) {  	int count = pending.Flush (output' offset' length);  	offset += count;  	totalOut += count;  	length -= count;  	if (length == 0 || state == FINISHED_STATE) {  		break;  	}  	if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  		if (state == BUSY_STATE) {  			/* We need more input now */return origLength - length;  		} else if (state == FLUSHING_STATE) {  			if (level != NO_COMPRESSION) {  				/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  				while (neededbits > 0) {  					/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  					neededbits -= 10;  				}  			}  			state = BUSY_STATE;  		} else if (state == FINISHING_STATE) {  			pending.AlignToByte ();  			// Compressed data is complete.  Write footer information if required.  			if (!noZlibHeaderOrFooter) {  				int adler = engine.Adler;  				pending.WriteShortMSB (adler >> 16);  				pending.WriteShortMSB (adler & 0xffff);  			}  			state = FINISHED_STATE;  		}  	}  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (; ;) {  	int count = pending.Flush (output' offset' length);  	offset += count;  	totalOut += count;  	length -= count;  	if (length == 0 || state == FINISHED_STATE) {  		break;  	}  	if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  		if (state == BUSY_STATE) {  			/* We need more input now */return origLength - length;  		} else if (state == FLUSHING_STATE) {  			if (level != NO_COMPRESSION) {  				/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  				while (neededbits > 0) {  					/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  					neededbits -= 10;  				}  			}  			state = BUSY_STATE;  		} else if (state == FINISHING_STATE) {  			pending.AlignToByte ();  			// Compressed data is complete.  Write footer information if required.  			if (!noZlibHeaderOrFooter) {  				int adler = engine.Adler;  				pending.WriteShortMSB (adler >> 16);  				pending.WriteShortMSB (adler & 0xffff);  			}  			state = FINISHED_STATE;  		}  	}  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (; ;) {  	int count = pending.Flush (output' offset' length);  	offset += count;  	totalOut += count;  	length -= count;  	if (length == 0 || state == FINISHED_STATE) {  		break;  	}  	if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  		if (state == BUSY_STATE) {  			/* We need more input now */return origLength - length;  		} else if (state == FLUSHING_STATE) {  			if (level != NO_COMPRESSION) {  				/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  				while (neededbits > 0) {  					/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  					neededbits -= 10;  				}  			}  			state = BUSY_STATE;  		} else if (state == FINISHING_STATE) {  			pending.AlignToByte ();  			// Compressed data is complete.  Write footer information if required.  			if (!noZlibHeaderOrFooter) {  				int adler = engine.Adler;  				pending.WriteShortMSB (adler >> 16);  				pending.WriteShortMSB (adler & 0xffff);  			}  			state = FINISHED_STATE;  		}  	}  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (; ;) {  	int count = pending.Flush (output' offset' length);  	offset += count;  	totalOut += count;  	length -= count;  	if (length == 0 || state == FINISHED_STATE) {  		break;  	}  	if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  		if (state == BUSY_STATE) {  			/* We need more input now */return origLength - length;  		} else if (state == FLUSHING_STATE) {  			if (level != NO_COMPRESSION) {  				/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  				while (neededbits > 0) {  					/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  					neededbits -= 10;  				}  			}  			state = BUSY_STATE;  		} else if (state == FINISHING_STATE) {  			pending.AlignToByte ();  			// Compressed data is complete.  Write footer information if required.  			if (!noZlibHeaderOrFooter) {  				int adler = engine.Adler;  				pending.WriteShortMSB (adler >> 16);  				pending.WriteShortMSB (adler & 0xffff);  			}  			state = FINISHED_STATE;  		}  	}  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (; ;) {  	int count = pending.Flush (output' offset' length);  	offset += count;  	totalOut += count;  	length -= count;  	if (length == 0 || state == FINISHED_STATE) {  		break;  	}  	if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  		if (state == BUSY_STATE) {  			/* We need more input now */return origLength - length;  		} else if (state == FLUSHING_STATE) {  			if (level != NO_COMPRESSION) {  				/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  				while (neededbits > 0) {  					/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  					neededbits -= 10;  				}  			}  			state = BUSY_STATE;  		} else if (state == FINISHING_STATE) {  			pending.AlignToByte ();  			// Compressed data is complete.  Write footer information if required.  			if (!noZlibHeaderOrFooter) {  				int adler = engine.Adler;  				pending.WriteShortMSB (adler >> 16);  				pending.WriteShortMSB (adler & 0xffff);  			}  			state = FINISHED_STATE;  		}  	}  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (; ;) {  	int count = pending.Flush (output' offset' length);  	offset += count;  	totalOut += count;  	length -= count;  	if (length == 0 || state == FINISHED_STATE) {  		break;  	}  	if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  		if (state == BUSY_STATE) {  			/* We need more input now */return origLength - length;  		} else if (state == FLUSHING_STATE) {  			if (level != NO_COMPRESSION) {  				/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  				while (neededbits > 0) {  					/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  					neededbits -= 10;  				}  			}  			state = BUSY_STATE;  		} else if (state == FINISHING_STATE) {  			pending.AlignToByte ();  			// Compressed data is complete.  Write footer information if required.  			if (!noZlibHeaderOrFooter) {  				int adler = engine.Adler;  				pending.WriteShortMSB (adler >> 16);  				pending.WriteShortMSB (adler & 0xffff);  			}  			state = FINISHED_STATE;  		}  	}  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  	if (state == BUSY_STATE) {  		/* We need more input now */return origLength - length;  	} else if (state == FLUSHING_STATE) {  		if (level != NO_COMPRESSION) {  			/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  			while (neededbits > 0) {  				/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  				neededbits -= 10;  			}  		}  		state = BUSY_STATE;  	} else if (state == FINISHING_STATE) {  		pending.AlignToByte ();  		// Compressed data is complete.  Write footer information if required.  		if (!noZlibHeaderOrFooter) {  			int adler = engine.Adler;  			pending.WriteShortMSB (adler >> 16);  			pending.WriteShortMSB (adler & 0xffff);  		}  		state = FINISHED_STATE;  	}  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  	if (state == BUSY_STATE) {  		/* We need more input now */return origLength - length;  	} else if (state == FLUSHING_STATE) {  		if (level != NO_COMPRESSION) {  			/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  			while (neededbits > 0) {  				/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  				neededbits -= 10;  			}  		}  		state = BUSY_STATE;  	} else if (state == FINISHING_STATE) {  		pending.AlignToByte ();  		// Compressed data is complete.  Write footer information if required.  		if (!noZlibHeaderOrFooter) {  			int adler = engine.Adler;  			pending.WriteShortMSB (adler >> 16);  			pending.WriteShortMSB (adler & 0xffff);  		}  		state = FINISHED_STATE;  	}  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  	if (state == BUSY_STATE) {  		/* We need more input now */return origLength - length;  	} else if (state == FLUSHING_STATE) {  		if (level != NO_COMPRESSION) {  			/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  			while (neededbits > 0) {  				/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  				neededbits -= 10;  			}  		}  		state = BUSY_STATE;  	} else if (state == FINISHING_STATE) {  		pending.AlignToByte ();  		// Compressed data is complete.  Write footer information if required.  		if (!noZlibHeaderOrFooter) {  			int adler = engine.Adler;  			pending.WriteShortMSB (adler >> 16);  			pending.WriteShortMSB (adler & 0xffff);  		}  		state = FINISHED_STATE;  	}  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  	if (state == BUSY_STATE) {  		/* We need more input now */return origLength - length;  	} else if (state == FLUSHING_STATE) {  		if (level != NO_COMPRESSION) {  			/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  			while (neededbits > 0) {  				/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  				neededbits -= 10;  			}  		}  		state = BUSY_STATE;  	} else if (state == FINISHING_STATE) {  		pending.AlignToByte ();  		// Compressed data is complete.  Write footer information if required.  		if (!noZlibHeaderOrFooter) {  			int adler = engine.Adler;  			pending.WriteShortMSB (adler >> 16);  			pending.WriteShortMSB (adler & 0xffff);  		}  		state = FINISHED_STATE;  	}  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  	if (state == BUSY_STATE) {  		/* We need more input now */return origLength - length;  	} else if (state == FLUSHING_STATE) {  		if (level != NO_COMPRESSION) {  			/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  			while (neededbits > 0) {  				/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  				neededbits -= 10;  			}  		}  		state = BUSY_STATE;  	} else if (state == FINISHING_STATE) {  		pending.AlignToByte ();  		// Compressed data is complete.  Write footer information if required.  		if (!noZlibHeaderOrFooter) {  			int adler = engine.Adler;  			pending.WriteShortMSB (adler >> 16);  			pending.WriteShortMSB (adler & 0xffff);  		}  		state = FINISHED_STATE;  	}  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!engine.Deflate ((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  	if (state == BUSY_STATE) {  		/* We need more input now */return origLength - length;  	} else if (state == FLUSHING_STATE) {  		if (level != NO_COMPRESSION) {  			/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  			while (neededbits > 0) {  				/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  				neededbits -= 10;  			}  		}  		state = BUSY_STATE;  	} else if (state == FINISHING_STATE) {  		pending.AlignToByte ();  		// Compressed data is complete.  Write footer information if required.  		if (!noZlibHeaderOrFooter) {  			int adler = engine.Adler;  			pending.WriteShortMSB (adler >> 16);  			pending.WriteShortMSB (adler & 0xffff);  		}  		state = FINISHED_STATE;  	}  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == BUSY_STATE) {  	/* We need more input now */return origLength - length;  } else if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  } else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == BUSY_STATE) {  	/* We need more input now */return origLength - length;  } else if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  } else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == BUSY_STATE) {  	/* We need more input now */return origLength - length;  } else if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  } else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == BUSY_STATE) {  	/* We need more input now */return origLength - length;  } else if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  } else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == BUSY_STATE) {  	/* We need more input now */return origLength - length;  } else if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  } else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == BUSY_STATE) {  	/* We need more input now */return origLength - length;  } else if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  } else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  } else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  } else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  } else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  } else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  } else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FLUSHING_STATE) {  	if (level != NO_COMPRESSION) {  		/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  		while (neededbits > 0) {  			/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  			neededbits -= 10;  		}  	}  	state = BUSY_STATE;  } else if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level != NO_COMPRESSION) {  	/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  	while (neededbits > 0) {  		/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  		neededbits -= 10;  	}  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level != NO_COMPRESSION) {  	/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  	while (neededbits > 0) {  		/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  		neededbits -= 10;  	}  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level != NO_COMPRESSION) {  	/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  	while (neededbits > 0) {  		/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  		neededbits -= 10;  	}  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level != NO_COMPRESSION) {  	/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  	while (neededbits > 0) {  		/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  		neededbits -= 10;  	}  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (level != NO_COMPRESSION) {  	/* We have to supply some lookahead.  8 bit lookahead 							 * is needed by the zlib inflater' and we must fill 							 * the next byte' so that all bits are flushed. 							 */int neededbits = 8 + ((-pending.BitCount) & 7);  	while (neededbits > 0) {  		/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  		neededbits -= 10;  	}  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: while (neededbits > 0) {  	/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  	neededbits -= 10;  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: while (neededbits > 0) {  	/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  	neededbits -= 10;  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: while (neededbits > 0) {  	/* write a static tree block consisting solely of 								 * an EOF: 								 */pending.WriteBits (2' 10);  	neededbits -= 10;  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: pending.WriteBits (2' 10);  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: pending.WriteBits (2' 10);  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: neededbits -= 10;  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state == FINISHING_STATE) {  	pending.AlignToByte ();  	// Compressed data is complete.  Write footer information if required.  	if (!noZlibHeaderOrFooter) {  		int adler = engine.Adler;  		pending.WriteShortMSB (adler >> 16);  		pending.WriteShortMSB (adler & 0xffff);  	}  	state = FINISHED_STATE;  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (!noZlibHeaderOrFooter) {  	int adler = engine.Adler;  	pending.WriteShortMSB (adler >> 16);  	pending.WriteShortMSB (adler & 0xffff);  }  
Magic Number,agsXMPP.IO.Compression,Deflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Deflater.cs,Deflate,The following statement contains a magic number: pending.WriteShortMSB (adler >> 16);  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: input.DropBits (16);  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: header = ((header << 8) | (header >> 8)) & 0xffff;  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: header = ((header << 8) | (header >> 8)) & 0xffff;  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: if (header % 31 != 0) {  	throw new SharpZipBaseException ("Header checksum illegal");  }  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: if ((header & 0x0f00) != (Deflater.DEFLATED << 8)) {  	throw new SharpZipBaseException ("Compression Method unknown");  }  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: if ((header & 0x0020) == 0) {  	// Dictionary flag?  	mode = DECODE_BLOCKS;  } else {  	mode = DECODE_DICT;  	neededBits = 32;  }  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: neededBits = 32;  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  	int dictByte = input.PeekBits (8);  	if (dictByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | dictByte;  	neededBits -= 8;  }  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  	int dictByte = input.PeekBits (8);  	if (dictByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | dictByte;  	neededBits -= 8;  }  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  	int dictByte = input.PeekBits (8);  	if (dictByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | dictByte;  	neededBits -= 8;  }  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  	int dictByte = input.PeekBits (8);  	if (dictByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | dictByte;  	neededBits -= 8;  }  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: input.DropBits (8);  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: readAdler = (readAdler << 8) | dictByte;  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: neededBits -= 8;  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  	int symbol;  	switch (mode) {  	case DECODE_HUFFMAN:  		/* This is the inner loop so it is optimized a bit */while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  			outputWindow.Write (symbol);  			if (--free < 258) {  				return true;  			}  		}  		if (symbol < 257) {  			if (symbol < 0) {  				return false;  			} else {  				/* symbol == 256: end of block */distTree = null;  				litlenTree = null;  				mode = DECODE_BLOCKS;  				return true;  			}  		}  		try {  			repLength = CPLENS [symbol - 257];  			neededBits = CPLEXT [symbol - 257];  		} catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep length code");  		}  		goto case DECODE_HUFFMAN_LENBITS;  	/* fall through */case DECODE_HUFFMAN_LENBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_LENBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repLength += i;  		}  		mode = DECODE_HUFFMAN_DIST;  		goto case DECODE_HUFFMAN_DIST;  	/* fall through */case DECODE_HUFFMAN_DIST:  		symbol = distTree.GetSymbol (input);  		if (symbol < 0) {  			return false;  		}  		try {  			repDist = CPDIST [symbol];  			neededBits = CPDEXT [symbol];  		} catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep dist code");  		}  		goto case DECODE_HUFFMAN_DISTBITS;  	/* fall through */case DECODE_HUFFMAN_DISTBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_DISTBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repDist += i;  		}  		outputWindow.Repeat (repLength' repDist);  		free -= repLength;  		mode = DECODE_HUFFMAN;  		break;  	default:  		throw new SharpZipBaseException ("Inflater unknown mode");  	}  }  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  	int symbol;  	switch (mode) {  	case DECODE_HUFFMAN:  		/* This is the inner loop so it is optimized a bit */while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  			outputWindow.Write (symbol);  			if (--free < 258) {  				return true;  			}  		}  		if (symbol < 257) {  			if (symbol < 0) {  				return false;  			} else {  				/* symbol == 256: end of block */distTree = null;  				litlenTree = null;  				mode = DECODE_BLOCKS;  				return true;  			}  		}  		try {  			repLength = CPLENS [symbol - 257];  			neededBits = CPLEXT [symbol - 257];  		} catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep length code");  		}  		goto case DECODE_HUFFMAN_LENBITS;  	/* fall through */case DECODE_HUFFMAN_LENBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_LENBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repLength += i;  		}  		mode = DECODE_HUFFMAN_DIST;  		goto case DECODE_HUFFMAN_DIST;  	/* fall through */case DECODE_HUFFMAN_DIST:  		symbol = distTree.GetSymbol (input);  		if (symbol < 0) {  			return false;  		}  		try {  			repDist = CPDIST [symbol];  			neededBits = CPDEXT [symbol];  		} catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep dist code");  		}  		goto case DECODE_HUFFMAN_DISTBITS;  	/* fall through */case DECODE_HUFFMAN_DISTBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_DISTBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repDist += i;  		}  		outputWindow.Repeat (repLength' repDist);  		free -= repLength;  		mode = DECODE_HUFFMAN;  		break;  	default:  		throw new SharpZipBaseException ("Inflater unknown mode");  	}  }  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  	int symbol;  	switch (mode) {  	case DECODE_HUFFMAN:  		/* This is the inner loop so it is optimized a bit */while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  			outputWindow.Write (symbol);  			if (--free < 258) {  				return true;  			}  		}  		if (symbol < 257) {  			if (symbol < 0) {  				return false;  			} else {  				/* symbol == 256: end of block */distTree = null;  				litlenTree = null;  				mode = DECODE_BLOCKS;  				return true;  			}  		}  		try {  			repLength = CPLENS [symbol - 257];  			neededBits = CPLEXT [symbol - 257];  		} catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep length code");  		}  		goto case DECODE_HUFFMAN_LENBITS;  	/* fall through */case DECODE_HUFFMAN_LENBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_LENBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repLength += i;  		}  		mode = DECODE_HUFFMAN_DIST;  		goto case DECODE_HUFFMAN_DIST;  	/* fall through */case DECODE_HUFFMAN_DIST:  		symbol = distTree.GetSymbol (input);  		if (symbol < 0) {  			return false;  		}  		try {  			repDist = CPDIST [symbol];  			neededBits = CPDEXT [symbol];  		} catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep dist code");  		}  		goto case DECODE_HUFFMAN_DISTBITS;  	/* fall through */case DECODE_HUFFMAN_DISTBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_DISTBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repDist += i;  		}  		outputWindow.Repeat (repLength' repDist);  		free -= repLength;  		mode = DECODE_HUFFMAN;  		break;  	default:  		throw new SharpZipBaseException ("Inflater unknown mode");  	}  }  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  	int symbol;  	switch (mode) {  	case DECODE_HUFFMAN:  		/* This is the inner loop so it is optimized a bit */while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  			outputWindow.Write (symbol);  			if (--free < 258) {  				return true;  			}  		}  		if (symbol < 257) {  			if (symbol < 0) {  				return false;  			} else {  				/* symbol == 256: end of block */distTree = null;  				litlenTree = null;  				mode = DECODE_BLOCKS;  				return true;  			}  		}  		try {  			repLength = CPLENS [symbol - 257];  			neededBits = CPLEXT [symbol - 257];  		} catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep length code");  		}  		goto case DECODE_HUFFMAN_LENBITS;  	/* fall through */case DECODE_HUFFMAN_LENBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_LENBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repLength += i;  		}  		mode = DECODE_HUFFMAN_DIST;  		goto case DECODE_HUFFMAN_DIST;  	/* fall through */case DECODE_HUFFMAN_DIST:  		symbol = distTree.GetSymbol (input);  		if (symbol < 0) {  			return false;  		}  		try {  			repDist = CPDIST [symbol];  			neededBits = CPDEXT [symbol];  		} catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep dist code");  		}  		goto case DECODE_HUFFMAN_DISTBITS;  	/* fall through */case DECODE_HUFFMAN_DISTBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_DISTBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repDist += i;  		}  		outputWindow.Repeat (repLength' repDist);  		free -= repLength;  		mode = DECODE_HUFFMAN;  		break;  	default:  		throw new SharpZipBaseException ("Inflater unknown mode");  	}  }  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258) {  	int symbol;  	switch (mode) {  	case DECODE_HUFFMAN:  		/* This is the inner loop so it is optimized a bit */while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  			outputWindow.Write (symbol);  			if (--free < 258) {  				return true;  			}  		}  		if (symbol < 257) {  			if (symbol < 0) {  				return false;  			} else {  				/* symbol == 256: end of block */distTree = null;  				litlenTree = null;  				mode = DECODE_BLOCKS;  				return true;  			}  		}  		try {  			repLength = CPLENS [symbol - 257];  			neededBits = CPLEXT [symbol - 257];  		} catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep length code");  		}  		goto case DECODE_HUFFMAN_LENBITS;  	/* fall through */case DECODE_HUFFMAN_LENBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_LENBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repLength += i;  		}  		mode = DECODE_HUFFMAN_DIST;  		goto case DECODE_HUFFMAN_DIST;  	/* fall through */case DECODE_HUFFMAN_DIST:  		symbol = distTree.GetSymbol (input);  		if (symbol < 0) {  			return false;  		}  		try {  			repDist = CPDIST [symbol];  			neededBits = CPDEXT [symbol];  		} catch (Exception) {  			throw new SharpZipBaseException ("Illegal rep dist code");  		}  		goto case DECODE_HUFFMAN_DISTBITS;  	/* fall through */case DECODE_HUFFMAN_DISTBITS:  		if (neededBits > 0) {  			mode = DECODE_HUFFMAN_DISTBITS;  			int i = input.PeekBits (neededBits);  			if (i < 0) {  				return false;  			}  			input.DropBits (neededBits);  			repDist += i;  		}  		outputWindow.Repeat (repLength' repDist);  		free -= repLength;  		mode = DECODE_HUFFMAN;  		break;  	default:  		throw new SharpZipBaseException ("Inflater unknown mode");  	}  }  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: switch (mode) {  case DECODE_HUFFMAN:  	/* This is the inner loop so it is optimized a bit */while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  		outputWindow.Write (symbol);  		if (--free < 258) {  			return true;  		}  	}  	if (symbol < 257) {  		if (symbol < 0) {  			return false;  		} else {  			/* symbol == 256: end of block */distTree = null;  			litlenTree = null;  			mode = DECODE_BLOCKS;  			return true;  		}  	}  	try {  		repLength = CPLENS [symbol - 257];  		neededBits = CPLEXT [symbol - 257];  	} catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep length code");  	}  	goto case DECODE_HUFFMAN_LENBITS;  /* fall through */case DECODE_HUFFMAN_LENBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_LENBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repLength += i;  	}  	mode = DECODE_HUFFMAN_DIST;  	goto case DECODE_HUFFMAN_DIST;  /* fall through */case DECODE_HUFFMAN_DIST:  	symbol = distTree.GetSymbol (input);  	if (symbol < 0) {  		return false;  	}  	try {  		repDist = CPDIST [symbol];  		neededBits = CPDEXT [symbol];  	} catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep dist code");  	}  	goto case DECODE_HUFFMAN_DISTBITS;  /* fall through */case DECODE_HUFFMAN_DISTBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_DISTBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repDist += i;  	}  	outputWindow.Repeat (repLength' repDist);  	free -= repLength;  	mode = DECODE_HUFFMAN;  	break;  default:  	throw new SharpZipBaseException ("Inflater unknown mode");  }  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: switch (mode) {  case DECODE_HUFFMAN:  	/* This is the inner loop so it is optimized a bit */while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  		outputWindow.Write (symbol);  		if (--free < 258) {  			return true;  		}  	}  	if (symbol < 257) {  		if (symbol < 0) {  			return false;  		} else {  			/* symbol == 256: end of block */distTree = null;  			litlenTree = null;  			mode = DECODE_BLOCKS;  			return true;  		}  	}  	try {  		repLength = CPLENS [symbol - 257];  		neededBits = CPLEXT [symbol - 257];  	} catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep length code");  	}  	goto case DECODE_HUFFMAN_LENBITS;  /* fall through */case DECODE_HUFFMAN_LENBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_LENBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repLength += i;  	}  	mode = DECODE_HUFFMAN_DIST;  	goto case DECODE_HUFFMAN_DIST;  /* fall through */case DECODE_HUFFMAN_DIST:  	symbol = distTree.GetSymbol (input);  	if (symbol < 0) {  		return false;  	}  	try {  		repDist = CPDIST [symbol];  		neededBits = CPDEXT [symbol];  	} catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep dist code");  	}  	goto case DECODE_HUFFMAN_DISTBITS;  /* fall through */case DECODE_HUFFMAN_DISTBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_DISTBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repDist += i;  	}  	outputWindow.Repeat (repLength' repDist);  	free -= repLength;  	mode = DECODE_HUFFMAN;  	break;  default:  	throw new SharpZipBaseException ("Inflater unknown mode");  }  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: switch (mode) {  case DECODE_HUFFMAN:  	/* This is the inner loop so it is optimized a bit */while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  		outputWindow.Write (symbol);  		if (--free < 258) {  			return true;  		}  	}  	if (symbol < 257) {  		if (symbol < 0) {  			return false;  		} else {  			/* symbol == 256: end of block */distTree = null;  			litlenTree = null;  			mode = DECODE_BLOCKS;  			return true;  		}  	}  	try {  		repLength = CPLENS [symbol - 257];  		neededBits = CPLEXT [symbol - 257];  	} catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep length code");  	}  	goto case DECODE_HUFFMAN_LENBITS;  /* fall through */case DECODE_HUFFMAN_LENBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_LENBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repLength += i;  	}  	mode = DECODE_HUFFMAN_DIST;  	goto case DECODE_HUFFMAN_DIST;  /* fall through */case DECODE_HUFFMAN_DIST:  	symbol = distTree.GetSymbol (input);  	if (symbol < 0) {  		return false;  	}  	try {  		repDist = CPDIST [symbol];  		neededBits = CPDEXT [symbol];  	} catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep dist code");  	}  	goto case DECODE_HUFFMAN_DISTBITS;  /* fall through */case DECODE_HUFFMAN_DISTBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_DISTBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repDist += i;  	}  	outputWindow.Repeat (repLength' repDist);  	free -= repLength;  	mode = DECODE_HUFFMAN;  	break;  default:  	throw new SharpZipBaseException ("Inflater unknown mode");  }  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: switch (mode) {  case DECODE_HUFFMAN:  	/* This is the inner loop so it is optimized a bit */while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  		outputWindow.Write (symbol);  		if (--free < 258) {  			return true;  		}  	}  	if (symbol < 257) {  		if (symbol < 0) {  			return false;  		} else {  			/* symbol == 256: end of block */distTree = null;  			litlenTree = null;  			mode = DECODE_BLOCKS;  			return true;  		}  	}  	try {  		repLength = CPLENS [symbol - 257];  		neededBits = CPLEXT [symbol - 257];  	} catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep length code");  	}  	goto case DECODE_HUFFMAN_LENBITS;  /* fall through */case DECODE_HUFFMAN_LENBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_LENBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repLength += i;  	}  	mode = DECODE_HUFFMAN_DIST;  	goto case DECODE_HUFFMAN_DIST;  /* fall through */case DECODE_HUFFMAN_DIST:  	symbol = distTree.GetSymbol (input);  	if (symbol < 0) {  		return false;  	}  	try {  		repDist = CPDIST [symbol];  		neededBits = CPDEXT [symbol];  	} catch (Exception) {  		throw new SharpZipBaseException ("Illegal rep dist code");  	}  	goto case DECODE_HUFFMAN_DISTBITS;  /* fall through */case DECODE_HUFFMAN_DISTBITS:  	if (neededBits > 0) {  		mode = DECODE_HUFFMAN_DISTBITS;  		int i = input.PeekBits (neededBits);  		if (i < 0) {  			return false;  		}  		input.DropBits (neededBits);  		repDist += i;  	}  	outputWindow.Repeat (repLength' repDist);  	free -= repLength;  	mode = DECODE_HUFFMAN;  	break;  default:  	throw new SharpZipBaseException ("Inflater unknown mode");  }  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (((symbol = litlenTree.GetSymbol (input)) & ~0xff) == 0) {  	outputWindow.Write (symbol);  	if (--free < 258) {  		return true;  	}  }  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: if (--free < 258) {  	return true;  }  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: if (symbol < 257) {  	if (symbol < 0) {  		return false;  	} else {  		/* symbol == 256: end of block */distTree = null;  		litlenTree = null;  		mode = DECODE_BLOCKS;  		return true;  	}  }  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: try {  	repLength = CPLENS [symbol - 257];  	neededBits = CPLEXT [symbol - 257];  } catch (Exception) {  	throw new SharpZipBaseException ("Illegal rep length code");  }  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: try {  	repLength = CPLENS [symbol - 257];  	neededBits = CPLEXT [symbol - 257];  } catch (Exception) {  	throw new SharpZipBaseException ("Illegal rep length code");  }  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: repLength = CPLENS [symbol - 257];  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: neededBits = CPLEXT [symbol - 257];  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  	int chkByte = input.PeekBits (8);  	if (chkByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | chkByte;  	neededBits -= 8;  }  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  	int chkByte = input.PeekBits (8);  	if (chkByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | chkByte;  	neededBits -= 8;  }  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  	int chkByte = input.PeekBits (8);  	if (chkByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | chkByte;  	neededBits -= 8;  }  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  	int chkByte = input.PeekBits (8);  	if (chkByte < 0) {  		return false;  	}  	input.DropBits (8);  	readAdler = (readAdler << 8) | chkByte;  	neededBits -= 8;  }  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: input.DropBits (8);  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: readAdler = (readAdler << 8) | chkByte;  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: neededBits -= 8;  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		} else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  /* fall through */case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  /* fall through */case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  /* fall through */case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		} else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  /* fall through */case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  /* fall through */case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  /* fall through */case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		} else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  /* fall through */case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  /* fall through */case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  /* fall through */case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		} else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  /* fall through */case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  /* fall through */case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  /* fall through */case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		} else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  /* fall through */case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  /* fall through */case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  /* fall through */case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		} else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  /* fall through */case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  /* fall through */case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  /* fall through */case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  case DECODE_HEADER:  	return DecodeHeader ();  case DECODE_DICT:  	return DecodeDict ();  case DECODE_CHKSUM:  	return DecodeChksum ();  case DECODE_BLOCKS:  	if (isLastBlock) {  		if (noHeader) {  			mode = FINISHED;  			return false;  		} else {  			input.SkipToByteBoundary ();  			neededBits = 32;  			mode = DECODE_CHKSUM;  			return true;  		}  	}  	int type = input.PeekBits (3);  	if (type < 0) {  		return false;  	}  	input.DropBits (3);  	if ((type & 1) != 0) {  		isLastBlock = true;  	}  	switch (type >> 1) {  	case DeflaterConstants.STORED_BLOCK:  		input.SkipToByteBoundary ();  		mode = DECODE_STORED_LEN1;  		break;  	case DeflaterConstants.STATIC_TREES:  		litlenTree = InflaterHuffmanTree.defLitLenTree;  		distTree = InflaterHuffmanTree.defDistTree;  		mode = DECODE_HUFFMAN;  		break;  	case DeflaterConstants.DYN_TREES:  		dynHeader = new InflaterDynHeader ();  		mode = DECODE_DYN_HEADER;  		break;  	default:  		throw new SharpZipBaseException ("Unknown block type " + type);  	}  	return true;  case DECODE_STORED_LEN1:  	{  		if ((uncomprLen = input.PeekBits (16)) < 0) {  			return false;  		}  		input.DropBits (16);  		mode = DECODE_STORED_LEN2;  	}  	goto case DECODE_STORED_LEN2;  /* fall through */case DECODE_STORED_LEN2:  	{  		int nlen = input.PeekBits (16);  		if (nlen < 0) {  			return false;  		}  		input.DropBits (16);  		if (nlen != (uncomprLen ^ 0xffff)) {  			throw new SharpZipBaseException ("broken uncompressed block");  		}  		mode = DECODE_STORED;  	}  	goto case DECODE_STORED;  /* fall through */case DECODE_STORED: {  	int more = outputWindow.CopyStored (input' uncomprLen);  	uncomprLen -= more;  	if (uncomprLen == 0) {  		mode = DECODE_BLOCKS;  		return true;  	}  	return !input.IsNeedingInput;  }  case DECODE_DYN_HEADER:  	if (!dynHeader.Decode (input)) {  		return false;  	}  	litlenTree = dynHeader.BuildLitLenTree ();  	distTree = dynHeader.BuildDistTree ();  	mode = DECODE_HUFFMAN;  	goto case DECODE_HUFFMAN;  /* fall through */case DECODE_HUFFMAN:  case DECODE_HUFFMAN_LENBITS:  case DECODE_HUFFMAN_DIST:  case DECODE_HUFFMAN_DISTBITS:  	return DecodeHuffman ();  case FINISHED:  	return false;  default:  	throw new SharpZipBaseException ("Inflater.Decode unknown mode");  }  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,Decode,The following statement contains a magic number: if (isLastBlock) {  	if (noHeader) {  		mode = FINISHED;  		return false;  	} else {  		input.SkipToByteBoundary ();  		neededBits = 32;  		mode = DECODE_CHKSUM;  		return true;  	}  }  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,Decode,The following statement contains a magic number: if (noHeader) {  	mode = FINISHED;  	return false;  } else {  	input.SkipToByteBoundary ();  	neededBits = 32;  	mode = DECODE_CHKSUM;  	return true;  }  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,Decode,The following statement contains a magic number: neededBits = 32;  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,Decode,The following statement contains a magic number: input.DropBits (3);  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,Decode,The following statement contains a magic number: if ((uncomprLen = input.PeekBits (16)) < 0) {  	return false;  }  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,Decode,The following statement contains a magic number: input.DropBits (16);  
Magic Number,agsXMPP.IO.Compression,Inflater,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Inflater.cs,Decode,The following statement contains a magic number: input.DropBits (16);  
Magic Number,agsXMPP.IO.Compression.Streams,StreamManipulator,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Streams\StreamManipulator.cs,PeekBits,The following statement contains a magic number: if (bits_in_buffer < n) {  	if (window_start == window_end) {  		return -1;  		// ok  	}  	buffer |= (uint)((window [window_start++] & 0xff | (window [window_start++] & 0xff) << 8) << bits_in_buffer);  	bits_in_buffer += 16;  }  
Magic Number,agsXMPP.IO.Compression.Streams,StreamManipulator,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Streams\StreamManipulator.cs,PeekBits,The following statement contains a magic number: if (bits_in_buffer < n) {  	if (window_start == window_end) {  		return -1;  		// ok  	}  	buffer |= (uint)((window [window_start++] & 0xff | (window [window_start++] & 0xff) << 8) << bits_in_buffer);  	bits_in_buffer += 16;  }  
Magic Number,agsXMPP.IO.Compression.Streams,StreamManipulator,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Streams\StreamManipulator.cs,PeekBits,The following statement contains a magic number: buffer |= (uint)((window [window_start++] & 0xff | (window [window_start++] & 0xff) << 8) << bits_in_buffer);  
Magic Number,agsXMPP.IO.Compression.Streams,StreamManipulator,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Streams\StreamManipulator.cs,PeekBits,The following statement contains a magic number: bits_in_buffer += 16;  
Magic Number,agsXMPP.IO.Compression.Streams,StreamManipulator,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Streams\StreamManipulator.cs,SkipToByteBoundary,The following statement contains a magic number: buffer >>= (bits_in_buffer & 7);  
Magic Number,agsXMPP.IO.Compression.Streams,StreamManipulator,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Streams\StreamManipulator.cs,SkipToByteBoundary,The following statement contains a magic number: bits_in_buffer &= ~7;  
Magic Number,agsXMPP.IO.Compression.Streams,StreamManipulator,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: if ((bits_in_buffer & 7) != 0) {  	/* bits_in_buffer may only be 0 or a multiple of 8 */throw new InvalidOperationException ("Bit buffer is not byte aligned!");  }  
Magic Number,agsXMPP.IO.Compression.Streams,StreamManipulator,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: while (bits_in_buffer > 0 && length > 0) {  	output [offset++] = (byte)buffer;  	buffer >>= 8;  	bits_in_buffer -= 8;  	length--;  	count++;  }  
Magic Number,agsXMPP.IO.Compression.Streams,StreamManipulator,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: while (bits_in_buffer > 0 && length > 0) {  	output [offset++] = (byte)buffer;  	buffer >>= 8;  	bits_in_buffer -= 8;  	length--;  	count++;  }  
Magic Number,agsXMPP.IO.Compression.Streams,StreamManipulator,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: buffer >>= 8;  
Magic Number,agsXMPP.IO.Compression.Streams,StreamManipulator,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: bits_in_buffer -= 8;  
Magic Number,agsXMPP.IO.Compression.Streams,StreamManipulator,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: if (((window_start - window_end) & 1) != 0) {  	/* We always want an even number of bytes in input' see peekBits */buffer = (uint)(window [window_start++] & 0xff);  	bits_in_buffer = 8;  }  
Magic Number,agsXMPP.IO.Compression.Streams,StreamManipulator,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: bits_in_buffer = 8;  
Magic Number,agsXMPP.IO.Compression.Streams,StreamManipulator,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Streams\StreamManipulator.cs,SetInput,The following statement contains a magic number: if ((len & 1) != 0) {  	/* We always want an even number of bytes in input' see peekBits */buffer |= (uint)((buf [off++] & 0xff) << bits_in_buffer);  	bits_in_buffer += 8;  }  
Magic Number,agsXMPP.IO.Compression.Streams,StreamManipulator,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\Streams\StreamManipulator.cs,SetInput,The following statement contains a magic number: bits_in_buffer += 8;  
Magic Number,agsXMPP,Jid,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Jid.cs,UnescapeNode,The following statement contains a magic number: for (int i = 0; i < node.Length; i++) {  	char c1 = node [i];  	if (c1 == '\\' && i + 2 < node.Length) {  		i += 1;  		char c2 = node [i];  		i += 1;  		char c3 = node [i];  		if (c2 == '2') {  			switch (c3) {  			case '0':  				sb.Append (' ');  				break;  			case '2':  				sb.Append ('"');  				break;  			case '6':  				sb.Append ('&');  				break;  			case '7':  				sb.Append ('\'');  				break;  			case 'f':  				sb.Append ('/');  				break;  			}  		} else if (c2 == '3') {  			switch (c3) {  			case 'a':  				sb.Append (':');  				break;  			case 'c':  				sb.Append ('<');  				break;  			case 'e':  				sb.Append ('>');  				break;  			}  		} else if (c2 == '4') {  			if (c3 == '0')  				sb.Append ("@");  		} else if (c2 == '5') {  			if (c3 == 'c')  				sb.Append ("\\");  		}  	} else  		sb.Append (c1);  }  
Magic Number,agsXMPP,Jid,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Jid.cs,UnescapeNode,The following statement contains a magic number: if (c1 == '\\' && i + 2 < node.Length) {  	i += 1;  	char c2 = node [i];  	i += 1;  	char c3 = node [i];  	if (c2 == '2') {  		switch (c3) {  		case '0':  			sb.Append (' ');  			break;  		case '2':  			sb.Append ('"');  			break;  		case '6':  			sb.Append ('&');  			break;  		case '7':  			sb.Append ('\'');  			break;  		case 'f':  			sb.Append ('/');  			break;  		}  	} else if (c2 == '3') {  		switch (c3) {  		case 'a':  			sb.Append (':');  			break;  		case 'c':  			sb.Append ('<');  			break;  		case 'e':  			sb.Append ('>');  			break;  		}  	} else if (c2 == '4') {  		if (c3 == '0')  			sb.Append ("@");  	} else if (c2 == '5') {  		if (c3 == 'c')  			sb.Append ("\\");  	}  } else  	sb.Append (c1);  
Magic Number,agsXMPP,XmppClientConnection,D:\newReposJune17\meebey_agsxmpp\agsxmpp\XmppClientConnection.cs,SocketOnError,The following statement contains a magic number: if ((ex.GetType () == typeof(ConnectTimeoutException) || (ex.GetType () == typeof(SocketException) && ((SocketException)ex).ErrorCode == 10061)) && _SRVRecords != null && _SRVRecords.Length > 1) {  	// connect failed. We are using SRV records and have multiple results.  	// remove the current record  	RemoveSrvRecord (_currentSRVRecord);  	// find and set a new record  	SetConnectServerFromSRVRecords ();  	// connect again  	OpenSocket ();  } else {  	// Fires the socket error  	if (OnSocketError != null)  		OnSocketError (this' ex);  	// Only cleaneUp Session and raise on close if the stream already has started  	// if teh stream gets closed because of a socket error we have to raise both errors fo course  	if (m_StreamStarted && !m_CleanUpDone)  		CleanupSession ();  }  
Magic Number,agsXMPP,XmppClientConnection,D:\newReposJune17\meebey_agsxmpp\agsxmpp\XmppClientConnection.cs,Send,The following statement contains a magic number: if (!(ClientSocket is BoshClientSocket)) {  	// this is a hack to not send the xmlns="jabber:client" with all packets  	Element dummyEl = new Element ("a");  	dummyEl.Namespace = Uri.CLIENT;  	dummyEl.AddChild (e);  	string toSend = dummyEl.ToString ();  	Send (toSend.Substring (25' toSend.Length - 25 - 4));  } else  	base.Send (e);  
Magic Number,agsXMPP,XmppClientConnection,D:\newReposJune17\meebey_agsxmpp\agsxmpp\XmppClientConnection.cs,Send,The following statement contains a magic number: if (!(ClientSocket is BoshClientSocket)) {  	// this is a hack to not send the xmlns="jabber:client" with all packets  	Element dummyEl = new Element ("a");  	dummyEl.Namespace = Uri.CLIENT;  	dummyEl.AddChild (e);  	string toSend = dummyEl.ToString ();  	Send (toSend.Substring (25' toSend.Length - 25 - 4));  } else  	base.Send (e);  
Magic Number,agsXMPP,XmppClientConnection,D:\newReposJune17\meebey_agsxmpp\agsxmpp\XmppClientConnection.cs,Send,The following statement contains a magic number: if (!(ClientSocket is BoshClientSocket)) {  	// this is a hack to not send the xmlns="jabber:client" with all packets  	Element dummyEl = new Element ("a");  	dummyEl.Namespace = Uri.CLIENT;  	dummyEl.AddChild (e);  	string toSend = dummyEl.ToString ();  	Send (toSend.Substring (25' toSend.Length - 25 - 4));  } else  	base.Send (e);  
Magic Number,agsXMPP,XmppClientConnection,D:\newReposJune17\meebey_agsxmpp\agsxmpp\XmppClientConnection.cs,Send,The following statement contains a magic number: Send (toSend.Substring (25' toSend.Length - 25 - 4));  
Magic Number,agsXMPP,XmppClientConnection,D:\newReposJune17\meebey_agsxmpp\agsxmpp\XmppClientConnection.cs,Send,The following statement contains a magic number: Send (toSend.Substring (25' toSend.Length - 25 - 4));  
Magic Number,agsXMPP,XmppClientConnection,D:\newReposJune17\meebey_agsxmpp\agsxmpp\XmppClientConnection.cs,Send,The following statement contains a magic number: Send (toSend.Substring (25' toSend.Length - 25 - 4));  
Magic Number,agsXMPP,XmppComponentConnection,D:\newReposJune17\meebey_agsxmpp\agsxmpp\XmppComponentConnection.cs,Send,The following statement contains a magic number: Send (toSend.Substring (35' toSend.Length - 35 - 4));  
Magic Number,agsXMPP,XmppComponentConnection,D:\newReposJune17\meebey_agsxmpp\agsxmpp\XmppComponentConnection.cs,Send,The following statement contains a magic number: Send (toSend.Substring (35' toSend.Length - 35 - 4));  
Magic Number,agsXMPP,XmppComponentConnection,D:\newReposJune17\meebey_agsxmpp\agsxmpp\XmppComponentConnection.cs,Send,The following statement contains a magic number: Send (toSend.Substring (35' toSend.Length - 35 - 4));  
Magic Number,agsXMPP,XmppConnection,D:\newReposJune17\meebey_agsxmpp\agsxmpp\XmppConnection.cs,StreamParserOnStreamStart,The following statement contains a magic number: xml = xml.Substring (0' xml.Length - 2) + ">";  
Magic Number,agsXMPP,XmppConnection,D:\newReposJune17\meebey_agsxmpp\agsxmpp\XmppConnection.cs,Send,The following statement contains a magic number: if (m_KeepAlive && m_KeepaliveTimer != null)  	m_KeepaliveTimer.Change (m_KeepAliveInterval * 1000' m_KeepAliveInterval * 1000);  
Magic Number,agsXMPP,XmppConnection,D:\newReposJune17\meebey_agsxmpp\agsxmpp\XmppConnection.cs,Send,The following statement contains a magic number: if (m_KeepAlive && m_KeepaliveTimer != null)  	m_KeepaliveTimer.Change (m_KeepAliveInterval * 1000' m_KeepAliveInterval * 1000);  
Magic Number,agsXMPP,XmppConnection,D:\newReposJune17\meebey_agsxmpp\agsxmpp\XmppConnection.cs,Send,The following statement contains a magic number: m_KeepaliveTimer.Change (m_KeepAliveInterval * 1000' m_KeepAliveInterval * 1000);  
Magic Number,agsXMPP,XmppConnection,D:\newReposJune17\meebey_agsxmpp\agsxmpp\XmppConnection.cs,Send,The following statement contains a magic number: m_KeepaliveTimer.Change (m_KeepAliveInterval * 1000' m_KeepAliveInterval * 1000);  
Magic Number,agsXMPP.Net.Dns,Pointer,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\Dns\Pointer.cs,ReadShort,The following statement contains a magic number: return (short)(ReadByte () << 8 | ReadByte ());  
Magic Number,agsXMPP.Net.Dns,Pointer,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\Dns\Pointer.cs,ReadInt,The following statement contains a magic number: return (ushort)ReadShort () << 16 | (ushort)ReadShort ();  
Magic Number,agsXMPP.Net.Dns,Pointer,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\Dns\Pointer.cs,ReadDomain,The following statement contains a magic number: while ((length = ReadByte ()) != 0) {  	// top 2 bits set denotes domain name compression and to reference elsewhere  	if ((length & 0xc0) == 0xc0) {  		// work out the existing domain name' copy this pointer  		Pointer newPointer = Copy ();  		// and move it to where specified here  		newPointer.SetPosition ((length & 0x3f) << 8 | ReadByte ());  		// repeat call recursively  		domain.Append (newPointer.ReadDomain ());  		return domain.ToString ();  	}  	// if not using compression' copy a char at a time to the domain name  	while (length > 0) {  		domain.Append (ReadChar ());  		length--;  	}  	// if size of next label isn't null (end of domain name) add a period ready for next label  	if (Peek () != 0)  		domain.Append ('.');  }  
Magic Number,agsXMPP.Net.Dns,Pointer,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\Dns\Pointer.cs,ReadDomain,The following statement contains a magic number: if ((length & 0xc0) == 0xc0) {  	// work out the existing domain name' copy this pointer  	Pointer newPointer = Copy ();  	// and move it to where specified here  	newPointer.SetPosition ((length & 0x3f) << 8 | ReadByte ());  	// repeat call recursively  	domain.Append (newPointer.ReadDomain ());  	return domain.ToString ();  }  
Magic Number,agsXMPP.Net.Dns,Pointer,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\Dns\Pointer.cs,ReadDomain,The following statement contains a magic number: newPointer.SetPosition ((length & 0x3f) << 8 | ReadByte ());  
Magic Number,agsXMPP.Net.Dns,Question,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\Dns\Question.cs,Question,The following statement contains a magic number: if (domain.Length == 0 || domain.Length > 255 || !Regex.IsMatch (domain' @"^[a-z|A-Z|0-9|\-|_]{1'63}(\.[a-z|A-Z|0-9|\-|_]{1'63})+$")) {  	// domain names can't be bigger tan 255 chars' and individal labels can't be bigger than 63 chars  	throw new ArgumentException ("The supplied domain name was not in the correct form"' "domain");  }  
Magic Number,agsXMPP.Net.Dns,Request,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\Dns\Request.cs,GetMessage,The following statement contains a magic number: data.Add ((byte)(((byte)_opCode << 3) | (_recursionDesired ? 0x01 : 0)));  
Magic Number,agsXMPP.Net.Dns,Request,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\Dns\Request.cs,GetMessage,The following statement contains a magic number: unchecked {  	data.Add ((byte)(_questions.Count >> 8));  	data.Add ((byte)_questions.Count);  }  
Magic Number,agsXMPP.Net.Dns,Request,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\Dns\Request.cs,GetMessage,The following statement contains a magic number: data.Add ((byte)(_questions.Count >> 8));  
Magic Number,agsXMPP.Net.Dns,Resolver,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\Dns\Resolver.cs,UdpTransfer,The following statement contains a magic number: while (attempts <= _udpRetryAttempts) {  	// firstly' uniquely mark this request with an id  	unchecked {  		// substitute in an id unique to this lookup' the request has no idea about this  		requestMessage [0] = (byte)(_uniqueId >> 8);  		requestMessage [1] = (byte)_uniqueId;  	}  	// we'll be send and receiving a UDP packet  	Socket socket;  	if (Socket.OSSupportsIPv6 && (server.AddressFamily == AddressFamily.InterNetworkV6))  		socket = new Socket (AddressFamily.InterNetworkV6' SocketType.Dgram' ProtocolType.Udp);  	// V6  	else  		socket = new Socket (AddressFamily.InterNetwork' SocketType.Dgram' ProtocolType.Udp);  	// we will wait at most 1 second for a dns reply  	socket.SetSocketOption (SocketOptionLevel.Socket' SocketOptionName.ReceiveTimeout' _udpTimeout);  	// send it off to the server  	socket.SendTo (requestMessage' requestMessage.Length' SocketFlags.None' server);  	// RFC1035 states that the maximum size of a UDP datagram is 512 octets (bytes)  	byte[] responseMessage = new byte[512];  	try {  		// wait for a response upto 1 second  		socket.Receive (responseMessage);  		// make sure the message returned is ours  		if (responseMessage [0] == requestMessage [0] && responseMessage [1] == requestMessage [1]) {  			// its a valid response - return it' this is our successful exit point  			return responseMessage;  		}  	} catch (SocketException) {  		// failure - we better try again' but remember how many attempts  		attempts++;  	} finally {  		// increase the unique id  		_uniqueId++;  		// close the socket  		socket.Close ();  	}  }  
Magic Number,agsXMPP.Net.Dns,Resolver,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\Dns\Resolver.cs,UdpTransfer,The following statement contains a magic number: while (attempts <= _udpRetryAttempts) {  	// firstly' uniquely mark this request with an id  	unchecked {  		// substitute in an id unique to this lookup' the request has no idea about this  		requestMessage [0] = (byte)(_uniqueId >> 8);  		requestMessage [1] = (byte)_uniqueId;  	}  	// we'll be send and receiving a UDP packet  	Socket socket;  	if (Socket.OSSupportsIPv6 && (server.AddressFamily == AddressFamily.InterNetworkV6))  		socket = new Socket (AddressFamily.InterNetworkV6' SocketType.Dgram' ProtocolType.Udp);  	// V6  	else  		socket = new Socket (AddressFamily.InterNetwork' SocketType.Dgram' ProtocolType.Udp);  	// we will wait at most 1 second for a dns reply  	socket.SetSocketOption (SocketOptionLevel.Socket' SocketOptionName.ReceiveTimeout' _udpTimeout);  	// send it off to the server  	socket.SendTo (requestMessage' requestMessage.Length' SocketFlags.None' server);  	// RFC1035 states that the maximum size of a UDP datagram is 512 octets (bytes)  	byte[] responseMessage = new byte[512];  	try {  		// wait for a response upto 1 second  		socket.Receive (responseMessage);  		// make sure the message returned is ours  		if (responseMessage [0] == requestMessage [0] && responseMessage [1] == requestMessage [1]) {  			// its a valid response - return it' this is our successful exit point  			return responseMessage;  		}  	} catch (SocketException) {  		// failure - we better try again' but remember how many attempts  		attempts++;  	} finally {  		// increase the unique id  		_uniqueId++;  		// close the socket  		socket.Close ();  	}  }  
Magic Number,agsXMPP.Net.Dns,Resolver,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\Dns\Resolver.cs,UdpTransfer,The following statement contains a magic number: unchecked {  	// substitute in an id unique to this lookup' the request has no idea about this  	requestMessage [0] = (byte)(_uniqueId >> 8);  	requestMessage [1] = (byte)_uniqueId;  }  
Magic Number,agsXMPP.Net.Dns,Resolver,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\Dns\Resolver.cs,UdpTransfer,The following statement contains a magic number: requestMessage [0] = (byte)(_uniqueId >> 8);  
Magic Number,agsXMPP.Net.Dns,Response,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\Dns\Response.cs,Response,The following statement contains a magic number: if (returnCode > 6)  	returnCode = 6;  
Magic Number,agsXMPP.Net.Dns,Response,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\Dns\Response.cs,Response,The following statement contains a magic number: if (returnCode > 6)  	returnCode = 6;  
Magic Number,agsXMPP.Net.Dns,Response,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\Dns\Response.cs,Response,The following statement contains a magic number: returnCode = 6;  
Magic Number,agsXMPP.Net.Dns,Response,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\Dns\Response.cs,Response,The following statement contains a magic number: _authoritativeAnswer = ((flags1 & 4) != 0);  
Magic Number,agsXMPP.Net.Dns,Response,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\Dns\Response.cs,Response,The following statement contains a magic number: _recursionAvailable = ((flags2 & 128) != 0);  
Magic Number,agsXMPP.Net.Dns,Response,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\Dns\Response.cs,Response,The following statement contains a magic number: _truncated = ((flags1 & 2) != 0);  
Magic Number,agsXMPP.Net.Dns,Response,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\Dns\Response.cs,Response,The following statement contains a magic number: _questions = new Question[GetShort (message' 4)];  
Magic Number,agsXMPP.Net.Dns,Response,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\Dns\Response.cs,Response,The following statement contains a magic number: _answers = new Answer[GetShort (message' 6)];  
Magic Number,agsXMPP.Net.Dns,Response,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\Dns\Response.cs,Response,The following statement contains a magic number: _nameServers = new NameServer[GetShort (message' 8)];  
Magic Number,agsXMPP.Net.Dns,Response,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\Dns\Response.cs,Response,The following statement contains a magic number: _additionalRecords = new AdditionalRecord[GetShort (message' 10)];  
Magic Number,agsXMPP.Net.Dns,Response,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\Dns\Response.cs,GetShort,The following statement contains a magic number: return (short)(message [position] << 8 | message [position + 1]);  
Magic Number,agsXMPP.Sasl.DigestMD5,Step1,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\DigestMD5\Step1.cs,Parse,The following statement contains a magic number: try {  	int start = 0;  	int end = 0;  	while (start < message.Length) {  		int equalPos = message.IndexOf ('='' start);  		if (equalPos > 0) {  			// look if the next char is a quote  			if (message.Substring (equalPos + 1' 1) == "\"") {  				// quoted value' find the end now  				end = message.IndexOf ('"'' equalPos + 2);  				ParsePair (message.Substring (start' end - start + 1));  				start = end + 2;  			} else {  				// value is not quoted' ends at the next comma or end of string     				end = message.IndexOf ('''' equalPos + 1);  				if (end == -1)  					end = message.Length;  				ParsePair (message.Substring (start' end - start));  				start = end + 1;  			}  		}  	}  } catch {  	throw new ChallengeParseException ("Unable to parse challenge");  }  
Magic Number,agsXMPP.Sasl.DigestMD5,Step1,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\DigestMD5\Step1.cs,Parse,The following statement contains a magic number: try {  	int start = 0;  	int end = 0;  	while (start < message.Length) {  		int equalPos = message.IndexOf ('='' start);  		if (equalPos > 0) {  			// look if the next char is a quote  			if (message.Substring (equalPos + 1' 1) == "\"") {  				// quoted value' find the end now  				end = message.IndexOf ('"'' equalPos + 2);  				ParsePair (message.Substring (start' end - start + 1));  				start = end + 2;  			} else {  				// value is not quoted' ends at the next comma or end of string     				end = message.IndexOf ('''' equalPos + 1);  				if (end == -1)  					end = message.Length;  				ParsePair (message.Substring (start' end - start));  				start = end + 1;  			}  		}  	}  } catch {  	throw new ChallengeParseException ("Unable to parse challenge");  }  
Magic Number,agsXMPP.Sasl.DigestMD5,Step1,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\DigestMD5\Step1.cs,Parse,The following statement contains a magic number: while (start < message.Length) {  	int equalPos = message.IndexOf ('='' start);  	if (equalPos > 0) {  		// look if the next char is a quote  		if (message.Substring (equalPos + 1' 1) == "\"") {  			// quoted value' find the end now  			end = message.IndexOf ('"'' equalPos + 2);  			ParsePair (message.Substring (start' end - start + 1));  			start = end + 2;  		} else {  			// value is not quoted' ends at the next comma or end of string     			end = message.IndexOf ('''' equalPos + 1);  			if (end == -1)  				end = message.Length;  			ParsePair (message.Substring (start' end - start));  			start = end + 1;  		}  	}  }  
Magic Number,agsXMPP.Sasl.DigestMD5,Step1,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\DigestMD5\Step1.cs,Parse,The following statement contains a magic number: while (start < message.Length) {  	int equalPos = message.IndexOf ('='' start);  	if (equalPos > 0) {  		// look if the next char is a quote  		if (message.Substring (equalPos + 1' 1) == "\"") {  			// quoted value' find the end now  			end = message.IndexOf ('"'' equalPos + 2);  			ParsePair (message.Substring (start' end - start + 1));  			start = end + 2;  		} else {  			// value is not quoted' ends at the next comma or end of string     			end = message.IndexOf ('''' equalPos + 1);  			if (end == -1)  				end = message.Length;  			ParsePair (message.Substring (start' end - start));  			start = end + 1;  		}  	}  }  
Magic Number,agsXMPP.Sasl.DigestMD5,Step1,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\DigestMD5\Step1.cs,Parse,The following statement contains a magic number: if (equalPos > 0) {  	// look if the next char is a quote  	if (message.Substring (equalPos + 1' 1) == "\"") {  		// quoted value' find the end now  		end = message.IndexOf ('"'' equalPos + 2);  		ParsePair (message.Substring (start' end - start + 1));  		start = end + 2;  	} else {  		// value is not quoted' ends at the next comma or end of string     		end = message.IndexOf ('''' equalPos + 1);  		if (end == -1)  			end = message.Length;  		ParsePair (message.Substring (start' end - start));  		start = end + 1;  	}  }  
Magic Number,agsXMPP.Sasl.DigestMD5,Step1,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\DigestMD5\Step1.cs,Parse,The following statement contains a magic number: if (equalPos > 0) {  	// look if the next char is a quote  	if (message.Substring (equalPos + 1' 1) == "\"") {  		// quoted value' find the end now  		end = message.IndexOf ('"'' equalPos + 2);  		ParsePair (message.Substring (start' end - start + 1));  		start = end + 2;  	} else {  		// value is not quoted' ends at the next comma or end of string     		end = message.IndexOf ('''' equalPos + 1);  		if (end == -1)  			end = message.Length;  		ParsePair (message.Substring (start' end - start));  		start = end + 1;  	}  }  
Magic Number,agsXMPP.Sasl.DigestMD5,Step1,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\DigestMD5\Step1.cs,Parse,The following statement contains a magic number: if (message.Substring (equalPos + 1' 1) == "\"") {  	// quoted value' find the end now  	end = message.IndexOf ('"'' equalPos + 2);  	ParsePair (message.Substring (start' end - start + 1));  	start = end + 2;  } else {  	// value is not quoted' ends at the next comma or end of string     	end = message.IndexOf ('''' equalPos + 1);  	if (end == -1)  		end = message.Length;  	ParsePair (message.Substring (start' end - start));  	start = end + 1;  }  
Magic Number,agsXMPP.Sasl.DigestMD5,Step1,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\DigestMD5\Step1.cs,Parse,The following statement contains a magic number: if (message.Substring (equalPos + 1' 1) == "\"") {  	// quoted value' find the end now  	end = message.IndexOf ('"'' equalPos + 2);  	ParsePair (message.Substring (start' end - start + 1));  	start = end + 2;  } else {  	// value is not quoted' ends at the next comma or end of string     	end = message.IndexOf ('''' equalPos + 1);  	if (end == -1)  		end = message.Length;  	ParsePair (message.Substring (start' end - start));  	start = end + 1;  }  
Magic Number,agsXMPP.Sasl.DigestMD5,Step1,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\DigestMD5\Step1.cs,Parse,The following statement contains a magic number: end = message.IndexOf ('"'' equalPos + 2);  
Magic Number,agsXMPP.Sasl.DigestMD5,Step1,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\DigestMD5\Step1.cs,Parse,The following statement contains a magic number: start = end + 2;  
Magic Number,agsXMPP.Sasl.DigestMD5,Step1,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\DigestMD5\Step1.cs,ParsePair,The following statement contains a magic number: if (equalPos > 0) {  	string key = pair.Substring (0' equalPos);  	string data;  	// is the value quoted?  	if (pair.Substring (equalPos + 1' 1) == "\"")  		data = pair.Substring (equalPos + 2' pair.Length - equalPos - 3);  	else  		data = pair.Substring (equalPos + 1);  	switch (key) {  	case "realm":  		m_Realm = data;  		break;  	case "nonce":  		m_Nonce = data;  		break;  	case "qop":  		m_Qop = data;  		break;  	case "charset":  		m_Charset = data;  		break;  	case "algorithm":  		m_Algorithm = data;  		break;  	case "rspauth":  		m_Rspauth = data;  		break;  	}  }  
Magic Number,agsXMPP.Sasl.DigestMD5,Step1,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\DigestMD5\Step1.cs,ParsePair,The following statement contains a magic number: if (equalPos > 0) {  	string key = pair.Substring (0' equalPos);  	string data;  	// is the value quoted?  	if (pair.Substring (equalPos + 1' 1) == "\"")  		data = pair.Substring (equalPos + 2' pair.Length - equalPos - 3);  	else  		data = pair.Substring (equalPos + 1);  	switch (key) {  	case "realm":  		m_Realm = data;  		break;  	case "nonce":  		m_Nonce = data;  		break;  	case "qop":  		m_Qop = data;  		break;  	case "charset":  		m_Charset = data;  		break;  	case "algorithm":  		m_Algorithm = data;  		break;  	case "rspauth":  		m_Rspauth = data;  		break;  	}  }  
Magic Number,agsXMPP.Sasl.DigestMD5,Step1,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\DigestMD5\Step1.cs,ParsePair,The following statement contains a magic number: if (pair.Substring (equalPos + 1' 1) == "\"")  	data = pair.Substring (equalPos + 2' pair.Length - equalPos - 3);  else  	data = pair.Substring (equalPos + 1);  
Magic Number,agsXMPP.Sasl.DigestMD5,Step1,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\DigestMD5\Step1.cs,ParsePair,The following statement contains a magic number: if (pair.Substring (equalPos + 1' 1) == "\"")  	data = pair.Substring (equalPos + 2' pair.Length - equalPos - 3);  else  	data = pair.Substring (equalPos + 1);  
Magic Number,agsXMPP.Sasl.DigestMD5,Step1,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\DigestMD5\Step1.cs,ParsePair,The following statement contains a magic number: data = pair.Substring (equalPos + 2' pair.Length - equalPos - 3);  
Magic Number,agsXMPP.Sasl.DigestMD5,Step1,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\DigestMD5\Step1.cs,ParsePair,The following statement contains a magic number: data = pair.Substring (equalPos + 2' pair.Length - equalPos - 3);  
Magic Number,agsXMPP.Sasl.DigestMD5,Step2,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\DigestMD5\Step2.cs,GenerateNc,The following statement contains a magic number: m_Nc = nc.ToString ().PadLeft (8' '0');  
Magic Number,agsXMPP.Sasl.Scram,ScramSha1Mechanism,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\Scram\ScramSha1Mechanism.cs,Hi,The following statement contains a magic number: return pdb.GetBytes (20);  
Magic Number,agsXMPP.Sasl.XGoogleToken,XGoogleTokenMechanism,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\XGoogleToken\XGoogleTokenMechanism.cs,ParseClientAuthResponse,The following statement contains a magic number: while ((line = reader.ReadLine ()) != null) {  	if (line.StartsWith ("SID="))  		_Sid = line.Substring (4);  	else if (line.StartsWith ("LSID="))  		_Lsid = line.Substring (5);  	else if (line.StartsWith ("Auth="))  		_Auth = line.Substring (5);  }  
Magic Number,agsXMPP.Sasl.XGoogleToken,XGoogleTokenMechanism,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\XGoogleToken\XGoogleTokenMechanism.cs,ParseClientAuthResponse,The following statement contains a magic number: while ((line = reader.ReadLine ()) != null) {  	if (line.StartsWith ("SID="))  		_Sid = line.Substring (4);  	else if (line.StartsWith ("LSID="))  		_Lsid = line.Substring (5);  	else if (line.StartsWith ("Auth="))  		_Auth = line.Substring (5);  }  
Magic Number,agsXMPP.Sasl.XGoogleToken,XGoogleTokenMechanism,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\XGoogleToken\XGoogleTokenMechanism.cs,ParseClientAuthResponse,The following statement contains a magic number: while ((line = reader.ReadLine ()) != null) {  	if (line.StartsWith ("SID="))  		_Sid = line.Substring (4);  	else if (line.StartsWith ("LSID="))  		_Lsid = line.Substring (5);  	else if (line.StartsWith ("Auth="))  		_Auth = line.Substring (5);  }  
Magic Number,agsXMPP.Sasl.XGoogleToken,XGoogleTokenMechanism,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\XGoogleToken\XGoogleTokenMechanism.cs,ParseClientAuthResponse,The following statement contains a magic number: if (line.StartsWith ("SID="))  	_Sid = line.Substring (4);  else if (line.StartsWith ("LSID="))  	_Lsid = line.Substring (5);  else if (line.StartsWith ("Auth="))  	_Auth = line.Substring (5);  
Magic Number,agsXMPP.Sasl.XGoogleToken,XGoogleTokenMechanism,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\XGoogleToken\XGoogleTokenMechanism.cs,ParseClientAuthResponse,The following statement contains a magic number: if (line.StartsWith ("SID="))  	_Sid = line.Substring (4);  else if (line.StartsWith ("LSID="))  	_Lsid = line.Substring (5);  else if (line.StartsWith ("Auth="))  	_Auth = line.Substring (5);  
Magic Number,agsXMPP.Sasl.XGoogleToken,XGoogleTokenMechanism,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\XGoogleToken\XGoogleTokenMechanism.cs,ParseClientAuthResponse,The following statement contains a magic number: if (line.StartsWith ("SID="))  	_Sid = line.Substring (4);  else if (line.StartsWith ("LSID="))  	_Lsid = line.Substring (5);  else if (line.StartsWith ("Auth="))  	_Auth = line.Substring (5);  
Magic Number,agsXMPP.Sasl.XGoogleToken,XGoogleTokenMechanism,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\XGoogleToken\XGoogleTokenMechanism.cs,ParseClientAuthResponse,The following statement contains a magic number: _Sid = line.Substring (4);  
Magic Number,agsXMPP.Sasl.XGoogleToken,XGoogleTokenMechanism,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\XGoogleToken\XGoogleTokenMechanism.cs,ParseClientAuthResponse,The following statement contains a magic number: if (line.StartsWith ("LSID="))  	_Lsid = line.Substring (5);  else if (line.StartsWith ("Auth="))  	_Auth = line.Substring (5);  
Magic Number,agsXMPP.Sasl.XGoogleToken,XGoogleTokenMechanism,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\XGoogleToken\XGoogleTokenMechanism.cs,ParseClientAuthResponse,The following statement contains a magic number: if (line.StartsWith ("LSID="))  	_Lsid = line.Substring (5);  else if (line.StartsWith ("Auth="))  	_Auth = line.Substring (5);  
Magic Number,agsXMPP.Sasl.XGoogleToken,XGoogleTokenMechanism,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\XGoogleToken\XGoogleTokenMechanism.cs,ParseClientAuthResponse,The following statement contains a magic number: _Lsid = line.Substring (5);  
Magic Number,agsXMPP.Sasl.XGoogleToken,XGoogleTokenMechanism,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\XGoogleToken\XGoogleTokenMechanism.cs,ParseClientAuthResponse,The following statement contains a magic number: if (line.StartsWith ("Auth="))  	_Auth = line.Substring (5);  
Magic Number,agsXMPP.Sasl.XGoogleToken,XGoogleTokenMechanism,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\XGoogleToken\XGoogleTokenMechanism.cs,ParseClientAuthResponse,The following statement contains a magic number: _Auth = line.Substring (5);  
Magic Number,agsXMPP.Util,Time,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Util\Date.cs,Date,The following statement contains a magic number: try {  	DateTime dt = new DateTime (int.Parse (date.Substring (0' 4))' int.Parse (date.Substring (4' 2))' int.Parse (date.Substring (6' 2))' int.Parse (date.Substring (9' 2))' int.Parse (date.Substring (12' 2))' int.Parse (date.Substring (15' 2)));  	return dt.ToLocalTime ();  } catch {  	return DateTime.MinValue;  }  
Magic Number,agsXMPP.Util,Time,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Util\Date.cs,Date,The following statement contains a magic number: try {  	DateTime dt = new DateTime (int.Parse (date.Substring (0' 4))' int.Parse (date.Substring (4' 2))' int.Parse (date.Substring (6' 2))' int.Parse (date.Substring (9' 2))' int.Parse (date.Substring (12' 2))' int.Parse (date.Substring (15' 2)));  	return dt.ToLocalTime ();  } catch {  	return DateTime.MinValue;  }  
Magic Number,agsXMPP.Util,Time,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Util\Date.cs,Date,The following statement contains a magic number: try {  	DateTime dt = new DateTime (int.Parse (date.Substring (0' 4))' int.Parse (date.Substring (4' 2))' int.Parse (date.Substring (6' 2))' int.Parse (date.Substring (9' 2))' int.Parse (date.Substring (12' 2))' int.Parse (date.Substring (15' 2)));  	return dt.ToLocalTime ();  } catch {  	return DateTime.MinValue;  }  
Magic Number,agsXMPP.Util,Time,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Util\Date.cs,Date,The following statement contains a magic number: try {  	DateTime dt = new DateTime (int.Parse (date.Substring (0' 4))' int.Parse (date.Substring (4' 2))' int.Parse (date.Substring (6' 2))' int.Parse (date.Substring (9' 2))' int.Parse (date.Substring (12' 2))' int.Parse (date.Substring (15' 2)));  	return dt.ToLocalTime ();  } catch {  	return DateTime.MinValue;  }  
Magic Number,agsXMPP.Util,Time,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Util\Date.cs,Date,The following statement contains a magic number: try {  	DateTime dt = new DateTime (int.Parse (date.Substring (0' 4))' int.Parse (date.Substring (4' 2))' int.Parse (date.Substring (6' 2))' int.Parse (date.Substring (9' 2))' int.Parse (date.Substring (12' 2))' int.Parse (date.Substring (15' 2)));  	return dt.ToLocalTime ();  } catch {  	return DateTime.MinValue;  }  
Magic Number,agsXMPP.Util,Time,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Util\Date.cs,Date,The following statement contains a magic number: try {  	DateTime dt = new DateTime (int.Parse (date.Substring (0' 4))' int.Parse (date.Substring (4' 2))' int.Parse (date.Substring (6' 2))' int.Parse (date.Substring (9' 2))' int.Parse (date.Substring (12' 2))' int.Parse (date.Substring (15' 2)));  	return dt.ToLocalTime ();  } catch {  	return DateTime.MinValue;  }  
Magic Number,agsXMPP.Util,Time,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Util\Date.cs,Date,The following statement contains a magic number: try {  	DateTime dt = new DateTime (int.Parse (date.Substring (0' 4))' int.Parse (date.Substring (4' 2))' int.Parse (date.Substring (6' 2))' int.Parse (date.Substring (9' 2))' int.Parse (date.Substring (12' 2))' int.Parse (date.Substring (15' 2)));  	return dt.ToLocalTime ();  } catch {  	return DateTime.MinValue;  }  
Magic Number,agsXMPP.Util,Time,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Util\Date.cs,Date,The following statement contains a magic number: try {  	DateTime dt = new DateTime (int.Parse (date.Substring (0' 4))' int.Parse (date.Substring (4' 2))' int.Parse (date.Substring (6' 2))' int.Parse (date.Substring (9' 2))' int.Parse (date.Substring (12' 2))' int.Parse (date.Substring (15' 2)));  	return dt.ToLocalTime ();  } catch {  	return DateTime.MinValue;  }  
Magic Number,agsXMPP.Util,Time,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Util\Date.cs,Date,The following statement contains a magic number: try {  	DateTime dt = new DateTime (int.Parse (date.Substring (0' 4))' int.Parse (date.Substring (4' 2))' int.Parse (date.Substring (6' 2))' int.Parse (date.Substring (9' 2))' int.Parse (date.Substring (12' 2))' int.Parse (date.Substring (15' 2)));  	return dt.ToLocalTime ();  } catch {  	return DateTime.MinValue;  }  
Magic Number,agsXMPP.Util,Time,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Util\Date.cs,Date,The following statement contains a magic number: try {  	DateTime dt = new DateTime (int.Parse (date.Substring (0' 4))' int.Parse (date.Substring (4' 2))' int.Parse (date.Substring (6' 2))' int.Parse (date.Substring (9' 2))' int.Parse (date.Substring (12' 2))' int.Parse (date.Substring (15' 2)));  	return dt.ToLocalTime ();  } catch {  	return DateTime.MinValue;  }  
Magic Number,agsXMPP.Util,Time,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Util\Date.cs,Date,The following statement contains a magic number: try {  	DateTime dt = new DateTime (int.Parse (date.Substring (0' 4))' int.Parse (date.Substring (4' 2))' int.Parse (date.Substring (6' 2))' int.Parse (date.Substring (9' 2))' int.Parse (date.Substring (12' 2))' int.Parse (date.Substring (15' 2)));  	return dt.ToLocalTime ();  } catch {  	return DateTime.MinValue;  }  
Magic Number,agsXMPP.Util,Runtime,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Util\Runtime.cs,IsUnix,The following statement contains a magic number: if ((p == 4) || (p == 6) || (p == 128))  	return true;  
Magic Number,agsXMPP.Util,Runtime,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Util\Runtime.cs,IsUnix,The following statement contains a magic number: if ((p == 4) || (p == 6) || (p == 128))  	return true;  
Magic Number,agsXMPP.Util,Runtime,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Util\Runtime.cs,IsUnix,The following statement contains a magic number: if ((p == 4) || (p == 6) || (p == 128))  	return true;  
Magic Number,agsXMPP.Xml.Dom,Node,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Dom\Node.cs,ToString,The following statement contains a magic number: using (var tw = new StringWriterWithEncoding (enc)) {  	//System.IO.StringWriter tw = new StringWriter();  	using (var w = new XmlTextWriter (tw)) {  		// Format the Output. So its human readable in notepad  		// Without that everyting is in one line  		w.Formatting = Formatting.Indented;  		w.Indentation = 3;  		WriteTree (this' w' null);  		return tw.ToString ();  	}  }  
Magic Number,agsXMPP.Xml.Dom,Node,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Dom\Node.cs,ToString,The following statement contains a magic number: using (var w = new XmlTextWriter (tw)) {  	// Format the Output. So its human readable in notepad  	// Without that everyting is in one line  	w.Formatting = Formatting.Indented;  	w.Indentation = 3;  	WriteTree (this' w' null);  	return tw.ToString ();  }  
Magic Number,agsXMPP.Xml.Dom,Node,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Dom\Node.cs,ToString,The following statement contains a magic number: w.Indentation = 3;  
Magic Number,agsXMPP.Xml.Dom,Node,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Dom\Node.cs,ToString,The following statement contains a magic number: return BuildXml (this' format' 3' ' ');  
Magic Number,agsXMPP.Xml,StreamParser,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\StreamParser.cs,Push,The following statement contains a magic number: try {  	while (off < b.Length) {  		if (m_cdata)  			tok = m_enc.tokenizeCdataSection (b' off' b.Length' ct);  		else  			tok = m_enc.tokenizeContent (b' off' b.Length' ct);  		switch (tok) {  		case TOK.EMPTY_ELEMENT_NO_ATTS:  		case TOK.EMPTY_ELEMENT_WITH_ATTS:  			StartTag (b' off' ct' tok);  			EndTag (b' off' ct' tok);  			break;  		case TOK.START_TAG_NO_ATTS:  		case TOK.START_TAG_WITH_ATTS:  			StartTag (b' off' ct' tok);  			break;  		case TOK.END_TAG:  			EndTag (b' off' ct' tok);  			break;  		case TOK.DATA_CHARS:  		case TOK.DATA_NEWLINE:  			AddText (utf.GetString (b' off' ct.TokenEnd - off));  			break;  		case TOK.CHAR_REF:  		case TOK.MAGIC_ENTITY_REF:  			AddText (new string (new char[] {  				ct.RefChar1  			}));  			break;  		case TOK.CHAR_PAIR_REF:  			AddText (new string (new char[] {  				ct.RefChar1'  				ct.RefChar2  			}));  			break;  		case TOK.COMMENT:  			if (current != null) {  				// <!-- 4  				//  --> 3  				int start = off + 4 * m_enc.MinBytesPerChar;  				int end = ct.TokenEnd - off - 7 * m_enc.MinBytesPerChar;  				string text = utf.GetString (b' start' end);  				current.AddChild (new Comment (text));  			}  			break;  		case TOK.CDATA_SECT_OPEN:  			m_cdata = true;  			break;  		case TOK.CDATA_SECT_CLOSE:  			m_cdata = false;  			break;  		case TOK.XML_DECL:  			// thou shalt use UTF8' and XML version 1.  			// i shall ignore evidence to the contrary...  			// TODO: Throw an exception if these assuptions are  			// wrong  			break;  		case TOK.ENTITY_REF:  		case TOK.PI:  			#if CF  								    throw new util.NotImplementedException("Token type not implemented: " + tok); #else  			throw new System.NotImplementedException ("Token type not implemented: " + tok);  		#endif  		}  		off = ct.TokenEnd;  	}  } catch (PartialTokenException) {  	// ignored;  } catch (ExtensibleTokenException) {  	// ignored;  } catch (Exception ex) {  	if (OnStreamError != null)  		OnStreamError (this' ex);  } finally {  	m_buf.Clear (off);  }  
Magic Number,agsXMPP.Xml,StreamParser,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\StreamParser.cs,Push,The following statement contains a magic number: try {  	while (off < b.Length) {  		if (m_cdata)  			tok = m_enc.tokenizeCdataSection (b' off' b.Length' ct);  		else  			tok = m_enc.tokenizeContent (b' off' b.Length' ct);  		switch (tok) {  		case TOK.EMPTY_ELEMENT_NO_ATTS:  		case TOK.EMPTY_ELEMENT_WITH_ATTS:  			StartTag (b' off' ct' tok);  			EndTag (b' off' ct' tok);  			break;  		case TOK.START_TAG_NO_ATTS:  		case TOK.START_TAG_WITH_ATTS:  			StartTag (b' off' ct' tok);  			break;  		case TOK.END_TAG:  			EndTag (b' off' ct' tok);  			break;  		case TOK.DATA_CHARS:  		case TOK.DATA_NEWLINE:  			AddText (utf.GetString (b' off' ct.TokenEnd - off));  			break;  		case TOK.CHAR_REF:  		case TOK.MAGIC_ENTITY_REF:  			AddText (new string (new char[] {  				ct.RefChar1  			}));  			break;  		case TOK.CHAR_PAIR_REF:  			AddText (new string (new char[] {  				ct.RefChar1'  				ct.RefChar2  			}));  			break;  		case TOK.COMMENT:  			if (current != null) {  				// <!-- 4  				//  --> 3  				int start = off + 4 * m_enc.MinBytesPerChar;  				int end = ct.TokenEnd - off - 7 * m_enc.MinBytesPerChar;  				string text = utf.GetString (b' start' end);  				current.AddChild (new Comment (text));  			}  			break;  		case TOK.CDATA_SECT_OPEN:  			m_cdata = true;  			break;  		case TOK.CDATA_SECT_CLOSE:  			m_cdata = false;  			break;  		case TOK.XML_DECL:  			// thou shalt use UTF8' and XML version 1.  			// i shall ignore evidence to the contrary...  			// TODO: Throw an exception if these assuptions are  			// wrong  			break;  		case TOK.ENTITY_REF:  		case TOK.PI:  			#if CF  								    throw new util.NotImplementedException("Token type not implemented: " + tok); #else  			throw new System.NotImplementedException ("Token type not implemented: " + tok);  		#endif  		}  		off = ct.TokenEnd;  	}  } catch (PartialTokenException) {  	// ignored;  } catch (ExtensibleTokenException) {  	// ignored;  } catch (Exception ex) {  	if (OnStreamError != null)  		OnStreamError (this' ex);  } finally {  	m_buf.Clear (off);  }  
Magic Number,agsXMPP.Xml,StreamParser,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\StreamParser.cs,Push,The following statement contains a magic number: while (off < b.Length) {  	if (m_cdata)  		tok = m_enc.tokenizeCdataSection (b' off' b.Length' ct);  	else  		tok = m_enc.tokenizeContent (b' off' b.Length' ct);  	switch (tok) {  	case TOK.EMPTY_ELEMENT_NO_ATTS:  	case TOK.EMPTY_ELEMENT_WITH_ATTS:  		StartTag (b' off' ct' tok);  		EndTag (b' off' ct' tok);  		break;  	case TOK.START_TAG_NO_ATTS:  	case TOK.START_TAG_WITH_ATTS:  		StartTag (b' off' ct' tok);  		break;  	case TOK.END_TAG:  		EndTag (b' off' ct' tok);  		break;  	case TOK.DATA_CHARS:  	case TOK.DATA_NEWLINE:  		AddText (utf.GetString (b' off' ct.TokenEnd - off));  		break;  	case TOK.CHAR_REF:  	case TOK.MAGIC_ENTITY_REF:  		AddText (new string (new char[] {  			ct.RefChar1  		}));  		break;  	case TOK.CHAR_PAIR_REF:  		AddText (new string (new char[] {  			ct.RefChar1'  			ct.RefChar2  		}));  		break;  	case TOK.COMMENT:  		if (current != null) {  			// <!-- 4  			//  --> 3  			int start = off + 4 * m_enc.MinBytesPerChar;  			int end = ct.TokenEnd - off - 7 * m_enc.MinBytesPerChar;  			string text = utf.GetString (b' start' end);  			current.AddChild (new Comment (text));  		}  		break;  	case TOK.CDATA_SECT_OPEN:  		m_cdata = true;  		break;  	case TOK.CDATA_SECT_CLOSE:  		m_cdata = false;  		break;  	case TOK.XML_DECL:  		// thou shalt use UTF8' and XML version 1.  		// i shall ignore evidence to the contrary...  		// TODO: Throw an exception if these assuptions are  		// wrong  		break;  	case TOK.ENTITY_REF:  	case TOK.PI:  		#if CF  							    throw new util.NotImplementedException("Token type not implemented: " + tok); #else  		throw new System.NotImplementedException ("Token type not implemented: " + tok);  	#endif  	}  	off = ct.TokenEnd;  }  
Magic Number,agsXMPP.Xml,StreamParser,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\StreamParser.cs,Push,The following statement contains a magic number: while (off < b.Length) {  	if (m_cdata)  		tok = m_enc.tokenizeCdataSection (b' off' b.Length' ct);  	else  		tok = m_enc.tokenizeContent (b' off' b.Length' ct);  	switch (tok) {  	case TOK.EMPTY_ELEMENT_NO_ATTS:  	case TOK.EMPTY_ELEMENT_WITH_ATTS:  		StartTag (b' off' ct' tok);  		EndTag (b' off' ct' tok);  		break;  	case TOK.START_TAG_NO_ATTS:  	case TOK.START_TAG_WITH_ATTS:  		StartTag (b' off' ct' tok);  		break;  	case TOK.END_TAG:  		EndTag (b' off' ct' tok);  		break;  	case TOK.DATA_CHARS:  	case TOK.DATA_NEWLINE:  		AddText (utf.GetString (b' off' ct.TokenEnd - off));  		break;  	case TOK.CHAR_REF:  	case TOK.MAGIC_ENTITY_REF:  		AddText (new string (new char[] {  			ct.RefChar1  		}));  		break;  	case TOK.CHAR_PAIR_REF:  		AddText (new string (new char[] {  			ct.RefChar1'  			ct.RefChar2  		}));  		break;  	case TOK.COMMENT:  		if (current != null) {  			// <!-- 4  			//  --> 3  			int start = off + 4 * m_enc.MinBytesPerChar;  			int end = ct.TokenEnd - off - 7 * m_enc.MinBytesPerChar;  			string text = utf.GetString (b' start' end);  			current.AddChild (new Comment (text));  		}  		break;  	case TOK.CDATA_SECT_OPEN:  		m_cdata = true;  		break;  	case TOK.CDATA_SECT_CLOSE:  		m_cdata = false;  		break;  	case TOK.XML_DECL:  		// thou shalt use UTF8' and XML version 1.  		// i shall ignore evidence to the contrary...  		// TODO: Throw an exception if these assuptions are  		// wrong  		break;  	case TOK.ENTITY_REF:  	case TOK.PI:  		#if CF  							    throw new util.NotImplementedException("Token type not implemented: " + tok); #else  		throw new System.NotImplementedException ("Token type not implemented: " + tok);  	#endif  	}  	off = ct.TokenEnd;  }  
Magic Number,agsXMPP.Xml,StreamParser,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\StreamParser.cs,Push,The following statement contains a magic number: switch (tok) {  case TOK.EMPTY_ELEMENT_NO_ATTS:  case TOK.EMPTY_ELEMENT_WITH_ATTS:  	StartTag (b' off' ct' tok);  	EndTag (b' off' ct' tok);  	break;  case TOK.START_TAG_NO_ATTS:  case TOK.START_TAG_WITH_ATTS:  	StartTag (b' off' ct' tok);  	break;  case TOK.END_TAG:  	EndTag (b' off' ct' tok);  	break;  case TOK.DATA_CHARS:  case TOK.DATA_NEWLINE:  	AddText (utf.GetString (b' off' ct.TokenEnd - off));  	break;  case TOK.CHAR_REF:  case TOK.MAGIC_ENTITY_REF:  	AddText (new string (new char[] {  		ct.RefChar1  	}));  	break;  case TOK.CHAR_PAIR_REF:  	AddText (new string (new char[] {  		ct.RefChar1'  		ct.RefChar2  	}));  	break;  case TOK.COMMENT:  	if (current != null) {  		// <!-- 4  		//  --> 3  		int start = off + 4 * m_enc.MinBytesPerChar;  		int end = ct.TokenEnd - off - 7 * m_enc.MinBytesPerChar;  		string text = utf.GetString (b' start' end);  		current.AddChild (new Comment (text));  	}  	break;  case TOK.CDATA_SECT_OPEN:  	m_cdata = true;  	break;  case TOK.CDATA_SECT_CLOSE:  	m_cdata = false;  	break;  case TOK.XML_DECL:  	// thou shalt use UTF8' and XML version 1.  	// i shall ignore evidence to the contrary...  	// TODO: Throw an exception if these assuptions are  	// wrong  	break;  case TOK.ENTITY_REF:  case TOK.PI:  	#if CF  						    throw new util.NotImplementedException("Token type not implemented: " + tok); #else  	throw new System.NotImplementedException ("Token type not implemented: " + tok);  #endif  }  
Magic Number,agsXMPP.Xml,StreamParser,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\StreamParser.cs,Push,The following statement contains a magic number: switch (tok) {  case TOK.EMPTY_ELEMENT_NO_ATTS:  case TOK.EMPTY_ELEMENT_WITH_ATTS:  	StartTag (b' off' ct' tok);  	EndTag (b' off' ct' tok);  	break;  case TOK.START_TAG_NO_ATTS:  case TOK.START_TAG_WITH_ATTS:  	StartTag (b' off' ct' tok);  	break;  case TOK.END_TAG:  	EndTag (b' off' ct' tok);  	break;  case TOK.DATA_CHARS:  case TOK.DATA_NEWLINE:  	AddText (utf.GetString (b' off' ct.TokenEnd - off));  	break;  case TOK.CHAR_REF:  case TOK.MAGIC_ENTITY_REF:  	AddText (new string (new char[] {  		ct.RefChar1  	}));  	break;  case TOK.CHAR_PAIR_REF:  	AddText (new string (new char[] {  		ct.RefChar1'  		ct.RefChar2  	}));  	break;  case TOK.COMMENT:  	if (current != null) {  		// <!-- 4  		//  --> 3  		int start = off + 4 * m_enc.MinBytesPerChar;  		int end = ct.TokenEnd - off - 7 * m_enc.MinBytesPerChar;  		string text = utf.GetString (b' start' end);  		current.AddChild (new Comment (text));  	}  	break;  case TOK.CDATA_SECT_OPEN:  	m_cdata = true;  	break;  case TOK.CDATA_SECT_CLOSE:  	m_cdata = false;  	break;  case TOK.XML_DECL:  	// thou shalt use UTF8' and XML version 1.  	// i shall ignore evidence to the contrary...  	// TODO: Throw an exception if these assuptions are  	// wrong  	break;  case TOK.ENTITY_REF:  case TOK.PI:  	#if CF  						    throw new util.NotImplementedException("Token type not implemented: " + tok); #else  	throw new System.NotImplementedException ("Token type not implemented: " + tok);  #endif  }  
Magic Number,agsXMPP.Xml,StreamParser,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\StreamParser.cs,Push,The following statement contains a magic number: if (current != null) {  	// <!-- 4  	//  --> 3  	int start = off + 4 * m_enc.MinBytesPerChar;  	int end = ct.TokenEnd - off - 7 * m_enc.MinBytesPerChar;  	string text = utf.GetString (b' start' end);  	current.AddChild (new Comment (text));  }  
Magic Number,agsXMPP.Xml,StreamParser,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\StreamParser.cs,Push,The following statement contains a magic number: if (current != null) {  	// <!-- 4  	//  --> 3  	int start = off + 4 * m_enc.MinBytesPerChar;  	int end = ct.TokenEnd - off - 7 * m_enc.MinBytesPerChar;  	string text = utf.GetString (b' start' end);  	current.AddChild (new Comment (text));  }  
Magic Number,agsXMPP.Xml,StreamParser,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\StreamParser.cs,EndTag,The following statement contains a magic number: if ((tok == TOK.EMPTY_ELEMENT_WITH_ATTS) || (tok == TOK.EMPTY_ELEMENT_NO_ATTS))  	name = utf.GetString (buf' offset + m_enc.MinBytesPerChar' ct.NameEnd - offset - m_enc.MinBytesPerChar);  else  	name = utf.GetString (buf' offset + m_enc.MinBytesPerChar * 2' ct.NameEnd - offset - m_enc.MinBytesPerChar * 2);  
Magic Number,agsXMPP.Xml,StreamParser,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\StreamParser.cs,EndTag,The following statement contains a magic number: if ((tok == TOK.EMPTY_ELEMENT_WITH_ATTS) || (tok == TOK.EMPTY_ELEMENT_NO_ATTS))  	name = utf.GetString (buf' offset + m_enc.MinBytesPerChar' ct.NameEnd - offset - m_enc.MinBytesPerChar);  else  	name = utf.GetString (buf' offset + m_enc.MinBytesPerChar * 2' ct.NameEnd - offset - m_enc.MinBytesPerChar * 2);  
Magic Number,agsXMPP.Xml,StreamParser,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\StreamParser.cs,EndTag,The following statement contains a magic number: name = utf.GetString (buf' offset + m_enc.MinBytesPerChar * 2' ct.NameEnd - offset - m_enc.MinBytesPerChar * 2);  
Magic Number,agsXMPP.Xml,StreamParser,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\StreamParser.cs,EndTag,The following statement contains a magic number: name = utf.GetString (buf' offset + m_enc.MinBytesPerChar * 2' ct.NameEnd - offset - m_enc.MinBytesPerChar * 2);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanComment,The following statement contains a magic number: if (off != end) {  	checkCharMatches (buf' off' '-');  	off += minBPC;  	while (off != end) {  		switch (byteType (buf' off)) {  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_MINUS:  			if ((off += minBPC) == end)  				throw new PartialTokenException ();  			if (charMatches (buf' off' '-')) {  				if ((off += minBPC) == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.TokenEnd = off + minBPC;  				return TOK.COMMENT;  			}  			break;  		default:  			off += minBPC;  			break;  		}  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanComment,The following statement contains a magic number: if (off != end) {  	checkCharMatches (buf' off' '-');  	off += minBPC;  	while (off != end) {  		switch (byteType (buf' off)) {  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_MINUS:  			if ((off += minBPC) == end)  				throw new PartialTokenException ();  			if (charMatches (buf' off' '-')) {  				if ((off += minBPC) == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.TokenEnd = off + minBPC;  				return TOK.COMMENT;  			}  			break;  		default:  			off += minBPC;  			break;  		}  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanComment,The following statement contains a magic number: if (off != end) {  	checkCharMatches (buf' off' '-');  	off += minBPC;  	while (off != end) {  		switch (byteType (buf' off)) {  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_MINUS:  			if ((off += minBPC) == end)  				throw new PartialTokenException ();  			if (charMatches (buf' off' '-')) {  				if ((off += minBPC) == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.TokenEnd = off + minBPC;  				return TOK.COMMENT;  			}  			break;  		default:  			off += minBPC;  			break;  		}  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanComment,The following statement contains a magic number: if (off != end) {  	checkCharMatches (buf' off' '-');  	off += minBPC;  	while (off != end) {  		switch (byteType (buf' off)) {  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_MINUS:  			if ((off += minBPC) == end)  				throw new PartialTokenException ();  			if (charMatches (buf' off' '-')) {  				if ((off += minBPC) == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.TokenEnd = off + minBPC;  				return TOK.COMMENT;  			}  			break;  		default:  			off += minBPC;  			break;  		}  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanComment,The following statement contains a magic number: if (off != end) {  	checkCharMatches (buf' off' '-');  	off += minBPC;  	while (off != end) {  		switch (byteType (buf' off)) {  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_MINUS:  			if ((off += minBPC) == end)  				throw new PartialTokenException ();  			if (charMatches (buf' off' '-')) {  				if ((off += minBPC) == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.TokenEnd = off + minBPC;  				return TOK.COMMENT;  			}  			break;  		default:  			off += minBPC;  			break;  		}  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanComment,The following statement contains a magic number: if (off != end) {  	checkCharMatches (buf' off' '-');  	off += minBPC;  	while (off != end) {  		switch (byteType (buf' off)) {  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_MINUS:  			if ((off += minBPC) == end)  				throw new PartialTokenException ();  			if (charMatches (buf' off' '-')) {  				if ((off += minBPC) == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.TokenEnd = off + minBPC;  				return TOK.COMMENT;  			}  			break;  		default:  			off += minBPC;  			break;  		}  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanComment,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_MINUS:  		if ((off += minBPC) == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off' '-')) {  			if ((off += minBPC) == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.TokenEnd = off + minBPC;  			return TOK.COMMENT;  		}  		break;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanComment,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_MINUS:  		if ((off += minBPC) == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off' '-')) {  			if ((off += minBPC) == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.TokenEnd = off + minBPC;  			return TOK.COMMENT;  		}  		break;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanComment,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_MINUS:  		if ((off += minBPC) == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off' '-')) {  			if ((off += minBPC) == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.TokenEnd = off + minBPC;  			return TOK.COMMENT;  		}  		break;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanComment,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_MINUS:  		if ((off += minBPC) == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off' '-')) {  			if ((off += minBPC) == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.TokenEnd = off + minBPC;  			return TOK.COMMENT;  		}  		break;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanComment,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_MINUS:  		if ((off += minBPC) == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off' '-')) {  			if ((off += minBPC) == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.TokenEnd = off + minBPC;  			return TOK.COMMENT;  		}  		break;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanComment,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_MINUS:  		if ((off += minBPC) == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off' '-')) {  			if ((off += minBPC) == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.TokenEnd = off + minBPC;  			return TOK.COMMENT;  		}  		break;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanComment,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_MINUS:  	if ((off += minBPC) == end)  		throw new PartialTokenException ();  	if (charMatches (buf' off' '-')) {  		if ((off += minBPC) == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return TOK.COMMENT;  	}  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanComment,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_MINUS:  	if ((off += minBPC) == end)  		throw new PartialTokenException ();  	if (charMatches (buf' off' '-')) {  		if ((off += minBPC) == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return TOK.COMMENT;  	}  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanComment,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_MINUS:  	if ((off += minBPC) == end)  		throw new PartialTokenException ();  	if (charMatches (buf' off' '-')) {  		if ((off += minBPC) == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return TOK.COMMENT;  	}  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanComment,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_MINUS:  	if ((off += minBPC) == end)  		throw new PartialTokenException ();  	if (charMatches (buf' off' '-')) {  		if ((off += minBPC) == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return TOK.COMMENT;  	}  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanComment,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_MINUS:  	if ((off += minBPC) == end)  		throw new PartialTokenException ();  	if (charMatches (buf' off' '-')) {  		if ((off += minBPC) == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return TOK.COMMENT;  	}  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanComment,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_MINUS:  	if ((off += minBPC) == end)  		throw new PartialTokenException ();  	if (charMatches (buf' off' '-')) {  		if ((off += minBPC) == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return TOK.COMMENT;  	}  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanComment,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanComment,The following statement contains a magic number: off += 2;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanComment,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanComment,The following statement contains a magic number: off += 3;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanComment,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanComment,The following statement contains a magic number: off += 4;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,targetIsXml,The following statement contains a magic number: if (end - off != minBPC * 3)  	return false;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: off += 2;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: off += 3;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: off += 4;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		bool isXml = targetIsXml (buf' target' off);  		token.NameEnd = off;  		off += minBPC;  		while (off != end) {  			switch (byteType (buf' off)) {  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_QUEST:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				if (charMatches (buf' off' '>')) {  					token.TokenEnd = off + minBPC;  					if (isXml)  						return TOK.XML_DECL;  					else  						return TOK.PI;  				}  				break;  			default:  				off += minBPC;  				break;  			}  		}  		throw new PartialTokenException ();  	case BT_QUEST:  		token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		bool isXml = targetIsXml (buf' target' off);  		token.NameEnd = off;  		off += minBPC;  		while (off != end) {  			switch (byteType (buf' off)) {  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_QUEST:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				if (charMatches (buf' off' '>')) {  					token.TokenEnd = off + minBPC;  					if (isXml)  						return TOK.XML_DECL;  					else  						return TOK.PI;  				}  				break;  			default:  				off += minBPC;  				break;  			}  		}  		throw new PartialTokenException ();  	case BT_QUEST:  		token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		bool isXml = targetIsXml (buf' target' off);  		token.NameEnd = off;  		off += minBPC;  		while (off != end) {  			switch (byteType (buf' off)) {  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_QUEST:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				if (charMatches (buf' off' '>')) {  					token.TokenEnd = off + minBPC;  					if (isXml)  						return TOK.XML_DECL;  					else  						return TOK.PI;  				}  				break;  			default:  				off += minBPC;  				break;  			}  		}  		throw new PartialTokenException ();  	case BT_QUEST:  		token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		bool isXml = targetIsXml (buf' target' off);  		token.NameEnd = off;  		off += minBPC;  		while (off != end) {  			switch (byteType (buf' off)) {  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_QUEST:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				if (charMatches (buf' off' '>')) {  					token.TokenEnd = off + minBPC;  					if (isXml)  						return TOK.XML_DECL;  					else  						return TOK.PI;  				}  				break;  			default:  				off += minBPC;  				break;  			}  		}  		throw new PartialTokenException ();  	case BT_QUEST:  		token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		bool isXml = targetIsXml (buf' target' off);  		token.NameEnd = off;  		off += minBPC;  		while (off != end) {  			switch (byteType (buf' off)) {  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_QUEST:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				if (charMatches (buf' off' '>')) {  					token.TokenEnd = off + minBPC;  					if (isXml)  						return TOK.XML_DECL;  					else  						return TOK.PI;  				}  				break;  			default:  				off += minBPC;  				break;  			}  		}  		throw new PartialTokenException ();  	case BT_QUEST:  		token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		bool isXml = targetIsXml (buf' target' off);  		token.NameEnd = off;  		off += minBPC;  		while (off != end) {  			switch (byteType (buf' off)) {  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_QUEST:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				if (charMatches (buf' off' '>')) {  					token.TokenEnd = off + minBPC;  					if (isXml)  						return TOK.XML_DECL;  					else  						return TOK.PI;  				}  				break;  			default:  				off += minBPC;  				break;  			}  		}  		throw new PartialTokenException ();  	case BT_QUEST:  		token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		bool isXml = targetIsXml (buf' target' off);  		token.NameEnd = off;  		off += minBPC;  		while (off != end) {  			switch (byteType (buf' off)) {  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_QUEST:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				if (charMatches (buf' off' '>')) {  					token.TokenEnd = off + minBPC;  					if (isXml)  						return TOK.XML_DECL;  					else  						return TOK.PI;  				}  				break;  			default:  				off += minBPC;  				break;  			}  		}  		throw new PartialTokenException ();  	case BT_QUEST:  		token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		bool isXml = targetIsXml (buf' target' off);  		token.NameEnd = off;  		off += minBPC;  		while (off != end) {  			switch (byteType (buf' off)) {  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_QUEST:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				if (charMatches (buf' off' '>')) {  					token.TokenEnd = off + minBPC;  					if (isXml)  						return TOK.XML_DECL;  					else  						return TOK.PI;  				}  				break;  			default:  				off += minBPC;  				break;  			}  		}  		throw new PartialTokenException ();  	case BT_QUEST:  		token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		bool isXml = targetIsXml (buf' target' off);  		token.NameEnd = off;  		off += minBPC;  		while (off != end) {  			switch (byteType (buf' off)) {  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_QUEST:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				if (charMatches (buf' off' '>')) {  					token.TokenEnd = off + minBPC;  					if (isXml)  						return TOK.XML_DECL;  					else  						return TOK.PI;  				}  				break;  			default:  				off += minBPC;  				break;  			}  		}  		throw new PartialTokenException ();  	case BT_QUEST:  		token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		bool isXml = targetIsXml (buf' target' off);  		token.NameEnd = off;  		off += minBPC;  		while (off != end) {  			switch (byteType (buf' off)) {  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_QUEST:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				if (charMatches (buf' off' '>')) {  					token.TokenEnd = off + minBPC;  					if (isXml)  						return TOK.XML_DECL;  					else  						return TOK.PI;  				}  				break;  			default:  				off += minBPC;  				break;  			}  		}  		throw new PartialTokenException ();  	case BT_QUEST:  		token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		bool isXml = targetIsXml (buf' target' off);  		token.NameEnd = off;  		off += minBPC;  		while (off != end) {  			switch (byteType (buf' off)) {  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_QUEST:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				if (charMatches (buf' off' '>')) {  					token.TokenEnd = off + minBPC;  					if (isXml)  						return TOK.XML_DECL;  					else  						return TOK.PI;  				}  				break;  			default:  				off += minBPC;  				break;  			}  		}  		throw new PartialTokenException ();  	case BT_QUEST:  		token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		bool isXml = targetIsXml (buf' target' off);  		token.NameEnd = off;  		off += minBPC;  		while (off != end) {  			switch (byteType (buf' off)) {  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_QUEST:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				if (charMatches (buf' off' '>')) {  					token.TokenEnd = off + minBPC;  					if (isXml)  						return TOK.XML_DECL;  					else  						return TOK.PI;  				}  				break;  			default:  				off += minBPC;  				break;  			}  		}  		throw new PartialTokenException ();  	case BT_QUEST:  		token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	bool isXml = targetIsXml (buf' target' off);  	token.NameEnd = off;  	off += minBPC;  	while (off != end) {  		switch (byteType (buf' off)) {  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_QUEST:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			if (charMatches (buf' off' '>')) {  				token.TokenEnd = off + minBPC;  				if (isXml)  					return TOK.XML_DECL;  				else  					return TOK.PI;  			}  			break;  		default:  			off += minBPC;  			break;  		}  	}  	throw new PartialTokenException ();  case BT_QUEST:  	token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	bool isXml = targetIsXml (buf' target' off);  	token.NameEnd = off;  	off += minBPC;  	while (off != end) {  		switch (byteType (buf' off)) {  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_QUEST:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			if (charMatches (buf' off' '>')) {  				token.TokenEnd = off + minBPC;  				if (isXml)  					return TOK.XML_DECL;  				else  					return TOK.PI;  			}  			break;  		default:  			off += minBPC;  			break;  		}  	}  	throw new PartialTokenException ();  case BT_QUEST:  	token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	bool isXml = targetIsXml (buf' target' off);  	token.NameEnd = off;  	off += minBPC;  	while (off != end) {  		switch (byteType (buf' off)) {  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_QUEST:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			if (charMatches (buf' off' '>')) {  				token.TokenEnd = off + minBPC;  				if (isXml)  					return TOK.XML_DECL;  				else  					return TOK.PI;  			}  			break;  		default:  			off += minBPC;  			break;  		}  	}  	throw new PartialTokenException ();  case BT_QUEST:  	token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	bool isXml = targetIsXml (buf' target' off);  	token.NameEnd = off;  	off += minBPC;  	while (off != end) {  		switch (byteType (buf' off)) {  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_QUEST:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			if (charMatches (buf' off' '>')) {  				token.TokenEnd = off + minBPC;  				if (isXml)  					return TOK.XML_DECL;  				else  					return TOK.PI;  			}  			break;  		default:  			off += minBPC;  			break;  		}  	}  	throw new PartialTokenException ();  case BT_QUEST:  	token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	bool isXml = targetIsXml (buf' target' off);  	token.NameEnd = off;  	off += minBPC;  	while (off != end) {  		switch (byteType (buf' off)) {  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_QUEST:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			if (charMatches (buf' off' '>')) {  				token.TokenEnd = off + minBPC;  				if (isXml)  					return TOK.XML_DECL;  				else  					return TOK.PI;  			}  			break;  		default:  			off += minBPC;  			break;  		}  	}  	throw new PartialTokenException ();  case BT_QUEST:  	token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	bool isXml = targetIsXml (buf' target' off);  	token.NameEnd = off;  	off += minBPC;  	while (off != end) {  		switch (byteType (buf' off)) {  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_QUEST:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			if (charMatches (buf' off' '>')) {  				token.TokenEnd = off + minBPC;  				if (isXml)  					return TOK.XML_DECL;  				else  					return TOK.PI;  			}  			break;  		default:  			off += minBPC;  			break;  		}  	}  	throw new PartialTokenException ();  case BT_QUEST:  	token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	bool isXml = targetIsXml (buf' target' off);  	token.NameEnd = off;  	off += minBPC;  	while (off != end) {  		switch (byteType (buf' off)) {  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_QUEST:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			if (charMatches (buf' off' '>')) {  				token.TokenEnd = off + minBPC;  				if (isXml)  					return TOK.XML_DECL;  				else  					return TOK.PI;  			}  			break;  		default:  			off += minBPC;  			break;  		}  	}  	throw new PartialTokenException ();  case BT_QUEST:  	token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	bool isXml = targetIsXml (buf' target' off);  	token.NameEnd = off;  	off += minBPC;  	while (off != end) {  		switch (byteType (buf' off)) {  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_QUEST:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			if (charMatches (buf' off' '>')) {  				token.TokenEnd = off + minBPC;  				if (isXml)  					return TOK.XML_DECL;  				else  					return TOK.PI;  			}  			break;  		default:  			off += minBPC;  			break;  		}  	}  	throw new PartialTokenException ();  case BT_QUEST:  	token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	bool isXml = targetIsXml (buf' target' off);  	token.NameEnd = off;  	off += minBPC;  	while (off != end) {  		switch (byteType (buf' off)) {  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_QUEST:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			if (charMatches (buf' off' '>')) {  				token.TokenEnd = off + minBPC;  				if (isXml)  					return TOK.XML_DECL;  				else  					return TOK.PI;  			}  			break;  		default:  			off += minBPC;  			break;  		}  	}  	throw new PartialTokenException ();  case BT_QUEST:  	token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	bool isXml = targetIsXml (buf' target' off);  	token.NameEnd = off;  	off += minBPC;  	while (off != end) {  		switch (byteType (buf' off)) {  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_QUEST:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			if (charMatches (buf' off' '>')) {  				token.TokenEnd = off + minBPC;  				if (isXml)  					return TOK.XML_DECL;  				else  					return TOK.PI;  			}  			break;  		default:  			off += minBPC;  			break;  		}  	}  	throw new PartialTokenException ();  case BT_QUEST:  	token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	bool isXml = targetIsXml (buf' target' off);  	token.NameEnd = off;  	off += minBPC;  	while (off != end) {  		switch (byteType (buf' off)) {  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_QUEST:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			if (charMatches (buf' off' '>')) {  				token.TokenEnd = off + minBPC;  				if (isXml)  					return TOK.XML_DECL;  				else  					return TOK.PI;  			}  			break;  		default:  			off += minBPC;  			break;  		}  	}  	throw new PartialTokenException ();  case BT_QUEST:  	token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	bool isXml = targetIsXml (buf' target' off);  	token.NameEnd = off;  	off += minBPC;  	while (off != end) {  		switch (byteType (buf' off)) {  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_QUEST:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			if (charMatches (buf' off' '>')) {  				token.TokenEnd = off + minBPC;  				if (isXml)  					return TOK.XML_DECL;  				else  					return TOK.PI;  			}  			break;  		default:  			off += minBPC;  			break;  		}  	}  	throw new PartialTokenException ();  case BT_QUEST:  	token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return (targetIsXml (buf' target' token.NameEnd) ? TOK.XML_DECL : TOK.PI);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: off += 2;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: off += 3;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: off += 4;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_QUEST:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off' '>')) {  			token.TokenEnd = off + minBPC;  			if (isXml)  				return TOK.XML_DECL;  			else  				return TOK.PI;  		}  		break;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_QUEST:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off' '>')) {  			token.TokenEnd = off + minBPC;  			if (isXml)  				return TOK.XML_DECL;  			else  				return TOK.PI;  		}  		break;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_QUEST:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off' '>')) {  			token.TokenEnd = off + minBPC;  			if (isXml)  				return TOK.XML_DECL;  			else  				return TOK.PI;  		}  		break;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_QUEST:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off' '>')) {  			token.TokenEnd = off + minBPC;  			if (isXml)  				return TOK.XML_DECL;  			else  				return TOK.PI;  		}  		break;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_QUEST:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off' '>')) {  			token.TokenEnd = off + minBPC;  			if (isXml)  				return TOK.XML_DECL;  			else  				return TOK.PI;  		}  		break;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_QUEST:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off' '>')) {  			token.TokenEnd = off + minBPC;  			if (isXml)  				return TOK.XML_DECL;  			else  				return TOK.PI;  		}  		break;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_QUEST:  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	if (charMatches (buf' off' '>')) {  		token.TokenEnd = off + minBPC;  		if (isXml)  			return TOK.XML_DECL;  		else  			return TOK.PI;  	}  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_QUEST:  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	if (charMatches (buf' off' '>')) {  		token.TokenEnd = off + minBPC;  		if (isXml)  			return TOK.XML_DECL;  		else  			return TOK.PI;  	}  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_QUEST:  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	if (charMatches (buf' off' '>')) {  		token.TokenEnd = off + minBPC;  		if (isXml)  			return TOK.XML_DECL;  		else  			return TOK.PI;  	}  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_QUEST:  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	if (charMatches (buf' off' '>')) {  		token.TokenEnd = off + minBPC;  		if (isXml)  			return TOK.XML_DECL;  		else  			return TOK.PI;  	}  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_QUEST:  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	if (charMatches (buf' off' '>')) {  		token.TokenEnd = off + minBPC;  		if (isXml)  			return TOK.XML_DECL;  		else  			return TOK.PI;  	}  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_QUEST:  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	if (charMatches (buf' off' '>')) {  		token.TokenEnd = off + minBPC;  		if (isXml)  			return TOK.XML_DECL;  		else  			return TOK.PI;  	}  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: off += 2;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: off += 3;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPi,The following statement contains a magic number: off += 4;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanCdataSection,The following statement contains a magic number: if (end - off < 6 * minBPC)  	throw new PartialTokenException ();  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeCdataSection,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	if (!charMatches (buf' off' ']'))  		break;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	if (!charMatches (buf' off' '>')) {  		off -= minBPC;  		break;  	}  	token.TokenEnd = off + minBPC;  	return TOK.CDATA_SECT_CLOSE;  case BT_CR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  	if (byteType (buf' off) == BT_LF)  		off += minBPC;  	token.TokenEnd = off;  	return TOK.DATA_NEWLINE;  case BT_LF:  	token.TokenEnd = off + minBPC;  	return TOK.DATA_NEWLINE;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeCdataSection,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	if (!charMatches (buf' off' ']'))  		break;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	if (!charMatches (buf' off' '>')) {  		off -= minBPC;  		break;  	}  	token.TokenEnd = off + minBPC;  	return TOK.CDATA_SECT_CLOSE;  case BT_CR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  	if (byteType (buf' off) == BT_LF)  		off += minBPC;  	token.TokenEnd = off;  	return TOK.DATA_NEWLINE;  case BT_LF:  	token.TokenEnd = off + minBPC;  	return TOK.DATA_NEWLINE;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeCdataSection,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	if (!charMatches (buf' off' ']'))  		break;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	if (!charMatches (buf' off' '>')) {  		off -= minBPC;  		break;  	}  	token.TokenEnd = off + minBPC;  	return TOK.CDATA_SECT_CLOSE;  case BT_CR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  	if (byteType (buf' off) == BT_LF)  		off += minBPC;  	token.TokenEnd = off;  	return TOK.DATA_NEWLINE;  case BT_LF:  	token.TokenEnd = off + minBPC;  	return TOK.DATA_NEWLINE;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeCdataSection,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	if (!charMatches (buf' off' ']'))  		break;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	if (!charMatches (buf' off' '>')) {  		off -= minBPC;  		break;  	}  	token.TokenEnd = off + minBPC;  	return TOK.CDATA_SECT_CLOSE;  case BT_CR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  	if (byteType (buf' off) == BT_LF)  		off += minBPC;  	token.TokenEnd = off;  	return TOK.DATA_NEWLINE;  case BT_LF:  	token.TokenEnd = off + minBPC;  	return TOK.DATA_NEWLINE;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeCdataSection,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	if (!charMatches (buf' off' ']'))  		break;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	if (!charMatches (buf' off' '>')) {  		off -= minBPC;  		break;  	}  	token.TokenEnd = off + minBPC;  	return TOK.CDATA_SECT_CLOSE;  case BT_CR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  	if (byteType (buf' off) == BT_LF)  		off += minBPC;  	token.TokenEnd = off;  	return TOK.DATA_NEWLINE;  case BT_LF:  	token.TokenEnd = off + minBPC;  	return TOK.DATA_NEWLINE;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeCdataSection,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	if (!charMatches (buf' off' ']'))  		break;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	if (!charMatches (buf' off' '>')) {  		off -= minBPC;  		break;  	}  	token.TokenEnd = off + minBPC;  	return TOK.CDATA_SECT_CLOSE;  case BT_CR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  	if (byteType (buf' off) == BT_LF)  		off += minBPC;  	token.TokenEnd = off;  	return TOK.DATA_NEWLINE;  case BT_LF:  	token.TokenEnd = off + minBPC;  	return TOK.DATA_NEWLINE;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeCdataSection,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeCdataSection,The following statement contains a magic number: off += 2;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeCdataSection,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeCdataSection,The following statement contains a magic number: off += 3;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeCdataSection,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeCdataSection,The following statement contains a magic number: off += 4;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,extendCdata,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			return off;  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			return off;  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			return off;  		check4 (buf' off);  		off += 4;  		break;  	case BT_RSQB:  	case BT_NONXML:  	case BT_MALFORM:  	case BT_CR:  	case BT_LF:  		return off;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,extendCdata,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			return off;  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			return off;  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			return off;  		check4 (buf' off);  		off += 4;  		break;  	case BT_RSQB:  	case BT_NONXML:  	case BT_MALFORM:  	case BT_CR:  	case BT_LF:  		return off;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,extendCdata,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			return off;  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			return off;  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			return off;  		check4 (buf' off);  		off += 4;  		break;  	case BT_RSQB:  	case BT_NONXML:  	case BT_MALFORM:  	case BT_CR:  	case BT_LF:  		return off;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,extendCdata,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			return off;  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			return off;  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			return off;  		check4 (buf' off);  		off += 4;  		break;  	case BT_RSQB:  	case BT_NONXML:  	case BT_MALFORM:  	case BT_CR:  	case BT_LF:  		return off;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,extendCdata,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			return off;  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			return off;  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			return off;  		check4 (buf' off);  		off += 4;  		break;  	case BT_RSQB:  	case BT_NONXML:  	case BT_MALFORM:  	case BT_CR:  	case BT_LF:  		return off;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,extendCdata,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			return off;  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			return off;  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			return off;  		check4 (buf' off);  		off += 4;  		break;  	case BT_RSQB:  	case BT_NONXML:  	case BT_MALFORM:  	case BT_CR:  	case BT_LF:  		return off;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,extendCdata,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		return off;  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		return off;  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		return off;  	check4 (buf' off);  	off += 4;  	break;  case BT_RSQB:  case BT_NONXML:  case BT_MALFORM:  case BT_CR:  case BT_LF:  	return off;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,extendCdata,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		return off;  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		return off;  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		return off;  	check4 (buf' off);  	off += 4;  	break;  case BT_RSQB:  case BT_NONXML:  case BT_MALFORM:  case BT_CR:  case BT_LF:  	return off;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,extendCdata,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		return off;  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		return off;  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		return off;  	check4 (buf' off);  	off += 4;  	break;  case BT_RSQB:  case BT_NONXML:  case BT_MALFORM:  case BT_CR:  case BT_LF:  	return off;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,extendCdata,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		return off;  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		return off;  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		return off;  	check4 (buf' off);  	off += 4;  	break;  case BT_RSQB:  case BT_NONXML:  case BT_MALFORM:  case BT_CR:  case BT_LF:  	return off;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,extendCdata,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		return off;  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		return off;  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		return off;  	check4 (buf' off);  	off += 4;  	break;  case BT_RSQB:  case BT_NONXML:  case BT_MALFORM:  case BT_CR:  case BT_LF:  	return off;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,extendCdata,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		return off;  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		return off;  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		return off;  	check4 (buf' off);  	off += 4;  	break;  case BT_RSQB:  case BT_NONXML:  case BT_MALFORM:  case BT_CR:  case BT_LF:  	return off;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,extendCdata,The following statement contains a magic number: if (end - off < 2)  	return off;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,extendCdata,The following statement contains a magic number: off += 2;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,extendCdata,The following statement contains a magic number: if (end - off < 3)  	return off;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,extendCdata,The following statement contains a magic number: off += 3;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,extendCdata,The following statement contains a magic number: if (end - off < 4)  	return off;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,extendCdata,The following statement contains a magic number: off += 4;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: off += 2;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: off += 3;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: off += 4;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.NameEnd = off;  		for (off += minBPC; off != end; off += minBPC) {  			switch (byteType (buf' off)) {  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.TokenEnd = off + minBPC;  				return TOK.END_TAG;  			default:  				throw new InvalidTokenException (off);  			}  		}  		throw new PartialTokenException ();  	case BT_GT:  		token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.END_TAG;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.NameEnd = off;  		for (off += minBPC; off != end; off += minBPC) {  			switch (byteType (buf' off)) {  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.TokenEnd = off + minBPC;  				return TOK.END_TAG;  			default:  				throw new InvalidTokenException (off);  			}  		}  		throw new PartialTokenException ();  	case BT_GT:  		token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.END_TAG;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.NameEnd = off;  		for (off += minBPC; off != end; off += minBPC) {  			switch (byteType (buf' off)) {  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.TokenEnd = off + minBPC;  				return TOK.END_TAG;  			default:  				throw new InvalidTokenException (off);  			}  		}  		throw new PartialTokenException ();  	case BT_GT:  		token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.END_TAG;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.NameEnd = off;  		for (off += minBPC; off != end; off += minBPC) {  			switch (byteType (buf' off)) {  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.TokenEnd = off + minBPC;  				return TOK.END_TAG;  			default:  				throw new InvalidTokenException (off);  			}  		}  		throw new PartialTokenException ();  	case BT_GT:  		token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.END_TAG;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.NameEnd = off;  		for (off += minBPC; off != end; off += minBPC) {  			switch (byteType (buf' off)) {  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.TokenEnd = off + minBPC;  				return TOK.END_TAG;  			default:  				throw new InvalidTokenException (off);  			}  		}  		throw new PartialTokenException ();  	case BT_GT:  		token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.END_TAG;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.NameEnd = off;  		for (off += minBPC; off != end; off += minBPC) {  			switch (byteType (buf' off)) {  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.TokenEnd = off + minBPC;  				return TOK.END_TAG;  			default:  				throw new InvalidTokenException (off);  			}  		}  		throw new PartialTokenException ();  	case BT_GT:  		token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.END_TAG;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	token.NameEnd = off;  	for (off += minBPC; off != end; off += minBPC) {  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.TokenEnd = off + minBPC;  			return TOK.END_TAG;  		default:  			throw new InvalidTokenException (off);  		}  	}  	throw new PartialTokenException ();  case BT_GT:  	token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.END_TAG;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	token.NameEnd = off;  	for (off += minBPC; off != end; off += minBPC) {  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.TokenEnd = off + minBPC;  			return TOK.END_TAG;  		default:  			throw new InvalidTokenException (off);  		}  	}  	throw new PartialTokenException ();  case BT_GT:  	token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.END_TAG;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	token.NameEnd = off;  	for (off += minBPC; off != end; off += minBPC) {  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.TokenEnd = off + minBPC;  			return TOK.END_TAG;  		default:  			throw new InvalidTokenException (off);  		}  	}  	throw new PartialTokenException ();  case BT_GT:  	token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.END_TAG;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	token.NameEnd = off;  	for (off += minBPC; off != end; off += minBPC) {  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.TokenEnd = off + minBPC;  			return TOK.END_TAG;  		default:  			throw new InvalidTokenException (off);  		}  	}  	throw new PartialTokenException ();  case BT_GT:  	token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.END_TAG;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	token.NameEnd = off;  	for (off += minBPC; off != end; off += minBPC) {  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.TokenEnd = off + minBPC;  			return TOK.END_TAG;  		default:  			throw new InvalidTokenException (off);  		}  	}  	throw new PartialTokenException ();  case BT_GT:  	token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.END_TAG;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	token.NameEnd = off;  	for (off += minBPC; off != end; off += minBPC) {  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.TokenEnd = off + minBPC;  			return TOK.END_TAG;  		default:  			throw new InvalidTokenException (off);  		}  	}  	throw new PartialTokenException ();  case BT_GT:  	token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.END_TAG;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: off += 2;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: off += 3;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanEndTag,The following statement contains a magic number: off += 4;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: if (off != end) {  	int c = byteToAscii (buf' off);  	int num;  	switch (c) {  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		num = c - '0';  		break;  	case 'A':  	case 'B':  	case 'C':  	case 'D':  	case 'E':  	case 'F':  		num = c - ('A' - 10);  		break;  	case 'a':  	case 'b':  	case 'c':  	case 'd':  	case 'e':  	case 'f':  		num = c - ('a' - 10);  		break;  	default:  		throw new InvalidTokenException (off);  	}  	for (off += minBPC; off != end; off += minBPC) {  		c = byteToAscii (buf' off);  		switch (c) {  		case '0':  		case '1':  		case '2':  		case '3':  		case '4':  		case '5':  		case '6':  		case '7':  		case '8':  		case '9':  			num = (num << 4) + c - '0';  			break;  		case 'A':  		case 'B':  		case 'C':  		case 'D':  		case 'E':  		case 'F':  			num = (num << 4) + c - ('A' - 10);  			break;  		case 'a':  		case 'b':  		case 'c':  		case 'd':  		case 'e':  		case 'f':  			num = (num << 4) + c - ('a' - 10);  			break;  		case ';':  			token.TokenEnd = off + minBPC;  			return setRefChar (num' token);  		default:  			throw new InvalidTokenException (off);  		}  		if (num >= 0x110000)  			throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: if (off != end) {  	int c = byteToAscii (buf' off);  	int num;  	switch (c) {  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		num = c - '0';  		break;  	case 'A':  	case 'B':  	case 'C':  	case 'D':  	case 'E':  	case 'F':  		num = c - ('A' - 10);  		break;  	case 'a':  	case 'b':  	case 'c':  	case 'd':  	case 'e':  	case 'f':  		num = c - ('a' - 10);  		break;  	default:  		throw new InvalidTokenException (off);  	}  	for (off += minBPC; off != end; off += minBPC) {  		c = byteToAscii (buf' off);  		switch (c) {  		case '0':  		case '1':  		case '2':  		case '3':  		case '4':  		case '5':  		case '6':  		case '7':  		case '8':  		case '9':  			num = (num << 4) + c - '0';  			break;  		case 'A':  		case 'B':  		case 'C':  		case 'D':  		case 'E':  		case 'F':  			num = (num << 4) + c - ('A' - 10);  			break;  		case 'a':  		case 'b':  		case 'c':  		case 'd':  		case 'e':  		case 'f':  			num = (num << 4) + c - ('a' - 10);  			break;  		case ';':  			token.TokenEnd = off + minBPC;  			return setRefChar (num' token);  		default:  			throw new InvalidTokenException (off);  		}  		if (num >= 0x110000)  			throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: if (off != end) {  	int c = byteToAscii (buf' off);  	int num;  	switch (c) {  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		num = c - '0';  		break;  	case 'A':  	case 'B':  	case 'C':  	case 'D':  	case 'E':  	case 'F':  		num = c - ('A' - 10);  		break;  	case 'a':  	case 'b':  	case 'c':  	case 'd':  	case 'e':  	case 'f':  		num = c - ('a' - 10);  		break;  	default:  		throw new InvalidTokenException (off);  	}  	for (off += minBPC; off != end; off += minBPC) {  		c = byteToAscii (buf' off);  		switch (c) {  		case '0':  		case '1':  		case '2':  		case '3':  		case '4':  		case '5':  		case '6':  		case '7':  		case '8':  		case '9':  			num = (num << 4) + c - '0';  			break;  		case 'A':  		case 'B':  		case 'C':  		case 'D':  		case 'E':  		case 'F':  			num = (num << 4) + c - ('A' - 10);  			break;  		case 'a':  		case 'b':  		case 'c':  		case 'd':  		case 'e':  		case 'f':  			num = (num << 4) + c - ('a' - 10);  			break;  		case ';':  			token.TokenEnd = off + minBPC;  			return setRefChar (num' token);  		default:  			throw new InvalidTokenException (off);  		}  		if (num >= 0x110000)  			throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: if (off != end) {  	int c = byteToAscii (buf' off);  	int num;  	switch (c) {  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		num = c - '0';  		break;  	case 'A':  	case 'B':  	case 'C':  	case 'D':  	case 'E':  	case 'F':  		num = c - ('A' - 10);  		break;  	case 'a':  	case 'b':  	case 'c':  	case 'd':  	case 'e':  	case 'f':  		num = c - ('a' - 10);  		break;  	default:  		throw new InvalidTokenException (off);  	}  	for (off += minBPC; off != end; off += minBPC) {  		c = byteToAscii (buf' off);  		switch (c) {  		case '0':  		case '1':  		case '2':  		case '3':  		case '4':  		case '5':  		case '6':  		case '7':  		case '8':  		case '9':  			num = (num << 4) + c - '0';  			break;  		case 'A':  		case 'B':  		case 'C':  		case 'D':  		case 'E':  		case 'F':  			num = (num << 4) + c - ('A' - 10);  			break;  		case 'a':  		case 'b':  		case 'c':  		case 'd':  		case 'e':  		case 'f':  			num = (num << 4) + c - ('a' - 10);  			break;  		case ';':  			token.TokenEnd = off + minBPC;  			return setRefChar (num' token);  		default:  			throw new InvalidTokenException (off);  		}  		if (num >= 0x110000)  			throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: if (off != end) {  	int c = byteToAscii (buf' off);  	int num;  	switch (c) {  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		num = c - '0';  		break;  	case 'A':  	case 'B':  	case 'C':  	case 'D':  	case 'E':  	case 'F':  		num = c - ('A' - 10);  		break;  	case 'a':  	case 'b':  	case 'c':  	case 'd':  	case 'e':  	case 'f':  		num = c - ('a' - 10);  		break;  	default:  		throw new InvalidTokenException (off);  	}  	for (off += minBPC; off != end; off += minBPC) {  		c = byteToAscii (buf' off);  		switch (c) {  		case '0':  		case '1':  		case '2':  		case '3':  		case '4':  		case '5':  		case '6':  		case '7':  		case '8':  		case '9':  			num = (num << 4) + c - '0';  			break;  		case 'A':  		case 'B':  		case 'C':  		case 'D':  		case 'E':  		case 'F':  			num = (num << 4) + c - ('A' - 10);  			break;  		case 'a':  		case 'b':  		case 'c':  		case 'd':  		case 'e':  		case 'f':  			num = (num << 4) + c - ('a' - 10);  			break;  		case ';':  			token.TokenEnd = off + minBPC;  			return setRefChar (num' token);  		default:  			throw new InvalidTokenException (off);  		}  		if (num >= 0x110000)  			throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: if (off != end) {  	int c = byteToAscii (buf' off);  	int num;  	switch (c) {  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		num = c - '0';  		break;  	case 'A':  	case 'B':  	case 'C':  	case 'D':  	case 'E':  	case 'F':  		num = c - ('A' - 10);  		break;  	case 'a':  	case 'b':  	case 'c':  	case 'd':  	case 'e':  	case 'f':  		num = c - ('a' - 10);  		break;  	default:  		throw new InvalidTokenException (off);  	}  	for (off += minBPC; off != end; off += minBPC) {  		c = byteToAscii (buf' off);  		switch (c) {  		case '0':  		case '1':  		case '2':  		case '3':  		case '4':  		case '5':  		case '6':  		case '7':  		case '8':  		case '9':  			num = (num << 4) + c - '0';  			break;  		case 'A':  		case 'B':  		case 'C':  		case 'D':  		case 'E':  		case 'F':  			num = (num << 4) + c - ('A' - 10);  			break;  		case 'a':  		case 'b':  		case 'c':  		case 'd':  		case 'e':  		case 'f':  			num = (num << 4) + c - ('a' - 10);  			break;  		case ';':  			token.TokenEnd = off + minBPC;  			return setRefChar (num' token);  		default:  			throw new InvalidTokenException (off);  		}  		if (num >= 0x110000)  			throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: if (off != end) {  	int c = byteToAscii (buf' off);  	int num;  	switch (c) {  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		num = c - '0';  		break;  	case 'A':  	case 'B':  	case 'C':  	case 'D':  	case 'E':  	case 'F':  		num = c - ('A' - 10);  		break;  	case 'a':  	case 'b':  	case 'c':  	case 'd':  	case 'e':  	case 'f':  		num = c - ('a' - 10);  		break;  	default:  		throw new InvalidTokenException (off);  	}  	for (off += minBPC; off != end; off += minBPC) {  		c = byteToAscii (buf' off);  		switch (c) {  		case '0':  		case '1':  		case '2':  		case '3':  		case '4':  		case '5':  		case '6':  		case '7':  		case '8':  		case '9':  			num = (num << 4) + c - '0';  			break;  		case 'A':  		case 'B':  		case 'C':  		case 'D':  		case 'E':  		case 'F':  			num = (num << 4) + c - ('A' - 10);  			break;  		case 'a':  		case 'b':  		case 'c':  		case 'd':  		case 'e':  		case 'f':  			num = (num << 4) + c - ('a' - 10);  			break;  		case ';':  			token.TokenEnd = off + minBPC;  			return setRefChar (num' token);  		default:  			throw new InvalidTokenException (off);  		}  		if (num >= 0x110000)  			throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: switch (c) {  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	num = c - '0';  	break;  case 'A':  case 'B':  case 'C':  case 'D':  case 'E':  case 'F':  	num = c - ('A' - 10);  	break;  case 'a':  case 'b':  case 'c':  case 'd':  case 'e':  case 'f':  	num = c - ('a' - 10);  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: switch (c) {  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	num = c - '0';  	break;  case 'A':  case 'B':  case 'C':  case 'D':  case 'E':  case 'F':  	num = c - ('A' - 10);  	break;  case 'a':  case 'b':  case 'c':  case 'd':  case 'e':  case 'f':  	num = c - ('a' - 10);  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: num = c - ('A' - 10);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: num = c - ('a' - 10);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: for (off += minBPC; off != end; off += minBPC) {  	c = byteToAscii (buf' off);  	switch (c) {  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		num = (num << 4) + c - '0';  		break;  	case 'A':  	case 'B':  	case 'C':  	case 'D':  	case 'E':  	case 'F':  		num = (num << 4) + c - ('A' - 10);  		break;  	case 'a':  	case 'b':  	case 'c':  	case 'd':  	case 'e':  	case 'f':  		num = (num << 4) + c - ('a' - 10);  		break;  	case ';':  		token.TokenEnd = off + minBPC;  		return setRefChar (num' token);  	default:  		throw new InvalidTokenException (off);  	}  	if (num >= 0x110000)  		throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: for (off += minBPC; off != end; off += minBPC) {  	c = byteToAscii (buf' off);  	switch (c) {  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		num = (num << 4) + c - '0';  		break;  	case 'A':  	case 'B':  	case 'C':  	case 'D':  	case 'E':  	case 'F':  		num = (num << 4) + c - ('A' - 10);  		break;  	case 'a':  	case 'b':  	case 'c':  	case 'd':  	case 'e':  	case 'f':  		num = (num << 4) + c - ('a' - 10);  		break;  	case ';':  		token.TokenEnd = off + minBPC;  		return setRefChar (num' token);  	default:  		throw new InvalidTokenException (off);  	}  	if (num >= 0x110000)  		throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: for (off += minBPC; off != end; off += minBPC) {  	c = byteToAscii (buf' off);  	switch (c) {  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		num = (num << 4) + c - '0';  		break;  	case 'A':  	case 'B':  	case 'C':  	case 'D':  	case 'E':  	case 'F':  		num = (num << 4) + c - ('A' - 10);  		break;  	case 'a':  	case 'b':  	case 'c':  	case 'd':  	case 'e':  	case 'f':  		num = (num << 4) + c - ('a' - 10);  		break;  	case ';':  		token.TokenEnd = off + minBPC;  		return setRefChar (num' token);  	default:  		throw new InvalidTokenException (off);  	}  	if (num >= 0x110000)  		throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: for (off += minBPC; off != end; off += minBPC) {  	c = byteToAscii (buf' off);  	switch (c) {  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		num = (num << 4) + c - '0';  		break;  	case 'A':  	case 'B':  	case 'C':  	case 'D':  	case 'E':  	case 'F':  		num = (num << 4) + c - ('A' - 10);  		break;  	case 'a':  	case 'b':  	case 'c':  	case 'd':  	case 'e':  	case 'f':  		num = (num << 4) + c - ('a' - 10);  		break;  	case ';':  		token.TokenEnd = off + minBPC;  		return setRefChar (num' token);  	default:  		throw new InvalidTokenException (off);  	}  	if (num >= 0x110000)  		throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: for (off += minBPC; off != end; off += minBPC) {  	c = byteToAscii (buf' off);  	switch (c) {  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		num = (num << 4) + c - '0';  		break;  	case 'A':  	case 'B':  	case 'C':  	case 'D':  	case 'E':  	case 'F':  		num = (num << 4) + c - ('A' - 10);  		break;  	case 'a':  	case 'b':  	case 'c':  	case 'd':  	case 'e':  	case 'f':  		num = (num << 4) + c - ('a' - 10);  		break;  	case ';':  		token.TokenEnd = off + minBPC;  		return setRefChar (num' token);  	default:  		throw new InvalidTokenException (off);  	}  	if (num >= 0x110000)  		throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: switch (c) {  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	num = (num << 4) + c - '0';  	break;  case 'A':  case 'B':  case 'C':  case 'D':  case 'E':  case 'F':  	num = (num << 4) + c - ('A' - 10);  	break;  case 'a':  case 'b':  case 'c':  case 'd':  case 'e':  case 'f':  	num = (num << 4) + c - ('a' - 10);  	break;  case ';':  	token.TokenEnd = off + minBPC;  	return setRefChar (num' token);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: switch (c) {  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	num = (num << 4) + c - '0';  	break;  case 'A':  case 'B':  case 'C':  case 'D':  case 'E':  case 'F':  	num = (num << 4) + c - ('A' - 10);  	break;  case 'a':  case 'b':  case 'c':  case 'd':  case 'e':  case 'f':  	num = (num << 4) + c - ('a' - 10);  	break;  case ';':  	token.TokenEnd = off + minBPC;  	return setRefChar (num' token);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: switch (c) {  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	num = (num << 4) + c - '0';  	break;  case 'A':  case 'B':  case 'C':  case 'D':  case 'E':  case 'F':  	num = (num << 4) + c - ('A' - 10);  	break;  case 'a':  case 'b':  case 'c':  case 'd':  case 'e':  case 'f':  	num = (num << 4) + c - ('a' - 10);  	break;  case ';':  	token.TokenEnd = off + minBPC;  	return setRefChar (num' token);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: switch (c) {  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	num = (num << 4) + c - '0';  	break;  case 'A':  case 'B':  case 'C':  case 'D':  case 'E':  case 'F':  	num = (num << 4) + c - ('A' - 10);  	break;  case 'a':  case 'b':  case 'c':  case 'd':  case 'e':  case 'f':  	num = (num << 4) + c - ('a' - 10);  	break;  case ';':  	token.TokenEnd = off + minBPC;  	return setRefChar (num' token);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: switch (c) {  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	num = (num << 4) + c - '0';  	break;  case 'A':  case 'B':  case 'C':  case 'D':  case 'E':  case 'F':  	num = (num << 4) + c - ('A' - 10);  	break;  case 'a':  case 'b':  case 'c':  case 'd':  case 'e':  case 'f':  	num = (num << 4) + c - ('a' - 10);  	break;  case ';':  	token.TokenEnd = off + minBPC;  	return setRefChar (num' token);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: num = (num << 4) + c - '0';  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: num = (num << 4) + c - ('A' - 10);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: num = (num << 4) + c - ('A' - 10);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: num = (num << 4) + c - ('a' - 10);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanHexCharRef,The following statement contains a magic number: num = (num << 4) + c - ('a' - 10);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanCharRef,The following statement contains a magic number: if (off != end) {  	int c = byteToAscii (buf' off);  	switch (c) {  	case 'x':  		return scanHexCharRef (buf' off + minBPC' end' token);  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		break;  	default:  		throw new InvalidTokenException (off);  	}  	int num = c - '0';  	for (off += minBPC; off != end; off += minBPC) {  		c = byteToAscii (buf' off);  		switch (c) {  		case '0':  		case '1':  		case '2':  		case '3':  		case '4':  		case '5':  		case '6':  		case '7':  		case '8':  		case '9':  			num = num * 10 + (c - '0');  			if (num < 0x110000)  				break;  			/* fall through */goto default;  		default:  			throw new InvalidTokenException (off);  		case ';':  			token.TokenEnd = off + minBPC;  			return setRefChar (num' token);  		}  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanCharRef,The following statement contains a magic number: for (off += minBPC; off != end; off += minBPC) {  	c = byteToAscii (buf' off);  	switch (c) {  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		num = num * 10 + (c - '0');  		if (num < 0x110000)  			break;  		/* fall through */goto default;  	default:  		throw new InvalidTokenException (off);  	case ';':  		token.TokenEnd = off + minBPC;  		return setRefChar (num' token);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanCharRef,The following statement contains a magic number: switch (c) {  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	num = num * 10 + (c - '0');  	if (num < 0x110000)  		break;  	/* fall through */goto default;  default:  	throw new InvalidTokenException (off);  case ';':  	token.TokenEnd = off + minBPC;  	return setRefChar (num' token);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanCharRef,The following statement contains a magic number: num = num * 10 + (c - '0');  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,setRefChar,The following statement contains a magic number: if (num < 0x10000) {  	switch (charTypeTable [num >> 8] [num & 0xFF]) {  	case BT_NONXML:  	case BT_LEAD4:  	case BT_MALFORM:  		throw new InvalidTokenException (token.TokenEnd - minBPC);  	}  	token.RefChar1 = (char)num;  	return TOK.CHAR_REF;  } else {  	num -= 0x10000;  	token.RefChar1 = (char)((num >> 10) + 0xD800);  	token.RefChar2 = (char)((num & ((1 << 10) - 1)) + 0xDC00);  	return TOK.CHAR_PAIR_REF;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,setRefChar,The following statement contains a magic number: if (num < 0x10000) {  	switch (charTypeTable [num >> 8] [num & 0xFF]) {  	case BT_NONXML:  	case BT_LEAD4:  	case BT_MALFORM:  		throw new InvalidTokenException (token.TokenEnd - minBPC);  	}  	token.RefChar1 = (char)num;  	return TOK.CHAR_REF;  } else {  	num -= 0x10000;  	token.RefChar1 = (char)((num >> 10) + 0xD800);  	token.RefChar2 = (char)((num & ((1 << 10) - 1)) + 0xDC00);  	return TOK.CHAR_PAIR_REF;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,setRefChar,The following statement contains a magic number: if (num < 0x10000) {  	switch (charTypeTable [num >> 8] [num & 0xFF]) {  	case BT_NONXML:  	case BT_LEAD4:  	case BT_MALFORM:  		throw new InvalidTokenException (token.TokenEnd - minBPC);  	}  	token.RefChar1 = (char)num;  	return TOK.CHAR_REF;  } else {  	num -= 0x10000;  	token.RefChar1 = (char)((num >> 10) + 0xD800);  	token.RefChar2 = (char)((num & ((1 << 10) - 1)) + 0xDC00);  	return TOK.CHAR_PAIR_REF;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,setRefChar,The following statement contains a magic number: switch (charTypeTable [num >> 8] [num & 0xFF]) {  case BT_NONXML:  case BT_LEAD4:  case BT_MALFORM:  	throw new InvalidTokenException (token.TokenEnd - minBPC);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,setRefChar,The following statement contains a magic number: token.RefChar1 = (char)((num >> 10) + 0xD800);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,setRefChar,The following statement contains a magic number: token.RefChar2 = (char)((num & ((1 << 10) - 1)) + 0xDC00);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (end - off < minBPC * 4)  	break;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off + minBPC)) {  case 'm':  	if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  		token.TokenEnd = off + minBPC * 4;  		token.RefChar1 = '&';  		return true;  	}  	break;  case 'p':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '\'';  		return true;  	}  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off + minBPC)) {  case 'm':  	if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  		token.TokenEnd = off + minBPC * 4;  		token.RefChar1 = '&';  		return true;  	}  	break;  case 'p':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '\'';  		return true;  	}  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off + minBPC)) {  case 'm':  	if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  		token.TokenEnd = off + minBPC * 4;  		token.RefChar1 = '&';  		return true;  	}  	break;  case 'p':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '\'';  		return true;  	}  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off + minBPC)) {  case 'm':  	if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  		token.TokenEnd = off + minBPC * 4;  		token.RefChar1 = '&';  		return true;  	}  	break;  case 'p':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '\'';  		return true;  	}  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off + minBPC)) {  case 'm':  	if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  		token.TokenEnd = off + minBPC * 4;  		token.RefChar1 = '&';  		return true;  	}  	break;  case 'p':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '\'';  		return true;  	}  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off + minBPC)) {  case 'm':  	if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  		token.TokenEnd = off + minBPC * 4;  		token.RefChar1 = '&';  		return true;  	}  	break;  case 'p':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '\'';  		return true;  	}  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off + minBPC)) {  case 'm':  	if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  		token.TokenEnd = off + minBPC * 4;  		token.RefChar1 = '&';  		return true;  	}  	break;  case 'p':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '\'';  		return true;  	}  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: switch (byteToAscii (buf' off + minBPC)) {  case 'm':  	if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  		token.TokenEnd = off + minBPC * 4;  		token.RefChar1 = '&';  		return true;  	}  	break;  case 'p':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '\'';  		return true;  	}  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  	token.TokenEnd = off + minBPC * 4;  	token.RefChar1 = '&';  	return true;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  	token.TokenEnd = off + minBPC * 4;  	token.RefChar1 = '&';  	return true;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  	token.TokenEnd = off + minBPC * 4;  	token.RefChar1 = '&';  	return true;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: token.TokenEnd = off + minBPC * 4;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  	token.TokenEnd = off + minBPC * 5;  	token.RefChar1 = '\'';  	return true;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  	token.TokenEnd = off + minBPC * 5;  	token.RefChar1 = '\'';  	return true;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  	token.TokenEnd = off + minBPC * 5;  	token.RefChar1 = '\'';  	return true;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  	token.TokenEnd = off + minBPC * 5;  	token.RefChar1 = '\'';  	return true;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  	token.TokenEnd = off + minBPC * 5;  	token.RefChar1 = '\'';  	return true;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: token.TokenEnd = off + minBPC * 5;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  	token.TokenEnd = off + minBPC * 3;  	token.RefChar1 = '<';  	return true;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  	token.TokenEnd = off + minBPC * 3;  	token.RefChar1 = '<';  	return true;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  	token.TokenEnd = off + minBPC * 3;  	token.RefChar1 = '<';  	return true;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: token.TokenEnd = off + minBPC * 3;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  	token.TokenEnd = off + minBPC * 3;  	token.RefChar1 = '>';  	return true;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  	token.TokenEnd = off + minBPC * 3;  	token.RefChar1 = '>';  	return true;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  	token.TokenEnd = off + minBPC * 3;  	token.RefChar1 = '>';  	return true;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: token.TokenEnd = off + minBPC * 3;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  	token.TokenEnd = off + minBPC * 5;  	token.RefChar1 = '"';  	return true;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  	token.TokenEnd = off + minBPC * 5;  	token.RefChar1 = '"';  	return true;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  	token.TokenEnd = off + minBPC * 5;  	token.RefChar1 = '"';  	return true;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  	token.TokenEnd = off + minBPC * 5;  	token.RefChar1 = '"';  	return true;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  	token.TokenEnd = off + minBPC * 5;  	token.RefChar1 = '"';  	return true;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following statement contains a magic number: token.TokenEnd = off + minBPC * 5;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_NUM:  	return scanCharRef (buf' off + minBPC' end' token);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_NUM:  	return scanCharRef (buf' off + minBPC' end' token);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_NUM:  	return scanCharRef (buf' off + minBPC' end' token);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_NUM:  	return scanCharRef (buf' off + minBPC' end' token);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_NUM:  	return scanCharRef (buf' off + minBPC' end' token);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_NUM:  	return scanCharRef (buf' off + minBPC' end' token);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanRef,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanRef,The following statement contains a magic number: off += 2;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanRef,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanRef,The following statement contains a magic number: off += 3;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanRef,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanRef,The following statement contains a magic number: off += 4;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanRef,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_SEMI:  		token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.ENTITY_REF;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanRef,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_SEMI:  		token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.ENTITY_REF;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanRef,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_SEMI:  		token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.ENTITY_REF;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanRef,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_SEMI:  		token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.ENTITY_REF;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanRef,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_SEMI:  		token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.ENTITY_REF;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanRef,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_SEMI:  		token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.ENTITY_REF;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_SEMI:  	token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.ENTITY_REF;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_SEMI:  	token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.ENTITY_REF;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_SEMI:  	token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.ENTITY_REF;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_SEMI:  	token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.ENTITY_REF;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_SEMI:  	token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.ENTITY_REF;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanRef,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_SEMI:  	token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.ENTITY_REF;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanRef,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanRef,The following statement contains a magic number: off += 2;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanRef,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanRef,The following statement contains a magic number: off += 3;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanRef,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanRef,The following statement contains a magic number: off += 4;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		NameEnd = off;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_EQUALS:  				goto loop;  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		;  		/* fall through */goto case BT_EQUALS;  	case BT_EQUALS: {  		if (NameEnd < 0)  			NameEnd = off;  		int open;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			open = byteType (buf' off);  			if (open == BT_QUOT || open == BT_APOS)  				break;  			switch (open) {  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		off += minBPC;  		int valueStart = off;  		bool normalized = true;  		int t;  		/* in attribute value */for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			if (t == open)  				break;  			switch (t) {  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_AMP: {  				normalized = false;  				int saveNameEnd = token.NameEnd;  				scanRef (buf' off + minBPC' end' token);  				token.NameEnd = saveNameEnd;  				off = token.TokenEnd;  				break;  			}  			case BT_S:  				if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  					normalized = false;  				off += minBPC;  				break;  			case BT_LT:  				throw new InvalidTokenException (off);  			case BT_LF:  			case BT_CR:  				normalized = false;  				/* fall through */goto default;  			default:  				off += minBPC;  				break;  			}  		}  		token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		switch (t) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			break;  		case BT_GT:  		case BT_SOL:  			break;  		default:  			throw new InvalidTokenException (off);  		}  		/* off points to closing quote */for (; ;) {  			switch (t) {  			case BT_NMSTRT:  				nameStart = off;  				off += minBPC;  				goto skipToName;  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 2;  				goto skipToName;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 3;  				goto skipToName;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 4;  				goto skipToName;  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.START_TAG_WITH_ATTS;  			case BT_SOL:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.EMPTY_ELEMENT_WITH_ATTS;  			default:  				throw new InvalidTokenException (off);  			}  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  		}  		skipToName:  		NameEnd = -1;  		break;  	}  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		NameEnd = off;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_EQUALS:  				goto loop;  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		;  		/* fall through */goto case BT_EQUALS;  	case BT_EQUALS: {  		if (NameEnd < 0)  			NameEnd = off;  		int open;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			open = byteType (buf' off);  			if (open == BT_QUOT || open == BT_APOS)  				break;  			switch (open) {  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		off += minBPC;  		int valueStart = off;  		bool normalized = true;  		int t;  		/* in attribute value */for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			if (t == open)  				break;  			switch (t) {  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_AMP: {  				normalized = false;  				int saveNameEnd = token.NameEnd;  				scanRef (buf' off + minBPC' end' token);  				token.NameEnd = saveNameEnd;  				off = token.TokenEnd;  				break;  			}  			case BT_S:  				if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  					normalized = false;  				off += minBPC;  				break;  			case BT_LT:  				throw new InvalidTokenException (off);  			case BT_LF:  			case BT_CR:  				normalized = false;  				/* fall through */goto default;  			default:  				off += minBPC;  				break;  			}  		}  		token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		switch (t) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			break;  		case BT_GT:  		case BT_SOL:  			break;  		default:  			throw new InvalidTokenException (off);  		}  		/* off points to closing quote */for (; ;) {  			switch (t) {  			case BT_NMSTRT:  				nameStart = off;  				off += minBPC;  				goto skipToName;  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 2;  				goto skipToName;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 3;  				goto skipToName;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 4;  				goto skipToName;  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.START_TAG_WITH_ATTS;  			case BT_SOL:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.EMPTY_ELEMENT_WITH_ATTS;  			default:  				throw new InvalidTokenException (off);  			}  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  		}  		skipToName:  		NameEnd = -1;  		break;  	}  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		NameEnd = off;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_EQUALS:  				goto loop;  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		;  		/* fall through */goto case BT_EQUALS;  	case BT_EQUALS: {  		if (NameEnd < 0)  			NameEnd = off;  		int open;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			open = byteType (buf' off);  			if (open == BT_QUOT || open == BT_APOS)  				break;  			switch (open) {  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		off += minBPC;  		int valueStart = off;  		bool normalized = true;  		int t;  		/* in attribute value */for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			if (t == open)  				break;  			switch (t) {  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_AMP: {  				normalized = false;  				int saveNameEnd = token.NameEnd;  				scanRef (buf' off + minBPC' end' token);  				token.NameEnd = saveNameEnd;  				off = token.TokenEnd;  				break;  			}  			case BT_S:  				if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  					normalized = false;  				off += minBPC;  				break;  			case BT_LT:  				throw new InvalidTokenException (off);  			case BT_LF:  			case BT_CR:  				normalized = false;  				/* fall through */goto default;  			default:  				off += minBPC;  				break;  			}  		}  		token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		switch (t) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			break;  		case BT_GT:  		case BT_SOL:  			break;  		default:  			throw new InvalidTokenException (off);  		}  		/* off points to closing quote */for (; ;) {  			switch (t) {  			case BT_NMSTRT:  				nameStart = off;  				off += minBPC;  				goto skipToName;  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 2;  				goto skipToName;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 3;  				goto skipToName;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 4;  				goto skipToName;  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.START_TAG_WITH_ATTS;  			case BT_SOL:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.EMPTY_ELEMENT_WITH_ATTS;  			default:  				throw new InvalidTokenException (off);  			}  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  		}  		skipToName:  		NameEnd = -1;  		break;  	}  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		NameEnd = off;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_EQUALS:  				goto loop;  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		;  		/* fall through */goto case BT_EQUALS;  	case BT_EQUALS: {  		if (NameEnd < 0)  			NameEnd = off;  		int open;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			open = byteType (buf' off);  			if (open == BT_QUOT || open == BT_APOS)  				break;  			switch (open) {  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		off += minBPC;  		int valueStart = off;  		bool normalized = true;  		int t;  		/* in attribute value */for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			if (t == open)  				break;  			switch (t) {  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_AMP: {  				normalized = false;  				int saveNameEnd = token.NameEnd;  				scanRef (buf' off + minBPC' end' token);  				token.NameEnd = saveNameEnd;  				off = token.TokenEnd;  				break;  			}  			case BT_S:  				if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  					normalized = false;  				off += minBPC;  				break;  			case BT_LT:  				throw new InvalidTokenException (off);  			case BT_LF:  			case BT_CR:  				normalized = false;  				/* fall through */goto default;  			default:  				off += minBPC;  				break;  			}  		}  		token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		switch (t) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			break;  		case BT_GT:  		case BT_SOL:  			break;  		default:  			throw new InvalidTokenException (off);  		}  		/* off points to closing quote */for (; ;) {  			switch (t) {  			case BT_NMSTRT:  				nameStart = off;  				off += minBPC;  				goto skipToName;  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 2;  				goto skipToName;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 3;  				goto skipToName;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 4;  				goto skipToName;  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.START_TAG_WITH_ATTS;  			case BT_SOL:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.EMPTY_ELEMENT_WITH_ATTS;  			default:  				throw new InvalidTokenException (off);  			}  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  		}  		skipToName:  		NameEnd = -1;  		break;  	}  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		NameEnd = off;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_EQUALS:  				goto loop;  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		;  		/* fall through */goto case BT_EQUALS;  	case BT_EQUALS: {  		if (NameEnd < 0)  			NameEnd = off;  		int open;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			open = byteType (buf' off);  			if (open == BT_QUOT || open == BT_APOS)  				break;  			switch (open) {  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		off += minBPC;  		int valueStart = off;  		bool normalized = true;  		int t;  		/* in attribute value */for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			if (t == open)  				break;  			switch (t) {  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_AMP: {  				normalized = false;  				int saveNameEnd = token.NameEnd;  				scanRef (buf' off + minBPC' end' token);  				token.NameEnd = saveNameEnd;  				off = token.TokenEnd;  				break;  			}  			case BT_S:  				if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  					normalized = false;  				off += minBPC;  				break;  			case BT_LT:  				throw new InvalidTokenException (off);  			case BT_LF:  			case BT_CR:  				normalized = false;  				/* fall through */goto default;  			default:  				off += minBPC;  				break;  			}  		}  		token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		switch (t) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			break;  		case BT_GT:  		case BT_SOL:  			break;  		default:  			throw new InvalidTokenException (off);  		}  		/* off points to closing quote */for (; ;) {  			switch (t) {  			case BT_NMSTRT:  				nameStart = off;  				off += minBPC;  				goto skipToName;  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 2;  				goto skipToName;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 3;  				goto skipToName;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 4;  				goto skipToName;  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.START_TAG_WITH_ATTS;  			case BT_SOL:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.EMPTY_ELEMENT_WITH_ATTS;  			default:  				throw new InvalidTokenException (off);  			}  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  		}  		skipToName:  		NameEnd = -1;  		break;  	}  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		NameEnd = off;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_EQUALS:  				goto loop;  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		;  		/* fall through */goto case BT_EQUALS;  	case BT_EQUALS: {  		if (NameEnd < 0)  			NameEnd = off;  		int open;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			open = byteType (buf' off);  			if (open == BT_QUOT || open == BT_APOS)  				break;  			switch (open) {  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		off += minBPC;  		int valueStart = off;  		bool normalized = true;  		int t;  		/* in attribute value */for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			if (t == open)  				break;  			switch (t) {  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_AMP: {  				normalized = false;  				int saveNameEnd = token.NameEnd;  				scanRef (buf' off + minBPC' end' token);  				token.NameEnd = saveNameEnd;  				off = token.TokenEnd;  				break;  			}  			case BT_S:  				if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  					normalized = false;  				off += minBPC;  				break;  			case BT_LT:  				throw new InvalidTokenException (off);  			case BT_LF:  			case BT_CR:  				normalized = false;  				/* fall through */goto default;  			default:  				off += minBPC;  				break;  			}  		}  		token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		switch (t) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			break;  		case BT_GT:  		case BT_SOL:  			break;  		default:  			throw new InvalidTokenException (off);  		}  		/* off points to closing quote */for (; ;) {  			switch (t) {  			case BT_NMSTRT:  				nameStart = off;  				off += minBPC;  				goto skipToName;  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 2;  				goto skipToName;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 3;  				goto skipToName;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 4;  				goto skipToName;  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.START_TAG_WITH_ATTS;  			case BT_SOL:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.EMPTY_ELEMENT_WITH_ATTS;  			default:  				throw new InvalidTokenException (off);  			}  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  		}  		skipToName:  		NameEnd = -1;  		break;  	}  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		NameEnd = off;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_EQUALS:  				goto loop;  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		;  		/* fall through */goto case BT_EQUALS;  	case BT_EQUALS: {  		if (NameEnd < 0)  			NameEnd = off;  		int open;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			open = byteType (buf' off);  			if (open == BT_QUOT || open == BT_APOS)  				break;  			switch (open) {  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		off += minBPC;  		int valueStart = off;  		bool normalized = true;  		int t;  		/* in attribute value */for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			if (t == open)  				break;  			switch (t) {  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_AMP: {  				normalized = false;  				int saveNameEnd = token.NameEnd;  				scanRef (buf' off + minBPC' end' token);  				token.NameEnd = saveNameEnd;  				off = token.TokenEnd;  				break;  			}  			case BT_S:  				if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  					normalized = false;  				off += minBPC;  				break;  			case BT_LT:  				throw new InvalidTokenException (off);  			case BT_LF:  			case BT_CR:  				normalized = false;  				/* fall through */goto default;  			default:  				off += minBPC;  				break;  			}  		}  		token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		switch (t) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			break;  		case BT_GT:  		case BT_SOL:  			break;  		default:  			throw new InvalidTokenException (off);  		}  		/* off points to closing quote */for (; ;) {  			switch (t) {  			case BT_NMSTRT:  				nameStart = off;  				off += minBPC;  				goto skipToName;  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 2;  				goto skipToName;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 3;  				goto skipToName;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 4;  				goto skipToName;  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.START_TAG_WITH_ATTS;  			case BT_SOL:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.EMPTY_ELEMENT_WITH_ATTS;  			default:  				throw new InvalidTokenException (off);  			}  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  		}  		skipToName:  		NameEnd = -1;  		break;  	}  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		NameEnd = off;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_EQUALS:  				goto loop;  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		;  		/* fall through */goto case BT_EQUALS;  	case BT_EQUALS: {  		if (NameEnd < 0)  			NameEnd = off;  		int open;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			open = byteType (buf' off);  			if (open == BT_QUOT || open == BT_APOS)  				break;  			switch (open) {  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		off += minBPC;  		int valueStart = off;  		bool normalized = true;  		int t;  		/* in attribute value */for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			if (t == open)  				break;  			switch (t) {  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_AMP: {  				normalized = false;  				int saveNameEnd = token.NameEnd;  				scanRef (buf' off + minBPC' end' token);  				token.NameEnd = saveNameEnd;  				off = token.TokenEnd;  				break;  			}  			case BT_S:  				if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  					normalized = false;  				off += minBPC;  				break;  			case BT_LT:  				throw new InvalidTokenException (off);  			case BT_LF:  			case BT_CR:  				normalized = false;  				/* fall through */goto default;  			default:  				off += minBPC;  				break;  			}  		}  		token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		switch (t) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			break;  		case BT_GT:  		case BT_SOL:  			break;  		default:  			throw new InvalidTokenException (off);  		}  		/* off points to closing quote */for (; ;) {  			switch (t) {  			case BT_NMSTRT:  				nameStart = off;  				off += minBPC;  				goto skipToName;  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 2;  				goto skipToName;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 3;  				goto skipToName;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 4;  				goto skipToName;  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.START_TAG_WITH_ATTS;  			case BT_SOL:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.EMPTY_ELEMENT_WITH_ATTS;  			default:  				throw new InvalidTokenException (off);  			}  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  		}  		skipToName:  		NameEnd = -1;  		break;  	}  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		NameEnd = off;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_EQUALS:  				goto loop;  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		;  		/* fall through */goto case BT_EQUALS;  	case BT_EQUALS: {  		if (NameEnd < 0)  			NameEnd = off;  		int open;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			open = byteType (buf' off);  			if (open == BT_QUOT || open == BT_APOS)  				break;  			switch (open) {  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		off += minBPC;  		int valueStart = off;  		bool normalized = true;  		int t;  		/* in attribute value */for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			if (t == open)  				break;  			switch (t) {  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_AMP: {  				normalized = false;  				int saveNameEnd = token.NameEnd;  				scanRef (buf' off + minBPC' end' token);  				token.NameEnd = saveNameEnd;  				off = token.TokenEnd;  				break;  			}  			case BT_S:  				if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  					normalized = false;  				off += minBPC;  				break;  			case BT_LT:  				throw new InvalidTokenException (off);  			case BT_LF:  			case BT_CR:  				normalized = false;  				/* fall through */goto default;  			default:  				off += minBPC;  				break;  			}  		}  		token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		switch (t) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			break;  		case BT_GT:  		case BT_SOL:  			break;  		default:  			throw new InvalidTokenException (off);  		}  		/* off points to closing quote */for (; ;) {  			switch (t) {  			case BT_NMSTRT:  				nameStart = off;  				off += minBPC;  				goto skipToName;  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 2;  				goto skipToName;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 3;  				goto skipToName;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 4;  				goto skipToName;  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.START_TAG_WITH_ATTS;  			case BT_SOL:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.EMPTY_ELEMENT_WITH_ATTS;  			default:  				throw new InvalidTokenException (off);  			}  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  		}  		skipToName:  		NameEnd = -1;  		break;  	}  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		NameEnd = off;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_EQUALS:  				goto loop;  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		;  		/* fall through */goto case BT_EQUALS;  	case BT_EQUALS: {  		if (NameEnd < 0)  			NameEnd = off;  		int open;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			open = byteType (buf' off);  			if (open == BT_QUOT || open == BT_APOS)  				break;  			switch (open) {  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		off += minBPC;  		int valueStart = off;  		bool normalized = true;  		int t;  		/* in attribute value */for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			if (t == open)  				break;  			switch (t) {  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_AMP: {  				normalized = false;  				int saveNameEnd = token.NameEnd;  				scanRef (buf' off + minBPC' end' token);  				token.NameEnd = saveNameEnd;  				off = token.TokenEnd;  				break;  			}  			case BT_S:  				if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  					normalized = false;  				off += minBPC;  				break;  			case BT_LT:  				throw new InvalidTokenException (off);  			case BT_LF:  			case BT_CR:  				normalized = false;  				/* fall through */goto default;  			default:  				off += minBPC;  				break;  			}  		}  		token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		switch (t) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			break;  		case BT_GT:  		case BT_SOL:  			break;  		default:  			throw new InvalidTokenException (off);  		}  		/* off points to closing quote */for (; ;) {  			switch (t) {  			case BT_NMSTRT:  				nameStart = off;  				off += minBPC;  				goto skipToName;  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 2;  				goto skipToName;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 3;  				goto skipToName;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 4;  				goto skipToName;  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.START_TAG_WITH_ATTS;  			case BT_SOL:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.EMPTY_ELEMENT_WITH_ATTS;  			default:  				throw new InvalidTokenException (off);  			}  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  		}  		skipToName:  		NameEnd = -1;  		break;  	}  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		NameEnd = off;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_EQUALS:  				goto loop;  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		;  		/* fall through */goto case BT_EQUALS;  	case BT_EQUALS: {  		if (NameEnd < 0)  			NameEnd = off;  		int open;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			open = byteType (buf' off);  			if (open == BT_QUOT || open == BT_APOS)  				break;  			switch (open) {  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		off += minBPC;  		int valueStart = off;  		bool normalized = true;  		int t;  		/* in attribute value */for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			if (t == open)  				break;  			switch (t) {  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_AMP: {  				normalized = false;  				int saveNameEnd = token.NameEnd;  				scanRef (buf' off + minBPC' end' token);  				token.NameEnd = saveNameEnd;  				off = token.TokenEnd;  				break;  			}  			case BT_S:  				if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  					normalized = false;  				off += minBPC;  				break;  			case BT_LT:  				throw new InvalidTokenException (off);  			case BT_LF:  			case BT_CR:  				normalized = false;  				/* fall through */goto default;  			default:  				off += minBPC;  				break;  			}  		}  		token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		switch (t) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			break;  		case BT_GT:  		case BT_SOL:  			break;  		default:  			throw new InvalidTokenException (off);  		}  		/* off points to closing quote */for (; ;) {  			switch (t) {  			case BT_NMSTRT:  				nameStart = off;  				off += minBPC;  				goto skipToName;  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 2;  				goto skipToName;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 3;  				goto skipToName;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 4;  				goto skipToName;  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.START_TAG_WITH_ATTS;  			case BT_SOL:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.EMPTY_ELEMENT_WITH_ATTS;  			default:  				throw new InvalidTokenException (off);  			}  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  		}  		skipToName:  		NameEnd = -1;  		break;  	}  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		NameEnd = off;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_EQUALS:  				goto loop;  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		;  		/* fall through */goto case BT_EQUALS;  	case BT_EQUALS: {  		if (NameEnd < 0)  			NameEnd = off;  		int open;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			open = byteType (buf' off);  			if (open == BT_QUOT || open == BT_APOS)  				break;  			switch (open) {  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		off += minBPC;  		int valueStart = off;  		bool normalized = true;  		int t;  		/* in attribute value */for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			if (t == open)  				break;  			switch (t) {  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_AMP: {  				normalized = false;  				int saveNameEnd = token.NameEnd;  				scanRef (buf' off + minBPC' end' token);  				token.NameEnd = saveNameEnd;  				off = token.TokenEnd;  				break;  			}  			case BT_S:  				if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  					normalized = false;  				off += minBPC;  				break;  			case BT_LT:  				throw new InvalidTokenException (off);  			case BT_LF:  			case BT_CR:  				normalized = false;  				/* fall through */goto default;  			default:  				off += minBPC;  				break;  			}  		}  		token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		switch (t) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			break;  		case BT_GT:  		case BT_SOL:  			break;  		default:  			throw new InvalidTokenException (off);  		}  		/* off points to closing quote */for (; ;) {  			switch (t) {  			case BT_NMSTRT:  				nameStart = off;  				off += minBPC;  				goto skipToName;  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 2;  				goto skipToName;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 3;  				goto skipToName;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 4;  				goto skipToName;  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.START_TAG_WITH_ATTS;  			case BT_SOL:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.EMPTY_ELEMENT_WITH_ATTS;  			default:  				throw new InvalidTokenException (off);  			}  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  		}  		skipToName:  		NameEnd = -1;  		break;  	}  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		NameEnd = off;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_EQUALS:  				goto loop;  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		;  		/* fall through */goto case BT_EQUALS;  	case BT_EQUALS: {  		if (NameEnd < 0)  			NameEnd = off;  		int open;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			open = byteType (buf' off);  			if (open == BT_QUOT || open == BT_APOS)  				break;  			switch (open) {  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		off += minBPC;  		int valueStart = off;  		bool normalized = true;  		int t;  		/* in attribute value */for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			if (t == open)  				break;  			switch (t) {  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_AMP: {  				normalized = false;  				int saveNameEnd = token.NameEnd;  				scanRef (buf' off + minBPC' end' token);  				token.NameEnd = saveNameEnd;  				off = token.TokenEnd;  				break;  			}  			case BT_S:  				if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  					normalized = false;  				off += minBPC;  				break;  			case BT_LT:  				throw new InvalidTokenException (off);  			case BT_LF:  			case BT_CR:  				normalized = false;  				/* fall through */goto default;  			default:  				off += minBPC;  				break;  			}  		}  		token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		switch (t) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			break;  		case BT_GT:  		case BT_SOL:  			break;  		default:  			throw new InvalidTokenException (off);  		}  		/* off points to closing quote */for (; ;) {  			switch (t) {  			case BT_NMSTRT:  				nameStart = off;  				off += minBPC;  				goto skipToName;  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 2;  				goto skipToName;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 3;  				goto skipToName;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 4;  				goto skipToName;  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.START_TAG_WITH_ATTS;  			case BT_SOL:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.EMPTY_ELEMENT_WITH_ATTS;  			default:  				throw new InvalidTokenException (off);  			}  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  		}  		skipToName:  		NameEnd = -1;  		break;  	}  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		NameEnd = off;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_EQUALS:  				goto loop;  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		;  		/* fall through */goto case BT_EQUALS;  	case BT_EQUALS: {  		if (NameEnd < 0)  			NameEnd = off;  		int open;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			open = byteType (buf' off);  			if (open == BT_QUOT || open == BT_APOS)  				break;  			switch (open) {  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		off += minBPC;  		int valueStart = off;  		bool normalized = true;  		int t;  		/* in attribute value */for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			if (t == open)  				break;  			switch (t) {  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_AMP: {  				normalized = false;  				int saveNameEnd = token.NameEnd;  				scanRef (buf' off + minBPC' end' token);  				token.NameEnd = saveNameEnd;  				off = token.TokenEnd;  				break;  			}  			case BT_S:  				if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  					normalized = false;  				off += minBPC;  				break;  			case BT_LT:  				throw new InvalidTokenException (off);  			case BT_LF:  			case BT_CR:  				normalized = false;  				/* fall through */goto default;  			default:  				off += minBPC;  				break;  			}  		}  		token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		switch (t) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			break;  		case BT_GT:  		case BT_SOL:  			break;  		default:  			throw new InvalidTokenException (off);  		}  		/* off points to closing quote */for (; ;) {  			switch (t) {  			case BT_NMSTRT:  				nameStart = off;  				off += minBPC;  				goto skipToName;  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 2;  				goto skipToName;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 3;  				goto skipToName;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 4;  				goto skipToName;  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.START_TAG_WITH_ATTS;  			case BT_SOL:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.EMPTY_ELEMENT_WITH_ATTS;  			default:  				throw new InvalidTokenException (off);  			}  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  		}  		skipToName:  		NameEnd = -1;  		break;  	}  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		NameEnd = off;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_EQUALS:  				goto loop;  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		;  		/* fall through */goto case BT_EQUALS;  	case BT_EQUALS: {  		if (NameEnd < 0)  			NameEnd = off;  		int open;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			open = byteType (buf' off);  			if (open == BT_QUOT || open == BT_APOS)  				break;  			switch (open) {  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		off += minBPC;  		int valueStart = off;  		bool normalized = true;  		int t;  		/* in attribute value */for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			if (t == open)  				break;  			switch (t) {  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_AMP: {  				normalized = false;  				int saveNameEnd = token.NameEnd;  				scanRef (buf' off + minBPC' end' token);  				token.NameEnd = saveNameEnd;  				off = token.TokenEnd;  				break;  			}  			case BT_S:  				if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  					normalized = false;  				off += minBPC;  				break;  			case BT_LT:  				throw new InvalidTokenException (off);  			case BT_LF:  			case BT_CR:  				normalized = false;  				/* fall through */goto default;  			default:  				off += minBPC;  				break;  			}  		}  		token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		switch (t) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			break;  		case BT_GT:  		case BT_SOL:  			break;  		default:  			throw new InvalidTokenException (off);  		}  		/* off points to closing quote */for (; ;) {  			switch (t) {  			case BT_NMSTRT:  				nameStart = off;  				off += minBPC;  				goto skipToName;  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 2;  				goto skipToName;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 3;  				goto skipToName;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 4;  				goto skipToName;  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.START_TAG_WITH_ATTS;  			case BT_SOL:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.EMPTY_ELEMENT_WITH_ATTS;  			default:  				throw new InvalidTokenException (off);  			}  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  		}  		skipToName:  		NameEnd = -1;  		break;  	}  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		NameEnd = off;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_EQUALS:  				goto loop;  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		;  		/* fall through */goto case BT_EQUALS;  	case BT_EQUALS: {  		if (NameEnd < 0)  			NameEnd = off;  		int open;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			open = byteType (buf' off);  			if (open == BT_QUOT || open == BT_APOS)  				break;  			switch (open) {  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		off += minBPC;  		int valueStart = off;  		bool normalized = true;  		int t;  		/* in attribute value */for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			if (t == open)  				break;  			switch (t) {  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_AMP: {  				normalized = false;  				int saveNameEnd = token.NameEnd;  				scanRef (buf' off + minBPC' end' token);  				token.NameEnd = saveNameEnd;  				off = token.TokenEnd;  				break;  			}  			case BT_S:  				if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  					normalized = false;  				off += minBPC;  				break;  			case BT_LT:  				throw new InvalidTokenException (off);  			case BT_LF:  			case BT_CR:  				normalized = false;  				/* fall through */goto default;  			default:  				off += minBPC;  				break;  			}  		}  		token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		switch (t) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			break;  		case BT_GT:  		case BT_SOL:  			break;  		default:  			throw new InvalidTokenException (off);  		}  		/* off points to closing quote */for (; ;) {  			switch (t) {  			case BT_NMSTRT:  				nameStart = off;  				off += minBPC;  				goto skipToName;  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 2;  				goto skipToName;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 3;  				goto skipToName;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 4;  				goto skipToName;  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.START_TAG_WITH_ATTS;  			case BT_SOL:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.EMPTY_ELEMENT_WITH_ATTS;  			default:  				throw new InvalidTokenException (off);  			}  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  		}  		skipToName:  		NameEnd = -1;  		break;  	}  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		NameEnd = off;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_EQUALS:  				goto loop;  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		;  		/* fall through */goto case BT_EQUALS;  	case BT_EQUALS: {  		if (NameEnd < 0)  			NameEnd = off;  		int open;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			open = byteType (buf' off);  			if (open == BT_QUOT || open == BT_APOS)  				break;  			switch (open) {  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		off += minBPC;  		int valueStart = off;  		bool normalized = true;  		int t;  		/* in attribute value */for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			if (t == open)  				break;  			switch (t) {  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_AMP: {  				normalized = false;  				int saveNameEnd = token.NameEnd;  				scanRef (buf' off + minBPC' end' token);  				token.NameEnd = saveNameEnd;  				off = token.TokenEnd;  				break;  			}  			case BT_S:  				if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  					normalized = false;  				off += minBPC;  				break;  			case BT_LT:  				throw new InvalidTokenException (off);  			case BT_LF:  			case BT_CR:  				normalized = false;  				/* fall through */goto default;  			default:  				off += minBPC;  				break;  			}  		}  		token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		switch (t) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			break;  		case BT_GT:  		case BT_SOL:  			break;  		default:  			throw new InvalidTokenException (off);  		}  		/* off points to closing quote */for (; ;) {  			switch (t) {  			case BT_NMSTRT:  				nameStart = off;  				off += minBPC;  				goto skipToName;  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 2;  				goto skipToName;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 3;  				goto skipToName;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 4;  				goto skipToName;  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.START_TAG_WITH_ATTS;  			case BT_SOL:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.EMPTY_ELEMENT_WITH_ATTS;  			default:  				throw new InvalidTokenException (off);  			}  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  		}  		skipToName:  		NameEnd = -1;  		break;  	}  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		NameEnd = off;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_EQUALS:  				goto loop;  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		;  		/* fall through */goto case BT_EQUALS;  	case BT_EQUALS: {  		if (NameEnd < 0)  			NameEnd = off;  		int open;  		for (; ;) {  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			open = byteType (buf' off);  			if (open == BT_QUOT || open == BT_APOS)  				break;  			switch (open) {  			case BT_S:  			case BT_LF:  			case BT_CR:  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		off += minBPC;  		int valueStart = off;  		bool normalized = true;  		int t;  		/* in attribute value */for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			if (t == open)  				break;  			switch (t) {  			case BT_NONXML:  			case BT_MALFORM:  				throw new InvalidTokenException (off);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				check2 (buf' off);  				off += 2;  				break;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				check3 (buf' off);  				off += 3;  				break;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				check4 (buf' off);  				off += 4;  				break;  			case BT_AMP: {  				normalized = false;  				int saveNameEnd = token.NameEnd;  				scanRef (buf' off + minBPC' end' token);  				token.NameEnd = saveNameEnd;  				off = token.TokenEnd;  				break;  			}  			case BT_S:  				if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  					normalized = false;  				off += minBPC;  				break;  			case BT_LT:  				throw new InvalidTokenException (off);  			case BT_LF:  			case BT_CR:  				normalized = false;  				/* fall through */goto default;  			default:  				off += minBPC;  				break;  			}  		}  		token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		switch (t) {  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  			break;  		case BT_GT:  		case BT_SOL:  			break;  		default:  			throw new InvalidTokenException (off);  		}  		/* off points to closing quote */for (; ;) {  			switch (t) {  			case BT_NMSTRT:  				nameStart = off;  				off += minBPC;  				goto skipToName;  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 2;  				goto skipToName;  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 3;  				goto skipToName;  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				nameStart = off;  				off += 4;  				goto skipToName;  			case BT_S:  			case BT_CR:  			case BT_LF:  				break;  			case BT_GT:  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.START_TAG_WITH_ATTS;  			case BT_SOL:  				off += minBPC;  				if (off == end)  					throw new PartialTokenException ();  				checkCharMatches (buf' off' '>');  				token.checkAttributeUniqueness (buf);  				token.TokenEnd = off + minBPC;  				return TOK.EMPTY_ELEMENT_WITH_ATTS;  			default:  				throw new InvalidTokenException (off);  			}  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			t = byteType (buf' off);  		}  		skipToName:  		NameEnd = -1;  		break;  	}  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	NameEnd = off;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_EQUALS:  			goto loop;  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	;  	/* fall through */goto case BT_EQUALS;  case BT_EQUALS: {  	if (NameEnd < 0)  		NameEnd = off;  	int open;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		open = byteType (buf' off);  		if (open == BT_QUOT || open == BT_APOS)  			break;  		switch (open) {  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	off += minBPC;  	int valueStart = off;  	bool normalized = true;  	int t;  	/* in attribute value */for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		if (t == open)  			break;  		switch (t) {  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_AMP: {  			normalized = false;  			int saveNameEnd = token.NameEnd;  			scanRef (buf' off + minBPC' end' token);  			token.NameEnd = saveNameEnd;  			off = token.TokenEnd;  			break;  		}  		case BT_S:  			if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  				normalized = false;  			off += minBPC;  			break;  		case BT_LT:  			throw new InvalidTokenException (off);  		case BT_LF:  		case BT_CR:  			normalized = false;  			/* fall through */goto default;  		default:  			off += minBPC;  			break;  		}  	}  	token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	switch (t) {  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		break;  	case BT_GT:  	case BT_SOL:  		break;  	default:  		throw new InvalidTokenException (off);  	}  	/* off points to closing quote */for (; ;) {  		switch (t) {  		case BT_NMSTRT:  			nameStart = off;  			off += minBPC;  			goto skipToName;  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 2;  			goto skipToName;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 3;  			goto skipToName;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 4;  			goto skipToName;  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.START_TAG_WITH_ATTS;  		case BT_SOL:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.EMPTY_ELEMENT_WITH_ATTS;  		default:  			throw new InvalidTokenException (off);  		}  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  	}  	skipToName:  	NameEnd = -1;  	break;  }  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	NameEnd = off;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_EQUALS:  			goto loop;  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	;  	/* fall through */goto case BT_EQUALS;  case BT_EQUALS: {  	if (NameEnd < 0)  		NameEnd = off;  	int open;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		open = byteType (buf' off);  		if (open == BT_QUOT || open == BT_APOS)  			break;  		switch (open) {  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	off += minBPC;  	int valueStart = off;  	bool normalized = true;  	int t;  	/* in attribute value */for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		if (t == open)  			break;  		switch (t) {  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_AMP: {  			normalized = false;  			int saveNameEnd = token.NameEnd;  			scanRef (buf' off + minBPC' end' token);  			token.NameEnd = saveNameEnd;  			off = token.TokenEnd;  			break;  		}  		case BT_S:  			if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  				normalized = false;  			off += minBPC;  			break;  		case BT_LT:  			throw new InvalidTokenException (off);  		case BT_LF:  		case BT_CR:  			normalized = false;  			/* fall through */goto default;  		default:  			off += minBPC;  			break;  		}  	}  	token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	switch (t) {  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		break;  	case BT_GT:  	case BT_SOL:  		break;  	default:  		throw new InvalidTokenException (off);  	}  	/* off points to closing quote */for (; ;) {  		switch (t) {  		case BT_NMSTRT:  			nameStart = off;  			off += minBPC;  			goto skipToName;  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 2;  			goto skipToName;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 3;  			goto skipToName;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 4;  			goto skipToName;  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.START_TAG_WITH_ATTS;  		case BT_SOL:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.EMPTY_ELEMENT_WITH_ATTS;  		default:  			throw new InvalidTokenException (off);  		}  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  	}  	skipToName:  	NameEnd = -1;  	break;  }  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	NameEnd = off;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_EQUALS:  			goto loop;  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	;  	/* fall through */goto case BT_EQUALS;  case BT_EQUALS: {  	if (NameEnd < 0)  		NameEnd = off;  	int open;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		open = byteType (buf' off);  		if (open == BT_QUOT || open == BT_APOS)  			break;  		switch (open) {  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	off += minBPC;  	int valueStart = off;  	bool normalized = true;  	int t;  	/* in attribute value */for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		if (t == open)  			break;  		switch (t) {  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_AMP: {  			normalized = false;  			int saveNameEnd = token.NameEnd;  			scanRef (buf' off + minBPC' end' token);  			token.NameEnd = saveNameEnd;  			off = token.TokenEnd;  			break;  		}  		case BT_S:  			if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  				normalized = false;  			off += minBPC;  			break;  		case BT_LT:  			throw new InvalidTokenException (off);  		case BT_LF:  		case BT_CR:  			normalized = false;  			/* fall through */goto default;  		default:  			off += minBPC;  			break;  		}  	}  	token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	switch (t) {  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		break;  	case BT_GT:  	case BT_SOL:  		break;  	default:  		throw new InvalidTokenException (off);  	}  	/* off points to closing quote */for (; ;) {  		switch (t) {  		case BT_NMSTRT:  			nameStart = off;  			off += minBPC;  			goto skipToName;  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 2;  			goto skipToName;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 3;  			goto skipToName;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 4;  			goto skipToName;  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.START_TAG_WITH_ATTS;  		case BT_SOL:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.EMPTY_ELEMENT_WITH_ATTS;  		default:  			throw new InvalidTokenException (off);  		}  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  	}  	skipToName:  	NameEnd = -1;  	break;  }  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	NameEnd = off;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_EQUALS:  			goto loop;  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	;  	/* fall through */goto case BT_EQUALS;  case BT_EQUALS: {  	if (NameEnd < 0)  		NameEnd = off;  	int open;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		open = byteType (buf' off);  		if (open == BT_QUOT || open == BT_APOS)  			break;  		switch (open) {  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	off += minBPC;  	int valueStart = off;  	bool normalized = true;  	int t;  	/* in attribute value */for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		if (t == open)  			break;  		switch (t) {  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_AMP: {  			normalized = false;  			int saveNameEnd = token.NameEnd;  			scanRef (buf' off + minBPC' end' token);  			token.NameEnd = saveNameEnd;  			off = token.TokenEnd;  			break;  		}  		case BT_S:  			if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  				normalized = false;  			off += minBPC;  			break;  		case BT_LT:  			throw new InvalidTokenException (off);  		case BT_LF:  		case BT_CR:  			normalized = false;  			/* fall through */goto default;  		default:  			off += minBPC;  			break;  		}  	}  	token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	switch (t) {  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		break;  	case BT_GT:  	case BT_SOL:  		break;  	default:  		throw new InvalidTokenException (off);  	}  	/* off points to closing quote */for (; ;) {  		switch (t) {  		case BT_NMSTRT:  			nameStart = off;  			off += minBPC;  			goto skipToName;  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 2;  			goto skipToName;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 3;  			goto skipToName;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 4;  			goto skipToName;  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.START_TAG_WITH_ATTS;  		case BT_SOL:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.EMPTY_ELEMENT_WITH_ATTS;  		default:  			throw new InvalidTokenException (off);  		}  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  	}  	skipToName:  	NameEnd = -1;  	break;  }  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	NameEnd = off;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_EQUALS:  			goto loop;  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	;  	/* fall through */goto case BT_EQUALS;  case BT_EQUALS: {  	if (NameEnd < 0)  		NameEnd = off;  	int open;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		open = byteType (buf' off);  		if (open == BT_QUOT || open == BT_APOS)  			break;  		switch (open) {  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	off += minBPC;  	int valueStart = off;  	bool normalized = true;  	int t;  	/* in attribute value */for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		if (t == open)  			break;  		switch (t) {  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_AMP: {  			normalized = false;  			int saveNameEnd = token.NameEnd;  			scanRef (buf' off + minBPC' end' token);  			token.NameEnd = saveNameEnd;  			off = token.TokenEnd;  			break;  		}  		case BT_S:  			if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  				normalized = false;  			off += minBPC;  			break;  		case BT_LT:  			throw new InvalidTokenException (off);  		case BT_LF:  		case BT_CR:  			normalized = false;  			/* fall through */goto default;  		default:  			off += minBPC;  			break;  		}  	}  	token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	switch (t) {  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		break;  	case BT_GT:  	case BT_SOL:  		break;  	default:  		throw new InvalidTokenException (off);  	}  	/* off points to closing quote */for (; ;) {  		switch (t) {  		case BT_NMSTRT:  			nameStart = off;  			off += minBPC;  			goto skipToName;  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 2;  			goto skipToName;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 3;  			goto skipToName;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 4;  			goto skipToName;  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.START_TAG_WITH_ATTS;  		case BT_SOL:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.EMPTY_ELEMENT_WITH_ATTS;  		default:  			throw new InvalidTokenException (off);  		}  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  	}  	skipToName:  	NameEnd = -1;  	break;  }  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	NameEnd = off;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_EQUALS:  			goto loop;  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	;  	/* fall through */goto case BT_EQUALS;  case BT_EQUALS: {  	if (NameEnd < 0)  		NameEnd = off;  	int open;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		open = byteType (buf' off);  		if (open == BT_QUOT || open == BT_APOS)  			break;  		switch (open) {  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	off += minBPC;  	int valueStart = off;  	bool normalized = true;  	int t;  	/* in attribute value */for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		if (t == open)  			break;  		switch (t) {  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_AMP: {  			normalized = false;  			int saveNameEnd = token.NameEnd;  			scanRef (buf' off + minBPC' end' token);  			token.NameEnd = saveNameEnd;  			off = token.TokenEnd;  			break;  		}  		case BT_S:  			if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  				normalized = false;  			off += minBPC;  			break;  		case BT_LT:  			throw new InvalidTokenException (off);  		case BT_LF:  		case BT_CR:  			normalized = false;  			/* fall through */goto default;  		default:  			off += minBPC;  			break;  		}  	}  	token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	switch (t) {  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		break;  	case BT_GT:  	case BT_SOL:  		break;  	default:  		throw new InvalidTokenException (off);  	}  	/* off points to closing quote */for (; ;) {  		switch (t) {  		case BT_NMSTRT:  			nameStart = off;  			off += minBPC;  			goto skipToName;  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 2;  			goto skipToName;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 3;  			goto skipToName;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 4;  			goto skipToName;  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.START_TAG_WITH_ATTS;  		case BT_SOL:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.EMPTY_ELEMENT_WITH_ATTS;  		default:  			throw new InvalidTokenException (off);  		}  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  	}  	skipToName:  	NameEnd = -1;  	break;  }  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	NameEnd = off;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_EQUALS:  			goto loop;  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	;  	/* fall through */goto case BT_EQUALS;  case BT_EQUALS: {  	if (NameEnd < 0)  		NameEnd = off;  	int open;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		open = byteType (buf' off);  		if (open == BT_QUOT || open == BT_APOS)  			break;  		switch (open) {  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	off += minBPC;  	int valueStart = off;  	bool normalized = true;  	int t;  	/* in attribute value */for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		if (t == open)  			break;  		switch (t) {  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_AMP: {  			normalized = false;  			int saveNameEnd = token.NameEnd;  			scanRef (buf' off + minBPC' end' token);  			token.NameEnd = saveNameEnd;  			off = token.TokenEnd;  			break;  		}  		case BT_S:  			if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  				normalized = false;  			off += minBPC;  			break;  		case BT_LT:  			throw new InvalidTokenException (off);  		case BT_LF:  		case BT_CR:  			normalized = false;  			/* fall through */goto default;  		default:  			off += minBPC;  			break;  		}  	}  	token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	switch (t) {  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		break;  	case BT_GT:  	case BT_SOL:  		break;  	default:  		throw new InvalidTokenException (off);  	}  	/* off points to closing quote */for (; ;) {  		switch (t) {  		case BT_NMSTRT:  			nameStart = off;  			off += minBPC;  			goto skipToName;  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 2;  			goto skipToName;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 3;  			goto skipToName;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 4;  			goto skipToName;  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.START_TAG_WITH_ATTS;  		case BT_SOL:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.EMPTY_ELEMENT_WITH_ATTS;  		default:  			throw new InvalidTokenException (off);  		}  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  	}  	skipToName:  	NameEnd = -1;  	break;  }  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	NameEnd = off;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_EQUALS:  			goto loop;  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	;  	/* fall through */goto case BT_EQUALS;  case BT_EQUALS: {  	if (NameEnd < 0)  		NameEnd = off;  	int open;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		open = byteType (buf' off);  		if (open == BT_QUOT || open == BT_APOS)  			break;  		switch (open) {  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	off += minBPC;  	int valueStart = off;  	bool normalized = true;  	int t;  	/* in attribute value */for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		if (t == open)  			break;  		switch (t) {  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_AMP: {  			normalized = false;  			int saveNameEnd = token.NameEnd;  			scanRef (buf' off + minBPC' end' token);  			token.NameEnd = saveNameEnd;  			off = token.TokenEnd;  			break;  		}  		case BT_S:  			if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  				normalized = false;  			off += minBPC;  			break;  		case BT_LT:  			throw new InvalidTokenException (off);  		case BT_LF:  		case BT_CR:  			normalized = false;  			/* fall through */goto default;  		default:  			off += minBPC;  			break;  		}  	}  	token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	switch (t) {  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		break;  	case BT_GT:  	case BT_SOL:  		break;  	default:  		throw new InvalidTokenException (off);  	}  	/* off points to closing quote */for (; ;) {  		switch (t) {  		case BT_NMSTRT:  			nameStart = off;  			off += minBPC;  			goto skipToName;  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 2;  			goto skipToName;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 3;  			goto skipToName;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 4;  			goto skipToName;  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.START_TAG_WITH_ATTS;  		case BT_SOL:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.EMPTY_ELEMENT_WITH_ATTS;  		default:  			throw new InvalidTokenException (off);  		}  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  	}  	skipToName:  	NameEnd = -1;  	break;  }  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	NameEnd = off;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_EQUALS:  			goto loop;  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	;  	/* fall through */goto case BT_EQUALS;  case BT_EQUALS: {  	if (NameEnd < 0)  		NameEnd = off;  	int open;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		open = byteType (buf' off);  		if (open == BT_QUOT || open == BT_APOS)  			break;  		switch (open) {  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	off += minBPC;  	int valueStart = off;  	bool normalized = true;  	int t;  	/* in attribute value */for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		if (t == open)  			break;  		switch (t) {  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_AMP: {  			normalized = false;  			int saveNameEnd = token.NameEnd;  			scanRef (buf' off + minBPC' end' token);  			token.NameEnd = saveNameEnd;  			off = token.TokenEnd;  			break;  		}  		case BT_S:  			if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  				normalized = false;  			off += minBPC;  			break;  		case BT_LT:  			throw new InvalidTokenException (off);  		case BT_LF:  		case BT_CR:  			normalized = false;  			/* fall through */goto default;  		default:  			off += minBPC;  			break;  		}  	}  	token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	switch (t) {  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		break;  	case BT_GT:  	case BT_SOL:  		break;  	default:  		throw new InvalidTokenException (off);  	}  	/* off points to closing quote */for (; ;) {  		switch (t) {  		case BT_NMSTRT:  			nameStart = off;  			off += minBPC;  			goto skipToName;  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 2;  			goto skipToName;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 3;  			goto skipToName;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 4;  			goto skipToName;  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.START_TAG_WITH_ATTS;  		case BT_SOL:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.EMPTY_ELEMENT_WITH_ATTS;  		default:  			throw new InvalidTokenException (off);  		}  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  	}  	skipToName:  	NameEnd = -1;  	break;  }  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	NameEnd = off;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_EQUALS:  			goto loop;  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	;  	/* fall through */goto case BT_EQUALS;  case BT_EQUALS: {  	if (NameEnd < 0)  		NameEnd = off;  	int open;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		open = byteType (buf' off);  		if (open == BT_QUOT || open == BT_APOS)  			break;  		switch (open) {  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	off += minBPC;  	int valueStart = off;  	bool normalized = true;  	int t;  	/* in attribute value */for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		if (t == open)  			break;  		switch (t) {  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_AMP: {  			normalized = false;  			int saveNameEnd = token.NameEnd;  			scanRef (buf' off + minBPC' end' token);  			token.NameEnd = saveNameEnd;  			off = token.TokenEnd;  			break;  		}  		case BT_S:  			if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  				normalized = false;  			off += minBPC;  			break;  		case BT_LT:  			throw new InvalidTokenException (off);  		case BT_LF:  		case BT_CR:  			normalized = false;  			/* fall through */goto default;  		default:  			off += minBPC;  			break;  		}  	}  	token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	switch (t) {  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		break;  	case BT_GT:  	case BT_SOL:  		break;  	default:  		throw new InvalidTokenException (off);  	}  	/* off points to closing quote */for (; ;) {  		switch (t) {  		case BT_NMSTRT:  			nameStart = off;  			off += minBPC;  			goto skipToName;  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 2;  			goto skipToName;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 3;  			goto skipToName;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 4;  			goto skipToName;  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.START_TAG_WITH_ATTS;  		case BT_SOL:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.EMPTY_ELEMENT_WITH_ATTS;  		default:  			throw new InvalidTokenException (off);  		}  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  	}  	skipToName:  	NameEnd = -1;  	break;  }  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	NameEnd = off;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_EQUALS:  			goto loop;  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	;  	/* fall through */goto case BT_EQUALS;  case BT_EQUALS: {  	if (NameEnd < 0)  		NameEnd = off;  	int open;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		open = byteType (buf' off);  		if (open == BT_QUOT || open == BT_APOS)  			break;  		switch (open) {  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	off += minBPC;  	int valueStart = off;  	bool normalized = true;  	int t;  	/* in attribute value */for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		if (t == open)  			break;  		switch (t) {  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_AMP: {  			normalized = false;  			int saveNameEnd = token.NameEnd;  			scanRef (buf' off + minBPC' end' token);  			token.NameEnd = saveNameEnd;  			off = token.TokenEnd;  			break;  		}  		case BT_S:  			if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  				normalized = false;  			off += minBPC;  			break;  		case BT_LT:  			throw new InvalidTokenException (off);  		case BT_LF:  		case BT_CR:  			normalized = false;  			/* fall through */goto default;  		default:  			off += minBPC;  			break;  		}  	}  	token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	switch (t) {  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		break;  	case BT_GT:  	case BT_SOL:  		break;  	default:  		throw new InvalidTokenException (off);  	}  	/* off points to closing quote */for (; ;) {  		switch (t) {  		case BT_NMSTRT:  			nameStart = off;  			off += minBPC;  			goto skipToName;  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 2;  			goto skipToName;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 3;  			goto skipToName;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 4;  			goto skipToName;  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.START_TAG_WITH_ATTS;  		case BT_SOL:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.EMPTY_ELEMENT_WITH_ATTS;  		default:  			throw new InvalidTokenException (off);  		}  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  	}  	skipToName:  	NameEnd = -1;  	break;  }  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	NameEnd = off;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_EQUALS:  			goto loop;  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	;  	/* fall through */goto case BT_EQUALS;  case BT_EQUALS: {  	if (NameEnd < 0)  		NameEnd = off;  	int open;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		open = byteType (buf' off);  		if (open == BT_QUOT || open == BT_APOS)  			break;  		switch (open) {  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	off += minBPC;  	int valueStart = off;  	bool normalized = true;  	int t;  	/* in attribute value */for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		if (t == open)  			break;  		switch (t) {  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_AMP: {  			normalized = false;  			int saveNameEnd = token.NameEnd;  			scanRef (buf' off + minBPC' end' token);  			token.NameEnd = saveNameEnd;  			off = token.TokenEnd;  			break;  		}  		case BT_S:  			if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  				normalized = false;  			off += minBPC;  			break;  		case BT_LT:  			throw new InvalidTokenException (off);  		case BT_LF:  		case BT_CR:  			normalized = false;  			/* fall through */goto default;  		default:  			off += minBPC;  			break;  		}  	}  	token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	switch (t) {  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		break;  	case BT_GT:  	case BT_SOL:  		break;  	default:  		throw new InvalidTokenException (off);  	}  	/* off points to closing quote */for (; ;) {  		switch (t) {  		case BT_NMSTRT:  			nameStart = off;  			off += minBPC;  			goto skipToName;  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 2;  			goto skipToName;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 3;  			goto skipToName;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 4;  			goto skipToName;  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.START_TAG_WITH_ATTS;  		case BT_SOL:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.EMPTY_ELEMENT_WITH_ATTS;  		default:  			throw new InvalidTokenException (off);  		}  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  	}  	skipToName:  	NameEnd = -1;  	break;  }  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	NameEnd = off;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_EQUALS:  			goto loop;  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	;  	/* fall through */goto case BT_EQUALS;  case BT_EQUALS: {  	if (NameEnd < 0)  		NameEnd = off;  	int open;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		open = byteType (buf' off);  		if (open == BT_QUOT || open == BT_APOS)  			break;  		switch (open) {  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	off += minBPC;  	int valueStart = off;  	bool normalized = true;  	int t;  	/* in attribute value */for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		if (t == open)  			break;  		switch (t) {  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_AMP: {  			normalized = false;  			int saveNameEnd = token.NameEnd;  			scanRef (buf' off + minBPC' end' token);  			token.NameEnd = saveNameEnd;  			off = token.TokenEnd;  			break;  		}  		case BT_S:  			if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  				normalized = false;  			off += minBPC;  			break;  		case BT_LT:  			throw new InvalidTokenException (off);  		case BT_LF:  		case BT_CR:  			normalized = false;  			/* fall through */goto default;  		default:  			off += minBPC;  			break;  		}  	}  	token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	switch (t) {  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		break;  	case BT_GT:  	case BT_SOL:  		break;  	default:  		throw new InvalidTokenException (off);  	}  	/* off points to closing quote */for (; ;) {  		switch (t) {  		case BT_NMSTRT:  			nameStart = off;  			off += minBPC;  			goto skipToName;  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 2;  			goto skipToName;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 3;  			goto skipToName;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 4;  			goto skipToName;  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.START_TAG_WITH_ATTS;  		case BT_SOL:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.EMPTY_ELEMENT_WITH_ATTS;  		default:  			throw new InvalidTokenException (off);  		}  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  	}  	skipToName:  	NameEnd = -1;  	break;  }  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	NameEnd = off;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_EQUALS:  			goto loop;  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	;  	/* fall through */goto case BT_EQUALS;  case BT_EQUALS: {  	if (NameEnd < 0)  		NameEnd = off;  	int open;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		open = byteType (buf' off);  		if (open == BT_QUOT || open == BT_APOS)  			break;  		switch (open) {  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	off += minBPC;  	int valueStart = off;  	bool normalized = true;  	int t;  	/* in attribute value */for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		if (t == open)  			break;  		switch (t) {  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_AMP: {  			normalized = false;  			int saveNameEnd = token.NameEnd;  			scanRef (buf' off + minBPC' end' token);  			token.NameEnd = saveNameEnd;  			off = token.TokenEnd;  			break;  		}  		case BT_S:  			if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  				normalized = false;  			off += minBPC;  			break;  		case BT_LT:  			throw new InvalidTokenException (off);  		case BT_LF:  		case BT_CR:  			normalized = false;  			/* fall through */goto default;  		default:  			off += minBPC;  			break;  		}  	}  	token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	switch (t) {  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		break;  	case BT_GT:  	case BT_SOL:  		break;  	default:  		throw new InvalidTokenException (off);  	}  	/* off points to closing quote */for (; ;) {  		switch (t) {  		case BT_NMSTRT:  			nameStart = off;  			off += minBPC;  			goto skipToName;  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 2;  			goto skipToName;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 3;  			goto skipToName;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 4;  			goto skipToName;  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.START_TAG_WITH_ATTS;  		case BT_SOL:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.EMPTY_ELEMENT_WITH_ATTS;  		default:  			throw new InvalidTokenException (off);  		}  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  	}  	skipToName:  	NameEnd = -1;  	break;  }  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	NameEnd = off;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_EQUALS:  			goto loop;  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	;  	/* fall through */goto case BT_EQUALS;  case BT_EQUALS: {  	if (NameEnd < 0)  		NameEnd = off;  	int open;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		open = byteType (buf' off);  		if (open == BT_QUOT || open == BT_APOS)  			break;  		switch (open) {  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	off += minBPC;  	int valueStart = off;  	bool normalized = true;  	int t;  	/* in attribute value */for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		if (t == open)  			break;  		switch (t) {  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_AMP: {  			normalized = false;  			int saveNameEnd = token.NameEnd;  			scanRef (buf' off + minBPC' end' token);  			token.NameEnd = saveNameEnd;  			off = token.TokenEnd;  			break;  		}  		case BT_S:  			if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  				normalized = false;  			off += minBPC;  			break;  		case BT_LT:  			throw new InvalidTokenException (off);  		case BT_LF:  		case BT_CR:  			normalized = false;  			/* fall through */goto default;  		default:  			off += minBPC;  			break;  		}  	}  	token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	switch (t) {  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		break;  	case BT_GT:  	case BT_SOL:  		break;  	default:  		throw new InvalidTokenException (off);  	}  	/* off points to closing quote */for (; ;) {  		switch (t) {  		case BT_NMSTRT:  			nameStart = off;  			off += minBPC;  			goto skipToName;  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 2;  			goto skipToName;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 3;  			goto skipToName;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 4;  			goto skipToName;  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.START_TAG_WITH_ATTS;  		case BT_SOL:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.EMPTY_ELEMENT_WITH_ATTS;  		default:  			throw new InvalidTokenException (off);  		}  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  	}  	skipToName:  	NameEnd = -1;  	break;  }  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	NameEnd = off;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_EQUALS:  			goto loop;  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	;  	/* fall through */goto case BT_EQUALS;  case BT_EQUALS: {  	if (NameEnd < 0)  		NameEnd = off;  	int open;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		open = byteType (buf' off);  		if (open == BT_QUOT || open == BT_APOS)  			break;  		switch (open) {  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	off += minBPC;  	int valueStart = off;  	bool normalized = true;  	int t;  	/* in attribute value */for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		if (t == open)  			break;  		switch (t) {  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_AMP: {  			normalized = false;  			int saveNameEnd = token.NameEnd;  			scanRef (buf' off + minBPC' end' token);  			token.NameEnd = saveNameEnd;  			off = token.TokenEnd;  			break;  		}  		case BT_S:  			if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  				normalized = false;  			off += minBPC;  			break;  		case BT_LT:  			throw new InvalidTokenException (off);  		case BT_LF:  		case BT_CR:  			normalized = false;  			/* fall through */goto default;  		default:  			off += minBPC;  			break;  		}  	}  	token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	switch (t) {  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		break;  	case BT_GT:  	case BT_SOL:  		break;  	default:  		throw new InvalidTokenException (off);  	}  	/* off points to closing quote */for (; ;) {  		switch (t) {  		case BT_NMSTRT:  			nameStart = off;  			off += minBPC;  			goto skipToName;  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 2;  			goto skipToName;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 3;  			goto skipToName;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 4;  			goto skipToName;  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.START_TAG_WITH_ATTS;  		case BT_SOL:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.EMPTY_ELEMENT_WITH_ATTS;  		default:  			throw new InvalidTokenException (off);  		}  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  	}  	skipToName:  	NameEnd = -1;  	break;  }  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	NameEnd = off;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_EQUALS:  			goto loop;  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	;  	/* fall through */goto case BT_EQUALS;  case BT_EQUALS: {  	if (NameEnd < 0)  		NameEnd = off;  	int open;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		open = byteType (buf' off);  		if (open == BT_QUOT || open == BT_APOS)  			break;  		switch (open) {  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	off += minBPC;  	int valueStart = off;  	bool normalized = true;  	int t;  	/* in attribute value */for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		if (t == open)  			break;  		switch (t) {  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_AMP: {  			normalized = false;  			int saveNameEnd = token.NameEnd;  			scanRef (buf' off + minBPC' end' token);  			token.NameEnd = saveNameEnd;  			off = token.TokenEnd;  			break;  		}  		case BT_S:  			if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  				normalized = false;  			off += minBPC;  			break;  		case BT_LT:  			throw new InvalidTokenException (off);  		case BT_LF:  		case BT_CR:  			normalized = false;  			/* fall through */goto default;  		default:  			off += minBPC;  			break;  		}  	}  	token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	switch (t) {  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		break;  	case BT_GT:  	case BT_SOL:  		break;  	default:  		throw new InvalidTokenException (off);  	}  	/* off points to closing quote */for (; ;) {  		switch (t) {  		case BT_NMSTRT:  			nameStart = off;  			off += minBPC;  			goto skipToName;  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 2;  			goto skipToName;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 3;  			goto skipToName;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 4;  			goto skipToName;  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.START_TAG_WITH_ATTS;  		case BT_SOL:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.EMPTY_ELEMENT_WITH_ATTS;  		default:  			throw new InvalidTokenException (off);  		}  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  	}  	skipToName:  	NameEnd = -1;  	break;  }  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	NameEnd = off;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_EQUALS:  			goto loop;  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	;  	/* fall through */goto case BT_EQUALS;  case BT_EQUALS: {  	if (NameEnd < 0)  		NameEnd = off;  	int open;  	for (; ;) {  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		open = byteType (buf' off);  		if (open == BT_QUOT || open == BT_APOS)  			break;  		switch (open) {  		case BT_S:  		case BT_LF:  		case BT_CR:  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	off += minBPC;  	int valueStart = off;  	bool normalized = true;  	int t;  	/* in attribute value */for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		if (t == open)  			break;  		switch (t) {  		case BT_NONXML:  		case BT_MALFORM:  			throw new InvalidTokenException (off);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			check2 (buf' off);  			off += 2;  			break;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			check3 (buf' off);  			off += 3;  			break;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			check4 (buf' off);  			off += 4;  			break;  		case BT_AMP: {  			normalized = false;  			int saveNameEnd = token.NameEnd;  			scanRef (buf' off + minBPC' end' token);  			token.NameEnd = saveNameEnd;  			off = token.TokenEnd;  			break;  		}  		case BT_S:  			if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  				normalized = false;  			off += minBPC;  			break;  		case BT_LT:  			throw new InvalidTokenException (off);  		case BT_LF:  		case BT_CR:  			normalized = false;  			/* fall through */goto default;  		default:  			off += minBPC;  			break;  		}  	}  	token.appendAttribute (nameStart' NameEnd' valueStart' off' normalized);  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	switch (t) {  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  		break;  	case BT_GT:  	case BT_SOL:  		break;  	default:  		throw new InvalidTokenException (off);  	}  	/* off points to closing quote */for (; ;) {  		switch (t) {  		case BT_NMSTRT:  			nameStart = off;  			off += minBPC;  			goto skipToName;  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 2;  			goto skipToName;  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 3;  			goto skipToName;  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			nameStart = off;  			off += 4;  			goto skipToName;  		case BT_S:  		case BT_CR:  		case BT_LF:  			break;  		case BT_GT:  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.START_TAG_WITH_ATTS;  		case BT_SOL:  			off += minBPC;  			if (off == end)  				throw new PartialTokenException ();  			checkCharMatches (buf' off' '>');  			token.checkAttributeUniqueness (buf);  			token.TokenEnd = off + minBPC;  			return TOK.EMPTY_ELEMENT_WITH_ATTS;  		default:  			throw new InvalidTokenException (off);  		}  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		t = byteType (buf' off);  	}  	skipToName:  	NameEnd = -1;  	break;  }  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: off += 2;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: off += 3;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: off += 4;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: for (; ;) {  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	if (t == open)  		break;  	switch (t) {  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_AMP: {  		normalized = false;  		int saveNameEnd = token.NameEnd;  		scanRef (buf' off + minBPC' end' token);  		token.NameEnd = saveNameEnd;  		off = token.TokenEnd;  		break;  	}  	case BT_S:  		if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  			normalized = false;  		off += minBPC;  		break;  	case BT_LT:  		throw new InvalidTokenException (off);  	case BT_LF:  	case BT_CR:  		normalized = false;  		/* fall through */goto default;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: for (; ;) {  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	if (t == open)  		break;  	switch (t) {  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_AMP: {  		normalized = false;  		int saveNameEnd = token.NameEnd;  		scanRef (buf' off + minBPC' end' token);  		token.NameEnd = saveNameEnd;  		off = token.TokenEnd;  		break;  	}  	case BT_S:  		if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  			normalized = false;  		off += minBPC;  		break;  	case BT_LT:  		throw new InvalidTokenException (off);  	case BT_LF:  	case BT_CR:  		normalized = false;  		/* fall through */goto default;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: for (; ;) {  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	if (t == open)  		break;  	switch (t) {  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_AMP: {  		normalized = false;  		int saveNameEnd = token.NameEnd;  		scanRef (buf' off + minBPC' end' token);  		token.NameEnd = saveNameEnd;  		off = token.TokenEnd;  		break;  	}  	case BT_S:  		if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  			normalized = false;  		off += minBPC;  		break;  	case BT_LT:  		throw new InvalidTokenException (off);  	case BT_LF:  	case BT_CR:  		normalized = false;  		/* fall through */goto default;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: for (; ;) {  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	if (t == open)  		break;  	switch (t) {  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_AMP: {  		normalized = false;  		int saveNameEnd = token.NameEnd;  		scanRef (buf' off + minBPC' end' token);  		token.NameEnd = saveNameEnd;  		off = token.TokenEnd;  		break;  	}  	case BT_S:  		if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  			normalized = false;  		off += minBPC;  		break;  	case BT_LT:  		throw new InvalidTokenException (off);  	case BT_LF:  	case BT_CR:  		normalized = false;  		/* fall through */goto default;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: for (; ;) {  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	if (t == open)  		break;  	switch (t) {  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_AMP: {  		normalized = false;  		int saveNameEnd = token.NameEnd;  		scanRef (buf' off + minBPC' end' token);  		token.NameEnd = saveNameEnd;  		off = token.TokenEnd;  		break;  	}  	case BT_S:  		if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  			normalized = false;  		off += minBPC;  		break;  	case BT_LT:  		throw new InvalidTokenException (off);  	case BT_LF:  	case BT_CR:  		normalized = false;  		/* fall through */goto default;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: for (; ;) {  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  	if (t == open)  		break;  	switch (t) {  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_AMP: {  		normalized = false;  		int saveNameEnd = token.NameEnd;  		scanRef (buf' off + minBPC' end' token);  		token.NameEnd = saveNameEnd;  		off = token.TokenEnd;  		break;  	}  	case BT_S:  		if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  			normalized = false;  		off += minBPC;  		break;  	case BT_LT:  		throw new InvalidTokenException (off);  	case BT_LF:  	case BT_CR:  		normalized = false;  		/* fall through */goto default;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (t) {  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_AMP: {  	normalized = false;  	int saveNameEnd = token.NameEnd;  	scanRef (buf' off + minBPC' end' token);  	token.NameEnd = saveNameEnd;  	off = token.TokenEnd;  	break;  }  case BT_S:  	if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  		normalized = false;  	off += minBPC;  	break;  case BT_LT:  	throw new InvalidTokenException (off);  case BT_LF:  case BT_CR:  	normalized = false;  	/* fall through */goto default;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (t) {  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_AMP: {  	normalized = false;  	int saveNameEnd = token.NameEnd;  	scanRef (buf' off + minBPC' end' token);  	token.NameEnd = saveNameEnd;  	off = token.TokenEnd;  	break;  }  case BT_S:  	if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  		normalized = false;  	off += minBPC;  	break;  case BT_LT:  	throw new InvalidTokenException (off);  case BT_LF:  case BT_CR:  	normalized = false;  	/* fall through */goto default;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (t) {  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_AMP: {  	normalized = false;  	int saveNameEnd = token.NameEnd;  	scanRef (buf' off + minBPC' end' token);  	token.NameEnd = saveNameEnd;  	off = token.TokenEnd;  	break;  }  case BT_S:  	if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  		normalized = false;  	off += minBPC;  	break;  case BT_LT:  	throw new InvalidTokenException (off);  case BT_LF:  case BT_CR:  	normalized = false;  	/* fall through */goto default;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (t) {  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_AMP: {  	normalized = false;  	int saveNameEnd = token.NameEnd;  	scanRef (buf' off + minBPC' end' token);  	token.NameEnd = saveNameEnd;  	off = token.TokenEnd;  	break;  }  case BT_S:  	if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  		normalized = false;  	off += minBPC;  	break;  case BT_LT:  	throw new InvalidTokenException (off);  case BT_LF:  case BT_CR:  	normalized = false;  	/* fall through */goto default;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (t) {  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_AMP: {  	normalized = false;  	int saveNameEnd = token.NameEnd;  	scanRef (buf' off + minBPC' end' token);  	token.NameEnd = saveNameEnd;  	off = token.TokenEnd;  	break;  }  case BT_S:  	if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  		normalized = false;  	off += minBPC;  	break;  case BT_LT:  	throw new InvalidTokenException (off);  case BT_LF:  case BT_CR:  	normalized = false;  	/* fall through */goto default;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (t) {  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_AMP: {  	normalized = false;  	int saveNameEnd = token.NameEnd;  	scanRef (buf' off + minBPC' end' token);  	token.NameEnd = saveNameEnd;  	off = token.TokenEnd;  	break;  }  case BT_S:  	if (normalized && (off == valueStart || byteToAscii (buf' off) != ' ' || (off + minBPC != end && (byteToAscii (buf' off + minBPC) == ' ' || byteType (buf' off + minBPC) == open))))  		normalized = false;  	off += minBPC;  	break;  case BT_LT:  	throw new InvalidTokenException (off);  case BT_LF:  case BT_CR:  	normalized = false;  	/* fall through */goto default;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: off += 2;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: off += 3;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: off += 4;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: for (; ;) {  	switch (t) {  	case BT_NMSTRT:  		nameStart = off;  		off += minBPC;  		goto skipToName;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (byteType2 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		nameStart = off;  		off += 2;  		goto skipToName;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (byteType3 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		nameStart = off;  		off += 3;  		goto skipToName;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (byteType4 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		nameStart = off;  		off += 4;  		goto skipToName;  	case BT_S:  	case BT_CR:  	case BT_LF:  		break;  	case BT_GT:  		token.checkAttributeUniqueness (buf);  		token.TokenEnd = off + minBPC;  		return TOK.START_TAG_WITH_ATTS;  	case BT_SOL:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.checkAttributeUniqueness (buf);  		token.TokenEnd = off + minBPC;  		return TOK.EMPTY_ELEMENT_WITH_ATTS;  	default:  		throw new InvalidTokenException (off);  	}  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: for (; ;) {  	switch (t) {  	case BT_NMSTRT:  		nameStart = off;  		off += minBPC;  		goto skipToName;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (byteType2 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		nameStart = off;  		off += 2;  		goto skipToName;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (byteType3 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		nameStart = off;  		off += 3;  		goto skipToName;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (byteType4 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		nameStart = off;  		off += 4;  		goto skipToName;  	case BT_S:  	case BT_CR:  	case BT_LF:  		break;  	case BT_GT:  		token.checkAttributeUniqueness (buf);  		token.TokenEnd = off + minBPC;  		return TOK.START_TAG_WITH_ATTS;  	case BT_SOL:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.checkAttributeUniqueness (buf);  		token.TokenEnd = off + minBPC;  		return TOK.EMPTY_ELEMENT_WITH_ATTS;  	default:  		throw new InvalidTokenException (off);  	}  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: for (; ;) {  	switch (t) {  	case BT_NMSTRT:  		nameStart = off;  		off += minBPC;  		goto skipToName;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (byteType2 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		nameStart = off;  		off += 2;  		goto skipToName;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (byteType3 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		nameStart = off;  		off += 3;  		goto skipToName;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (byteType4 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		nameStart = off;  		off += 4;  		goto skipToName;  	case BT_S:  	case BT_CR:  	case BT_LF:  		break;  	case BT_GT:  		token.checkAttributeUniqueness (buf);  		token.TokenEnd = off + minBPC;  		return TOK.START_TAG_WITH_ATTS;  	case BT_SOL:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.checkAttributeUniqueness (buf);  		token.TokenEnd = off + minBPC;  		return TOK.EMPTY_ELEMENT_WITH_ATTS;  	default:  		throw new InvalidTokenException (off);  	}  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: for (; ;) {  	switch (t) {  	case BT_NMSTRT:  		nameStart = off;  		off += minBPC;  		goto skipToName;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (byteType2 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		nameStart = off;  		off += 2;  		goto skipToName;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (byteType3 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		nameStart = off;  		off += 3;  		goto skipToName;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (byteType4 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		nameStart = off;  		off += 4;  		goto skipToName;  	case BT_S:  	case BT_CR:  	case BT_LF:  		break;  	case BT_GT:  		token.checkAttributeUniqueness (buf);  		token.TokenEnd = off + minBPC;  		return TOK.START_TAG_WITH_ATTS;  	case BT_SOL:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.checkAttributeUniqueness (buf);  		token.TokenEnd = off + minBPC;  		return TOK.EMPTY_ELEMENT_WITH_ATTS;  	default:  		throw new InvalidTokenException (off);  	}  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: for (; ;) {  	switch (t) {  	case BT_NMSTRT:  		nameStart = off;  		off += minBPC;  		goto skipToName;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (byteType2 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		nameStart = off;  		off += 2;  		goto skipToName;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (byteType3 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		nameStart = off;  		off += 3;  		goto skipToName;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (byteType4 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		nameStart = off;  		off += 4;  		goto skipToName;  	case BT_S:  	case BT_CR:  	case BT_LF:  		break;  	case BT_GT:  		token.checkAttributeUniqueness (buf);  		token.TokenEnd = off + minBPC;  		return TOK.START_TAG_WITH_ATTS;  	case BT_SOL:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.checkAttributeUniqueness (buf);  		token.TokenEnd = off + minBPC;  		return TOK.EMPTY_ELEMENT_WITH_ATTS;  	default:  		throw new InvalidTokenException (off);  	}  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: for (; ;) {  	switch (t) {  	case BT_NMSTRT:  		nameStart = off;  		off += minBPC;  		goto skipToName;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (byteType2 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		nameStart = off;  		off += 2;  		goto skipToName;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (byteType3 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		nameStart = off;  		off += 3;  		goto skipToName;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (byteType4 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		nameStart = off;  		off += 4;  		goto skipToName;  	case BT_S:  	case BT_CR:  	case BT_LF:  		break;  	case BT_GT:  		token.checkAttributeUniqueness (buf);  		token.TokenEnd = off + minBPC;  		return TOK.START_TAG_WITH_ATTS;  	case BT_SOL:  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.checkAttributeUniqueness (buf);  		token.TokenEnd = off + minBPC;  		return TOK.EMPTY_ELEMENT_WITH_ATTS;  	default:  		throw new InvalidTokenException (off);  	}  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	t = byteType (buf' off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (t) {  case BT_NMSTRT:  	nameStart = off;  	off += minBPC;  	goto skipToName;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	nameStart = off;  	off += 2;  	goto skipToName;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	nameStart = off;  	off += 3;  	goto skipToName;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	nameStart = off;  	off += 4;  	goto skipToName;  case BT_S:  case BT_CR:  case BT_LF:  	break;  case BT_GT:  	token.checkAttributeUniqueness (buf);  	token.TokenEnd = off + minBPC;  	return TOK.START_TAG_WITH_ATTS;  case BT_SOL:  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.checkAttributeUniqueness (buf);  	token.TokenEnd = off + minBPC;  	return TOK.EMPTY_ELEMENT_WITH_ATTS;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (t) {  case BT_NMSTRT:  	nameStart = off;  	off += minBPC;  	goto skipToName;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	nameStart = off;  	off += 2;  	goto skipToName;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	nameStart = off;  	off += 3;  	goto skipToName;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	nameStart = off;  	off += 4;  	goto skipToName;  case BT_S:  case BT_CR:  case BT_LF:  	break;  case BT_GT:  	token.checkAttributeUniqueness (buf);  	token.TokenEnd = off + minBPC;  	return TOK.START_TAG_WITH_ATTS;  case BT_SOL:  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.checkAttributeUniqueness (buf);  	token.TokenEnd = off + minBPC;  	return TOK.EMPTY_ELEMENT_WITH_ATTS;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (t) {  case BT_NMSTRT:  	nameStart = off;  	off += minBPC;  	goto skipToName;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	nameStart = off;  	off += 2;  	goto skipToName;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	nameStart = off;  	off += 3;  	goto skipToName;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	nameStart = off;  	off += 4;  	goto skipToName;  case BT_S:  case BT_CR:  case BT_LF:  	break;  case BT_GT:  	token.checkAttributeUniqueness (buf);  	token.TokenEnd = off + minBPC;  	return TOK.START_TAG_WITH_ATTS;  case BT_SOL:  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.checkAttributeUniqueness (buf);  	token.TokenEnd = off + minBPC;  	return TOK.EMPTY_ELEMENT_WITH_ATTS;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (t) {  case BT_NMSTRT:  	nameStart = off;  	off += minBPC;  	goto skipToName;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	nameStart = off;  	off += 2;  	goto skipToName;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	nameStart = off;  	off += 3;  	goto skipToName;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	nameStart = off;  	off += 4;  	goto skipToName;  case BT_S:  case BT_CR:  case BT_LF:  	break;  case BT_GT:  	token.checkAttributeUniqueness (buf);  	token.TokenEnd = off + minBPC;  	return TOK.START_TAG_WITH_ATTS;  case BT_SOL:  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.checkAttributeUniqueness (buf);  	token.TokenEnd = off + minBPC;  	return TOK.EMPTY_ELEMENT_WITH_ATTS;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (t) {  case BT_NMSTRT:  	nameStart = off;  	off += minBPC;  	goto skipToName;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	nameStart = off;  	off += 2;  	goto skipToName;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	nameStart = off;  	off += 3;  	goto skipToName;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	nameStart = off;  	off += 4;  	goto skipToName;  case BT_S:  case BT_CR:  case BT_LF:  	break;  case BT_GT:  	token.checkAttributeUniqueness (buf);  	token.TokenEnd = off + minBPC;  	return TOK.START_TAG_WITH_ATTS;  case BT_SOL:  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.checkAttributeUniqueness (buf);  	token.TokenEnd = off + minBPC;  	return TOK.EMPTY_ELEMENT_WITH_ATTS;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: switch (t) {  case BT_NMSTRT:  	nameStart = off;  	off += minBPC;  	goto skipToName;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	nameStart = off;  	off += 2;  	goto skipToName;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	nameStart = off;  	off += 3;  	goto skipToName;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	nameStart = off;  	off += 4;  	goto skipToName;  case BT_S:  case BT_CR:  case BT_LF:  	break;  case BT_GT:  	token.checkAttributeUniqueness (buf);  	token.TokenEnd = off + minBPC;  	return TOK.START_TAG_WITH_ATTS;  case BT_SOL:  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.checkAttributeUniqueness (buf);  	token.TokenEnd = off + minBPC;  	return TOK.EMPTY_ELEMENT_WITH_ATTS;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: off += 2;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: off += 3;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanAtts,The following statement contains a magic number: off += 4;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_EXCL:  	if ((off += minBPC) == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_MINUS:  		return scanComment (buf' off + minBPC' end' token);  	case BT_LSQB:  		return scanCdataSection (buf' off + minBPC' end' token);  	}  	throw new InvalidTokenException (off);  case BT_QUEST:  	return scanPi (buf' off + minBPC' end' token);  case BT_SOL:  	return scanEndTag (buf' off + minBPC' end' token);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_EXCL:  	if ((off += minBPC) == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_MINUS:  		return scanComment (buf' off + minBPC' end' token);  	case BT_LSQB:  		return scanCdataSection (buf' off + minBPC' end' token);  	}  	throw new InvalidTokenException (off);  case BT_QUEST:  	return scanPi (buf' off + minBPC' end' token);  case BT_SOL:  	return scanEndTag (buf' off + minBPC' end' token);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_EXCL:  	if ((off += minBPC) == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_MINUS:  		return scanComment (buf' off + minBPC' end' token);  	case BT_LSQB:  		return scanCdataSection (buf' off + minBPC' end' token);  	}  	throw new InvalidTokenException (off);  case BT_QUEST:  	return scanPi (buf' off + minBPC' end' token);  case BT_SOL:  	return scanEndTag (buf' off + minBPC' end' token);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_EXCL:  	if ((off += minBPC) == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_MINUS:  		return scanComment (buf' off + minBPC' end' token);  	case BT_LSQB:  		return scanCdataSection (buf' off + minBPC' end' token);  	}  	throw new InvalidTokenException (off);  case BT_QUEST:  	return scanPi (buf' off + minBPC' end' token);  case BT_SOL:  	return scanEndTag (buf' off + minBPC' end' token);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_EXCL:  	if ((off += minBPC) == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_MINUS:  		return scanComment (buf' off + minBPC' end' token);  	case BT_LSQB:  		return scanCdataSection (buf' off + minBPC' end' token);  	}  	throw new InvalidTokenException (off);  case BT_QUEST:  	return scanPi (buf' off + minBPC' end' token);  case BT_SOL:  	return scanEndTag (buf' off + minBPC' end' token);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_EXCL:  	if ((off += minBPC) == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_MINUS:  		return scanComment (buf' off + minBPC' end' token);  	case BT_LSQB:  		return scanCdataSection (buf' off + minBPC' end' token);  	}  	throw new InvalidTokenException (off);  case BT_QUEST:  	return scanPi (buf' off + minBPC' end' token);  case BT_SOL:  	return scanEndTag (buf' off + minBPC' end' token);  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: off += 2;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: off += 3;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: off += 4;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.NameEnd = off;  		off += minBPC;  		for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_NMSTRT:  				return scanAtts (off' buf' off + minBPC' end' token);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 2' end' token);  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 3' end' token);  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 4' end' token);  			case BT_GT:  			case BT_SOL:  				goto loop;  			case BT_S:  			case BT_CR:  			case BT_LF:  				off += minBPC;  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		break;  	case BT_GT:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.START_TAG_NO_ATTS;  	case BT_SOL:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return TOK.EMPTY_ELEMENT_NO_ATTS;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.NameEnd = off;  		off += minBPC;  		for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_NMSTRT:  				return scanAtts (off' buf' off + minBPC' end' token);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 2' end' token);  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 3' end' token);  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 4' end' token);  			case BT_GT:  			case BT_SOL:  				goto loop;  			case BT_S:  			case BT_CR:  			case BT_LF:  				off += minBPC;  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		break;  	case BT_GT:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.START_TAG_NO_ATTS;  	case BT_SOL:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return TOK.EMPTY_ELEMENT_NO_ATTS;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.NameEnd = off;  		off += minBPC;  		for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_NMSTRT:  				return scanAtts (off' buf' off + minBPC' end' token);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 2' end' token);  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 3' end' token);  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 4' end' token);  			case BT_GT:  			case BT_SOL:  				goto loop;  			case BT_S:  			case BT_CR:  			case BT_LF:  				off += minBPC;  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		break;  	case BT_GT:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.START_TAG_NO_ATTS;  	case BT_SOL:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return TOK.EMPTY_ELEMENT_NO_ATTS;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.NameEnd = off;  		off += minBPC;  		for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_NMSTRT:  				return scanAtts (off' buf' off + minBPC' end' token);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 2' end' token);  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 3' end' token);  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 4' end' token);  			case BT_GT:  			case BT_SOL:  				goto loop;  			case BT_S:  			case BT_CR:  			case BT_LF:  				off += minBPC;  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		break;  	case BT_GT:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.START_TAG_NO_ATTS;  	case BT_SOL:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return TOK.EMPTY_ELEMENT_NO_ATTS;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.NameEnd = off;  		off += minBPC;  		for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_NMSTRT:  				return scanAtts (off' buf' off + minBPC' end' token);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 2' end' token);  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 3' end' token);  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 4' end' token);  			case BT_GT:  			case BT_SOL:  				goto loop;  			case BT_S:  			case BT_CR:  			case BT_LF:  				off += minBPC;  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		break;  	case BT_GT:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.START_TAG_NO_ATTS;  	case BT_SOL:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return TOK.EMPTY_ELEMENT_NO_ATTS;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.NameEnd = off;  		off += minBPC;  		for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_NMSTRT:  				return scanAtts (off' buf' off + minBPC' end' token);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 2' end' token);  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 3' end' token);  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 4' end' token);  			case BT_GT:  			case BT_SOL:  				goto loop;  			case BT_S:  			case BT_CR:  			case BT_LF:  				off += minBPC;  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		break;  	case BT_GT:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.START_TAG_NO_ATTS;  	case BT_SOL:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return TOK.EMPTY_ELEMENT_NO_ATTS;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.NameEnd = off;  		off += minBPC;  		for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_NMSTRT:  				return scanAtts (off' buf' off + minBPC' end' token);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 2' end' token);  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 3' end' token);  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 4' end' token);  			case BT_GT:  			case BT_SOL:  				goto loop;  			case BT_S:  			case BT_CR:  			case BT_LF:  				off += minBPC;  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		break;  	case BT_GT:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.START_TAG_NO_ATTS;  	case BT_SOL:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return TOK.EMPTY_ELEMENT_NO_ATTS;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.NameEnd = off;  		off += minBPC;  		for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_NMSTRT:  				return scanAtts (off' buf' off + minBPC' end' token);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 2' end' token);  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 3' end' token);  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 4' end' token);  			case BT_GT:  			case BT_SOL:  				goto loop;  			case BT_S:  			case BT_CR:  			case BT_LF:  				off += minBPC;  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		break;  	case BT_GT:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.START_TAG_NO_ATTS;  	case BT_SOL:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return TOK.EMPTY_ELEMENT_NO_ATTS;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.NameEnd = off;  		off += minBPC;  		for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_NMSTRT:  				return scanAtts (off' buf' off + minBPC' end' token);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 2' end' token);  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 3' end' token);  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 4' end' token);  			case BT_GT:  			case BT_SOL:  				goto loop;  			case BT_S:  			case BT_CR:  			case BT_LF:  				off += minBPC;  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		break;  	case BT_GT:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.START_TAG_NO_ATTS;  	case BT_SOL:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return TOK.EMPTY_ELEMENT_NO_ATTS;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.NameEnd = off;  		off += minBPC;  		for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_NMSTRT:  				return scanAtts (off' buf' off + minBPC' end' token);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 2' end' token);  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 3' end' token);  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 4' end' token);  			case BT_GT:  			case BT_SOL:  				goto loop;  			case BT_S:  			case BT_CR:  			case BT_LF:  				off += minBPC;  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		break;  	case BT_GT:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.START_TAG_NO_ATTS;  	case BT_SOL:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return TOK.EMPTY_ELEMENT_NO_ATTS;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.NameEnd = off;  		off += minBPC;  		for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_NMSTRT:  				return scanAtts (off' buf' off + minBPC' end' token);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 2' end' token);  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 3' end' token);  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 4' end' token);  			case BT_GT:  			case BT_SOL:  				goto loop;  			case BT_S:  			case BT_CR:  			case BT_LF:  				off += minBPC;  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		break;  	case BT_GT:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.START_TAG_NO_ATTS;  	case BT_SOL:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return TOK.EMPTY_ELEMENT_NO_ATTS;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.NameEnd = off;  		off += minBPC;  		for (; ;) {  			if (off == end)  				throw new PartialTokenException ();  			switch (byteType (buf' off)) {  			case BT_NMSTRT:  				return scanAtts (off' buf' off + minBPC' end' token);  			case BT_LEAD2:  				if (end - off < 2)  					throw new PartialCharException (off);  				if (byteType2 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 2' end' token);  			case BT_LEAD3:  				if (end - off < 3)  					throw new PartialCharException (off);  				if (byteType3 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 3' end' token);  			case BT_LEAD4:  				if (end - off < 4)  					throw new PartialCharException (off);  				if (byteType4 (buf' off) != BT_NMSTRT)  					throw new InvalidTokenException (off);  				return scanAtts (off' buf' off + 4' end' token);  			case BT_GT:  			case BT_SOL:  				goto loop;  			case BT_S:  			case BT_CR:  			case BT_LF:  				off += minBPC;  				break;  			default:  				throw new InvalidTokenException (off);  			}  		}  		loop:  		break;  	case BT_GT:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.START_TAG_NO_ATTS;  	case BT_SOL:  		if (token.NameEnd < 0)  			token.NameEnd = off;  		off += minBPC;  		if (off == end)  			throw new PartialTokenException ();  		checkCharMatches (buf' off' '>');  		token.TokenEnd = off + minBPC;  		return TOK.EMPTY_ELEMENT_NO_ATTS;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	token.NameEnd = off;  	off += minBPC;  	for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_NMSTRT:  			return scanAtts (off' buf' off + minBPC' end' token);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 2' end' token);  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 3' end' token);  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 4' end' token);  		case BT_GT:  		case BT_SOL:  			goto loop;  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	break;  case BT_GT:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.START_TAG_NO_ATTS;  case BT_SOL:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return TOK.EMPTY_ELEMENT_NO_ATTS;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	token.NameEnd = off;  	off += minBPC;  	for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_NMSTRT:  			return scanAtts (off' buf' off + minBPC' end' token);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 2' end' token);  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 3' end' token);  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 4' end' token);  		case BT_GT:  		case BT_SOL:  			goto loop;  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	break;  case BT_GT:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.START_TAG_NO_ATTS;  case BT_SOL:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return TOK.EMPTY_ELEMENT_NO_ATTS;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	token.NameEnd = off;  	off += minBPC;  	for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_NMSTRT:  			return scanAtts (off' buf' off + minBPC' end' token);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 2' end' token);  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 3' end' token);  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 4' end' token);  		case BT_GT:  		case BT_SOL:  			goto loop;  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	break;  case BT_GT:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.START_TAG_NO_ATTS;  case BT_SOL:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return TOK.EMPTY_ELEMENT_NO_ATTS;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	token.NameEnd = off;  	off += minBPC;  	for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_NMSTRT:  			return scanAtts (off' buf' off + minBPC' end' token);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 2' end' token);  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 3' end' token);  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 4' end' token);  		case BT_GT:  		case BT_SOL:  			goto loop;  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	break;  case BT_GT:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.START_TAG_NO_ATTS;  case BT_SOL:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return TOK.EMPTY_ELEMENT_NO_ATTS;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	token.NameEnd = off;  	off += minBPC;  	for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_NMSTRT:  			return scanAtts (off' buf' off + minBPC' end' token);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 2' end' token);  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 3' end' token);  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 4' end' token);  		case BT_GT:  		case BT_SOL:  			goto loop;  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	break;  case BT_GT:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.START_TAG_NO_ATTS;  case BT_SOL:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return TOK.EMPTY_ELEMENT_NO_ATTS;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	token.NameEnd = off;  	off += minBPC;  	for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_NMSTRT:  			return scanAtts (off' buf' off + minBPC' end' token);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 2' end' token);  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 3' end' token);  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 4' end' token);  		case BT_GT:  		case BT_SOL:  			goto loop;  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	break;  case BT_GT:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.START_TAG_NO_ATTS;  case BT_SOL:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return TOK.EMPTY_ELEMENT_NO_ATTS;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	token.NameEnd = off;  	off += minBPC;  	for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_NMSTRT:  			return scanAtts (off' buf' off + minBPC' end' token);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 2' end' token);  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 3' end' token);  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 4' end' token);  		case BT_GT:  		case BT_SOL:  			goto loop;  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	break;  case BT_GT:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.START_TAG_NO_ATTS;  case BT_SOL:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return TOK.EMPTY_ELEMENT_NO_ATTS;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	token.NameEnd = off;  	off += minBPC;  	for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_NMSTRT:  			return scanAtts (off' buf' off + minBPC' end' token);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 2' end' token);  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 3' end' token);  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 4' end' token);  		case BT_GT:  		case BT_SOL:  			goto loop;  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	break;  case BT_GT:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.START_TAG_NO_ATTS;  case BT_SOL:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return TOK.EMPTY_ELEMENT_NO_ATTS;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	token.NameEnd = off;  	off += minBPC;  	for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_NMSTRT:  			return scanAtts (off' buf' off + minBPC' end' token);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 2' end' token);  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 3' end' token);  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 4' end' token);  		case BT_GT:  		case BT_SOL:  			goto loop;  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	break;  case BT_GT:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.START_TAG_NO_ATTS;  case BT_SOL:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return TOK.EMPTY_ELEMENT_NO_ATTS;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	token.NameEnd = off;  	off += minBPC;  	for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_NMSTRT:  			return scanAtts (off' buf' off + minBPC' end' token);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 2' end' token);  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 3' end' token);  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 4' end' token);  		case BT_GT:  		case BT_SOL:  			goto loop;  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	break;  case BT_GT:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.START_TAG_NO_ATTS;  case BT_SOL:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return TOK.EMPTY_ELEMENT_NO_ATTS;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	token.NameEnd = off;  	off += minBPC;  	for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_NMSTRT:  			return scanAtts (off' buf' off + minBPC' end' token);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 2' end' token);  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 3' end' token);  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 4' end' token);  		case BT_GT:  		case BT_SOL:  			goto loop;  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	break;  case BT_GT:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.START_TAG_NO_ATTS;  case BT_SOL:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return TOK.EMPTY_ELEMENT_NO_ATTS;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_CR:  case BT_LF:  	token.NameEnd = off;  	off += minBPC;  	for (; ;) {  		if (off == end)  			throw new PartialTokenException ();  		switch (byteType (buf' off)) {  		case BT_NMSTRT:  			return scanAtts (off' buf' off + minBPC' end' token);  		case BT_LEAD2:  			if (end - off < 2)  				throw new PartialCharException (off);  			if (byteType2 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 2' end' token);  		case BT_LEAD3:  			if (end - off < 3)  				throw new PartialCharException (off);  			if (byteType3 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 3' end' token);  		case BT_LEAD4:  			if (end - off < 4)  				throw new PartialCharException (off);  			if (byteType4 (buf' off) != BT_NMSTRT)  				throw new InvalidTokenException (off);  			return scanAtts (off' buf' off + 4' end' token);  		case BT_GT:  		case BT_SOL:  			goto loop;  		case BT_S:  		case BT_CR:  		case BT_LF:  			off += minBPC;  			break;  		default:  			throw new InvalidTokenException (off);  		}  	}  	loop:  	break;  case BT_GT:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.START_TAG_NO_ATTS;  case BT_SOL:  	if (token.NameEnd < 0)  		token.NameEnd = off;  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	checkCharMatches (buf' off' '>');  	token.TokenEnd = off + minBPC;  	return TOK.EMPTY_ELEMENT_NO_ATTS;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: off += 2;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: off += 3;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: off += 4;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: for (; ;) {  	if (off == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  		return scanAtts (off' buf' off + minBPC' end' token);  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (byteType2 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		return scanAtts (off' buf' off + 2' end' token);  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (byteType3 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		return scanAtts (off' buf' off + 3' end' token);  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (byteType4 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		return scanAtts (off' buf' off + 4' end' token);  	case BT_GT:  	case BT_SOL:  		goto loop;  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		break;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: for (; ;) {  	if (off == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  		return scanAtts (off' buf' off + minBPC' end' token);  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (byteType2 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		return scanAtts (off' buf' off + 2' end' token);  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (byteType3 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		return scanAtts (off' buf' off + 3' end' token);  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (byteType4 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		return scanAtts (off' buf' off + 4' end' token);  	case BT_GT:  	case BT_SOL:  		goto loop;  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		break;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: for (; ;) {  	if (off == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  		return scanAtts (off' buf' off + minBPC' end' token);  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (byteType2 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		return scanAtts (off' buf' off + 2' end' token);  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (byteType3 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		return scanAtts (off' buf' off + 3' end' token);  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (byteType4 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		return scanAtts (off' buf' off + 4' end' token);  	case BT_GT:  	case BT_SOL:  		goto loop;  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		break;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: for (; ;) {  	if (off == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  		return scanAtts (off' buf' off + minBPC' end' token);  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (byteType2 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		return scanAtts (off' buf' off + 2' end' token);  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (byteType3 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		return scanAtts (off' buf' off + 3' end' token);  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (byteType4 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		return scanAtts (off' buf' off + 4' end' token);  	case BT_GT:  	case BT_SOL:  		goto loop;  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		break;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: for (; ;) {  	if (off == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  		return scanAtts (off' buf' off + minBPC' end' token);  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (byteType2 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		return scanAtts (off' buf' off + 2' end' token);  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (byteType3 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		return scanAtts (off' buf' off + 3' end' token);  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (byteType4 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		return scanAtts (off' buf' off + 4' end' token);  	case BT_GT:  	case BT_SOL:  		goto loop;  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		break;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: for (; ;) {  	if (off == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  		return scanAtts (off' buf' off + minBPC' end' token);  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (byteType2 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		return scanAtts (off' buf' off + 2' end' token);  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (byteType3 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		return scanAtts (off' buf' off + 3' end' token);  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (byteType4 (buf' off) != BT_NMSTRT)  			throw new InvalidTokenException (off);  		return scanAtts (off' buf' off + 4' end' token);  	case BT_GT:  	case BT_SOL:  		goto loop;  	case BT_S:  	case BT_CR:  	case BT_LF:  		off += minBPC;  		break;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	return scanAtts (off' buf' off + minBPC' end' token);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	return scanAtts (off' buf' off + 2' end' token);  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	return scanAtts (off' buf' off + 3' end' token);  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	return scanAtts (off' buf' off + 4' end' token);  case BT_GT:  case BT_SOL:  	goto loop;  case BT_S:  case BT_CR:  case BT_LF:  	off += minBPC;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	return scanAtts (off' buf' off + minBPC' end' token);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	return scanAtts (off' buf' off + 2' end' token);  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	return scanAtts (off' buf' off + 3' end' token);  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	return scanAtts (off' buf' off + 4' end' token);  case BT_GT:  case BT_SOL:  	goto loop;  case BT_S:  case BT_CR:  case BT_LF:  	off += minBPC;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	return scanAtts (off' buf' off + minBPC' end' token);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	return scanAtts (off' buf' off + 2' end' token);  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	return scanAtts (off' buf' off + 3' end' token);  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	return scanAtts (off' buf' off + 4' end' token);  case BT_GT:  case BT_SOL:  	goto loop;  case BT_S:  case BT_CR:  case BT_LF:  	off += minBPC;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	return scanAtts (off' buf' off + minBPC' end' token);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	return scanAtts (off' buf' off + 2' end' token);  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	return scanAtts (off' buf' off + 3' end' token);  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	return scanAtts (off' buf' off + 4' end' token);  case BT_GT:  case BT_SOL:  	goto loop;  case BT_S:  case BT_CR:  case BT_LF:  	off += minBPC;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	return scanAtts (off' buf' off + minBPC' end' token);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	return scanAtts (off' buf' off + 2' end' token);  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	return scanAtts (off' buf' off + 3' end' token);  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	return scanAtts (off' buf' off + 4' end' token);  case BT_GT:  case BT_SOL:  	goto loop;  case BT_S:  case BT_CR:  case BT_LF:  	off += minBPC;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	return scanAtts (off' buf' off + minBPC' end' token);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	return scanAtts (off' buf' off + 2' end' token);  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	return scanAtts (off' buf' off + 3' end' token);  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	return scanAtts (off' buf' off + 4' end' token);  case BT_GT:  case BT_SOL:  	goto loop;  case BT_S:  case BT_CR:  case BT_LF:  	off += minBPC;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: return scanAtts (off' buf' off + 2' end' token);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: return scanAtts (off' buf' off + 3' end' token);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following statement contains a magic number: return scanAtts (off' buf' off + 4' end' token);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeContent,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LT:  	return scanLt (buf' off + minBPC' end' token);  case BT_AMP:  	return scanRef (buf' off + minBPC' end' token);  case BT_CR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  	if (byteType (buf' off) == BT_LF)  		off += minBPC;  	token.TokenEnd = off;  	return TOK.DATA_NEWLINE;  case BT_LF:  	token.TokenEnd = off + minBPC;  	return TOK.DATA_NEWLINE;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_CHARS);  	if (!charMatches (buf' off' ']'))  		break;  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_CHARS);  	if (!charMatches (buf' off' '>')) {  		off -= minBPC;  		break;  	}  	throw new InvalidTokenException (off);  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeContent,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LT:  	return scanLt (buf' off + minBPC' end' token);  case BT_AMP:  	return scanRef (buf' off + minBPC' end' token);  case BT_CR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  	if (byteType (buf' off) == BT_LF)  		off += minBPC;  	token.TokenEnd = off;  	return TOK.DATA_NEWLINE;  case BT_LF:  	token.TokenEnd = off + minBPC;  	return TOK.DATA_NEWLINE;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_CHARS);  	if (!charMatches (buf' off' ']'))  		break;  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_CHARS);  	if (!charMatches (buf' off' '>')) {  		off -= minBPC;  		break;  	}  	throw new InvalidTokenException (off);  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeContent,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LT:  	return scanLt (buf' off + minBPC' end' token);  case BT_AMP:  	return scanRef (buf' off + minBPC' end' token);  case BT_CR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  	if (byteType (buf' off) == BT_LF)  		off += minBPC;  	token.TokenEnd = off;  	return TOK.DATA_NEWLINE;  case BT_LF:  	token.TokenEnd = off + minBPC;  	return TOK.DATA_NEWLINE;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_CHARS);  	if (!charMatches (buf' off' ']'))  		break;  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_CHARS);  	if (!charMatches (buf' off' '>')) {  		off -= minBPC;  		break;  	}  	throw new InvalidTokenException (off);  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeContent,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LT:  	return scanLt (buf' off + minBPC' end' token);  case BT_AMP:  	return scanRef (buf' off + minBPC' end' token);  case BT_CR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  	if (byteType (buf' off) == BT_LF)  		off += minBPC;  	token.TokenEnd = off;  	return TOK.DATA_NEWLINE;  case BT_LF:  	token.TokenEnd = off + minBPC;  	return TOK.DATA_NEWLINE;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_CHARS);  	if (!charMatches (buf' off' ']'))  		break;  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_CHARS);  	if (!charMatches (buf' off' '>')) {  		off -= minBPC;  		break;  	}  	throw new InvalidTokenException (off);  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeContent,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LT:  	return scanLt (buf' off + minBPC' end' token);  case BT_AMP:  	return scanRef (buf' off + minBPC' end' token);  case BT_CR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  	if (byteType (buf' off) == BT_LF)  		off += minBPC;  	token.TokenEnd = off;  	return TOK.DATA_NEWLINE;  case BT_LF:  	token.TokenEnd = off + minBPC;  	return TOK.DATA_NEWLINE;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_CHARS);  	if (!charMatches (buf' off' ']'))  		break;  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_CHARS);  	if (!charMatches (buf' off' '>')) {  		off -= minBPC;  		break;  	}  	throw new InvalidTokenException (off);  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeContent,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LT:  	return scanLt (buf' off + minBPC' end' token);  case BT_AMP:  	return scanRef (buf' off + minBPC' end' token);  case BT_CR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  	if (byteType (buf' off) == BT_LF)  		off += minBPC;  	token.TokenEnd = off;  	return TOK.DATA_NEWLINE;  case BT_LF:  	token.TokenEnd = off + minBPC;  	return TOK.DATA_NEWLINE;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_CHARS);  	if (!charMatches (buf' off' ']'))  		break;  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.DATA_CHARS);  	if (!charMatches (buf' off' '>')) {  		off -= minBPC;  		break;  	}  	throw new InvalidTokenException (off);  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeContent,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeContent,The following statement contains a magic number: off += 2;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeContent,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeContent,The following statement contains a magic number: off += 3;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeContent,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeContent,The following statement contains a magic number: off += 4;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,extendData,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			return off;  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			return off;  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			return off;  		check4 (buf' off);  		off += 4;  		break;  	case BT_RSQB:  	case BT_AMP:  	case BT_LT:  	case BT_NONXML:  	case BT_MALFORM:  	case BT_CR:  	case BT_LF:  		return off;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,extendData,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			return off;  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			return off;  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			return off;  		check4 (buf' off);  		off += 4;  		break;  	case BT_RSQB:  	case BT_AMP:  	case BT_LT:  	case BT_NONXML:  	case BT_MALFORM:  	case BT_CR:  	case BT_LF:  		return off;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,extendData,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			return off;  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			return off;  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			return off;  		check4 (buf' off);  		off += 4;  		break;  	case BT_RSQB:  	case BT_AMP:  	case BT_LT:  	case BT_NONXML:  	case BT_MALFORM:  	case BT_CR:  	case BT_LF:  		return off;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,extendData,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			return off;  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			return off;  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			return off;  		check4 (buf' off);  		off += 4;  		break;  	case BT_RSQB:  	case BT_AMP:  	case BT_LT:  	case BT_NONXML:  	case BT_MALFORM:  	case BT_CR:  	case BT_LF:  		return off;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,extendData,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			return off;  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			return off;  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			return off;  		check4 (buf' off);  		off += 4;  		break;  	case BT_RSQB:  	case BT_AMP:  	case BT_LT:  	case BT_NONXML:  	case BT_MALFORM:  	case BT_CR:  	case BT_LF:  		return off;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,extendData,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			return off;  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			return off;  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			return off;  		check4 (buf' off);  		off += 4;  		break;  	case BT_RSQB:  	case BT_AMP:  	case BT_LT:  	case BT_NONXML:  	case BT_MALFORM:  	case BT_CR:  	case BT_LF:  		return off;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,extendData,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		return off;  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		return off;  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		return off;  	check4 (buf' off);  	off += 4;  	break;  case BT_RSQB:  case BT_AMP:  case BT_LT:  case BT_NONXML:  case BT_MALFORM:  case BT_CR:  case BT_LF:  	return off;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,extendData,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		return off;  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		return off;  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		return off;  	check4 (buf' off);  	off += 4;  	break;  case BT_RSQB:  case BT_AMP:  case BT_LT:  case BT_NONXML:  case BT_MALFORM:  case BT_CR:  case BT_LF:  	return off;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,extendData,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		return off;  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		return off;  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		return off;  	check4 (buf' off);  	off += 4;  	break;  case BT_RSQB:  case BT_AMP:  case BT_LT:  case BT_NONXML:  case BT_MALFORM:  case BT_CR:  case BT_LF:  	return off;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,extendData,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		return off;  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		return off;  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		return off;  	check4 (buf' off);  	off += 4;  	break;  case BT_RSQB:  case BT_AMP:  case BT_LT:  case BT_NONXML:  case BT_MALFORM:  case BT_CR:  case BT_LF:  	return off;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,extendData,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		return off;  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		return off;  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		return off;  	check4 (buf' off);  	off += 4;  	break;  case BT_RSQB:  case BT_AMP:  case BT_LT:  case BT_NONXML:  case BT_MALFORM:  case BT_CR:  case BT_LF:  	return off;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,extendData,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		return off;  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		return off;  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		return off;  	check4 (buf' off);  	off += 4;  	break;  case BT_RSQB:  case BT_AMP:  case BT_LT:  case BT_NONXML:  case BT_MALFORM:  case BT_CR:  case BT_LF:  	return off;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,extendData,The following statement contains a magic number: if (end - off < 2)  	return off;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,extendData,The following statement contains a magic number: off += 2;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,extendData,The following statement contains a magic number: if (end - off < 3)  	return off;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,extendData,The following statement contains a magic number: off += 3;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,extendData,The following statement contains a magic number: if (end - off < 4)  	return off;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,extendData,The following statement contains a magic number: off += 4;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_LF:  case BT_CR:  case BT_PERCNT:  	token.TokenEnd = off;  	return TOK.PERCENT;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_LF:  case BT_CR:  case BT_PERCNT:  	token.TokenEnd = off;  	return TOK.PERCENT;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_LF:  case BT_CR:  case BT_PERCNT:  	token.TokenEnd = off;  	return TOK.PERCENT;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_LF:  case BT_CR:  case BT_PERCNT:  	token.TokenEnd = off;  	return TOK.PERCENT;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_LF:  case BT_CR:  case BT_PERCNT:  	token.TokenEnd = off;  	return TOK.PERCENT;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_S:  case BT_LF:  case BT_CR:  case BT_PERCNT:  	token.TokenEnd = off;  	return TOK.PERCENT;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: off += 2;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: off += 3;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: off += 4;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_SEMI:  		token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.PARAM_ENTITY_REF;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_SEMI:  		token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.PARAM_ENTITY_REF;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_SEMI:  		token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.PARAM_ENTITY_REF;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_SEMI:  		token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.PARAM_ENTITY_REF;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_SEMI:  		token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.PARAM_ENTITY_REF;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_SEMI:  		token.NameEnd = off;  		token.TokenEnd = off + minBPC;  		return TOK.PARAM_ENTITY_REF;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_SEMI:  	token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.PARAM_ENTITY_REF;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_SEMI:  	token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.PARAM_ENTITY_REF;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_SEMI:  	token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.PARAM_ENTITY_REF;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_SEMI:  	token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.PARAM_ENTITY_REF;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_SEMI:  	token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.PARAM_ENTITY_REF;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_SEMI:  	token.NameEnd = off;  	token.TokenEnd = off + minBPC;  	return TOK.PARAM_ENTITY_REF;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: off += 2;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: off += 3;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPercent,The following statement contains a magic number: off += 4;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (byteType2 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (byteType3 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (byteType4 (buf' off) != BT_NMSTRT)  		throw new InvalidTokenException (off);  	off += 4;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: off += 2;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: off += 3;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: off += 4;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_CR:  	case BT_LF:  	case BT_S:  	case BT_RPAR:  	case BT_GT:  	case BT_PERCNT:  	case BT_VERBAR:  		token.TokenEnd = off;  		return TOK.POUND_NAME;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_CR:  	case BT_LF:  	case BT_S:  	case BT_RPAR:  	case BT_GT:  	case BT_PERCNT:  	case BT_VERBAR:  		token.TokenEnd = off;  		return TOK.POUND_NAME;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_CR:  	case BT_LF:  	case BT_S:  	case BT_RPAR:  	case BT_GT:  	case BT_PERCNT:  	case BT_VERBAR:  		token.TokenEnd = off;  		return TOK.POUND_NAME;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_CR:  	case BT_LF:  	case BT_S:  	case BT_RPAR:  	case BT_GT:  	case BT_PERCNT:  	case BT_VERBAR:  		token.TokenEnd = off;  		return TOK.POUND_NAME;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_CR:  	case BT_LF:  	case BT_S:  	case BT_RPAR:  	case BT_GT:  	case BT_PERCNT:  	case BT_VERBAR:  		token.TokenEnd = off;  		return TOK.POUND_NAME;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_CR:  	case BT_LF:  	case BT_S:  	case BT_RPAR:  	case BT_GT:  	case BT_PERCNT:  	case BT_VERBAR:  		token.TokenEnd = off;  		return TOK.POUND_NAME;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_CR:  case BT_LF:  case BT_S:  case BT_RPAR:  case BT_GT:  case BT_PERCNT:  case BT_VERBAR:  	token.TokenEnd = off;  	return TOK.POUND_NAME;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_CR:  case BT_LF:  case BT_S:  case BT_RPAR:  case BT_GT:  case BT_PERCNT:  case BT_VERBAR:  	token.TokenEnd = off;  	return TOK.POUND_NAME;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_CR:  case BT_LF:  case BT_S:  case BT_RPAR:  case BT_GT:  case BT_PERCNT:  case BT_VERBAR:  	token.TokenEnd = off;  	return TOK.POUND_NAME;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_CR:  case BT_LF:  case BT_S:  case BT_RPAR:  case BT_GT:  case BT_PERCNT:  case BT_VERBAR:  	token.TokenEnd = off;  	return TOK.POUND_NAME;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_CR:  case BT_LF:  case BT_S:  case BT_RPAR:  case BT_GT:  case BT_PERCNT:  case BT_VERBAR:  	token.TokenEnd = off;  	return TOK.POUND_NAME;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_CR:  case BT_LF:  case BT_S:  case BT_RPAR:  case BT_GT:  case BT_PERCNT:  case BT_VERBAR:  	token.TokenEnd = off;  	return TOK.POUND_NAME;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: off += 2;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: off += 3;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanPoundName,The following statement contains a magic number: off += 4;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLit,The following statement contains a magic number: while (off != end) {  	int t = byteType (buf' off);  	switch (t) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialTokenException ();  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialTokenException ();  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialTokenException ();  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_QUOT:  	case BT_APOS:  		off += minBPC;  		if (t != open)  			break;  		if (off == end)  			throw new ExtensibleTokenException (TOK.LITERAL);  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_CR:  		case BT_LF:  		case BT_GT:  		case BT_PERCNT:  		case BT_LSQB:  			token.TokenEnd = off;  			return TOK.LITERAL;  		default:  			throw new InvalidTokenException (off);  		}  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLit,The following statement contains a magic number: while (off != end) {  	int t = byteType (buf' off);  	switch (t) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialTokenException ();  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialTokenException ();  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialTokenException ();  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_QUOT:  	case BT_APOS:  		off += minBPC;  		if (t != open)  			break;  		if (off == end)  			throw new ExtensibleTokenException (TOK.LITERAL);  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_CR:  		case BT_LF:  		case BT_GT:  		case BT_PERCNT:  		case BT_LSQB:  			token.TokenEnd = off;  			return TOK.LITERAL;  		default:  			throw new InvalidTokenException (off);  		}  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLit,The following statement contains a magic number: while (off != end) {  	int t = byteType (buf' off);  	switch (t) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialTokenException ();  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialTokenException ();  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialTokenException ();  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_QUOT:  	case BT_APOS:  		off += minBPC;  		if (t != open)  			break;  		if (off == end)  			throw new ExtensibleTokenException (TOK.LITERAL);  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_CR:  		case BT_LF:  		case BT_GT:  		case BT_PERCNT:  		case BT_LSQB:  			token.TokenEnd = off;  			return TOK.LITERAL;  		default:  			throw new InvalidTokenException (off);  		}  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLit,The following statement contains a magic number: while (off != end) {  	int t = byteType (buf' off);  	switch (t) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialTokenException ();  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialTokenException ();  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialTokenException ();  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_QUOT:  	case BT_APOS:  		off += minBPC;  		if (t != open)  			break;  		if (off == end)  			throw new ExtensibleTokenException (TOK.LITERAL);  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_CR:  		case BT_LF:  		case BT_GT:  		case BT_PERCNT:  		case BT_LSQB:  			token.TokenEnd = off;  			return TOK.LITERAL;  		default:  			throw new InvalidTokenException (off);  		}  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLit,The following statement contains a magic number: while (off != end) {  	int t = byteType (buf' off);  	switch (t) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialTokenException ();  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialTokenException ();  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialTokenException ();  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_QUOT:  	case BT_APOS:  		off += minBPC;  		if (t != open)  			break;  		if (off == end)  			throw new ExtensibleTokenException (TOK.LITERAL);  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_CR:  		case BT_LF:  		case BT_GT:  		case BT_PERCNT:  		case BT_LSQB:  			token.TokenEnd = off;  			return TOK.LITERAL;  		default:  			throw new InvalidTokenException (off);  		}  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLit,The following statement contains a magic number: while (off != end) {  	int t = byteType (buf' off);  	switch (t) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialTokenException ();  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialTokenException ();  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialTokenException ();  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_QUOT:  	case BT_APOS:  		off += minBPC;  		if (t != open)  			break;  		if (off == end)  			throw new ExtensibleTokenException (TOK.LITERAL);  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_CR:  		case BT_LF:  		case BT_GT:  		case BT_PERCNT:  		case BT_LSQB:  			token.TokenEnd = off;  			return TOK.LITERAL;  		default:  			throw new InvalidTokenException (off);  		}  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLit,The following statement contains a magic number: switch (t) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialTokenException ();  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialTokenException ();  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialTokenException ();  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_QUOT:  case BT_APOS:  	off += minBPC;  	if (t != open)  		break;  	if (off == end)  		throw new ExtensibleTokenException (TOK.LITERAL);  	switch (byteType (buf' off)) {  	case BT_S:  	case BT_CR:  	case BT_LF:  	case BT_GT:  	case BT_PERCNT:  	case BT_LSQB:  		token.TokenEnd = off;  		return TOK.LITERAL;  	default:  		throw new InvalidTokenException (off);  	}  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLit,The following statement contains a magic number: switch (t) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialTokenException ();  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialTokenException ();  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialTokenException ();  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_QUOT:  case BT_APOS:  	off += minBPC;  	if (t != open)  		break;  	if (off == end)  		throw new ExtensibleTokenException (TOK.LITERAL);  	switch (byteType (buf' off)) {  	case BT_S:  	case BT_CR:  	case BT_LF:  	case BT_GT:  	case BT_PERCNT:  	case BT_LSQB:  		token.TokenEnd = off;  		return TOK.LITERAL;  	default:  		throw new InvalidTokenException (off);  	}  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLit,The following statement contains a magic number: switch (t) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialTokenException ();  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialTokenException ();  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialTokenException ();  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_QUOT:  case BT_APOS:  	off += minBPC;  	if (t != open)  		break;  	if (off == end)  		throw new ExtensibleTokenException (TOK.LITERAL);  	switch (byteType (buf' off)) {  	case BT_S:  	case BT_CR:  	case BT_LF:  	case BT_GT:  	case BT_PERCNT:  	case BT_LSQB:  		token.TokenEnd = off;  		return TOK.LITERAL;  	default:  		throw new InvalidTokenException (off);  	}  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLit,The following statement contains a magic number: switch (t) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialTokenException ();  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialTokenException ();  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialTokenException ();  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_QUOT:  case BT_APOS:  	off += minBPC;  	if (t != open)  		break;  	if (off == end)  		throw new ExtensibleTokenException (TOK.LITERAL);  	switch (byteType (buf' off)) {  	case BT_S:  	case BT_CR:  	case BT_LF:  	case BT_GT:  	case BT_PERCNT:  	case BT_LSQB:  		token.TokenEnd = off;  		return TOK.LITERAL;  	default:  		throw new InvalidTokenException (off);  	}  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLit,The following statement contains a magic number: switch (t) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialTokenException ();  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialTokenException ();  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialTokenException ();  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_QUOT:  case BT_APOS:  	off += minBPC;  	if (t != open)  		break;  	if (off == end)  		throw new ExtensibleTokenException (TOK.LITERAL);  	switch (byteType (buf' off)) {  	case BT_S:  	case BT_CR:  	case BT_LF:  	case BT_GT:  	case BT_PERCNT:  	case BT_LSQB:  		token.TokenEnd = off;  		return TOK.LITERAL;  	default:  		throw new InvalidTokenException (off);  	}  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLit,The following statement contains a magic number: switch (t) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialTokenException ();  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialTokenException ();  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialTokenException ();  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_QUOT:  case BT_APOS:  	off += minBPC;  	if (t != open)  		break;  	if (off == end)  		throw new ExtensibleTokenException (TOK.LITERAL);  	switch (byteType (buf' off)) {  	case BT_S:  	case BT_CR:  	case BT_LF:  	case BT_GT:  	case BT_PERCNT:  	case BT_LSQB:  		token.TokenEnd = off;  		return TOK.LITERAL;  	default:  		throw new InvalidTokenException (off);  	}  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLit,The following statement contains a magic number: if (end - off < 2)  	throw new PartialTokenException ();  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLit,The following statement contains a magic number: off += 2;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLit,The following statement contains a magic number: if (end - off < 3)  	throw new PartialTokenException ();  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLit,The following statement contains a magic number: off += 3;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLit,The following statement contains a magic number: if (end - off < 4)  	throw new PartialTokenException ();  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLit,The following statement contains a magic number: off += 4;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: switch (end - off) {  case 0:  	break;  case 1:  	if (buf [off] > 127)  		return null;  	break;  default:  	int b0 = buf [off] & 0xFF;  	int b1 = buf [off + 1] & 0xFF;  	switch ((b0 << 8) | b1) {  	case 0xFEFF:  		token.TokenEnd = off + 2;  		/* fall through */goto case '<';  	case '<':  		/* not legal; but not a fatal error */return getEncoding (UTF16_BIG_ENDIAN_ENCODING);  	case 0xFFFE:  		token.TokenEnd = off + 2;  		/* fall through */goto case '<' << 8;  	case '<' << 8:  		/* not legal; but not a fatal error */return getEncoding (UTF16_LITTLE_ENDIAN_ENCODING);  	}  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: switch (end - off) {  case 0:  	break;  case 1:  	if (buf [off] > 127)  		return null;  	break;  default:  	int b0 = buf [off] & 0xFF;  	int b1 = buf [off + 1] & 0xFF;  	switch ((b0 << 8) | b1) {  	case 0xFEFF:  		token.TokenEnd = off + 2;  		/* fall through */goto case '<';  	case '<':  		/* not legal; but not a fatal error */return getEncoding (UTF16_BIG_ENDIAN_ENCODING);  	case 0xFFFE:  		token.TokenEnd = off + 2;  		/* fall through */goto case '<' << 8;  	case '<' << 8:  		/* not legal; but not a fatal error */return getEncoding (UTF16_LITTLE_ENDIAN_ENCODING);  	}  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: switch (end - off) {  case 0:  	break;  case 1:  	if (buf [off] > 127)  		return null;  	break;  default:  	int b0 = buf [off] & 0xFF;  	int b1 = buf [off + 1] & 0xFF;  	switch ((b0 << 8) | b1) {  	case 0xFEFF:  		token.TokenEnd = off + 2;  		/* fall through */goto case '<';  	case '<':  		/* not legal; but not a fatal error */return getEncoding (UTF16_BIG_ENDIAN_ENCODING);  	case 0xFFFE:  		token.TokenEnd = off + 2;  		/* fall through */goto case '<' << 8;  	case '<' << 8:  		/* not legal; but not a fatal error */return getEncoding (UTF16_LITTLE_ENDIAN_ENCODING);  	}  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: switch (end - off) {  case 0:  	break;  case 1:  	if (buf [off] > 127)  		return null;  	break;  default:  	int b0 = buf [off] & 0xFF;  	int b1 = buf [off + 1] & 0xFF;  	switch ((b0 << 8) | b1) {  	case 0xFEFF:  		token.TokenEnd = off + 2;  		/* fall through */goto case '<';  	case '<':  		/* not legal; but not a fatal error */return getEncoding (UTF16_BIG_ENDIAN_ENCODING);  	case 0xFFFE:  		token.TokenEnd = off + 2;  		/* fall through */goto case '<' << 8;  	case '<' << 8:  		/* not legal; but not a fatal error */return getEncoding (UTF16_LITTLE_ENDIAN_ENCODING);  	}  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: switch (end - off) {  case 0:  	break;  case 1:  	if (buf [off] > 127)  		return null;  	break;  default:  	int b0 = buf [off] & 0xFF;  	int b1 = buf [off + 1] & 0xFF;  	switch ((b0 << 8) | b1) {  	case 0xFEFF:  		token.TokenEnd = off + 2;  		/* fall through */goto case '<';  	case '<':  		/* not legal; but not a fatal error */return getEncoding (UTF16_BIG_ENDIAN_ENCODING);  	case 0xFFFE:  		token.TokenEnd = off + 2;  		/* fall through */goto case '<' << 8;  	case '<' << 8:  		/* not legal; but not a fatal error */return getEncoding (UTF16_LITTLE_ENDIAN_ENCODING);  	}  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: switch (end - off) {  case 0:  	break;  case 1:  	if (buf [off] > 127)  		return null;  	break;  default:  	int b0 = buf [off] & 0xFF;  	int b1 = buf [off + 1] & 0xFF;  	switch ((b0 << 8) | b1) {  	case 0xFEFF:  		token.TokenEnd = off + 2;  		/* fall through */goto case '<';  	case '<':  		/* not legal; but not a fatal error */return getEncoding (UTF16_BIG_ENDIAN_ENCODING);  	case 0xFFFE:  		token.TokenEnd = off + 2;  		/* fall through */goto case '<' << 8;  	case '<' << 8:  		/* not legal; but not a fatal error */return getEncoding (UTF16_LITTLE_ENDIAN_ENCODING);  	}  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: if (buf [off] > 127)  	return null;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: switch ((b0 << 8) | b1) {  case 0xFEFF:  	token.TokenEnd = off + 2;  	/* fall through */goto case '<';  case '<':  	/* not legal; but not a fatal error */return getEncoding (UTF16_BIG_ENDIAN_ENCODING);  case 0xFFFE:  	token.TokenEnd = off + 2;  	/* fall through */goto case '<' << 8;  case '<' << 8:  	/* not legal; but not a fatal error */return getEncoding (UTF16_LITTLE_ENDIAN_ENCODING);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: switch ((b0 << 8) | b1) {  case 0xFEFF:  	token.TokenEnd = off + 2;  	/* fall through */goto case '<';  case '<':  	/* not legal; but not a fatal error */return getEncoding (UTF16_BIG_ENDIAN_ENCODING);  case 0xFFFE:  	token.TokenEnd = off + 2;  	/* fall through */goto case '<' << 8;  case '<' << 8:  	/* not legal; but not a fatal error */return getEncoding (UTF16_LITTLE_ENDIAN_ENCODING);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: switch ((b0 << 8) | b1) {  case 0xFEFF:  	token.TokenEnd = off + 2;  	/* fall through */goto case '<';  case '<':  	/* not legal; but not a fatal error */return getEncoding (UTF16_BIG_ENDIAN_ENCODING);  case 0xFFFE:  	token.TokenEnd = off + 2;  	/* fall through */goto case '<' << 8;  case '<' << 8:  	/* not legal; but not a fatal error */return getEncoding (UTF16_LITTLE_ENDIAN_ENCODING);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: switch ((b0 << 8) | b1) {  case 0xFEFF:  	token.TokenEnd = off + 2;  	/* fall through */goto case '<';  case '<':  	/* not legal; but not a fatal error */return getEncoding (UTF16_BIG_ENDIAN_ENCODING);  case 0xFFFE:  	token.TokenEnd = off + 2;  	/* fall through */goto case '<' << 8;  case '<' << 8:  	/* not legal; but not a fatal error */return getEncoding (UTF16_LITTLE_ENDIAN_ENCODING);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: switch ((b0 << 8) | b1) {  case 0xFEFF:  	token.TokenEnd = off + 2;  	/* fall through */goto case '<';  case '<':  	/* not legal; but not a fatal error */return getEncoding (UTF16_BIG_ENDIAN_ENCODING);  case 0xFFFE:  	token.TokenEnd = off + 2;  	/* fall through */goto case '<' << 8;  case '<' << 8:  	/* not legal; but not a fatal error */return getEncoding (UTF16_LITTLE_ENDIAN_ENCODING);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: token.TokenEnd = off + 2;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: token.TokenEnd = off + 2;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,getInitialEncoding,The following statement contains a magic number: goto case '<' << 8;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_QUOT:  	return scanLit (BT_QUOT' buf' off + minBPC' end' token);  case BT_APOS:  	return scanLit (BT_APOS' buf' off + minBPC' end' token);  case BT_LT: {  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_EXCL:  		return scanDecl (buf' off + minBPC' end' token);  	case BT_QUEST:  		return scanPi (buf' off + minBPC' end' token);  	case BT_NMSTRT:  	case BT_LEAD2:  	case BT_LEAD3:  	case BT_LEAD4:  		token.TokenEnd = off - minBPC;  		throw new EndOfPrologException ();  	}  	throw new InvalidTokenException (off);  }  case BT_CR:  	if (off + minBPC == end)  		throw new ExtensibleTokenException (TOK.PROLOG_S);  	/* fall through */goto case BT_S;  case BT_S:  case BT_LF:  	for (; ;) {  		off += minBPC;  		if (off == end)  			break;  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_LF:  			break;  		case BT_CR:  			/* don't split CR/LF pair */if (off + minBPC != end)  				break;  			/* fall through */goto default;  		default:  			token.TokenEnd = off;  			return TOK.PROLOG_S;  		}  	}  	token.TokenEnd = off;  	return TOK.PROLOG_S;  case BT_PERCNT:  	return scanPercent (buf' off + minBPC' end' token);  case BT_COMMA:  	token.TokenEnd = off + minBPC;  	return TOK.COMMA;  case BT_LSQB:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_BRACKET;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_BRACKET);  	if (charMatches (buf' off' ']')) {  		if (off + minBPC == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off + minBPC' '>')) {  			token.TokenEnd = off + 2 * minBPC;  			return TOK.COND_SECT_CLOSE;  		}  	}  	token.TokenEnd = off;  	return TOK.CLOSE_BRACKET;  case BT_LPAR:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_PAREN;  case BT_RPAR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_PAREN);  	switch (byteType (buf' off)) {  	case BT_AST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_ASTERISK;  	case BT_QUEST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_QUESTION;  	case BT_PLUS:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_PLUS;  	case BT_CR:  	case BT_LF:  	case BT_S:  	case BT_GT:  	case BT_COMMA:  	case BT_VERBAR:  	case BT_RPAR:  		token.TokenEnd = off;  		return TOK.CLOSE_PAREN;  	}  	throw new InvalidTokenException (off);  case BT_VERBAR:  	token.TokenEnd = off + minBPC;  	return TOK.OR;  case BT_GT:  	token.TokenEnd = off + minBPC;  	return TOK.DECL_CLOSE;  case BT_NUM:  	return scanPoundName (buf' off + minBPC' end' token);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	switch (byteType2 (buf' off)) {  	case BT_NMSTRT:  		off += 2;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 2;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	switch (byteType3 (buf' off)) {  	case BT_NMSTRT:  		off += 3;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 3;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	switch (byteType4 (buf' off)) {  	case BT_NMSTRT:  		off += 4;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 4;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_NMSTRT:  	tok = TOK.NAME;  	off += minBPC;  	break;  case BT_NAME:  case BT_MINUS:  	tok = TOK.NMTOKEN;  	off += minBPC;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_QUOT:  	return scanLit (BT_QUOT' buf' off + minBPC' end' token);  case BT_APOS:  	return scanLit (BT_APOS' buf' off + minBPC' end' token);  case BT_LT: {  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_EXCL:  		return scanDecl (buf' off + minBPC' end' token);  	case BT_QUEST:  		return scanPi (buf' off + minBPC' end' token);  	case BT_NMSTRT:  	case BT_LEAD2:  	case BT_LEAD3:  	case BT_LEAD4:  		token.TokenEnd = off - minBPC;  		throw new EndOfPrologException ();  	}  	throw new InvalidTokenException (off);  }  case BT_CR:  	if (off + minBPC == end)  		throw new ExtensibleTokenException (TOK.PROLOG_S);  	/* fall through */goto case BT_S;  case BT_S:  case BT_LF:  	for (; ;) {  		off += minBPC;  		if (off == end)  			break;  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_LF:  			break;  		case BT_CR:  			/* don't split CR/LF pair */if (off + minBPC != end)  				break;  			/* fall through */goto default;  		default:  			token.TokenEnd = off;  			return TOK.PROLOG_S;  		}  	}  	token.TokenEnd = off;  	return TOK.PROLOG_S;  case BT_PERCNT:  	return scanPercent (buf' off + minBPC' end' token);  case BT_COMMA:  	token.TokenEnd = off + minBPC;  	return TOK.COMMA;  case BT_LSQB:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_BRACKET;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_BRACKET);  	if (charMatches (buf' off' ']')) {  		if (off + minBPC == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off + minBPC' '>')) {  			token.TokenEnd = off + 2 * minBPC;  			return TOK.COND_SECT_CLOSE;  		}  	}  	token.TokenEnd = off;  	return TOK.CLOSE_BRACKET;  case BT_LPAR:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_PAREN;  case BT_RPAR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_PAREN);  	switch (byteType (buf' off)) {  	case BT_AST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_ASTERISK;  	case BT_QUEST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_QUESTION;  	case BT_PLUS:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_PLUS;  	case BT_CR:  	case BT_LF:  	case BT_S:  	case BT_GT:  	case BT_COMMA:  	case BT_VERBAR:  	case BT_RPAR:  		token.TokenEnd = off;  		return TOK.CLOSE_PAREN;  	}  	throw new InvalidTokenException (off);  case BT_VERBAR:  	token.TokenEnd = off + minBPC;  	return TOK.OR;  case BT_GT:  	token.TokenEnd = off + minBPC;  	return TOK.DECL_CLOSE;  case BT_NUM:  	return scanPoundName (buf' off + minBPC' end' token);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	switch (byteType2 (buf' off)) {  	case BT_NMSTRT:  		off += 2;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 2;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	switch (byteType3 (buf' off)) {  	case BT_NMSTRT:  		off += 3;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 3;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	switch (byteType4 (buf' off)) {  	case BT_NMSTRT:  		off += 4;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 4;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_NMSTRT:  	tok = TOK.NAME;  	off += minBPC;  	break;  case BT_NAME:  case BT_MINUS:  	tok = TOK.NMTOKEN;  	off += minBPC;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_QUOT:  	return scanLit (BT_QUOT' buf' off + minBPC' end' token);  case BT_APOS:  	return scanLit (BT_APOS' buf' off + minBPC' end' token);  case BT_LT: {  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_EXCL:  		return scanDecl (buf' off + minBPC' end' token);  	case BT_QUEST:  		return scanPi (buf' off + minBPC' end' token);  	case BT_NMSTRT:  	case BT_LEAD2:  	case BT_LEAD3:  	case BT_LEAD4:  		token.TokenEnd = off - minBPC;  		throw new EndOfPrologException ();  	}  	throw new InvalidTokenException (off);  }  case BT_CR:  	if (off + minBPC == end)  		throw new ExtensibleTokenException (TOK.PROLOG_S);  	/* fall through */goto case BT_S;  case BT_S:  case BT_LF:  	for (; ;) {  		off += minBPC;  		if (off == end)  			break;  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_LF:  			break;  		case BT_CR:  			/* don't split CR/LF pair */if (off + minBPC != end)  				break;  			/* fall through */goto default;  		default:  			token.TokenEnd = off;  			return TOK.PROLOG_S;  		}  	}  	token.TokenEnd = off;  	return TOK.PROLOG_S;  case BT_PERCNT:  	return scanPercent (buf' off + minBPC' end' token);  case BT_COMMA:  	token.TokenEnd = off + minBPC;  	return TOK.COMMA;  case BT_LSQB:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_BRACKET;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_BRACKET);  	if (charMatches (buf' off' ']')) {  		if (off + minBPC == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off + minBPC' '>')) {  			token.TokenEnd = off + 2 * minBPC;  			return TOK.COND_SECT_CLOSE;  		}  	}  	token.TokenEnd = off;  	return TOK.CLOSE_BRACKET;  case BT_LPAR:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_PAREN;  case BT_RPAR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_PAREN);  	switch (byteType (buf' off)) {  	case BT_AST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_ASTERISK;  	case BT_QUEST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_QUESTION;  	case BT_PLUS:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_PLUS;  	case BT_CR:  	case BT_LF:  	case BT_S:  	case BT_GT:  	case BT_COMMA:  	case BT_VERBAR:  	case BT_RPAR:  		token.TokenEnd = off;  		return TOK.CLOSE_PAREN;  	}  	throw new InvalidTokenException (off);  case BT_VERBAR:  	token.TokenEnd = off + minBPC;  	return TOK.OR;  case BT_GT:  	token.TokenEnd = off + minBPC;  	return TOK.DECL_CLOSE;  case BT_NUM:  	return scanPoundName (buf' off + minBPC' end' token);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	switch (byteType2 (buf' off)) {  	case BT_NMSTRT:  		off += 2;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 2;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	switch (byteType3 (buf' off)) {  	case BT_NMSTRT:  		off += 3;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 3;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	switch (byteType4 (buf' off)) {  	case BT_NMSTRT:  		off += 4;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 4;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_NMSTRT:  	tok = TOK.NAME;  	off += minBPC;  	break;  case BT_NAME:  case BT_MINUS:  	tok = TOK.NMTOKEN;  	off += minBPC;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_QUOT:  	return scanLit (BT_QUOT' buf' off + minBPC' end' token);  case BT_APOS:  	return scanLit (BT_APOS' buf' off + minBPC' end' token);  case BT_LT: {  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_EXCL:  		return scanDecl (buf' off + minBPC' end' token);  	case BT_QUEST:  		return scanPi (buf' off + minBPC' end' token);  	case BT_NMSTRT:  	case BT_LEAD2:  	case BT_LEAD3:  	case BT_LEAD4:  		token.TokenEnd = off - minBPC;  		throw new EndOfPrologException ();  	}  	throw new InvalidTokenException (off);  }  case BT_CR:  	if (off + minBPC == end)  		throw new ExtensibleTokenException (TOK.PROLOG_S);  	/* fall through */goto case BT_S;  case BT_S:  case BT_LF:  	for (; ;) {  		off += minBPC;  		if (off == end)  			break;  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_LF:  			break;  		case BT_CR:  			/* don't split CR/LF pair */if (off + minBPC != end)  				break;  			/* fall through */goto default;  		default:  			token.TokenEnd = off;  			return TOK.PROLOG_S;  		}  	}  	token.TokenEnd = off;  	return TOK.PROLOG_S;  case BT_PERCNT:  	return scanPercent (buf' off + minBPC' end' token);  case BT_COMMA:  	token.TokenEnd = off + minBPC;  	return TOK.COMMA;  case BT_LSQB:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_BRACKET;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_BRACKET);  	if (charMatches (buf' off' ']')) {  		if (off + minBPC == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off + minBPC' '>')) {  			token.TokenEnd = off + 2 * minBPC;  			return TOK.COND_SECT_CLOSE;  		}  	}  	token.TokenEnd = off;  	return TOK.CLOSE_BRACKET;  case BT_LPAR:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_PAREN;  case BT_RPAR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_PAREN);  	switch (byteType (buf' off)) {  	case BT_AST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_ASTERISK;  	case BT_QUEST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_QUESTION;  	case BT_PLUS:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_PLUS;  	case BT_CR:  	case BT_LF:  	case BT_S:  	case BT_GT:  	case BT_COMMA:  	case BT_VERBAR:  	case BT_RPAR:  		token.TokenEnd = off;  		return TOK.CLOSE_PAREN;  	}  	throw new InvalidTokenException (off);  case BT_VERBAR:  	token.TokenEnd = off + minBPC;  	return TOK.OR;  case BT_GT:  	token.TokenEnd = off + minBPC;  	return TOK.DECL_CLOSE;  case BT_NUM:  	return scanPoundName (buf' off + minBPC' end' token);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	switch (byteType2 (buf' off)) {  	case BT_NMSTRT:  		off += 2;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 2;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	switch (byteType3 (buf' off)) {  	case BT_NMSTRT:  		off += 3;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 3;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	switch (byteType4 (buf' off)) {  	case BT_NMSTRT:  		off += 4;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 4;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_NMSTRT:  	tok = TOK.NAME;  	off += minBPC;  	break;  case BT_NAME:  case BT_MINUS:  	tok = TOK.NMTOKEN;  	off += minBPC;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_QUOT:  	return scanLit (BT_QUOT' buf' off + minBPC' end' token);  case BT_APOS:  	return scanLit (BT_APOS' buf' off + minBPC' end' token);  case BT_LT: {  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_EXCL:  		return scanDecl (buf' off + minBPC' end' token);  	case BT_QUEST:  		return scanPi (buf' off + minBPC' end' token);  	case BT_NMSTRT:  	case BT_LEAD2:  	case BT_LEAD3:  	case BT_LEAD4:  		token.TokenEnd = off - minBPC;  		throw new EndOfPrologException ();  	}  	throw new InvalidTokenException (off);  }  case BT_CR:  	if (off + minBPC == end)  		throw new ExtensibleTokenException (TOK.PROLOG_S);  	/* fall through */goto case BT_S;  case BT_S:  case BT_LF:  	for (; ;) {  		off += minBPC;  		if (off == end)  			break;  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_LF:  			break;  		case BT_CR:  			/* don't split CR/LF pair */if (off + minBPC != end)  				break;  			/* fall through */goto default;  		default:  			token.TokenEnd = off;  			return TOK.PROLOG_S;  		}  	}  	token.TokenEnd = off;  	return TOK.PROLOG_S;  case BT_PERCNT:  	return scanPercent (buf' off + minBPC' end' token);  case BT_COMMA:  	token.TokenEnd = off + minBPC;  	return TOK.COMMA;  case BT_LSQB:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_BRACKET;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_BRACKET);  	if (charMatches (buf' off' ']')) {  		if (off + minBPC == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off + minBPC' '>')) {  			token.TokenEnd = off + 2 * minBPC;  			return TOK.COND_SECT_CLOSE;  		}  	}  	token.TokenEnd = off;  	return TOK.CLOSE_BRACKET;  case BT_LPAR:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_PAREN;  case BT_RPAR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_PAREN);  	switch (byteType (buf' off)) {  	case BT_AST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_ASTERISK;  	case BT_QUEST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_QUESTION;  	case BT_PLUS:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_PLUS;  	case BT_CR:  	case BT_LF:  	case BT_S:  	case BT_GT:  	case BT_COMMA:  	case BT_VERBAR:  	case BT_RPAR:  		token.TokenEnd = off;  		return TOK.CLOSE_PAREN;  	}  	throw new InvalidTokenException (off);  case BT_VERBAR:  	token.TokenEnd = off + minBPC;  	return TOK.OR;  case BT_GT:  	token.TokenEnd = off + minBPC;  	return TOK.DECL_CLOSE;  case BT_NUM:  	return scanPoundName (buf' off + minBPC' end' token);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	switch (byteType2 (buf' off)) {  	case BT_NMSTRT:  		off += 2;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 2;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	switch (byteType3 (buf' off)) {  	case BT_NMSTRT:  		off += 3;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 3;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	switch (byteType4 (buf' off)) {  	case BT_NMSTRT:  		off += 4;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 4;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_NMSTRT:  	tok = TOK.NAME;  	off += minBPC;  	break;  case BT_NAME:  case BT_MINUS:  	tok = TOK.NMTOKEN;  	off += minBPC;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_QUOT:  	return scanLit (BT_QUOT' buf' off + minBPC' end' token);  case BT_APOS:  	return scanLit (BT_APOS' buf' off + minBPC' end' token);  case BT_LT: {  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_EXCL:  		return scanDecl (buf' off + minBPC' end' token);  	case BT_QUEST:  		return scanPi (buf' off + minBPC' end' token);  	case BT_NMSTRT:  	case BT_LEAD2:  	case BT_LEAD3:  	case BT_LEAD4:  		token.TokenEnd = off - minBPC;  		throw new EndOfPrologException ();  	}  	throw new InvalidTokenException (off);  }  case BT_CR:  	if (off + minBPC == end)  		throw new ExtensibleTokenException (TOK.PROLOG_S);  	/* fall through */goto case BT_S;  case BT_S:  case BT_LF:  	for (; ;) {  		off += minBPC;  		if (off == end)  			break;  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_LF:  			break;  		case BT_CR:  			/* don't split CR/LF pair */if (off + minBPC != end)  				break;  			/* fall through */goto default;  		default:  			token.TokenEnd = off;  			return TOK.PROLOG_S;  		}  	}  	token.TokenEnd = off;  	return TOK.PROLOG_S;  case BT_PERCNT:  	return scanPercent (buf' off + minBPC' end' token);  case BT_COMMA:  	token.TokenEnd = off + minBPC;  	return TOK.COMMA;  case BT_LSQB:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_BRACKET;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_BRACKET);  	if (charMatches (buf' off' ']')) {  		if (off + minBPC == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off + minBPC' '>')) {  			token.TokenEnd = off + 2 * minBPC;  			return TOK.COND_SECT_CLOSE;  		}  	}  	token.TokenEnd = off;  	return TOK.CLOSE_BRACKET;  case BT_LPAR:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_PAREN;  case BT_RPAR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_PAREN);  	switch (byteType (buf' off)) {  	case BT_AST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_ASTERISK;  	case BT_QUEST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_QUESTION;  	case BT_PLUS:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_PLUS;  	case BT_CR:  	case BT_LF:  	case BT_S:  	case BT_GT:  	case BT_COMMA:  	case BT_VERBAR:  	case BT_RPAR:  		token.TokenEnd = off;  		return TOK.CLOSE_PAREN;  	}  	throw new InvalidTokenException (off);  case BT_VERBAR:  	token.TokenEnd = off + minBPC;  	return TOK.OR;  case BT_GT:  	token.TokenEnd = off + minBPC;  	return TOK.DECL_CLOSE;  case BT_NUM:  	return scanPoundName (buf' off + minBPC' end' token);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	switch (byteType2 (buf' off)) {  	case BT_NMSTRT:  		off += 2;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 2;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	switch (byteType3 (buf' off)) {  	case BT_NMSTRT:  		off += 3;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 3;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	switch (byteType4 (buf' off)) {  	case BT_NMSTRT:  		off += 4;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 4;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_NMSTRT:  	tok = TOK.NAME;  	off += minBPC;  	break;  case BT_NAME:  case BT_MINUS:  	tok = TOK.NMTOKEN;  	off += minBPC;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_QUOT:  	return scanLit (BT_QUOT' buf' off + minBPC' end' token);  case BT_APOS:  	return scanLit (BT_APOS' buf' off + minBPC' end' token);  case BT_LT: {  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_EXCL:  		return scanDecl (buf' off + minBPC' end' token);  	case BT_QUEST:  		return scanPi (buf' off + minBPC' end' token);  	case BT_NMSTRT:  	case BT_LEAD2:  	case BT_LEAD3:  	case BT_LEAD4:  		token.TokenEnd = off - minBPC;  		throw new EndOfPrologException ();  	}  	throw new InvalidTokenException (off);  }  case BT_CR:  	if (off + minBPC == end)  		throw new ExtensibleTokenException (TOK.PROLOG_S);  	/* fall through */goto case BT_S;  case BT_S:  case BT_LF:  	for (; ;) {  		off += minBPC;  		if (off == end)  			break;  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_LF:  			break;  		case BT_CR:  			/* don't split CR/LF pair */if (off + minBPC != end)  				break;  			/* fall through */goto default;  		default:  			token.TokenEnd = off;  			return TOK.PROLOG_S;  		}  	}  	token.TokenEnd = off;  	return TOK.PROLOG_S;  case BT_PERCNT:  	return scanPercent (buf' off + minBPC' end' token);  case BT_COMMA:  	token.TokenEnd = off + minBPC;  	return TOK.COMMA;  case BT_LSQB:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_BRACKET;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_BRACKET);  	if (charMatches (buf' off' ']')) {  		if (off + minBPC == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off + minBPC' '>')) {  			token.TokenEnd = off + 2 * minBPC;  			return TOK.COND_SECT_CLOSE;  		}  	}  	token.TokenEnd = off;  	return TOK.CLOSE_BRACKET;  case BT_LPAR:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_PAREN;  case BT_RPAR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_PAREN);  	switch (byteType (buf' off)) {  	case BT_AST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_ASTERISK;  	case BT_QUEST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_QUESTION;  	case BT_PLUS:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_PLUS;  	case BT_CR:  	case BT_LF:  	case BT_S:  	case BT_GT:  	case BT_COMMA:  	case BT_VERBAR:  	case BT_RPAR:  		token.TokenEnd = off;  		return TOK.CLOSE_PAREN;  	}  	throw new InvalidTokenException (off);  case BT_VERBAR:  	token.TokenEnd = off + minBPC;  	return TOK.OR;  case BT_GT:  	token.TokenEnd = off + minBPC;  	return TOK.DECL_CLOSE;  case BT_NUM:  	return scanPoundName (buf' off + minBPC' end' token);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	switch (byteType2 (buf' off)) {  	case BT_NMSTRT:  		off += 2;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 2;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	switch (byteType3 (buf' off)) {  	case BT_NMSTRT:  		off += 3;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 3;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	switch (byteType4 (buf' off)) {  	case BT_NMSTRT:  		off += 4;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 4;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_NMSTRT:  	tok = TOK.NAME;  	off += minBPC;  	break;  case BT_NAME:  case BT_MINUS:  	tok = TOK.NMTOKEN;  	off += minBPC;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_QUOT:  	return scanLit (BT_QUOT' buf' off + minBPC' end' token);  case BT_APOS:  	return scanLit (BT_APOS' buf' off + minBPC' end' token);  case BT_LT: {  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_EXCL:  		return scanDecl (buf' off + minBPC' end' token);  	case BT_QUEST:  		return scanPi (buf' off + minBPC' end' token);  	case BT_NMSTRT:  	case BT_LEAD2:  	case BT_LEAD3:  	case BT_LEAD4:  		token.TokenEnd = off - minBPC;  		throw new EndOfPrologException ();  	}  	throw new InvalidTokenException (off);  }  case BT_CR:  	if (off + minBPC == end)  		throw new ExtensibleTokenException (TOK.PROLOG_S);  	/* fall through */goto case BT_S;  case BT_S:  case BT_LF:  	for (; ;) {  		off += minBPC;  		if (off == end)  			break;  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_LF:  			break;  		case BT_CR:  			/* don't split CR/LF pair */if (off + minBPC != end)  				break;  			/* fall through */goto default;  		default:  			token.TokenEnd = off;  			return TOK.PROLOG_S;  		}  	}  	token.TokenEnd = off;  	return TOK.PROLOG_S;  case BT_PERCNT:  	return scanPercent (buf' off + minBPC' end' token);  case BT_COMMA:  	token.TokenEnd = off + minBPC;  	return TOK.COMMA;  case BT_LSQB:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_BRACKET;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_BRACKET);  	if (charMatches (buf' off' ']')) {  		if (off + minBPC == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off + minBPC' '>')) {  			token.TokenEnd = off + 2 * minBPC;  			return TOK.COND_SECT_CLOSE;  		}  	}  	token.TokenEnd = off;  	return TOK.CLOSE_BRACKET;  case BT_LPAR:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_PAREN;  case BT_RPAR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_PAREN);  	switch (byteType (buf' off)) {  	case BT_AST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_ASTERISK;  	case BT_QUEST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_QUESTION;  	case BT_PLUS:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_PLUS;  	case BT_CR:  	case BT_LF:  	case BT_S:  	case BT_GT:  	case BT_COMMA:  	case BT_VERBAR:  	case BT_RPAR:  		token.TokenEnd = off;  		return TOK.CLOSE_PAREN;  	}  	throw new InvalidTokenException (off);  case BT_VERBAR:  	token.TokenEnd = off + minBPC;  	return TOK.OR;  case BT_GT:  	token.TokenEnd = off + minBPC;  	return TOK.DECL_CLOSE;  case BT_NUM:  	return scanPoundName (buf' off + minBPC' end' token);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	switch (byteType2 (buf' off)) {  	case BT_NMSTRT:  		off += 2;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 2;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	switch (byteType3 (buf' off)) {  	case BT_NMSTRT:  		off += 3;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 3;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	switch (byteType4 (buf' off)) {  	case BT_NMSTRT:  		off += 4;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 4;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_NMSTRT:  	tok = TOK.NAME;  	off += minBPC;  	break;  case BT_NAME:  case BT_MINUS:  	tok = TOK.NMTOKEN;  	off += minBPC;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_QUOT:  	return scanLit (BT_QUOT' buf' off + minBPC' end' token);  case BT_APOS:  	return scanLit (BT_APOS' buf' off + minBPC' end' token);  case BT_LT: {  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_EXCL:  		return scanDecl (buf' off + minBPC' end' token);  	case BT_QUEST:  		return scanPi (buf' off + minBPC' end' token);  	case BT_NMSTRT:  	case BT_LEAD2:  	case BT_LEAD3:  	case BT_LEAD4:  		token.TokenEnd = off - minBPC;  		throw new EndOfPrologException ();  	}  	throw new InvalidTokenException (off);  }  case BT_CR:  	if (off + minBPC == end)  		throw new ExtensibleTokenException (TOK.PROLOG_S);  	/* fall through */goto case BT_S;  case BT_S:  case BT_LF:  	for (; ;) {  		off += minBPC;  		if (off == end)  			break;  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_LF:  			break;  		case BT_CR:  			/* don't split CR/LF pair */if (off + minBPC != end)  				break;  			/* fall through */goto default;  		default:  			token.TokenEnd = off;  			return TOK.PROLOG_S;  		}  	}  	token.TokenEnd = off;  	return TOK.PROLOG_S;  case BT_PERCNT:  	return scanPercent (buf' off + minBPC' end' token);  case BT_COMMA:  	token.TokenEnd = off + minBPC;  	return TOK.COMMA;  case BT_LSQB:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_BRACKET;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_BRACKET);  	if (charMatches (buf' off' ']')) {  		if (off + minBPC == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off + minBPC' '>')) {  			token.TokenEnd = off + 2 * minBPC;  			return TOK.COND_SECT_CLOSE;  		}  	}  	token.TokenEnd = off;  	return TOK.CLOSE_BRACKET;  case BT_LPAR:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_PAREN;  case BT_RPAR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_PAREN);  	switch (byteType (buf' off)) {  	case BT_AST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_ASTERISK;  	case BT_QUEST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_QUESTION;  	case BT_PLUS:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_PLUS;  	case BT_CR:  	case BT_LF:  	case BT_S:  	case BT_GT:  	case BT_COMMA:  	case BT_VERBAR:  	case BT_RPAR:  		token.TokenEnd = off;  		return TOK.CLOSE_PAREN;  	}  	throw new InvalidTokenException (off);  case BT_VERBAR:  	token.TokenEnd = off + minBPC;  	return TOK.OR;  case BT_GT:  	token.TokenEnd = off + minBPC;  	return TOK.DECL_CLOSE;  case BT_NUM:  	return scanPoundName (buf' off + minBPC' end' token);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	switch (byteType2 (buf' off)) {  	case BT_NMSTRT:  		off += 2;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 2;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	switch (byteType3 (buf' off)) {  	case BT_NMSTRT:  		off += 3;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 3;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	switch (byteType4 (buf' off)) {  	case BT_NMSTRT:  		off += 4;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 4;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_NMSTRT:  	tok = TOK.NAME;  	off += minBPC;  	break;  case BT_NAME:  case BT_MINUS:  	tok = TOK.NMTOKEN;  	off += minBPC;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_QUOT:  	return scanLit (BT_QUOT' buf' off + minBPC' end' token);  case BT_APOS:  	return scanLit (BT_APOS' buf' off + minBPC' end' token);  case BT_LT: {  	off += minBPC;  	if (off == end)  		throw new PartialTokenException ();  	switch (byteType (buf' off)) {  	case BT_EXCL:  		return scanDecl (buf' off + minBPC' end' token);  	case BT_QUEST:  		return scanPi (buf' off + minBPC' end' token);  	case BT_NMSTRT:  	case BT_LEAD2:  	case BT_LEAD3:  	case BT_LEAD4:  		token.TokenEnd = off - minBPC;  		throw new EndOfPrologException ();  	}  	throw new InvalidTokenException (off);  }  case BT_CR:  	if (off + minBPC == end)  		throw new ExtensibleTokenException (TOK.PROLOG_S);  	/* fall through */goto case BT_S;  case BT_S:  case BT_LF:  	for (; ;) {  		off += minBPC;  		if (off == end)  			break;  		switch (byteType (buf' off)) {  		case BT_S:  		case BT_LF:  			break;  		case BT_CR:  			/* don't split CR/LF pair */if (off + minBPC != end)  				break;  			/* fall through */goto default;  		default:  			token.TokenEnd = off;  			return TOK.PROLOG_S;  		}  	}  	token.TokenEnd = off;  	return TOK.PROLOG_S;  case BT_PERCNT:  	return scanPercent (buf' off + minBPC' end' token);  case BT_COMMA:  	token.TokenEnd = off + minBPC;  	return TOK.COMMA;  case BT_LSQB:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_BRACKET;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_BRACKET);  	if (charMatches (buf' off' ']')) {  		if (off + minBPC == end)  			throw new PartialTokenException ();  		if (charMatches (buf' off + minBPC' '>')) {  			token.TokenEnd = off + 2 * minBPC;  			return TOK.COND_SECT_CLOSE;  		}  	}  	token.TokenEnd = off;  	return TOK.CLOSE_BRACKET;  case BT_LPAR:  	token.TokenEnd = off + minBPC;  	return TOK.OPEN_PAREN;  case BT_RPAR:  	off += minBPC;  	if (off == end)  		throw new ExtensibleTokenException (TOK.CLOSE_PAREN);  	switch (byteType (buf' off)) {  	case BT_AST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_ASTERISK;  	case BT_QUEST:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_QUESTION;  	case BT_PLUS:  		token.TokenEnd = off + minBPC;  		return TOK.CLOSE_PAREN_PLUS;  	case BT_CR:  	case BT_LF:  	case BT_S:  	case BT_GT:  	case BT_COMMA:  	case BT_VERBAR:  	case BT_RPAR:  		token.TokenEnd = off;  		return TOK.CLOSE_PAREN;  	}  	throw new InvalidTokenException (off);  case BT_VERBAR:  	token.TokenEnd = off + minBPC;  	return TOK.OR;  case BT_GT:  	token.TokenEnd = off + minBPC;  	return TOK.DECL_CLOSE;  case BT_NUM:  	return scanPoundName (buf' off + minBPC' end' token);  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	switch (byteType2 (buf' off)) {  	case BT_NMSTRT:  		off += 2;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 2;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	switch (byteType3 (buf' off)) {  	case BT_NMSTRT:  		off += 3;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 3;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	switch (byteType4 (buf' off)) {  	case BT_NMSTRT:  		off += 4;  		tok = TOK.NAME;  		break;  	case BT_NAME:  		off += 4;  		tok = TOK.NMTOKEN;  		break;  	default:  		throw new InvalidTokenException (off);  	}  	break;  case BT_NMSTRT:  	tok = TOK.NAME;  	off += minBPC;  	break;  case BT_NAME:  case BT_MINUS:  	tok = TOK.NMTOKEN;  	off += minBPC;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: if (charMatches (buf' off' ']')) {  	if (off + minBPC == end)  		throw new PartialTokenException ();  	if (charMatches (buf' off + minBPC' '>')) {  		token.TokenEnd = off + 2 * minBPC;  		return TOK.COND_SECT_CLOSE;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: if (charMatches (buf' off + minBPC' '>')) {  	token.TokenEnd = off + 2 * minBPC;  	return TOK.COND_SECT_CLOSE;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: token.TokenEnd = off + 2 * minBPC;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType2 (buf' off)) {  case BT_NMSTRT:  	off += 2;  	tok = TOK.NAME;  	break;  case BT_NAME:  	off += 2;  	tok = TOK.NMTOKEN;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType2 (buf' off)) {  case BT_NMSTRT:  	off += 2;  	tok = TOK.NAME;  	break;  case BT_NAME:  	off += 2;  	tok = TOK.NMTOKEN;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: off += 2;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: off += 2;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType3 (buf' off)) {  case BT_NMSTRT:  	off += 3;  	tok = TOK.NAME;  	break;  case BT_NAME:  	off += 3;  	tok = TOK.NMTOKEN;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType3 (buf' off)) {  case BT_NMSTRT:  	off += 3;  	tok = TOK.NAME;  	break;  case BT_NAME:  	off += 3;  	tok = TOK.NMTOKEN;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: off += 3;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: off += 3;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType4 (buf' off)) {  case BT_NMSTRT:  	off += 4;  	tok = TOK.NAME;  	break;  case BT_NAME:  	off += 4;  	tok = TOK.NMTOKEN;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType4 (buf' off)) {  case BT_NMSTRT:  	off += 4;  	tok = TOK.NAME;  	break;  case BT_NAME:  	off += 4;  	tok = TOK.NMTOKEN;  	break;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: off += 4;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: off += 4;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_GT:  	case BT_RPAR:  	case BT_COMMA:  	case BT_VERBAR:  	case BT_LSQB:  	case BT_PERCNT:  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.TokenEnd = off;  		return tok;  	case BT_PLUS:  		if (tok != TOK.NAME)  			throw new InvalidTokenException (off);  		token.TokenEnd = off + minBPC;  		return TOK.NAME_PLUS;  	case BT_AST:  		if (tok != TOK.NAME)  			throw new InvalidTokenException (off);  		token.TokenEnd = off + minBPC;  		return TOK.NAME_ASTERISK;  	case BT_QUEST:  		if (tok != TOK.NAME)  			throw new InvalidTokenException (off);  		token.TokenEnd = off + minBPC;  		return TOK.NAME_QUESTION;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_GT:  	case BT_RPAR:  	case BT_COMMA:  	case BT_VERBAR:  	case BT_LSQB:  	case BT_PERCNT:  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.TokenEnd = off;  		return tok;  	case BT_PLUS:  		if (tok != TOK.NAME)  			throw new InvalidTokenException (off);  		token.TokenEnd = off + minBPC;  		return TOK.NAME_PLUS;  	case BT_AST:  		if (tok != TOK.NAME)  			throw new InvalidTokenException (off);  		token.TokenEnd = off + minBPC;  		return TOK.NAME_ASTERISK;  	case BT_QUEST:  		if (tok != TOK.NAME)  			throw new InvalidTokenException (off);  		token.TokenEnd = off + minBPC;  		return TOK.NAME_QUESTION;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_GT:  	case BT_RPAR:  	case BT_COMMA:  	case BT_VERBAR:  	case BT_LSQB:  	case BT_PERCNT:  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.TokenEnd = off;  		return tok;  	case BT_PLUS:  		if (tok != TOK.NAME)  			throw new InvalidTokenException (off);  		token.TokenEnd = off + minBPC;  		return TOK.NAME_PLUS;  	case BT_AST:  		if (tok != TOK.NAME)  			throw new InvalidTokenException (off);  		token.TokenEnd = off + minBPC;  		return TOK.NAME_ASTERISK;  	case BT_QUEST:  		if (tok != TOK.NAME)  			throw new InvalidTokenException (off);  		token.TokenEnd = off + minBPC;  		return TOK.NAME_QUESTION;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_GT:  	case BT_RPAR:  	case BT_COMMA:  	case BT_VERBAR:  	case BT_LSQB:  	case BT_PERCNT:  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.TokenEnd = off;  		return tok;  	case BT_PLUS:  		if (tok != TOK.NAME)  			throw new InvalidTokenException (off);  		token.TokenEnd = off + minBPC;  		return TOK.NAME_PLUS;  	case BT_AST:  		if (tok != TOK.NAME)  			throw new InvalidTokenException (off);  		token.TokenEnd = off + minBPC;  		return TOK.NAME_ASTERISK;  	case BT_QUEST:  		if (tok != TOK.NAME)  			throw new InvalidTokenException (off);  		token.TokenEnd = off + minBPC;  		return TOK.NAME_QUESTION;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_GT:  	case BT_RPAR:  	case BT_COMMA:  	case BT_VERBAR:  	case BT_LSQB:  	case BT_PERCNT:  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.TokenEnd = off;  		return tok;  	case BT_PLUS:  		if (tok != TOK.NAME)  			throw new InvalidTokenException (off);  		token.TokenEnd = off + minBPC;  		return TOK.NAME_PLUS;  	case BT_AST:  		if (tok != TOK.NAME)  			throw new InvalidTokenException (off);  		token.TokenEnd = off + minBPC;  		return TOK.NAME_ASTERISK;  	case BT_QUEST:  		if (tok != TOK.NAME)  			throw new InvalidTokenException (off);  		token.TokenEnd = off + minBPC;  		return TOK.NAME_QUESTION;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_NMSTRT:  	case BT_NAME:  	case BT_MINUS:  		off += minBPC;  		break;  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		if (!isNameChar2 (buf' off))  			throw new InvalidTokenException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		if (!isNameChar3 (buf' off))  			throw new InvalidTokenException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		if (!isNameChar4 (buf' off))  			throw new InvalidTokenException (off);  		off += 4;  		break;  	case BT_GT:  	case BT_RPAR:  	case BT_COMMA:  	case BT_VERBAR:  	case BT_LSQB:  	case BT_PERCNT:  	case BT_S:  	case BT_CR:  	case BT_LF:  		token.TokenEnd = off;  		return tok;  	case BT_PLUS:  		if (tok != TOK.NAME)  			throw new InvalidTokenException (off);  		token.TokenEnd = off + minBPC;  		return TOK.NAME_PLUS;  	case BT_AST:  		if (tok != TOK.NAME)  			throw new InvalidTokenException (off);  		token.TokenEnd = off + minBPC;  		return TOK.NAME_ASTERISK;  	case BT_QUEST:  		if (tok != TOK.NAME)  			throw new InvalidTokenException (off);  		token.TokenEnd = off + minBPC;  		return TOK.NAME_QUESTION;  	default:  		throw new InvalidTokenException (off);  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_GT:  case BT_RPAR:  case BT_COMMA:  case BT_VERBAR:  case BT_LSQB:  case BT_PERCNT:  case BT_S:  case BT_CR:  case BT_LF:  	token.TokenEnd = off;  	return tok;  case BT_PLUS:  	if (tok != TOK.NAME)  		throw new InvalidTokenException (off);  	token.TokenEnd = off + minBPC;  	return TOK.NAME_PLUS;  case BT_AST:  	if (tok != TOK.NAME)  		throw new InvalidTokenException (off);  	token.TokenEnd = off + minBPC;  	return TOK.NAME_ASTERISK;  case BT_QUEST:  	if (tok != TOK.NAME)  		throw new InvalidTokenException (off);  	token.TokenEnd = off + minBPC;  	return TOK.NAME_QUESTION;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_GT:  case BT_RPAR:  case BT_COMMA:  case BT_VERBAR:  case BT_LSQB:  case BT_PERCNT:  case BT_S:  case BT_CR:  case BT_LF:  	token.TokenEnd = off;  	return tok;  case BT_PLUS:  	if (tok != TOK.NAME)  		throw new InvalidTokenException (off);  	token.TokenEnd = off + minBPC;  	return TOK.NAME_PLUS;  case BT_AST:  	if (tok != TOK.NAME)  		throw new InvalidTokenException (off);  	token.TokenEnd = off + minBPC;  	return TOK.NAME_ASTERISK;  case BT_QUEST:  	if (tok != TOK.NAME)  		throw new InvalidTokenException (off);  	token.TokenEnd = off + minBPC;  	return TOK.NAME_QUESTION;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_GT:  case BT_RPAR:  case BT_COMMA:  case BT_VERBAR:  case BT_LSQB:  case BT_PERCNT:  case BT_S:  case BT_CR:  case BT_LF:  	token.TokenEnd = off;  	return tok;  case BT_PLUS:  	if (tok != TOK.NAME)  		throw new InvalidTokenException (off);  	token.TokenEnd = off + minBPC;  	return TOK.NAME_PLUS;  case BT_AST:  	if (tok != TOK.NAME)  		throw new InvalidTokenException (off);  	token.TokenEnd = off + minBPC;  	return TOK.NAME_ASTERISK;  case BT_QUEST:  	if (tok != TOK.NAME)  		throw new InvalidTokenException (off);  	token.TokenEnd = off + minBPC;  	return TOK.NAME_QUESTION;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_GT:  case BT_RPAR:  case BT_COMMA:  case BT_VERBAR:  case BT_LSQB:  case BT_PERCNT:  case BT_S:  case BT_CR:  case BT_LF:  	token.TokenEnd = off;  	return tok;  case BT_PLUS:  	if (tok != TOK.NAME)  		throw new InvalidTokenException (off);  	token.TokenEnd = off + minBPC;  	return TOK.NAME_PLUS;  case BT_AST:  	if (tok != TOK.NAME)  		throw new InvalidTokenException (off);  	token.TokenEnd = off + minBPC;  	return TOK.NAME_ASTERISK;  case BT_QUEST:  	if (tok != TOK.NAME)  		throw new InvalidTokenException (off);  	token.TokenEnd = off + minBPC;  	return TOK.NAME_QUESTION;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_GT:  case BT_RPAR:  case BT_COMMA:  case BT_VERBAR:  case BT_LSQB:  case BT_PERCNT:  case BT_S:  case BT_CR:  case BT_LF:  	token.TokenEnd = off;  	return tok;  case BT_PLUS:  	if (tok != TOK.NAME)  		throw new InvalidTokenException (off);  	token.TokenEnd = off + minBPC;  	return TOK.NAME_PLUS;  case BT_AST:  	if (tok != TOK.NAME)  		throw new InvalidTokenException (off);  	token.TokenEnd = off + minBPC;  	return TOK.NAME_ASTERISK;  case BT_QUEST:  	if (tok != TOK.NAME)  		throw new InvalidTokenException (off);  	token.TokenEnd = off + minBPC;  	return TOK.NAME_QUESTION;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_NMSTRT:  case BT_NAME:  case BT_MINUS:  	off += minBPC;  	break;  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	if (!isNameChar2 (buf' off))  		throw new InvalidTokenException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	if (!isNameChar3 (buf' off))  		throw new InvalidTokenException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	if (!isNameChar4 (buf' off))  		throw new InvalidTokenException (off);  	off += 4;  	break;  case BT_GT:  case BT_RPAR:  case BT_COMMA:  case BT_VERBAR:  case BT_LSQB:  case BT_PERCNT:  case BT_S:  case BT_CR:  case BT_LF:  	token.TokenEnd = off;  	return tok;  case BT_PLUS:  	if (tok != TOK.NAME)  		throw new InvalidTokenException (off);  	token.TokenEnd = off + minBPC;  	return TOK.NAME_PLUS;  case BT_AST:  	if (tok != TOK.NAME)  		throw new InvalidTokenException (off);  	token.TokenEnd = off + minBPC;  	return TOK.NAME_ASTERISK;  case BT_QUEST:  	if (tok != TOK.NAME)  		throw new InvalidTokenException (off);  	token.TokenEnd = off + minBPC;  	return TOK.NAME_QUESTION;  default:  	throw new InvalidTokenException (off);  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: off += 2;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: off += 3;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following statement contains a magic number: off += 4;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		off += 4;  		break;  	case BT_AMP:  		if (off == start)  			return scanRef (buf' off + minBPC' end' token);  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_LT:  		/* this is for inside entity references */throw new InvalidTokenException (off);  	case BT_S:  		if (off == start) {  			token.TokenEnd = off + minBPC;  			return TOK.ATTRIBUTE_VALUE_S;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_LF:  		if (off == start) {  			token.TokenEnd = off + minBPC;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_CR:  		if (off == start) {  			off += minBPC;  			if (off == end)  				throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  			if (byteType (buf' off) == BT_LF)  				off += minBPC;  			token.TokenEnd = off;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		off += 4;  		break;  	case BT_AMP:  		if (off == start)  			return scanRef (buf' off + minBPC' end' token);  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_LT:  		/* this is for inside entity references */throw new InvalidTokenException (off);  	case BT_S:  		if (off == start) {  			token.TokenEnd = off + minBPC;  			return TOK.ATTRIBUTE_VALUE_S;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_LF:  		if (off == start) {  			token.TokenEnd = off + minBPC;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_CR:  		if (off == start) {  			off += minBPC;  			if (off == end)  				throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  			if (byteType (buf' off) == BT_LF)  				off += minBPC;  			token.TokenEnd = off;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		off += 4;  		break;  	case BT_AMP:  		if (off == start)  			return scanRef (buf' off + minBPC' end' token);  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_LT:  		/* this is for inside entity references */throw new InvalidTokenException (off);  	case BT_S:  		if (off == start) {  			token.TokenEnd = off + minBPC;  			return TOK.ATTRIBUTE_VALUE_S;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_LF:  		if (off == start) {  			token.TokenEnd = off + minBPC;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_CR:  		if (off == start) {  			off += minBPC;  			if (off == end)  				throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  			if (byteType (buf' off) == BT_LF)  				off += minBPC;  			token.TokenEnd = off;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		off += 4;  		break;  	case BT_AMP:  		if (off == start)  			return scanRef (buf' off + minBPC' end' token);  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_LT:  		/* this is for inside entity references */throw new InvalidTokenException (off);  	case BT_S:  		if (off == start) {  			token.TokenEnd = off + minBPC;  			return TOK.ATTRIBUTE_VALUE_S;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_LF:  		if (off == start) {  			token.TokenEnd = off + minBPC;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_CR:  		if (off == start) {  			off += minBPC;  			if (off == end)  				throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  			if (byteType (buf' off) == BT_LF)  				off += minBPC;  			token.TokenEnd = off;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		off += 4;  		break;  	case BT_AMP:  		if (off == start)  			return scanRef (buf' off + minBPC' end' token);  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_LT:  		/* this is for inside entity references */throw new InvalidTokenException (off);  	case BT_S:  		if (off == start) {  			token.TokenEnd = off + minBPC;  			return TOK.ATTRIBUTE_VALUE_S;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_LF:  		if (off == start) {  			token.TokenEnd = off + minBPC;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_CR:  		if (off == start) {  			off += minBPC;  			if (off == end)  				throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  			if (byteType (buf' off) == BT_LF)  				off += minBPC;  			token.TokenEnd = off;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		off += 4;  		break;  	case BT_AMP:  		if (off == start)  			return scanRef (buf' off + minBPC' end' token);  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_LT:  		/* this is for inside entity references */throw new InvalidTokenException (off);  	case BT_S:  		if (off == start) {  			token.TokenEnd = off + minBPC;  			return TOK.ATTRIBUTE_VALUE_S;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_LF:  		if (off == start) {  			token.TokenEnd = off + minBPC;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_CR:  		if (off == start) {  			off += minBPC;  			if (off == end)  				throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  			if (byteType (buf' off) == BT_LF)  				off += minBPC;  			token.TokenEnd = off;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	off += 4;  	break;  case BT_AMP:  	if (off == start)  		return scanRef (buf' off + minBPC' end' token);  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_LT:  	/* this is for inside entity references */throw new InvalidTokenException (off);  case BT_S:  	if (off == start) {  		token.TokenEnd = off + minBPC;  		return TOK.ATTRIBUTE_VALUE_S;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_LF:  	if (off == start) {  		token.TokenEnd = off + minBPC;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_CR:  	if (off == start) {  		off += minBPC;  		if (off == end)  			throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  		if (byteType (buf' off) == BT_LF)  			off += minBPC;  		token.TokenEnd = off;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	off += 4;  	break;  case BT_AMP:  	if (off == start)  		return scanRef (buf' off + minBPC' end' token);  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_LT:  	/* this is for inside entity references */throw new InvalidTokenException (off);  case BT_S:  	if (off == start) {  		token.TokenEnd = off + minBPC;  		return TOK.ATTRIBUTE_VALUE_S;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_LF:  	if (off == start) {  		token.TokenEnd = off + minBPC;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_CR:  	if (off == start) {  		off += minBPC;  		if (off == end)  			throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  		if (byteType (buf' off) == BT_LF)  			off += minBPC;  		token.TokenEnd = off;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	off += 4;  	break;  case BT_AMP:  	if (off == start)  		return scanRef (buf' off + minBPC' end' token);  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_LT:  	/* this is for inside entity references */throw new InvalidTokenException (off);  case BT_S:  	if (off == start) {  		token.TokenEnd = off + minBPC;  		return TOK.ATTRIBUTE_VALUE_S;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_LF:  	if (off == start) {  		token.TokenEnd = off + minBPC;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_CR:  	if (off == start) {  		off += minBPC;  		if (off == end)  			throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  		if (byteType (buf' off) == BT_LF)  			off += minBPC;  		token.TokenEnd = off;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	off += 4;  	break;  case BT_AMP:  	if (off == start)  		return scanRef (buf' off + minBPC' end' token);  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_LT:  	/* this is for inside entity references */throw new InvalidTokenException (off);  case BT_S:  	if (off == start) {  		token.TokenEnd = off + minBPC;  		return TOK.ATTRIBUTE_VALUE_S;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_LF:  	if (off == start) {  		token.TokenEnd = off + minBPC;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_CR:  	if (off == start) {  		off += minBPC;  		if (off == end)  			throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  		if (byteType (buf' off) == BT_LF)  			off += minBPC;  		token.TokenEnd = off;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	off += 4;  	break;  case BT_AMP:  	if (off == start)  		return scanRef (buf' off + minBPC' end' token);  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_LT:  	/* this is for inside entity references */throw new InvalidTokenException (off);  case BT_S:  	if (off == start) {  		token.TokenEnd = off + minBPC;  		return TOK.ATTRIBUTE_VALUE_S;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_LF:  	if (off == start) {  		token.TokenEnd = off + minBPC;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_CR:  	if (off == start) {  		off += minBPC;  		if (off == end)  			throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  		if (byteType (buf' off) == BT_LF)  			off += minBPC;  		token.TokenEnd = off;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	off += 4;  	break;  case BT_AMP:  	if (off == start)  		return scanRef (buf' off + minBPC' end' token);  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_LT:  	/* this is for inside entity references */throw new InvalidTokenException (off);  case BT_S:  	if (off == start) {  		token.TokenEnd = off + minBPC;  		return TOK.ATTRIBUTE_VALUE_S;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_LF:  	if (off == start) {  		token.TokenEnd = off + minBPC;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_CR:  	if (off == start) {  		off += minBPC;  		if (off == end)  			throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  		if (byteType (buf' off) == BT_LF)  			off += minBPC;  		token.TokenEnd = off;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: off += 2;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: off += 3;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeAttributeValue,The following statement contains a magic number: off += 4;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		off += 4;  		break;  	case BT_AMP:  		if (off == start)  			return scanRef (buf' off + minBPC' end' token);  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_PERCNT:  		if (off == start)  			return scanPercent (buf' off + minBPC' end' token);  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_LF:  		if (off == start) {  			token.TokenEnd = off + minBPC;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_CR:  		if (off == start) {  			off += minBPC;  			if (off == end)  				throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  			if (byteType (buf' off) == BT_LF)  				off += minBPC;  			token.TokenEnd = off;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		off += 4;  		break;  	case BT_AMP:  		if (off == start)  			return scanRef (buf' off + minBPC' end' token);  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_PERCNT:  		if (off == start)  			return scanPercent (buf' off + minBPC' end' token);  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_LF:  		if (off == start) {  			token.TokenEnd = off + minBPC;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_CR:  		if (off == start) {  			off += minBPC;  			if (off == end)  				throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  			if (byteType (buf' off) == BT_LF)  				off += minBPC;  			token.TokenEnd = off;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		off += 4;  		break;  	case BT_AMP:  		if (off == start)  			return scanRef (buf' off + minBPC' end' token);  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_PERCNT:  		if (off == start)  			return scanPercent (buf' off + minBPC' end' token);  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_LF:  		if (off == start) {  			token.TokenEnd = off + minBPC;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_CR:  		if (off == start) {  			off += minBPC;  			if (off == end)  				throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  			if (byteType (buf' off) == BT_LF)  				off += minBPC;  			token.TokenEnd = off;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		off += 4;  		break;  	case BT_AMP:  		if (off == start)  			return scanRef (buf' off + minBPC' end' token);  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_PERCNT:  		if (off == start)  			return scanPercent (buf' off + minBPC' end' token);  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_LF:  		if (off == start) {  			token.TokenEnd = off + minBPC;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_CR:  		if (off == start) {  			off += minBPC;  			if (off == end)  				throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  			if (byteType (buf' off) == BT_LF)  				off += minBPC;  			token.TokenEnd = off;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		off += 4;  		break;  	case BT_AMP:  		if (off == start)  			return scanRef (buf' off + minBPC' end' token);  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_PERCNT:  		if (off == start)  			return scanPercent (buf' off + minBPC' end' token);  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_LF:  		if (off == start) {  			token.TokenEnd = off + minBPC;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_CR:  		if (off == start) {  			off += minBPC;  			if (off == end)  				throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  			if (byteType (buf' off) == BT_LF)  				off += minBPC;  			token.TokenEnd = off;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		off += 4;  		break;  	case BT_AMP:  		if (off == start)  			return scanRef (buf' off + minBPC' end' token);  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_PERCNT:  		if (off == start)  			return scanPercent (buf' off + minBPC' end' token);  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_LF:  		if (off == start) {  			token.TokenEnd = off + minBPC;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	case BT_CR:  		if (off == start) {  			off += minBPC;  			if (off == end)  				throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  			if (byteType (buf' off) == BT_LF)  				off += minBPC;  			token.TokenEnd = off;  			return TOK.DATA_NEWLINE;  		}  		token.TokenEnd = off;  		return TOK.DATA_CHARS;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	off += 4;  	break;  case BT_AMP:  	if (off == start)  		return scanRef (buf' off + minBPC' end' token);  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_PERCNT:  	if (off == start)  		return scanPercent (buf' off + minBPC' end' token);  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_LF:  	if (off == start) {  		token.TokenEnd = off + minBPC;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_CR:  	if (off == start) {  		off += minBPC;  		if (off == end)  			throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  		if (byteType (buf' off) == BT_LF)  			off += minBPC;  		token.TokenEnd = off;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	off += 4;  	break;  case BT_AMP:  	if (off == start)  		return scanRef (buf' off + minBPC' end' token);  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_PERCNT:  	if (off == start)  		return scanPercent (buf' off + minBPC' end' token);  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_LF:  	if (off == start) {  		token.TokenEnd = off + minBPC;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_CR:  	if (off == start) {  		off += minBPC;  		if (off == end)  			throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  		if (byteType (buf' off) == BT_LF)  			off += minBPC;  		token.TokenEnd = off;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	off += 4;  	break;  case BT_AMP:  	if (off == start)  		return scanRef (buf' off + minBPC' end' token);  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_PERCNT:  	if (off == start)  		return scanPercent (buf' off + minBPC' end' token);  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_LF:  	if (off == start) {  		token.TokenEnd = off + minBPC;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_CR:  	if (off == start) {  		off += minBPC;  		if (off == end)  			throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  		if (byteType (buf' off) == BT_LF)  			off += minBPC;  		token.TokenEnd = off;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	off += 4;  	break;  case BT_AMP:  	if (off == start)  		return scanRef (buf' off + minBPC' end' token);  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_PERCNT:  	if (off == start)  		return scanPercent (buf' off + minBPC' end' token);  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_LF:  	if (off == start) {  		token.TokenEnd = off + minBPC;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_CR:  	if (off == start) {  		off += minBPC;  		if (off == end)  			throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  		if (byteType (buf' off) == BT_LF)  			off += minBPC;  		token.TokenEnd = off;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	off += 4;  	break;  case BT_AMP:  	if (off == start)  		return scanRef (buf' off + minBPC' end' token);  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_PERCNT:  	if (off == start)  		return scanPercent (buf' off + minBPC' end' token);  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_LF:  	if (off == start) {  		token.TokenEnd = off + minBPC;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_CR:  	if (off == start) {  		off += minBPC;  		if (off == end)  			throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  		if (byteType (buf' off) == BT_LF)  			off += minBPC;  		token.TokenEnd = off;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	off += 4;  	break;  case BT_AMP:  	if (off == start)  		return scanRef (buf' off + minBPC' end' token);  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_PERCNT:  	if (off == start)  		return scanPercent (buf' off + minBPC' end' token);  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_LF:  	if (off == start) {  		token.TokenEnd = off + minBPC;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  case BT_CR:  	if (off == start) {  		off += minBPC;  		if (off == end)  			throw new ExtensibleTokenException (TOK.DATA_NEWLINE);  		if (byteType (buf' off) == BT_LF)  			off += minBPC;  		token.TokenEnd = off;  		return TOK.DATA_NEWLINE;  	}  	token.TokenEnd = off;  	return TOK.DATA_CHARS;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: off += 2;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: off += 3;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeEntityValue,The following statement contains a magic number: off += 4;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_LT:  		off += minBPC;  		if (off == end)  			goto loop;  		if (!charMatches (buf' off' '!'))  			break;  		off += minBPC;  		if (off == end)  			goto loop;  		if (!charMatches (buf' off' '['))  			break;  		level++;  		off += minBPC;  		break;  	case BT_RSQB:  		off += minBPC;  		if (off == end)  			goto loop;  		if (!charMatches (buf' off' ']'))  			break;  		off += minBPC;  		if (off == end)  			goto loop;  		if (charMatches (buf' off' '>')) {  			if (level == 0)  				return off + minBPC;  			level--;  		} else if (charMatches (buf' off' ']'))  			break;  		off += minBPC;  		break;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_LT:  		off += minBPC;  		if (off == end)  			goto loop;  		if (!charMatches (buf' off' '!'))  			break;  		off += minBPC;  		if (off == end)  			goto loop;  		if (!charMatches (buf' off' '['))  			break;  		level++;  		off += minBPC;  		break;  	case BT_RSQB:  		off += minBPC;  		if (off == end)  			goto loop;  		if (!charMatches (buf' off' ']'))  			break;  		off += minBPC;  		if (off == end)  			goto loop;  		if (charMatches (buf' off' '>')) {  			if (level == 0)  				return off + minBPC;  			level--;  		} else if (charMatches (buf' off' ']'))  			break;  		off += minBPC;  		break;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_LT:  		off += minBPC;  		if (off == end)  			goto loop;  		if (!charMatches (buf' off' '!'))  			break;  		off += minBPC;  		if (off == end)  			goto loop;  		if (!charMatches (buf' off' '['))  			break;  		level++;  		off += minBPC;  		break;  	case BT_RSQB:  		off += minBPC;  		if (off == end)  			goto loop;  		if (!charMatches (buf' off' ']'))  			break;  		off += minBPC;  		if (off == end)  			goto loop;  		if (charMatches (buf' off' '>')) {  			if (level == 0)  				return off + minBPC;  			level--;  		} else if (charMatches (buf' off' ']'))  			break;  		off += minBPC;  		break;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_LT:  		off += minBPC;  		if (off == end)  			goto loop;  		if (!charMatches (buf' off' '!'))  			break;  		off += minBPC;  		if (off == end)  			goto loop;  		if (!charMatches (buf' off' '['))  			break;  		level++;  		off += minBPC;  		break;  	case BT_RSQB:  		off += minBPC;  		if (off == end)  			goto loop;  		if (!charMatches (buf' off' ']'))  			break;  		off += minBPC;  		if (off == end)  			goto loop;  		if (charMatches (buf' off' '>')) {  			if (level == 0)  				return off + minBPC;  			level--;  		} else if (charMatches (buf' off' ']'))  			break;  		off += minBPC;  		break;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_LT:  		off += minBPC;  		if (off == end)  			goto loop;  		if (!charMatches (buf' off' '!'))  			break;  		off += minBPC;  		if (off == end)  			goto loop;  		if (!charMatches (buf' off' '['))  			break;  		level++;  		off += minBPC;  		break;  	case BT_RSQB:  		off += minBPC;  		if (off == end)  			goto loop;  		if (!charMatches (buf' off' ']'))  			break;  		off += minBPC;  		if (off == end)  			goto loop;  		if (charMatches (buf' off' '>')) {  			if (level == 0)  				return off + minBPC;  			level--;  		} else if (charMatches (buf' off' ']'))  			break;  		off += minBPC;  		break;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: while (off != end) {  	switch (byteType (buf' off)) {  	case BT_LEAD2:  		if (end - off < 2)  			throw new PartialCharException (off);  		check2 (buf' off);  		off += 2;  		break;  	case BT_LEAD3:  		if (end - off < 3)  			throw new PartialCharException (off);  		check3 (buf' off);  		off += 3;  		break;  	case BT_LEAD4:  		if (end - off < 4)  			throw new PartialCharException (off);  		check4 (buf' off);  		off += 4;  		break;  	case BT_NONXML:  	case BT_MALFORM:  		throw new InvalidTokenException (off);  	case BT_LT:  		off += minBPC;  		if (off == end)  			goto loop;  		if (!charMatches (buf' off' '!'))  			break;  		off += minBPC;  		if (off == end)  			goto loop;  		if (!charMatches (buf' off' '['))  			break;  		level++;  		off += minBPC;  		break;  	case BT_RSQB:  		off += minBPC;  		if (off == end)  			goto loop;  		if (!charMatches (buf' off' ']'))  			break;  		off += minBPC;  		if (off == end)  			goto loop;  		if (charMatches (buf' off' '>')) {  			if (level == 0)  				return off + minBPC;  			level--;  		} else if (charMatches (buf' off' ']'))  			break;  		off += minBPC;  		break;  	default:  		off += minBPC;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LT:  	off += minBPC;  	if (off == end)  		goto loop;  	if (!charMatches (buf' off' '!'))  		break;  	off += minBPC;  	if (off == end)  		goto loop;  	if (!charMatches (buf' off' '['))  		break;  	level++;  	off += minBPC;  	break;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		goto loop;  	if (!charMatches (buf' off' ']'))  		break;  	off += minBPC;  	if (off == end)  		goto loop;  	if (charMatches (buf' off' '>')) {  		if (level == 0)  			return off + minBPC;  		level--;  	} else if (charMatches (buf' off' ']'))  		break;  	off += minBPC;  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LT:  	off += minBPC;  	if (off == end)  		goto loop;  	if (!charMatches (buf' off' '!'))  		break;  	off += minBPC;  	if (off == end)  		goto loop;  	if (!charMatches (buf' off' '['))  		break;  	level++;  	off += minBPC;  	break;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		goto loop;  	if (!charMatches (buf' off' ']'))  		break;  	off += minBPC;  	if (off == end)  		goto loop;  	if (charMatches (buf' off' '>')) {  		if (level == 0)  			return off + minBPC;  		level--;  	} else if (charMatches (buf' off' ']'))  		break;  	off += minBPC;  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LT:  	off += minBPC;  	if (off == end)  		goto loop;  	if (!charMatches (buf' off' '!'))  		break;  	off += minBPC;  	if (off == end)  		goto loop;  	if (!charMatches (buf' off' '['))  		break;  	level++;  	off += minBPC;  	break;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		goto loop;  	if (!charMatches (buf' off' ']'))  		break;  	off += minBPC;  	if (off == end)  		goto loop;  	if (charMatches (buf' off' '>')) {  		if (level == 0)  			return off + minBPC;  		level--;  	} else if (charMatches (buf' off' ']'))  		break;  	off += minBPC;  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LT:  	off += minBPC;  	if (off == end)  		goto loop;  	if (!charMatches (buf' off' '!'))  		break;  	off += minBPC;  	if (off == end)  		goto loop;  	if (!charMatches (buf' off' '['))  		break;  	level++;  	off += minBPC;  	break;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		goto loop;  	if (!charMatches (buf' off' ']'))  		break;  	off += minBPC;  	if (off == end)  		goto loop;  	if (charMatches (buf' off' '>')) {  		if (level == 0)  			return off + minBPC;  		level--;  	} else if (charMatches (buf' off' ']'))  		break;  	off += minBPC;  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LT:  	off += minBPC;  	if (off == end)  		goto loop;  	if (!charMatches (buf' off' '!'))  		break;  	off += minBPC;  	if (off == end)  		goto loop;  	if (!charMatches (buf' off' '['))  		break;  	level++;  	off += minBPC;  	break;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		goto loop;  	if (!charMatches (buf' off' ']'))  		break;  	off += minBPC;  	if (off == end)  		goto loop;  	if (charMatches (buf' off' '>')) {  		if (level == 0)  			return off + minBPC;  		level--;  	} else if (charMatches (buf' off' ']'))  		break;  	off += minBPC;  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: switch (byteType (buf' off)) {  case BT_LEAD2:  	if (end - off < 2)  		throw new PartialCharException (off);  	check2 (buf' off);  	off += 2;  	break;  case BT_LEAD3:  	if (end - off < 3)  		throw new PartialCharException (off);  	check3 (buf' off);  	off += 3;  	break;  case BT_LEAD4:  	if (end - off < 4)  		throw new PartialCharException (off);  	check4 (buf' off);  	off += 4;  	break;  case BT_NONXML:  case BT_MALFORM:  	throw new InvalidTokenException (off);  case BT_LT:  	off += minBPC;  	if (off == end)  		goto loop;  	if (!charMatches (buf' off' '!'))  		break;  	off += minBPC;  	if (off == end)  		goto loop;  	if (!charMatches (buf' off' '['))  		break;  	level++;  	off += minBPC;  	break;  case BT_RSQB:  	off += minBPC;  	if (off == end)  		goto loop;  	if (!charMatches (buf' off' ']'))  		break;  	off += minBPC;  	if (off == end)  		goto loop;  	if (charMatches (buf' off' '>')) {  		if (level == 0)  			return off + minBPC;  		level--;  	} else if (charMatches (buf' off' ']'))  		break;  	off += minBPC;  	break;  default:  	off += minBPC;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: if (end - off < 2)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: off += 2;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: if (end - off < 3)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: off += 3;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: if (end - off < 4)  	throw new PartialCharException (off);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,skipIgnoreSect,The following statement contains a magic number: off += 4;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,setCharType,The following statement contains a magic number: if (charTypeTable [hi] == null) {  	charTypeTable [hi] = new int[256];  	for (int i = 0; i < 256; i++)  		charTypeTable [hi] [i] = BT_OTHER;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,setCharType,The following statement contains a magic number: if (charTypeTable [hi] == null) {  	charTypeTable [hi] = new int[256];  	for (int i = 0; i < 256; i++)  		charTypeTable [hi] [i] = BT_OTHER;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,setCharType,The following statement contains a magic number: charTypeTable [hi] = new int[256];  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,setCharType,The following statement contains a magic number: for (int i = 0; i < 256; i++)  	charTypeTable [hi] [i] = BT_OTHER;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,setCharType,The following statement contains a magic number: do {  	if ((min & 0xFF) == 0) {  		for (; min + (char)0xFF <= max; min += (char)0x100) {  			if (shared == null) {  				shared = new int[256];  				for (int i = 0; i < 256; i++)  					shared [i] = type;  			}  			charTypeTable [min >> 8] = shared;  			if (min + 0xFF == max)  				return;  		}  	}  	setCharType (min' type);  } while (min++ != max);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,setCharType,The following statement contains a magic number: do {  	if ((min & 0xFF) == 0) {  		for (; min + (char)0xFF <= max; min += (char)0x100) {  			if (shared == null) {  				shared = new int[256];  				for (int i = 0; i < 256; i++)  					shared [i] = type;  			}  			charTypeTable [min >> 8] = shared;  			if (min + 0xFF == max)  				return;  		}  	}  	setCharType (min' type);  } while (min++ != max);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,setCharType,The following statement contains a magic number: do {  	if ((min & 0xFF) == 0) {  		for (; min + (char)0xFF <= max; min += (char)0x100) {  			if (shared == null) {  				shared = new int[256];  				for (int i = 0; i < 256; i++)  					shared [i] = type;  			}  			charTypeTable [min >> 8] = shared;  			if (min + 0xFF == max)  				return;  		}  	}  	setCharType (min' type);  } while (min++ != max);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,setCharType,The following statement contains a magic number: if ((min & 0xFF) == 0) {  	for (; min + (char)0xFF <= max; min += (char)0x100) {  		if (shared == null) {  			shared = new int[256];  			for (int i = 0; i < 256; i++)  				shared [i] = type;  		}  		charTypeTable [min >> 8] = shared;  		if (min + 0xFF == max)  			return;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,setCharType,The following statement contains a magic number: if ((min & 0xFF) == 0) {  	for (; min + (char)0xFF <= max; min += (char)0x100) {  		if (shared == null) {  			shared = new int[256];  			for (int i = 0; i < 256; i++)  				shared [i] = type;  		}  		charTypeTable [min >> 8] = shared;  		if (min + 0xFF == max)  			return;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,setCharType,The following statement contains a magic number: if ((min & 0xFF) == 0) {  	for (; min + (char)0xFF <= max; min += (char)0x100) {  		if (shared == null) {  			shared = new int[256];  			for (int i = 0; i < 256; i++)  				shared [i] = type;  		}  		charTypeTable [min >> 8] = shared;  		if (min + 0xFF == max)  			return;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,setCharType,The following statement contains a magic number: for (; min + (char)0xFF <= max; min += (char)0x100) {  	if (shared == null) {  		shared = new int[256];  		for (int i = 0; i < 256; i++)  			shared [i] = type;  	}  	charTypeTable [min >> 8] = shared;  	if (min + 0xFF == max)  		return;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,setCharType,The following statement contains a magic number: for (; min + (char)0xFF <= max; min += (char)0x100) {  	if (shared == null) {  		shared = new int[256];  		for (int i = 0; i < 256; i++)  			shared [i] = type;  	}  	charTypeTable [min >> 8] = shared;  	if (min + 0xFF == max)  		return;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,setCharType,The following statement contains a magic number: for (; min + (char)0xFF <= max; min += (char)0x100) {  	if (shared == null) {  		shared = new int[256];  		for (int i = 0; i < 256; i++)  			shared [i] = type;  	}  	charTypeTable [min >> 8] = shared;  	if (min + 0xFF == max)  		return;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,setCharType,The following statement contains a magic number: if (shared == null) {  	shared = new int[256];  	for (int i = 0; i < 256; i++)  		shared [i] = type;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,setCharType,The following statement contains a magic number: if (shared == null) {  	shared = new int[256];  	for (int i = 0; i < 256; i++)  		shared [i] = type;  }  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,setCharType,The following statement contains a magic number: shared = new int[256];  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,setCharType,The following statement contains a magic number: for (int i = 0; i < 256; i++)  	shared [i] = type;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,setCharType,The following statement contains a magic number: charTypeTable [min >> 8] = shared;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,Encoding,The following statement contains a magic number: charTypeTable = new int[256][];  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,Encoding,The following statement contains a magic number: for (int i = 0; i < nameRanges.Length; i += 2)  	setCharType (nameRanges [i]' nameRanges [i + 1]' BT_NAME);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,Encoding,The following statement contains a magic number: i += 2
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,Encoding,The following statement contains a magic number: for (int i = 0; i < nameStartRanges.Length; i += 2)  	setCharType (nameStartRanges [i]' nameStartRanges [i + 1]' BT_NMSTRT);  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,Encoding,The following statement contains a magic number: i += 2
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,Encoding,The following statement contains a magic number: for (int i = 0; i < 256; i++)  	other [i] = BT_OTHER;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,Encoding,The following statement contains a magic number: for (int i = 0; i < 256; i++)  	if (charTypeTable [i] == null)  		charTypeTable [i] = other;  
Magic Number,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,Encoding,The following statement contains a magic number: System.Array.Copy (asciiTypeTable' 0' charTypeTable [0]' 0' 128);  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,UTF8Encoding,The following statement contains a magic number: System.Array.Copy (asciiTypeTable' 0' utf8TypeTable' 0' 128);  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,UTF8Encoding,The following statement contains a magic number: System.Array.Copy (utf8HiTypeTable' 0' utf8TypeTable' 128' 128);  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,UTF8Encoding,The following statement contains a magic number: System.Array.Copy (utf8HiTypeTable' 0' utf8TypeTable' 128' 128);  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,byteType2,The following statement contains a magic number: return page [((buf [off] & 3) << 6) | (buf [off + 1] & 0x3F)];  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,byteType2,The following statement contains a magic number: return page [((buf [off] & 3) << 6) | (buf [off + 1] & 0x3F)];  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,byteType3,The following statement contains a magic number: return page [((buf [off + 1] & 3) << 6) | (buf [off + 2] & 0x3F)];  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,byteType3,The following statement contains a magic number: return page [((buf [off + 1] & 3) << 6) | (buf [off + 2] & 0x3F)];  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,byteType3,The following statement contains a magic number: return page [((buf [off + 1] & 3) << 6) | (buf [off + 2] & 0x3F)];  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,check3,The following statement contains a magic number: switch (buf [off]) {  case 0xEF:  	/* 0xFFFF 0xFFFE */if ((buf [off + 1] == 0xBF) && ((buf [off + 2] == 0xBF) || (buf [off + 2] == 0xBE)))  		throw new InvalidTokenException (off);  	return;  case 0xED:  	/* 0xD800..0xDFFF <=> top 5 bits are 11011 */if ((buf [off + 1] & 0x20) != 0)  		throw new InvalidTokenException (off);  	return;  default:  	return;  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,check3,The following statement contains a magic number: switch (buf [off]) {  case 0xEF:  	/* 0xFFFF 0xFFFE */if ((buf [off + 1] == 0xBF) && ((buf [off + 2] == 0xBF) || (buf [off + 2] == 0xBE)))  		throw new InvalidTokenException (off);  	return;  case 0xED:  	/* 0xD800..0xDFFF <=> top 5 bits are 11011 */if ((buf [off + 1] & 0x20) != 0)  		throw new InvalidTokenException (off);  	return;  default:  	return;  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,check3,The following statement contains a magic number: if ((buf [off + 1] == 0xBF) && ((buf [off + 2] == 0xBF) || (buf [off + 2] == 0xBE)))  	throw new InvalidTokenException (off);  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,check3,The following statement contains a magic number: if ((buf [off + 1] == 0xBF) && ((buf [off + 2] == 0xBF) || (buf [off + 2] == 0xBE)))  	throw new InvalidTokenException (off);  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,check4,The following statement contains a magic number: switch (buf [off] & 0x7) {  default:  	return;  case 5:  case 6:  case 7:  	break;  case 4:  	if ((buf [off + 1] & 0x30) == 0)  		return;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,check4,The following statement contains a magic number: switch (buf [off] & 0x7) {  default:  	return;  case 5:  case 6:  case 7:  	break;  case 4:  	if ((buf [off + 1] & 0x30) == 0)  		return;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,check4,The following statement contains a magic number: switch (buf [off] & 0x7) {  default:  	return;  case 5:  case 6:  case 7:  	break;  case 4:  	if ((buf [off + 1] & 0x30) == 0)  		return;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,check4,The following statement contains a magic number: switch (buf [off] & 0x7) {  default:  	return;  case 5:  case 6:  case 7:  	break;  case 4:  	if ((buf [off + 1] & 0x30) == 0)  		return;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: while (sourceStart != sourceEnd) {  	byte b = sourceBuf [sourceStart++];  	if (b >= 0)  		targetBuf [targetStart++] = (char)b;  	else {  		switch (utf8TypeTable [b & 0xFF]) {  		case BT_LEAD2:  			/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  			break;  		case BT_LEAD3:  			/* 4' 6' 6 */c = (b & 0xF) << 12;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  			c |= (sourceBuf [sourceStart++] & 0x3F);  			targetBuf [targetStart++] = (char)c;  			break;  		case BT_LEAD4:  			/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  			c |= (sourceBuf [sourceStart++] & 0x3F);  			c -= 0x10000;  			targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  			targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  			break;  		}  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: while (sourceStart != sourceEnd) {  	byte b = sourceBuf [sourceStart++];  	if (b >= 0)  		targetBuf [targetStart++] = (char)b;  	else {  		switch (utf8TypeTable [b & 0xFF]) {  		case BT_LEAD2:  			/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  			break;  		case BT_LEAD3:  			/* 4' 6' 6 */c = (b & 0xF) << 12;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  			c |= (sourceBuf [sourceStart++] & 0x3F);  			targetBuf [targetStart++] = (char)c;  			break;  		case BT_LEAD4:  			/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  			c |= (sourceBuf [sourceStart++] & 0x3F);  			c -= 0x10000;  			targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  			targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  			break;  		}  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: while (sourceStart != sourceEnd) {  	byte b = sourceBuf [sourceStart++];  	if (b >= 0)  		targetBuf [targetStart++] = (char)b;  	else {  		switch (utf8TypeTable [b & 0xFF]) {  		case BT_LEAD2:  			/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  			break;  		case BT_LEAD3:  			/* 4' 6' 6 */c = (b & 0xF) << 12;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  			c |= (sourceBuf [sourceStart++] & 0x3F);  			targetBuf [targetStart++] = (char)c;  			break;  		case BT_LEAD4:  			/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  			c |= (sourceBuf [sourceStart++] & 0x3F);  			c -= 0x10000;  			targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  			targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  			break;  		}  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: while (sourceStart != sourceEnd) {  	byte b = sourceBuf [sourceStart++];  	if (b >= 0)  		targetBuf [targetStart++] = (char)b;  	else {  		switch (utf8TypeTable [b & 0xFF]) {  		case BT_LEAD2:  			/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  			break;  		case BT_LEAD3:  			/* 4' 6' 6 */c = (b & 0xF) << 12;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  			c |= (sourceBuf [sourceStart++] & 0x3F);  			targetBuf [targetStart++] = (char)c;  			break;  		case BT_LEAD4:  			/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  			c |= (sourceBuf [sourceStart++] & 0x3F);  			c -= 0x10000;  			targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  			targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  			break;  		}  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: while (sourceStart != sourceEnd) {  	byte b = sourceBuf [sourceStart++];  	if (b >= 0)  		targetBuf [targetStart++] = (char)b;  	else {  		switch (utf8TypeTable [b & 0xFF]) {  		case BT_LEAD2:  			/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  			break;  		case BT_LEAD3:  			/* 4' 6' 6 */c = (b & 0xF) << 12;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  			c |= (sourceBuf [sourceStart++] & 0x3F);  			targetBuf [targetStart++] = (char)c;  			break;  		case BT_LEAD4:  			/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  			c |= (sourceBuf [sourceStart++] & 0x3F);  			c -= 0x10000;  			targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  			targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  			break;  		}  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: while (sourceStart != sourceEnd) {  	byte b = sourceBuf [sourceStart++];  	if (b >= 0)  		targetBuf [targetStart++] = (char)b;  	else {  		switch (utf8TypeTable [b & 0xFF]) {  		case BT_LEAD2:  			/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  			break;  		case BT_LEAD3:  			/* 4' 6' 6 */c = (b & 0xF) << 12;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  			c |= (sourceBuf [sourceStart++] & 0x3F);  			targetBuf [targetStart++] = (char)c;  			break;  		case BT_LEAD4:  			/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  			c |= (sourceBuf [sourceStart++] & 0x3F);  			c -= 0x10000;  			targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  			targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  			break;  		}  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: while (sourceStart != sourceEnd) {  	byte b = sourceBuf [sourceStart++];  	if (b >= 0)  		targetBuf [targetStart++] = (char)b;  	else {  		switch (utf8TypeTable [b & 0xFF]) {  		case BT_LEAD2:  			/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  			break;  		case BT_LEAD3:  			/* 4' 6' 6 */c = (b & 0xF) << 12;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  			c |= (sourceBuf [sourceStart++] & 0x3F);  			targetBuf [targetStart++] = (char)c;  			break;  		case BT_LEAD4:  			/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  			c |= (sourceBuf [sourceStart++] & 0x3F);  			c -= 0x10000;  			targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  			targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  			break;  		}  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: while (sourceStart != sourceEnd) {  	byte b = sourceBuf [sourceStart++];  	if (b >= 0)  		targetBuf [targetStart++] = (char)b;  	else {  		switch (utf8TypeTable [b & 0xFF]) {  		case BT_LEAD2:  			/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  			break;  		case BT_LEAD3:  			/* 4' 6' 6 */c = (b & 0xF) << 12;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  			c |= (sourceBuf [sourceStart++] & 0x3F);  			targetBuf [targetStart++] = (char)c;  			break;  		case BT_LEAD4:  			/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  			c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  			c |= (sourceBuf [sourceStart++] & 0x3F);  			c -= 0x10000;  			targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  			targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  			break;  		}  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: if (b >= 0)  	targetBuf [targetStart++] = (char)b;  else {  	switch (utf8TypeTable [b & 0xFF]) {  	case BT_LEAD2:  		/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  		break;  	case BT_LEAD3:  		/* 4' 6' 6 */c = (b & 0xF) << 12;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  		c |= (sourceBuf [sourceStart++] & 0x3F);  		targetBuf [targetStart++] = (char)c;  		break;  	case BT_LEAD4:  		/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  		c |= (sourceBuf [sourceStart++] & 0x3F);  		c -= 0x10000;  		targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  		targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: if (b >= 0)  	targetBuf [targetStart++] = (char)b;  else {  	switch (utf8TypeTable [b & 0xFF]) {  	case BT_LEAD2:  		/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  		break;  	case BT_LEAD3:  		/* 4' 6' 6 */c = (b & 0xF) << 12;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  		c |= (sourceBuf [sourceStart++] & 0x3F);  		targetBuf [targetStart++] = (char)c;  		break;  	case BT_LEAD4:  		/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  		c |= (sourceBuf [sourceStart++] & 0x3F);  		c -= 0x10000;  		targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  		targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: if (b >= 0)  	targetBuf [targetStart++] = (char)b;  else {  	switch (utf8TypeTable [b & 0xFF]) {  	case BT_LEAD2:  		/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  		break;  	case BT_LEAD3:  		/* 4' 6' 6 */c = (b & 0xF) << 12;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  		c |= (sourceBuf [sourceStart++] & 0x3F);  		targetBuf [targetStart++] = (char)c;  		break;  	case BT_LEAD4:  		/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  		c |= (sourceBuf [sourceStart++] & 0x3F);  		c -= 0x10000;  		targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  		targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: if (b >= 0)  	targetBuf [targetStart++] = (char)b;  else {  	switch (utf8TypeTable [b & 0xFF]) {  	case BT_LEAD2:  		/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  		break;  	case BT_LEAD3:  		/* 4' 6' 6 */c = (b & 0xF) << 12;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  		c |= (sourceBuf [sourceStart++] & 0x3F);  		targetBuf [targetStart++] = (char)c;  		break;  	case BT_LEAD4:  		/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  		c |= (sourceBuf [sourceStart++] & 0x3F);  		c -= 0x10000;  		targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  		targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: if (b >= 0)  	targetBuf [targetStart++] = (char)b;  else {  	switch (utf8TypeTable [b & 0xFF]) {  	case BT_LEAD2:  		/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  		break;  	case BT_LEAD3:  		/* 4' 6' 6 */c = (b & 0xF) << 12;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  		c |= (sourceBuf [sourceStart++] & 0x3F);  		targetBuf [targetStart++] = (char)c;  		break;  	case BT_LEAD4:  		/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  		c |= (sourceBuf [sourceStart++] & 0x3F);  		c -= 0x10000;  		targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  		targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: if (b >= 0)  	targetBuf [targetStart++] = (char)b;  else {  	switch (utf8TypeTable [b & 0xFF]) {  	case BT_LEAD2:  		/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  		break;  	case BT_LEAD3:  		/* 4' 6' 6 */c = (b & 0xF) << 12;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  		c |= (sourceBuf [sourceStart++] & 0x3F);  		targetBuf [targetStart++] = (char)c;  		break;  	case BT_LEAD4:  		/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  		c |= (sourceBuf [sourceStart++] & 0x3F);  		c -= 0x10000;  		targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  		targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: if (b >= 0)  	targetBuf [targetStart++] = (char)b;  else {  	switch (utf8TypeTable [b & 0xFF]) {  	case BT_LEAD2:  		/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  		break;  	case BT_LEAD3:  		/* 4' 6' 6 */c = (b & 0xF) << 12;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  		c |= (sourceBuf [sourceStart++] & 0x3F);  		targetBuf [targetStart++] = (char)c;  		break;  	case BT_LEAD4:  		/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  		c |= (sourceBuf [sourceStart++] & 0x3F);  		c -= 0x10000;  		targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  		targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: if (b >= 0)  	targetBuf [targetStart++] = (char)b;  else {  	switch (utf8TypeTable [b & 0xFF]) {  	case BT_LEAD2:  		/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  		break;  	case BT_LEAD3:  		/* 4' 6' 6 */c = (b & 0xF) << 12;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  		c |= (sourceBuf [sourceStart++] & 0x3F);  		targetBuf [targetStart++] = (char)c;  		break;  	case BT_LEAD4:  		/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  		c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  		c |= (sourceBuf [sourceStart++] & 0x3F);  		c -= 0x10000;  		targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  		targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: switch (utf8TypeTable [b & 0xFF]) {  case BT_LEAD2:  	/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  	break;  case BT_LEAD3:  	/* 4' 6' 6 */c = (b & 0xF) << 12;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  	c |= (sourceBuf [sourceStart++] & 0x3F);  	targetBuf [targetStart++] = (char)c;  	break;  case BT_LEAD4:  	/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  	c |= (sourceBuf [sourceStart++] & 0x3F);  	c -= 0x10000;  	targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  	targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: switch (utf8TypeTable [b & 0xFF]) {  case BT_LEAD2:  	/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  	break;  case BT_LEAD3:  	/* 4' 6' 6 */c = (b & 0xF) << 12;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  	c |= (sourceBuf [sourceStart++] & 0x3F);  	targetBuf [targetStart++] = (char)c;  	break;  case BT_LEAD4:  	/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  	c |= (sourceBuf [sourceStart++] & 0x3F);  	c -= 0x10000;  	targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  	targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: switch (utf8TypeTable [b & 0xFF]) {  case BT_LEAD2:  	/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  	break;  case BT_LEAD3:  	/* 4' 6' 6 */c = (b & 0xF) << 12;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  	c |= (sourceBuf [sourceStart++] & 0x3F);  	targetBuf [targetStart++] = (char)c;  	break;  case BT_LEAD4:  	/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  	c |= (sourceBuf [sourceStart++] & 0x3F);  	c -= 0x10000;  	targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  	targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: switch (utf8TypeTable [b & 0xFF]) {  case BT_LEAD2:  	/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  	break;  case BT_LEAD3:  	/* 4' 6' 6 */c = (b & 0xF) << 12;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  	c |= (sourceBuf [sourceStart++] & 0x3F);  	targetBuf [targetStart++] = (char)c;  	break;  case BT_LEAD4:  	/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  	c |= (sourceBuf [sourceStart++] & 0x3F);  	c -= 0x10000;  	targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  	targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: switch (utf8TypeTable [b & 0xFF]) {  case BT_LEAD2:  	/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  	break;  case BT_LEAD3:  	/* 4' 6' 6 */c = (b & 0xF) << 12;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  	c |= (sourceBuf [sourceStart++] & 0x3F);  	targetBuf [targetStart++] = (char)c;  	break;  case BT_LEAD4:  	/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  	c |= (sourceBuf [sourceStart++] & 0x3F);  	c -= 0x10000;  	targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  	targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: switch (utf8TypeTable [b & 0xFF]) {  case BT_LEAD2:  	/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  	break;  case BT_LEAD3:  	/* 4' 6' 6 */c = (b & 0xF) << 12;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  	c |= (sourceBuf [sourceStart++] & 0x3F);  	targetBuf [targetStart++] = (char)c;  	break;  case BT_LEAD4:  	/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  	c |= (sourceBuf [sourceStart++] & 0x3F);  	c -= 0x10000;  	targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  	targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: switch (utf8TypeTable [b & 0xFF]) {  case BT_LEAD2:  	/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  	break;  case BT_LEAD3:  	/* 4' 6' 6 */c = (b & 0xF) << 12;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  	c |= (sourceBuf [sourceStart++] & 0x3F);  	targetBuf [targetStart++] = (char)c;  	break;  case BT_LEAD4:  	/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  	c |= (sourceBuf [sourceStart++] & 0x3F);  	c -= 0x10000;  	targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  	targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: switch (utf8TypeTable [b & 0xFF]) {  case BT_LEAD2:  	/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  	break;  case BT_LEAD3:  	/* 4' 6' 6 */c = (b & 0xF) << 12;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  	c |= (sourceBuf [sourceStart++] & 0x3F);  	targetBuf [targetStart++] = (char)c;  	break;  case BT_LEAD4:  	/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  	c |= (sourceBuf [sourceStart++] & 0x3F);  	c -= 0x10000;  	targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  	targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: c = (b & 0xF) << 12;  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: c = (b & 0x7) << 18;  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,convert,The following statement contains a magic number: targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: while (off != end) {  	byte b = buf [off];  	if (b >= 0) {  		++off;  		switch (b) {  		case (byte)'\n':  			lineNumber += 1;  			colDiff = off;  			break;  		case (byte)'\r':  			lineNumber += 1;  			if (off != end && buf [off] == '\n')  				off++;  			colDiff = off;  			break;  		}  	} else {  		switch (utf8TypeTable [b & 0xFF]) {  		default:  			off += 1;  			break;  		case BT_LEAD2:  			off += 2;  			colDiff++;  			break;  		case BT_LEAD3:  			off += 3;  			colDiff += 2;  			break;  		case BT_LEAD4:  			off += 4;  			colDiff += 3;  			break;  		}  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: while (off != end) {  	byte b = buf [off];  	if (b >= 0) {  		++off;  		switch (b) {  		case (byte)'\n':  			lineNumber += 1;  			colDiff = off;  			break;  		case (byte)'\r':  			lineNumber += 1;  			if (off != end && buf [off] == '\n')  				off++;  			colDiff = off;  			break;  		}  	} else {  		switch (utf8TypeTable [b & 0xFF]) {  		default:  			off += 1;  			break;  		case BT_LEAD2:  			off += 2;  			colDiff++;  			break;  		case BT_LEAD3:  			off += 3;  			colDiff += 2;  			break;  		case BT_LEAD4:  			off += 4;  			colDiff += 3;  			break;  		}  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: while (off != end) {  	byte b = buf [off];  	if (b >= 0) {  		++off;  		switch (b) {  		case (byte)'\n':  			lineNumber += 1;  			colDiff = off;  			break;  		case (byte)'\r':  			lineNumber += 1;  			if (off != end && buf [off] == '\n')  				off++;  			colDiff = off;  			break;  		}  	} else {  		switch (utf8TypeTable [b & 0xFF]) {  		default:  			off += 1;  			break;  		case BT_LEAD2:  			off += 2;  			colDiff++;  			break;  		case BT_LEAD3:  			off += 3;  			colDiff += 2;  			break;  		case BT_LEAD4:  			off += 4;  			colDiff += 3;  			break;  		}  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: while (off != end) {  	byte b = buf [off];  	if (b >= 0) {  		++off;  		switch (b) {  		case (byte)'\n':  			lineNumber += 1;  			colDiff = off;  			break;  		case (byte)'\r':  			lineNumber += 1;  			if (off != end && buf [off] == '\n')  				off++;  			colDiff = off;  			break;  		}  	} else {  		switch (utf8TypeTable [b & 0xFF]) {  		default:  			off += 1;  			break;  		case BT_LEAD2:  			off += 2;  			colDiff++;  			break;  		case BT_LEAD3:  			off += 3;  			colDiff += 2;  			break;  		case BT_LEAD4:  			off += 4;  			colDiff += 3;  			break;  		}  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: while (off != end) {  	byte b = buf [off];  	if (b >= 0) {  		++off;  		switch (b) {  		case (byte)'\n':  			lineNumber += 1;  			colDiff = off;  			break;  		case (byte)'\r':  			lineNumber += 1;  			if (off != end && buf [off] == '\n')  				off++;  			colDiff = off;  			break;  		}  	} else {  		switch (utf8TypeTable [b & 0xFF]) {  		default:  			off += 1;  			break;  		case BT_LEAD2:  			off += 2;  			colDiff++;  			break;  		case BT_LEAD3:  			off += 3;  			colDiff += 2;  			break;  		case BT_LEAD4:  			off += 4;  			colDiff += 3;  			break;  		}  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: if (b >= 0) {  	++off;  	switch (b) {  	case (byte)'\n':  		lineNumber += 1;  		colDiff = off;  		break;  	case (byte)'\r':  		lineNumber += 1;  		if (off != end && buf [off] == '\n')  			off++;  		colDiff = off;  		break;  	}  } else {  	switch (utf8TypeTable [b & 0xFF]) {  	default:  		off += 1;  		break;  	case BT_LEAD2:  		off += 2;  		colDiff++;  		break;  	case BT_LEAD3:  		off += 3;  		colDiff += 2;  		break;  	case BT_LEAD4:  		off += 4;  		colDiff += 3;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: if (b >= 0) {  	++off;  	switch (b) {  	case (byte)'\n':  		lineNumber += 1;  		colDiff = off;  		break;  	case (byte)'\r':  		lineNumber += 1;  		if (off != end && buf [off] == '\n')  			off++;  		colDiff = off;  		break;  	}  } else {  	switch (utf8TypeTable [b & 0xFF]) {  	default:  		off += 1;  		break;  	case BT_LEAD2:  		off += 2;  		colDiff++;  		break;  	case BT_LEAD3:  		off += 3;  		colDiff += 2;  		break;  	case BT_LEAD4:  		off += 4;  		colDiff += 3;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: if (b >= 0) {  	++off;  	switch (b) {  	case (byte)'\n':  		lineNumber += 1;  		colDiff = off;  		break;  	case (byte)'\r':  		lineNumber += 1;  		if (off != end && buf [off] == '\n')  			off++;  		colDiff = off;  		break;  	}  } else {  	switch (utf8TypeTable [b & 0xFF]) {  	default:  		off += 1;  		break;  	case BT_LEAD2:  		off += 2;  		colDiff++;  		break;  	case BT_LEAD3:  		off += 3;  		colDiff += 2;  		break;  	case BT_LEAD4:  		off += 4;  		colDiff += 3;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: if (b >= 0) {  	++off;  	switch (b) {  	case (byte)'\n':  		lineNumber += 1;  		colDiff = off;  		break;  	case (byte)'\r':  		lineNumber += 1;  		if (off != end && buf [off] == '\n')  			off++;  		colDiff = off;  		break;  	}  } else {  	switch (utf8TypeTable [b & 0xFF]) {  	default:  		off += 1;  		break;  	case BT_LEAD2:  		off += 2;  		colDiff++;  		break;  	case BT_LEAD3:  		off += 3;  		colDiff += 2;  		break;  	case BT_LEAD4:  		off += 4;  		colDiff += 3;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: if (b >= 0) {  	++off;  	switch (b) {  	case (byte)'\n':  		lineNumber += 1;  		colDiff = off;  		break;  	case (byte)'\r':  		lineNumber += 1;  		if (off != end && buf [off] == '\n')  			off++;  		colDiff = off;  		break;  	}  } else {  	switch (utf8TypeTable [b & 0xFF]) {  	default:  		off += 1;  		break;  	case BT_LEAD2:  		off += 2;  		colDiff++;  		break;  	case BT_LEAD3:  		off += 3;  		colDiff += 2;  		break;  	case BT_LEAD4:  		off += 4;  		colDiff += 3;  		break;  	}  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: switch (utf8TypeTable [b & 0xFF]) {  default:  	off += 1;  	break;  case BT_LEAD2:  	off += 2;  	colDiff++;  	break;  case BT_LEAD3:  	off += 3;  	colDiff += 2;  	break;  case BT_LEAD4:  	off += 4;  	colDiff += 3;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: switch (utf8TypeTable [b & 0xFF]) {  default:  	off += 1;  	break;  case BT_LEAD2:  	off += 2;  	colDiff++;  	break;  case BT_LEAD3:  	off += 3;  	colDiff += 2;  	break;  case BT_LEAD4:  	off += 4;  	colDiff += 3;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: switch (utf8TypeTable [b & 0xFF]) {  default:  	off += 1;  	break;  case BT_LEAD2:  	off += 2;  	colDiff++;  	break;  case BT_LEAD3:  	off += 3;  	colDiff += 2;  	break;  case BT_LEAD4:  	off += 4;  	colDiff += 3;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: switch (utf8TypeTable [b & 0xFF]) {  default:  	off += 1;  	break;  case BT_LEAD2:  	off += 2;  	colDiff++;  	break;  case BT_LEAD3:  	off += 3;  	colDiff += 2;  	break;  case BT_LEAD4:  	off += 4;  	colDiff += 3;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: switch (utf8TypeTable [b & 0xFF]) {  default:  	off += 1;  	break;  case BT_LEAD2:  	off += 2;  	colDiff++;  	break;  case BT_LEAD3:  	off += 3;  	colDiff += 2;  	break;  case BT_LEAD4:  	off += 4;  	colDiff += 3;  	break;  }  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: off += 2;  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: off += 3;  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: colDiff += 2;  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: off += 4;  
Magic Number,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,movePosition,The following statement contains a magic number: colDiff += 3;  
Missing Default,agsXMPP.Net,PollClientSocket,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Net\PollClientSocket.cs,PollThread,The following switch statement is missing a default case: switch (id) {  case "0:0":  	// 3.1.1 Unknown Error  	// Server returns ID=0:0.  	// The response body can contain a textual error message.									  	return;  case "-1:0":  	// 3.1.2 Server Error  	// Server returns ID=-1:0  	return;  case "-2:0":  	// 3.1.3 Bad Request  	// Server returns ID=-2:0  	return;  case "-3:0":  	// 3.1.4 Key Sequence Error  	// Server returns ID=-3:0  	return;  }  
Missing Default,agsXMPP.IO.Compression,DeflaterEngine,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\DeflaterEngine.cs,SetLevel,The following switch statement is missing a default case: switch (comprFunc) {  case DEFLATE_STORED:  	if (strstart > blockStart) {  		huffman.FlushStoredBlock (window' blockStart' strstart - blockStart' false);  		blockStart = strstart;  	}  	UpdateHash ();  	break;  case DEFLATE_FAST:  	if (strstart > blockStart) {  		huffman.FlushBlock (window' blockStart' strstart - blockStart' false);  		blockStart = strstart;  	}  	break;  case DEFLATE_SLOW:  	if (prevAvailable) {  		huffman.TallyLit (window [strstart - 1] & 0xff);  	}  	if (strstart > blockStart) {  		huffman.FlushBlock (window' blockStart' strstart - blockStart' false);  		blockStart = strstart;  	}  	prevAvailable = false;  	matchLen = MIN_MATCH - 1;  	break;  }  
Missing Default,agsXMPP.IO.Compression,InflaterDynHeader,D:\newReposJune17\meebey_agsxmpp\agsxmpp\IO\Compression\InflaterDynHeader.cs,Decode,The following switch statement is missing a default case: switch (mode) {  case LNUM:  	lnum = input.PeekBits (5);  	if (lnum < 0) {  		return false;  	}  	lnum += 257;  	input.DropBits (5);  	//  	    System.err.println("LNUM: "+lnum);  	mode = DNUM;  	goto case DNUM;  // fall through  case DNUM:  	dnum = input.PeekBits (5);  	if (dnum < 0) {  		return false;  	}  	dnum++;  	input.DropBits (5);  	//  	    System.err.println("DNUM: "+dnum);  	num = lnum + dnum;  	litdistLens = new byte[num];  	mode = BLNUM;  	goto case BLNUM;  // fall through  case BLNUM:  	blnum = input.PeekBits (4);  	if (blnum < 0) {  		return false;  	}  	blnum += 4;  	input.DropBits (4);  	blLens = new byte[19];  	ptr = 0;  	//  	    System.err.println("BLNUM: "+blnum);  	mode = BLLENS;  	goto case BLLENS;  // fall through  case BLLENS:  	while (ptr < blnum) {  		int len = input.PeekBits (3);  		if (len < 0) {  			return false;  		}  		input.DropBits (3);  		//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  		blLens [BL_ORDER [ptr]] = (byte)len;  		ptr++;  	}  	blTree = new InflaterHuffmanTree (blLens);  	blLens = null;  	ptr = 0;  	mode = LENS;  	goto case LENS;  // fall through  case LENS:  	{  		int symbol;  		while (((symbol = blTree.GetSymbol (input)) & ~15) == 0) {  			/* Normal case: symbol in [0..15] *///  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  			litdistLens [ptr++] = lastLen = (byte)symbol;  			if (ptr == num) {  				/* Finished */return true;  			}  		}  		/* need more input ? */if (symbol < 0) {  			return false;  		}  		/* otherwise repeat code */if (symbol >= 17) {  			/* repeat zero *///  		  System.err.println("repeating zero");  			lastLen = 0;  		} else {  			if (ptr == 0) {  				throw new SharpZipBaseException ();  			}  		}  		repSymbol = symbol - 16;  	}  	mode = REPS;  	goto case REPS;  // fall through  case REPS:  	{  		int bits = repBits [repSymbol];  		int count = input.PeekBits (bits);  		if (count < 0) {  			return false;  		}  		input.DropBits (bits);  		count += repMin [repSymbol];  		//  	      System.err.println("litdistLens repeated: "+count);  		if (ptr + count > num) {  			throw new SharpZipBaseException ();  		}  		while (count-- > 0) {  			litdistLens [ptr++] = lastLen;  		}  		if (ptr == num) {  			/* Finished */return true;  		}  	}  	mode = LENS;  	goto decode_loop;  }  
Missing Default,agsXMPP,Jid,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Jid.cs,UnescapeNode,The following switch statement is missing a default case: switch (c3) {  case '0':  	sb.Append (' ');  	break;  case '2':  	sb.Append ('"');  	break;  case '6':  	sb.Append ('&');  	break;  case '7':  	sb.Append ('\'');  	break;  case 'f':  	sb.Append ('/');  	break;  }  
Missing Default,agsXMPP,Jid,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Jid.cs,UnescapeNode,The following switch statement is missing a default case: switch (c3) {  case 'a':  	sb.Append (':');  	break;  case 'c':  	sb.Append ('<');  	break;  case 'e':  	sb.Append ('>');  	break;  }  
Missing Default,agsXMPP.Sasl.DigestMD5,Step1,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Sasl\DigestMD5\Step1.cs,ParsePair,The following switch statement is missing a default case: switch (key) {  case "realm":  	m_Realm = data;  	break;  case "nonce":  	m_Nonce = data;  	break;  case "qop":  	m_Qop = data;  	break;  case "charset":  	m_Charset = data;  	break;  case "algorithm":  	m_Algorithm = data;  	break;  case "rspauth":  	m_Rspauth = data;  	break;  }  
Missing Default,agsXMPP.Xml,StreamParser,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\StreamParser.cs,Push,The following switch statement is missing a default case: switch (tok) {  case TOK.EMPTY_ELEMENT_NO_ATTS:  case TOK.EMPTY_ELEMENT_WITH_ATTS:  	StartTag (b' off' ct' tok);  	EndTag (b' off' ct' tok);  	break;  case TOK.START_TAG_NO_ATTS:  case TOK.START_TAG_WITH_ATTS:  	StartTag (b' off' ct' tok);  	break;  case TOK.END_TAG:  	EndTag (b' off' ct' tok);  	break;  case TOK.DATA_CHARS:  case TOK.DATA_NEWLINE:  	AddText (utf.GetString (b' off' ct.TokenEnd - off));  	break;  case TOK.CHAR_REF:  case TOK.MAGIC_ENTITY_REF:  	AddText (new string (new char[] {  		ct.RefChar1  	}));  	break;  case TOK.CHAR_PAIR_REF:  	AddText (new string (new char[] {  		ct.RefChar1'  		ct.RefChar2  	}));  	break;  case TOK.COMMENT:  	if (current != null) {  		// <!-- 4  		//  --> 3  		int start = off + 4 * m_enc.MinBytesPerChar;  		int end = ct.TokenEnd - off - 7 * m_enc.MinBytesPerChar;  		string text = utf.GetString (b' start' end);  		current.AddChild (new Comment (text));  	}  	break;  case TOK.CDATA_SECT_OPEN:  	m_cdata = true;  	break;  case TOK.CDATA_SECT_CLOSE:  	m_cdata = false;  	break;  case TOK.XML_DECL:  	// thou shalt use UTF8' and XML version 1.  	// i shall ignore evidence to the contrary...  	// TODO: Throw an exception if these assuptions are  	// wrong  	break;  case TOK.ENTITY_REF:  case TOK.PI:  	#if CF  						    throw new util.NotImplementedException("Token type not implemented: " + tok); #else  	throw new System.NotImplementedException ("Token type not implemented: " + tok);  #endif  }  
Missing Default,agsXMPP.Xml,StreamParser,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\StreamParser.cs,NormalizeAttributeValue,The following switch statement is missing a default case: switch (tok) {  case TOK.ATTRIBUTE_VALUE_S:  case TOK.DATA_CHARS:  case TOK.DATA_NEWLINE:  	val += (utf.GetString (b' off' ct.TokenEnd - off));  	break;  case TOK.CHAR_REF:  case TOK.MAGIC_ENTITY_REF:  	val += new string (new char[] {  		ct.RefChar1  	});  	break;  case TOK.CHAR_PAIR_REF:  	val += new string (new char[] {  		ct.RefChar1'  		ct.RefChar2  	});  	break;  case TOK.ENTITY_REF:  	#if CF  							    throw new util.NotImplementedException("Token type not implemented: " + tok); #else  	throw new System.NotImplementedException ("Token type not implemented: " + tok);  #endif  }  
Missing Default,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,getEncoding,The following switch statement is missing a default case: switch (enc) {  case UTF8_ENCODING:  	if (utf8Encoding == null)  		utf8Encoding = new UTF8Encoding ();  	return utf8Encoding;  /*             case UTF16_LITTLE_ENDIAN_ENCODING:                 if (utf16LittleEndianEncoding == null)                     utf16LittleEndianEncoding = new UTF16LittleEndianEncoding();                 return utf16LittleEndianEncoding;             case UTF16_BIG_ENDIAN_ENCODING:                 if (utf16BigEndianEncoding == null)                     utf16BigEndianEncoding = new UTF16BigEndianEncoding();                 return utf16BigEndianEncoding;             case INTERNAL_ENCODING:                 if (internalEncoding == null)                     internalEncoding = new InternalEncoding();                 return internalEncoding;             case ISO8859_1_ENCODING:                 if (iso8859_1Encoding == null)                     iso8859_1Encoding = new ISO8859_1Encoding();                 return iso8859_1Encoding;             case ASCII_ENCODING:                 if (asciiEncoding == null)                     asciiEncoding = new ASCIIEncoding();                 return asciiEncoding;                 */}  
Missing Default,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanDecl,The following switch statement is missing a default case: switch (byteType (buf' off + minBPC)) {  case BT_S:  case BT_CR:  case BT_LF:  case BT_PERCNT:  	throw new InvalidTokenException (off);  }  
Missing Default,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,setRefChar,The following switch statement is missing a default case: switch (charTypeTable [num >> 8] [num & 0xFF]) {  case BT_NONXML:  case BT_LEAD4:  case BT_MALFORM:  	throw new InvalidTokenException (token.TokenEnd - minBPC);  }  
Missing Default,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following switch statement is missing a default case: switch (byteToAscii (buf' off)) {  case 'a':  	if (end - off < minBPC * 4)  		break;  	switch (byteToAscii (buf' off + minBPC)) {  	case 'm':  		if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  			token.TokenEnd = off + minBPC * 4;  			token.RefChar1 = '&';  			return true;  		}  		break;  	case 'p':  		if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  			token.TokenEnd = off + minBPC * 5;  			token.RefChar1 = '\'';  			return true;  		}  		break;  	}  	break;  case 'l':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '<';  		return true;  	}  	break;  case 'g':  	if (end - off >= minBPC * 3 && charMatches (buf' off + minBPC' 't') && charMatches (buf' off + minBPC * 2' ';')) {  		token.TokenEnd = off + minBPC * 3;  		token.RefChar1 = '>';  		return true;  	}  	break;  case 'q':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC' 'u') && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 't') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '"';  		return true;  	}  	break;  }  
Missing Default,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,isMagicEntityRef,The following switch statement is missing a default case: switch (byteToAscii (buf' off + minBPC)) {  case 'm':  	if (charMatches (buf' off + minBPC * 2' 'p') && charMatches (buf' off + minBPC * 3' ';')) {  		token.TokenEnd = off + minBPC * 4;  		token.RefChar1 = '&';  		return true;  	}  	break;  case 'p':  	if (end - off >= minBPC * 5 && charMatches (buf' off + minBPC * 2' 'o') && charMatches (buf' off + minBPC * 3' 's') && charMatches (buf' off + minBPC * 4' ';')) {  		token.TokenEnd = off + minBPC * 5;  		token.RefChar1 = '\'';  		return true;  	}  	break;  }  
Missing Default,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,scanLt,The following switch statement is missing a default case: switch (byteType (buf' off)) {  case BT_MINUS:  	return scanComment (buf' off + minBPC' end' token);  case BT_LSQB:  	return scanCdataSection (buf' off + minBPC' end' token);  }  
Missing Default,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,getInitialEncoding,The following switch statement is missing a default case: switch ((b0 << 8) | b1) {  case 0xFEFF:  	token.TokenEnd = off + 2;  	/* fall through */goto case '<';  case '<':  	/* not legal; but not a fatal error */return getEncoding (UTF16_BIG_ENDIAN_ENCODING);  case 0xFFFE:  	token.TokenEnd = off + 2;  	/* fall through */goto case '<' << 8;  case '<' << 8:  	/* not legal; but not a fatal error */return getEncoding (UTF16_LITTLE_ENDIAN_ENCODING);  }  
Missing Default,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,getEncoding,The following switch statement is missing a default case: switch (name.ToUpper ()) {  case "UTF-8":  	return getEncoding (UTF8_ENCODING);  /*             case "UTF-16":                 return getUTF16Encoding();             case "ISO-8859-1":                 return getEncoding(ISO8859_1_ENCODING);             case "US-ASCII":                 return getEncoding(ASCII_ENCODING);                 */}  
Missing Default,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following switch statement is missing a default case: switch (byteType (buf' off)) {  case BT_EXCL:  	return scanDecl (buf' off + minBPC' end' token);  case BT_QUEST:  	return scanPi (buf' off + minBPC' end' token);  case BT_NMSTRT:  case BT_LEAD2:  case BT_LEAD3:  case BT_LEAD4:  	token.TokenEnd = off - minBPC;  	throw new EndOfPrologException ();  }  
Missing Default,agsXMPP.Xml.Xpnet,Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\Encoding.cs,tokenizeProlog,The following switch statement is missing a default case: switch (byteType (buf' off)) {  case BT_AST:  	token.TokenEnd = off + minBPC;  	return TOK.CLOSE_PAREN_ASTERISK;  case BT_QUEST:  	token.TokenEnd = off + minBPC;  	return TOK.CLOSE_PAREN_QUESTION;  case BT_PLUS:  	token.TokenEnd = off + minBPC;  	return TOK.CLOSE_PAREN_PLUS;  case BT_CR:  case BT_LF:  case BT_S:  case BT_GT:  case BT_COMMA:  case BT_VERBAR:  case BT_RPAR:  	token.TokenEnd = off;  	return TOK.CLOSE_PAREN;  }  
Missing Default,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,convert,The following switch statement is missing a default case: switch (utf8TypeTable [b & 0xFF]) {  case BT_LEAD2:  	/* 5' 6 */targetBuf [targetStart++] = (char)(((b & 0x1F) << 6) | (sourceBuf [sourceStart++] & 0x3F));  	break;  case BT_LEAD3:  	/* 4' 6' 6 */c = (b & 0xF) << 12;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  	c |= (sourceBuf [sourceStart++] & 0x3F);  	targetBuf [targetStart++] = (char)c;  	break;  case BT_LEAD4:  	/* 3' 6' 6' 6 */c = (b & 0x7) << 18;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 12;  	c |= (sourceBuf [sourceStart++] & 0x3F) << 6;  	c |= (sourceBuf [sourceStart++] & 0x3F);  	c -= 0x10000;  	targetBuf [targetStart++] = (char)((c >> 10) | 0xD800);  	targetBuf [targetStart++] = (char)((c & ((1 << 10) - 1)) | 0xDC00);  	break;  }  
Missing Default,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,movePosition,The following switch statement is missing a default case: switch (b) {  case (byte)'\n':  	lineNumber += 1;  	colDiff = off;  	break;  case (byte)'\r':  	lineNumber += 1;  	if (off != end && buf [off] == '\n')  		off++;  	colDiff = off;  	break;  }  
Missing Default,agsXMPP.Xml.Xpnet,UTF8Encoding,D:\newReposJune17\meebey_agsxmpp\agsxmpp\Xml\Xpnet\UTF8Encoding.cs,extendData,The following switch statement is missing a default case: switch (type) {  case BT_LEAD3:  	check3 (buf' off);  	break;  case BT_LEAD4:  	check4 (buf' off);  	break;  }  
